open Aws.BaseTypes

type calendar = CalendarLib.Calendar.t

module TargetValues = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module InventoryDeletionSummaryItem = struct
  type t =
    { version : String.t option
    ; count : Integer.t option
    ; remaining_count : Integer.t option
    }

  let make ?version ?count ?remaining_count () = { version; count; remaining_count }

  let parse xml =
    Some
      { version = Aws.Util.option_bind (Aws.Xml.member "Version" xml) String.parse
      ; count = Aws.Util.option_bind (Aws.Xml.member "Count" xml) Integer.parse
      ; remaining_count =
          Aws.Util.option_bind (Aws.Xml.member "RemainingCount" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.remaining_count (fun f ->
               Aws.Query.Pair ("RemainingCount", Integer.to_query f))
         ; Aws.Util.option_map v.count (fun f ->
               Aws.Query.Pair ("Count", Integer.to_query f))
         ; Aws.Util.option_map v.version (fun f ->
               Aws.Query.Pair ("Version", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.remaining_count (fun f ->
               "RemainingCount", Integer.to_json f)
         ; Aws.Util.option_map v.count (fun f -> "Count", Integer.to_json f)
         ; Aws.Util.option_map v.version (fun f -> "Version", String.to_json f)
         ])

  let of_json j =
    { version = Aws.Util.option_map (Aws.Json.lookup j "Version") String.of_json
    ; count = Aws.Util.option_map (Aws.Json.lookup j "Count") Integer.of_json
    ; remaining_count =
        Aws.Util.option_map (Aws.Json.lookup j "RemainingCount") Integer.of_json
    }
end

module OperatingSystem = struct
  type t =
    | WINDOWS
    | AMAZON_LINUX
    | AMAZON_LINUX_2
    | UBUNTU
    | REDHAT_ENTERPRISE_LINUX
    | SUSE
    | CENTOS
    | ORACLE_LINUX
    | DEBIAN

  let str_to_t =
    [ "DEBIAN", DEBIAN
    ; "ORACLE_LINUX", ORACLE_LINUX
    ; "CENTOS", CENTOS
    ; "SUSE", SUSE
    ; "REDHAT_ENTERPRISE_LINUX", REDHAT_ENTERPRISE_LINUX
    ; "UBUNTU", UBUNTU
    ; "AMAZON_LINUX_2", AMAZON_LINUX_2
    ; "AMAZON_LINUX", AMAZON_LINUX
    ; "WINDOWS", WINDOWS
    ]

  let t_to_str =
    [ DEBIAN, "DEBIAN"
    ; ORACLE_LINUX, "ORACLE_LINUX"
    ; CENTOS, "CENTOS"
    ; SUSE, "SUSE"
    ; REDHAT_ENTERPRISE_LINUX, "REDHAT_ENTERPRISE_LINUX"
    ; UBUNTU, "UBUNTU"
    ; AMAZON_LINUX_2, "AMAZON_LINUX_2"
    ; AMAZON_LINUX, "AMAZON_LINUX"
    ; WINDOWS, "WINDOWS"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module GetDefaultPatchBaselineResult = struct
  type t =
    { baseline_id : String.t option
    ; operating_system : OperatingSystem.t option
    }

  let make ?baseline_id ?operating_system () = { baseline_id; operating_system }

  let parse xml =
    Some
      { baseline_id = Aws.Util.option_bind (Aws.Xml.member "BaselineId" xml) String.parse
      ; operating_system =
          Aws.Util.option_bind
            (Aws.Xml.member "OperatingSystem" xml)
            OperatingSystem.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.operating_system (fun f ->
               Aws.Query.Pair ("OperatingSystem", OperatingSystem.to_query f))
         ; Aws.Util.option_map v.baseline_id (fun f ->
               Aws.Query.Pair ("BaselineId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.operating_system (fun f ->
               "OperatingSystem", OperatingSystem.to_json f)
         ; Aws.Util.option_map v.baseline_id (fun f -> "BaselineId", String.to_json f)
         ])

  let of_json j =
    { baseline_id = Aws.Util.option_map (Aws.Json.lookup j "BaselineId") String.of_json
    ; operating_system =
        Aws.Util.option_map (Aws.Json.lookup j "OperatingSystem") OperatingSystem.of_json
    }
end

module PatchBaselineIdentity = struct
  type t =
    { baseline_id : String.t option
    ; baseline_name : String.t option
    ; operating_system : OperatingSystem.t option
    ; baseline_description : String.t option
    ; default_baseline : Boolean.t option
    }

  let make
      ?baseline_id
      ?baseline_name
      ?operating_system
      ?baseline_description
      ?default_baseline
      () =
    { baseline_id
    ; baseline_name
    ; operating_system
    ; baseline_description
    ; default_baseline
    }

  let parse xml =
    Some
      { baseline_id = Aws.Util.option_bind (Aws.Xml.member "BaselineId" xml) String.parse
      ; baseline_name =
          Aws.Util.option_bind (Aws.Xml.member "BaselineName" xml) String.parse
      ; operating_system =
          Aws.Util.option_bind
            (Aws.Xml.member "OperatingSystem" xml)
            OperatingSystem.parse
      ; baseline_description =
          Aws.Util.option_bind (Aws.Xml.member "BaselineDescription" xml) String.parse
      ; default_baseline =
          Aws.Util.option_bind (Aws.Xml.member "DefaultBaseline" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.default_baseline (fun f ->
               Aws.Query.Pair ("DefaultBaseline", Boolean.to_query f))
         ; Aws.Util.option_map v.baseline_description (fun f ->
               Aws.Query.Pair ("BaselineDescription", String.to_query f))
         ; Aws.Util.option_map v.operating_system (fun f ->
               Aws.Query.Pair ("OperatingSystem", OperatingSystem.to_query f))
         ; Aws.Util.option_map v.baseline_name (fun f ->
               Aws.Query.Pair ("BaselineName", String.to_query f))
         ; Aws.Util.option_map v.baseline_id (fun f ->
               Aws.Query.Pair ("BaselineId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.default_baseline (fun f ->
               "DefaultBaseline", Boolean.to_json f)
         ; Aws.Util.option_map v.baseline_description (fun f ->
               "BaselineDescription", String.to_json f)
         ; Aws.Util.option_map v.operating_system (fun f ->
               "OperatingSystem", OperatingSystem.to_json f)
         ; Aws.Util.option_map v.baseline_name (fun f -> "BaselineName", String.to_json f)
         ; Aws.Util.option_map v.baseline_id (fun f -> "BaselineId", String.to_json f)
         ])

  let of_json j =
    { baseline_id = Aws.Util.option_map (Aws.Json.lookup j "BaselineId") String.of_json
    ; baseline_name =
        Aws.Util.option_map (Aws.Json.lookup j "BaselineName") String.of_json
    ; operating_system =
        Aws.Util.option_map (Aws.Json.lookup j "OperatingSystem") OperatingSystem.of_json
    ; baseline_description =
        Aws.Util.option_map (Aws.Json.lookup j "BaselineDescription") String.of_json
    ; default_baseline =
        Aws.Util.option_map (Aws.Json.lookup j "DefaultBaseline") Boolean.of_json
    }
end

module PatchGroupPatchBaselineMapping = struct
  type t =
    { patch_group : String.t option
    ; baseline_identity : PatchBaselineIdentity.t option
    }

  let make ?patch_group ?baseline_identity () = { patch_group; baseline_identity }

  let parse xml =
    Some
      { patch_group = Aws.Util.option_bind (Aws.Xml.member "PatchGroup" xml) String.parse
      ; baseline_identity =
          Aws.Util.option_bind
            (Aws.Xml.member "BaselineIdentity" xml)
            PatchBaselineIdentity.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.baseline_identity (fun f ->
               Aws.Query.Pair ("BaselineIdentity", PatchBaselineIdentity.to_query f))
         ; Aws.Util.option_map v.patch_group (fun f ->
               Aws.Query.Pair ("PatchGroup", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.baseline_identity (fun f ->
               "BaselineIdentity", PatchBaselineIdentity.to_json f)
         ; Aws.Util.option_map v.patch_group (fun f -> "PatchGroup", String.to_json f)
         ])

  let of_json j =
    { patch_group = Aws.Util.option_map (Aws.Json.lookup j "PatchGroup") String.of_json
    ; baseline_identity =
        Aws.Util.option_map
          (Aws.Json.lookup j "BaselineIdentity")
          PatchBaselineIdentity.of_json
    }
end

module PatchGroupPatchBaselineMappingList = struct
  type t = PatchGroupPatchBaselineMapping.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map PatchGroupPatchBaselineMapping.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list PatchGroupPatchBaselineMapping.to_query v
  let to_json v = `List (List.map PatchGroupPatchBaselineMapping.to_json v)
  let of_json j = Aws.Json.to_list PatchGroupPatchBaselineMapping.of_json j
end

module DescribePatchGroupsResult = struct
  type t =
    { mappings : PatchGroupPatchBaselineMappingList.t
    ; next_token : String.t option
    }

  let make ?(mappings = []) ?next_token () = { mappings; next_token }

  let parse xml =
    Some
      { mappings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Mappings" xml)
               PatchGroupPatchBaselineMappingList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Mappings.member", PatchGroupPatchBaselineMappingList.to_query v.mappings))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Mappings", PatchGroupPatchBaselineMappingList.to_json v.mappings)
         ])

  let of_json j =
    { mappings =
        PatchGroupPatchBaselineMappingList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Mappings"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module RegisterDefaultPatchBaselineRequest = struct
  type t = { baseline_id : String.t }

  let make ~baseline_id () = { baseline_id }

  let parse xml =
    Some
      { baseline_id =
          Aws.Xml.required
            "BaselineId"
            (Aws.Util.option_bind (Aws.Xml.member "BaselineId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("BaselineId", String.to_query v.baseline_id)) ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt [ Some ("BaselineId", String.to_json v.baseline_id) ])

  let of_json j =
    { baseline_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "BaselineId"))
    }
end

module GetConnectionStatusRequest = struct
  type t = { target : String.t }

  let make ~target () = { target }

  let parse xml =
    Some
      { target =
          Aws.Xml.required
            "Target"
            (Aws.Util.option_bind (Aws.Xml.member "Target" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Target", String.to_query v.target)) ])

  let to_json v =
    `Assoc (Aws.Util.list_filter_opt [ Some ("Target", String.to_json v.target) ])

  let of_json j =
    { target = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Target")) }
end

module Target = struct
  type t =
    { key : String.t option
    ; values : TargetValues.t
    }

  let make ?key ?(values = []) () = { key; values }

  let parse xml =
    Some
      { key = Aws.Util.option_bind (Aws.Xml.member "Key" xml) String.parse
      ; values =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Values" xml) TargetValues.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Values.member", TargetValues.to_query v.values))
         ; Aws.Util.option_map v.key (fun f -> Aws.Query.Pair ("Key", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Values", TargetValues.to_json v.values)
         ; Aws.Util.option_map v.key (fun f -> "Key", String.to_json f)
         ])

  let of_json j =
    { key = Aws.Util.option_map (Aws.Json.lookup j "Key") String.of_json
    ; values = TargetValues.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Values"))
    }
end

module ParameterValueList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module CommandInvocationStatus = struct
  type t =
    | Pending
    | InProgress
    | Delayed
    | Success
    | Cancelled
    | TimedOut
    | Failed
    | Cancelling

  let str_to_t =
    [ "Cancelling", Cancelling
    ; "Failed", Failed
    ; "TimedOut", TimedOut
    ; "Cancelled", Cancelled
    ; "Success", Success
    ; "Delayed", Delayed
    ; "InProgress", InProgress
    ; "Pending", Pending
    ]

  let t_to_str =
    [ Cancelling, "Cancelling"
    ; Failed, "Failed"
    ; TimedOut, "TimedOut"
    ; Cancelled, "Cancelled"
    ; Success, "Success"
    ; Delayed, "Delayed"
    ; InProgress, "InProgress"
    ; Pending, "Pending"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module CloudWatchOutputConfig = struct
  type t =
    { cloud_watch_log_group_name : String.t option
    ; cloud_watch_output_enabled : Boolean.t option
    }

  let make ?cloud_watch_log_group_name ?cloud_watch_output_enabled () =
    { cloud_watch_log_group_name; cloud_watch_output_enabled }

  let parse xml =
    Some
      { cloud_watch_log_group_name =
          Aws.Util.option_bind (Aws.Xml.member "CloudWatchLogGroupName" xml) String.parse
      ; cloud_watch_output_enabled =
          Aws.Util.option_bind
            (Aws.Xml.member "CloudWatchOutputEnabled" xml)
            Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cloud_watch_output_enabled (fun f ->
               Aws.Query.Pair ("CloudWatchOutputEnabled", Boolean.to_query f))
         ; Aws.Util.option_map v.cloud_watch_log_group_name (fun f ->
               Aws.Query.Pair ("CloudWatchLogGroupName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cloud_watch_output_enabled (fun f ->
               "CloudWatchOutputEnabled", Boolean.to_json f)
         ; Aws.Util.option_map v.cloud_watch_log_group_name (fun f ->
               "CloudWatchLogGroupName", String.to_json f)
         ])

  let of_json j =
    { cloud_watch_log_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "CloudWatchLogGroupName") String.of_json
    ; cloud_watch_output_enabled =
        Aws.Util.option_map (Aws.Json.lookup j "CloudWatchOutputEnabled") Boolean.of_json
    }
end

module GetCommandInvocationResult = struct
  type t =
    { command_id : String.t option
    ; instance_id : String.t option
    ; comment : String.t option
    ; document_name : String.t option
    ; document_version : String.t option
    ; plugin_name : String.t option
    ; response_code : Integer.t option
    ; execution_start_date_time : String.t option
    ; execution_elapsed_time : String.t option
    ; execution_end_date_time : String.t option
    ; status : CommandInvocationStatus.t option
    ; status_details : String.t option
    ; standard_output_content : String.t option
    ; standard_output_url : String.t option
    ; standard_error_content : String.t option
    ; standard_error_url : String.t option
    ; cloud_watch_output_config : CloudWatchOutputConfig.t option
    }

  let make
      ?command_id
      ?instance_id
      ?comment
      ?document_name
      ?document_version
      ?plugin_name
      ?response_code
      ?execution_start_date_time
      ?execution_elapsed_time
      ?execution_end_date_time
      ?status
      ?status_details
      ?standard_output_content
      ?standard_output_url
      ?standard_error_content
      ?standard_error_url
      ?cloud_watch_output_config
      () =
    { command_id
    ; instance_id
    ; comment
    ; document_name
    ; document_version
    ; plugin_name
    ; response_code
    ; execution_start_date_time
    ; execution_elapsed_time
    ; execution_end_date_time
    ; status
    ; status_details
    ; standard_output_content
    ; standard_output_url
    ; standard_error_content
    ; standard_error_url
    ; cloud_watch_output_config
    }

  let parse xml =
    Some
      { command_id = Aws.Util.option_bind (Aws.Xml.member "CommandId" xml) String.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse
      ; comment = Aws.Util.option_bind (Aws.Xml.member "Comment" xml) String.parse
      ; document_name =
          Aws.Util.option_bind (Aws.Xml.member "DocumentName" xml) String.parse
      ; document_version =
          Aws.Util.option_bind (Aws.Xml.member "DocumentVersion" xml) String.parse
      ; plugin_name = Aws.Util.option_bind (Aws.Xml.member "PluginName" xml) String.parse
      ; response_code =
          Aws.Util.option_bind (Aws.Xml.member "ResponseCode" xml) Integer.parse
      ; execution_start_date_time =
          Aws.Util.option_bind (Aws.Xml.member "ExecutionStartDateTime" xml) String.parse
      ; execution_elapsed_time =
          Aws.Util.option_bind (Aws.Xml.member "ExecutionElapsedTime" xml) String.parse
      ; execution_end_date_time =
          Aws.Util.option_bind (Aws.Xml.member "ExecutionEndDateTime" xml) String.parse
      ; status =
          Aws.Util.option_bind (Aws.Xml.member "Status" xml) CommandInvocationStatus.parse
      ; status_details =
          Aws.Util.option_bind (Aws.Xml.member "StatusDetails" xml) String.parse
      ; standard_output_content =
          Aws.Util.option_bind (Aws.Xml.member "StandardOutputContent" xml) String.parse
      ; standard_output_url =
          Aws.Util.option_bind (Aws.Xml.member "StandardOutputUrl" xml) String.parse
      ; standard_error_content =
          Aws.Util.option_bind (Aws.Xml.member "StandardErrorContent" xml) String.parse
      ; standard_error_url =
          Aws.Util.option_bind (Aws.Xml.member "StandardErrorUrl" xml) String.parse
      ; cloud_watch_output_config =
          Aws.Util.option_bind
            (Aws.Xml.member "CloudWatchOutputConfig" xml)
            CloudWatchOutputConfig.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cloud_watch_output_config (fun f ->
               Aws.Query.Pair ("CloudWatchOutputConfig", CloudWatchOutputConfig.to_query f))
         ; Aws.Util.option_map v.standard_error_url (fun f ->
               Aws.Query.Pair ("StandardErrorUrl", String.to_query f))
         ; Aws.Util.option_map v.standard_error_content (fun f ->
               Aws.Query.Pair ("StandardErrorContent", String.to_query f))
         ; Aws.Util.option_map v.standard_output_url (fun f ->
               Aws.Query.Pair ("StandardOutputUrl", String.to_query f))
         ; Aws.Util.option_map v.standard_output_content (fun f ->
               Aws.Query.Pair ("StandardOutputContent", String.to_query f))
         ; Aws.Util.option_map v.status_details (fun f ->
               Aws.Query.Pair ("StatusDetails", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", CommandInvocationStatus.to_query f))
         ; Aws.Util.option_map v.execution_end_date_time (fun f ->
               Aws.Query.Pair ("ExecutionEndDateTime", String.to_query f))
         ; Aws.Util.option_map v.execution_elapsed_time (fun f ->
               Aws.Query.Pair ("ExecutionElapsedTime", String.to_query f))
         ; Aws.Util.option_map v.execution_start_date_time (fun f ->
               Aws.Query.Pair ("ExecutionStartDateTime", String.to_query f))
         ; Aws.Util.option_map v.response_code (fun f ->
               Aws.Query.Pair ("ResponseCode", Integer.to_query f))
         ; Aws.Util.option_map v.plugin_name (fun f ->
               Aws.Query.Pair ("PluginName", String.to_query f))
         ; Aws.Util.option_map v.document_version (fun f ->
               Aws.Query.Pair ("DocumentVersion", String.to_query f))
         ; Aws.Util.option_map v.document_name (fun f ->
               Aws.Query.Pair ("DocumentName", String.to_query f))
         ; Aws.Util.option_map v.comment (fun f ->
               Aws.Query.Pair ("Comment", String.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.command_id (fun f ->
               Aws.Query.Pair ("CommandId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cloud_watch_output_config (fun f ->
               "CloudWatchOutputConfig", CloudWatchOutputConfig.to_json f)
         ; Aws.Util.option_map v.standard_error_url (fun f ->
               "StandardErrorUrl", String.to_json f)
         ; Aws.Util.option_map v.standard_error_content (fun f ->
               "StandardErrorContent", String.to_json f)
         ; Aws.Util.option_map v.standard_output_url (fun f ->
               "StandardOutputUrl", String.to_json f)
         ; Aws.Util.option_map v.standard_output_content (fun f ->
               "StandardOutputContent", String.to_json f)
         ; Aws.Util.option_map v.status_details (fun f ->
               "StatusDetails", String.to_json f)
         ; Aws.Util.option_map v.status (fun f ->
               "Status", CommandInvocationStatus.to_json f)
         ; Aws.Util.option_map v.execution_end_date_time (fun f ->
               "ExecutionEndDateTime", String.to_json f)
         ; Aws.Util.option_map v.execution_elapsed_time (fun f ->
               "ExecutionElapsedTime", String.to_json f)
         ; Aws.Util.option_map v.execution_start_date_time (fun f ->
               "ExecutionStartDateTime", String.to_json f)
         ; Aws.Util.option_map v.response_code (fun f ->
               "ResponseCode", Integer.to_json f)
         ; Aws.Util.option_map v.plugin_name (fun f -> "PluginName", String.to_json f)
         ; Aws.Util.option_map v.document_version (fun f ->
               "DocumentVersion", String.to_json f)
         ; Aws.Util.option_map v.document_name (fun f -> "DocumentName", String.to_json f)
         ; Aws.Util.option_map v.comment (fun f -> "Comment", String.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "InstanceId", String.to_json f)
         ; Aws.Util.option_map v.command_id (fun f -> "CommandId", String.to_json f)
         ])

  let of_json j =
    { command_id = Aws.Util.option_map (Aws.Json.lookup j "CommandId") String.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "InstanceId") String.of_json
    ; comment = Aws.Util.option_map (Aws.Json.lookup j "Comment") String.of_json
    ; document_name =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentName") String.of_json
    ; document_version =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentVersion") String.of_json
    ; plugin_name = Aws.Util.option_map (Aws.Json.lookup j "PluginName") String.of_json
    ; response_code =
        Aws.Util.option_map (Aws.Json.lookup j "ResponseCode") Integer.of_json
    ; execution_start_date_time =
        Aws.Util.option_map (Aws.Json.lookup j "ExecutionStartDateTime") String.of_json
    ; execution_elapsed_time =
        Aws.Util.option_map (Aws.Json.lookup j "ExecutionElapsedTime") String.of_json
    ; execution_end_date_time =
        Aws.Util.option_map (Aws.Json.lookup j "ExecutionEndDateTime") String.of_json
    ; status =
        Aws.Util.option_map (Aws.Json.lookup j "Status") CommandInvocationStatus.of_json
    ; status_details =
        Aws.Util.option_map (Aws.Json.lookup j "StatusDetails") String.of_json
    ; standard_output_content =
        Aws.Util.option_map (Aws.Json.lookup j "StandardOutputContent") String.of_json
    ; standard_output_url =
        Aws.Util.option_map (Aws.Json.lookup j "StandardOutputUrl") String.of_json
    ; standard_error_content =
        Aws.Util.option_map (Aws.Json.lookup j "StandardErrorContent") String.of_json
    ; standard_error_url =
        Aws.Util.option_map (Aws.Json.lookup j "StandardErrorUrl") String.of_json
    ; cloud_watch_output_config =
        Aws.Util.option_map
          (Aws.Json.lookup j "CloudWatchOutputConfig")
          CloudWatchOutputConfig.of_json
    }
end

module ParametersFilterKey = struct
  type t =
    | Name
    | Type
    | KeyId

  let str_to_t = [ "KeyId", KeyId; "Type", Type; "Name", Name ]
  let t_to_str = [ KeyId, "KeyId"; Type, "Type"; Name, "Name" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module MaintenanceWindowExecutionStatus = struct
  type t =
    | PENDING
    | IN_PROGRESS
    | SUCCESS
    | FAILED
    | TIMED_OUT
    | CANCELLING
    | CANCELLED
    | SKIPPED_OVERLAPPING

  let str_to_t =
    [ "SKIPPED_OVERLAPPING", SKIPPED_OVERLAPPING
    ; "CANCELLED", CANCELLED
    ; "CANCELLING", CANCELLING
    ; "TIMED_OUT", TIMED_OUT
    ; "FAILED", FAILED
    ; "SUCCESS", SUCCESS
    ; "IN_PROGRESS", IN_PROGRESS
    ; "PENDING", PENDING
    ]

  let t_to_str =
    [ SKIPPED_OVERLAPPING, "SKIPPED_OVERLAPPING"
    ; CANCELLED, "CANCELLED"
    ; CANCELLING, "CANCELLING"
    ; TIMED_OUT, "TIMED_OUT"
    ; FAILED, "FAILED"
    ; SUCCESS, "SUCCESS"
    ; IN_PROGRESS, "IN_PROGRESS"
    ; PENDING, "PENDING"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module InvalidDocumentContent = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module InvalidAssociation = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module AttachmentsSourceValues = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module AttachmentsSourceKey = struct
  type t =
    | SourceUrl
    | S3FileUrl
    | AttachmentReference

  let str_to_t =
    [ "AttachmentReference", AttachmentReference
    ; "S3FileUrl", S3FileUrl
    ; "SourceUrl", SourceUrl
    ]

  let t_to_str =
    [ AttachmentReference, "AttachmentReference"
    ; S3FileUrl, "S3FileUrl"
    ; SourceUrl, "SourceUrl"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module AttachmentsSource = struct
  type t =
    { key : AttachmentsSourceKey.t option
    ; values : AttachmentsSourceValues.t
    ; name : String.t option
    }

  let make ?key ?(values = []) ?name () = { key; values; name }

  let parse xml =
    Some
      { key = Aws.Util.option_bind (Aws.Xml.member "Key" xml) AttachmentsSourceKey.parse
      ; values =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Values" xml)
               AttachmentsSourceValues.parse)
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Some
             (Aws.Query.Pair ("Values.member", AttachmentsSourceValues.to_query v.values))
         ; Aws.Util.option_map v.key (fun f ->
               Aws.Query.Pair ("Key", AttachmentsSourceKey.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Some ("Values", AttachmentsSourceValues.to_json v.values)
         ; Aws.Util.option_map v.key (fun f -> "Key", AttachmentsSourceKey.to_json f)
         ])

  let of_json j =
    { key = Aws.Util.option_map (Aws.Json.lookup j "Key") AttachmentsSourceKey.of_json
    ; values =
        AttachmentsSourceValues.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Values"))
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    }
end

module AttachmentsSourceList = struct
  type t = AttachmentsSource.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map AttachmentsSource.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list AttachmentsSource.to_query v
  let to_json v = `List (List.map AttachmentsSource.to_json v)
  let of_json j = Aws.Json.to_list AttachmentsSource.of_json j
end

module InvalidOutputLocation = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module DocumentKeyValuesFilterValues = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module AttachmentHashType = struct
  type t = Sha256

  let str_to_t = [ "Sha256", Sha256 ]
  let t_to_str = [ Sha256, "Sha256" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module AttachmentContent = struct
  type t =
    { name : String.t option
    ; size : Long.t option
    ; hash : String.t option
    ; hash_type : AttachmentHashType.t option
    ; url : String.t option
    }

  let make ?name ?size ?hash ?hash_type ?url () = { name; size; hash; hash_type; url }

  let parse xml =
    Some
      { name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; size = Aws.Util.option_bind (Aws.Xml.member "Size" xml) Long.parse
      ; hash = Aws.Util.option_bind (Aws.Xml.member "Hash" xml) String.parse
      ; hash_type =
          Aws.Util.option_bind (Aws.Xml.member "HashType" xml) AttachmentHashType.parse
      ; url = Aws.Util.option_bind (Aws.Xml.member "Url" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.url (fun f -> Aws.Query.Pair ("Url", String.to_query f))
         ; Aws.Util.option_map v.hash_type (fun f ->
               Aws.Query.Pair ("HashType", AttachmentHashType.to_query f))
         ; Aws.Util.option_map v.hash (fun f ->
               Aws.Query.Pair ("Hash", String.to_query f))
         ; Aws.Util.option_map v.size (fun f -> Aws.Query.Pair ("Size", Long.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.url (fun f -> "Url", String.to_json f)
         ; Aws.Util.option_map v.hash_type (fun f ->
               "HashType", AttachmentHashType.to_json f)
         ; Aws.Util.option_map v.hash (fun f -> "Hash", String.to_json f)
         ; Aws.Util.option_map v.size (fun f -> "Size", Long.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ])

  let of_json j =
    { name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; size = Aws.Util.option_map (Aws.Json.lookup j "Size") Long.of_json
    ; hash = Aws.Util.option_map (Aws.Json.lookup j "Hash") String.of_json
    ; hash_type =
        Aws.Util.option_map (Aws.Json.lookup j "HashType") AttachmentHashType.of_json
    ; url = Aws.Util.option_map (Aws.Json.lookup j "Url") String.of_json
    }
end

module ParametersFilterValueList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module ParametersFilter = struct
  type t =
    { key : ParametersFilterKey.t
    ; values : ParametersFilterValueList.t
    }

  let make ~key ~values () = { key; values }

  let parse xml =
    Some
      { key =
          Aws.Xml.required
            "Key"
            (Aws.Util.option_bind (Aws.Xml.member "Key" xml) ParametersFilterKey.parse)
      ; values =
          Aws.Xml.required
            "Values"
            (Aws.Util.option_bind
               (Aws.Xml.member "Values" xml)
               ParametersFilterValueList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("Values.member", ParametersFilterValueList.to_query v.values))
         ; Some (Aws.Query.Pair ("Key", ParametersFilterKey.to_query v.key))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Values", ParametersFilterValueList.to_json v.values)
         ; Some ("Key", ParametersFilterKey.to_json v.key)
         ])

  let of_json j =
    { key = ParametersFilterKey.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Key"))
    ; values =
        ParametersFilterValueList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Values"))
    }
end

module ParametersFilterList = struct
  type t = ParametersFilter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ParametersFilter.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list ParametersFilter.to_query v
  let to_json v = `List (List.map ParametersFilter.to_json v)
  let of_json j = Aws.Json.to_list ParametersFilter.of_json j
end

module ParameterStringFilterValueList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module ParameterStringFilter = struct
  type t =
    { key : String.t
    ; option : String.t option
    ; values : ParameterStringFilterValueList.t
    }

  let make ~key ?option ?(values = []) () = { key; option; values }

  let parse xml =
    Some
      { key =
          Aws.Xml.required
            "Key"
            (Aws.Util.option_bind (Aws.Xml.member "Key" xml) String.parse)
      ; option = Aws.Util.option_bind (Aws.Xml.member "Option" xml) String.parse
      ; values =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Values" xml)
               ParameterStringFilterValueList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("Values.member", ParameterStringFilterValueList.to_query v.values))
         ; Aws.Util.option_map v.option (fun f ->
               Aws.Query.Pair ("Option", String.to_query f))
         ; Some (Aws.Query.Pair ("Key", String.to_query v.key))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Values", ParameterStringFilterValueList.to_json v.values)
         ; Aws.Util.option_map v.option (fun f -> "Option", String.to_json f)
         ; Some ("Key", String.to_json v.key)
         ])

  let of_json j =
    { key = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Key"))
    ; option = Aws.Util.option_map (Aws.Json.lookup j "Option") String.of_json
    ; values =
        ParameterStringFilterValueList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Values"))
    }
end

module ParameterStringFilterList = struct
  type t = ParameterStringFilter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ParameterStringFilter.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list ParameterStringFilter.to_query v
  let to_json v = `List (List.map ParameterStringFilter.to_json v)
  let of_json j = Aws.Json.to_list ParameterStringFilter.of_json j
end

module DescribeParametersRequest = struct
  type t =
    { filters : ParametersFilterList.t
    ; parameter_filters : ParameterStringFilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?(filters = []) ?(parameter_filters = []) ?max_results ?next_token () =
    { filters; parameter_filters; max_results; next_token }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               ParametersFilterList.parse)
      ; parameter_filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ParameterFilters" xml)
               ParameterStringFilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ParameterFilters.member"
                , ParameterStringFilterList.to_query v.parameter_filters ))
         ; Some
             (Aws.Query.Pair ("Filters.member", ParametersFilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("ParameterFilters", ParameterStringFilterList.to_json v.parameter_filters)
         ; Some ("Filters", ParametersFilterList.to_json v.filters)
         ])

  let of_json j =
    { filters =
        ParametersFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; parameter_filters =
        ParameterStringFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ParameterFilters"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module InventoryDeletionSummaryItems = struct
  type t = InventoryDeletionSummaryItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map InventoryDeletionSummaryItem.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list InventoryDeletionSummaryItem.to_query v
  let to_json v = `List (List.map InventoryDeletionSummaryItem.to_json v)
  let of_json j = Aws.Json.to_list InventoryDeletionSummaryItem.of_json j
end

module InventoryDeletionSummary = struct
  type t =
    { total_count : Integer.t option
    ; remaining_count : Integer.t option
    ; summary_items : InventoryDeletionSummaryItems.t
    }

  let make ?total_count ?remaining_count ?(summary_items = []) () =
    { total_count; remaining_count; summary_items }

  let parse xml =
    Some
      { total_count = Aws.Util.option_bind (Aws.Xml.member "TotalCount" xml) Integer.parse
      ; remaining_count =
          Aws.Util.option_bind (Aws.Xml.member "RemainingCount" xml) Integer.parse
      ; summary_items =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SummaryItems" xml)
               InventoryDeletionSummaryItems.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "SummaryItems.member"
                , InventoryDeletionSummaryItems.to_query v.summary_items ))
         ; Aws.Util.option_map v.remaining_count (fun f ->
               Aws.Query.Pair ("RemainingCount", Integer.to_query f))
         ; Aws.Util.option_map v.total_count (fun f ->
               Aws.Query.Pair ("TotalCount", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("SummaryItems", InventoryDeletionSummaryItems.to_json v.summary_items)
         ; Aws.Util.option_map v.remaining_count (fun f ->
               "RemainingCount", Integer.to_json f)
         ; Aws.Util.option_map v.total_count (fun f -> "TotalCount", Integer.to_json f)
         ])

  let of_json j =
    { total_count = Aws.Util.option_map (Aws.Json.lookup j "TotalCount") Integer.of_json
    ; remaining_count =
        Aws.Util.option_map (Aws.Json.lookup j "RemainingCount") Integer.of_json
    ; summary_items =
        InventoryDeletionSummaryItems.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SummaryItems"))
    }
end

module InventoryDeletionStatus = struct
  type t =
    | InProgress
    | Complete

  let str_to_t = [ "Complete", Complete; "InProgress", InProgress ]
  let t_to_str = [ Complete, "Complete"; InProgress, "InProgress" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module InventoryDeletionStatusItem = struct
  type t =
    { deletion_id : String.t option
    ; type_name : String.t option
    ; deletion_start_time : DateTime.t option
    ; last_status : InventoryDeletionStatus.t option
    ; last_status_message : String.t option
    ; deletion_summary : InventoryDeletionSummary.t option
    ; last_status_update_time : DateTime.t option
    }

  let make
      ?deletion_id
      ?type_name
      ?deletion_start_time
      ?last_status
      ?last_status_message
      ?deletion_summary
      ?last_status_update_time
      () =
    { deletion_id
    ; type_name
    ; deletion_start_time
    ; last_status
    ; last_status_message
    ; deletion_summary
    ; last_status_update_time
    }

  let parse xml =
    Some
      { deletion_id = Aws.Util.option_bind (Aws.Xml.member "DeletionId" xml) String.parse
      ; type_name = Aws.Util.option_bind (Aws.Xml.member "TypeName" xml) String.parse
      ; deletion_start_time =
          Aws.Util.option_bind (Aws.Xml.member "DeletionStartTime" xml) DateTime.parse
      ; last_status =
          Aws.Util.option_bind
            (Aws.Xml.member "LastStatus" xml)
            InventoryDeletionStatus.parse
      ; last_status_message =
          Aws.Util.option_bind (Aws.Xml.member "LastStatusMessage" xml) String.parse
      ; deletion_summary =
          Aws.Util.option_bind
            (Aws.Xml.member "DeletionSummary" xml)
            InventoryDeletionSummary.parse
      ; last_status_update_time =
          Aws.Util.option_bind (Aws.Xml.member "LastStatusUpdateTime" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.last_status_update_time (fun f ->
               Aws.Query.Pair ("LastStatusUpdateTime", DateTime.to_query f))
         ; Aws.Util.option_map v.deletion_summary (fun f ->
               Aws.Query.Pair ("DeletionSummary", InventoryDeletionSummary.to_query f))
         ; Aws.Util.option_map v.last_status_message (fun f ->
               Aws.Query.Pair ("LastStatusMessage", String.to_query f))
         ; Aws.Util.option_map v.last_status (fun f ->
               Aws.Query.Pair ("LastStatus", InventoryDeletionStatus.to_query f))
         ; Aws.Util.option_map v.deletion_start_time (fun f ->
               Aws.Query.Pair ("DeletionStartTime", DateTime.to_query f))
         ; Aws.Util.option_map v.type_name (fun f ->
               Aws.Query.Pair ("TypeName", String.to_query f))
         ; Aws.Util.option_map v.deletion_id (fun f ->
               Aws.Query.Pair ("DeletionId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.last_status_update_time (fun f ->
               "LastStatusUpdateTime", DateTime.to_json f)
         ; Aws.Util.option_map v.deletion_summary (fun f ->
               "DeletionSummary", InventoryDeletionSummary.to_json f)
         ; Aws.Util.option_map v.last_status_message (fun f ->
               "LastStatusMessage", String.to_json f)
         ; Aws.Util.option_map v.last_status (fun f ->
               "LastStatus", InventoryDeletionStatus.to_json f)
         ; Aws.Util.option_map v.deletion_start_time (fun f ->
               "DeletionStartTime", DateTime.to_json f)
         ; Aws.Util.option_map v.type_name (fun f -> "TypeName", String.to_json f)
         ; Aws.Util.option_map v.deletion_id (fun f -> "DeletionId", String.to_json f)
         ])

  let of_json j =
    { deletion_id = Aws.Util.option_map (Aws.Json.lookup j "DeletionId") String.of_json
    ; type_name = Aws.Util.option_map (Aws.Json.lookup j "TypeName") String.of_json
    ; deletion_start_time =
        Aws.Util.option_map (Aws.Json.lookup j "DeletionStartTime") DateTime.of_json
    ; last_status =
        Aws.Util.option_map
          (Aws.Json.lookup j "LastStatus")
          InventoryDeletionStatus.of_json
    ; last_status_message =
        Aws.Util.option_map (Aws.Json.lookup j "LastStatusMessage") String.of_json
    ; deletion_summary =
        Aws.Util.option_map
          (Aws.Json.lookup j "DeletionSummary")
          InventoryDeletionSummary.of_json
    ; last_status_update_time =
        Aws.Util.option_map (Aws.Json.lookup j "LastStatusUpdateTime") DateTime.of_json
    }
end

module InventoryDeletionsList = struct
  type t = InventoryDeletionStatusItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map InventoryDeletionStatusItem.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list InventoryDeletionStatusItem.to_query v
  let to_json v = `List (List.map InventoryDeletionStatusItem.to_json v)
  let of_json j = Aws.Json.to_list InventoryDeletionStatusItem.of_json j
end

module UnsupportedOperatingSystem = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module DocumentParameterType = struct
  type t =
    | String
    | StringList

  let str_to_t = [ "StringList", StringList; "String", String ]
  let t_to_str = [ StringList, "StringList"; String, "String" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module NormalStringMap = struct
  type t = (String.t, String.t) Hashtbl.t

  let make elems () = elems
  let parse xml = None
  let to_query v = Aws.Query.to_query_hashtbl String.to_string String.to_query v

  let to_json v =
    `Assoc
      (Hashtbl.fold (fun k v acc -> (String.to_string k, String.to_json v) :: acc) v [])

  let of_json j = Aws.Json.to_hashtbl String.of_string String.of_json j
end

module Targets = struct
  type t = Target.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Target.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list Target.to_query v
  let to_json v = `List (List.map Target.to_json v)
  let of_json j = Aws.Json.to_list Target.of_json j
end

module UpdateMaintenanceWindowTargetRequest = struct
  type t =
    { window_id : String.t
    ; window_target_id : String.t
    ; targets : Targets.t
    ; owner_information : String.t option
    ; name : String.t option
    ; description : String.t option
    ; replace : Boolean.t option
    }

  let make
      ~window_id
      ~window_target_id
      ?(targets = [])
      ?owner_information
      ?name
      ?description
      ?replace
      () =
    { window_id
    ; window_target_id
    ; targets
    ; owner_information
    ; name
    ; description
    ; replace
    }

  let parse xml =
    Some
      { window_id =
          Aws.Xml.required
            "WindowId"
            (Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse)
      ; window_target_id =
          Aws.Xml.required
            "WindowTargetId"
            (Aws.Util.option_bind (Aws.Xml.member "WindowTargetId" xml) String.parse)
      ; targets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Targets" xml) Targets.parse)
      ; owner_information =
          Aws.Util.option_bind (Aws.Xml.member "OwnerInformation" xml) String.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; replace = Aws.Util.option_bind (Aws.Xml.member "Replace" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.replace (fun f ->
               Aws.Query.Pair ("Replace", Boolean.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.owner_information (fun f ->
               Aws.Query.Pair ("OwnerInformation", String.to_query f))
         ; Some (Aws.Query.Pair ("Targets.member", Targets.to_query v.targets))
         ; Some (Aws.Query.Pair ("WindowTargetId", String.to_query v.window_target_id))
         ; Some (Aws.Query.Pair ("WindowId", String.to_query v.window_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.replace (fun f -> "Replace", Boolean.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.owner_information (fun f ->
               "OwnerInformation", String.to_json f)
         ; Some ("Targets", Targets.to_json v.targets)
         ; Some ("WindowTargetId", String.to_json v.window_target_id)
         ; Some ("WindowId", String.to_json v.window_id)
         ])

  let of_json j =
    { window_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowId"))
    ; window_target_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowTargetId"))
    ; targets = Targets.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Targets"))
    ; owner_information =
        Aws.Util.option_map (Aws.Json.lookup j "OwnerInformation") String.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; replace = Aws.Util.option_map (Aws.Json.lookup j "Replace") Boolean.of_json
    }
end

module ComplianceResourceIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module ParameterType = struct
  type t =
    | String
    | StringList
    | SecureString

  let str_to_t =
    [ "SecureString", SecureString; "StringList", StringList; "String", String ]

  let t_to_str =
    [ SecureString, "SecureString"; StringList, "StringList"; String, "String" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ParameterTier = struct
  type t =
    | Standard
    | Advanced
    | Intelligent_Tiering

  let str_to_t =
    [ "Intelligent-Tiering", Intelligent_Tiering
    ; "Advanced", Advanced
    ; "Standard", Standard
    ]

  let t_to_str =
    [ Intelligent_Tiering, "Intelligent-Tiering"
    ; Advanced, "Advanced"
    ; Standard, "Standard"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ParameterInlinePolicy = struct
  type t =
    { policy_text : String.t option
    ; policy_type : String.t option
    ; policy_status : String.t option
    }

  let make ?policy_text ?policy_type ?policy_status () =
    { policy_text; policy_type; policy_status }

  let parse xml =
    Some
      { policy_text = Aws.Util.option_bind (Aws.Xml.member "PolicyText" xml) String.parse
      ; policy_type = Aws.Util.option_bind (Aws.Xml.member "PolicyType" xml) String.parse
      ; policy_status =
          Aws.Util.option_bind (Aws.Xml.member "PolicyStatus" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.policy_status (fun f ->
               Aws.Query.Pair ("PolicyStatus", String.to_query f))
         ; Aws.Util.option_map v.policy_type (fun f ->
               Aws.Query.Pair ("PolicyType", String.to_query f))
         ; Aws.Util.option_map v.policy_text (fun f ->
               Aws.Query.Pair ("PolicyText", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.policy_status (fun f -> "PolicyStatus", String.to_json f)
         ; Aws.Util.option_map v.policy_type (fun f -> "PolicyType", String.to_json f)
         ; Aws.Util.option_map v.policy_text (fun f -> "PolicyText", String.to_json f)
         ])

  let of_json j =
    { policy_text = Aws.Util.option_map (Aws.Json.lookup j "PolicyText") String.of_json
    ; policy_type = Aws.Util.option_map (Aws.Json.lookup j "PolicyType") String.of_json
    ; policy_status =
        Aws.Util.option_map (Aws.Json.lookup j "PolicyStatus") String.of_json
    }
end

module ParameterPolicyList = struct
  type t = ParameterInlinePolicy.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ParameterInlinePolicy.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list ParameterInlinePolicy.to_query v
  let to_json v = `List (List.map ParameterInlinePolicy.to_json v)
  let of_json j = Aws.Json.to_list ParameterInlinePolicy.of_json j
end

module ParameterLabelList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module ParameterHistory = struct
  type t =
    { name : String.t option
    ; type_ : ParameterType.t option
    ; key_id : String.t option
    ; last_modified_date : DateTime.t option
    ; last_modified_user : String.t option
    ; description : String.t option
    ; value : String.t option
    ; allowed_pattern : String.t option
    ; version : Long.t option
    ; labels : ParameterLabelList.t
    ; tier : ParameterTier.t option
    ; policies : ParameterPolicyList.t
    ; data_type : String.t option
    }

  let make
      ?name
      ?type_
      ?key_id
      ?last_modified_date
      ?last_modified_user
      ?description
      ?value
      ?allowed_pattern
      ?version
      ?(labels = [])
      ?tier
      ?(policies = [])
      ?data_type
      () =
    { name
    ; type_
    ; key_id
    ; last_modified_date
    ; last_modified_user
    ; description
    ; value
    ; allowed_pattern
    ; version
    ; labels
    ; tier
    ; policies
    ; data_type
    }

  let parse xml =
    Some
      { name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; type_ = Aws.Util.option_bind (Aws.Xml.member "Type" xml) ParameterType.parse
      ; key_id = Aws.Util.option_bind (Aws.Xml.member "KeyId" xml) String.parse
      ; last_modified_date =
          Aws.Util.option_bind (Aws.Xml.member "LastModifiedDate" xml) DateTime.parse
      ; last_modified_user =
          Aws.Util.option_bind (Aws.Xml.member "LastModifiedUser" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; value = Aws.Util.option_bind (Aws.Xml.member "Value" xml) String.parse
      ; allowed_pattern =
          Aws.Util.option_bind (Aws.Xml.member "AllowedPattern" xml) String.parse
      ; version = Aws.Util.option_bind (Aws.Xml.member "Version" xml) Long.parse
      ; labels =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Labels" xml) ParameterLabelList.parse)
      ; tier = Aws.Util.option_bind (Aws.Xml.member "Tier" xml) ParameterTier.parse
      ; policies =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Policies" xml)
               ParameterPolicyList.parse)
      ; data_type = Aws.Util.option_bind (Aws.Xml.member "DataType" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.data_type (fun f ->
               Aws.Query.Pair ("DataType", String.to_query f))
         ; Some
             (Aws.Query.Pair ("Policies.member", ParameterPolicyList.to_query v.policies))
         ; Aws.Util.option_map v.tier (fun f ->
               Aws.Query.Pair ("Tier", ParameterTier.to_query f))
         ; Some (Aws.Query.Pair ("Labels.member", ParameterLabelList.to_query v.labels))
         ; Aws.Util.option_map v.version (fun f ->
               Aws.Query.Pair ("Version", Long.to_query f))
         ; Aws.Util.option_map v.allowed_pattern (fun f ->
               Aws.Query.Pair ("AllowedPattern", String.to_query f))
         ; Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.last_modified_user (fun f ->
               Aws.Query.Pair ("LastModifiedUser", String.to_query f))
         ; Aws.Util.option_map v.last_modified_date (fun f ->
               Aws.Query.Pair ("LastModifiedDate", DateTime.to_query f))
         ; Aws.Util.option_map v.key_id (fun f ->
               Aws.Query.Pair ("KeyId", String.to_query f))
         ; Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", ParameterType.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.data_type (fun f -> "DataType", String.to_json f)
         ; Some ("Policies", ParameterPolicyList.to_json v.policies)
         ; Aws.Util.option_map v.tier (fun f -> "Tier", ParameterTier.to_json f)
         ; Some ("Labels", ParameterLabelList.to_json v.labels)
         ; Aws.Util.option_map v.version (fun f -> "Version", Long.to_json f)
         ; Aws.Util.option_map v.allowed_pattern (fun f ->
               "AllowedPattern", String.to_json f)
         ; Aws.Util.option_map v.value (fun f -> "Value", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.last_modified_user (fun f ->
               "LastModifiedUser", String.to_json f)
         ; Aws.Util.option_map v.last_modified_date (fun f ->
               "LastModifiedDate", DateTime.to_json f)
         ; Aws.Util.option_map v.key_id (fun f -> "KeyId", String.to_json f)
         ; Aws.Util.option_map v.type_ (fun f -> "Type", ParameterType.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ])

  let of_json j =
    { name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; type_ = Aws.Util.option_map (Aws.Json.lookup j "Type") ParameterType.of_json
    ; key_id = Aws.Util.option_map (Aws.Json.lookup j "KeyId") String.of_json
    ; last_modified_date =
        Aws.Util.option_map (Aws.Json.lookup j "LastModifiedDate") DateTime.of_json
    ; last_modified_user =
        Aws.Util.option_map (Aws.Json.lookup j "LastModifiedUser") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; value = Aws.Util.option_map (Aws.Json.lookup j "Value") String.of_json
    ; allowed_pattern =
        Aws.Util.option_map (Aws.Json.lookup j "AllowedPattern") String.of_json
    ; version = Aws.Util.option_map (Aws.Json.lookup j "Version") Long.of_json
    ; labels =
        ParameterLabelList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Labels"))
    ; tier = Aws.Util.option_map (Aws.Json.lookup j "Tier") ParameterTier.of_json
    ; policies =
        ParameterPolicyList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Policies"))
    ; data_type = Aws.Util.option_map (Aws.Json.lookup j "DataType") String.of_json
    }
end

module ParameterHistoryList = struct
  type t = ParameterHistory.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ParameterHistory.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list ParameterHistory.to_query v
  let to_json v = `List (List.map ParameterHistory.to_json v)
  let of_json j = Aws.Json.to_list ParameterHistory.of_json j
end

module DocumentStatus = struct
  type t =
    | Creating
    | Active
    | Updating
    | Deleting
    | Failed

  let str_to_t =
    [ "Failed", Failed
    ; "Deleting", Deleting
    ; "Updating", Updating
    ; "Active", Active
    ; "Creating", Creating
    ]

  let t_to_str =
    [ Failed, "Failed"
    ; Deleting, "Deleting"
    ; Updating, "Updating"
    ; Active, "Active"
    ; Creating, "Creating"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DocumentFormat = struct
  type t =
    | YAML
    | JSON
    | TEXT

  let str_to_t = [ "TEXT", TEXT; "JSON", JSON; "YAML", YAML ]
  let t_to_str = [ TEXT, "TEXT"; JSON, "JSON"; YAML, "YAML" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DocumentVersionInfo = struct
  type t =
    { name : String.t option
    ; document_version : String.t option
    ; version_name : String.t option
    ; created_date : DateTime.t option
    ; is_default_version : Boolean.t option
    ; document_format : DocumentFormat.t option
    ; status : DocumentStatus.t option
    ; status_information : String.t option
    }

  let make
      ?name
      ?document_version
      ?version_name
      ?created_date
      ?is_default_version
      ?document_format
      ?status
      ?status_information
      () =
    { name
    ; document_version
    ; version_name
    ; created_date
    ; is_default_version
    ; document_format
    ; status
    ; status_information
    }

  let parse xml =
    Some
      { name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; document_version =
          Aws.Util.option_bind (Aws.Xml.member "DocumentVersion" xml) String.parse
      ; version_name =
          Aws.Util.option_bind (Aws.Xml.member "VersionName" xml) String.parse
      ; created_date =
          Aws.Util.option_bind (Aws.Xml.member "CreatedDate" xml) DateTime.parse
      ; is_default_version =
          Aws.Util.option_bind (Aws.Xml.member "IsDefaultVersion" xml) Boolean.parse
      ; document_format =
          Aws.Util.option_bind (Aws.Xml.member "DocumentFormat" xml) DocumentFormat.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) DocumentStatus.parse
      ; status_information =
          Aws.Util.option_bind (Aws.Xml.member "StatusInformation" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status_information (fun f ->
               Aws.Query.Pair ("StatusInformation", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", DocumentStatus.to_query f))
         ; Aws.Util.option_map v.document_format (fun f ->
               Aws.Query.Pair ("DocumentFormat", DocumentFormat.to_query f))
         ; Aws.Util.option_map v.is_default_version (fun f ->
               Aws.Query.Pair ("IsDefaultVersion", Boolean.to_query f))
         ; Aws.Util.option_map v.created_date (fun f ->
               Aws.Query.Pair ("CreatedDate", DateTime.to_query f))
         ; Aws.Util.option_map v.version_name (fun f ->
               Aws.Query.Pair ("VersionName", String.to_query f))
         ; Aws.Util.option_map v.document_version (fun f ->
               Aws.Query.Pair ("DocumentVersion", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status_information (fun f ->
               "StatusInformation", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", DocumentStatus.to_json f)
         ; Aws.Util.option_map v.document_format (fun f ->
               "DocumentFormat", DocumentFormat.to_json f)
         ; Aws.Util.option_map v.is_default_version (fun f ->
               "IsDefaultVersion", Boolean.to_json f)
         ; Aws.Util.option_map v.created_date (fun f -> "CreatedDate", DateTime.to_json f)
         ; Aws.Util.option_map v.version_name (fun f -> "VersionName", String.to_json f)
         ; Aws.Util.option_map v.document_version (fun f ->
               "DocumentVersion", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ])

  let of_json j =
    { name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; document_version =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentVersion") String.of_json
    ; version_name = Aws.Util.option_map (Aws.Json.lookup j "VersionName") String.of_json
    ; created_date =
        Aws.Util.option_map (Aws.Json.lookup j "CreatedDate") DateTime.of_json
    ; is_default_version =
        Aws.Util.option_map (Aws.Json.lookup j "IsDefaultVersion") Boolean.of_json
    ; document_format =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentFormat") DocumentFormat.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") DocumentStatus.of_json
    ; status_information =
        Aws.Util.option_map (Aws.Json.lookup j "StatusInformation") String.of_json
    }
end

module AutomationExecutionStatus = struct
  type t =
    | Pending
    | InProgress
    | Waiting
    | Success
    | TimedOut
    | Cancelling
    | Cancelled
    | Failed

  let str_to_t =
    [ "Failed", Failed
    ; "Cancelled", Cancelled
    ; "Cancelling", Cancelling
    ; "TimedOut", TimedOut
    ; "Success", Success
    ; "Waiting", Waiting
    ; "InProgress", InProgress
    ; "Pending", Pending
    ]

  let t_to_str =
    [ Failed, "Failed"
    ; Cancelled, "Cancelled"
    ; Cancelling, "Cancelling"
    ; TimedOut, "TimedOut"
    ; Success, "Success"
    ; Waiting, "Waiting"
    ; InProgress, "InProgress"
    ; Pending, "Pending"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module PatchSourceProductList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module PatchSource = struct
  type t =
    { name : String.t
    ; products : PatchSourceProductList.t
    ; configuration : String.t
    }

  let make ~name ~products ~configuration () = { name; products; configuration }

  let parse xml =
    Some
      { name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      ; products =
          Aws.Xml.required
            "Products"
            (Aws.Util.option_bind
               (Aws.Xml.member "Products" xml)
               PatchSourceProductList.parse)
      ; configuration =
          Aws.Xml.required
            "Configuration"
            (Aws.Util.option_bind (Aws.Xml.member "Configuration" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Configuration", String.to_query v.configuration))
         ; Some
             (Aws.Query.Pair
                ("Products.member", PatchSourceProductList.to_query v.products))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Configuration", String.to_json v.configuration)
         ; Some ("Products", PatchSourceProductList.to_json v.products)
         ; Some ("Name", String.to_json v.name)
         ])

  let of_json j =
    { name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; products =
        PatchSourceProductList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Products"))
    ; configuration =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Configuration"))
    }
end

module MaintenanceWindowExecution = struct
  type t =
    { window_id : String.t option
    ; window_execution_id : String.t option
    ; status : MaintenanceWindowExecutionStatus.t option
    ; status_details : String.t option
    ; start_time : DateTime.t option
    ; end_time : DateTime.t option
    }

  let make
      ?window_id
      ?window_execution_id
      ?status
      ?status_details
      ?start_time
      ?end_time
      () =
    { window_id; window_execution_id; status; status_details; start_time; end_time }

  let parse xml =
    Some
      { window_id = Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse
      ; window_execution_id =
          Aws.Util.option_bind (Aws.Xml.member "WindowExecutionId" xml) String.parse
      ; status =
          Aws.Util.option_bind
            (Aws.Xml.member "Status" xml)
            MaintenanceWindowExecutionStatus.parse
      ; status_details =
          Aws.Util.option_bind (Aws.Xml.member "StatusDetails" xml) String.parse
      ; start_time = Aws.Util.option_bind (Aws.Xml.member "StartTime" xml) DateTime.parse
      ; end_time = Aws.Util.option_bind (Aws.Xml.member "EndTime" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.end_time (fun f ->
               Aws.Query.Pair ("EndTime", DateTime.to_query f))
         ; Aws.Util.option_map v.start_time (fun f ->
               Aws.Query.Pair ("StartTime", DateTime.to_query f))
         ; Aws.Util.option_map v.status_details (fun f ->
               Aws.Query.Pair ("StatusDetails", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", MaintenanceWindowExecutionStatus.to_query f))
         ; Aws.Util.option_map v.window_execution_id (fun f ->
               Aws.Query.Pair ("WindowExecutionId", String.to_query f))
         ; Aws.Util.option_map v.window_id (fun f ->
               Aws.Query.Pair ("WindowId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.end_time (fun f -> "EndTime", DateTime.to_json f)
         ; Aws.Util.option_map v.start_time (fun f -> "StartTime", DateTime.to_json f)
         ; Aws.Util.option_map v.status_details (fun f ->
               "StatusDetails", String.to_json f)
         ; Aws.Util.option_map v.status (fun f ->
               "Status", MaintenanceWindowExecutionStatus.to_json f)
         ; Aws.Util.option_map v.window_execution_id (fun f ->
               "WindowExecutionId", String.to_json f)
         ; Aws.Util.option_map v.window_id (fun f -> "WindowId", String.to_json f)
         ])

  let of_json j =
    { window_id = Aws.Util.option_map (Aws.Json.lookup j "WindowId") String.of_json
    ; window_execution_id =
        Aws.Util.option_map (Aws.Json.lookup j "WindowExecutionId") String.of_json
    ; status =
        Aws.Util.option_map
          (Aws.Json.lookup j "Status")
          MaintenanceWindowExecutionStatus.of_json
    ; status_details =
        Aws.Util.option_map (Aws.Json.lookup j "StatusDetails") String.of_json
    ; start_time = Aws.Util.option_map (Aws.Json.lookup j "StartTime") DateTime.of_json
    ; end_time = Aws.Util.option_map (Aws.Json.lookup j "EndTime") DateTime.of_json
    }
end

module MaintenanceWindowExecutionList = struct
  type t = MaintenanceWindowExecution.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map MaintenanceWindowExecution.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list MaintenanceWindowExecution.to_query v
  let to_json v = `List (List.map MaintenanceWindowExecution.to_json v)
  let of_json j = Aws.Json.to_list MaintenanceWindowExecution.of_json j
end

module DescribeMaintenanceWindowExecutionsResult = struct
  type t =
    { window_executions : MaintenanceWindowExecutionList.t
    ; next_token : String.t option
    }

  let make ?(window_executions = []) ?next_token () = { window_executions; next_token }

  let parse xml =
    Some
      { window_executions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "WindowExecutions" xml)
               MaintenanceWindowExecutionList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "WindowExecutions.member"
                , MaintenanceWindowExecutionList.to_query v.window_executions ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some
             ( "WindowExecutions"
             , MaintenanceWindowExecutionList.to_json v.window_executions )
         ])

  let of_json j =
    { window_executions =
        MaintenanceWindowExecutionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowExecutions"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module InventoryFilterValueList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module GetMaintenanceWindowResult = struct
  type t =
    { window_id : String.t option
    ; name : String.t option
    ; description : String.t option
    ; start_date : String.t option
    ; end_date : String.t option
    ; schedule : String.t option
    ; schedule_timezone : String.t option
    ; schedule_offset : Integer.t option
    ; next_execution_time : String.t option
    ; duration : Integer.t option
    ; cutoff : Integer.t option
    ; allow_unassociated_targets : Boolean.t option
    ; enabled : Boolean.t option
    ; created_date : DateTime.t option
    ; modified_date : DateTime.t option
    }

  let make
      ?window_id
      ?name
      ?description
      ?start_date
      ?end_date
      ?schedule
      ?schedule_timezone
      ?schedule_offset
      ?next_execution_time
      ?duration
      ?cutoff
      ?allow_unassociated_targets
      ?enabled
      ?created_date
      ?modified_date
      () =
    { window_id
    ; name
    ; description
    ; start_date
    ; end_date
    ; schedule
    ; schedule_timezone
    ; schedule_offset
    ; next_execution_time
    ; duration
    ; cutoff
    ; allow_unassociated_targets
    ; enabled
    ; created_date
    ; modified_date
    }

  let parse xml =
    Some
      { window_id = Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; start_date = Aws.Util.option_bind (Aws.Xml.member "StartDate" xml) String.parse
      ; end_date = Aws.Util.option_bind (Aws.Xml.member "EndDate" xml) String.parse
      ; schedule = Aws.Util.option_bind (Aws.Xml.member "Schedule" xml) String.parse
      ; schedule_timezone =
          Aws.Util.option_bind (Aws.Xml.member "ScheduleTimezone" xml) String.parse
      ; schedule_offset =
          Aws.Util.option_bind (Aws.Xml.member "ScheduleOffset" xml) Integer.parse
      ; next_execution_time =
          Aws.Util.option_bind (Aws.Xml.member "NextExecutionTime" xml) String.parse
      ; duration = Aws.Util.option_bind (Aws.Xml.member "Duration" xml) Integer.parse
      ; cutoff = Aws.Util.option_bind (Aws.Xml.member "Cutoff" xml) Integer.parse
      ; allow_unassociated_targets =
          Aws.Util.option_bind
            (Aws.Xml.member "AllowUnassociatedTargets" xml)
            Boolean.parse
      ; enabled = Aws.Util.option_bind (Aws.Xml.member "Enabled" xml) Boolean.parse
      ; created_date =
          Aws.Util.option_bind (Aws.Xml.member "CreatedDate" xml) DateTime.parse
      ; modified_date =
          Aws.Util.option_bind (Aws.Xml.member "ModifiedDate" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.modified_date (fun f ->
               Aws.Query.Pair ("ModifiedDate", DateTime.to_query f))
         ; Aws.Util.option_map v.created_date (fun f ->
               Aws.Query.Pair ("CreatedDate", DateTime.to_query f))
         ; Aws.Util.option_map v.enabled (fun f ->
               Aws.Query.Pair ("Enabled", Boolean.to_query f))
         ; Aws.Util.option_map v.allow_unassociated_targets (fun f ->
               Aws.Query.Pair ("AllowUnassociatedTargets", Boolean.to_query f))
         ; Aws.Util.option_map v.cutoff (fun f ->
               Aws.Query.Pair ("Cutoff", Integer.to_query f))
         ; Aws.Util.option_map v.duration (fun f ->
               Aws.Query.Pair ("Duration", Integer.to_query f))
         ; Aws.Util.option_map v.next_execution_time (fun f ->
               Aws.Query.Pair ("NextExecutionTime", String.to_query f))
         ; Aws.Util.option_map v.schedule_offset (fun f ->
               Aws.Query.Pair ("ScheduleOffset", Integer.to_query f))
         ; Aws.Util.option_map v.schedule_timezone (fun f ->
               Aws.Query.Pair ("ScheduleTimezone", String.to_query f))
         ; Aws.Util.option_map v.schedule (fun f ->
               Aws.Query.Pair ("Schedule", String.to_query f))
         ; Aws.Util.option_map v.end_date (fun f ->
               Aws.Query.Pair ("EndDate", String.to_query f))
         ; Aws.Util.option_map v.start_date (fun f ->
               Aws.Query.Pair ("StartDate", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.window_id (fun f ->
               Aws.Query.Pair ("WindowId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.modified_date (fun f ->
               "ModifiedDate", DateTime.to_json f)
         ; Aws.Util.option_map v.created_date (fun f -> "CreatedDate", DateTime.to_json f)
         ; Aws.Util.option_map v.enabled (fun f -> "Enabled", Boolean.to_json f)
         ; Aws.Util.option_map v.allow_unassociated_targets (fun f ->
               "AllowUnassociatedTargets", Boolean.to_json f)
         ; Aws.Util.option_map v.cutoff (fun f -> "Cutoff", Integer.to_json f)
         ; Aws.Util.option_map v.duration (fun f -> "Duration", Integer.to_json f)
         ; Aws.Util.option_map v.next_execution_time (fun f ->
               "NextExecutionTime", String.to_json f)
         ; Aws.Util.option_map v.schedule_offset (fun f ->
               "ScheduleOffset", Integer.to_json f)
         ; Aws.Util.option_map v.schedule_timezone (fun f ->
               "ScheduleTimezone", String.to_json f)
         ; Aws.Util.option_map v.schedule (fun f -> "Schedule", String.to_json f)
         ; Aws.Util.option_map v.end_date (fun f -> "EndDate", String.to_json f)
         ; Aws.Util.option_map v.start_date (fun f -> "StartDate", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.window_id (fun f -> "WindowId", String.to_json f)
         ])

  let of_json j =
    { window_id = Aws.Util.option_map (Aws.Json.lookup j "WindowId") String.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; start_date = Aws.Util.option_map (Aws.Json.lookup j "StartDate") String.of_json
    ; end_date = Aws.Util.option_map (Aws.Json.lookup j "EndDate") String.of_json
    ; schedule = Aws.Util.option_map (Aws.Json.lookup j "Schedule") String.of_json
    ; schedule_timezone =
        Aws.Util.option_map (Aws.Json.lookup j "ScheduleTimezone") String.of_json
    ; schedule_offset =
        Aws.Util.option_map (Aws.Json.lookup j "ScheduleOffset") Integer.of_json
    ; next_execution_time =
        Aws.Util.option_map (Aws.Json.lookup j "NextExecutionTime") String.of_json
    ; duration = Aws.Util.option_map (Aws.Json.lookup j "Duration") Integer.of_json
    ; cutoff = Aws.Util.option_map (Aws.Json.lookup j "Cutoff") Integer.of_json
    ; allow_unassociated_targets =
        Aws.Util.option_map (Aws.Json.lookup j "AllowUnassociatedTargets") Boolean.of_json
    ; enabled = Aws.Util.option_map (Aws.Json.lookup j "Enabled") Boolean.of_json
    ; created_date =
        Aws.Util.option_map (Aws.Json.lookup j "CreatedDate") DateTime.of_json
    ; modified_date =
        Aws.Util.option_map (Aws.Json.lookup j "ModifiedDate") DateTime.of_json
    }
end

module MaintenanceWindowResourceType = struct
  type t =
    | INSTANCE
    | RESOURCE_GROUP

  let str_to_t = [ "RESOURCE_GROUP", RESOURCE_GROUP; "INSTANCE", INSTANCE ]
  let t_to_str = [ RESOURCE_GROUP, "RESOURCE_GROUP"; INSTANCE, "INSTANCE" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DescribeMaintenanceWindowsForTargetRequest = struct
  type t =
    { targets : Targets.t
    ; resource_type : MaintenanceWindowResourceType.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ~targets ~resource_type ?max_results ?next_token () =
    { targets; resource_type; max_results; next_token }

  let parse xml =
    Some
      { targets =
          Aws.Xml.required
            "Targets"
            (Aws.Util.option_bind (Aws.Xml.member "Targets" xml) Targets.parse)
      ; resource_type =
          Aws.Xml.required
            "ResourceType"
            (Aws.Util.option_bind
               (Aws.Xml.member "ResourceType" xml)
               MaintenanceWindowResourceType.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ResourceType", MaintenanceWindowResourceType.to_query v.resource_type))
         ; Some (Aws.Query.Pair ("Targets.member", Targets.to_query v.targets))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("ResourceType", MaintenanceWindowResourceType.to_json v.resource_type)
         ; Some ("Targets", Targets.to_json v.targets)
         ])

  let of_json j =
    { targets = Targets.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Targets"))
    ; resource_type =
        MaintenanceWindowResourceType.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ResourceType"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module ProgressCounters = struct
  type t =
    { total_steps : Integer.t option
    ; success_steps : Integer.t option
    ; failed_steps : Integer.t option
    ; cancelled_steps : Integer.t option
    ; timed_out_steps : Integer.t option
    }

  let make ?total_steps ?success_steps ?failed_steps ?cancelled_steps ?timed_out_steps ()
      =
    { total_steps; success_steps; failed_steps; cancelled_steps; timed_out_steps }

  let parse xml =
    Some
      { total_steps = Aws.Util.option_bind (Aws.Xml.member "TotalSteps" xml) Integer.parse
      ; success_steps =
          Aws.Util.option_bind (Aws.Xml.member "SuccessSteps" xml) Integer.parse
      ; failed_steps =
          Aws.Util.option_bind (Aws.Xml.member "FailedSteps" xml) Integer.parse
      ; cancelled_steps =
          Aws.Util.option_bind (Aws.Xml.member "CancelledSteps" xml) Integer.parse
      ; timed_out_steps =
          Aws.Util.option_bind (Aws.Xml.member "TimedOutSteps" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timed_out_steps (fun f ->
               Aws.Query.Pair ("TimedOutSteps", Integer.to_query f))
         ; Aws.Util.option_map v.cancelled_steps (fun f ->
               Aws.Query.Pair ("CancelledSteps", Integer.to_query f))
         ; Aws.Util.option_map v.failed_steps (fun f ->
               Aws.Query.Pair ("FailedSteps", Integer.to_query f))
         ; Aws.Util.option_map v.success_steps (fun f ->
               Aws.Query.Pair ("SuccessSteps", Integer.to_query f))
         ; Aws.Util.option_map v.total_steps (fun f ->
               Aws.Query.Pair ("TotalSteps", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timed_out_steps (fun f ->
               "TimedOutSteps", Integer.to_json f)
         ; Aws.Util.option_map v.cancelled_steps (fun f ->
               "CancelledSteps", Integer.to_json f)
         ; Aws.Util.option_map v.failed_steps (fun f -> "FailedSteps", Integer.to_json f)
         ; Aws.Util.option_map v.success_steps (fun f ->
               "SuccessSteps", Integer.to_json f)
         ; Aws.Util.option_map v.total_steps (fun f -> "TotalSteps", Integer.to_json f)
         ])

  let of_json j =
    { total_steps = Aws.Util.option_map (Aws.Json.lookup j "TotalSteps") Integer.of_json
    ; success_steps =
        Aws.Util.option_map (Aws.Json.lookup j "SuccessSteps") Integer.of_json
    ; failed_steps = Aws.Util.option_map (Aws.Json.lookup j "FailedSteps") Integer.of_json
    ; cancelled_steps =
        Aws.Util.option_map (Aws.Json.lookup j "CancelledSteps") Integer.of_json
    ; timed_out_steps =
        Aws.Util.option_map (Aws.Json.lookup j "TimedOutSteps") Integer.of_json
    }
end

module InstancePatchStateOperatorType = struct
  type t =
    | Equal
    | NotEqual
    | LessThan
    | GreaterThan

  let str_to_t =
    [ "GreaterThan", GreaterThan
    ; "LessThan", LessThan
    ; "NotEqual", NotEqual
    ; "Equal", Equal
    ]

  let t_to_str =
    [ GreaterThan, "GreaterThan"
    ; LessThan, "LessThan"
    ; NotEqual, "NotEqual"
    ; Equal, "Equal"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module InstancePatchStateFilterValues = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module InstancePatchStateFilter = struct
  type t =
    { key : String.t
    ; values : InstancePatchStateFilterValues.t
    ; type_ : InstancePatchStateOperatorType.t
    }

  let make ~key ~values ~type_ () = { key; values; type_ }

  let parse xml =
    Some
      { key =
          Aws.Xml.required
            "Key"
            (Aws.Util.option_bind (Aws.Xml.member "Key" xml) String.parse)
      ; values =
          Aws.Xml.required
            "Values"
            (Aws.Util.option_bind
               (Aws.Xml.member "Values" xml)
               InstancePatchStateFilterValues.parse)
      ; type_ =
          Aws.Xml.required
            "Type"
            (Aws.Util.option_bind
               (Aws.Xml.member "Type" xml)
               InstancePatchStateOperatorType.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Type", InstancePatchStateOperatorType.to_query v.type_))
         ; Some
             (Aws.Query.Pair
                ("Values.member", InstancePatchStateFilterValues.to_query v.values))
         ; Some (Aws.Query.Pair ("Key", String.to_query v.key))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Type", InstancePatchStateOperatorType.to_json v.type_)
         ; Some ("Values", InstancePatchStateFilterValues.to_json v.values)
         ; Some ("Key", String.to_json v.key)
         ])

  let of_json j =
    { key = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Key"))
    ; values =
        InstancePatchStateFilterValues.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Values"))
    ; type_ =
        InstancePatchStateOperatorType.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Type"))
    }
end

module InstancePatchStateFilterList = struct
  type t = InstancePatchStateFilter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map InstancePatchStateFilter.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list InstancePatchStateFilter.to_query v
  let to_json v = `List (List.map InstancePatchStateFilter.to_json v)
  let of_json j = Aws.Json.to_list InstancePatchStateFilter.of_json j
end

module ResourceDataSyncS3Format = struct
  type t = JsonSerDe

  let str_to_t = [ "JsonSerDe", JsonSerDe ]
  let t_to_str = [ JsonSerDe, "JsonSerDe" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ResourceDataSyncDestinationDataSharing = struct
  type t = { destination_data_sharing_type : String.t option }

  let make ?destination_data_sharing_type () = { destination_data_sharing_type }

  let parse xml =
    Some
      { destination_data_sharing_type =
          Aws.Util.option_bind
            (Aws.Xml.member "DestinationDataSharingType" xml)
            String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.destination_data_sharing_type (fun f ->
               Aws.Query.Pair ("DestinationDataSharingType", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.destination_data_sharing_type (fun f ->
               "DestinationDataSharingType", String.to_json f)
         ])

  let of_json j =
    { destination_data_sharing_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "DestinationDataSharingType")
          String.of_json
    }
end

module ResourceDataSyncS3Destination = struct
  type t =
    { bucket_name : String.t
    ; prefix : String.t option
    ; sync_format : ResourceDataSyncS3Format.t
    ; region : String.t
    ; a_w_s_k_m_s_key_a_r_n : String.t option
    ; destination_data_sharing : ResourceDataSyncDestinationDataSharing.t option
    }

  let make
      ~bucket_name
      ?prefix
      ~sync_format
      ~region
      ?a_w_s_k_m_s_key_a_r_n
      ?destination_data_sharing
      () =
    { bucket_name
    ; prefix
    ; sync_format
    ; region
    ; a_w_s_k_m_s_key_a_r_n
    ; destination_data_sharing
    }

  let parse xml =
    Some
      { bucket_name =
          Aws.Xml.required
            "BucketName"
            (Aws.Util.option_bind (Aws.Xml.member "BucketName" xml) String.parse)
      ; prefix = Aws.Util.option_bind (Aws.Xml.member "Prefix" xml) String.parse
      ; sync_format =
          Aws.Xml.required
            "SyncFormat"
            (Aws.Util.option_bind
               (Aws.Xml.member "SyncFormat" xml)
               ResourceDataSyncS3Format.parse)
      ; region =
          Aws.Xml.required
            "Region"
            (Aws.Util.option_bind (Aws.Xml.member "Region" xml) String.parse)
      ; a_w_s_k_m_s_key_a_r_n =
          Aws.Util.option_bind (Aws.Xml.member "AWSKMSKeyARN" xml) String.parse
      ; destination_data_sharing =
          Aws.Util.option_bind
            (Aws.Xml.member "DestinationDataSharing" xml)
            ResourceDataSyncDestinationDataSharing.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.destination_data_sharing (fun f ->
               Aws.Query.Pair
                 ( "DestinationDataSharing"
                 , ResourceDataSyncDestinationDataSharing.to_query f ))
         ; Aws.Util.option_map v.a_w_s_k_m_s_key_a_r_n (fun f ->
               Aws.Query.Pair ("AWSKMSKeyARN", String.to_query f))
         ; Some (Aws.Query.Pair ("Region", String.to_query v.region))
         ; Some
             (Aws.Query.Pair
                ("SyncFormat", ResourceDataSyncS3Format.to_query v.sync_format))
         ; Aws.Util.option_map v.prefix (fun f ->
               Aws.Query.Pair ("Prefix", String.to_query f))
         ; Some (Aws.Query.Pair ("BucketName", String.to_query v.bucket_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.destination_data_sharing (fun f ->
               "DestinationDataSharing", ResourceDataSyncDestinationDataSharing.to_json f)
         ; Aws.Util.option_map v.a_w_s_k_m_s_key_a_r_n (fun f ->
               "AWSKMSKeyARN", String.to_json f)
         ; Some ("Region", String.to_json v.region)
         ; Some ("SyncFormat", ResourceDataSyncS3Format.to_json v.sync_format)
         ; Aws.Util.option_map v.prefix (fun f -> "Prefix", String.to_json f)
         ; Some ("BucketName", String.to_json v.bucket_name)
         ])

  let of_json j =
    { bucket_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "BucketName"))
    ; prefix = Aws.Util.option_map (Aws.Json.lookup j "Prefix") String.of_json
    ; sync_format =
        ResourceDataSyncS3Format.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SyncFormat"))
    ; region = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Region"))
    ; a_w_s_k_m_s_key_a_r_n =
        Aws.Util.option_map (Aws.Json.lookup j "AWSKMSKeyARN") String.of_json
    ; destination_data_sharing =
        Aws.Util.option_map
          (Aws.Json.lookup j "DestinationDataSharing")
          ResourceDataSyncDestinationDataSharing.of_json
    }
end

module MaintenanceWindowIdentity = struct
  type t =
    { window_id : String.t option
    ; name : String.t option
    ; description : String.t option
    ; enabled : Boolean.t option
    ; duration : Integer.t option
    ; cutoff : Integer.t option
    ; schedule : String.t option
    ; schedule_timezone : String.t option
    ; schedule_offset : Integer.t option
    ; end_date : String.t option
    ; start_date : String.t option
    ; next_execution_time : String.t option
    }

  let make
      ?window_id
      ?name
      ?description
      ?enabled
      ?duration
      ?cutoff
      ?schedule
      ?schedule_timezone
      ?schedule_offset
      ?end_date
      ?start_date
      ?next_execution_time
      () =
    { window_id
    ; name
    ; description
    ; enabled
    ; duration
    ; cutoff
    ; schedule
    ; schedule_timezone
    ; schedule_offset
    ; end_date
    ; start_date
    ; next_execution_time
    }

  let parse xml =
    Some
      { window_id = Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; enabled = Aws.Util.option_bind (Aws.Xml.member "Enabled" xml) Boolean.parse
      ; duration = Aws.Util.option_bind (Aws.Xml.member "Duration" xml) Integer.parse
      ; cutoff = Aws.Util.option_bind (Aws.Xml.member "Cutoff" xml) Integer.parse
      ; schedule = Aws.Util.option_bind (Aws.Xml.member "Schedule" xml) String.parse
      ; schedule_timezone =
          Aws.Util.option_bind (Aws.Xml.member "ScheduleTimezone" xml) String.parse
      ; schedule_offset =
          Aws.Util.option_bind (Aws.Xml.member "ScheduleOffset" xml) Integer.parse
      ; end_date = Aws.Util.option_bind (Aws.Xml.member "EndDate" xml) String.parse
      ; start_date = Aws.Util.option_bind (Aws.Xml.member "StartDate" xml) String.parse
      ; next_execution_time =
          Aws.Util.option_bind (Aws.Xml.member "NextExecutionTime" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_execution_time (fun f ->
               Aws.Query.Pair ("NextExecutionTime", String.to_query f))
         ; Aws.Util.option_map v.start_date (fun f ->
               Aws.Query.Pair ("StartDate", String.to_query f))
         ; Aws.Util.option_map v.end_date (fun f ->
               Aws.Query.Pair ("EndDate", String.to_query f))
         ; Aws.Util.option_map v.schedule_offset (fun f ->
               Aws.Query.Pair ("ScheduleOffset", Integer.to_query f))
         ; Aws.Util.option_map v.schedule_timezone (fun f ->
               Aws.Query.Pair ("ScheduleTimezone", String.to_query f))
         ; Aws.Util.option_map v.schedule (fun f ->
               Aws.Query.Pair ("Schedule", String.to_query f))
         ; Aws.Util.option_map v.cutoff (fun f ->
               Aws.Query.Pair ("Cutoff", Integer.to_query f))
         ; Aws.Util.option_map v.duration (fun f ->
               Aws.Query.Pair ("Duration", Integer.to_query f))
         ; Aws.Util.option_map v.enabled (fun f ->
               Aws.Query.Pair ("Enabled", Boolean.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.window_id (fun f ->
               Aws.Query.Pair ("WindowId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_execution_time (fun f ->
               "NextExecutionTime", String.to_json f)
         ; Aws.Util.option_map v.start_date (fun f -> "StartDate", String.to_json f)
         ; Aws.Util.option_map v.end_date (fun f -> "EndDate", String.to_json f)
         ; Aws.Util.option_map v.schedule_offset (fun f ->
               "ScheduleOffset", Integer.to_json f)
         ; Aws.Util.option_map v.schedule_timezone (fun f ->
               "ScheduleTimezone", String.to_json f)
         ; Aws.Util.option_map v.schedule (fun f -> "Schedule", String.to_json f)
         ; Aws.Util.option_map v.cutoff (fun f -> "Cutoff", Integer.to_json f)
         ; Aws.Util.option_map v.duration (fun f -> "Duration", Integer.to_json f)
         ; Aws.Util.option_map v.enabled (fun f -> "Enabled", Boolean.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.window_id (fun f -> "WindowId", String.to_json f)
         ])

  let of_json j =
    { window_id = Aws.Util.option_map (Aws.Json.lookup j "WindowId") String.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; enabled = Aws.Util.option_map (Aws.Json.lookup j "Enabled") Boolean.of_json
    ; duration = Aws.Util.option_map (Aws.Json.lookup j "Duration") Integer.of_json
    ; cutoff = Aws.Util.option_map (Aws.Json.lookup j "Cutoff") Integer.of_json
    ; schedule = Aws.Util.option_map (Aws.Json.lookup j "Schedule") String.of_json
    ; schedule_timezone =
        Aws.Util.option_map (Aws.Json.lookup j "ScheduleTimezone") String.of_json
    ; schedule_offset =
        Aws.Util.option_map (Aws.Json.lookup j "ScheduleOffset") Integer.of_json
    ; end_date = Aws.Util.option_map (Aws.Json.lookup j "EndDate") String.of_json
    ; start_date = Aws.Util.option_map (Aws.Json.lookup j "StartDate") String.of_json
    ; next_execution_time =
        Aws.Util.option_map (Aws.Json.lookup j "NextExecutionTime") String.of_json
    }
end

module GetParameterHistoryRequest = struct
  type t =
    { name : String.t
    ; with_decryption : Boolean.t option
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ~name ?with_decryption ?max_results ?next_token () =
    { name; with_decryption; max_results; next_token }

  let parse xml =
    Some
      { name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      ; with_decryption =
          Aws.Util.option_bind (Aws.Xml.member "WithDecryption" xml) Boolean.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.with_decryption (fun f ->
               Aws.Query.Pair ("WithDecryption", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.with_decryption (fun f ->
               "WithDecryption", Boolean.to_json f)
         ; Some ("Name", String.to_json v.name)
         ])

  let of_json j =
    { name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; with_decryption =
        Aws.Util.option_map (Aws.Json.lookup j "WithDecryption") Boolean.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module ParameterNameList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module Parameter = struct
  type t =
    { name : String.t option
    ; type_ : ParameterType.t option
    ; value : String.t option
    ; version : Long.t option
    ; selector : String.t option
    ; source_result : String.t option
    ; last_modified_date : DateTime.t option
    ; a_r_n : String.t option
    ; data_type : String.t option
    }

  let make
      ?name
      ?type_
      ?value
      ?version
      ?selector
      ?source_result
      ?last_modified_date
      ?a_r_n
      ?data_type
      () =
    { name
    ; type_
    ; value
    ; version
    ; selector
    ; source_result
    ; last_modified_date
    ; a_r_n
    ; data_type
    }

  let parse xml =
    Some
      { name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; type_ = Aws.Util.option_bind (Aws.Xml.member "Type" xml) ParameterType.parse
      ; value = Aws.Util.option_bind (Aws.Xml.member "Value" xml) String.parse
      ; version = Aws.Util.option_bind (Aws.Xml.member "Version" xml) Long.parse
      ; selector = Aws.Util.option_bind (Aws.Xml.member "Selector" xml) String.parse
      ; source_result =
          Aws.Util.option_bind (Aws.Xml.member "SourceResult" xml) String.parse
      ; last_modified_date =
          Aws.Util.option_bind (Aws.Xml.member "LastModifiedDate" xml) DateTime.parse
      ; a_r_n = Aws.Util.option_bind (Aws.Xml.member "ARN" xml) String.parse
      ; data_type = Aws.Util.option_bind (Aws.Xml.member "DataType" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.data_type (fun f ->
               Aws.Query.Pair ("DataType", String.to_query f))
         ; Aws.Util.option_map v.a_r_n (fun f ->
               Aws.Query.Pair ("ARN", String.to_query f))
         ; Aws.Util.option_map v.last_modified_date (fun f ->
               Aws.Query.Pair ("LastModifiedDate", DateTime.to_query f))
         ; Aws.Util.option_map v.source_result (fun f ->
               Aws.Query.Pair ("SourceResult", String.to_query f))
         ; Aws.Util.option_map v.selector (fun f ->
               Aws.Query.Pair ("Selector", String.to_query f))
         ; Aws.Util.option_map v.version (fun f ->
               Aws.Query.Pair ("Version", Long.to_query f))
         ; Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", String.to_query f))
         ; Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", ParameterType.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.data_type (fun f -> "DataType", String.to_json f)
         ; Aws.Util.option_map v.a_r_n (fun f -> "ARN", String.to_json f)
         ; Aws.Util.option_map v.last_modified_date (fun f ->
               "LastModifiedDate", DateTime.to_json f)
         ; Aws.Util.option_map v.source_result (fun f -> "SourceResult", String.to_json f)
         ; Aws.Util.option_map v.selector (fun f -> "Selector", String.to_json f)
         ; Aws.Util.option_map v.version (fun f -> "Version", Long.to_json f)
         ; Aws.Util.option_map v.value (fun f -> "Value", String.to_json f)
         ; Aws.Util.option_map v.type_ (fun f -> "Type", ParameterType.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ])

  let of_json j =
    { name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; type_ = Aws.Util.option_map (Aws.Json.lookup j "Type") ParameterType.of_json
    ; value = Aws.Util.option_map (Aws.Json.lookup j "Value") String.of_json
    ; version = Aws.Util.option_map (Aws.Json.lookup j "Version") Long.of_json
    ; selector = Aws.Util.option_map (Aws.Json.lookup j "Selector") String.of_json
    ; source_result =
        Aws.Util.option_map (Aws.Json.lookup j "SourceResult") String.of_json
    ; last_modified_date =
        Aws.Util.option_map (Aws.Json.lookup j "LastModifiedDate") DateTime.of_json
    ; a_r_n = Aws.Util.option_map (Aws.Json.lookup j "ARN") String.of_json
    ; data_type = Aws.Util.option_map (Aws.Json.lookup j "DataType") String.of_json
    }
end

module ParameterList = struct
  type t = Parameter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Parameter.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list Parameter.to_query v
  let to_json v = `List (List.map Parameter.to_json v)
  let of_json j = Aws.Json.to_list Parameter.of_json j
end

module GetParametersResult = struct
  type t =
    { parameters : ParameterList.t
    ; invalid_parameters : ParameterNameList.t
    }

  let make ?(parameters = []) ?(invalid_parameters = []) () =
    { parameters; invalid_parameters }

  let parse xml =
    Some
      { parameters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Parameters" xml) ParameterList.parse)
      ; invalid_parameters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "InvalidParameters" xml)
               ParameterNameList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "InvalidParameters.member"
                , ParameterNameList.to_query v.invalid_parameters ))
         ; Some
             (Aws.Query.Pair ("Parameters.member", ParameterList.to_query v.parameters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("InvalidParameters", ParameterNameList.to_json v.invalid_parameters)
         ; Some ("Parameters", ParameterList.to_json v.parameters)
         ])

  let of_json j =
    { parameters =
        ParameterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Parameters"))
    ; invalid_parameters =
        ParameterNameList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InvalidParameters"))
    }
end

module DescribeEffectivePatchesForPatchBaselineRequest = struct
  type t =
    { baseline_id : String.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ~baseline_id ?max_results ?next_token () =
    { baseline_id; max_results; next_token }

  let parse xml =
    Some
      { baseline_id =
          Aws.Xml.required
            "BaselineId"
            (Aws.Util.option_bind (Aws.Xml.member "BaselineId" xml) String.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("BaselineId", String.to_query v.baseline_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("BaselineId", String.to_json v.baseline_id)
         ])

  let of_json j =
    { baseline_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "BaselineId"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module AssociationFilterOperatorType = struct
  type t =
    | EQUAL
    | LESS_THAN
    | GREATER_THAN

  let str_to_t = [ "GREATER_THAN", GREATER_THAN; "LESS_THAN", LESS_THAN; "EQUAL", EQUAL ]
  let t_to_str = [ GREATER_THAN, "GREATER_THAN"; LESS_THAN, "LESS_THAN"; EQUAL, "EQUAL" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module AssociationExecutionFilterKey = struct
  type t =
    | ExecutionId
    | Status
    | CreatedTime

  let str_to_t =
    [ "CreatedTime", CreatedTime; "Status", Status; "ExecutionId", ExecutionId ]

  let t_to_str =
    [ CreatedTime, "CreatedTime"; Status, "Status"; ExecutionId, "ExecutionId" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module AssociationExecutionFilter = struct
  type t =
    { key : AssociationExecutionFilterKey.t
    ; value : String.t
    ; type_ : AssociationFilterOperatorType.t
    }

  let make ~key ~value ~type_ () = { key; value; type_ }

  let parse xml =
    Some
      { key =
          Aws.Xml.required
            "Key"
            (Aws.Util.option_bind
               (Aws.Xml.member "Key" xml)
               AssociationExecutionFilterKey.parse)
      ; value =
          Aws.Xml.required
            "Value"
            (Aws.Util.option_bind (Aws.Xml.member "Value" xml) String.parse)
      ; type_ =
          Aws.Xml.required
            "Type"
            (Aws.Util.option_bind
               (Aws.Xml.member "Type" xml)
               AssociationFilterOperatorType.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Type", AssociationFilterOperatorType.to_query v.type_))
         ; Some (Aws.Query.Pair ("Value", String.to_query v.value))
         ; Some (Aws.Query.Pair ("Key", AssociationExecutionFilterKey.to_query v.key))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Type", AssociationFilterOperatorType.to_json v.type_)
         ; Some ("Value", String.to_json v.value)
         ; Some ("Key", AssociationExecutionFilterKey.to_json v.key)
         ])

  let of_json j =
    { key =
        AssociationExecutionFilterKey.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Key"))
    ; value = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Value"))
    ; type_ =
        AssociationFilterOperatorType.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Type"))
    }
end

module AssociationExecutionFilterList = struct
  type t = AssociationExecutionFilter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map AssociationExecutionFilter.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list AssociationExecutionFilter.to_query v
  let to_json v = `List (List.map AssociationExecutionFilter.to_json v)
  let of_json j = Aws.Json.to_list AssociationExecutionFilter.of_json j
end

module UnsupportedInventorySchemaVersionException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module DoesNotExistException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module GetOpsItemRequest = struct
  type t = { ops_item_id : String.t }

  let make ~ops_item_id () = { ops_item_id }

  let parse xml =
    Some
      { ops_item_id =
          Aws.Xml.required
            "OpsItemId"
            (Aws.Util.option_bind (Aws.Xml.member "OpsItemId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("OpsItemId", String.to_query v.ops_item_id)) ])

  let to_json v =
    `Assoc (Aws.Util.list_filter_opt [ Some ("OpsItemId", String.to_json v.ops_item_id) ])

  let of_json j =
    { ops_item_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "OpsItemId"))
    }
end

module Regions = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module Accounts = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module TargetLocation = struct
  type t =
    { accounts : Accounts.t
    ; regions : Regions.t
    ; target_location_max_concurrency : String.t option
    ; target_location_max_errors : String.t option
    ; execution_role_name : String.t option
    }

  let make
      ?(accounts = [])
      ?(regions = [])
      ?target_location_max_concurrency
      ?target_location_max_errors
      ?execution_role_name
      () =
    { accounts
    ; regions
    ; target_location_max_concurrency
    ; target_location_max_errors
    ; execution_role_name
    }

  let parse xml =
    Some
      { accounts =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Accounts" xml) Accounts.parse)
      ; regions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Regions" xml) Regions.parse)
      ; target_location_max_concurrency =
          Aws.Util.option_bind
            (Aws.Xml.member "TargetLocationMaxConcurrency" xml)
            String.parse
      ; target_location_max_errors =
          Aws.Util.option_bind (Aws.Xml.member "TargetLocationMaxErrors" xml) String.parse
      ; execution_role_name =
          Aws.Util.option_bind (Aws.Xml.member "ExecutionRoleName" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.execution_role_name (fun f ->
               Aws.Query.Pair ("ExecutionRoleName", String.to_query f))
         ; Aws.Util.option_map v.target_location_max_errors (fun f ->
               Aws.Query.Pair ("TargetLocationMaxErrors", String.to_query f))
         ; Aws.Util.option_map v.target_location_max_concurrency (fun f ->
               Aws.Query.Pair ("TargetLocationMaxConcurrency", String.to_query f))
         ; Some (Aws.Query.Pair ("Regions.member", Regions.to_query v.regions))
         ; Some (Aws.Query.Pair ("Accounts.member", Accounts.to_query v.accounts))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.execution_role_name (fun f ->
               "ExecutionRoleName", String.to_json f)
         ; Aws.Util.option_map v.target_location_max_errors (fun f ->
               "TargetLocationMaxErrors", String.to_json f)
         ; Aws.Util.option_map v.target_location_max_concurrency (fun f ->
               "TargetLocationMaxConcurrency", String.to_json f)
         ; Some ("Regions", Regions.to_json v.regions)
         ; Some ("Accounts", Accounts.to_json v.accounts)
         ])

  let of_json j =
    { accounts = Accounts.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Accounts"))
    ; regions = Regions.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Regions"))
    ; target_location_max_concurrency =
        Aws.Util.option_map
          (Aws.Json.lookup j "TargetLocationMaxConcurrency")
          String.of_json
    ; target_location_max_errors =
        Aws.Util.option_map (Aws.Json.lookup j "TargetLocationMaxErrors") String.of_json
    ; execution_role_name =
        Aws.Util.option_map (Aws.Json.lookup j "ExecutionRoleName") String.of_json
    }
end

module TargetLocations = struct
  type t = TargetLocation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map TargetLocation.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list TargetLocation.to_query v
  let to_json v = `List (List.map TargetLocation.to_json v)
  let of_json j = Aws.Json.to_list TargetLocation.of_json j
end

module StringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module InstanceAssociationStatusAggregatedCount = struct
  type t = (String.t, Integer.t) Hashtbl.t

  let make elems () = elems
  let parse xml = None
  let to_query v = Aws.Query.to_query_hashtbl String.to_string Integer.to_query v

  let to_json v =
    `Assoc
      (Hashtbl.fold (fun k v acc -> (String.to_string k, Integer.to_json v) :: acc) v [])

  let of_json j = Aws.Json.to_hashtbl String.of_string Integer.of_json j
end

module ResourceDataSyncSourceRegionList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module ResourceDataSyncOrganizationalUnit = struct
  type t = { organizational_unit_id : String.t option }

  let make ?organizational_unit_id () = { organizational_unit_id }

  let parse xml =
    Some
      { organizational_unit_id =
          Aws.Util.option_bind (Aws.Xml.member "OrganizationalUnitId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.organizational_unit_id (fun f ->
               Aws.Query.Pair ("OrganizationalUnitId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.organizational_unit_id (fun f ->
               "OrganizationalUnitId", String.to_json f)
         ])

  let of_json j =
    { organizational_unit_id =
        Aws.Util.option_map (Aws.Json.lookup j "OrganizationalUnitId") String.of_json
    }
end

module ResourceDataSyncOrganizationalUnitList = struct
  type t = ResourceDataSyncOrganizationalUnit.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ResourceDataSyncOrganizationalUnit.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list ResourceDataSyncOrganizationalUnit.to_query v
  let to_json v = `List (List.map ResourceDataSyncOrganizationalUnit.to_json v)
  let of_json j = Aws.Json.to_list ResourceDataSyncOrganizationalUnit.of_json j
end

module ResourceDataSyncAwsOrganizationsSource = struct
  type t =
    { organization_source_type : String.t
    ; organizational_units : ResourceDataSyncOrganizationalUnitList.t
    }

  let make ~organization_source_type ?(organizational_units = []) () =
    { organization_source_type; organizational_units }

  let parse xml =
    Some
      { organization_source_type =
          Aws.Xml.required
            "OrganizationSourceType"
            (Aws.Util.option_bind
               (Aws.Xml.member "OrganizationSourceType" xml)
               String.parse)
      ; organizational_units =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "OrganizationalUnits" xml)
               ResourceDataSyncOrganizationalUnitList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "OrganizationalUnits.member"
                , ResourceDataSyncOrganizationalUnitList.to_query v.organizational_units
                ))
         ; Some
             (Aws.Query.Pair
                ("OrganizationSourceType", String.to_query v.organization_source_type))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "OrganizationalUnits"
             , ResourceDataSyncOrganizationalUnitList.to_json v.organizational_units )
         ; Some ("OrganizationSourceType", String.to_json v.organization_source_type)
         ])

  let of_json j =
    { organization_source_type =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "OrganizationSourceType"))
    ; organizational_units =
        ResourceDataSyncOrganizationalUnitList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "OrganizationalUnits"))
    }
end

module ResourceDataSyncSourceWithState = struct
  type t =
    { source_type : String.t option
    ; aws_organizations_source : ResourceDataSyncAwsOrganizationsSource.t option
    ; source_regions : ResourceDataSyncSourceRegionList.t
    ; include_future_regions : Boolean.t option
    ; state : String.t option
    }

  let make
      ?source_type
      ?aws_organizations_source
      ?(source_regions = [])
      ?include_future_regions
      ?state
      () =
    { source_type
    ; aws_organizations_source
    ; source_regions
    ; include_future_regions
    ; state
    }

  let parse xml =
    Some
      { source_type = Aws.Util.option_bind (Aws.Xml.member "SourceType" xml) String.parse
      ; aws_organizations_source =
          Aws.Util.option_bind
            (Aws.Xml.member "AwsOrganizationsSource" xml)
            ResourceDataSyncAwsOrganizationsSource.parse
      ; source_regions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SourceRegions" xml)
               ResourceDataSyncSourceRegionList.parse)
      ; include_future_regions =
          Aws.Util.option_bind (Aws.Xml.member "IncludeFutureRegions" xml) Boolean.parse
      ; state = Aws.Util.option_bind (Aws.Xml.member "State" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", String.to_query f))
         ; Aws.Util.option_map v.include_future_regions (fun f ->
               Aws.Query.Pair ("IncludeFutureRegions", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "SourceRegions.member"
                , ResourceDataSyncSourceRegionList.to_query v.source_regions ))
         ; Aws.Util.option_map v.aws_organizations_source (fun f ->
               Aws.Query.Pair
                 ( "AwsOrganizationsSource"
                 , ResourceDataSyncAwsOrganizationsSource.to_query f ))
         ; Aws.Util.option_map v.source_type (fun f ->
               Aws.Query.Pair ("SourceType", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f -> "State", String.to_json f)
         ; Aws.Util.option_map v.include_future_regions (fun f ->
               "IncludeFutureRegions", Boolean.to_json f)
         ; Some
             ("SourceRegions", ResourceDataSyncSourceRegionList.to_json v.source_regions)
         ; Aws.Util.option_map v.aws_organizations_source (fun f ->
               "AwsOrganizationsSource", ResourceDataSyncAwsOrganizationsSource.to_json f)
         ; Aws.Util.option_map v.source_type (fun f -> "SourceType", String.to_json f)
         ])

  let of_json j =
    { source_type = Aws.Util.option_map (Aws.Json.lookup j "SourceType") String.of_json
    ; aws_organizations_source =
        Aws.Util.option_map
          (Aws.Json.lookup j "AwsOrganizationsSource")
          ResourceDataSyncAwsOrganizationsSource.of_json
    ; source_regions =
        ResourceDataSyncSourceRegionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceRegions"))
    ; include_future_regions =
        Aws.Util.option_map (Aws.Json.lookup j "IncludeFutureRegions") Boolean.of_json
    ; state = Aws.Util.option_map (Aws.Json.lookup j "State") String.of_json
    }
end

module LastResourceDataSyncStatus = struct
  type t =
    | Successful
    | Failed
    | InProgress

  let str_to_t = [ "InProgress", InProgress; "Failed", Failed; "Successful", Successful ]
  let t_to_str = [ InProgress, "InProgress"; Failed, "Failed"; Successful, "Successful" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ResourceDataSyncItem = struct
  type t =
    { sync_name : String.t option
    ; sync_type : String.t option
    ; sync_source : ResourceDataSyncSourceWithState.t option
    ; s3_destination : ResourceDataSyncS3Destination.t option
    ; last_sync_time : DateTime.t option
    ; last_successful_sync_time : DateTime.t option
    ; sync_last_modified_time : DateTime.t option
    ; last_status : LastResourceDataSyncStatus.t option
    ; sync_created_time : DateTime.t option
    ; last_sync_status_message : String.t option
    }

  let make
      ?sync_name
      ?sync_type
      ?sync_source
      ?s3_destination
      ?last_sync_time
      ?last_successful_sync_time
      ?sync_last_modified_time
      ?last_status
      ?sync_created_time
      ?last_sync_status_message
      () =
    { sync_name
    ; sync_type
    ; sync_source
    ; s3_destination
    ; last_sync_time
    ; last_successful_sync_time
    ; sync_last_modified_time
    ; last_status
    ; sync_created_time
    ; last_sync_status_message
    }

  let parse xml =
    Some
      { sync_name = Aws.Util.option_bind (Aws.Xml.member "SyncName" xml) String.parse
      ; sync_type = Aws.Util.option_bind (Aws.Xml.member "SyncType" xml) String.parse
      ; sync_source =
          Aws.Util.option_bind
            (Aws.Xml.member "SyncSource" xml)
            ResourceDataSyncSourceWithState.parse
      ; s3_destination =
          Aws.Util.option_bind
            (Aws.Xml.member "S3Destination" xml)
            ResourceDataSyncS3Destination.parse
      ; last_sync_time =
          Aws.Util.option_bind (Aws.Xml.member "LastSyncTime" xml) DateTime.parse
      ; last_successful_sync_time =
          Aws.Util.option_bind
            (Aws.Xml.member "LastSuccessfulSyncTime" xml)
            DateTime.parse
      ; sync_last_modified_time =
          Aws.Util.option_bind (Aws.Xml.member "SyncLastModifiedTime" xml) DateTime.parse
      ; last_status =
          Aws.Util.option_bind
            (Aws.Xml.member "LastStatus" xml)
            LastResourceDataSyncStatus.parse
      ; sync_created_time =
          Aws.Util.option_bind (Aws.Xml.member "SyncCreatedTime" xml) DateTime.parse
      ; last_sync_status_message =
          Aws.Util.option_bind (Aws.Xml.member "LastSyncStatusMessage" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.last_sync_status_message (fun f ->
               Aws.Query.Pair ("LastSyncStatusMessage", String.to_query f))
         ; Aws.Util.option_map v.sync_created_time (fun f ->
               Aws.Query.Pair ("SyncCreatedTime", DateTime.to_query f))
         ; Aws.Util.option_map v.last_status (fun f ->
               Aws.Query.Pair ("LastStatus", LastResourceDataSyncStatus.to_query f))
         ; Aws.Util.option_map v.sync_last_modified_time (fun f ->
               Aws.Query.Pair ("SyncLastModifiedTime", DateTime.to_query f))
         ; Aws.Util.option_map v.last_successful_sync_time (fun f ->
               Aws.Query.Pair ("LastSuccessfulSyncTime", DateTime.to_query f))
         ; Aws.Util.option_map v.last_sync_time (fun f ->
               Aws.Query.Pair ("LastSyncTime", DateTime.to_query f))
         ; Aws.Util.option_map v.s3_destination (fun f ->
               Aws.Query.Pair ("S3Destination", ResourceDataSyncS3Destination.to_query f))
         ; Aws.Util.option_map v.sync_source (fun f ->
               Aws.Query.Pair ("SyncSource", ResourceDataSyncSourceWithState.to_query f))
         ; Aws.Util.option_map v.sync_type (fun f ->
               Aws.Query.Pair ("SyncType", String.to_query f))
         ; Aws.Util.option_map v.sync_name (fun f ->
               Aws.Query.Pair ("SyncName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.last_sync_status_message (fun f ->
               "LastSyncStatusMessage", String.to_json f)
         ; Aws.Util.option_map v.sync_created_time (fun f ->
               "SyncCreatedTime", DateTime.to_json f)
         ; Aws.Util.option_map v.last_status (fun f ->
               "LastStatus", LastResourceDataSyncStatus.to_json f)
         ; Aws.Util.option_map v.sync_last_modified_time (fun f ->
               "SyncLastModifiedTime", DateTime.to_json f)
         ; Aws.Util.option_map v.last_successful_sync_time (fun f ->
               "LastSuccessfulSyncTime", DateTime.to_json f)
         ; Aws.Util.option_map v.last_sync_time (fun f ->
               "LastSyncTime", DateTime.to_json f)
         ; Aws.Util.option_map v.s3_destination (fun f ->
               "S3Destination", ResourceDataSyncS3Destination.to_json f)
         ; Aws.Util.option_map v.sync_source (fun f ->
               "SyncSource", ResourceDataSyncSourceWithState.to_json f)
         ; Aws.Util.option_map v.sync_type (fun f -> "SyncType", String.to_json f)
         ; Aws.Util.option_map v.sync_name (fun f -> "SyncName", String.to_json f)
         ])

  let of_json j =
    { sync_name = Aws.Util.option_map (Aws.Json.lookup j "SyncName") String.of_json
    ; sync_type = Aws.Util.option_map (Aws.Json.lookup j "SyncType") String.of_json
    ; sync_source =
        Aws.Util.option_map
          (Aws.Json.lookup j "SyncSource")
          ResourceDataSyncSourceWithState.of_json
    ; s3_destination =
        Aws.Util.option_map
          (Aws.Json.lookup j "S3Destination")
          ResourceDataSyncS3Destination.of_json
    ; last_sync_time =
        Aws.Util.option_map (Aws.Json.lookup j "LastSyncTime") DateTime.of_json
    ; last_successful_sync_time =
        Aws.Util.option_map (Aws.Json.lookup j "LastSuccessfulSyncTime") DateTime.of_json
    ; sync_last_modified_time =
        Aws.Util.option_map (Aws.Json.lookup j "SyncLastModifiedTime") DateTime.of_json
    ; last_status =
        Aws.Util.option_map
          (Aws.Json.lookup j "LastStatus")
          LastResourceDataSyncStatus.of_json
    ; sync_created_time =
        Aws.Util.option_map (Aws.Json.lookup j "SyncCreatedTime") DateTime.of_json
    ; last_sync_status_message =
        Aws.Util.option_map (Aws.Json.lookup j "LastSyncStatusMessage") String.of_json
    }
end

module ResourceDataSyncItemList = struct
  type t = ResourceDataSyncItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ResourceDataSyncItem.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list ResourceDataSyncItem.to_query v
  let to_json v = `List (List.map ResourceDataSyncItem.to_json v)
  let of_json j = Aws.Json.to_list ResourceDataSyncItem.of_json j
end

module ListResourceDataSyncResult = struct
  type t =
    { resource_data_sync_items : ResourceDataSyncItemList.t
    ; next_token : String.t option
    }

  let make ?(resource_data_sync_items = []) ?next_token () =
    { resource_data_sync_items; next_token }

  let parse xml =
    Some
      { resource_data_sync_items =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ResourceDataSyncItems" xml)
               ResourceDataSyncItemList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ResourceDataSyncItems.member"
                , ResourceDataSyncItemList.to_query v.resource_data_sync_items ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some
             ( "ResourceDataSyncItems"
             , ResourceDataSyncItemList.to_json v.resource_data_sync_items )
         ])

  let of_json j =
    { resource_data_sync_items =
        ResourceDataSyncItemList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ResourceDataSyncItems"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module ResumeSessionRequest = struct
  type t = { session_id : String.t }

  let make ~session_id () = { session_id }

  let parse xml =
    Some
      { session_id =
          Aws.Xml.required
            "SessionId"
            (Aws.Util.option_bind (Aws.Xml.member "SessionId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("SessionId", String.to_query v.session_id)) ])

  let to_json v =
    `Assoc (Aws.Util.list_filter_opt [ Some ("SessionId", String.to_json v.session_id) ])

  let of_json j =
    { session_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SessionId"))
    }
end

module GetMaintenanceWindowExecutionRequest = struct
  type t = { window_execution_id : String.t }

  let make ~window_execution_id () = { window_execution_id }

  let parse xml =
    Some
      { window_execution_id =
          Aws.Xml.required
            "WindowExecutionId"
            (Aws.Util.option_bind (Aws.Xml.member "WindowExecutionId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("WindowExecutionId", String.to_query v.window_execution_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("WindowExecutionId", String.to_json v.window_execution_id) ])

  let of_json j =
    { window_execution_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowExecutionId"))
    }
end

module DocumentType = struct
  type t =
    | Command
    | Policy
    | Automation
    | Session
    | Package
    | ApplicationConfiguration
    | ApplicationConfigurationSchema
    | DeploymentStrategy
    | ChangeCalendar

  let str_to_t =
    [ "ChangeCalendar", ChangeCalendar
    ; "DeploymentStrategy", DeploymentStrategy
    ; "ApplicationConfigurationSchema", ApplicationConfigurationSchema
    ; "ApplicationConfiguration", ApplicationConfiguration
    ; "Package", Package
    ; "Session", Session
    ; "Automation", Automation
    ; "Policy", Policy
    ; "Command", Command
    ]

  let t_to_str =
    [ ChangeCalendar, "ChangeCalendar"
    ; DeploymentStrategy, "DeploymentStrategy"
    ; ApplicationConfigurationSchema, "ApplicationConfigurationSchema"
    ; ApplicationConfiguration, "ApplicationConfiguration"
    ; Package, "Package"
    ; Session, "Session"
    ; Automation, "Automation"
    ; Policy, "Policy"
    ; Command, "Command"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DocumentRequires = struct
  type t =
    { name : String.t
    ; version : String.t option
    }

  let make ~name ?version () = { name; version }

  let parse xml =
    Some
      { name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      ; version = Aws.Util.option_bind (Aws.Xml.member "Version" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.version (fun f ->
               Aws.Query.Pair ("Version", String.to_query f))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.version (fun f -> "Version", String.to_json f)
         ; Some ("Name", String.to_json v.name)
         ])

  let of_json j =
    { name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; version = Aws.Util.option_map (Aws.Json.lookup j "Version") String.of_json
    }
end

module DocumentRequiresList = struct
  type t = DocumentRequires.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map DocumentRequires.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list DocumentRequires.to_query v
  let to_json v = `List (List.map DocumentRequires.to_json v)
  let of_json j = Aws.Json.to_list DocumentRequires.of_json j
end

module AttachmentContentList = struct
  type t = AttachmentContent.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map AttachmentContent.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list AttachmentContent.to_query v
  let to_json v = `List (List.map AttachmentContent.to_json v)
  let of_json j = Aws.Json.to_list AttachmentContent.of_json j
end

module GetDocumentResult = struct
  type t =
    { name : String.t option
    ; version_name : String.t option
    ; document_version : String.t option
    ; status : DocumentStatus.t option
    ; status_information : String.t option
    ; content : String.t option
    ; document_type : DocumentType.t option
    ; document_format : DocumentFormat.t option
    ; requires : DocumentRequiresList.t
    ; attachments_content : AttachmentContentList.t
    }

  let make
      ?name
      ?version_name
      ?document_version
      ?status
      ?status_information
      ?content
      ?document_type
      ?document_format
      ?(requires = [])
      ?(attachments_content = [])
      () =
    { name
    ; version_name
    ; document_version
    ; status
    ; status_information
    ; content
    ; document_type
    ; document_format
    ; requires
    ; attachments_content
    }

  let parse xml =
    Some
      { name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; version_name =
          Aws.Util.option_bind (Aws.Xml.member "VersionName" xml) String.parse
      ; document_version =
          Aws.Util.option_bind (Aws.Xml.member "DocumentVersion" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) DocumentStatus.parse
      ; status_information =
          Aws.Util.option_bind (Aws.Xml.member "StatusInformation" xml) String.parse
      ; content = Aws.Util.option_bind (Aws.Xml.member "Content" xml) String.parse
      ; document_type =
          Aws.Util.option_bind (Aws.Xml.member "DocumentType" xml) DocumentType.parse
      ; document_format =
          Aws.Util.option_bind (Aws.Xml.member "DocumentFormat" xml) DocumentFormat.parse
      ; requires =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Requires" xml)
               DocumentRequiresList.parse)
      ; attachments_content =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AttachmentsContent" xml)
               AttachmentContentList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "AttachmentsContent.member"
                , AttachmentContentList.to_query v.attachments_content ))
         ; Some
             (Aws.Query.Pair ("Requires.member", DocumentRequiresList.to_query v.requires))
         ; Aws.Util.option_map v.document_format (fun f ->
               Aws.Query.Pair ("DocumentFormat", DocumentFormat.to_query f))
         ; Aws.Util.option_map v.document_type (fun f ->
               Aws.Query.Pair ("DocumentType", DocumentType.to_query f))
         ; Aws.Util.option_map v.content (fun f ->
               Aws.Query.Pair ("Content", String.to_query f))
         ; Aws.Util.option_map v.status_information (fun f ->
               Aws.Query.Pair ("StatusInformation", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", DocumentStatus.to_query f))
         ; Aws.Util.option_map v.document_version (fun f ->
               Aws.Query.Pair ("DocumentVersion", String.to_query f))
         ; Aws.Util.option_map v.version_name (fun f ->
               Aws.Query.Pair ("VersionName", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("AttachmentsContent", AttachmentContentList.to_json v.attachments_content)
         ; Some ("Requires", DocumentRequiresList.to_json v.requires)
         ; Aws.Util.option_map v.document_format (fun f ->
               "DocumentFormat", DocumentFormat.to_json f)
         ; Aws.Util.option_map v.document_type (fun f ->
               "DocumentType", DocumentType.to_json f)
         ; Aws.Util.option_map v.content (fun f -> "Content", String.to_json f)
         ; Aws.Util.option_map v.status_information (fun f ->
               "StatusInformation", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", DocumentStatus.to_json f)
         ; Aws.Util.option_map v.document_version (fun f ->
               "DocumentVersion", String.to_json f)
         ; Aws.Util.option_map v.version_name (fun f -> "VersionName", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ])

  let of_json j =
    { name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; version_name = Aws.Util.option_map (Aws.Json.lookup j "VersionName") String.of_json
    ; document_version =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentVersion") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") DocumentStatus.of_json
    ; status_information =
        Aws.Util.option_map (Aws.Json.lookup j "StatusInformation") String.of_json
    ; content = Aws.Util.option_map (Aws.Json.lookup j "Content") String.of_json
    ; document_type =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentType") DocumentType.of_json
    ; document_format =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentFormat") DocumentFormat.of_json
    ; requires =
        DocumentRequiresList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Requires"))
    ; attachments_content =
        AttachmentContentList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AttachmentsContent"))
    }
end

module S3OutputUrl = struct
  type t = { output_url : String.t option }

  let make ?output_url () = { output_url }

  let parse xml =
    Some
      { output_url = Aws.Util.option_bind (Aws.Xml.member "OutputUrl" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.output_url (fun f ->
               Aws.Query.Pair ("OutputUrl", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.output_url (fun f -> "OutputUrl", String.to_json f) ])

  let of_json j =
    { output_url = Aws.Util.option_map (Aws.Json.lookup j "OutputUrl") String.of_json }
end

module PatchSourceList = struct
  type t = PatchSource.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map PatchSource.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list PatchSource.to_query v
  let to_json v = `List (List.map PatchSource.to_json v)
  let of_json j = Aws.Json.to_list PatchSource.of_json j
end

module PatchFilterValueList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module PatchFilterKey = struct
  type t =
    | ARCH
    | ADVISORY_ID
    | BUGZILLA_ID
    | PATCH_SET
    | PRODUCT
    | PRODUCT_FAMILY
    | CLASSIFICATION
    | CVE_ID
    | EPOCH
    | MSRC_SEVERITY
    | NAME
    | PATCH_ID
    | SECTION
    | PRIORITY
    | REPOSITORY
    | RELEASE
    | SEVERITY
    | SECURITY
    | VERSION

  let str_to_t =
    [ "VERSION", VERSION
    ; "SECURITY", SECURITY
    ; "SEVERITY", SEVERITY
    ; "RELEASE", RELEASE
    ; "REPOSITORY", REPOSITORY
    ; "PRIORITY", PRIORITY
    ; "SECTION", SECTION
    ; "PATCH_ID", PATCH_ID
    ; "NAME", NAME
    ; "MSRC_SEVERITY", MSRC_SEVERITY
    ; "EPOCH", EPOCH
    ; "CVE_ID", CVE_ID
    ; "CLASSIFICATION", CLASSIFICATION
    ; "PRODUCT_FAMILY", PRODUCT_FAMILY
    ; "PRODUCT", PRODUCT
    ; "PATCH_SET", PATCH_SET
    ; "BUGZILLA_ID", BUGZILLA_ID
    ; "ADVISORY_ID", ADVISORY_ID
    ; "ARCH", ARCH
    ]

  let t_to_str =
    [ VERSION, "VERSION"
    ; SECURITY, "SECURITY"
    ; SEVERITY, "SEVERITY"
    ; RELEASE, "RELEASE"
    ; REPOSITORY, "REPOSITORY"
    ; PRIORITY, "PRIORITY"
    ; SECTION, "SECTION"
    ; PATCH_ID, "PATCH_ID"
    ; NAME, "NAME"
    ; MSRC_SEVERITY, "MSRC_SEVERITY"
    ; EPOCH, "EPOCH"
    ; CVE_ID, "CVE_ID"
    ; CLASSIFICATION, "CLASSIFICATION"
    ; PRODUCT_FAMILY, "PRODUCT_FAMILY"
    ; PRODUCT, "PRODUCT"
    ; PATCH_SET, "PATCH_SET"
    ; BUGZILLA_ID, "BUGZILLA_ID"
    ; ADVISORY_ID, "ADVISORY_ID"
    ; ARCH, "ARCH"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module PatchFilter = struct
  type t =
    { key : PatchFilterKey.t
    ; values : PatchFilterValueList.t
    }

  let make ~key ~values () = { key; values }

  let parse xml =
    Some
      { key =
          Aws.Xml.required
            "Key"
            (Aws.Util.option_bind (Aws.Xml.member "Key" xml) PatchFilterKey.parse)
      ; values =
          Aws.Xml.required
            "Values"
            (Aws.Util.option_bind
               (Aws.Xml.member "Values" xml)
               PatchFilterValueList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Values.member", PatchFilterValueList.to_query v.values))
         ; Some (Aws.Query.Pair ("Key", PatchFilterKey.to_query v.key))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Values", PatchFilterValueList.to_json v.values)
         ; Some ("Key", PatchFilterKey.to_json v.key)
         ])

  let of_json j =
    { key = PatchFilterKey.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Key"))
    ; values =
        PatchFilterValueList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Values"))
    }
end

module PatchFilterList = struct
  type t = PatchFilter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map PatchFilter.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list PatchFilter.to_query v
  let to_json v = `List (List.map PatchFilter.to_json v)
  let of_json j = Aws.Json.to_list PatchFilter.of_json j
end

module PatchFilterGroup = struct
  type t = { patch_filters : PatchFilterList.t }

  let make ~patch_filters () = { patch_filters }

  let parse xml =
    Some
      { patch_filters =
          Aws.Xml.required
            "PatchFilters"
            (Aws.Util.option_bind
               (Aws.Xml.member "PatchFilters" xml)
               PatchFilterList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("PatchFilters.member", PatchFilterList.to_query v.patch_filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("PatchFilters", PatchFilterList.to_json v.patch_filters) ])

  let of_json j =
    { patch_filters =
        PatchFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "PatchFilters"))
    }
end

module PatchComplianceLevel = struct
  type t =
    | CRITICAL
    | HIGH
    | MEDIUM
    | LOW
    | INFORMATIONAL
    | UNSPECIFIED

  let str_to_t =
    [ "UNSPECIFIED", UNSPECIFIED
    ; "INFORMATIONAL", INFORMATIONAL
    ; "LOW", LOW
    ; "MEDIUM", MEDIUM
    ; "HIGH", HIGH
    ; "CRITICAL", CRITICAL
    ]

  let t_to_str =
    [ UNSPECIFIED, "UNSPECIFIED"
    ; INFORMATIONAL, "INFORMATIONAL"
    ; LOW, "LOW"
    ; MEDIUM, "MEDIUM"
    ; HIGH, "HIGH"
    ; CRITICAL, "CRITICAL"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module PatchRule = struct
  type t =
    { patch_filter_group : PatchFilterGroup.t
    ; compliance_level : PatchComplianceLevel.t option
    ; approve_after_days : Integer.t option
    ; approve_until_date : String.t option
    ; enable_non_security : Boolean.t option
    }

  let make
      ~patch_filter_group
      ?compliance_level
      ?approve_after_days
      ?approve_until_date
      ?enable_non_security
      () =
    { patch_filter_group
    ; compliance_level
    ; approve_after_days
    ; approve_until_date
    ; enable_non_security
    }

  let parse xml =
    Some
      { patch_filter_group =
          Aws.Xml.required
            "PatchFilterGroup"
            (Aws.Util.option_bind
               (Aws.Xml.member "PatchFilterGroup" xml)
               PatchFilterGroup.parse)
      ; compliance_level =
          Aws.Util.option_bind
            (Aws.Xml.member "ComplianceLevel" xml)
            PatchComplianceLevel.parse
      ; approve_after_days =
          Aws.Util.option_bind (Aws.Xml.member "ApproveAfterDays" xml) Integer.parse
      ; approve_until_date =
          Aws.Util.option_bind (Aws.Xml.member "ApproveUntilDate" xml) String.parse
      ; enable_non_security =
          Aws.Util.option_bind (Aws.Xml.member "EnableNonSecurity" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enable_non_security (fun f ->
               Aws.Query.Pair ("EnableNonSecurity", Boolean.to_query f))
         ; Aws.Util.option_map v.approve_until_date (fun f ->
               Aws.Query.Pair ("ApproveUntilDate", String.to_query f))
         ; Aws.Util.option_map v.approve_after_days (fun f ->
               Aws.Query.Pair ("ApproveAfterDays", Integer.to_query f))
         ; Aws.Util.option_map v.compliance_level (fun f ->
               Aws.Query.Pair ("ComplianceLevel", PatchComplianceLevel.to_query f))
         ; Some
             (Aws.Query.Pair
                ("PatchFilterGroup", PatchFilterGroup.to_query v.patch_filter_group))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enable_non_security (fun f ->
               "EnableNonSecurity", Boolean.to_json f)
         ; Aws.Util.option_map v.approve_until_date (fun f ->
               "ApproveUntilDate", String.to_json f)
         ; Aws.Util.option_map v.approve_after_days (fun f ->
               "ApproveAfterDays", Integer.to_json f)
         ; Aws.Util.option_map v.compliance_level (fun f ->
               "ComplianceLevel", PatchComplianceLevel.to_json f)
         ; Some ("PatchFilterGroup", PatchFilterGroup.to_json v.patch_filter_group)
         ])

  let of_json j =
    { patch_filter_group =
        PatchFilterGroup.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "PatchFilterGroup"))
    ; compliance_level =
        Aws.Util.option_map
          (Aws.Json.lookup j "ComplianceLevel")
          PatchComplianceLevel.of_json
    ; approve_after_days =
        Aws.Util.option_map (Aws.Json.lookup j "ApproveAfterDays") Integer.of_json
    ; approve_until_date =
        Aws.Util.option_map (Aws.Json.lookup j "ApproveUntilDate") String.of_json
    ; enable_non_security =
        Aws.Util.option_map (Aws.Json.lookup j "EnableNonSecurity") Boolean.of_json
    }
end

module PatchRuleList = struct
  type t = PatchRule.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map PatchRule.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list PatchRule.to_query v
  let to_json v = `List (List.map PatchRule.to_json v)
  let of_json j = Aws.Json.to_list PatchRule.of_json j
end

module PatchRuleGroup = struct
  type t = { patch_rules : PatchRuleList.t }

  let make ~patch_rules () = { patch_rules }

  let parse xml =
    Some
      { patch_rules =
          Aws.Xml.required
            "PatchRules"
            (Aws.Util.option_bind (Aws.Xml.member "PatchRules" xml) PatchRuleList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("PatchRules.member", PatchRuleList.to_query v.patch_rules))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("PatchRules", PatchRuleList.to_json v.patch_rules) ])

  let of_json j =
    { patch_rules =
        PatchRuleList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PatchRules"))
    }
end

module PatchIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module PatchGroupList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module PatchAction = struct
  type t =
    | ALLOW_AS_DEPENDENCY
    | BLOCK

  let str_to_t = [ "BLOCK", BLOCK; "ALLOW_AS_DEPENDENCY", ALLOW_AS_DEPENDENCY ]
  let t_to_str = [ BLOCK, "BLOCK"; ALLOW_AS_DEPENDENCY, "ALLOW_AS_DEPENDENCY" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module GetPatchBaselineResult = struct
  type t =
    { baseline_id : String.t option
    ; name : String.t option
    ; operating_system : OperatingSystem.t option
    ; global_filters : PatchFilterGroup.t option
    ; approval_rules : PatchRuleGroup.t option
    ; approved_patches : PatchIdList.t
    ; approved_patches_compliance_level : PatchComplianceLevel.t option
    ; approved_patches_enable_non_security : Boolean.t option
    ; rejected_patches : PatchIdList.t
    ; rejected_patches_action : PatchAction.t option
    ; patch_groups : PatchGroupList.t
    ; created_date : DateTime.t option
    ; modified_date : DateTime.t option
    ; description : String.t option
    ; sources : PatchSourceList.t
    }

  let make
      ?baseline_id
      ?name
      ?operating_system
      ?global_filters
      ?approval_rules
      ?(approved_patches = [])
      ?approved_patches_compliance_level
      ?approved_patches_enable_non_security
      ?(rejected_patches = [])
      ?rejected_patches_action
      ?(patch_groups = [])
      ?created_date
      ?modified_date
      ?description
      ?(sources = [])
      () =
    { baseline_id
    ; name
    ; operating_system
    ; global_filters
    ; approval_rules
    ; approved_patches
    ; approved_patches_compliance_level
    ; approved_patches_enable_non_security
    ; rejected_patches
    ; rejected_patches_action
    ; patch_groups
    ; created_date
    ; modified_date
    ; description
    ; sources
    }

  let parse xml =
    Some
      { baseline_id = Aws.Util.option_bind (Aws.Xml.member "BaselineId" xml) String.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; operating_system =
          Aws.Util.option_bind
            (Aws.Xml.member "OperatingSystem" xml)
            OperatingSystem.parse
      ; global_filters =
          Aws.Util.option_bind (Aws.Xml.member "GlobalFilters" xml) PatchFilterGroup.parse
      ; approval_rules =
          Aws.Util.option_bind (Aws.Xml.member "ApprovalRules" xml) PatchRuleGroup.parse
      ; approved_patches =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ApprovedPatches" xml)
               PatchIdList.parse)
      ; approved_patches_compliance_level =
          Aws.Util.option_bind
            (Aws.Xml.member "ApprovedPatchesComplianceLevel" xml)
            PatchComplianceLevel.parse
      ; approved_patches_enable_non_security =
          Aws.Util.option_bind
            (Aws.Xml.member "ApprovedPatchesEnableNonSecurity" xml)
            Boolean.parse
      ; rejected_patches =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "RejectedPatches" xml)
               PatchIdList.parse)
      ; rejected_patches_action =
          Aws.Util.option_bind
            (Aws.Xml.member "RejectedPatchesAction" xml)
            PatchAction.parse
      ; patch_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "PatchGroups" xml) PatchGroupList.parse)
      ; created_date =
          Aws.Util.option_bind (Aws.Xml.member "CreatedDate" xml) DateTime.parse
      ; modified_date =
          Aws.Util.option_bind (Aws.Xml.member "ModifiedDate" xml) DateTime.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; sources =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Sources" xml) PatchSourceList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Sources.member", PatchSourceList.to_query v.sources))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.modified_date (fun f ->
               Aws.Query.Pair ("ModifiedDate", DateTime.to_query f))
         ; Aws.Util.option_map v.created_date (fun f ->
               Aws.Query.Pair ("CreatedDate", DateTime.to_query f))
         ; Some
             (Aws.Query.Pair ("PatchGroups.member", PatchGroupList.to_query v.patch_groups))
         ; Aws.Util.option_map v.rejected_patches_action (fun f ->
               Aws.Query.Pair ("RejectedPatchesAction", PatchAction.to_query f))
         ; Some
             (Aws.Query.Pair
                ("RejectedPatches.member", PatchIdList.to_query v.rejected_patches))
         ; Aws.Util.option_map v.approved_patches_enable_non_security (fun f ->
               Aws.Query.Pair ("ApprovedPatchesEnableNonSecurity", Boolean.to_query f))
         ; Aws.Util.option_map v.approved_patches_compliance_level (fun f ->
               Aws.Query.Pair
                 ("ApprovedPatchesComplianceLevel", PatchComplianceLevel.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ApprovedPatches.member", PatchIdList.to_query v.approved_patches))
         ; Aws.Util.option_map v.approval_rules (fun f ->
               Aws.Query.Pair ("ApprovalRules", PatchRuleGroup.to_query f))
         ; Aws.Util.option_map v.global_filters (fun f ->
               Aws.Query.Pair ("GlobalFilters", PatchFilterGroup.to_query f))
         ; Aws.Util.option_map v.operating_system (fun f ->
               Aws.Query.Pair ("OperatingSystem", OperatingSystem.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.baseline_id (fun f ->
               Aws.Query.Pair ("BaselineId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Sources", PatchSourceList.to_json v.sources)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.modified_date (fun f ->
               "ModifiedDate", DateTime.to_json f)
         ; Aws.Util.option_map v.created_date (fun f -> "CreatedDate", DateTime.to_json f)
         ; Some ("PatchGroups", PatchGroupList.to_json v.patch_groups)
         ; Aws.Util.option_map v.rejected_patches_action (fun f ->
               "RejectedPatchesAction", PatchAction.to_json f)
         ; Some ("RejectedPatches", PatchIdList.to_json v.rejected_patches)
         ; Aws.Util.option_map v.approved_patches_enable_non_security (fun f ->
               "ApprovedPatchesEnableNonSecurity", Boolean.to_json f)
         ; Aws.Util.option_map v.approved_patches_compliance_level (fun f ->
               "ApprovedPatchesComplianceLevel", PatchComplianceLevel.to_json f)
         ; Some ("ApprovedPatches", PatchIdList.to_json v.approved_patches)
         ; Aws.Util.option_map v.approval_rules (fun f ->
               "ApprovalRules", PatchRuleGroup.to_json f)
         ; Aws.Util.option_map v.global_filters (fun f ->
               "GlobalFilters", PatchFilterGroup.to_json f)
         ; Aws.Util.option_map v.operating_system (fun f ->
               "OperatingSystem", OperatingSystem.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.baseline_id (fun f -> "BaselineId", String.to_json f)
         ])

  let of_json j =
    { baseline_id = Aws.Util.option_map (Aws.Json.lookup j "BaselineId") String.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; operating_system =
        Aws.Util.option_map (Aws.Json.lookup j "OperatingSystem") OperatingSystem.of_json
    ; global_filters =
        Aws.Util.option_map (Aws.Json.lookup j "GlobalFilters") PatchFilterGroup.of_json
    ; approval_rules =
        Aws.Util.option_map (Aws.Json.lookup j "ApprovalRules") PatchRuleGroup.of_json
    ; approved_patches =
        PatchIdList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ApprovedPatches"))
    ; approved_patches_compliance_level =
        Aws.Util.option_map
          (Aws.Json.lookup j "ApprovedPatchesComplianceLevel")
          PatchComplianceLevel.of_json
    ; approved_patches_enable_non_security =
        Aws.Util.option_map
          (Aws.Json.lookup j "ApprovedPatchesEnableNonSecurity")
          Boolean.of_json
    ; rejected_patches =
        PatchIdList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "RejectedPatches"))
    ; rejected_patches_action =
        Aws.Util.option_map
          (Aws.Json.lookup j "RejectedPatchesAction")
          PatchAction.of_json
    ; patch_groups =
        PatchGroupList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PatchGroups"))
    ; created_date =
        Aws.Util.option_map (Aws.Json.lookup j "CreatedDate") DateTime.of_json
    ; modified_date =
        Aws.Util.option_map (Aws.Json.lookup j "ModifiedDate") DateTime.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; sources =
        PatchSourceList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Sources"))
    }
end

module ResourceDataSyncConflictException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module Tag = struct
  type t =
    { key : String.t
    ; value : String.t
    }

  let make ~key ~value () = { key; value }

  let parse xml =
    Some
      { key =
          Aws.Xml.required
            "Key"
            (Aws.Util.option_bind (Aws.Xml.member "Key" xml) String.parse)
      ; value =
          Aws.Xml.required
            "Value"
            (Aws.Util.option_bind (Aws.Xml.member "Value" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Value", String.to_query v.value))
         ; Some (Aws.Query.Pair ("Key", String.to_query v.key))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Value", String.to_json v.value); Some ("Key", String.to_json v.key) ])

  let of_json j =
    { key = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Key"))
    ; value = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Value"))
    }
end

module TagList = struct
  type t = Tag.t list

  let make elems () = elems
  let parse xml = Aws.Util.option_all (List.map Tag.parse (Aws.Xml.members "member" xml))
  let to_query v = Aws.Query.to_query_list Tag.to_query v
  let to_json v = `List (List.map Tag.to_json v)
  let of_json j = Aws.Json.to_list Tag.of_json j
end

module CreateMaintenanceWindowRequest = struct
  type t =
    { name : String.t
    ; description : String.t option
    ; start_date : String.t option
    ; end_date : String.t option
    ; schedule : String.t
    ; schedule_timezone : String.t option
    ; schedule_offset : Integer.t option
    ; duration : Integer.t
    ; cutoff : Integer.t
    ; allow_unassociated_targets : Boolean.t
    ; client_token : String.t option
    ; tags : TagList.t
    }

  let make
      ~name
      ?description
      ?start_date
      ?end_date
      ~schedule
      ?schedule_timezone
      ?schedule_offset
      ~duration
      ~cutoff
      ~allow_unassociated_targets
      ?client_token
      ?(tags = [])
      () =
    { name
    ; description
    ; start_date
    ; end_date
    ; schedule
    ; schedule_timezone
    ; schedule_offset
    ; duration
    ; cutoff
    ; allow_unassociated_targets
    ; client_token
    ; tags
    }

  let parse xml =
    Some
      { name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; start_date = Aws.Util.option_bind (Aws.Xml.member "StartDate" xml) String.parse
      ; end_date = Aws.Util.option_bind (Aws.Xml.member "EndDate" xml) String.parse
      ; schedule =
          Aws.Xml.required
            "Schedule"
            (Aws.Util.option_bind (Aws.Xml.member "Schedule" xml) String.parse)
      ; schedule_timezone =
          Aws.Util.option_bind (Aws.Xml.member "ScheduleTimezone" xml) String.parse
      ; schedule_offset =
          Aws.Util.option_bind (Aws.Xml.member "ScheduleOffset" xml) Integer.parse
      ; duration =
          Aws.Xml.required
            "Duration"
            (Aws.Util.option_bind (Aws.Xml.member "Duration" xml) Integer.parse)
      ; cutoff =
          Aws.Xml.required
            "Cutoff"
            (Aws.Util.option_bind (Aws.Xml.member "Cutoff" xml) Integer.parse)
      ; allow_unassociated_targets =
          Aws.Xml.required
            "AllowUnassociatedTargets"
            (Aws.Util.option_bind
               (Aws.Xml.member "AllowUnassociatedTargets" xml)
               Boolean.parse)
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("AllowUnassociatedTargets", Boolean.to_query v.allow_unassociated_targets))
         ; Some (Aws.Query.Pair ("Cutoff", Integer.to_query v.cutoff))
         ; Some (Aws.Query.Pair ("Duration", Integer.to_query v.duration))
         ; Aws.Util.option_map v.schedule_offset (fun f ->
               Aws.Query.Pair ("ScheduleOffset", Integer.to_query f))
         ; Aws.Util.option_map v.schedule_timezone (fun f ->
               Aws.Query.Pair ("ScheduleTimezone", String.to_query f))
         ; Some (Aws.Query.Pair ("Schedule", String.to_query v.schedule))
         ; Aws.Util.option_map v.end_date (fun f ->
               Aws.Query.Pair ("EndDate", String.to_query f))
         ; Aws.Util.option_map v.start_date (fun f ->
               Aws.Query.Pair ("StartDate", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tags", TagList.to_json v.tags)
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Some ("AllowUnassociatedTargets", Boolean.to_json v.allow_unassociated_targets)
         ; Some ("Cutoff", Integer.to_json v.cutoff)
         ; Some ("Duration", Integer.to_json v.duration)
         ; Aws.Util.option_map v.schedule_offset (fun f ->
               "ScheduleOffset", Integer.to_json f)
         ; Aws.Util.option_map v.schedule_timezone (fun f ->
               "ScheduleTimezone", String.to_json f)
         ; Some ("Schedule", String.to_json v.schedule)
         ; Aws.Util.option_map v.end_date (fun f -> "EndDate", String.to_json f)
         ; Aws.Util.option_map v.start_date (fun f -> "StartDate", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Some ("Name", String.to_json v.name)
         ])

  let of_json j =
    { name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; start_date = Aws.Util.option_map (Aws.Json.lookup j "StartDate") String.of_json
    ; end_date = Aws.Util.option_map (Aws.Json.lookup j "EndDate") String.of_json
    ; schedule = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Schedule"))
    ; schedule_timezone =
        Aws.Util.option_map (Aws.Json.lookup j "ScheduleTimezone") String.of_json
    ; schedule_offset =
        Aws.Util.option_map (Aws.Json.lookup j "ScheduleOffset") Integer.of_json
    ; duration = Integer.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Duration"))
    ; cutoff = Integer.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Cutoff"))
    ; allow_unassociated_targets =
        Boolean.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AllowUnassociatedTargets"))
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    }
end

module PatchOrchestratorFilterValues = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module PatchOrchestratorFilter = struct
  type t =
    { key : String.t option
    ; values : PatchOrchestratorFilterValues.t
    }

  let make ?key ?(values = []) () = { key; values }

  let parse xml =
    Some
      { key = Aws.Util.option_bind (Aws.Xml.member "Key" xml) String.parse
      ; values =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Values" xml)
               PatchOrchestratorFilterValues.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("Values.member", PatchOrchestratorFilterValues.to_query v.values))
         ; Aws.Util.option_map v.key (fun f -> Aws.Query.Pair ("Key", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Values", PatchOrchestratorFilterValues.to_json v.values)
         ; Aws.Util.option_map v.key (fun f -> "Key", String.to_json f)
         ])

  let of_json j =
    { key = Aws.Util.option_map (Aws.Json.lookup j "Key") String.of_json
    ; values =
        PatchOrchestratorFilterValues.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Values"))
    }
end

module PatchOrchestratorFilterList = struct
  type t = PatchOrchestratorFilter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map PatchOrchestratorFilter.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list PatchOrchestratorFilter.to_query v
  let to_json v = `List (List.map PatchOrchestratorFilter.to_json v)
  let of_json j = Aws.Json.to_list PatchOrchestratorFilter.of_json j
end

module DescribePatchGroupsRequest = struct
  type t =
    { max_results : Integer.t option
    ; filters : PatchOrchestratorFilterList.t
    ; next_token : String.t option
    }

  let make ?max_results ?(filters = []) ?next_token () =
    { max_results; filters; next_token }

  let parse xml =
    Some
      { max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               PatchOrchestratorFilterList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Filters.member", PatchOrchestratorFilterList.to_query v.filters))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Filters", PatchOrchestratorFilterList.to_json v.filters)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ])

  let of_json j =
    { max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; filters =
        PatchOrchestratorFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module RebootOption = struct
  type t =
    | RebootIfNeeded
    | NoReboot

  let str_to_t = [ "NoReboot", NoReboot; "RebootIfNeeded", RebootIfNeeded ]
  let t_to_str = [ NoReboot, "NoReboot"; RebootIfNeeded, "RebootIfNeeded" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module IdempotentParameterMismatch = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module OpsItemFilterValues = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module OpsItemFilterOperator = struct
  type t =
    | Equal
    | Contains
    | GreaterThan
    | LessThan

  let str_to_t =
    [ "LessThan", LessThan
    ; "GreaterThan", GreaterThan
    ; "Contains", Contains
    ; "Equal", Equal
    ]

  let t_to_str =
    [ LessThan, "LessThan"
    ; GreaterThan, "GreaterThan"
    ; Contains, "Contains"
    ; Equal, "Equal"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module OpsItemFilterKey = struct
  type t =
    | Status
    | CreatedBy
    | Source
    | Priority
    | Title
    | OpsItemId
    | CreatedTime
    | LastModifiedTime
    | OperationalData
    | OperationalDataKey
    | OperationalDataValue
    | ResourceId
    | AutomationId
    | Category
    | Severity

  let str_to_t =
    [ "Severity", Severity
    ; "Category", Category
    ; "AutomationId", AutomationId
    ; "ResourceId", ResourceId
    ; "OperationalDataValue", OperationalDataValue
    ; "OperationalDataKey", OperationalDataKey
    ; "OperationalData", OperationalData
    ; "LastModifiedTime", LastModifiedTime
    ; "CreatedTime", CreatedTime
    ; "OpsItemId", OpsItemId
    ; "Title", Title
    ; "Priority", Priority
    ; "Source", Source
    ; "CreatedBy", CreatedBy
    ; "Status", Status
    ]

  let t_to_str =
    [ Severity, "Severity"
    ; Category, "Category"
    ; AutomationId, "AutomationId"
    ; ResourceId, "ResourceId"
    ; OperationalDataValue, "OperationalDataValue"
    ; OperationalDataKey, "OperationalDataKey"
    ; OperationalData, "OperationalData"
    ; LastModifiedTime, "LastModifiedTime"
    ; CreatedTime, "CreatedTime"
    ; OpsItemId, "OpsItemId"
    ; Title, "Title"
    ; Priority, "Priority"
    ; Source, "Source"
    ; CreatedBy, "CreatedBy"
    ; Status, "Status"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module OpsItemFilter = struct
  type t =
    { key : OpsItemFilterKey.t
    ; values : OpsItemFilterValues.t
    ; operator : OpsItemFilterOperator.t
    }

  let make ~key ~values ~operator () = { key; values; operator }

  let parse xml =
    Some
      { key =
          Aws.Xml.required
            "Key"
            (Aws.Util.option_bind (Aws.Xml.member "Key" xml) OpsItemFilterKey.parse)
      ; values =
          Aws.Xml.required
            "Values"
            (Aws.Util.option_bind (Aws.Xml.member "Values" xml) OpsItemFilterValues.parse)
      ; operator =
          Aws.Xml.required
            "Operator"
            (Aws.Util.option_bind
               (Aws.Xml.member "Operator" xml)
               OpsItemFilterOperator.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Operator", OpsItemFilterOperator.to_query v.operator))
         ; Some (Aws.Query.Pair ("Values.member", OpsItemFilterValues.to_query v.values))
         ; Some (Aws.Query.Pair ("Key", OpsItemFilterKey.to_query v.key))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Operator", OpsItemFilterOperator.to_json v.operator)
         ; Some ("Values", OpsItemFilterValues.to_json v.values)
         ; Some ("Key", OpsItemFilterKey.to_json v.key)
         ])

  let of_json j =
    { key = OpsItemFilterKey.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Key"))
    ; values =
        OpsItemFilterValues.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Values"))
    ; operator =
        OpsItemFilterOperator.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Operator"))
    }
end

module OpsItemFilters = struct
  type t = OpsItemFilter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map OpsItemFilter.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list OpsItemFilter.to_query v
  let to_json v = `List (List.map OpsItemFilter.to_json v)
  let of_json j = Aws.Json.to_list OpsItemFilter.of_json j
end

module DescribeOpsItemsRequest = struct
  type t =
    { ops_item_filters : OpsItemFilters.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?(ops_item_filters = []) ?max_results ?next_token () =
    { ops_item_filters; max_results; next_token }

  let parse xml =
    Some
      { ops_item_filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "OpsItemFilters" xml)
               OpsItemFilters.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("OpsItemFilters.member", OpsItemFilters.to_query v.ops_item_filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("OpsItemFilters", OpsItemFilters.to_json v.ops_item_filters)
         ])

  let of_json j =
    { ops_item_filters =
        OpsItemFilters.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "OpsItemFilters"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module InventoryItemEntry = struct
  type t = (String.t, String.t) Hashtbl.t

  let make elems () = elems
  let parse xml = None
  let to_query v = Aws.Query.to_query_hashtbl String.to_string String.to_query v

  let to_json v =
    `Assoc
      (Hashtbl.fold (fun k v acc -> (String.to_string k, String.to_json v) :: acc) v [])

  let of_json j = Aws.Json.to_hashtbl String.of_string String.of_json j
end

module InventoryItemEntryList = struct
  type t = InventoryItemEntry.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map InventoryItemEntry.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list InventoryItemEntry.to_query v
  let to_json v = `List (List.map InventoryItemEntry.to_json v)
  let of_json j = Aws.Json.to_list InventoryItemEntry.of_json j
end

module InventoryResultItem = struct
  type t =
    { type_name : String.t
    ; schema_version : String.t
    ; capture_time : String.t option
    ; content_hash : String.t option
    ; content : InventoryItemEntryList.t
    }

  let make ~type_name ~schema_version ?capture_time ?content_hash ~content () =
    { type_name; schema_version; capture_time; content_hash; content }

  let parse xml =
    Some
      { type_name =
          Aws.Xml.required
            "TypeName"
            (Aws.Util.option_bind (Aws.Xml.member "TypeName" xml) String.parse)
      ; schema_version =
          Aws.Xml.required
            "SchemaVersion"
            (Aws.Util.option_bind (Aws.Xml.member "SchemaVersion" xml) String.parse)
      ; capture_time =
          Aws.Util.option_bind (Aws.Xml.member "CaptureTime" xml) String.parse
      ; content_hash =
          Aws.Util.option_bind (Aws.Xml.member "ContentHash" xml) String.parse
      ; content =
          Aws.Xml.required
            "Content"
            (Aws.Util.option_bind
               (Aws.Xml.member "Content" xml)
               InventoryItemEntryList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("Content.member", InventoryItemEntryList.to_query v.content))
         ; Aws.Util.option_map v.content_hash (fun f ->
               Aws.Query.Pair ("ContentHash", String.to_query f))
         ; Aws.Util.option_map v.capture_time (fun f ->
               Aws.Query.Pair ("CaptureTime", String.to_query f))
         ; Some (Aws.Query.Pair ("SchemaVersion", String.to_query v.schema_version))
         ; Some (Aws.Query.Pair ("TypeName", String.to_query v.type_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Content", InventoryItemEntryList.to_json v.content)
         ; Aws.Util.option_map v.content_hash (fun f -> "ContentHash", String.to_json f)
         ; Aws.Util.option_map v.capture_time (fun f -> "CaptureTime", String.to_json f)
         ; Some ("SchemaVersion", String.to_json v.schema_version)
         ; Some ("TypeName", String.to_json v.type_name)
         ])

  let of_json j =
    { type_name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TypeName"))
    ; schema_version =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SchemaVersion"))
    ; capture_time = Aws.Util.option_map (Aws.Json.lookup j "CaptureTime") String.of_json
    ; content_hash = Aws.Util.option_map (Aws.Json.lookup j "ContentHash") String.of_json
    ; content =
        InventoryItemEntryList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Content"))
    }
end

module InstanceInformationFilterValueSet = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module InstanceInformationStringFilter = struct
  type t =
    { key : String.t
    ; values : InstanceInformationFilterValueSet.t
    }

  let make ~key ~values () = { key; values }

  let parse xml =
    Some
      { key =
          Aws.Xml.required
            "Key"
            (Aws.Util.option_bind (Aws.Xml.member "Key" xml) String.parse)
      ; values =
          Aws.Xml.required
            "Values"
            (Aws.Util.option_bind
               (Aws.Xml.member "Values" xml)
               InstanceInformationFilterValueSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("Values.member", InstanceInformationFilterValueSet.to_query v.values))
         ; Some (Aws.Query.Pair ("Key", String.to_query v.key))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Values", InstanceInformationFilterValueSet.to_json v.values)
         ; Some ("Key", String.to_json v.key)
         ])

  let of_json j =
    { key = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Key"))
    ; values =
        InstanceInformationFilterValueSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Values"))
    }
end

module OpsFilterValueList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module OpsFilterOperatorType = struct
  type t =
    | Equal
    | NotEqual
    | BeginWith
    | LessThan
    | GreaterThan
    | Exists

  let str_to_t =
    [ "Exists", Exists
    ; "GreaterThan", GreaterThan
    ; "LessThan", LessThan
    ; "BeginWith", BeginWith
    ; "NotEqual", NotEqual
    ; "Equal", Equal
    ]

  let t_to_str =
    [ Exists, "Exists"
    ; GreaterThan, "GreaterThan"
    ; LessThan, "LessThan"
    ; BeginWith, "BeginWith"
    ; NotEqual, "NotEqual"
    ; Equal, "Equal"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module OpsFilter = struct
  type t =
    { key : String.t
    ; values : OpsFilterValueList.t
    ; type_ : OpsFilterOperatorType.t option
    }

  let make ~key ~values ?type_ () = { key; values; type_ }

  let parse xml =
    Some
      { key =
          Aws.Xml.required
            "Key"
            (Aws.Util.option_bind (Aws.Xml.member "Key" xml) String.parse)
      ; values =
          Aws.Xml.required
            "Values"
            (Aws.Util.option_bind (Aws.Xml.member "Values" xml) OpsFilterValueList.parse)
      ; type_ =
          Aws.Util.option_bind (Aws.Xml.member "Type" xml) OpsFilterOperatorType.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", OpsFilterOperatorType.to_query f))
         ; Some (Aws.Query.Pair ("Values.member", OpsFilterValueList.to_query v.values))
         ; Some (Aws.Query.Pair ("Key", String.to_query v.key))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.type_ (fun f -> "Type", OpsFilterOperatorType.to_json f)
         ; Some ("Values", OpsFilterValueList.to_json v.values)
         ; Some ("Key", String.to_json v.key)
         ])

  let of_json j =
    { key = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Key"))
    ; values =
        OpsFilterValueList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Values"))
    ; type_ = Aws.Util.option_map (Aws.Json.lookup j "Type") OpsFilterOperatorType.of_json
    }
end

module OpsFilterList = struct
  type t = OpsFilter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map OpsFilter.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list OpsFilter.to_query v
  let to_json v = `List (List.map OpsFilter.to_json v)
  let of_json j = Aws.Json.to_list OpsFilter.of_json j
end

module OpsAggregatorValueMap = struct
  type t = (String.t, String.t) Hashtbl.t

  let make elems () = elems
  let parse xml = None
  let to_query v = Aws.Query.to_query_hashtbl String.to_string String.to_query v

  let to_json v =
    `Assoc
      (Hashtbl.fold (fun k v acc -> (String.to_string k, String.to_json v) :: acc) v [])

  let of_json j = Aws.Json.to_hashtbl String.of_string String.of_json j
end

module rec OpsAggregator : sig
  type t =
    { aggregator_type : String.t option
    ; type_name : String.t option
    ; attribute_name : String.t option
    ; values : OpsAggregatorValueMap.t option
    ; filters : OpsFilterList.t
    ; aggregators : OpsAggregatorList.t
    }

  val make :
       ?aggregator_type:String.t
    -> ?type_name:String.t
    -> ?attribute_name:String.t
    -> ?values:OpsAggregatorValueMap.t
    -> ?filters:OpsFilterList.t
    -> ?aggregators:OpsAggregatorList.t
    -> unit
    -> t

  val parse : Ezxmlm.nodes -> t option
  val to_query : t -> Aws.Query.t
  val to_json : t -> Aws.Json.t
  val of_json : Aws.Json.t -> t
end = struct
  type t =
    { aggregator_type : String.t option
    ; type_name : String.t option
    ; attribute_name : String.t option
    ; values : OpsAggregatorValueMap.t option
    ; filters : OpsFilterList.t
    ; aggregators : OpsAggregatorList.t
    }

  let make
      ?aggregator_type
      ?type_name
      ?attribute_name
      ?values
      ?(filters = [])
      ?(aggregators = [])
      () =
    { aggregator_type; type_name; attribute_name; values; filters; aggregators }

  let parse xml =
    Some
      { aggregator_type =
          Aws.Util.option_bind (Aws.Xml.member "AggregatorType" xml) String.parse
      ; type_name = Aws.Util.option_bind (Aws.Xml.member "TypeName" xml) String.parse
      ; attribute_name =
          Aws.Util.option_bind (Aws.Xml.member "AttributeName" xml) String.parse
      ; values =
          Aws.Util.option_bind (Aws.Xml.member "Values" xml) OpsAggregatorValueMap.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) OpsFilterList.parse)
      ; aggregators =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Aggregators" xml)
               OpsAggregatorList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("Aggregators.member", OpsAggregatorList.to_query v.aggregators))
         ; Some (Aws.Query.Pair ("Filters.member", OpsFilterList.to_query v.filters))
         ; Aws.Util.option_map v.values (fun f ->
               Aws.Query.Pair ("Values", OpsAggregatorValueMap.to_query f))
         ; Aws.Util.option_map v.attribute_name (fun f ->
               Aws.Query.Pair ("AttributeName", String.to_query f))
         ; Aws.Util.option_map v.type_name (fun f ->
               Aws.Query.Pair ("TypeName", String.to_query f))
         ; Aws.Util.option_map v.aggregator_type (fun f ->
               Aws.Query.Pair ("AggregatorType", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Aggregators", OpsAggregatorList.to_json v.aggregators)
         ; Some ("Filters", OpsFilterList.to_json v.filters)
         ; Aws.Util.option_map v.values (fun f ->
               "Values", OpsAggregatorValueMap.to_json f)
         ; Aws.Util.option_map v.attribute_name (fun f ->
               "AttributeName", String.to_json f)
         ; Aws.Util.option_map v.type_name (fun f -> "TypeName", String.to_json f)
         ; Aws.Util.option_map v.aggregator_type (fun f ->
               "AggregatorType", String.to_json f)
         ])

  let of_json j =
    { aggregator_type =
        Aws.Util.option_map (Aws.Json.lookup j "AggregatorType") String.of_json
    ; type_name = Aws.Util.option_map (Aws.Json.lookup j "TypeName") String.of_json
    ; attribute_name =
        Aws.Util.option_map (Aws.Json.lookup j "AttributeName") String.of_json
    ; values =
        Aws.Util.option_map (Aws.Json.lookup j "Values") OpsAggregatorValueMap.of_json
    ; filters =
        OpsFilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; aggregators =
        OpsAggregatorList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Aggregators"))
    }
end

and OpsAggregatorList : sig
  type t = OpsAggregator.t list

  val make : 'a -> unit -> 'a
  val parse : Ezxmlm.nodes -> t option
  val to_query : t -> Aws.Query.t
  val to_json : t -> Aws.Json.t
  val of_json : Aws.Json.t -> t
end = struct
  type t = OpsAggregator.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map OpsAggregator.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list OpsAggregator.to_query v
  let to_json v = `List (List.map OpsAggregator.to_json v)
  let of_json j = Aws.Json.to_list OpsAggregator.of_json j
end

module MaintenanceWindowStepFunctionsParameters = struct
  type t =
    { input : String.t option
    ; name : String.t option
    }

  let make ?input ?name () = { input; name }

  let parse xml =
    Some
      { input = Aws.Util.option_bind (Aws.Xml.member "Input" xml) String.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.input (fun f ->
               Aws.Query.Pair ("Input", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.input (fun f -> "Input", String.to_json f)
         ])

  let of_json j =
    { input = Aws.Util.option_map (Aws.Json.lookup j "Input") String.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    }
end

module InvalidInventoryGroupException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module AccountSharingInfo = struct
  type t =
    { account_id : String.t option
    ; shared_document_version : String.t option
    }

  let make ?account_id ?shared_document_version () =
    { account_id; shared_document_version }

  let parse xml =
    Some
      { account_id = Aws.Util.option_bind (Aws.Xml.member "AccountId" xml) String.parse
      ; shared_document_version =
          Aws.Util.option_bind (Aws.Xml.member "SharedDocumentVersion" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.shared_document_version (fun f ->
               Aws.Query.Pair ("SharedDocumentVersion", String.to_query f))
         ; Aws.Util.option_map v.account_id (fun f ->
               Aws.Query.Pair ("AccountId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.shared_document_version (fun f ->
               "SharedDocumentVersion", String.to_json f)
         ; Aws.Util.option_map v.account_id (fun f -> "AccountId", String.to_json f)
         ])

  let of_json j =
    { account_id = Aws.Util.option_map (Aws.Json.lookup j "AccountId") String.of_json
    ; shared_document_version =
        Aws.Util.option_map (Aws.Json.lookup j "SharedDocumentVersion") String.of_json
    }
end

module ParameterPatternMismatchException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json }
end

module OpsEntityItemEntry = struct
  type t = (String.t, String.t) Hashtbl.t

  let make elems () = elems
  let parse xml = None
  let to_query v = Aws.Query.to_query_hashtbl String.to_string String.to_query v

  let to_json v =
    `Assoc
      (Hashtbl.fold (fun k v acc -> (String.to_string k, String.to_json v) :: acc) v [])

  let of_json j = Aws.Json.to_hashtbl String.of_string String.of_json j
end

module DeleteParametersResult = struct
  type t =
    { deleted_parameters : ParameterNameList.t
    ; invalid_parameters : ParameterNameList.t
    }

  let make ?(deleted_parameters = []) ?(invalid_parameters = []) () =
    { deleted_parameters; invalid_parameters }

  let parse xml =
    Some
      { deleted_parameters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DeletedParameters" xml)
               ParameterNameList.parse)
      ; invalid_parameters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "InvalidParameters" xml)
               ParameterNameList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "InvalidParameters.member"
                , ParameterNameList.to_query v.invalid_parameters ))
         ; Some
             (Aws.Query.Pair
                ( "DeletedParameters.member"
                , ParameterNameList.to_query v.deleted_parameters ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("InvalidParameters", ParameterNameList.to_json v.invalid_parameters)
         ; Some ("DeletedParameters", ParameterNameList.to_json v.deleted_parameters)
         ])

  let of_json j =
    { deleted_parameters =
        ParameterNameList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DeletedParameters"))
    ; invalid_parameters =
        ParameterNameList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InvalidParameters"))
    }
end

module ConnectionStatus = struct
  type t =
    | Connected
    | NotConnected

  let str_to_t = [ "NotConnected", NotConnected; "Connected", Connected ]
  let t_to_str = [ NotConnected, "NotConnected"; Connected, "Connected" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module RegisterDefaultPatchBaselineResult = struct
  type t = { baseline_id : String.t option }

  let make ?baseline_id () = { baseline_id }

  let parse xml =
    Some
      { baseline_id = Aws.Util.option_bind (Aws.Xml.member "BaselineId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.baseline_id (fun f ->
               Aws.Query.Pair ("BaselineId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.baseline_id (fun f -> "BaselineId", String.to_json f) ])

  let of_json j =
    { baseline_id = Aws.Util.option_map (Aws.Json.lookup j "BaselineId") String.of_json }
end

module InventoryItemContentContext = struct
  type t = (String.t, String.t) Hashtbl.t

  let make elems () = elems
  let parse xml = None
  let to_query v = Aws.Query.to_query_hashtbl String.to_string String.to_query v

  let to_json v =
    `Assoc
      (Hashtbl.fold (fun k v acc -> (String.to_string k, String.to_json v) :: acc) v [])

  let of_json j = Aws.Json.to_hashtbl String.of_string String.of_json j
end

module InventoryItem = struct
  type t =
    { type_name : String.t
    ; schema_version : String.t
    ; capture_time : String.t
    ; content_hash : String.t option
    ; content : InventoryItemEntryList.t
    ; context : InventoryItemContentContext.t option
    }

  let make
      ~type_name
      ~schema_version
      ~capture_time
      ?content_hash
      ?(content = [])
      ?context
      () =
    { type_name; schema_version; capture_time; content_hash; content; context }

  let parse xml =
    Some
      { type_name =
          Aws.Xml.required
            "TypeName"
            (Aws.Util.option_bind (Aws.Xml.member "TypeName" xml) String.parse)
      ; schema_version =
          Aws.Xml.required
            "SchemaVersion"
            (Aws.Util.option_bind (Aws.Xml.member "SchemaVersion" xml) String.parse)
      ; capture_time =
          Aws.Xml.required
            "CaptureTime"
            (Aws.Util.option_bind (Aws.Xml.member "CaptureTime" xml) String.parse)
      ; content_hash =
          Aws.Util.option_bind (Aws.Xml.member "ContentHash" xml) String.parse
      ; content =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Content" xml)
               InventoryItemEntryList.parse)
      ; context =
          Aws.Util.option_bind
            (Aws.Xml.member "Context" xml)
            InventoryItemContentContext.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.context (fun f ->
               Aws.Query.Pair ("Context", InventoryItemContentContext.to_query f))
         ; Some
             (Aws.Query.Pair ("Content.member", InventoryItemEntryList.to_query v.content))
         ; Aws.Util.option_map v.content_hash (fun f ->
               Aws.Query.Pair ("ContentHash", String.to_query f))
         ; Some (Aws.Query.Pair ("CaptureTime", String.to_query v.capture_time))
         ; Some (Aws.Query.Pair ("SchemaVersion", String.to_query v.schema_version))
         ; Some (Aws.Query.Pair ("TypeName", String.to_query v.type_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.context (fun f ->
               "Context", InventoryItemContentContext.to_json f)
         ; Some ("Content", InventoryItemEntryList.to_json v.content)
         ; Aws.Util.option_map v.content_hash (fun f -> "ContentHash", String.to_json f)
         ; Some ("CaptureTime", String.to_json v.capture_time)
         ; Some ("SchemaVersion", String.to_json v.schema_version)
         ; Some ("TypeName", String.to_json v.type_name)
         ])

  let of_json j =
    { type_name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TypeName"))
    ; schema_version =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SchemaVersion"))
    ; capture_time =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "CaptureTime"))
    ; content_hash = Aws.Util.option_map (Aws.Json.lookup j "ContentHash") String.of_json
    ; content =
        InventoryItemEntryList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Content"))
    ; context =
        Aws.Util.option_map
          (Aws.Json.lookup j "Context")
          InventoryItemContentContext.of_json
    }
end

module InventoryItemList = struct
  type t = InventoryItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map InventoryItem.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list InventoryItem.to_query v
  let to_json v = `List (List.map InventoryItem.to_json v)
  let of_json j = Aws.Json.to_list InventoryItem.of_json j
end

module PutInventoryRequest = struct
  type t =
    { instance_id : String.t
    ; items : InventoryItemList.t
    }

  let make ~instance_id ~items () = { instance_id; items }

  let parse xml =
    Some
      { instance_id =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse)
      ; items =
          Aws.Xml.required
            "Items"
            (Aws.Util.option_bind (Aws.Xml.member "Items" xml) InventoryItemList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Items.member", InventoryItemList.to_query v.items))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Items", InventoryItemList.to_json v.items)
         ; Some ("InstanceId", String.to_json v.instance_id)
         ])

  let of_json j =
    { instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; items =
        InventoryItemList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Items"))
    }
end

module Parameters = struct
  type t = (String.t, ParameterValueList.t) Hashtbl.t

  let make elems () = elems
  let parse xml = None

  let to_query v =
    Aws.Query.to_query_hashtbl String.to_string ParameterValueList.to_query v

  let to_json v =
    `Assoc
      (Hashtbl.fold
         (fun k v acc -> (String.to_string k, ParameterValueList.to_json v) :: acc)
         v
         [])

  let of_json j = Aws.Json.to_hashtbl String.of_string ParameterValueList.of_json j
end

module NotificationType = struct
  type t =
    | Command
    | Invocation

  let str_to_t = [ "Invocation", Invocation; "Command", Command ]
  let t_to_str = [ Invocation, "Invocation"; Command, "Command" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module NotificationEvent = struct
  type t =
    | All
    | InProgress
    | Success
    | TimedOut
    | Cancelled
    | Failed

  let str_to_t =
    [ "Failed", Failed
    ; "Cancelled", Cancelled
    ; "TimedOut", TimedOut
    ; "Success", Success
    ; "InProgress", InProgress
    ; "All", All
    ]

  let t_to_str =
    [ Failed, "Failed"
    ; Cancelled, "Cancelled"
    ; TimedOut, "TimedOut"
    ; Success, "Success"
    ; InProgress, "InProgress"
    ; All, "All"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module NotificationEventList = struct
  type t = NotificationEvent.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map NotificationEvent.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list NotificationEvent.to_query v
  let to_json v = `List (List.map NotificationEvent.to_json v)
  let of_json j = Aws.Json.to_list NotificationEvent.of_json j
end

module NotificationConfig = struct
  type t =
    { notification_arn : String.t option
    ; notification_events : NotificationEventList.t
    ; notification_type : NotificationType.t option
    }

  let make ?notification_arn ?(notification_events = []) ?notification_type () =
    { notification_arn; notification_events; notification_type }

  let parse xml =
    Some
      { notification_arn =
          Aws.Util.option_bind (Aws.Xml.member "NotificationArn" xml) String.parse
      ; notification_events =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "NotificationEvents" xml)
               NotificationEventList.parse)
      ; notification_type =
          Aws.Util.option_bind
            (Aws.Xml.member "NotificationType" xml)
            NotificationType.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.notification_type (fun f ->
               Aws.Query.Pair ("NotificationType", NotificationType.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "NotificationEvents.member"
                , NotificationEventList.to_query v.notification_events ))
         ; Aws.Util.option_map v.notification_arn (fun f ->
               Aws.Query.Pair ("NotificationArn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.notification_type (fun f ->
               "NotificationType", NotificationType.to_json f)
         ; Some ("NotificationEvents", NotificationEventList.to_json v.notification_events)
         ; Aws.Util.option_map v.notification_arn (fun f ->
               "NotificationArn", String.to_json f)
         ])

  let of_json j =
    { notification_arn =
        Aws.Util.option_map (Aws.Json.lookup j "NotificationArn") String.of_json
    ; notification_events =
        NotificationEventList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "NotificationEvents"))
    ; notification_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "NotificationType")
          NotificationType.of_json
    }
end

module DocumentHashType = struct
  type t =
    | Sha256
    | Sha1

  let str_to_t = [ "Sha1", Sha1; "Sha256", Sha256 ]
  let t_to_str = [ Sha1, "Sha1"; Sha256, "Sha256" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module MaintenanceWindowRunCommandParameters = struct
  type t =
    { comment : String.t option
    ; cloud_watch_output_config : CloudWatchOutputConfig.t option
    ; document_hash : String.t option
    ; document_hash_type : DocumentHashType.t option
    ; document_version : String.t option
    ; notification_config : NotificationConfig.t option
    ; output_s3_bucket_name : String.t option
    ; output_s3_key_prefix : String.t option
    ; parameters : Parameters.t option
    ; service_role_arn : String.t option
    ; timeout_seconds : Integer.t option
    }

  let make
      ?comment
      ?cloud_watch_output_config
      ?document_hash
      ?document_hash_type
      ?document_version
      ?notification_config
      ?output_s3_bucket_name
      ?output_s3_key_prefix
      ?parameters
      ?service_role_arn
      ?timeout_seconds
      () =
    { comment
    ; cloud_watch_output_config
    ; document_hash
    ; document_hash_type
    ; document_version
    ; notification_config
    ; output_s3_bucket_name
    ; output_s3_key_prefix
    ; parameters
    ; service_role_arn
    ; timeout_seconds
    }

  let parse xml =
    Some
      { comment = Aws.Util.option_bind (Aws.Xml.member "Comment" xml) String.parse
      ; cloud_watch_output_config =
          Aws.Util.option_bind
            (Aws.Xml.member "CloudWatchOutputConfig" xml)
            CloudWatchOutputConfig.parse
      ; document_hash =
          Aws.Util.option_bind (Aws.Xml.member "DocumentHash" xml) String.parse
      ; document_hash_type =
          Aws.Util.option_bind
            (Aws.Xml.member "DocumentHashType" xml)
            DocumentHashType.parse
      ; document_version =
          Aws.Util.option_bind (Aws.Xml.member "DocumentVersion" xml) String.parse
      ; notification_config =
          Aws.Util.option_bind
            (Aws.Xml.member "NotificationConfig" xml)
            NotificationConfig.parse
      ; output_s3_bucket_name =
          Aws.Util.option_bind (Aws.Xml.member "OutputS3BucketName" xml) String.parse
      ; output_s3_key_prefix =
          Aws.Util.option_bind (Aws.Xml.member "OutputS3KeyPrefix" xml) String.parse
      ; parameters =
          Aws.Util.option_bind (Aws.Xml.member "Parameters" xml) Parameters.parse
      ; service_role_arn =
          Aws.Util.option_bind (Aws.Xml.member "ServiceRoleArn" xml) String.parse
      ; timeout_seconds =
          Aws.Util.option_bind (Aws.Xml.member "TimeoutSeconds" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timeout_seconds (fun f ->
               Aws.Query.Pair ("TimeoutSeconds", Integer.to_query f))
         ; Aws.Util.option_map v.service_role_arn (fun f ->
               Aws.Query.Pair ("ServiceRoleArn", String.to_query f))
         ; Aws.Util.option_map v.parameters (fun f ->
               Aws.Query.Pair ("Parameters", Parameters.to_query f))
         ; Aws.Util.option_map v.output_s3_key_prefix (fun f ->
               Aws.Query.Pair ("OutputS3KeyPrefix", String.to_query f))
         ; Aws.Util.option_map v.output_s3_bucket_name (fun f ->
               Aws.Query.Pair ("OutputS3BucketName", String.to_query f))
         ; Aws.Util.option_map v.notification_config (fun f ->
               Aws.Query.Pair ("NotificationConfig", NotificationConfig.to_query f))
         ; Aws.Util.option_map v.document_version (fun f ->
               Aws.Query.Pair ("DocumentVersion", String.to_query f))
         ; Aws.Util.option_map v.document_hash_type (fun f ->
               Aws.Query.Pair ("DocumentHashType", DocumentHashType.to_query f))
         ; Aws.Util.option_map v.document_hash (fun f ->
               Aws.Query.Pair ("DocumentHash", String.to_query f))
         ; Aws.Util.option_map v.cloud_watch_output_config (fun f ->
               Aws.Query.Pair ("CloudWatchOutputConfig", CloudWatchOutputConfig.to_query f))
         ; Aws.Util.option_map v.comment (fun f ->
               Aws.Query.Pair ("Comment", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timeout_seconds (fun f ->
               "TimeoutSeconds", Integer.to_json f)
         ; Aws.Util.option_map v.service_role_arn (fun f ->
               "ServiceRoleArn", String.to_json f)
         ; Aws.Util.option_map v.parameters (fun f -> "Parameters", Parameters.to_json f)
         ; Aws.Util.option_map v.output_s3_key_prefix (fun f ->
               "OutputS3KeyPrefix", String.to_json f)
         ; Aws.Util.option_map v.output_s3_bucket_name (fun f ->
               "OutputS3BucketName", String.to_json f)
         ; Aws.Util.option_map v.notification_config (fun f ->
               "NotificationConfig", NotificationConfig.to_json f)
         ; Aws.Util.option_map v.document_version (fun f ->
               "DocumentVersion", String.to_json f)
         ; Aws.Util.option_map v.document_hash_type (fun f ->
               "DocumentHashType", DocumentHashType.to_json f)
         ; Aws.Util.option_map v.document_hash (fun f -> "DocumentHash", String.to_json f)
         ; Aws.Util.option_map v.cloud_watch_output_config (fun f ->
               "CloudWatchOutputConfig", CloudWatchOutputConfig.to_json f)
         ; Aws.Util.option_map v.comment (fun f -> "Comment", String.to_json f)
         ])

  let of_json j =
    { comment = Aws.Util.option_map (Aws.Json.lookup j "Comment") String.of_json
    ; cloud_watch_output_config =
        Aws.Util.option_map
          (Aws.Json.lookup j "CloudWatchOutputConfig")
          CloudWatchOutputConfig.of_json
    ; document_hash =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentHash") String.of_json
    ; document_hash_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "DocumentHashType")
          DocumentHashType.of_json
    ; document_version =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentVersion") String.of_json
    ; notification_config =
        Aws.Util.option_map
          (Aws.Json.lookup j "NotificationConfig")
          NotificationConfig.of_json
    ; output_s3_bucket_name =
        Aws.Util.option_map (Aws.Json.lookup j "OutputS3BucketName") String.of_json
    ; output_s3_key_prefix =
        Aws.Util.option_map (Aws.Json.lookup j "OutputS3KeyPrefix") String.of_json
    ; parameters = Aws.Util.option_map (Aws.Json.lookup j "Parameters") Parameters.of_json
    ; service_role_arn =
        Aws.Util.option_map (Aws.Json.lookup j "ServiceRoleArn") String.of_json
    ; timeout_seconds =
        Aws.Util.option_map (Aws.Json.lookup j "TimeoutSeconds") Integer.of_json
    }
end

module MaintenanceWindowLambdaParameters = struct
  type t =
    { client_context : String.t option
    ; qualifier : String.t option
    ; payload : Blob.t option
    }

  let make ?client_context ?qualifier ?payload () = { client_context; qualifier; payload }

  let parse xml =
    Some
      { client_context =
          Aws.Util.option_bind (Aws.Xml.member "ClientContext" xml) String.parse
      ; qualifier = Aws.Util.option_bind (Aws.Xml.member "Qualifier" xml) String.parse
      ; payload = Aws.Util.option_bind (Aws.Xml.member "Payload" xml) Blob.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.payload (fun f ->
               Aws.Query.Pair ("Payload", Blob.to_query f))
         ; Aws.Util.option_map v.qualifier (fun f ->
               Aws.Query.Pair ("Qualifier", String.to_query f))
         ; Aws.Util.option_map v.client_context (fun f ->
               Aws.Query.Pair ("ClientContext", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.payload (fun f -> "Payload", Blob.to_json f)
         ; Aws.Util.option_map v.qualifier (fun f -> "Qualifier", String.to_json f)
         ; Aws.Util.option_map v.client_context (fun f ->
               "ClientContext", String.to_json f)
         ])

  let of_json j =
    { client_context =
        Aws.Util.option_map (Aws.Json.lookup j "ClientContext") String.of_json
    ; qualifier = Aws.Util.option_map (Aws.Json.lookup j "Qualifier") String.of_json
    ; payload = Aws.Util.option_map (Aws.Json.lookup j "Payload") Blob.of_json
    }
end

module AutomationParameterValueList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module AutomationParameterMap = struct
  type t = (String.t, AutomationParameterValueList.t) Hashtbl.t

  let make elems () = elems
  let parse xml = None

  let to_query v =
    Aws.Query.to_query_hashtbl String.to_string AutomationParameterValueList.to_query v

  let to_json v =
    `Assoc
      (Hashtbl.fold
         (fun k v acc ->
           (String.to_string k, AutomationParameterValueList.to_json v) :: acc)
         v
         [])

  let of_json j =
    Aws.Json.to_hashtbl String.of_string AutomationParameterValueList.of_json j
end

module MaintenanceWindowAutomationParameters = struct
  type t =
    { document_version : String.t option
    ; parameters : AutomationParameterMap.t option
    }

  let make ?document_version ?parameters () = { document_version; parameters }

  let parse xml =
    Some
      { document_version =
          Aws.Util.option_bind (Aws.Xml.member "DocumentVersion" xml) String.parse
      ; parameters =
          Aws.Util.option_bind
            (Aws.Xml.member "Parameters" xml)
            AutomationParameterMap.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.parameters (fun f ->
               Aws.Query.Pair ("Parameters", AutomationParameterMap.to_query f))
         ; Aws.Util.option_map v.document_version (fun f ->
               Aws.Query.Pair ("DocumentVersion", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.parameters (fun f ->
               "Parameters", AutomationParameterMap.to_json f)
         ; Aws.Util.option_map v.document_version (fun f ->
               "DocumentVersion", String.to_json f)
         ])

  let of_json j =
    { document_version =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentVersion") String.of_json
    ; parameters =
        Aws.Util.option_map
          (Aws.Json.lookup j "Parameters")
          AutomationParameterMap.of_json
    }
end

module MaintenanceWindowTaskInvocationParameters = struct
  type t =
    { run_command : MaintenanceWindowRunCommandParameters.t option
    ; automation : MaintenanceWindowAutomationParameters.t option
    ; step_functions : MaintenanceWindowStepFunctionsParameters.t option
    ; lambda : MaintenanceWindowLambdaParameters.t option
    }

  let make ?run_command ?automation ?step_functions ?lambda () =
    { run_command; automation; step_functions; lambda }

  let parse xml =
    Some
      { run_command =
          Aws.Util.option_bind
            (Aws.Xml.member "RunCommand" xml)
            MaintenanceWindowRunCommandParameters.parse
      ; automation =
          Aws.Util.option_bind
            (Aws.Xml.member "Automation" xml)
            MaintenanceWindowAutomationParameters.parse
      ; step_functions =
          Aws.Util.option_bind
            (Aws.Xml.member "StepFunctions" xml)
            MaintenanceWindowStepFunctionsParameters.parse
      ; lambda =
          Aws.Util.option_bind
            (Aws.Xml.member "Lambda" xml)
            MaintenanceWindowLambdaParameters.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.lambda (fun f ->
               Aws.Query.Pair ("Lambda", MaintenanceWindowLambdaParameters.to_query f))
         ; Aws.Util.option_map v.step_functions (fun f ->
               Aws.Query.Pair
                 ("StepFunctions", MaintenanceWindowStepFunctionsParameters.to_query f))
         ; Aws.Util.option_map v.automation (fun f ->
               Aws.Query.Pair
                 ("Automation", MaintenanceWindowAutomationParameters.to_query f))
         ; Aws.Util.option_map v.run_command (fun f ->
               Aws.Query.Pair
                 ("RunCommand", MaintenanceWindowRunCommandParameters.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.lambda (fun f ->
               "Lambda", MaintenanceWindowLambdaParameters.to_json f)
         ; Aws.Util.option_map v.step_functions (fun f ->
               "StepFunctions", MaintenanceWindowStepFunctionsParameters.to_json f)
         ; Aws.Util.option_map v.automation (fun f ->
               "Automation", MaintenanceWindowAutomationParameters.to_json f)
         ; Aws.Util.option_map v.run_command (fun f ->
               "RunCommand", MaintenanceWindowRunCommandParameters.to_json f)
         ])

  let of_json j =
    { run_command =
        Aws.Util.option_map
          (Aws.Json.lookup j "RunCommand")
          MaintenanceWindowRunCommandParameters.of_json
    ; automation =
        Aws.Util.option_map
          (Aws.Json.lookup j "Automation")
          MaintenanceWindowAutomationParameters.of_json
    ; step_functions =
        Aws.Util.option_map
          (Aws.Json.lookup j "StepFunctions")
          MaintenanceWindowStepFunctionsParameters.of_json
    ; lambda =
        Aws.Util.option_map
          (Aws.Json.lookup j "Lambda")
          MaintenanceWindowLambdaParameters.of_json
    }
end

module CommandPluginStatus = struct
  type t =
    | Pending
    | InProgress
    | Success
    | TimedOut
    | Cancelled
    | Failed

  let str_to_t =
    [ "Failed", Failed
    ; "Cancelled", Cancelled
    ; "TimedOut", TimedOut
    ; "Success", Success
    ; "InProgress", InProgress
    ; "Pending", Pending
    ]

  let t_to_str =
    [ Failed, "Failed"
    ; Cancelled, "Cancelled"
    ; TimedOut, "TimedOut"
    ; Success, "Success"
    ; InProgress, "InProgress"
    ; Pending, "Pending"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module CommandPlugin = struct
  type t =
    { name : String.t option
    ; status : CommandPluginStatus.t option
    ; status_details : String.t option
    ; response_code : Integer.t option
    ; response_start_date_time : DateTime.t option
    ; response_finish_date_time : DateTime.t option
    ; output : String.t option
    ; standard_output_url : String.t option
    ; standard_error_url : String.t option
    ; output_s3_region : String.t option
    ; output_s3_bucket_name : String.t option
    ; output_s3_key_prefix : String.t option
    }

  let make
      ?name
      ?status
      ?status_details
      ?response_code
      ?response_start_date_time
      ?response_finish_date_time
      ?output
      ?standard_output_url
      ?standard_error_url
      ?output_s3_region
      ?output_s3_bucket_name
      ?output_s3_key_prefix
      () =
    { name
    ; status
    ; status_details
    ; response_code
    ; response_start_date_time
    ; response_finish_date_time
    ; output
    ; standard_output_url
    ; standard_error_url
    ; output_s3_region
    ; output_s3_bucket_name
    ; output_s3_key_prefix
    }

  let parse xml =
    Some
      { name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; status =
          Aws.Util.option_bind (Aws.Xml.member "Status" xml) CommandPluginStatus.parse
      ; status_details =
          Aws.Util.option_bind (Aws.Xml.member "StatusDetails" xml) String.parse
      ; response_code =
          Aws.Util.option_bind (Aws.Xml.member "ResponseCode" xml) Integer.parse
      ; response_start_date_time =
          Aws.Util.option_bind (Aws.Xml.member "ResponseStartDateTime" xml) DateTime.parse
      ; response_finish_date_time =
          Aws.Util.option_bind
            (Aws.Xml.member "ResponseFinishDateTime" xml)
            DateTime.parse
      ; output = Aws.Util.option_bind (Aws.Xml.member "Output" xml) String.parse
      ; standard_output_url =
          Aws.Util.option_bind (Aws.Xml.member "StandardOutputUrl" xml) String.parse
      ; standard_error_url =
          Aws.Util.option_bind (Aws.Xml.member "StandardErrorUrl" xml) String.parse
      ; output_s3_region =
          Aws.Util.option_bind (Aws.Xml.member "OutputS3Region" xml) String.parse
      ; output_s3_bucket_name =
          Aws.Util.option_bind (Aws.Xml.member "OutputS3BucketName" xml) String.parse
      ; output_s3_key_prefix =
          Aws.Util.option_bind (Aws.Xml.member "OutputS3KeyPrefix" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.output_s3_key_prefix (fun f ->
               Aws.Query.Pair ("OutputS3KeyPrefix", String.to_query f))
         ; Aws.Util.option_map v.output_s3_bucket_name (fun f ->
               Aws.Query.Pair ("OutputS3BucketName", String.to_query f))
         ; Aws.Util.option_map v.output_s3_region (fun f ->
               Aws.Query.Pair ("OutputS3Region", String.to_query f))
         ; Aws.Util.option_map v.standard_error_url (fun f ->
               Aws.Query.Pair ("StandardErrorUrl", String.to_query f))
         ; Aws.Util.option_map v.standard_output_url (fun f ->
               Aws.Query.Pair ("StandardOutputUrl", String.to_query f))
         ; Aws.Util.option_map v.output (fun f ->
               Aws.Query.Pair ("Output", String.to_query f))
         ; Aws.Util.option_map v.response_finish_date_time (fun f ->
               Aws.Query.Pair ("ResponseFinishDateTime", DateTime.to_query f))
         ; Aws.Util.option_map v.response_start_date_time (fun f ->
               Aws.Query.Pair ("ResponseStartDateTime", DateTime.to_query f))
         ; Aws.Util.option_map v.response_code (fun f ->
               Aws.Query.Pair ("ResponseCode", Integer.to_query f))
         ; Aws.Util.option_map v.status_details (fun f ->
               Aws.Query.Pair ("StatusDetails", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", CommandPluginStatus.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.output_s3_key_prefix (fun f ->
               "OutputS3KeyPrefix", String.to_json f)
         ; Aws.Util.option_map v.output_s3_bucket_name (fun f ->
               "OutputS3BucketName", String.to_json f)
         ; Aws.Util.option_map v.output_s3_region (fun f ->
               "OutputS3Region", String.to_json f)
         ; Aws.Util.option_map v.standard_error_url (fun f ->
               "StandardErrorUrl", String.to_json f)
         ; Aws.Util.option_map v.standard_output_url (fun f ->
               "StandardOutputUrl", String.to_json f)
         ; Aws.Util.option_map v.output (fun f -> "Output", String.to_json f)
         ; Aws.Util.option_map v.response_finish_date_time (fun f ->
               "ResponseFinishDateTime", DateTime.to_json f)
         ; Aws.Util.option_map v.response_start_date_time (fun f ->
               "ResponseStartDateTime", DateTime.to_json f)
         ; Aws.Util.option_map v.response_code (fun f ->
               "ResponseCode", Integer.to_json f)
         ; Aws.Util.option_map v.status_details (fun f ->
               "StatusDetails", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", CommandPluginStatus.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ])

  let of_json j =
    { name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; status =
        Aws.Util.option_map (Aws.Json.lookup j "Status") CommandPluginStatus.of_json
    ; status_details =
        Aws.Util.option_map (Aws.Json.lookup j "StatusDetails") String.of_json
    ; response_code =
        Aws.Util.option_map (Aws.Json.lookup j "ResponseCode") Integer.of_json
    ; response_start_date_time =
        Aws.Util.option_map (Aws.Json.lookup j "ResponseStartDateTime") DateTime.of_json
    ; response_finish_date_time =
        Aws.Util.option_map (Aws.Json.lookup j "ResponseFinishDateTime") DateTime.of_json
    ; output = Aws.Util.option_map (Aws.Json.lookup j "Output") String.of_json
    ; standard_output_url =
        Aws.Util.option_map (Aws.Json.lookup j "StandardOutputUrl") String.of_json
    ; standard_error_url =
        Aws.Util.option_map (Aws.Json.lookup j "StandardErrorUrl") String.of_json
    ; output_s3_region =
        Aws.Util.option_map (Aws.Json.lookup j "OutputS3Region") String.of_json
    ; output_s3_bucket_name =
        Aws.Util.option_map (Aws.Json.lookup j "OutputS3BucketName") String.of_json
    ; output_s3_key_prefix =
        Aws.Util.option_map (Aws.Json.lookup j "OutputS3KeyPrefix") String.of_json
    }
end

module StopType = struct
  type t =
    | Complete
    | Cancel

  let str_to_t = [ "Cancel", Cancel; "Complete", Complete ]
  let t_to_str = [ Cancel, "Cancel"; Complete, "Complete" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module StopAutomationExecutionRequest = struct
  type t =
    { automation_execution_id : String.t
    ; type_ : StopType.t option
    }

  let make ~automation_execution_id ?type_ () = { automation_execution_id; type_ }

  let parse xml =
    Some
      { automation_execution_id =
          Aws.Xml.required
            "AutomationExecutionId"
            (Aws.Util.option_bind
               (Aws.Xml.member "AutomationExecutionId" xml)
               String.parse)
      ; type_ = Aws.Util.option_bind (Aws.Xml.member "Type" xml) StopType.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", StopType.to_query f))
         ; Some
             (Aws.Query.Pair
                ("AutomationExecutionId", String.to_query v.automation_execution_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.type_ (fun f -> "Type", StopType.to_json f)
         ; Some ("AutomationExecutionId", String.to_json v.automation_execution_id)
         ])

  let of_json j =
    { automation_execution_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AutomationExecutionId"))
    ; type_ = Aws.Util.option_map (Aws.Json.lookup j "Type") StopType.of_json
    }
end

module InventoryAttributeDataType = struct
  type t =
    | String
    | Number

  let str_to_t = [ "number", Number; "string", String ]
  let t_to_str = [ Number, "number"; String, "string" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module InventoryItemAttribute = struct
  type t =
    { name : String.t
    ; data_type : InventoryAttributeDataType.t
    }

  let make ~name ~data_type () = { name; data_type }

  let parse xml =
    Some
      { name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      ; data_type =
          Aws.Xml.required
            "DataType"
            (Aws.Util.option_bind
               (Aws.Xml.member "DataType" xml)
               InventoryAttributeDataType.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("DataType", InventoryAttributeDataType.to_query v.data_type))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("DataType", InventoryAttributeDataType.to_json v.data_type)
         ; Some ("Name", String.to_json v.name)
         ])

  let of_json j =
    { name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; data_type =
        InventoryAttributeDataType.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DataType"))
    }
end

module InventoryItemAttributeList = struct
  type t = InventoryItemAttribute.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map InventoryItemAttribute.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list InventoryItemAttribute.to_query v
  let to_json v = `List (List.map InventoryItemAttribute.to_json v)
  let of_json j = Aws.Json.to_list InventoryItemAttribute.of_json j
end

module InventoryItemSchema = struct
  type t =
    { type_name : String.t
    ; version : String.t option
    ; attributes : InventoryItemAttributeList.t
    ; display_name : String.t option
    }

  let make ~type_name ?version ~attributes ?display_name () =
    { type_name; version; attributes; display_name }

  let parse xml =
    Some
      { type_name =
          Aws.Xml.required
            "TypeName"
            (Aws.Util.option_bind (Aws.Xml.member "TypeName" xml) String.parse)
      ; version = Aws.Util.option_bind (Aws.Xml.member "Version" xml) String.parse
      ; attributes =
          Aws.Xml.required
            "Attributes"
            (Aws.Util.option_bind
               (Aws.Xml.member "Attributes" xml)
               InventoryItemAttributeList.parse)
      ; display_name =
          Aws.Util.option_bind (Aws.Xml.member "DisplayName" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.display_name (fun f ->
               Aws.Query.Pair ("DisplayName", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Attributes.member", InventoryItemAttributeList.to_query v.attributes))
         ; Aws.Util.option_map v.version (fun f ->
               Aws.Query.Pair ("Version", String.to_query f))
         ; Some (Aws.Query.Pair ("TypeName", String.to_query v.type_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.display_name (fun f -> "DisplayName", String.to_json f)
         ; Some ("Attributes", InventoryItemAttributeList.to_json v.attributes)
         ; Aws.Util.option_map v.version (fun f -> "Version", String.to_json f)
         ; Some ("TypeName", String.to_json v.type_name)
         ])

  let of_json j =
    { type_name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TypeName"))
    ; version = Aws.Util.option_map (Aws.Json.lookup j "Version") String.of_json
    ; attributes =
        InventoryItemAttributeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Attributes"))
    ; display_name = Aws.Util.option_map (Aws.Json.lookup j "DisplayName") String.of_json
    }
end

module InventoryItemSchemaResultList = struct
  type t = InventoryItemSchema.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map InventoryItemSchema.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list InventoryItemSchema.to_query v
  let to_json v = `List (List.map InventoryItemSchema.to_json v)
  let of_json j = Aws.Json.to_list InventoryItemSchema.of_json j
end

module InventoryQueryOperatorType = struct
  type t =
    | Equal
    | NotEqual
    | BeginWith
    | LessThan
    | GreaterThan
    | Exists

  let str_to_t =
    [ "Exists", Exists
    ; "GreaterThan", GreaterThan
    ; "LessThan", LessThan
    ; "BeginWith", BeginWith
    ; "NotEqual", NotEqual
    ; "Equal", Equal
    ]

  let t_to_str =
    [ Exists, "Exists"
    ; GreaterThan, "GreaterThan"
    ; LessThan, "LessThan"
    ; BeginWith, "BeginWith"
    ; NotEqual, "NotEqual"
    ; Equal, "Equal"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module InventoryFilter = struct
  type t =
    { key : String.t
    ; values : InventoryFilterValueList.t
    ; type_ : InventoryQueryOperatorType.t option
    }

  let make ~key ~values ?type_ () = { key; values; type_ }

  let parse xml =
    Some
      { key =
          Aws.Xml.required
            "Key"
            (Aws.Util.option_bind (Aws.Xml.member "Key" xml) String.parse)
      ; values =
          Aws.Xml.required
            "Values"
            (Aws.Util.option_bind
               (Aws.Xml.member "Values" xml)
               InventoryFilterValueList.parse)
      ; type_ =
          Aws.Util.option_bind
            (Aws.Xml.member "Type" xml)
            InventoryQueryOperatorType.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", InventoryQueryOperatorType.to_query f))
         ; Some
             (Aws.Query.Pair ("Values.member", InventoryFilterValueList.to_query v.values))
         ; Some (Aws.Query.Pair ("Key", String.to_query v.key))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.type_ (fun f ->
               "Type", InventoryQueryOperatorType.to_json f)
         ; Some ("Values", InventoryFilterValueList.to_json v.values)
         ; Some ("Key", String.to_json v.key)
         ])

  let of_json j =
    { key = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Key"))
    ; values =
        InventoryFilterValueList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Values"))
    ; type_ =
        Aws.Util.option_map (Aws.Json.lookup j "Type") InventoryQueryOperatorType.of_json
    }
end

module InventoryFilterList = struct
  type t = InventoryFilter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map InventoryFilter.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list InventoryFilter.to_query v
  let to_json v = `List (List.map InventoryFilter.to_json v)
  let of_json j = Aws.Json.to_list InventoryFilter.of_json j
end

module InventoryGroup = struct
  type t =
    { name : String.t
    ; filters : InventoryFilterList.t
    }

  let make ~name ~filters () = { name; filters }

  let parse xml =
    Some
      { name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      ; filters =
          Aws.Xml.required
            "Filters"
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               InventoryFilterList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("Filters.member", InventoryFilterList.to_query v.filters))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Filters", InventoryFilterList.to_json v.filters)
         ; Some ("Name", String.to_json v.name)
         ])

  let of_json j =
    { name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; filters =
        InventoryFilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    }
end

module InventoryGroupList = struct
  type t = InventoryGroup.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map InventoryGroup.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list InventoryGroup.to_query v
  let to_json v = `List (List.map InventoryGroup.to_json v)
  let of_json j = Aws.Json.to_list InventoryGroup.of_json j
end

module rec InventoryAggregator : sig
  type t =
    { expression : String.t option
    ; aggregators : InventoryAggregatorList.t
    ; groups : InventoryGroupList.t
    }

  val make :
       ?expression:String.t
    -> ?aggregators:InventoryAggregatorList.t
    -> ?groups:InventoryGroupList.t
    -> unit
    -> t

  val parse : Ezxmlm.nodes -> t option
  val to_query : t -> Aws.Query.t
  val to_json : t -> Aws.Json.t
  val of_json : Aws.Json.t -> t
end = struct
  type t =
    { expression : String.t option
    ; aggregators : InventoryAggregatorList.t
    ; groups : InventoryGroupList.t
    }

  let make ?expression ?(aggregators = []) ?(groups = []) () =
    { expression; aggregators; groups }

  let parse xml =
    Some
      { expression = Aws.Util.option_bind (Aws.Xml.member "Expression" xml) String.parse
      ; aggregators =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Aggregators" xml)
               InventoryAggregatorList.parse)
      ; groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Groups" xml) InventoryGroupList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Groups.member", InventoryGroupList.to_query v.groups))
         ; Some
             (Aws.Query.Pair
                ("Aggregators.member", InventoryAggregatorList.to_query v.aggregators))
         ; Aws.Util.option_map v.expression (fun f ->
               Aws.Query.Pair ("Expression", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Groups", InventoryGroupList.to_json v.groups)
         ; Some ("Aggregators", InventoryAggregatorList.to_json v.aggregators)
         ; Aws.Util.option_map v.expression (fun f -> "Expression", String.to_json f)
         ])

  let of_json j =
    { expression = Aws.Util.option_map (Aws.Json.lookup j "Expression") String.of_json
    ; aggregators =
        InventoryAggregatorList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Aggregators"))
    ; groups =
        InventoryGroupList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Groups"))
    }
end

and InventoryAggregatorList : sig
  type t = InventoryAggregator.t list

  val make : 'a -> unit -> 'a
  val parse : Ezxmlm.nodes -> t option
  val to_query : t -> Aws.Query.t
  val to_json : t -> Aws.Json.t
  val of_json : Aws.Json.t -> t
end = struct
  type t = InventoryAggregator.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map InventoryAggregator.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list InventoryAggregator.to_query v
  let to_json v = `List (List.map InventoryAggregator.to_json v)
  let of_json j = Aws.Json.to_list InventoryAggregator.of_json j
end

module DocumentKeyValuesFilter = struct
  type t =
    { key : String.t option
    ; values : DocumentKeyValuesFilterValues.t
    }

  let make ?key ?(values = []) () = { key; values }

  let parse xml =
    Some
      { key = Aws.Util.option_bind (Aws.Xml.member "Key" xml) String.parse
      ; values =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Values" xml)
               DocumentKeyValuesFilterValues.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("Values.member", DocumentKeyValuesFilterValues.to_query v.values))
         ; Aws.Util.option_map v.key (fun f -> Aws.Query.Pair ("Key", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Values", DocumentKeyValuesFilterValues.to_json v.values)
         ; Aws.Util.option_map v.key (fun f -> "Key", String.to_json f)
         ])

  let of_json j =
    { key = Aws.Util.option_map (Aws.Json.lookup j "Key") String.of_json
    ; values =
        DocumentKeyValuesFilterValues.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Values"))
    }
end

module InvalidActivation = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module HierarchyTypeMismatchException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json }
end

module DeleteAssociationResult = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module ServiceSetting = struct
  type t =
    { setting_id : String.t option
    ; setting_value : String.t option
    ; last_modified_date : DateTime.t option
    ; last_modified_user : String.t option
    ; a_r_n : String.t option
    ; status : String.t option
    }

  let make
      ?setting_id
      ?setting_value
      ?last_modified_date
      ?last_modified_user
      ?a_r_n
      ?status
      () =
    { setting_id; setting_value; last_modified_date; last_modified_user; a_r_n; status }

  let parse xml =
    Some
      { setting_id = Aws.Util.option_bind (Aws.Xml.member "SettingId" xml) String.parse
      ; setting_value =
          Aws.Util.option_bind (Aws.Xml.member "SettingValue" xml) String.parse
      ; last_modified_date =
          Aws.Util.option_bind (Aws.Xml.member "LastModifiedDate" xml) DateTime.parse
      ; last_modified_user =
          Aws.Util.option_bind (Aws.Xml.member "LastModifiedUser" xml) String.parse
      ; a_r_n = Aws.Util.option_bind (Aws.Xml.member "ARN" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.a_r_n (fun f ->
               Aws.Query.Pair ("ARN", String.to_query f))
         ; Aws.Util.option_map v.last_modified_user (fun f ->
               Aws.Query.Pair ("LastModifiedUser", String.to_query f))
         ; Aws.Util.option_map v.last_modified_date (fun f ->
               Aws.Query.Pair ("LastModifiedDate", DateTime.to_query f))
         ; Aws.Util.option_map v.setting_value (fun f ->
               Aws.Query.Pair ("SettingValue", String.to_query f))
         ; Aws.Util.option_map v.setting_id (fun f ->
               Aws.Query.Pair ("SettingId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ; Aws.Util.option_map v.a_r_n (fun f -> "ARN", String.to_json f)
         ; Aws.Util.option_map v.last_modified_user (fun f ->
               "LastModifiedUser", String.to_json f)
         ; Aws.Util.option_map v.last_modified_date (fun f ->
               "LastModifiedDate", DateTime.to_json f)
         ; Aws.Util.option_map v.setting_value (fun f -> "SettingValue", String.to_json f)
         ; Aws.Util.option_map v.setting_id (fun f -> "SettingId", String.to_json f)
         ])

  let of_json j =
    { setting_id = Aws.Util.option_map (Aws.Json.lookup j "SettingId") String.of_json
    ; setting_value =
        Aws.Util.option_map (Aws.Json.lookup j "SettingValue") String.of_json
    ; last_modified_date =
        Aws.Util.option_map (Aws.Json.lookup j "LastModifiedDate") DateTime.of_json
    ; last_modified_user =
        Aws.Util.option_map (Aws.Json.lookup j "LastModifiedUser") String.of_json
    ; a_r_n = Aws.Util.option_map (Aws.Json.lookup j "ARN") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    }
end

module ResetServiceSettingResult = struct
  type t = { service_setting : ServiceSetting.t option }

  let make ?service_setting () = { service_setting }

  let parse xml =
    Some
      { service_setting =
          Aws.Util.option_bind (Aws.Xml.member "ServiceSetting" xml) ServiceSetting.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.service_setting (fun f ->
               Aws.Query.Pair ("ServiceSetting", ServiceSetting.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.service_setting (fun f ->
               "ServiceSetting", ServiceSetting.to_json f)
         ])

  let of_json j =
    { service_setting =
        Aws.Util.option_map (Aws.Json.lookup j "ServiceSetting") ServiceSetting.of_json
    }
end

module AssociationStatusName = struct
  type t =
    | Pending
    | Success
    | Failed

  let str_to_t = [ "Failed", Failed; "Success", Success; "Pending", Pending ]
  let t_to_str = [ Failed, "Failed"; Success, "Success"; Pending, "Pending" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module AssociationStatus = struct
  type t =
    { date : DateTime.t
    ; name : AssociationStatusName.t
    ; message : String.t
    ; additional_info : String.t option
    }

  let make ~date ~name ~message ?additional_info () =
    { date; name; message; additional_info }

  let parse xml =
    Some
      { date =
          Aws.Xml.required
            "Date"
            (Aws.Util.option_bind (Aws.Xml.member "Date" xml) DateTime.parse)
      ; name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) AssociationStatusName.parse)
      ; message =
          Aws.Xml.required
            "Message"
            (Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse)
      ; additional_info =
          Aws.Util.option_bind (Aws.Xml.member "AdditionalInfo" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.additional_info (fun f ->
               Aws.Query.Pair ("AdditionalInfo", String.to_query f))
         ; Some (Aws.Query.Pair ("Message", String.to_query v.message))
         ; Some (Aws.Query.Pair ("Name", AssociationStatusName.to_query v.name))
         ; Some (Aws.Query.Pair ("Date", DateTime.to_query v.date))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.additional_info (fun f ->
               "AdditionalInfo", String.to_json f)
         ; Some ("Message", String.to_json v.message)
         ; Some ("Name", AssociationStatusName.to_json v.name)
         ; Some ("Date", DateTime.to_json v.date)
         ])

  let of_json j =
    { date = DateTime.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Date"))
    ; name =
        AssociationStatusName.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; message = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Message"))
    ; additional_info =
        Aws.Util.option_map (Aws.Json.lookup j "AdditionalInfo") String.of_json
    }
end

module AssociationIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module UnsupportedFeatureRequiredException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module OpsEntityItemEntryList = struct
  type t = OpsEntityItemEntry.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map OpsEntityItemEntry.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list OpsEntityItemEntry.to_query v
  let to_json v = `List (List.map OpsEntityItemEntry.to_json v)
  let of_json j = Aws.Json.to_list OpsEntityItemEntry.of_json j
end

module UnsupportedInventoryItemContextException = struct
  type t =
    { type_name : String.t option
    ; message : String.t option
    }

  let make ?type_name ?message () = { type_name; message }

  let parse xml =
    Some
      { type_name = Aws.Util.option_bind (Aws.Xml.member "TypeName" xml) String.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.type_name (fun f ->
               Aws.Query.Pair ("TypeName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f)
         ; Aws.Util.option_map v.type_name (fun f -> "TypeName", String.to_json f)
         ])

  let of_json j =
    { type_name = Aws.Util.option_map (Aws.Json.lookup j "TypeName") String.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json
    }
end

module ResourceDataSyncSource = struct
  type t =
    { source_type : String.t
    ; aws_organizations_source : ResourceDataSyncAwsOrganizationsSource.t option
    ; source_regions : ResourceDataSyncSourceRegionList.t
    ; include_future_regions : Boolean.t option
    }

  let make
      ~source_type
      ?aws_organizations_source
      ~source_regions
      ?include_future_regions
      () =
    { source_type; aws_organizations_source; source_regions; include_future_regions }

  let parse xml =
    Some
      { source_type =
          Aws.Xml.required
            "SourceType"
            (Aws.Util.option_bind (Aws.Xml.member "SourceType" xml) String.parse)
      ; aws_organizations_source =
          Aws.Util.option_bind
            (Aws.Xml.member "AwsOrganizationsSource" xml)
            ResourceDataSyncAwsOrganizationsSource.parse
      ; source_regions =
          Aws.Xml.required
            "SourceRegions"
            (Aws.Util.option_bind
               (Aws.Xml.member "SourceRegions" xml)
               ResourceDataSyncSourceRegionList.parse)
      ; include_future_regions =
          Aws.Util.option_bind (Aws.Xml.member "IncludeFutureRegions" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.include_future_regions (fun f ->
               Aws.Query.Pair ("IncludeFutureRegions", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "SourceRegions.member"
                , ResourceDataSyncSourceRegionList.to_query v.source_regions ))
         ; Aws.Util.option_map v.aws_organizations_source (fun f ->
               Aws.Query.Pair
                 ( "AwsOrganizationsSource"
                 , ResourceDataSyncAwsOrganizationsSource.to_query f ))
         ; Some (Aws.Query.Pair ("SourceType", String.to_query v.source_type))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.include_future_regions (fun f ->
               "IncludeFutureRegions", Boolean.to_json f)
         ; Some
             ("SourceRegions", ResourceDataSyncSourceRegionList.to_json v.source_regions)
         ; Aws.Util.option_map v.aws_organizations_source (fun f ->
               "AwsOrganizationsSource", ResourceDataSyncAwsOrganizationsSource.to_json f)
         ; Some ("SourceType", String.to_json v.source_type)
         ])

  let of_json j =
    { source_type =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceType"))
    ; aws_organizations_source =
        Aws.Util.option_map
          (Aws.Json.lookup j "AwsOrganizationsSource")
          ResourceDataSyncAwsOrganizationsSource.of_json
    ; source_regions =
        ResourceDataSyncSourceRegionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceRegions"))
    ; include_future_regions =
        Aws.Util.option_map (Aws.Json.lookup j "IncludeFutureRegions") Boolean.of_json
    }
end

module MaintenanceWindowFilterValues = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module MaintenanceWindowFilter = struct
  type t =
    { key : String.t option
    ; values : MaintenanceWindowFilterValues.t
    }

  let make ?key ?(values = []) () = { key; values }

  let parse xml =
    Some
      { key = Aws.Util.option_bind (Aws.Xml.member "Key" xml) String.parse
      ; values =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Values" xml)
               MaintenanceWindowFilterValues.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("Values.member", MaintenanceWindowFilterValues.to_query v.values))
         ; Aws.Util.option_map v.key (fun f -> Aws.Query.Pair ("Key", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Values", MaintenanceWindowFilterValues.to_json v.values)
         ; Aws.Util.option_map v.key (fun f -> "Key", String.to_json f)
         ])

  let of_json j =
    { key = Aws.Util.option_map (Aws.Json.lookup j "Key") String.of_json
    ; values =
        MaintenanceWindowFilterValues.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Values"))
    }
end

module MaintenanceWindowFilterList = struct
  type t = MaintenanceWindowFilter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map MaintenanceWindowFilter.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list MaintenanceWindowFilter.to_query v
  let to_json v = `List (List.map MaintenanceWindowFilter.to_json v)
  let of_json j = Aws.Json.to_list MaintenanceWindowFilter.of_json j
end

module DescribeMaintenanceWindowsRequest = struct
  type t =
    { filters : MaintenanceWindowFilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?(filters = []) ?max_results ?next_token () =
    { filters; max_results; next_token }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               MaintenanceWindowFilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Filters.member", MaintenanceWindowFilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filters", MaintenanceWindowFilterList.to_json v.filters)
         ])

  let of_json j =
    { filters =
        MaintenanceWindowFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module Activation = struct
  type t =
    { activation_id : String.t option
    ; description : String.t option
    ; default_instance_name : String.t option
    ; iam_role : String.t option
    ; registration_limit : Integer.t option
    ; registrations_count : Integer.t option
    ; expiration_date : DateTime.t option
    ; expired : Boolean.t option
    ; created_date : DateTime.t option
    ; tags : TagList.t
    }

  let make
      ?activation_id
      ?description
      ?default_instance_name
      ?iam_role
      ?registration_limit
      ?registrations_count
      ?expiration_date
      ?expired
      ?created_date
      ?(tags = [])
      () =
    { activation_id
    ; description
    ; default_instance_name
    ; iam_role
    ; registration_limit
    ; registrations_count
    ; expiration_date
    ; expired
    ; created_date
    ; tags
    }

  let parse xml =
    Some
      { activation_id =
          Aws.Util.option_bind (Aws.Xml.member "ActivationId" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; default_instance_name =
          Aws.Util.option_bind (Aws.Xml.member "DefaultInstanceName" xml) String.parse
      ; iam_role = Aws.Util.option_bind (Aws.Xml.member "IamRole" xml) String.parse
      ; registration_limit =
          Aws.Util.option_bind (Aws.Xml.member "RegistrationLimit" xml) Integer.parse
      ; registrations_count =
          Aws.Util.option_bind (Aws.Xml.member "RegistrationsCount" xml) Integer.parse
      ; expiration_date =
          Aws.Util.option_bind (Aws.Xml.member "ExpirationDate" xml) DateTime.parse
      ; expired = Aws.Util.option_bind (Aws.Xml.member "Expired" xml) Boolean.parse
      ; created_date =
          Aws.Util.option_bind (Aws.Xml.member "CreatedDate" xml) DateTime.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Aws.Util.option_map v.created_date (fun f ->
               Aws.Query.Pair ("CreatedDate", DateTime.to_query f))
         ; Aws.Util.option_map v.expired (fun f ->
               Aws.Query.Pair ("Expired", Boolean.to_query f))
         ; Aws.Util.option_map v.expiration_date (fun f ->
               Aws.Query.Pair ("ExpirationDate", DateTime.to_query f))
         ; Aws.Util.option_map v.registrations_count (fun f ->
               Aws.Query.Pair ("RegistrationsCount", Integer.to_query f))
         ; Aws.Util.option_map v.registration_limit (fun f ->
               Aws.Query.Pair ("RegistrationLimit", Integer.to_query f))
         ; Aws.Util.option_map v.iam_role (fun f ->
               Aws.Query.Pair ("IamRole", String.to_query f))
         ; Aws.Util.option_map v.default_instance_name (fun f ->
               Aws.Query.Pair ("DefaultInstanceName", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.activation_id (fun f ->
               Aws.Query.Pair ("ActivationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tags", TagList.to_json v.tags)
         ; Aws.Util.option_map v.created_date (fun f -> "CreatedDate", DateTime.to_json f)
         ; Aws.Util.option_map v.expired (fun f -> "Expired", Boolean.to_json f)
         ; Aws.Util.option_map v.expiration_date (fun f ->
               "ExpirationDate", DateTime.to_json f)
         ; Aws.Util.option_map v.registrations_count (fun f ->
               "RegistrationsCount", Integer.to_json f)
         ; Aws.Util.option_map v.registration_limit (fun f ->
               "RegistrationLimit", Integer.to_json f)
         ; Aws.Util.option_map v.iam_role (fun f -> "IamRole", String.to_json f)
         ; Aws.Util.option_map v.default_instance_name (fun f ->
               "DefaultInstanceName", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.activation_id (fun f -> "ActivationId", String.to_json f)
         ])

  let of_json j =
    { activation_id =
        Aws.Util.option_map (Aws.Json.lookup j "ActivationId") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; default_instance_name =
        Aws.Util.option_map (Aws.Json.lookup j "DefaultInstanceName") String.of_json
    ; iam_role = Aws.Util.option_map (Aws.Json.lookup j "IamRole") String.of_json
    ; registration_limit =
        Aws.Util.option_map (Aws.Json.lookup j "RegistrationLimit") Integer.of_json
    ; registrations_count =
        Aws.Util.option_map (Aws.Json.lookup j "RegistrationsCount") Integer.of_json
    ; expiration_date =
        Aws.Util.option_map (Aws.Json.lookup j "ExpirationDate") DateTime.of_json
    ; expired = Aws.Util.option_map (Aws.Json.lookup j "Expired") Boolean.of_json
    ; created_date =
        Aws.Util.option_map (Aws.Json.lookup j "CreatedDate") DateTime.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    }
end

module ActivationList = struct
  type t = Activation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Activation.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list Activation.to_query v
  let to_json v = `List (List.map Activation.to_json v)
  let of_json j = Aws.Json.to_list Activation.of_json j
end

module RemoveTagsFromResourceResult = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module CommandPluginList = struct
  type t = CommandPlugin.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map CommandPlugin.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list CommandPlugin.to_query v
  let to_json v = `List (List.map CommandPlugin.to_json v)
  let of_json j = Aws.Json.to_list CommandPlugin.of_json j
end

module CommandInvocation = struct
  type t =
    { command_id : String.t option
    ; instance_id : String.t option
    ; instance_name : String.t option
    ; comment : String.t option
    ; document_name : String.t option
    ; document_version : String.t option
    ; requested_date_time : DateTime.t option
    ; status : CommandInvocationStatus.t option
    ; status_details : String.t option
    ; trace_output : String.t option
    ; standard_output_url : String.t option
    ; standard_error_url : String.t option
    ; command_plugins : CommandPluginList.t
    ; service_role : String.t option
    ; notification_config : NotificationConfig.t option
    ; cloud_watch_output_config : CloudWatchOutputConfig.t option
    }

  let make
      ?command_id
      ?instance_id
      ?instance_name
      ?comment
      ?document_name
      ?document_version
      ?requested_date_time
      ?status
      ?status_details
      ?trace_output
      ?standard_output_url
      ?standard_error_url
      ?(command_plugins = [])
      ?service_role
      ?notification_config
      ?cloud_watch_output_config
      () =
    { command_id
    ; instance_id
    ; instance_name
    ; comment
    ; document_name
    ; document_version
    ; requested_date_time
    ; status
    ; status_details
    ; trace_output
    ; standard_output_url
    ; standard_error_url
    ; command_plugins
    ; service_role
    ; notification_config
    ; cloud_watch_output_config
    }

  let parse xml =
    Some
      { command_id = Aws.Util.option_bind (Aws.Xml.member "CommandId" xml) String.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse
      ; instance_name =
          Aws.Util.option_bind (Aws.Xml.member "InstanceName" xml) String.parse
      ; comment = Aws.Util.option_bind (Aws.Xml.member "Comment" xml) String.parse
      ; document_name =
          Aws.Util.option_bind (Aws.Xml.member "DocumentName" xml) String.parse
      ; document_version =
          Aws.Util.option_bind (Aws.Xml.member "DocumentVersion" xml) String.parse
      ; requested_date_time =
          Aws.Util.option_bind (Aws.Xml.member "RequestedDateTime" xml) DateTime.parse
      ; status =
          Aws.Util.option_bind (Aws.Xml.member "Status" xml) CommandInvocationStatus.parse
      ; status_details =
          Aws.Util.option_bind (Aws.Xml.member "StatusDetails" xml) String.parse
      ; trace_output =
          Aws.Util.option_bind (Aws.Xml.member "TraceOutput" xml) String.parse
      ; standard_output_url =
          Aws.Util.option_bind (Aws.Xml.member "StandardOutputUrl" xml) String.parse
      ; standard_error_url =
          Aws.Util.option_bind (Aws.Xml.member "StandardErrorUrl" xml) String.parse
      ; command_plugins =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "CommandPlugins" xml)
               CommandPluginList.parse)
      ; service_role =
          Aws.Util.option_bind (Aws.Xml.member "ServiceRole" xml) String.parse
      ; notification_config =
          Aws.Util.option_bind
            (Aws.Xml.member "NotificationConfig" xml)
            NotificationConfig.parse
      ; cloud_watch_output_config =
          Aws.Util.option_bind
            (Aws.Xml.member "CloudWatchOutputConfig" xml)
            CloudWatchOutputConfig.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cloud_watch_output_config (fun f ->
               Aws.Query.Pair ("CloudWatchOutputConfig", CloudWatchOutputConfig.to_query f))
         ; Aws.Util.option_map v.notification_config (fun f ->
               Aws.Query.Pair ("NotificationConfig", NotificationConfig.to_query f))
         ; Aws.Util.option_map v.service_role (fun f ->
               Aws.Query.Pair ("ServiceRole", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("CommandPlugins.member", CommandPluginList.to_query v.command_plugins))
         ; Aws.Util.option_map v.standard_error_url (fun f ->
               Aws.Query.Pair ("StandardErrorUrl", String.to_query f))
         ; Aws.Util.option_map v.standard_output_url (fun f ->
               Aws.Query.Pair ("StandardOutputUrl", String.to_query f))
         ; Aws.Util.option_map v.trace_output (fun f ->
               Aws.Query.Pair ("TraceOutput", String.to_query f))
         ; Aws.Util.option_map v.status_details (fun f ->
               Aws.Query.Pair ("StatusDetails", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", CommandInvocationStatus.to_query f))
         ; Aws.Util.option_map v.requested_date_time (fun f ->
               Aws.Query.Pair ("RequestedDateTime", DateTime.to_query f))
         ; Aws.Util.option_map v.document_version (fun f ->
               Aws.Query.Pair ("DocumentVersion", String.to_query f))
         ; Aws.Util.option_map v.document_name (fun f ->
               Aws.Query.Pair ("DocumentName", String.to_query f))
         ; Aws.Util.option_map v.comment (fun f ->
               Aws.Query.Pair ("Comment", String.to_query f))
         ; Aws.Util.option_map v.instance_name (fun f ->
               Aws.Query.Pair ("InstanceName", String.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.command_id (fun f ->
               Aws.Query.Pair ("CommandId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cloud_watch_output_config (fun f ->
               "CloudWatchOutputConfig", CloudWatchOutputConfig.to_json f)
         ; Aws.Util.option_map v.notification_config (fun f ->
               "NotificationConfig", NotificationConfig.to_json f)
         ; Aws.Util.option_map v.service_role (fun f -> "ServiceRole", String.to_json f)
         ; Some ("CommandPlugins", CommandPluginList.to_json v.command_plugins)
         ; Aws.Util.option_map v.standard_error_url (fun f ->
               "StandardErrorUrl", String.to_json f)
         ; Aws.Util.option_map v.standard_output_url (fun f ->
               "StandardOutputUrl", String.to_json f)
         ; Aws.Util.option_map v.trace_output (fun f -> "TraceOutput", String.to_json f)
         ; Aws.Util.option_map v.status_details (fun f ->
               "StatusDetails", String.to_json f)
         ; Aws.Util.option_map v.status (fun f ->
               "Status", CommandInvocationStatus.to_json f)
         ; Aws.Util.option_map v.requested_date_time (fun f ->
               "RequestedDateTime", DateTime.to_json f)
         ; Aws.Util.option_map v.document_version (fun f ->
               "DocumentVersion", String.to_json f)
         ; Aws.Util.option_map v.document_name (fun f -> "DocumentName", String.to_json f)
         ; Aws.Util.option_map v.comment (fun f -> "Comment", String.to_json f)
         ; Aws.Util.option_map v.instance_name (fun f -> "InstanceName", String.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "InstanceId", String.to_json f)
         ; Aws.Util.option_map v.command_id (fun f -> "CommandId", String.to_json f)
         ])

  let of_json j =
    { command_id = Aws.Util.option_map (Aws.Json.lookup j "CommandId") String.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "InstanceId") String.of_json
    ; instance_name =
        Aws.Util.option_map (Aws.Json.lookup j "InstanceName") String.of_json
    ; comment = Aws.Util.option_map (Aws.Json.lookup j "Comment") String.of_json
    ; document_name =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentName") String.of_json
    ; document_version =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentVersion") String.of_json
    ; requested_date_time =
        Aws.Util.option_map (Aws.Json.lookup j "RequestedDateTime") DateTime.of_json
    ; status =
        Aws.Util.option_map (Aws.Json.lookup j "Status") CommandInvocationStatus.of_json
    ; status_details =
        Aws.Util.option_map (Aws.Json.lookup j "StatusDetails") String.of_json
    ; trace_output = Aws.Util.option_map (Aws.Json.lookup j "TraceOutput") String.of_json
    ; standard_output_url =
        Aws.Util.option_map (Aws.Json.lookup j "StandardOutputUrl") String.of_json
    ; standard_error_url =
        Aws.Util.option_map (Aws.Json.lookup j "StandardErrorUrl") String.of_json
    ; command_plugins =
        CommandPluginList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "CommandPlugins"))
    ; service_role = Aws.Util.option_map (Aws.Json.lookup j "ServiceRole") String.of_json
    ; notification_config =
        Aws.Util.option_map
          (Aws.Json.lookup j "NotificationConfig")
          NotificationConfig.of_json
    ; cloud_watch_output_config =
        Aws.Util.option_map
          (Aws.Json.lookup j "CloudWatchOutputConfig")
          CloudWatchOutputConfig.of_json
    }
end

module CommandInvocationList = struct
  type t = CommandInvocation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map CommandInvocation.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list CommandInvocation.to_query v
  let to_json v = `List (List.map CommandInvocation.to_json v)
  let of_json j = Aws.Json.to_list CommandInvocation.of_json j
end

module ListCommandInvocationsResult = struct
  type t =
    { command_invocations : CommandInvocationList.t
    ; next_token : String.t option
    }

  let make ?(command_invocations = []) ?next_token () =
    { command_invocations; next_token }

  let parse xml =
    Some
      { command_invocations =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "CommandInvocations" xml)
               CommandInvocationList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "CommandInvocations.member"
                , CommandInvocationList.to_query v.command_invocations ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("CommandInvocations", CommandInvocationList.to_json v.command_invocations)
         ])

  let of_json j =
    { command_invocations =
        CommandInvocationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "CommandInvocations"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module DeleteParameterResult = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module RelatedOpsItem = struct
  type t = { ops_item_id : String.t }

  let make ~ops_item_id () = { ops_item_id }

  let parse xml =
    Some
      { ops_item_id =
          Aws.Xml.required
            "OpsItemId"
            (Aws.Util.option_bind (Aws.Xml.member "OpsItemId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("OpsItemId", String.to_query v.ops_item_id)) ])

  let to_json v =
    `Assoc (Aws.Util.list_filter_opt [ Some ("OpsItemId", String.to_json v.ops_item_id) ])

  let of_json j =
    { ops_item_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "OpsItemId"))
    }
end

module RelatedOpsItems = struct
  type t = RelatedOpsItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map RelatedOpsItem.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list RelatedOpsItem.to_query v
  let to_json v = `List (List.map RelatedOpsItem.to_json v)
  let of_json j = Aws.Json.to_list RelatedOpsItem.of_json j
end

module OpsItemDataType = struct
  type t =
    | SearchableString
    | String

  let str_to_t = [ "String", String; "SearchableString", SearchableString ]
  let t_to_str = [ String, "String"; SearchableString, "SearchableString" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module OpsItemDataValue = struct
  type t =
    { value : String.t option
    ; type_ : OpsItemDataType.t option
    }

  let make ?value ?type_ () = { value; type_ }

  let parse xml =
    Some
      { value = Aws.Util.option_bind (Aws.Xml.member "Value" xml) String.parse
      ; type_ = Aws.Util.option_bind (Aws.Xml.member "Type" xml) OpsItemDataType.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", OpsItemDataType.to_query f))
         ; Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.type_ (fun f -> "Type", OpsItemDataType.to_json f)
         ; Aws.Util.option_map v.value (fun f -> "Value", String.to_json f)
         ])

  let of_json j =
    { value = Aws.Util.option_map (Aws.Json.lookup j "Value") String.of_json
    ; type_ = Aws.Util.option_map (Aws.Json.lookup j "Type") OpsItemDataType.of_json
    }
end

module OpsItemOperationalData = struct
  type t = (String.t, OpsItemDataValue.t) Hashtbl.t

  let make elems () = elems
  let parse xml = None
  let to_query v = Aws.Query.to_query_hashtbl String.to_string OpsItemDataValue.to_query v

  let to_json v =
    `Assoc
      (Hashtbl.fold
         (fun k v acc -> (String.to_string k, OpsItemDataValue.to_json v) :: acc)
         v
         [])

  let of_json j = Aws.Json.to_hashtbl String.of_string OpsItemDataValue.of_json j
end

module OpsItemNotification = struct
  type t = { arn : String.t option }

  let make ?arn () = { arn }

  let parse xml =
    Some { arn = Aws.Util.option_bind (Aws.Xml.member "Arn" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.arn (fun f -> Aws.Query.Pair ("Arn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.arn (fun f -> "Arn", String.to_json f) ])

  let of_json j = { arn = Aws.Util.option_map (Aws.Json.lookup j "Arn") String.of_json }
end

module OpsItemNotifications = struct
  type t = OpsItemNotification.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map OpsItemNotification.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list OpsItemNotification.to_query v
  let to_json v = `List (List.map OpsItemNotification.to_json v)
  let of_json j = Aws.Json.to_list OpsItemNotification.of_json j
end

module CreateOpsItemRequest = struct
  type t =
    { description : String.t
    ; operational_data : OpsItemOperationalData.t option
    ; notifications : OpsItemNotifications.t
    ; priority : Integer.t option
    ; related_ops_items : RelatedOpsItems.t
    ; source : String.t
    ; title : String.t
    ; tags : TagList.t
    ; category : String.t option
    ; severity : String.t option
    }

  let make
      ~description
      ?operational_data
      ?(notifications = [])
      ?priority
      ?(related_ops_items = [])
      ~source
      ~title
      ?(tags = [])
      ?category
      ?severity
      () =
    { description
    ; operational_data
    ; notifications
    ; priority
    ; related_ops_items
    ; source
    ; title
    ; tags
    ; category
    ; severity
    }

  let parse xml =
    Some
      { description =
          Aws.Xml.required
            "Description"
            (Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse)
      ; operational_data =
          Aws.Util.option_bind
            (Aws.Xml.member "OperationalData" xml)
            OpsItemOperationalData.parse
      ; notifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Notifications" xml)
               OpsItemNotifications.parse)
      ; priority = Aws.Util.option_bind (Aws.Xml.member "Priority" xml) Integer.parse
      ; related_ops_items =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "RelatedOpsItems" xml)
               RelatedOpsItems.parse)
      ; source =
          Aws.Xml.required
            "Source"
            (Aws.Util.option_bind (Aws.Xml.member "Source" xml) String.parse)
      ; title =
          Aws.Xml.required
            "Title"
            (Aws.Util.option_bind (Aws.Xml.member "Title" xml) String.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      ; category = Aws.Util.option_bind (Aws.Xml.member "Category" xml) String.parse
      ; severity = Aws.Util.option_bind (Aws.Xml.member "Severity" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.severity (fun f ->
               Aws.Query.Pair ("Severity", String.to_query f))
         ; Aws.Util.option_map v.category (fun f ->
               Aws.Query.Pair ("Category", String.to_query f))
         ; Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Some (Aws.Query.Pair ("Title", String.to_query v.title))
         ; Some (Aws.Query.Pair ("Source", String.to_query v.source))
         ; Some
             (Aws.Query.Pair
                ("RelatedOpsItems.member", RelatedOpsItems.to_query v.related_ops_items))
         ; Aws.Util.option_map v.priority (fun f ->
               Aws.Query.Pair ("Priority", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Notifications.member", OpsItemNotifications.to_query v.notifications))
         ; Aws.Util.option_map v.operational_data (fun f ->
               Aws.Query.Pair ("OperationalData", OpsItemOperationalData.to_query f))
         ; Some (Aws.Query.Pair ("Description", String.to_query v.description))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.severity (fun f -> "Severity", String.to_json f)
         ; Aws.Util.option_map v.category (fun f -> "Category", String.to_json f)
         ; Some ("Tags", TagList.to_json v.tags)
         ; Some ("Title", String.to_json v.title)
         ; Some ("Source", String.to_json v.source)
         ; Some ("RelatedOpsItems", RelatedOpsItems.to_json v.related_ops_items)
         ; Aws.Util.option_map v.priority (fun f -> "Priority", Integer.to_json f)
         ; Some ("Notifications", OpsItemNotifications.to_json v.notifications)
         ; Aws.Util.option_map v.operational_data (fun f ->
               "OperationalData", OpsItemOperationalData.to_json f)
         ; Some ("Description", String.to_json v.description)
         ])

  let of_json j =
    { description =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Description"))
    ; operational_data =
        Aws.Util.option_map
          (Aws.Json.lookup j "OperationalData")
          OpsItemOperationalData.of_json
    ; notifications =
        OpsItemNotifications.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Notifications"))
    ; priority = Aws.Util.option_map (Aws.Json.lookup j "Priority") Integer.of_json
    ; related_ops_items =
        RelatedOpsItems.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "RelatedOpsItems"))
    ; source = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Source"))
    ; title = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Title"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    ; category = Aws.Util.option_map (Aws.Json.lookup j "Category") String.of_json
    ; severity = Aws.Util.option_map (Aws.Json.lookup j "Severity") String.of_json
    }
end

module StepExecutionFilterValueList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module ComplianceStatus = struct
  type t =
    | COMPLIANT
    | NON_COMPLIANT

  let str_to_t = [ "NON_COMPLIANT", NON_COMPLIANT; "COMPLIANT", COMPLIANT ]
  let t_to_str = [ NON_COMPLIANT, "NON_COMPLIANT"; COMPLIANT, "COMPLIANT" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module PutParameterRequest = struct
  type t =
    { name : String.t
    ; description : String.t option
    ; value : String.t
    ; type_ : ParameterType.t option
    ; key_id : String.t option
    ; overwrite : Boolean.t option
    ; allowed_pattern : String.t option
    ; tags : TagList.t
    ; tier : ParameterTier.t option
    ; policies : String.t option
    ; data_type : String.t option
    }

  let make
      ~name
      ?description
      ~value
      ?type_
      ?key_id
      ?overwrite
      ?allowed_pattern
      ?(tags = [])
      ?tier
      ?policies
      ?data_type
      () =
    { name
    ; description
    ; value
    ; type_
    ; key_id
    ; overwrite
    ; allowed_pattern
    ; tags
    ; tier
    ; policies
    ; data_type
    }

  let parse xml =
    Some
      { name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; value =
          Aws.Xml.required
            "Value"
            (Aws.Util.option_bind (Aws.Xml.member "Value" xml) String.parse)
      ; type_ = Aws.Util.option_bind (Aws.Xml.member "Type" xml) ParameterType.parse
      ; key_id = Aws.Util.option_bind (Aws.Xml.member "KeyId" xml) String.parse
      ; overwrite = Aws.Util.option_bind (Aws.Xml.member "Overwrite" xml) Boolean.parse
      ; allowed_pattern =
          Aws.Util.option_bind (Aws.Xml.member "AllowedPattern" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      ; tier = Aws.Util.option_bind (Aws.Xml.member "Tier" xml) ParameterTier.parse
      ; policies = Aws.Util.option_bind (Aws.Xml.member "Policies" xml) String.parse
      ; data_type = Aws.Util.option_bind (Aws.Xml.member "DataType" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.data_type (fun f ->
               Aws.Query.Pair ("DataType", String.to_query f))
         ; Aws.Util.option_map v.policies (fun f ->
               Aws.Query.Pair ("Policies", String.to_query f))
         ; Aws.Util.option_map v.tier (fun f ->
               Aws.Query.Pair ("Tier", ParameterTier.to_query f))
         ; Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Aws.Util.option_map v.allowed_pattern (fun f ->
               Aws.Query.Pair ("AllowedPattern", String.to_query f))
         ; Aws.Util.option_map v.overwrite (fun f ->
               Aws.Query.Pair ("Overwrite", Boolean.to_query f))
         ; Aws.Util.option_map v.key_id (fun f ->
               Aws.Query.Pair ("KeyId", String.to_query f))
         ; Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", ParameterType.to_query f))
         ; Some (Aws.Query.Pair ("Value", String.to_query v.value))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.data_type (fun f -> "DataType", String.to_json f)
         ; Aws.Util.option_map v.policies (fun f -> "Policies", String.to_json f)
         ; Aws.Util.option_map v.tier (fun f -> "Tier", ParameterTier.to_json f)
         ; Some ("Tags", TagList.to_json v.tags)
         ; Aws.Util.option_map v.allowed_pattern (fun f ->
               "AllowedPattern", String.to_json f)
         ; Aws.Util.option_map v.overwrite (fun f -> "Overwrite", Boolean.to_json f)
         ; Aws.Util.option_map v.key_id (fun f -> "KeyId", String.to_json f)
         ; Aws.Util.option_map v.type_ (fun f -> "Type", ParameterType.to_json f)
         ; Some ("Value", String.to_json v.value)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Some ("Name", String.to_json v.name)
         ])

  let of_json j =
    { name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; value = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Value"))
    ; type_ = Aws.Util.option_map (Aws.Json.lookup j "Type") ParameterType.of_json
    ; key_id = Aws.Util.option_map (Aws.Json.lookup j "KeyId") String.of_json
    ; overwrite = Aws.Util.option_map (Aws.Json.lookup j "Overwrite") Boolean.of_json
    ; allowed_pattern =
        Aws.Util.option_map (Aws.Json.lookup j "AllowedPattern") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    ; tier = Aws.Util.option_map (Aws.Json.lookup j "Tier") ParameterTier.of_json
    ; policies = Aws.Util.option_map (Aws.Json.lookup j "Policies") String.of_json
    ; data_type = Aws.Util.option_map (Aws.Json.lookup j "DataType") String.of_json
    }
end

module TotalSizeLimitExceededException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module IncompatiblePolicyException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json }
end

module OpsItemStatus = struct
  type t =
    | Open
    | InProgress
    | Resolved

  let str_to_t = [ "Resolved", Resolved; "InProgress", InProgress; "Open", Open ]
  let t_to_str = [ Resolved, "Resolved"; InProgress, "InProgress"; Open, "Open" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module RegisterTargetWithMaintenanceWindowRequest = struct
  type t =
    { window_id : String.t
    ; resource_type : MaintenanceWindowResourceType.t
    ; targets : Targets.t
    ; owner_information : String.t option
    ; name : String.t option
    ; description : String.t option
    ; client_token : String.t option
    }

  let make
      ~window_id
      ~resource_type
      ~targets
      ?owner_information
      ?name
      ?description
      ?client_token
      () =
    { window_id
    ; resource_type
    ; targets
    ; owner_information
    ; name
    ; description
    ; client_token
    }

  let parse xml =
    Some
      { window_id =
          Aws.Xml.required
            "WindowId"
            (Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse)
      ; resource_type =
          Aws.Xml.required
            "ResourceType"
            (Aws.Util.option_bind
               (Aws.Xml.member "ResourceType" xml)
               MaintenanceWindowResourceType.parse)
      ; targets =
          Aws.Xml.required
            "Targets"
            (Aws.Util.option_bind (Aws.Xml.member "Targets" xml) Targets.parse)
      ; owner_information =
          Aws.Util.option_bind (Aws.Xml.member "OwnerInformation" xml) String.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.owner_information (fun f ->
               Aws.Query.Pair ("OwnerInformation", String.to_query f))
         ; Some (Aws.Query.Pair ("Targets.member", Targets.to_query v.targets))
         ; Some
             (Aws.Query.Pair
                ("ResourceType", MaintenanceWindowResourceType.to_query v.resource_type))
         ; Some (Aws.Query.Pair ("WindowId", String.to_query v.window_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.owner_information (fun f ->
               "OwnerInformation", String.to_json f)
         ; Some ("Targets", Targets.to_json v.targets)
         ; Some ("ResourceType", MaintenanceWindowResourceType.to_json v.resource_type)
         ; Some ("WindowId", String.to_json v.window_id)
         ])

  let of_json j =
    { window_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowId"))
    ; resource_type =
        MaintenanceWindowResourceType.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ResourceType"))
    ; targets = Targets.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Targets"))
    ; owner_information =
        Aws.Util.option_map (Aws.Json.lookup j "OwnerInformation") String.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    }
end

module DocumentPermissionType = struct
  type t = Share

  let str_to_t = [ "Share", Share ]
  let t_to_str = [ Share, "Share" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module AccountIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module ModifyDocumentPermissionRequest = struct
  type t =
    { name : String.t
    ; permission_type : DocumentPermissionType.t
    ; account_ids_to_add : AccountIdList.t
    ; account_ids_to_remove : AccountIdList.t
    ; shared_document_version : String.t option
    }

  let make
      ~name
      ~permission_type
      ?(account_ids_to_add = [])
      ?(account_ids_to_remove = [])
      ?shared_document_version
      () =
    { name
    ; permission_type
    ; account_ids_to_add
    ; account_ids_to_remove
    ; shared_document_version
    }

  let parse xml =
    Some
      { name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      ; permission_type =
          Aws.Xml.required
            "PermissionType"
            (Aws.Util.option_bind
               (Aws.Xml.member "PermissionType" xml)
               DocumentPermissionType.parse)
      ; account_ids_to_add =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AccountIdsToAdd" xml)
               AccountIdList.parse)
      ; account_ids_to_remove =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AccountIdsToRemove" xml)
               AccountIdList.parse)
      ; shared_document_version =
          Aws.Util.option_bind (Aws.Xml.member "SharedDocumentVersion" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.shared_document_version (fun f ->
               Aws.Query.Pair ("SharedDocumentVersion", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "AccountIdsToRemove.member"
                , AccountIdList.to_query v.account_ids_to_remove ))
         ; Some
             (Aws.Query.Pair
                ("AccountIdsToAdd.member", AccountIdList.to_query v.account_ids_to_add))
         ; Some
             (Aws.Query.Pair
                ("PermissionType", DocumentPermissionType.to_query v.permission_type))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.shared_document_version (fun f ->
               "SharedDocumentVersion", String.to_json f)
         ; Some ("AccountIdsToRemove", AccountIdList.to_json v.account_ids_to_remove)
         ; Some ("AccountIdsToAdd", AccountIdList.to_json v.account_ids_to_add)
         ; Some ("PermissionType", DocumentPermissionType.to_json v.permission_type)
         ; Some ("Name", String.to_json v.name)
         ])

  let of_json j =
    { name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; permission_type =
        DocumentPermissionType.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "PermissionType"))
    ; account_ids_to_add =
        AccountIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AccountIdsToAdd"))
    ; account_ids_to_remove =
        AccountIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AccountIdsToRemove"))
    ; shared_document_version =
        Aws.Util.option_map (Aws.Json.lookup j "SharedDocumentVersion") String.of_json
    }
end

module OutputSource = struct
  type t =
    { output_source_id : String.t option
    ; output_source_type : String.t option
    }

  let make ?output_source_id ?output_source_type () =
    { output_source_id; output_source_type }

  let parse xml =
    Some
      { output_source_id =
          Aws.Util.option_bind (Aws.Xml.member "OutputSourceId" xml) String.parse
      ; output_source_type =
          Aws.Util.option_bind (Aws.Xml.member "OutputSourceType" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.output_source_type (fun f ->
               Aws.Query.Pair ("OutputSourceType", String.to_query f))
         ; Aws.Util.option_map v.output_source_id (fun f ->
               Aws.Query.Pair ("OutputSourceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.output_source_type (fun f ->
               "OutputSourceType", String.to_json f)
         ; Aws.Util.option_map v.output_source_id (fun f ->
               "OutputSourceId", String.to_json f)
         ])

  let of_json j =
    { output_source_id =
        Aws.Util.option_map (Aws.Json.lookup j "OutputSourceId") String.of_json
    ; output_source_type =
        Aws.Util.option_map (Aws.Json.lookup j "OutputSourceType") String.of_json
    }
end

module AssociationExecutionTarget = struct
  type t =
    { association_id : String.t option
    ; association_version : String.t option
    ; execution_id : String.t option
    ; resource_id : String.t option
    ; resource_type : String.t option
    ; status : String.t option
    ; detailed_status : String.t option
    ; last_execution_date : DateTime.t option
    ; output_source : OutputSource.t option
    }

  let make
      ?association_id
      ?association_version
      ?execution_id
      ?resource_id
      ?resource_type
      ?status
      ?detailed_status
      ?last_execution_date
      ?output_source
      () =
    { association_id
    ; association_version
    ; execution_id
    ; resource_id
    ; resource_type
    ; status
    ; detailed_status
    ; last_execution_date
    ; output_source
    }

  let parse xml =
    Some
      { association_id =
          Aws.Util.option_bind (Aws.Xml.member "AssociationId" xml) String.parse
      ; association_version =
          Aws.Util.option_bind (Aws.Xml.member "AssociationVersion" xml) String.parse
      ; execution_id =
          Aws.Util.option_bind (Aws.Xml.member "ExecutionId" xml) String.parse
      ; resource_id = Aws.Util.option_bind (Aws.Xml.member "ResourceId" xml) String.parse
      ; resource_type =
          Aws.Util.option_bind (Aws.Xml.member "ResourceType" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      ; detailed_status =
          Aws.Util.option_bind (Aws.Xml.member "DetailedStatus" xml) String.parse
      ; last_execution_date =
          Aws.Util.option_bind (Aws.Xml.member "LastExecutionDate" xml) DateTime.parse
      ; output_source =
          Aws.Util.option_bind (Aws.Xml.member "OutputSource" xml) OutputSource.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.output_source (fun f ->
               Aws.Query.Pair ("OutputSource", OutputSource.to_query f))
         ; Aws.Util.option_map v.last_execution_date (fun f ->
               Aws.Query.Pair ("LastExecutionDate", DateTime.to_query f))
         ; Aws.Util.option_map v.detailed_status (fun f ->
               Aws.Query.Pair ("DetailedStatus", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.resource_type (fun f ->
               Aws.Query.Pair ("ResourceType", String.to_query f))
         ; Aws.Util.option_map v.resource_id (fun f ->
               Aws.Query.Pair ("ResourceId", String.to_query f))
         ; Aws.Util.option_map v.execution_id (fun f ->
               Aws.Query.Pair ("ExecutionId", String.to_query f))
         ; Aws.Util.option_map v.association_version (fun f ->
               Aws.Query.Pair ("AssociationVersion", String.to_query f))
         ; Aws.Util.option_map v.association_id (fun f ->
               Aws.Query.Pair ("AssociationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.output_source (fun f ->
               "OutputSource", OutputSource.to_json f)
         ; Aws.Util.option_map v.last_execution_date (fun f ->
               "LastExecutionDate", DateTime.to_json f)
         ; Aws.Util.option_map v.detailed_status (fun f ->
               "DetailedStatus", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ; Aws.Util.option_map v.resource_type (fun f -> "ResourceType", String.to_json f)
         ; Aws.Util.option_map v.resource_id (fun f -> "ResourceId", String.to_json f)
         ; Aws.Util.option_map v.execution_id (fun f -> "ExecutionId", String.to_json f)
         ; Aws.Util.option_map v.association_version (fun f ->
               "AssociationVersion", String.to_json f)
         ; Aws.Util.option_map v.association_id (fun f ->
               "AssociationId", String.to_json f)
         ])

  let of_json j =
    { association_id =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationId") String.of_json
    ; association_version =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationVersion") String.of_json
    ; execution_id = Aws.Util.option_map (Aws.Json.lookup j "ExecutionId") String.of_json
    ; resource_id = Aws.Util.option_map (Aws.Json.lookup j "ResourceId") String.of_json
    ; resource_type =
        Aws.Util.option_map (Aws.Json.lookup j "ResourceType") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    ; detailed_status =
        Aws.Util.option_map (Aws.Json.lookup j "DetailedStatus") String.of_json
    ; last_execution_date =
        Aws.Util.option_map (Aws.Json.lookup j "LastExecutionDate") DateTime.of_json
    ; output_source =
        Aws.Util.option_map (Aws.Json.lookup j "OutputSource") OutputSource.of_json
    }
end

module AssociationExecutionTargetsList = struct
  type t = AssociationExecutionTarget.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map AssociationExecutionTarget.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list AssociationExecutionTarget.to_query v
  let to_json v = `List (List.map AssociationExecutionTarget.to_json v)
  let of_json j = Aws.Json.to_list AssociationExecutionTarget.of_json j
end

module SessionFilterKey = struct
  type t =
    | InvokedAfter
    | InvokedBefore
    | Target
    | Owner
    | Status
    | SessionId

  let str_to_t =
    [ "SessionId", SessionId
    ; "Status", Status
    ; "Owner", Owner
    ; "Target", Target
    ; "InvokedBefore", InvokedBefore
    ; "InvokedAfter", InvokedAfter
    ]

  let t_to_str =
    [ SessionId, "SessionId"
    ; Status, "Status"
    ; Owner, "Owner"
    ; Target, "Target"
    ; InvokedBefore, "InvokedBefore"
    ; InvokedAfter, "InvokedAfter"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module SessionFilter = struct
  type t =
    { key : SessionFilterKey.t
    ; value : String.t
    }

  let make ~key ~value () = { key; value }

  let parse xml =
    Some
      { key =
          Aws.Xml.required
            "key"
            (Aws.Util.option_bind (Aws.Xml.member "key" xml) SessionFilterKey.parse)
      ; value =
          Aws.Xml.required
            "value"
            (Aws.Util.option_bind (Aws.Xml.member "value" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("value", String.to_query v.value))
         ; Some (Aws.Query.Pair ("key", SessionFilterKey.to_query v.key))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("value", String.to_json v.value)
         ; Some ("key", SessionFilterKey.to_json v.key)
         ])

  let of_json j =
    { key = SessionFilterKey.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "key"))
    ; value = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "value"))
    }
end

module SessionFilterList = struct
  type t = SessionFilter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map SessionFilter.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list SessionFilter.to_query v
  let to_json v = `List (List.map SessionFilter.to_json v)
  let of_json j = Aws.Json.to_list SessionFilter.of_json j
end

module UpdateDocumentRequest = struct
  type t =
    { content : String.t
    ; attachments : AttachmentsSourceList.t
    ; name : String.t
    ; version_name : String.t option
    ; document_version : String.t option
    ; document_format : DocumentFormat.t option
    ; target_type : String.t option
    }

  let make
      ~content
      ?(attachments = [])
      ~name
      ?version_name
      ?document_version
      ?document_format
      ?target_type
      () =
    { content
    ; attachments
    ; name
    ; version_name
    ; document_version
    ; document_format
    ; target_type
    }

  let parse xml =
    Some
      { content =
          Aws.Xml.required
            "Content"
            (Aws.Util.option_bind (Aws.Xml.member "Content" xml) String.parse)
      ; attachments =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Attachments" xml)
               AttachmentsSourceList.parse)
      ; name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      ; version_name =
          Aws.Util.option_bind (Aws.Xml.member "VersionName" xml) String.parse
      ; document_version =
          Aws.Util.option_bind (Aws.Xml.member "DocumentVersion" xml) String.parse
      ; document_format =
          Aws.Util.option_bind (Aws.Xml.member "DocumentFormat" xml) DocumentFormat.parse
      ; target_type = Aws.Util.option_bind (Aws.Xml.member "TargetType" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.target_type (fun f ->
               Aws.Query.Pair ("TargetType", String.to_query f))
         ; Aws.Util.option_map v.document_format (fun f ->
               Aws.Query.Pair ("DocumentFormat", DocumentFormat.to_query f))
         ; Aws.Util.option_map v.document_version (fun f ->
               Aws.Query.Pair ("DocumentVersion", String.to_query f))
         ; Aws.Util.option_map v.version_name (fun f ->
               Aws.Query.Pair ("VersionName", String.to_query f))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ; Some
             (Aws.Query.Pair
                ("Attachments.member", AttachmentsSourceList.to_query v.attachments))
         ; Some (Aws.Query.Pair ("Content", String.to_query v.content))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.target_type (fun f -> "TargetType", String.to_json f)
         ; Aws.Util.option_map v.document_format (fun f ->
               "DocumentFormat", DocumentFormat.to_json f)
         ; Aws.Util.option_map v.document_version (fun f ->
               "DocumentVersion", String.to_json f)
         ; Aws.Util.option_map v.version_name (fun f -> "VersionName", String.to_json f)
         ; Some ("Name", String.to_json v.name)
         ; Some ("Attachments", AttachmentsSourceList.to_json v.attachments)
         ; Some ("Content", String.to_json v.content)
         ])

  let of_json j =
    { content = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Content"))
    ; attachments =
        AttachmentsSourceList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Attachments"))
    ; name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; version_name = Aws.Util.option_map (Aws.Json.lookup j "VersionName") String.of_json
    ; document_version =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentVersion") String.of_json
    ; document_format =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentFormat") DocumentFormat.of_json
    ; target_type = Aws.Util.option_map (Aws.Json.lookup j "TargetType") String.of_json
    }
end

module AutomationExecutionFilterValueList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module ComplianceExecutionSummary = struct
  type t =
    { execution_time : DateTime.t
    ; execution_id : String.t option
    ; execution_type : String.t option
    }

  let make ~execution_time ?execution_id ?execution_type () =
    { execution_time; execution_id; execution_type }

  let parse xml =
    Some
      { execution_time =
          Aws.Xml.required
            "ExecutionTime"
            (Aws.Util.option_bind (Aws.Xml.member "ExecutionTime" xml) DateTime.parse)
      ; execution_id =
          Aws.Util.option_bind (Aws.Xml.member "ExecutionId" xml) String.parse
      ; execution_type =
          Aws.Util.option_bind (Aws.Xml.member "ExecutionType" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.execution_type (fun f ->
               Aws.Query.Pair ("ExecutionType", String.to_query f))
         ; Aws.Util.option_map v.execution_id (fun f ->
               Aws.Query.Pair ("ExecutionId", String.to_query f))
         ; Some (Aws.Query.Pair ("ExecutionTime", DateTime.to_query v.execution_time))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.execution_type (fun f ->
               "ExecutionType", String.to_json f)
         ; Aws.Util.option_map v.execution_id (fun f -> "ExecutionId", String.to_json f)
         ; Some ("ExecutionTime", DateTime.to_json v.execution_time)
         ])

  let of_json j =
    { execution_time =
        DateTime.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ExecutionTime"))
    ; execution_id = Aws.Util.option_map (Aws.Json.lookup j "ExecutionId") String.of_json
    ; execution_type =
        Aws.Util.option_map (Aws.Json.lookup j "ExecutionType") String.of_json
    }
end

module PatchOperationType = struct
  type t =
    | Scan
    | Install

  let str_to_t = [ "Install", Install; "Scan", Scan ]
  let t_to_str = [ Install, "Install"; Scan, "Scan" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module InstancePatchState = struct
  type t =
    { instance_id : String.t
    ; patch_group : String.t
    ; baseline_id : String.t
    ; snapshot_id : String.t option
    ; install_override_list : String.t option
    ; owner_information : String.t option
    ; installed_count : Integer.t option
    ; installed_other_count : Integer.t option
    ; installed_pending_reboot_count : Integer.t option
    ; installed_rejected_count : Integer.t option
    ; missing_count : Integer.t option
    ; failed_count : Integer.t option
    ; unreported_not_applicable_count : Integer.t option
    ; not_applicable_count : Integer.t option
    ; operation_start_time : DateTime.t
    ; operation_end_time : DateTime.t
    ; operation : PatchOperationType.t
    ; last_no_reboot_install_operation_time : DateTime.t option
    ; reboot_option : RebootOption.t option
    }

  let make
      ~instance_id
      ~patch_group
      ~baseline_id
      ?snapshot_id
      ?install_override_list
      ?owner_information
      ?installed_count
      ?installed_other_count
      ?installed_pending_reboot_count
      ?installed_rejected_count
      ?missing_count
      ?failed_count
      ?unreported_not_applicable_count
      ?not_applicable_count
      ~operation_start_time
      ~operation_end_time
      ~operation
      ?last_no_reboot_install_operation_time
      ?reboot_option
      () =
    { instance_id
    ; patch_group
    ; baseline_id
    ; snapshot_id
    ; install_override_list
    ; owner_information
    ; installed_count
    ; installed_other_count
    ; installed_pending_reboot_count
    ; installed_rejected_count
    ; missing_count
    ; failed_count
    ; unreported_not_applicable_count
    ; not_applicable_count
    ; operation_start_time
    ; operation_end_time
    ; operation
    ; last_no_reboot_install_operation_time
    ; reboot_option
    }

  let parse xml =
    Some
      { instance_id =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse)
      ; patch_group =
          Aws.Xml.required
            "PatchGroup"
            (Aws.Util.option_bind (Aws.Xml.member "PatchGroup" xml) String.parse)
      ; baseline_id =
          Aws.Xml.required
            "BaselineId"
            (Aws.Util.option_bind (Aws.Xml.member "BaselineId" xml) String.parse)
      ; snapshot_id = Aws.Util.option_bind (Aws.Xml.member "SnapshotId" xml) String.parse
      ; install_override_list =
          Aws.Util.option_bind (Aws.Xml.member "InstallOverrideList" xml) String.parse
      ; owner_information =
          Aws.Util.option_bind (Aws.Xml.member "OwnerInformation" xml) String.parse
      ; installed_count =
          Aws.Util.option_bind (Aws.Xml.member "InstalledCount" xml) Integer.parse
      ; installed_other_count =
          Aws.Util.option_bind (Aws.Xml.member "InstalledOtherCount" xml) Integer.parse
      ; installed_pending_reboot_count =
          Aws.Util.option_bind
            (Aws.Xml.member "InstalledPendingRebootCount" xml)
            Integer.parse
      ; installed_rejected_count =
          Aws.Util.option_bind (Aws.Xml.member "InstalledRejectedCount" xml) Integer.parse
      ; missing_count =
          Aws.Util.option_bind (Aws.Xml.member "MissingCount" xml) Integer.parse
      ; failed_count =
          Aws.Util.option_bind (Aws.Xml.member "FailedCount" xml) Integer.parse
      ; unreported_not_applicable_count =
          Aws.Util.option_bind
            (Aws.Xml.member "UnreportedNotApplicableCount" xml)
            Integer.parse
      ; not_applicable_count =
          Aws.Util.option_bind (Aws.Xml.member "NotApplicableCount" xml) Integer.parse
      ; operation_start_time =
          Aws.Xml.required
            "OperationStartTime"
            (Aws.Util.option_bind
               (Aws.Xml.member "OperationStartTime" xml)
               DateTime.parse)
      ; operation_end_time =
          Aws.Xml.required
            "OperationEndTime"
            (Aws.Util.option_bind (Aws.Xml.member "OperationEndTime" xml) DateTime.parse)
      ; operation =
          Aws.Xml.required
            "Operation"
            (Aws.Util.option_bind
               (Aws.Xml.member "Operation" xml)
               PatchOperationType.parse)
      ; last_no_reboot_install_operation_time =
          Aws.Util.option_bind
            (Aws.Xml.member "LastNoRebootInstallOperationTime" xml)
            DateTime.parse
      ; reboot_option =
          Aws.Util.option_bind (Aws.Xml.member "RebootOption" xml) RebootOption.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.reboot_option (fun f ->
               Aws.Query.Pair ("RebootOption", RebootOption.to_query f))
         ; Aws.Util.option_map v.last_no_reboot_install_operation_time (fun f ->
               Aws.Query.Pair ("LastNoRebootInstallOperationTime", DateTime.to_query f))
         ; Some (Aws.Query.Pair ("Operation", PatchOperationType.to_query v.operation))
         ; Some
             (Aws.Query.Pair ("OperationEndTime", DateTime.to_query v.operation_end_time))
         ; Some
             (Aws.Query.Pair
                ("OperationStartTime", DateTime.to_query v.operation_start_time))
         ; Aws.Util.option_map v.not_applicable_count (fun f ->
               Aws.Query.Pair ("NotApplicableCount", Integer.to_query f))
         ; Aws.Util.option_map v.unreported_not_applicable_count (fun f ->
               Aws.Query.Pair ("UnreportedNotApplicableCount", Integer.to_query f))
         ; Aws.Util.option_map v.failed_count (fun f ->
               Aws.Query.Pair ("FailedCount", Integer.to_query f))
         ; Aws.Util.option_map v.missing_count (fun f ->
               Aws.Query.Pair ("MissingCount", Integer.to_query f))
         ; Aws.Util.option_map v.installed_rejected_count (fun f ->
               Aws.Query.Pair ("InstalledRejectedCount", Integer.to_query f))
         ; Aws.Util.option_map v.installed_pending_reboot_count (fun f ->
               Aws.Query.Pair ("InstalledPendingRebootCount", Integer.to_query f))
         ; Aws.Util.option_map v.installed_other_count (fun f ->
               Aws.Query.Pair ("InstalledOtherCount", Integer.to_query f))
         ; Aws.Util.option_map v.installed_count (fun f ->
               Aws.Query.Pair ("InstalledCount", Integer.to_query f))
         ; Aws.Util.option_map v.owner_information (fun f ->
               Aws.Query.Pair ("OwnerInformation", String.to_query f))
         ; Aws.Util.option_map v.install_override_list (fun f ->
               Aws.Query.Pair ("InstallOverrideList", String.to_query f))
         ; Aws.Util.option_map v.snapshot_id (fun f ->
               Aws.Query.Pair ("SnapshotId", String.to_query f))
         ; Some (Aws.Query.Pair ("BaselineId", String.to_query v.baseline_id))
         ; Some (Aws.Query.Pair ("PatchGroup", String.to_query v.patch_group))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.reboot_option (fun f ->
               "RebootOption", RebootOption.to_json f)
         ; Aws.Util.option_map v.last_no_reboot_install_operation_time (fun f ->
               "LastNoRebootInstallOperationTime", DateTime.to_json f)
         ; Some ("Operation", PatchOperationType.to_json v.operation)
         ; Some ("OperationEndTime", DateTime.to_json v.operation_end_time)
         ; Some ("OperationStartTime", DateTime.to_json v.operation_start_time)
         ; Aws.Util.option_map v.not_applicable_count (fun f ->
               "NotApplicableCount", Integer.to_json f)
         ; Aws.Util.option_map v.unreported_not_applicable_count (fun f ->
               "UnreportedNotApplicableCount", Integer.to_json f)
         ; Aws.Util.option_map v.failed_count (fun f -> "FailedCount", Integer.to_json f)
         ; Aws.Util.option_map v.missing_count (fun f ->
               "MissingCount", Integer.to_json f)
         ; Aws.Util.option_map v.installed_rejected_count (fun f ->
               "InstalledRejectedCount", Integer.to_json f)
         ; Aws.Util.option_map v.installed_pending_reboot_count (fun f ->
               "InstalledPendingRebootCount", Integer.to_json f)
         ; Aws.Util.option_map v.installed_other_count (fun f ->
               "InstalledOtherCount", Integer.to_json f)
         ; Aws.Util.option_map v.installed_count (fun f ->
               "InstalledCount", Integer.to_json f)
         ; Aws.Util.option_map v.owner_information (fun f ->
               "OwnerInformation", String.to_json f)
         ; Aws.Util.option_map v.install_override_list (fun f ->
               "InstallOverrideList", String.to_json f)
         ; Aws.Util.option_map v.snapshot_id (fun f -> "SnapshotId", String.to_json f)
         ; Some ("BaselineId", String.to_json v.baseline_id)
         ; Some ("PatchGroup", String.to_json v.patch_group)
         ; Some ("InstanceId", String.to_json v.instance_id)
         ])

  let of_json j =
    { instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; patch_group =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PatchGroup"))
    ; baseline_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "BaselineId"))
    ; snapshot_id = Aws.Util.option_map (Aws.Json.lookup j "SnapshotId") String.of_json
    ; install_override_list =
        Aws.Util.option_map (Aws.Json.lookup j "InstallOverrideList") String.of_json
    ; owner_information =
        Aws.Util.option_map (Aws.Json.lookup j "OwnerInformation") String.of_json
    ; installed_count =
        Aws.Util.option_map (Aws.Json.lookup j "InstalledCount") Integer.of_json
    ; installed_other_count =
        Aws.Util.option_map (Aws.Json.lookup j "InstalledOtherCount") Integer.of_json
    ; installed_pending_reboot_count =
        Aws.Util.option_map
          (Aws.Json.lookup j "InstalledPendingRebootCount")
          Integer.of_json
    ; installed_rejected_count =
        Aws.Util.option_map (Aws.Json.lookup j "InstalledRejectedCount") Integer.of_json
    ; missing_count =
        Aws.Util.option_map (Aws.Json.lookup j "MissingCount") Integer.of_json
    ; failed_count = Aws.Util.option_map (Aws.Json.lookup j "FailedCount") Integer.of_json
    ; unreported_not_applicable_count =
        Aws.Util.option_map
          (Aws.Json.lookup j "UnreportedNotApplicableCount")
          Integer.of_json
    ; not_applicable_count =
        Aws.Util.option_map (Aws.Json.lookup j "NotApplicableCount") Integer.of_json
    ; operation_start_time =
        DateTime.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "OperationStartTime"))
    ; operation_end_time =
        DateTime.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "OperationEndTime"))
    ; operation =
        PatchOperationType.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Operation"))
    ; last_no_reboot_install_operation_time =
        Aws.Util.option_map
          (Aws.Json.lookup j "LastNoRebootInstallOperationTime")
          DateTime.of_json
    ; reboot_option =
        Aws.Util.option_map (Aws.Json.lookup j "RebootOption") RebootOption.of_json
    }
end

module InstancePatchStateList = struct
  type t = InstancePatchState.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map InstancePatchState.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list InstancePatchState.to_query v
  let to_json v = `List (List.map InstancePatchState.to_json v)
  let of_json j = Aws.Json.to_list InstancePatchState.of_json j
end

module DescribeInstancePatchStatesResult = struct
  type t =
    { instance_patch_states : InstancePatchStateList.t
    ; next_token : String.t option
    }

  let make ?(instance_patch_states = []) ?next_token () =
    { instance_patch_states; next_token }

  let parse xml =
    Some
      { instance_patch_states =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "InstancePatchStates" xml)
               InstancePatchStateList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "InstancePatchStates.member"
                , InstancePatchStateList.to_query v.instance_patch_states ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some
             ( "InstancePatchStates"
             , InstancePatchStateList.to_json v.instance_patch_states )
         ])

  let of_json j =
    { instance_patch_states =
        InstancePatchStateList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InstancePatchStates"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module ResetServiceSettingRequest = struct
  type t = { setting_id : String.t }

  let make ~setting_id () = { setting_id }

  let parse xml =
    Some
      { setting_id =
          Aws.Xml.required
            "SettingId"
            (Aws.Util.option_bind (Aws.Xml.member "SettingId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("SettingId", String.to_query v.setting_id)) ])

  let to_json v =
    `Assoc (Aws.Util.list_filter_opt [ Some ("SettingId", String.to_json v.setting_id) ])

  let of_json j =
    { setting_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SettingId"))
    }
end

module StopAutomationExecutionResult = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module DuplicateDocumentContent = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module OpsItemSummary = struct
  type t =
    { created_by : String.t option
    ; created_time : DateTime.t option
    ; last_modified_by : String.t option
    ; last_modified_time : DateTime.t option
    ; priority : Integer.t option
    ; source : String.t option
    ; status : OpsItemStatus.t option
    ; ops_item_id : String.t option
    ; title : String.t option
    ; operational_data : OpsItemOperationalData.t option
    ; category : String.t option
    ; severity : String.t option
    }

  let make
      ?created_by
      ?created_time
      ?last_modified_by
      ?last_modified_time
      ?priority
      ?source
      ?status
      ?ops_item_id
      ?title
      ?operational_data
      ?category
      ?severity
      () =
    { created_by
    ; created_time
    ; last_modified_by
    ; last_modified_time
    ; priority
    ; source
    ; status
    ; ops_item_id
    ; title
    ; operational_data
    ; category
    ; severity
    }

  let parse xml =
    Some
      { created_by = Aws.Util.option_bind (Aws.Xml.member "CreatedBy" xml) String.parse
      ; created_time =
          Aws.Util.option_bind (Aws.Xml.member "CreatedTime" xml) DateTime.parse
      ; last_modified_by =
          Aws.Util.option_bind (Aws.Xml.member "LastModifiedBy" xml) String.parse
      ; last_modified_time =
          Aws.Util.option_bind (Aws.Xml.member "LastModifiedTime" xml) DateTime.parse
      ; priority = Aws.Util.option_bind (Aws.Xml.member "Priority" xml) Integer.parse
      ; source = Aws.Util.option_bind (Aws.Xml.member "Source" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) OpsItemStatus.parse
      ; ops_item_id = Aws.Util.option_bind (Aws.Xml.member "OpsItemId" xml) String.parse
      ; title = Aws.Util.option_bind (Aws.Xml.member "Title" xml) String.parse
      ; operational_data =
          Aws.Util.option_bind
            (Aws.Xml.member "OperationalData" xml)
            OpsItemOperationalData.parse
      ; category = Aws.Util.option_bind (Aws.Xml.member "Category" xml) String.parse
      ; severity = Aws.Util.option_bind (Aws.Xml.member "Severity" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.severity (fun f ->
               Aws.Query.Pair ("Severity", String.to_query f))
         ; Aws.Util.option_map v.category (fun f ->
               Aws.Query.Pair ("Category", String.to_query f))
         ; Aws.Util.option_map v.operational_data (fun f ->
               Aws.Query.Pair ("OperationalData", OpsItemOperationalData.to_query f))
         ; Aws.Util.option_map v.title (fun f ->
               Aws.Query.Pair ("Title", String.to_query f))
         ; Aws.Util.option_map v.ops_item_id (fun f ->
               Aws.Query.Pair ("OpsItemId", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", OpsItemStatus.to_query f))
         ; Aws.Util.option_map v.source (fun f ->
               Aws.Query.Pair ("Source", String.to_query f))
         ; Aws.Util.option_map v.priority (fun f ->
               Aws.Query.Pair ("Priority", Integer.to_query f))
         ; Aws.Util.option_map v.last_modified_time (fun f ->
               Aws.Query.Pair ("LastModifiedTime", DateTime.to_query f))
         ; Aws.Util.option_map v.last_modified_by (fun f ->
               Aws.Query.Pair ("LastModifiedBy", String.to_query f))
         ; Aws.Util.option_map v.created_time (fun f ->
               Aws.Query.Pair ("CreatedTime", DateTime.to_query f))
         ; Aws.Util.option_map v.created_by (fun f ->
               Aws.Query.Pair ("CreatedBy", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.severity (fun f -> "Severity", String.to_json f)
         ; Aws.Util.option_map v.category (fun f -> "Category", String.to_json f)
         ; Aws.Util.option_map v.operational_data (fun f ->
               "OperationalData", OpsItemOperationalData.to_json f)
         ; Aws.Util.option_map v.title (fun f -> "Title", String.to_json f)
         ; Aws.Util.option_map v.ops_item_id (fun f -> "OpsItemId", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", OpsItemStatus.to_json f)
         ; Aws.Util.option_map v.source (fun f -> "Source", String.to_json f)
         ; Aws.Util.option_map v.priority (fun f -> "Priority", Integer.to_json f)
         ; Aws.Util.option_map v.last_modified_time (fun f ->
               "LastModifiedTime", DateTime.to_json f)
         ; Aws.Util.option_map v.last_modified_by (fun f ->
               "LastModifiedBy", String.to_json f)
         ; Aws.Util.option_map v.created_time (fun f -> "CreatedTime", DateTime.to_json f)
         ; Aws.Util.option_map v.created_by (fun f -> "CreatedBy", String.to_json f)
         ])

  let of_json j =
    { created_by = Aws.Util.option_map (Aws.Json.lookup j "CreatedBy") String.of_json
    ; created_time =
        Aws.Util.option_map (Aws.Json.lookup j "CreatedTime") DateTime.of_json
    ; last_modified_by =
        Aws.Util.option_map (Aws.Json.lookup j "LastModifiedBy") String.of_json
    ; last_modified_time =
        Aws.Util.option_map (Aws.Json.lookup j "LastModifiedTime") DateTime.of_json
    ; priority = Aws.Util.option_map (Aws.Json.lookup j "Priority") Integer.of_json
    ; source = Aws.Util.option_map (Aws.Json.lookup j "Source") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") OpsItemStatus.of_json
    ; ops_item_id = Aws.Util.option_map (Aws.Json.lookup j "OpsItemId") String.of_json
    ; title = Aws.Util.option_map (Aws.Json.lookup j "Title") String.of_json
    ; operational_data =
        Aws.Util.option_map
          (Aws.Json.lookup j "OperationalData")
          OpsItemOperationalData.of_json
    ; category = Aws.Util.option_map (Aws.Json.lookup j "Category") String.of_json
    ; severity = Aws.Util.option_map (Aws.Json.lookup j "Severity") String.of_json
    }
end

module InvalidFilterOption = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json }
end

module AssociationComplianceSeverity = struct
  type t =
    | CRITICAL
    | HIGH
    | MEDIUM
    | LOW
    | UNSPECIFIED

  let str_to_t =
    [ "UNSPECIFIED", UNSPECIFIED
    ; "LOW", LOW
    ; "MEDIUM", MEDIUM
    ; "HIGH", HIGH
    ; "CRITICAL", CRITICAL
    ]

  let t_to_str =
    [ UNSPECIFIED, "UNSPECIFIED"
    ; LOW, "LOW"
    ; MEDIUM, "MEDIUM"
    ; HIGH, "HIGH"
    ; CRITICAL, "CRITICAL"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module CommandFilterKey = struct
  type t =
    | InvokedAfter
    | InvokedBefore
    | Status
    | ExecutionStage
    | DocumentName

  let str_to_t =
    [ "DocumentName", DocumentName
    ; "ExecutionStage", ExecutionStage
    ; "Status", Status
    ; "InvokedBefore", InvokedBefore
    ; "InvokedAfter", InvokedAfter
    ]

  let t_to_str =
    [ DocumentName, "DocumentName"
    ; ExecutionStage, "ExecutionStage"
    ; Status, "Status"
    ; InvokedBefore, "InvokedBefore"
    ; InvokedAfter, "InvokedAfter"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module CommandFilter = struct
  type t =
    { key : CommandFilterKey.t
    ; value : String.t
    }

  let make ~key ~value () = { key; value }

  let parse xml =
    Some
      { key =
          Aws.Xml.required
            "key"
            (Aws.Util.option_bind (Aws.Xml.member "key" xml) CommandFilterKey.parse)
      ; value =
          Aws.Xml.required
            "value"
            (Aws.Util.option_bind (Aws.Xml.member "value" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("value", String.to_query v.value))
         ; Some (Aws.Query.Pair ("key", CommandFilterKey.to_query v.key))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("value", String.to_json v.value)
         ; Some ("key", CommandFilterKey.to_json v.key)
         ])

  let of_json j =
    { key = CommandFilterKey.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "key"))
    ; value = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "value"))
    }
end

module CommandFilterList = struct
  type t = CommandFilter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map CommandFilter.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list CommandFilter.to_query v
  let to_json v = `List (List.map CommandFilter.to_json v)
  let of_json j = Aws.Json.to_list CommandFilter.of_json j
end

module ListCommandInvocationsRequest = struct
  type t =
    { command_id : String.t option
    ; instance_id : String.t option
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; filters : CommandFilterList.t
    ; details : Boolean.t option
    }

  let make ?command_id ?instance_id ?max_results ?next_token ?(filters = []) ?details () =
    { command_id; instance_id; max_results; next_token; filters; details }

  let parse xml =
    Some
      { command_id = Aws.Util.option_bind (Aws.Xml.member "CommandId" xml) String.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) CommandFilterList.parse)
      ; details = Aws.Util.option_bind (Aws.Xml.member "Details" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.details (fun f ->
               Aws.Query.Pair ("Details", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", CommandFilterList.to_query v.filters))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.command_id (fun f ->
               Aws.Query.Pair ("CommandId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.details (fun f -> "Details", Boolean.to_json f)
         ; Some ("Filters", CommandFilterList.to_json v.filters)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "InstanceId", String.to_json f)
         ; Aws.Util.option_map v.command_id (fun f -> "CommandId", String.to_json f)
         ])

  let of_json j =
    { command_id = Aws.Util.option_map (Aws.Json.lookup j "CommandId") String.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "InstanceId") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; filters =
        CommandFilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; details = Aws.Util.option_map (Aws.Json.lookup j "Details") Boolean.of_json
    }
end

module GetParametersRequest = struct
  type t =
    { names : ParameterNameList.t
    ; with_decryption : Boolean.t option
    }

  let make ~names ?with_decryption () = { names; with_decryption }

  let parse xml =
    Some
      { names =
          Aws.Xml.required
            "Names"
            (Aws.Util.option_bind (Aws.Xml.member "Names" xml) ParameterNameList.parse)
      ; with_decryption =
          Aws.Util.option_bind (Aws.Xml.member "WithDecryption" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.with_decryption (fun f ->
               Aws.Query.Pair ("WithDecryption", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Names.member", ParameterNameList.to_query v.names))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.with_decryption (fun f ->
               "WithDecryption", Boolean.to_json f)
         ; Some ("Names", ParameterNameList.to_json v.names)
         ])

  let of_json j =
    { names =
        ParameterNameList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Names"))
    ; with_decryption =
        Aws.Util.option_map (Aws.Json.lookup j "WithDecryption") Boolean.of_json
    }
end

module DeregisterPatchBaselineForPatchGroupResult = struct
  type t =
    { baseline_id : String.t option
    ; patch_group : String.t option
    }

  let make ?baseline_id ?patch_group () = { baseline_id; patch_group }

  let parse xml =
    Some
      { baseline_id = Aws.Util.option_bind (Aws.Xml.member "BaselineId" xml) String.parse
      ; patch_group = Aws.Util.option_bind (Aws.Xml.member "PatchGroup" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.patch_group (fun f ->
               Aws.Query.Pair ("PatchGroup", String.to_query f))
         ; Aws.Util.option_map v.baseline_id (fun f ->
               Aws.Query.Pair ("BaselineId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.patch_group (fun f -> "PatchGroup", String.to_json f)
         ; Aws.Util.option_map v.baseline_id (fun f -> "BaselineId", String.to_json f)
         ])

  let of_json j =
    { baseline_id = Aws.Util.option_map (Aws.Json.lookup j "BaselineId") String.of_json
    ; patch_group = Aws.Util.option_map (Aws.Json.lookup j "PatchGroup") String.of_json
    }
end

module OpsEntityItem = struct
  type t =
    { capture_time : String.t option
    ; content : OpsEntityItemEntryList.t
    }

  let make ?capture_time ?(content = []) () = { capture_time; content }

  let parse xml =
    Some
      { capture_time =
          Aws.Util.option_bind (Aws.Xml.member "CaptureTime" xml) String.parse
      ; content =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Content" xml)
               OpsEntityItemEntryList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("Content.member", OpsEntityItemEntryList.to_query v.content))
         ; Aws.Util.option_map v.capture_time (fun f ->
               Aws.Query.Pair ("CaptureTime", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Content", OpsEntityItemEntryList.to_json v.content)
         ; Aws.Util.option_map v.capture_time (fun f -> "CaptureTime", String.to_json f)
         ])

  let of_json j =
    { capture_time = Aws.Util.option_map (Aws.Json.lookup j "CaptureTime") String.of_json
    ; content =
        OpsEntityItemEntryList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Content"))
    }
end

module ComplianceSeverity = struct
  type t =
    | CRITICAL
    | HIGH
    | MEDIUM
    | LOW
    | INFORMATIONAL
    | UNSPECIFIED

  let str_to_t =
    [ "UNSPECIFIED", UNSPECIFIED
    ; "INFORMATIONAL", INFORMATIONAL
    ; "LOW", LOW
    ; "MEDIUM", MEDIUM
    ; "HIGH", HIGH
    ; "CRITICAL", CRITICAL
    ]

  let t_to_str =
    [ UNSPECIFIED, "UNSPECIFIED"
    ; INFORMATIONAL, "INFORMATIONAL"
    ; LOW, "LOW"
    ; MEDIUM, "MEDIUM"
    ; HIGH, "HIGH"
    ; CRITICAL, "CRITICAL"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ComplianceItemDetails = struct
  type t = (String.t, String.t) Hashtbl.t

  let make elems () = elems
  let parse xml = None
  let to_query v = Aws.Query.to_query_hashtbl String.to_string String.to_query v

  let to_json v =
    `Assoc
      (Hashtbl.fold (fun k v acc -> (String.to_string k, String.to_json v) :: acc) v [])

  let of_json j = Aws.Json.to_hashtbl String.of_string String.of_json j
end

module ComplianceItem = struct
  type t =
    { compliance_type : String.t option
    ; resource_type : String.t option
    ; resource_id : String.t option
    ; id : String.t option
    ; title : String.t option
    ; status : ComplianceStatus.t option
    ; severity : ComplianceSeverity.t option
    ; execution_summary : ComplianceExecutionSummary.t option
    ; details : ComplianceItemDetails.t option
    }

  let make
      ?compliance_type
      ?resource_type
      ?resource_id
      ?id
      ?title
      ?status
      ?severity
      ?execution_summary
      ?details
      () =
    { compliance_type
    ; resource_type
    ; resource_id
    ; id
    ; title
    ; status
    ; severity
    ; execution_summary
    ; details
    }

  let parse xml =
    Some
      { compliance_type =
          Aws.Util.option_bind (Aws.Xml.member "ComplianceType" xml) String.parse
      ; resource_type =
          Aws.Util.option_bind (Aws.Xml.member "ResourceType" xml) String.parse
      ; resource_id = Aws.Util.option_bind (Aws.Xml.member "ResourceId" xml) String.parse
      ; id = Aws.Util.option_bind (Aws.Xml.member "Id" xml) String.parse
      ; title = Aws.Util.option_bind (Aws.Xml.member "Title" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) ComplianceStatus.parse
      ; severity =
          Aws.Util.option_bind (Aws.Xml.member "Severity" xml) ComplianceSeverity.parse
      ; execution_summary =
          Aws.Util.option_bind
            (Aws.Xml.member "ExecutionSummary" xml)
            ComplianceExecutionSummary.parse
      ; details =
          Aws.Util.option_bind (Aws.Xml.member "Details" xml) ComplianceItemDetails.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.details (fun f ->
               Aws.Query.Pair ("Details", ComplianceItemDetails.to_query f))
         ; Aws.Util.option_map v.execution_summary (fun f ->
               Aws.Query.Pair ("ExecutionSummary", ComplianceExecutionSummary.to_query f))
         ; Aws.Util.option_map v.severity (fun f ->
               Aws.Query.Pair ("Severity", ComplianceSeverity.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", ComplianceStatus.to_query f))
         ; Aws.Util.option_map v.title (fun f ->
               Aws.Query.Pair ("Title", String.to_query f))
         ; Aws.Util.option_map v.id (fun f -> Aws.Query.Pair ("Id", String.to_query f))
         ; Aws.Util.option_map v.resource_id (fun f ->
               Aws.Query.Pair ("ResourceId", String.to_query f))
         ; Aws.Util.option_map v.resource_type (fun f ->
               Aws.Query.Pair ("ResourceType", String.to_query f))
         ; Aws.Util.option_map v.compliance_type (fun f ->
               Aws.Query.Pair ("ComplianceType", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.details (fun f ->
               "Details", ComplianceItemDetails.to_json f)
         ; Aws.Util.option_map v.execution_summary (fun f ->
               "ExecutionSummary", ComplianceExecutionSummary.to_json f)
         ; Aws.Util.option_map v.severity (fun f ->
               "Severity", ComplianceSeverity.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", ComplianceStatus.to_json f)
         ; Aws.Util.option_map v.title (fun f -> "Title", String.to_json f)
         ; Aws.Util.option_map v.id (fun f -> "Id", String.to_json f)
         ; Aws.Util.option_map v.resource_id (fun f -> "ResourceId", String.to_json f)
         ; Aws.Util.option_map v.resource_type (fun f -> "ResourceType", String.to_json f)
         ; Aws.Util.option_map v.compliance_type (fun f ->
               "ComplianceType", String.to_json f)
         ])

  let of_json j =
    { compliance_type =
        Aws.Util.option_map (Aws.Json.lookup j "ComplianceType") String.of_json
    ; resource_type =
        Aws.Util.option_map (Aws.Json.lookup j "ResourceType") String.of_json
    ; resource_id = Aws.Util.option_map (Aws.Json.lookup j "ResourceId") String.of_json
    ; id = Aws.Util.option_map (Aws.Json.lookup j "Id") String.of_json
    ; title = Aws.Util.option_map (Aws.Json.lookup j "Title") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") ComplianceStatus.of_json
    ; severity =
        Aws.Util.option_map (Aws.Json.lookup j "Severity") ComplianceSeverity.of_json
    ; execution_summary =
        Aws.Util.option_map
          (Aws.Json.lookup j "ExecutionSummary")
          ComplianceExecutionSummary.of_json
    ; details =
        Aws.Util.option_map (Aws.Json.lookup j "Details") ComplianceItemDetails.of_json
    }
end

module ComplianceItemList = struct
  type t = ComplianceItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ComplianceItem.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list ComplianceItem.to_query v
  let to_json v = `List (List.map ComplianceItem.to_json v)
  let of_json j = Aws.Json.to_list ComplianceItem.of_json j
end

module InstanceInformationFilterKey = struct
  type t =
    | InstanceIds
    | AgentVersion
    | PingStatus
    | PlatformTypes
    | ActivationIds
    | IamRole
    | ResourceType
    | AssociationStatus

  let str_to_t =
    [ "AssociationStatus", AssociationStatus
    ; "ResourceType", ResourceType
    ; "IamRole", IamRole
    ; "ActivationIds", ActivationIds
    ; "PlatformTypes", PlatformTypes
    ; "PingStatus", PingStatus
    ; "AgentVersion", AgentVersion
    ; "InstanceIds", InstanceIds
    ]

  let t_to_str =
    [ AssociationStatus, "AssociationStatus"
    ; ResourceType, "ResourceType"
    ; IamRole, "IamRole"
    ; ActivationIds, "ActivationIds"
    ; PlatformTypes, "PlatformTypes"
    ; PingStatus, "PingStatus"
    ; AgentVersion, "AgentVersion"
    ; InstanceIds, "InstanceIds"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DescribeActivationsFilterKeys = struct
  type t =
    | ActivationIds
    | DefaultInstanceName
    | IamRole

  let str_to_t =
    [ "IamRole", IamRole
    ; "DefaultInstanceName", DefaultInstanceName
    ; "ActivationIds", ActivationIds
    ]

  let t_to_str =
    [ IamRole, "IamRole"
    ; DefaultInstanceName, "DefaultInstanceName"
    ; ActivationIds, "ActivationIds"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DescribeActivationsFilter = struct
  type t =
    { filter_key : DescribeActivationsFilterKeys.t option
    ; filter_values : StringList.t
    }

  let make ?filter_key ?(filter_values = []) () = { filter_key; filter_values }

  let parse xml =
    Some
      { filter_key =
          Aws.Util.option_bind
            (Aws.Xml.member "FilterKey" xml)
            DescribeActivationsFilterKeys.parse
      ; filter_values =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "FilterValues" xml) StringList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("FilterValues.member", StringList.to_query v.filter_values))
         ; Aws.Util.option_map v.filter_key (fun f ->
               Aws.Query.Pair ("FilterKey", DescribeActivationsFilterKeys.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("FilterValues", StringList.to_json v.filter_values)
         ; Aws.Util.option_map v.filter_key (fun f ->
               "FilterKey", DescribeActivationsFilterKeys.to_json f)
         ])

  let of_json j =
    { filter_key =
        Aws.Util.option_map
          (Aws.Json.lookup j "FilterKey")
          DescribeActivationsFilterKeys.of_json
    ; filter_values =
        StringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "FilterValues"))
    }
end

module DescribeActivationsFilterList = struct
  type t = DescribeActivationsFilter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map DescribeActivationsFilter.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list DescribeActivationsFilter.to_query v
  let to_json v = `List (List.map DescribeActivationsFilter.to_json v)
  let of_json j = Aws.Json.to_list DescribeActivationsFilter.of_json j
end

module DescribeActivationsRequest = struct
  type t =
    { filters : DescribeActivationsFilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?(filters = []) ?max_results ?next_token () =
    { filters; max_results; next_token }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               DescribeActivationsFilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Filters.member", DescribeActivationsFilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filters", DescribeActivationsFilterList.to_json v.filters)
         ])

  let of_json j =
    { filters =
        DescribeActivationsFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module MaintenanceWindowIdentityForTarget = struct
  type t =
    { window_id : String.t option
    ; name : String.t option
    }

  let make ?window_id ?name () = { window_id; name }

  let parse xml =
    Some
      { window_id = Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.window_id (fun f ->
               Aws.Query.Pair ("WindowId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.window_id (fun f -> "WindowId", String.to_json f)
         ])

  let of_json j =
    { window_id = Aws.Util.option_map (Aws.Json.lookup j "WindowId") String.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    }
end

module MaintenanceWindowsForTargetList = struct
  type t = MaintenanceWindowIdentityForTarget.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map MaintenanceWindowIdentityForTarget.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list MaintenanceWindowIdentityForTarget.to_query v
  let to_json v = `List (List.map MaintenanceWindowIdentityForTarget.to_json v)
  let of_json j = Aws.Json.to_list MaintenanceWindowIdentityForTarget.of_json j
end

module DescribeMaintenanceWindowsForTargetResult = struct
  type t =
    { window_identities : MaintenanceWindowsForTargetList.t
    ; next_token : String.t option
    }

  let make ?(window_identities = []) ?next_token () = { window_identities; next_token }

  let parse xml =
    Some
      { window_identities =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "WindowIdentities" xml)
               MaintenanceWindowsForTargetList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "WindowIdentities.member"
                , MaintenanceWindowsForTargetList.to_query v.window_identities ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some
             ( "WindowIdentities"
             , MaintenanceWindowsForTargetList.to_json v.window_identities )
         ])

  let of_json j =
    { window_identities =
        MaintenanceWindowsForTargetList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowIdentities"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module MaintenanceWindowTaskType = struct
  type t =
    | RUN_COMMAND
    | AUTOMATION
    | STEP_FUNCTIONS
    | LAMBDA

  let str_to_t =
    [ "LAMBDA", LAMBDA
    ; "STEP_FUNCTIONS", STEP_FUNCTIONS
    ; "AUTOMATION", AUTOMATION
    ; "RUN_COMMAND", RUN_COMMAND
    ]

  let t_to_str =
    [ LAMBDA, "LAMBDA"
    ; STEP_FUNCTIONS, "STEP_FUNCTIONS"
    ; AUTOMATION, "AUTOMATION"
    ; RUN_COMMAND, "RUN_COMMAND"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module MaintenanceWindowExecutionTaskInvocationIdentity = struct
  type t =
    { window_execution_id : String.t option
    ; task_execution_id : String.t option
    ; invocation_id : String.t option
    ; execution_id : String.t option
    ; task_type : MaintenanceWindowTaskType.t option
    ; parameters : String.t option
    ; status : MaintenanceWindowExecutionStatus.t option
    ; status_details : String.t option
    ; start_time : DateTime.t option
    ; end_time : DateTime.t option
    ; owner_information : String.t option
    ; window_target_id : String.t option
    }

  let make
      ?window_execution_id
      ?task_execution_id
      ?invocation_id
      ?execution_id
      ?task_type
      ?parameters
      ?status
      ?status_details
      ?start_time
      ?end_time
      ?owner_information
      ?window_target_id
      () =
    { window_execution_id
    ; task_execution_id
    ; invocation_id
    ; execution_id
    ; task_type
    ; parameters
    ; status
    ; status_details
    ; start_time
    ; end_time
    ; owner_information
    ; window_target_id
    }

  let parse xml =
    Some
      { window_execution_id =
          Aws.Util.option_bind (Aws.Xml.member "WindowExecutionId" xml) String.parse
      ; task_execution_id =
          Aws.Util.option_bind (Aws.Xml.member "TaskExecutionId" xml) String.parse
      ; invocation_id =
          Aws.Util.option_bind (Aws.Xml.member "InvocationId" xml) String.parse
      ; execution_id =
          Aws.Util.option_bind (Aws.Xml.member "ExecutionId" xml) String.parse
      ; task_type =
          Aws.Util.option_bind
            (Aws.Xml.member "TaskType" xml)
            MaintenanceWindowTaskType.parse
      ; parameters = Aws.Util.option_bind (Aws.Xml.member "Parameters" xml) String.parse
      ; status =
          Aws.Util.option_bind
            (Aws.Xml.member "Status" xml)
            MaintenanceWindowExecutionStatus.parse
      ; status_details =
          Aws.Util.option_bind (Aws.Xml.member "StatusDetails" xml) String.parse
      ; start_time = Aws.Util.option_bind (Aws.Xml.member "StartTime" xml) DateTime.parse
      ; end_time = Aws.Util.option_bind (Aws.Xml.member "EndTime" xml) DateTime.parse
      ; owner_information =
          Aws.Util.option_bind (Aws.Xml.member "OwnerInformation" xml) String.parse
      ; window_target_id =
          Aws.Util.option_bind (Aws.Xml.member "WindowTargetId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.window_target_id (fun f ->
               Aws.Query.Pair ("WindowTargetId", String.to_query f))
         ; Aws.Util.option_map v.owner_information (fun f ->
               Aws.Query.Pair ("OwnerInformation", String.to_query f))
         ; Aws.Util.option_map v.end_time (fun f ->
               Aws.Query.Pair ("EndTime", DateTime.to_query f))
         ; Aws.Util.option_map v.start_time (fun f ->
               Aws.Query.Pair ("StartTime", DateTime.to_query f))
         ; Aws.Util.option_map v.status_details (fun f ->
               Aws.Query.Pair ("StatusDetails", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", MaintenanceWindowExecutionStatus.to_query f))
         ; Aws.Util.option_map v.parameters (fun f ->
               Aws.Query.Pair ("Parameters", String.to_query f))
         ; Aws.Util.option_map v.task_type (fun f ->
               Aws.Query.Pair ("TaskType", MaintenanceWindowTaskType.to_query f))
         ; Aws.Util.option_map v.execution_id (fun f ->
               Aws.Query.Pair ("ExecutionId", String.to_query f))
         ; Aws.Util.option_map v.invocation_id (fun f ->
               Aws.Query.Pair ("InvocationId", String.to_query f))
         ; Aws.Util.option_map v.task_execution_id (fun f ->
               Aws.Query.Pair ("TaskExecutionId", String.to_query f))
         ; Aws.Util.option_map v.window_execution_id (fun f ->
               Aws.Query.Pair ("WindowExecutionId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.window_target_id (fun f ->
               "WindowTargetId", String.to_json f)
         ; Aws.Util.option_map v.owner_information (fun f ->
               "OwnerInformation", String.to_json f)
         ; Aws.Util.option_map v.end_time (fun f -> "EndTime", DateTime.to_json f)
         ; Aws.Util.option_map v.start_time (fun f -> "StartTime", DateTime.to_json f)
         ; Aws.Util.option_map v.status_details (fun f ->
               "StatusDetails", String.to_json f)
         ; Aws.Util.option_map v.status (fun f ->
               "Status", MaintenanceWindowExecutionStatus.to_json f)
         ; Aws.Util.option_map v.parameters (fun f -> "Parameters", String.to_json f)
         ; Aws.Util.option_map v.task_type (fun f ->
               "TaskType", MaintenanceWindowTaskType.to_json f)
         ; Aws.Util.option_map v.execution_id (fun f -> "ExecutionId", String.to_json f)
         ; Aws.Util.option_map v.invocation_id (fun f -> "InvocationId", String.to_json f)
         ; Aws.Util.option_map v.task_execution_id (fun f ->
               "TaskExecutionId", String.to_json f)
         ; Aws.Util.option_map v.window_execution_id (fun f ->
               "WindowExecutionId", String.to_json f)
         ])

  let of_json j =
    { window_execution_id =
        Aws.Util.option_map (Aws.Json.lookup j "WindowExecutionId") String.of_json
    ; task_execution_id =
        Aws.Util.option_map (Aws.Json.lookup j "TaskExecutionId") String.of_json
    ; invocation_id =
        Aws.Util.option_map (Aws.Json.lookup j "InvocationId") String.of_json
    ; execution_id = Aws.Util.option_map (Aws.Json.lookup j "ExecutionId") String.of_json
    ; task_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "TaskType")
          MaintenanceWindowTaskType.of_json
    ; parameters = Aws.Util.option_map (Aws.Json.lookup j "Parameters") String.of_json
    ; status =
        Aws.Util.option_map
          (Aws.Json.lookup j "Status")
          MaintenanceWindowExecutionStatus.of_json
    ; status_details =
        Aws.Util.option_map (Aws.Json.lookup j "StatusDetails") String.of_json
    ; start_time = Aws.Util.option_map (Aws.Json.lookup j "StartTime") DateTime.of_json
    ; end_time = Aws.Util.option_map (Aws.Json.lookup j "EndTime") DateTime.of_json
    ; owner_information =
        Aws.Util.option_map (Aws.Json.lookup j "OwnerInformation") String.of_json
    ; window_target_id =
        Aws.Util.option_map (Aws.Json.lookup j "WindowTargetId") String.of_json
    }
end

module MaintenanceWindowExecutionTaskInvocationIdentityList = struct
  type t = MaintenanceWindowExecutionTaskInvocationIdentity.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         MaintenanceWindowExecutionTaskInvocationIdentity.parse
         (Aws.Xml.members "member" xml))

  let to_query v =
    Aws.Query.to_query_list MaintenanceWindowExecutionTaskInvocationIdentity.to_query v

  let to_json v =
    `List (List.map MaintenanceWindowExecutionTaskInvocationIdentity.to_json v)

  let of_json j =
    Aws.Json.to_list MaintenanceWindowExecutionTaskInvocationIdentity.of_json j
end

module DescribeMaintenanceWindowExecutionTaskInvocationsResult = struct
  type t =
    { window_execution_task_invocation_identities :
        MaintenanceWindowExecutionTaskInvocationIdentityList.t
    ; next_token : String.t option
    }

  let make ?(window_execution_task_invocation_identities = []) ?next_token () =
    { window_execution_task_invocation_identities; next_token }

  let parse xml =
    Some
      { window_execution_task_invocation_identities =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "WindowExecutionTaskInvocationIdentities" xml)
               MaintenanceWindowExecutionTaskInvocationIdentityList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "WindowExecutionTaskInvocationIdentities.member"
                , MaintenanceWindowExecutionTaskInvocationIdentityList.to_query
                    v.window_execution_task_invocation_identities ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some
             ( "WindowExecutionTaskInvocationIdentities"
             , MaintenanceWindowExecutionTaskInvocationIdentityList.to_json
                 v.window_execution_task_invocation_identities )
         ])

  let of_json j =
    { window_execution_task_invocation_identities =
        MaintenanceWindowExecutionTaskInvocationIdentityList.of_json
          (Aws.Util.of_option_exn
             (Aws.Json.lookup j "WindowExecutionTaskInvocationIdentities"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module InstanceInformationFilter = struct
  type t =
    { key : InstanceInformationFilterKey.t
    ; value_set : InstanceInformationFilterValueSet.t
    }

  let make ~key ~value_set () = { key; value_set }

  let parse xml =
    Some
      { key =
          Aws.Xml.required
            "key"
            (Aws.Util.option_bind
               (Aws.Xml.member "key" xml)
               InstanceInformationFilterKey.parse)
      ; value_set =
          Aws.Xml.required
            "valueSet"
            (Aws.Util.option_bind
               (Aws.Xml.member "valueSet" xml)
               InstanceInformationFilterValueSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("valueSet.member", InstanceInformationFilterValueSet.to_query v.value_set))
         ; Some (Aws.Query.Pair ("key", InstanceInformationFilterKey.to_query v.key))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("valueSet", InstanceInformationFilterValueSet.to_json v.value_set)
         ; Some ("key", InstanceInformationFilterKey.to_json v.key)
         ])

  let of_json j =
    { key =
        InstanceInformationFilterKey.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "key"))
    ; value_set =
        InstanceInformationFilterValueSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "valueSet"))
    }
end

module InstanceInformationFilterList = struct
  type t = InstanceInformationFilter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map InstanceInformationFilter.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list InstanceInformationFilter.to_query v
  let to_json v = `List (List.map InstanceInformationFilter.to_json v)
  let of_json j = Aws.Json.to_list InstanceInformationFilter.of_json j
end

module InvalidInstanceId = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module ListTagsForResourceResult = struct
  type t = { tag_list : TagList.t }

  let make ?(tag_list = []) () = { tag_list }

  let parse xml =
    Some
      { tag_list =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "TagList" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagList.member", TagList.to_query v.tag_list)) ])

  let to_json v =
    `Assoc (Aws.Util.list_filter_opt [ Some ("TagList", TagList.to_json v.tag_list) ])

  let of_json j =
    { tag_list = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TagList")) }
end

module ListInventoryEntriesResult = struct
  type t =
    { type_name : String.t option
    ; instance_id : String.t option
    ; schema_version : String.t option
    ; capture_time : String.t option
    ; entries : InventoryItemEntryList.t
    ; next_token : String.t option
    }

  let make
      ?type_name
      ?instance_id
      ?schema_version
      ?capture_time
      ?(entries = [])
      ?next_token
      () =
    { type_name; instance_id; schema_version; capture_time; entries; next_token }

  let parse xml =
    Some
      { type_name = Aws.Util.option_bind (Aws.Xml.member "TypeName" xml) String.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse
      ; schema_version =
          Aws.Util.option_bind (Aws.Xml.member "SchemaVersion" xml) String.parse
      ; capture_time =
          Aws.Util.option_bind (Aws.Xml.member "CaptureTime" xml) String.parse
      ; entries =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Entries" xml)
               InventoryItemEntryList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair ("Entries.member", InventoryItemEntryList.to_query v.entries))
         ; Aws.Util.option_map v.capture_time (fun f ->
               Aws.Query.Pair ("CaptureTime", String.to_query f))
         ; Aws.Util.option_map v.schema_version (fun f ->
               Aws.Query.Pair ("SchemaVersion", String.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.type_name (fun f ->
               Aws.Query.Pair ("TypeName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Entries", InventoryItemEntryList.to_json v.entries)
         ; Aws.Util.option_map v.capture_time (fun f -> "CaptureTime", String.to_json f)
         ; Aws.Util.option_map v.schema_version (fun f ->
               "SchemaVersion", String.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "InstanceId", String.to_json f)
         ; Aws.Util.option_map v.type_name (fun f -> "TypeName", String.to_json f)
         ])

  let of_json j =
    { type_name = Aws.Util.option_map (Aws.Json.lookup j "TypeName") String.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "InstanceId") String.of_json
    ; schema_version =
        Aws.Util.option_map (Aws.Json.lookup j "SchemaVersion") String.of_json
    ; capture_time = Aws.Util.option_map (Aws.Json.lookup j "CaptureTime") String.of_json
    ; entries =
        InventoryItemEntryList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Entries"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module AccountSharingInfoList = struct
  type t = AccountSharingInfo.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map AccountSharingInfo.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list AccountSharingInfo.to_query v
  let to_json v = `List (List.map AccountSharingInfo.to_json v)
  let of_json j = Aws.Json.to_list AccountSharingInfo.of_json j
end

module DescribeDocumentPermissionResponse = struct
  type t =
    { account_ids : AccountIdList.t
    ; account_sharing_info_list : AccountSharingInfoList.t
    }

  let make ?(account_ids = []) ?(account_sharing_info_list = []) () =
    { account_ids; account_sharing_info_list }

  let parse xml =
    Some
      { account_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "AccountIds" xml) AccountIdList.parse)
      ; account_sharing_info_list =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AccountSharingInfoList" xml)
               AccountSharingInfoList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "AccountSharingInfoList.member"
                , AccountSharingInfoList.to_query v.account_sharing_info_list ))
         ; Some
             (Aws.Query.Pair ("AccountIds.member", AccountIdList.to_query v.account_ids))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "AccountSharingInfoList"
             , AccountSharingInfoList.to_json v.account_sharing_info_list )
         ; Some ("AccountIds", AccountIdList.to_json v.account_ids)
         ])

  let of_json j =
    { account_ids =
        AccountIdList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "AccountIds"))
    ; account_sharing_info_list =
        AccountSharingInfoList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AccountSharingInfoList"))
    }
end

module InstanceIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module CancelCommandRequest = struct
  type t =
    { command_id : String.t
    ; instance_ids : InstanceIdList.t
    }

  let make ~command_id ?(instance_ids = []) () = { command_id; instance_ids }

  let parse xml =
    Some
      { command_id =
          Aws.Xml.required
            "CommandId"
            (Aws.Util.option_bind (Aws.Xml.member "CommandId" xml) String.parse)
      ; instance_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "InstanceIds" xml) InstanceIdList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("InstanceIds.member", InstanceIdList.to_query v.instance_ids))
         ; Some (Aws.Query.Pair ("CommandId", String.to_query v.command_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("InstanceIds", InstanceIdList.to_json v.instance_ids)
         ; Some ("CommandId", String.to_json v.command_id)
         ])

  let of_json j =
    { command_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "CommandId"))
    ; instance_ids =
        InstanceIdList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceIds"))
    }
end

module S3OutputLocation = struct
  type t =
    { output_s3_region : String.t option
    ; output_s3_bucket_name : String.t option
    ; output_s3_key_prefix : String.t option
    }

  let make ?output_s3_region ?output_s3_bucket_name ?output_s3_key_prefix () =
    { output_s3_region; output_s3_bucket_name; output_s3_key_prefix }

  let parse xml =
    Some
      { output_s3_region =
          Aws.Util.option_bind (Aws.Xml.member "OutputS3Region" xml) String.parse
      ; output_s3_bucket_name =
          Aws.Util.option_bind (Aws.Xml.member "OutputS3BucketName" xml) String.parse
      ; output_s3_key_prefix =
          Aws.Util.option_bind (Aws.Xml.member "OutputS3KeyPrefix" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.output_s3_key_prefix (fun f ->
               Aws.Query.Pair ("OutputS3KeyPrefix", String.to_query f))
         ; Aws.Util.option_map v.output_s3_bucket_name (fun f ->
               Aws.Query.Pair ("OutputS3BucketName", String.to_query f))
         ; Aws.Util.option_map v.output_s3_region (fun f ->
               Aws.Query.Pair ("OutputS3Region", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.output_s3_key_prefix (fun f ->
               "OutputS3KeyPrefix", String.to_json f)
         ; Aws.Util.option_map v.output_s3_bucket_name (fun f ->
               "OutputS3BucketName", String.to_json f)
         ; Aws.Util.option_map v.output_s3_region (fun f ->
               "OutputS3Region", String.to_json f)
         ])

  let of_json j =
    { output_s3_region =
        Aws.Util.option_map (Aws.Json.lookup j "OutputS3Region") String.of_json
    ; output_s3_bucket_name =
        Aws.Util.option_map (Aws.Json.lookup j "OutputS3BucketName") String.of_json
    ; output_s3_key_prefix =
        Aws.Util.option_map (Aws.Json.lookup j "OutputS3KeyPrefix") String.of_json
    }
end

module InstanceAssociationOutputLocation = struct
  type t = { s3_location : S3OutputLocation.t option }

  let make ?s3_location () = { s3_location }

  let parse xml =
    Some
      { s3_location =
          Aws.Util.option_bind (Aws.Xml.member "S3Location" xml) S3OutputLocation.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.s3_location (fun f ->
               Aws.Query.Pair ("S3Location", S3OutputLocation.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.s3_location (fun f ->
               "S3Location", S3OutputLocation.to_json f)
         ])

  let of_json j =
    { s3_location =
        Aws.Util.option_map (Aws.Json.lookup j "S3Location") S3OutputLocation.of_json
    }
end

module AssociationSyncCompliance = struct
  type t =
    | AUTO
    | MANUAL

  let str_to_t = [ "MANUAL", MANUAL; "AUTO", AUTO ]
  let t_to_str = [ MANUAL, "MANUAL"; AUTO, "AUTO" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module UpdateAssociationRequest = struct
  type t =
    { association_id : String.t
    ; parameters : Parameters.t option
    ; document_version : String.t option
    ; schedule_expression : String.t option
    ; output_location : InstanceAssociationOutputLocation.t option
    ; name : String.t option
    ; targets : Targets.t
    ; association_name : String.t option
    ; association_version : String.t option
    ; automation_target_parameter_name : String.t option
    ; max_errors : String.t option
    ; max_concurrency : String.t option
    ; compliance_severity : AssociationComplianceSeverity.t option
    ; sync_compliance : AssociationSyncCompliance.t option
    ; apply_only_at_cron_interval : Boolean.t option
    }

  let make
      ~association_id
      ?parameters
      ?document_version
      ?schedule_expression
      ?output_location
      ?name
      ?(targets = [])
      ?association_name
      ?association_version
      ?automation_target_parameter_name
      ?max_errors
      ?max_concurrency
      ?compliance_severity
      ?sync_compliance
      ?apply_only_at_cron_interval
      () =
    { association_id
    ; parameters
    ; document_version
    ; schedule_expression
    ; output_location
    ; name
    ; targets
    ; association_name
    ; association_version
    ; automation_target_parameter_name
    ; max_errors
    ; max_concurrency
    ; compliance_severity
    ; sync_compliance
    ; apply_only_at_cron_interval
    }

  let parse xml =
    Some
      { association_id =
          Aws.Xml.required
            "AssociationId"
            (Aws.Util.option_bind (Aws.Xml.member "AssociationId" xml) String.parse)
      ; parameters =
          Aws.Util.option_bind (Aws.Xml.member "Parameters" xml) Parameters.parse
      ; document_version =
          Aws.Util.option_bind (Aws.Xml.member "DocumentVersion" xml) String.parse
      ; schedule_expression =
          Aws.Util.option_bind (Aws.Xml.member "ScheduleExpression" xml) String.parse
      ; output_location =
          Aws.Util.option_bind
            (Aws.Xml.member "OutputLocation" xml)
            InstanceAssociationOutputLocation.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; targets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Targets" xml) Targets.parse)
      ; association_name =
          Aws.Util.option_bind (Aws.Xml.member "AssociationName" xml) String.parse
      ; association_version =
          Aws.Util.option_bind (Aws.Xml.member "AssociationVersion" xml) String.parse
      ; automation_target_parameter_name =
          Aws.Util.option_bind
            (Aws.Xml.member "AutomationTargetParameterName" xml)
            String.parse
      ; max_errors = Aws.Util.option_bind (Aws.Xml.member "MaxErrors" xml) String.parse
      ; max_concurrency =
          Aws.Util.option_bind (Aws.Xml.member "MaxConcurrency" xml) String.parse
      ; compliance_severity =
          Aws.Util.option_bind
            (Aws.Xml.member "ComplianceSeverity" xml)
            AssociationComplianceSeverity.parse
      ; sync_compliance =
          Aws.Util.option_bind
            (Aws.Xml.member "SyncCompliance" xml)
            AssociationSyncCompliance.parse
      ; apply_only_at_cron_interval =
          Aws.Util.option_bind
            (Aws.Xml.member "ApplyOnlyAtCronInterval" xml)
            Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.apply_only_at_cron_interval (fun f ->
               Aws.Query.Pair ("ApplyOnlyAtCronInterval", Boolean.to_query f))
         ; Aws.Util.option_map v.sync_compliance (fun f ->
               Aws.Query.Pair ("SyncCompliance", AssociationSyncCompliance.to_query f))
         ; Aws.Util.option_map v.compliance_severity (fun f ->
               Aws.Query.Pair
                 ("ComplianceSeverity", AssociationComplianceSeverity.to_query f))
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               Aws.Query.Pair ("MaxConcurrency", String.to_query f))
         ; Aws.Util.option_map v.max_errors (fun f ->
               Aws.Query.Pair ("MaxErrors", String.to_query f))
         ; Aws.Util.option_map v.automation_target_parameter_name (fun f ->
               Aws.Query.Pair ("AutomationTargetParameterName", String.to_query f))
         ; Aws.Util.option_map v.association_version (fun f ->
               Aws.Query.Pair ("AssociationVersion", String.to_query f))
         ; Aws.Util.option_map v.association_name (fun f ->
               Aws.Query.Pair ("AssociationName", String.to_query f))
         ; Some (Aws.Query.Pair ("Targets.member", Targets.to_query v.targets))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.output_location (fun f ->
               Aws.Query.Pair
                 ("OutputLocation", InstanceAssociationOutputLocation.to_query f))
         ; Aws.Util.option_map v.schedule_expression (fun f ->
               Aws.Query.Pair ("ScheduleExpression", String.to_query f))
         ; Aws.Util.option_map v.document_version (fun f ->
               Aws.Query.Pair ("DocumentVersion", String.to_query f))
         ; Aws.Util.option_map v.parameters (fun f ->
               Aws.Query.Pair ("Parameters", Parameters.to_query f))
         ; Some (Aws.Query.Pair ("AssociationId", String.to_query v.association_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.apply_only_at_cron_interval (fun f ->
               "ApplyOnlyAtCronInterval", Boolean.to_json f)
         ; Aws.Util.option_map v.sync_compliance (fun f ->
               "SyncCompliance", AssociationSyncCompliance.to_json f)
         ; Aws.Util.option_map v.compliance_severity (fun f ->
               "ComplianceSeverity", AssociationComplianceSeverity.to_json f)
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               "MaxConcurrency", String.to_json f)
         ; Aws.Util.option_map v.max_errors (fun f -> "MaxErrors", String.to_json f)
         ; Aws.Util.option_map v.automation_target_parameter_name (fun f ->
               "AutomationTargetParameterName", String.to_json f)
         ; Aws.Util.option_map v.association_version (fun f ->
               "AssociationVersion", String.to_json f)
         ; Aws.Util.option_map v.association_name (fun f ->
               "AssociationName", String.to_json f)
         ; Some ("Targets", Targets.to_json v.targets)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.output_location (fun f ->
               "OutputLocation", InstanceAssociationOutputLocation.to_json f)
         ; Aws.Util.option_map v.schedule_expression (fun f ->
               "ScheduleExpression", String.to_json f)
         ; Aws.Util.option_map v.document_version (fun f ->
               "DocumentVersion", String.to_json f)
         ; Aws.Util.option_map v.parameters (fun f -> "Parameters", Parameters.to_json f)
         ; Some ("AssociationId", String.to_json v.association_id)
         ])

  let of_json j =
    { association_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "AssociationId"))
    ; parameters = Aws.Util.option_map (Aws.Json.lookup j "Parameters") Parameters.of_json
    ; document_version =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentVersion") String.of_json
    ; schedule_expression =
        Aws.Util.option_map (Aws.Json.lookup j "ScheduleExpression") String.of_json
    ; output_location =
        Aws.Util.option_map
          (Aws.Json.lookup j "OutputLocation")
          InstanceAssociationOutputLocation.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; targets = Targets.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Targets"))
    ; association_name =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationName") String.of_json
    ; association_version =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationVersion") String.of_json
    ; automation_target_parameter_name =
        Aws.Util.option_map
          (Aws.Json.lookup j "AutomationTargetParameterName")
          String.of_json
    ; max_errors = Aws.Util.option_map (Aws.Json.lookup j "MaxErrors") String.of_json
    ; max_concurrency =
        Aws.Util.option_map (Aws.Json.lookup j "MaxConcurrency") String.of_json
    ; compliance_severity =
        Aws.Util.option_map
          (Aws.Json.lookup j "ComplianceSeverity")
          AssociationComplianceSeverity.of_json
    ; sync_compliance =
        Aws.Util.option_map
          (Aws.Json.lookup j "SyncCompliance")
          AssociationSyncCompliance.of_json
    ; apply_only_at_cron_interval =
        Aws.Util.option_map (Aws.Json.lookup j "ApplyOnlyAtCronInterval") Boolean.of_json
    }
end

module ComplianceStringFilterValueList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module ComplianceQueryOperatorType = struct
  type t =
    | EQUAL
    | NOT_EQUAL
    | BEGIN_WITH
    | LESS_THAN
    | GREATER_THAN

  let str_to_t =
    [ "GREATER_THAN", GREATER_THAN
    ; "LESS_THAN", LESS_THAN
    ; "BEGIN_WITH", BEGIN_WITH
    ; "NOT_EQUAL", NOT_EQUAL
    ; "EQUAL", EQUAL
    ]

  let t_to_str =
    [ GREATER_THAN, "GREATER_THAN"
    ; LESS_THAN, "LESS_THAN"
    ; BEGIN_WITH, "BEGIN_WITH"
    ; NOT_EQUAL, "NOT_EQUAL"
    ; EQUAL, "EQUAL"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ComplianceStringFilter = struct
  type t =
    { key : String.t option
    ; values : ComplianceStringFilterValueList.t
    ; type_ : ComplianceQueryOperatorType.t option
    }

  let make ?key ?(values = []) ?type_ () = { key; values; type_ }

  let parse xml =
    Some
      { key = Aws.Util.option_bind (Aws.Xml.member "Key" xml) String.parse
      ; values =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Values" xml)
               ComplianceStringFilterValueList.parse)
      ; type_ =
          Aws.Util.option_bind
            (Aws.Xml.member "Type" xml)
            ComplianceQueryOperatorType.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", ComplianceQueryOperatorType.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Values.member", ComplianceStringFilterValueList.to_query v.values))
         ; Aws.Util.option_map v.key (fun f -> Aws.Query.Pair ("Key", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.type_ (fun f ->
               "Type", ComplianceQueryOperatorType.to_json f)
         ; Some ("Values", ComplianceStringFilterValueList.to_json v.values)
         ; Aws.Util.option_map v.key (fun f -> "Key", String.to_json f)
         ])

  let of_json j =
    { key = Aws.Util.option_map (Aws.Json.lookup j "Key") String.of_json
    ; values =
        ComplianceStringFilterValueList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Values"))
    ; type_ =
        Aws.Util.option_map (Aws.Json.lookup j "Type") ComplianceQueryOperatorType.of_json
    }
end

module ComplianceStringFilterList = struct
  type t = ComplianceStringFilter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ComplianceStringFilter.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list ComplianceStringFilter.to_query v
  let to_json v = `List (List.map ComplianceStringFilter.to_json v)
  let of_json j = Aws.Json.to_list ComplianceStringFilter.of_json j
end

module ComplianceResourceTypeList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module ListComplianceItemsRequest = struct
  type t =
    { filters : ComplianceStringFilterList.t
    ; resource_ids : ComplianceResourceIdList.t
    ; resource_types : ComplianceResourceTypeList.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    }

  let make
      ?(filters = [])
      ?(resource_ids = [])
      ?(resource_types = [])
      ?next_token
      ?max_results
      () =
    { filters; resource_ids; resource_types; next_token; max_results }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               ComplianceStringFilterList.parse)
      ; resource_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ResourceIds" xml)
               ComplianceResourceIdList.parse)
      ; resource_types =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ResourceTypes" xml)
               ComplianceResourceTypeList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ResourceTypes.member"
                , ComplianceResourceTypeList.to_query v.resource_types ))
         ; Some
             (Aws.Query.Pair
                ("ResourceIds.member", ComplianceResourceIdList.to_query v.resource_ids))
         ; Some
             (Aws.Query.Pair
                ("Filters.member", ComplianceStringFilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("ResourceTypes", ComplianceResourceTypeList.to_json v.resource_types)
         ; Some ("ResourceIds", ComplianceResourceIdList.to_json v.resource_ids)
         ; Some ("Filters", ComplianceStringFilterList.to_json v.filters)
         ])

  let of_json j =
    { filters =
        ComplianceStringFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; resource_ids =
        ComplianceResourceIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ResourceIds"))
    ; resource_types =
        ComplianceResourceTypeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ResourceTypes"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module StartAutomationExecutionResult = struct
  type t = { automation_execution_id : String.t option }

  let make ?automation_execution_id () = { automation_execution_id }

  let parse xml =
    Some
      { automation_execution_id =
          Aws.Util.option_bind (Aws.Xml.member "AutomationExecutionId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.automation_execution_id (fun f ->
               Aws.Query.Pair ("AutomationExecutionId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.automation_execution_id (fun f ->
               "AutomationExecutionId", String.to_json f)
         ])

  let of_json j =
    { automation_execution_id =
        Aws.Util.option_map (Aws.Json.lookup j "AutomationExecutionId") String.of_json
    }
end

module DescribeMaintenanceWindowTargetsRequest = struct
  type t =
    { window_id : String.t
    ; filters : MaintenanceWindowFilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ~window_id ?(filters = []) ?max_results ?next_token () =
    { window_id; filters; max_results; next_token }

  let parse xml =
    Some
      { window_id =
          Aws.Xml.required
            "WindowId"
            (Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               MaintenanceWindowFilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Filters.member", MaintenanceWindowFilterList.to_query v.filters))
         ; Some (Aws.Query.Pair ("WindowId", String.to_query v.window_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filters", MaintenanceWindowFilterList.to_json v.filters)
         ; Some ("WindowId", String.to_json v.window_id)
         ])

  let of_json j =
    { window_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowId"))
    ; filters =
        MaintenanceWindowFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module AssociationStatusAggregatedCount = struct
  type t = (String.t, Integer.t) Hashtbl.t

  let make elems () = elems
  let parse xml = None
  let to_query v = Aws.Query.to_query_hashtbl String.to_string Integer.to_query v

  let to_json v =
    `Assoc
      (Hashtbl.fold (fun k v acc -> (String.to_string k, Integer.to_json v) :: acc) v [])

  let of_json j = Aws.Json.to_hashtbl String.of_string Integer.of_json j
end

module AssociationOverview = struct
  type t =
    { status : String.t option
    ; detailed_status : String.t option
    ; association_status_aggregated_count : AssociationStatusAggregatedCount.t option
    }

  let make ?status ?detailed_status ?association_status_aggregated_count () =
    { status; detailed_status; association_status_aggregated_count }

  let parse xml =
    Some
      { status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      ; detailed_status =
          Aws.Util.option_bind (Aws.Xml.member "DetailedStatus" xml) String.parse
      ; association_status_aggregated_count =
          Aws.Util.option_bind
            (Aws.Xml.member "AssociationStatusAggregatedCount" xml)
            AssociationStatusAggregatedCount.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_status_aggregated_count (fun f ->
               Aws.Query.Pair
                 ( "AssociationStatusAggregatedCount"
                 , AssociationStatusAggregatedCount.to_query f ))
         ; Aws.Util.option_map v.detailed_status (fun f ->
               Aws.Query.Pair ("DetailedStatus", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_status_aggregated_count (fun f ->
               ( "AssociationStatusAggregatedCount"
               , AssociationStatusAggregatedCount.to_json f ))
         ; Aws.Util.option_map v.detailed_status (fun f ->
               "DetailedStatus", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ])

  let of_json j =
    { status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    ; detailed_status =
        Aws.Util.option_map (Aws.Json.lookup j "DetailedStatus") String.of_json
    ; association_status_aggregated_count =
        Aws.Util.option_map
          (Aws.Json.lookup j "AssociationStatusAggregatedCount")
          AssociationStatusAggregatedCount.of_json
    }
end

module Association = struct
  type t =
    { name : String.t option
    ; instance_id : String.t option
    ; association_id : String.t option
    ; association_version : String.t option
    ; document_version : String.t option
    ; targets : Targets.t
    ; last_execution_date : DateTime.t option
    ; overview : AssociationOverview.t option
    ; schedule_expression : String.t option
    ; association_name : String.t option
    }

  let make
      ?name
      ?instance_id
      ?association_id
      ?association_version
      ?document_version
      ?(targets = [])
      ?last_execution_date
      ?overview
      ?schedule_expression
      ?association_name
      () =
    { name
    ; instance_id
    ; association_id
    ; association_version
    ; document_version
    ; targets
    ; last_execution_date
    ; overview
    ; schedule_expression
    ; association_name
    }

  let parse xml =
    Some
      { name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse
      ; association_id =
          Aws.Util.option_bind (Aws.Xml.member "AssociationId" xml) String.parse
      ; association_version =
          Aws.Util.option_bind (Aws.Xml.member "AssociationVersion" xml) String.parse
      ; document_version =
          Aws.Util.option_bind (Aws.Xml.member "DocumentVersion" xml) String.parse
      ; targets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Targets" xml) Targets.parse)
      ; last_execution_date =
          Aws.Util.option_bind (Aws.Xml.member "LastExecutionDate" xml) DateTime.parse
      ; overview =
          Aws.Util.option_bind (Aws.Xml.member "Overview" xml) AssociationOverview.parse
      ; schedule_expression =
          Aws.Util.option_bind (Aws.Xml.member "ScheduleExpression" xml) String.parse
      ; association_name =
          Aws.Util.option_bind (Aws.Xml.member "AssociationName" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_name (fun f ->
               Aws.Query.Pair ("AssociationName", String.to_query f))
         ; Aws.Util.option_map v.schedule_expression (fun f ->
               Aws.Query.Pair ("ScheduleExpression", String.to_query f))
         ; Aws.Util.option_map v.overview (fun f ->
               Aws.Query.Pair ("Overview", AssociationOverview.to_query f))
         ; Aws.Util.option_map v.last_execution_date (fun f ->
               Aws.Query.Pair ("LastExecutionDate", DateTime.to_query f))
         ; Some (Aws.Query.Pair ("Targets.member", Targets.to_query v.targets))
         ; Aws.Util.option_map v.document_version (fun f ->
               Aws.Query.Pair ("DocumentVersion", String.to_query f))
         ; Aws.Util.option_map v.association_version (fun f ->
               Aws.Query.Pair ("AssociationVersion", String.to_query f))
         ; Aws.Util.option_map v.association_id (fun f ->
               Aws.Query.Pair ("AssociationId", String.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_name (fun f ->
               "AssociationName", String.to_json f)
         ; Aws.Util.option_map v.schedule_expression (fun f ->
               "ScheduleExpression", String.to_json f)
         ; Aws.Util.option_map v.overview (fun f ->
               "Overview", AssociationOverview.to_json f)
         ; Aws.Util.option_map v.last_execution_date (fun f ->
               "LastExecutionDate", DateTime.to_json f)
         ; Some ("Targets", Targets.to_json v.targets)
         ; Aws.Util.option_map v.document_version (fun f ->
               "DocumentVersion", String.to_json f)
         ; Aws.Util.option_map v.association_version (fun f ->
               "AssociationVersion", String.to_json f)
         ; Aws.Util.option_map v.association_id (fun f ->
               "AssociationId", String.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "InstanceId", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ])

  let of_json j =
    { name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "InstanceId") String.of_json
    ; association_id =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationId") String.of_json
    ; association_version =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationVersion") String.of_json
    ; document_version =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentVersion") String.of_json
    ; targets = Targets.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Targets"))
    ; last_execution_date =
        Aws.Util.option_map (Aws.Json.lookup j "LastExecutionDate") DateTime.of_json
    ; overview =
        Aws.Util.option_map (Aws.Json.lookup j "Overview") AssociationOverview.of_json
    ; schedule_expression =
        Aws.Util.option_map (Aws.Json.lookup j "ScheduleExpression") String.of_json
    ; association_name =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationName") String.of_json
    }
end

module AssociationList = struct
  type t = Association.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Association.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list Association.to_query v
  let to_json v = `List (List.map Association.to_json v)
  let of_json j = Aws.Json.to_list Association.of_json j
end

module CalendarState = struct
  type t =
    | OPEN
    | CLOSED

  let str_to_t = [ "CLOSED", CLOSED; "OPEN", OPEN ]
  let t_to_str = [ CLOSED, "CLOSED"; OPEN, "OPEN" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ExecutionMode = struct
  type t =
    | Auto
    | Interactive

  let str_to_t = [ "Interactive", Interactive; "Auto", Auto ]
  let t_to_str = [ Interactive, "Interactive"; Auto, "Auto" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DeleteParametersRequest = struct
  type t = { names : ParameterNameList.t }

  let make ~names () = { names }

  let parse xml =
    Some
      { names =
          Aws.Xml.required
            "Names"
            (Aws.Util.option_bind (Aws.Xml.member "Names" xml) ParameterNameList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Names.member", ParameterNameList.to_query v.names)) ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt [ Some ("Names", ParameterNameList.to_json v.names) ])

  let of_json j =
    { names =
        ParameterNameList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Names"))
    }
end

module UpdateDocumentDefaultVersionRequest = struct
  type t =
    { name : String.t
    ; document_version : String.t
    }

  let make ~name ~document_version () = { name; document_version }

  let parse xml =
    Some
      { name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      ; document_version =
          Aws.Xml.required
            "DocumentVersion"
            (Aws.Util.option_bind (Aws.Xml.member "DocumentVersion" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("DocumentVersion", String.to_query v.document_version))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("DocumentVersion", String.to_json v.document_version)
         ; Some ("Name", String.to_json v.name)
         ])

  let of_json j =
    { name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; document_version =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DocumentVersion"))
    }
end

module InventoryResultItemMap = struct
  type t = (String.t, InventoryResultItem.t) Hashtbl.t

  let make elems () = elems
  let parse xml = None

  let to_query v =
    Aws.Query.to_query_hashtbl String.to_string InventoryResultItem.to_query v

  let to_json v =
    `Assoc
      (Hashtbl.fold
         (fun k v acc -> (String.to_string k, InventoryResultItem.to_json v) :: acc)
         v
         [])

  let of_json j = Aws.Json.to_hashtbl String.of_string InventoryResultItem.of_json j
end

module DescribeInventoryDeletionsRequest = struct
  type t =
    { deletion_id : String.t option
    ; next_token : String.t option
    ; max_results : Integer.t option
    }

  let make ?deletion_id ?next_token ?max_results () =
    { deletion_id; next_token; max_results }

  let parse xml =
    Some
      { deletion_id = Aws.Util.option_bind (Aws.Xml.member "DeletionId" xml) String.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.deletion_id (fun f ->
               Aws.Query.Pair ("DeletionId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.deletion_id (fun f -> "DeletionId", String.to_json f)
         ])

  let of_json j =
    { deletion_id = Aws.Util.option_map (Aws.Json.lookup j "DeletionId") String.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module CreateDocumentRequest = struct
  type t =
    { content : String.t
    ; requires : DocumentRequiresList.t
    ; attachments : AttachmentsSourceList.t
    ; name : String.t
    ; version_name : String.t option
    ; document_type : DocumentType.t option
    ; document_format : DocumentFormat.t option
    ; target_type : String.t option
    ; tags : TagList.t
    }

  let make
      ~content
      ?(requires = [])
      ?(attachments = [])
      ~name
      ?version_name
      ?document_type
      ?document_format
      ?target_type
      ?(tags = [])
      () =
    { content
    ; requires
    ; attachments
    ; name
    ; version_name
    ; document_type
    ; document_format
    ; target_type
    ; tags
    }

  let parse xml =
    Some
      { content =
          Aws.Xml.required
            "Content"
            (Aws.Util.option_bind (Aws.Xml.member "Content" xml) String.parse)
      ; requires =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Requires" xml)
               DocumentRequiresList.parse)
      ; attachments =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Attachments" xml)
               AttachmentsSourceList.parse)
      ; name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      ; version_name =
          Aws.Util.option_bind (Aws.Xml.member "VersionName" xml) String.parse
      ; document_type =
          Aws.Util.option_bind (Aws.Xml.member "DocumentType" xml) DocumentType.parse
      ; document_format =
          Aws.Util.option_bind (Aws.Xml.member "DocumentFormat" xml) DocumentFormat.parse
      ; target_type = Aws.Util.option_bind (Aws.Xml.member "TargetType" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Aws.Util.option_map v.target_type (fun f ->
               Aws.Query.Pair ("TargetType", String.to_query f))
         ; Aws.Util.option_map v.document_format (fun f ->
               Aws.Query.Pair ("DocumentFormat", DocumentFormat.to_query f))
         ; Aws.Util.option_map v.document_type (fun f ->
               Aws.Query.Pair ("DocumentType", DocumentType.to_query f))
         ; Aws.Util.option_map v.version_name (fun f ->
               Aws.Query.Pair ("VersionName", String.to_query f))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ; Some
             (Aws.Query.Pair
                ("Attachments.member", AttachmentsSourceList.to_query v.attachments))
         ; Some
             (Aws.Query.Pair ("Requires.member", DocumentRequiresList.to_query v.requires))
         ; Some (Aws.Query.Pair ("Content", String.to_query v.content))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tags", TagList.to_json v.tags)
         ; Aws.Util.option_map v.target_type (fun f -> "TargetType", String.to_json f)
         ; Aws.Util.option_map v.document_format (fun f ->
               "DocumentFormat", DocumentFormat.to_json f)
         ; Aws.Util.option_map v.document_type (fun f ->
               "DocumentType", DocumentType.to_json f)
         ; Aws.Util.option_map v.version_name (fun f -> "VersionName", String.to_json f)
         ; Some ("Name", String.to_json v.name)
         ; Some ("Attachments", AttachmentsSourceList.to_json v.attachments)
         ; Some ("Requires", DocumentRequiresList.to_json v.requires)
         ; Some ("Content", String.to_json v.content)
         ])

  let of_json j =
    { content = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Content"))
    ; requires =
        DocumentRequiresList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Requires"))
    ; attachments =
        AttachmentsSourceList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Attachments"))
    ; name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; version_name = Aws.Util.option_map (Aws.Json.lookup j "VersionName") String.of_json
    ; document_type =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentType") DocumentType.of_json
    ; document_format =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentFormat") DocumentFormat.of_json
    ; target_type = Aws.Util.option_map (Aws.Json.lookup j "TargetType") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    }
end

module MaintenanceWindowTaskParameterValueList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module MaintenanceWindowTaskParameterValueExpression = struct
  type t = { values : MaintenanceWindowTaskParameterValueList.t }

  let make ?(values = []) () = { values }

  let parse xml =
    Some
      { values =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Values" xml)
               MaintenanceWindowTaskParameterValueList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "Values.member"
                , MaintenanceWindowTaskParameterValueList.to_query v.values ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Values", MaintenanceWindowTaskParameterValueList.to_json v.values) ])

  let of_json j =
    { values =
        MaintenanceWindowTaskParameterValueList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Values"))
    }
end

module MaintenanceWindowTaskParameters = struct
  type t = (String.t, MaintenanceWindowTaskParameterValueExpression.t) Hashtbl.t

  let make elems () = elems
  let parse xml = None

  let to_query v =
    Aws.Query.to_query_hashtbl
      String.to_string
      MaintenanceWindowTaskParameterValueExpression.to_query
      v

  let to_json v =
    `Assoc
      (Hashtbl.fold
         (fun k v acc ->
           (String.to_string k, MaintenanceWindowTaskParameterValueExpression.to_json v)
           :: acc)
         v
         [])

  let of_json j =
    Aws.Json.to_hashtbl
      String.of_string
      MaintenanceWindowTaskParameterValueExpression.of_json
      j
end

module LoggingInfo = struct
  type t =
    { s3_bucket_name : String.t
    ; s3_key_prefix : String.t option
    ; s3_region : String.t
    }

  let make ~s3_bucket_name ?s3_key_prefix ~s3_region () =
    { s3_bucket_name; s3_key_prefix; s3_region }

  let parse xml =
    Some
      { s3_bucket_name =
          Aws.Xml.required
            "S3BucketName"
            (Aws.Util.option_bind (Aws.Xml.member "S3BucketName" xml) String.parse)
      ; s3_key_prefix =
          Aws.Util.option_bind (Aws.Xml.member "S3KeyPrefix" xml) String.parse
      ; s3_region =
          Aws.Xml.required
            "S3Region"
            (Aws.Util.option_bind (Aws.Xml.member "S3Region" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("S3Region", String.to_query v.s3_region))
         ; Aws.Util.option_map v.s3_key_prefix (fun f ->
               Aws.Query.Pair ("S3KeyPrefix", String.to_query f))
         ; Some (Aws.Query.Pair ("S3BucketName", String.to_query v.s3_bucket_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("S3Region", String.to_json v.s3_region)
         ; Aws.Util.option_map v.s3_key_prefix (fun f -> "S3KeyPrefix", String.to_json f)
         ; Some ("S3BucketName", String.to_json v.s3_bucket_name)
         ])

  let of_json j =
    { s3_bucket_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "S3BucketName"))
    ; s3_key_prefix = Aws.Util.option_map (Aws.Json.lookup j "S3KeyPrefix") String.of_json
    ; s3_region = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "S3Region"))
    }
end

module UpdateMaintenanceWindowTaskRequest = struct
  type t =
    { window_id : String.t
    ; window_task_id : String.t
    ; targets : Targets.t
    ; task_arn : String.t option
    ; service_role_arn : String.t option
    ; task_parameters : MaintenanceWindowTaskParameters.t option
    ; task_invocation_parameters : MaintenanceWindowTaskInvocationParameters.t option
    ; priority : Integer.t option
    ; max_concurrency : String.t option
    ; max_errors : String.t option
    ; logging_info : LoggingInfo.t option
    ; name : String.t option
    ; description : String.t option
    ; replace : Boolean.t option
    }

  let make
      ~window_id
      ~window_task_id
      ?(targets = [])
      ?task_arn
      ?service_role_arn
      ?task_parameters
      ?task_invocation_parameters
      ?priority
      ?max_concurrency
      ?max_errors
      ?logging_info
      ?name
      ?description
      ?replace
      () =
    { window_id
    ; window_task_id
    ; targets
    ; task_arn
    ; service_role_arn
    ; task_parameters
    ; task_invocation_parameters
    ; priority
    ; max_concurrency
    ; max_errors
    ; logging_info
    ; name
    ; description
    ; replace
    }

  let parse xml =
    Some
      { window_id =
          Aws.Xml.required
            "WindowId"
            (Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse)
      ; window_task_id =
          Aws.Xml.required
            "WindowTaskId"
            (Aws.Util.option_bind (Aws.Xml.member "WindowTaskId" xml) String.parse)
      ; targets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Targets" xml) Targets.parse)
      ; task_arn = Aws.Util.option_bind (Aws.Xml.member "TaskArn" xml) String.parse
      ; service_role_arn =
          Aws.Util.option_bind (Aws.Xml.member "ServiceRoleArn" xml) String.parse
      ; task_parameters =
          Aws.Util.option_bind
            (Aws.Xml.member "TaskParameters" xml)
            MaintenanceWindowTaskParameters.parse
      ; task_invocation_parameters =
          Aws.Util.option_bind
            (Aws.Xml.member "TaskInvocationParameters" xml)
            MaintenanceWindowTaskInvocationParameters.parse
      ; priority = Aws.Util.option_bind (Aws.Xml.member "Priority" xml) Integer.parse
      ; max_concurrency =
          Aws.Util.option_bind (Aws.Xml.member "MaxConcurrency" xml) String.parse
      ; max_errors = Aws.Util.option_bind (Aws.Xml.member "MaxErrors" xml) String.parse
      ; logging_info =
          Aws.Util.option_bind (Aws.Xml.member "LoggingInfo" xml) LoggingInfo.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; replace = Aws.Util.option_bind (Aws.Xml.member "Replace" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.replace (fun f ->
               Aws.Query.Pair ("Replace", Boolean.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.logging_info (fun f ->
               Aws.Query.Pair ("LoggingInfo", LoggingInfo.to_query f))
         ; Aws.Util.option_map v.max_errors (fun f ->
               Aws.Query.Pair ("MaxErrors", String.to_query f))
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               Aws.Query.Pair ("MaxConcurrency", String.to_query f))
         ; Aws.Util.option_map v.priority (fun f ->
               Aws.Query.Pair ("Priority", Integer.to_query f))
         ; Aws.Util.option_map v.task_invocation_parameters (fun f ->
               Aws.Query.Pair
                 ( "TaskInvocationParameters"
                 , MaintenanceWindowTaskInvocationParameters.to_query f ))
         ; Aws.Util.option_map v.task_parameters (fun f ->
               Aws.Query.Pair
                 ("TaskParameters", MaintenanceWindowTaskParameters.to_query f))
         ; Aws.Util.option_map v.service_role_arn (fun f ->
               Aws.Query.Pair ("ServiceRoleArn", String.to_query f))
         ; Aws.Util.option_map v.task_arn (fun f ->
               Aws.Query.Pair ("TaskArn", String.to_query f))
         ; Some (Aws.Query.Pair ("Targets.member", Targets.to_query v.targets))
         ; Some (Aws.Query.Pair ("WindowTaskId", String.to_query v.window_task_id))
         ; Some (Aws.Query.Pair ("WindowId", String.to_query v.window_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.replace (fun f -> "Replace", Boolean.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.logging_info (fun f ->
               "LoggingInfo", LoggingInfo.to_json f)
         ; Aws.Util.option_map v.max_errors (fun f -> "MaxErrors", String.to_json f)
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               "MaxConcurrency", String.to_json f)
         ; Aws.Util.option_map v.priority (fun f -> "Priority", Integer.to_json f)
         ; Aws.Util.option_map v.task_invocation_parameters (fun f ->
               ( "TaskInvocationParameters"
               , MaintenanceWindowTaskInvocationParameters.to_json f ))
         ; Aws.Util.option_map v.task_parameters (fun f ->
               "TaskParameters", MaintenanceWindowTaskParameters.to_json f)
         ; Aws.Util.option_map v.service_role_arn (fun f ->
               "ServiceRoleArn", String.to_json f)
         ; Aws.Util.option_map v.task_arn (fun f -> "TaskArn", String.to_json f)
         ; Some ("Targets", Targets.to_json v.targets)
         ; Some ("WindowTaskId", String.to_json v.window_task_id)
         ; Some ("WindowId", String.to_json v.window_id)
         ])

  let of_json j =
    { window_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowId"))
    ; window_task_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowTaskId"))
    ; targets = Targets.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Targets"))
    ; task_arn = Aws.Util.option_map (Aws.Json.lookup j "TaskArn") String.of_json
    ; service_role_arn =
        Aws.Util.option_map (Aws.Json.lookup j "ServiceRoleArn") String.of_json
    ; task_parameters =
        Aws.Util.option_map
          (Aws.Json.lookup j "TaskParameters")
          MaintenanceWindowTaskParameters.of_json
    ; task_invocation_parameters =
        Aws.Util.option_map
          (Aws.Json.lookup j "TaskInvocationParameters")
          MaintenanceWindowTaskInvocationParameters.of_json
    ; priority = Aws.Util.option_map (Aws.Json.lookup j "Priority") Integer.of_json
    ; max_concurrency =
        Aws.Util.option_map (Aws.Json.lookup j "MaxConcurrency") String.of_json
    ; max_errors = Aws.Util.option_map (Aws.Json.lookup j "MaxErrors") String.of_json
    ; logging_info =
        Aws.Util.option_map (Aws.Json.lookup j "LoggingInfo") LoggingInfo.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; replace = Aws.Util.option_map (Aws.Json.lookup j "Replace") Boolean.of_json
    }
end

module ModifyDocumentPermissionResponse = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module PatchProperty = struct
  type t =
    | PRODUCT
    | PRODUCT_FAMILY
    | CLASSIFICATION
    | MSRC_SEVERITY
    | PRIORITY
    | SEVERITY

  let str_to_t =
    [ "SEVERITY", SEVERITY
    ; "PRIORITY", PRIORITY
    ; "MSRC_SEVERITY", MSRC_SEVERITY
    ; "CLASSIFICATION", CLASSIFICATION
    ; "PRODUCT_FAMILY", PRODUCT_FAMILY
    ; "PRODUCT", PRODUCT
    ]

  let t_to_str =
    [ SEVERITY, "SEVERITY"
    ; PRIORITY, "PRIORITY"
    ; MSRC_SEVERITY, "MSRC_SEVERITY"
    ; CLASSIFICATION, "CLASSIFICATION"
    ; PRODUCT_FAMILY, "PRODUCT_FAMILY"
    ; PRODUCT, "PRODUCT"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module AssociationExecutionDoesNotExist = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module DocumentDefaultVersionDescription = struct
  type t =
    { name : String.t option
    ; default_version : String.t option
    ; default_version_name : String.t option
    }

  let make ?name ?default_version ?default_version_name () =
    { name; default_version; default_version_name }

  let parse xml =
    Some
      { name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; default_version =
          Aws.Util.option_bind (Aws.Xml.member "DefaultVersion" xml) String.parse
      ; default_version_name =
          Aws.Util.option_bind (Aws.Xml.member "DefaultVersionName" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.default_version_name (fun f ->
               Aws.Query.Pair ("DefaultVersionName", String.to_query f))
         ; Aws.Util.option_map v.default_version (fun f ->
               Aws.Query.Pair ("DefaultVersion", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.default_version_name (fun f ->
               "DefaultVersionName", String.to_json f)
         ; Aws.Util.option_map v.default_version (fun f ->
               "DefaultVersion", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ])

  let of_json j =
    { name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; default_version =
        Aws.Util.option_map (Aws.Json.lookup j "DefaultVersion") String.of_json
    ; default_version_name =
        Aws.Util.option_map (Aws.Json.lookup j "DefaultVersionName") String.of_json
    }
end

module ParameterVersionLabelLimitExceeded = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json }
end

module CreateActivationRequest = struct
  type t =
    { description : String.t option
    ; default_instance_name : String.t option
    ; iam_role : String.t
    ; registration_limit : Integer.t option
    ; expiration_date : DateTime.t option
    ; tags : TagList.t
    }

  let make
      ?description
      ?default_instance_name
      ~iam_role
      ?registration_limit
      ?expiration_date
      ?(tags = [])
      () =
    { description
    ; default_instance_name
    ; iam_role
    ; registration_limit
    ; expiration_date
    ; tags
    }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; default_instance_name =
          Aws.Util.option_bind (Aws.Xml.member "DefaultInstanceName" xml) String.parse
      ; iam_role =
          Aws.Xml.required
            "IamRole"
            (Aws.Util.option_bind (Aws.Xml.member "IamRole" xml) String.parse)
      ; registration_limit =
          Aws.Util.option_bind (Aws.Xml.member "RegistrationLimit" xml) Integer.parse
      ; expiration_date =
          Aws.Util.option_bind (Aws.Xml.member "ExpirationDate" xml) DateTime.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Aws.Util.option_map v.expiration_date (fun f ->
               Aws.Query.Pair ("ExpirationDate", DateTime.to_query f))
         ; Aws.Util.option_map v.registration_limit (fun f ->
               Aws.Query.Pair ("RegistrationLimit", Integer.to_query f))
         ; Some (Aws.Query.Pair ("IamRole", String.to_query v.iam_role))
         ; Aws.Util.option_map v.default_instance_name (fun f ->
               Aws.Query.Pair ("DefaultInstanceName", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tags", TagList.to_json v.tags)
         ; Aws.Util.option_map v.expiration_date (fun f ->
               "ExpirationDate", DateTime.to_json f)
         ; Aws.Util.option_map v.registration_limit (fun f ->
               "RegistrationLimit", Integer.to_json f)
         ; Some ("IamRole", String.to_json v.iam_role)
         ; Aws.Util.option_map v.default_instance_name (fun f ->
               "DefaultInstanceName", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; default_instance_name =
        Aws.Util.option_map (Aws.Json.lookup j "DefaultInstanceName") String.of_json
    ; iam_role = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "IamRole"))
    ; registration_limit =
        Aws.Util.option_map (Aws.Json.lookup j "RegistrationLimit") Integer.of_json
    ; expiration_date =
        Aws.Util.option_map (Aws.Json.lookup j "ExpirationDate") DateTime.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    }
end

module DeleteAssociationRequest = struct
  type t =
    { name : String.t option
    ; instance_id : String.t option
    ; association_id : String.t option
    }

  let make ?name ?instance_id ?association_id () = { name; instance_id; association_id }

  let parse xml =
    Some
      { name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse
      ; association_id =
          Aws.Util.option_bind (Aws.Xml.member "AssociationId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_id (fun f ->
               Aws.Query.Pair ("AssociationId", String.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_id (fun f ->
               "AssociationId", String.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "InstanceId", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ])

  let of_json j =
    { name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "InstanceId") String.of_json
    ; association_id =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationId") String.of_json
    }
end

module DeleteActivationRequest = struct
  type t = { activation_id : String.t }

  let make ~activation_id () = { activation_id }

  let parse xml =
    Some
      { activation_id =
          Aws.Xml.required
            "ActivationId"
            (Aws.Util.option_bind (Aws.Xml.member "ActivationId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("ActivationId", String.to_query v.activation_id)) ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt [ Some ("ActivationId", String.to_json v.activation_id) ])

  let of_json j =
    { activation_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ActivationId"))
    }
end

module CommandStatus = struct
  type t =
    | Pending
    | InProgress
    | Success
    | Cancelled
    | Failed
    | TimedOut
    | Cancelling

  let str_to_t =
    [ "Cancelling", Cancelling
    ; "TimedOut", TimedOut
    ; "Failed", Failed
    ; "Cancelled", Cancelled
    ; "Success", Success
    ; "InProgress", InProgress
    ; "Pending", Pending
    ]

  let t_to_str =
    [ Cancelling, "Cancelling"
    ; TimedOut, "TimedOut"
    ; Failed, "Failed"
    ; Cancelled, "Cancelled"
    ; Success, "Success"
    ; InProgress, "InProgress"
    ; Pending, "Pending"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module Command = struct
  type t =
    { command_id : String.t option
    ; document_name : String.t option
    ; document_version : String.t option
    ; comment : String.t option
    ; expires_after : DateTime.t option
    ; parameters : Parameters.t option
    ; instance_ids : InstanceIdList.t
    ; targets : Targets.t
    ; requested_date_time : DateTime.t option
    ; status : CommandStatus.t option
    ; status_details : String.t option
    ; output_s3_region : String.t option
    ; output_s3_bucket_name : String.t option
    ; output_s3_key_prefix : String.t option
    ; max_concurrency : String.t option
    ; max_errors : String.t option
    ; target_count : Integer.t option
    ; completed_count : Integer.t option
    ; error_count : Integer.t option
    ; delivery_timed_out_count : Integer.t option
    ; service_role : String.t option
    ; notification_config : NotificationConfig.t option
    ; cloud_watch_output_config : CloudWatchOutputConfig.t option
    ; timeout_seconds : Integer.t option
    }

  let make
      ?command_id
      ?document_name
      ?document_version
      ?comment
      ?expires_after
      ?parameters
      ?(instance_ids = [])
      ?(targets = [])
      ?requested_date_time
      ?status
      ?status_details
      ?output_s3_region
      ?output_s3_bucket_name
      ?output_s3_key_prefix
      ?max_concurrency
      ?max_errors
      ?target_count
      ?completed_count
      ?error_count
      ?delivery_timed_out_count
      ?service_role
      ?notification_config
      ?cloud_watch_output_config
      ?timeout_seconds
      () =
    { command_id
    ; document_name
    ; document_version
    ; comment
    ; expires_after
    ; parameters
    ; instance_ids
    ; targets
    ; requested_date_time
    ; status
    ; status_details
    ; output_s3_region
    ; output_s3_bucket_name
    ; output_s3_key_prefix
    ; max_concurrency
    ; max_errors
    ; target_count
    ; completed_count
    ; error_count
    ; delivery_timed_out_count
    ; service_role
    ; notification_config
    ; cloud_watch_output_config
    ; timeout_seconds
    }

  let parse xml =
    Some
      { command_id = Aws.Util.option_bind (Aws.Xml.member "CommandId" xml) String.parse
      ; document_name =
          Aws.Util.option_bind (Aws.Xml.member "DocumentName" xml) String.parse
      ; document_version =
          Aws.Util.option_bind (Aws.Xml.member "DocumentVersion" xml) String.parse
      ; comment = Aws.Util.option_bind (Aws.Xml.member "Comment" xml) String.parse
      ; expires_after =
          Aws.Util.option_bind (Aws.Xml.member "ExpiresAfter" xml) DateTime.parse
      ; parameters =
          Aws.Util.option_bind (Aws.Xml.member "Parameters" xml) Parameters.parse
      ; instance_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "InstanceIds" xml) InstanceIdList.parse)
      ; targets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Targets" xml) Targets.parse)
      ; requested_date_time =
          Aws.Util.option_bind (Aws.Xml.member "RequestedDateTime" xml) DateTime.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) CommandStatus.parse
      ; status_details =
          Aws.Util.option_bind (Aws.Xml.member "StatusDetails" xml) String.parse
      ; output_s3_region =
          Aws.Util.option_bind (Aws.Xml.member "OutputS3Region" xml) String.parse
      ; output_s3_bucket_name =
          Aws.Util.option_bind (Aws.Xml.member "OutputS3BucketName" xml) String.parse
      ; output_s3_key_prefix =
          Aws.Util.option_bind (Aws.Xml.member "OutputS3KeyPrefix" xml) String.parse
      ; max_concurrency =
          Aws.Util.option_bind (Aws.Xml.member "MaxConcurrency" xml) String.parse
      ; max_errors = Aws.Util.option_bind (Aws.Xml.member "MaxErrors" xml) String.parse
      ; target_count =
          Aws.Util.option_bind (Aws.Xml.member "TargetCount" xml) Integer.parse
      ; completed_count =
          Aws.Util.option_bind (Aws.Xml.member "CompletedCount" xml) Integer.parse
      ; error_count = Aws.Util.option_bind (Aws.Xml.member "ErrorCount" xml) Integer.parse
      ; delivery_timed_out_count =
          Aws.Util.option_bind (Aws.Xml.member "DeliveryTimedOutCount" xml) Integer.parse
      ; service_role =
          Aws.Util.option_bind (Aws.Xml.member "ServiceRole" xml) String.parse
      ; notification_config =
          Aws.Util.option_bind
            (Aws.Xml.member "NotificationConfig" xml)
            NotificationConfig.parse
      ; cloud_watch_output_config =
          Aws.Util.option_bind
            (Aws.Xml.member "CloudWatchOutputConfig" xml)
            CloudWatchOutputConfig.parse
      ; timeout_seconds =
          Aws.Util.option_bind (Aws.Xml.member "TimeoutSeconds" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timeout_seconds (fun f ->
               Aws.Query.Pair ("TimeoutSeconds", Integer.to_query f))
         ; Aws.Util.option_map v.cloud_watch_output_config (fun f ->
               Aws.Query.Pair ("CloudWatchOutputConfig", CloudWatchOutputConfig.to_query f))
         ; Aws.Util.option_map v.notification_config (fun f ->
               Aws.Query.Pair ("NotificationConfig", NotificationConfig.to_query f))
         ; Aws.Util.option_map v.service_role (fun f ->
               Aws.Query.Pair ("ServiceRole", String.to_query f))
         ; Aws.Util.option_map v.delivery_timed_out_count (fun f ->
               Aws.Query.Pair ("DeliveryTimedOutCount", Integer.to_query f))
         ; Aws.Util.option_map v.error_count (fun f ->
               Aws.Query.Pair ("ErrorCount", Integer.to_query f))
         ; Aws.Util.option_map v.completed_count (fun f ->
               Aws.Query.Pair ("CompletedCount", Integer.to_query f))
         ; Aws.Util.option_map v.target_count (fun f ->
               Aws.Query.Pair ("TargetCount", Integer.to_query f))
         ; Aws.Util.option_map v.max_errors (fun f ->
               Aws.Query.Pair ("MaxErrors", String.to_query f))
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               Aws.Query.Pair ("MaxConcurrency", String.to_query f))
         ; Aws.Util.option_map v.output_s3_key_prefix (fun f ->
               Aws.Query.Pair ("OutputS3KeyPrefix", String.to_query f))
         ; Aws.Util.option_map v.output_s3_bucket_name (fun f ->
               Aws.Query.Pair ("OutputS3BucketName", String.to_query f))
         ; Aws.Util.option_map v.output_s3_region (fun f ->
               Aws.Query.Pair ("OutputS3Region", String.to_query f))
         ; Aws.Util.option_map v.status_details (fun f ->
               Aws.Query.Pair ("StatusDetails", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", CommandStatus.to_query f))
         ; Aws.Util.option_map v.requested_date_time (fun f ->
               Aws.Query.Pair ("RequestedDateTime", DateTime.to_query f))
         ; Some (Aws.Query.Pair ("Targets.member", Targets.to_query v.targets))
         ; Some
             (Aws.Query.Pair ("InstanceIds.member", InstanceIdList.to_query v.instance_ids))
         ; Aws.Util.option_map v.parameters (fun f ->
               Aws.Query.Pair ("Parameters", Parameters.to_query f))
         ; Aws.Util.option_map v.expires_after (fun f ->
               Aws.Query.Pair ("ExpiresAfter", DateTime.to_query f))
         ; Aws.Util.option_map v.comment (fun f ->
               Aws.Query.Pair ("Comment", String.to_query f))
         ; Aws.Util.option_map v.document_version (fun f ->
               Aws.Query.Pair ("DocumentVersion", String.to_query f))
         ; Aws.Util.option_map v.document_name (fun f ->
               Aws.Query.Pair ("DocumentName", String.to_query f))
         ; Aws.Util.option_map v.command_id (fun f ->
               Aws.Query.Pair ("CommandId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timeout_seconds (fun f ->
               "TimeoutSeconds", Integer.to_json f)
         ; Aws.Util.option_map v.cloud_watch_output_config (fun f ->
               "CloudWatchOutputConfig", CloudWatchOutputConfig.to_json f)
         ; Aws.Util.option_map v.notification_config (fun f ->
               "NotificationConfig", NotificationConfig.to_json f)
         ; Aws.Util.option_map v.service_role (fun f -> "ServiceRole", String.to_json f)
         ; Aws.Util.option_map v.delivery_timed_out_count (fun f ->
               "DeliveryTimedOutCount", Integer.to_json f)
         ; Aws.Util.option_map v.error_count (fun f -> "ErrorCount", Integer.to_json f)
         ; Aws.Util.option_map v.completed_count (fun f ->
               "CompletedCount", Integer.to_json f)
         ; Aws.Util.option_map v.target_count (fun f -> "TargetCount", Integer.to_json f)
         ; Aws.Util.option_map v.max_errors (fun f -> "MaxErrors", String.to_json f)
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               "MaxConcurrency", String.to_json f)
         ; Aws.Util.option_map v.output_s3_key_prefix (fun f ->
               "OutputS3KeyPrefix", String.to_json f)
         ; Aws.Util.option_map v.output_s3_bucket_name (fun f ->
               "OutputS3BucketName", String.to_json f)
         ; Aws.Util.option_map v.output_s3_region (fun f ->
               "OutputS3Region", String.to_json f)
         ; Aws.Util.option_map v.status_details (fun f ->
               "StatusDetails", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", CommandStatus.to_json f)
         ; Aws.Util.option_map v.requested_date_time (fun f ->
               "RequestedDateTime", DateTime.to_json f)
         ; Some ("Targets", Targets.to_json v.targets)
         ; Some ("InstanceIds", InstanceIdList.to_json v.instance_ids)
         ; Aws.Util.option_map v.parameters (fun f -> "Parameters", Parameters.to_json f)
         ; Aws.Util.option_map v.expires_after (fun f ->
               "ExpiresAfter", DateTime.to_json f)
         ; Aws.Util.option_map v.comment (fun f -> "Comment", String.to_json f)
         ; Aws.Util.option_map v.document_version (fun f ->
               "DocumentVersion", String.to_json f)
         ; Aws.Util.option_map v.document_name (fun f -> "DocumentName", String.to_json f)
         ; Aws.Util.option_map v.command_id (fun f -> "CommandId", String.to_json f)
         ])

  let of_json j =
    { command_id = Aws.Util.option_map (Aws.Json.lookup j "CommandId") String.of_json
    ; document_name =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentName") String.of_json
    ; document_version =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentVersion") String.of_json
    ; comment = Aws.Util.option_map (Aws.Json.lookup j "Comment") String.of_json
    ; expires_after =
        Aws.Util.option_map (Aws.Json.lookup j "ExpiresAfter") DateTime.of_json
    ; parameters = Aws.Util.option_map (Aws.Json.lookup j "Parameters") Parameters.of_json
    ; instance_ids =
        InstanceIdList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceIds"))
    ; targets = Targets.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Targets"))
    ; requested_date_time =
        Aws.Util.option_map (Aws.Json.lookup j "RequestedDateTime") DateTime.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") CommandStatus.of_json
    ; status_details =
        Aws.Util.option_map (Aws.Json.lookup j "StatusDetails") String.of_json
    ; output_s3_region =
        Aws.Util.option_map (Aws.Json.lookup j "OutputS3Region") String.of_json
    ; output_s3_bucket_name =
        Aws.Util.option_map (Aws.Json.lookup j "OutputS3BucketName") String.of_json
    ; output_s3_key_prefix =
        Aws.Util.option_map (Aws.Json.lookup j "OutputS3KeyPrefix") String.of_json
    ; max_concurrency =
        Aws.Util.option_map (Aws.Json.lookup j "MaxConcurrency") String.of_json
    ; max_errors = Aws.Util.option_map (Aws.Json.lookup j "MaxErrors") String.of_json
    ; target_count = Aws.Util.option_map (Aws.Json.lookup j "TargetCount") Integer.of_json
    ; completed_count =
        Aws.Util.option_map (Aws.Json.lookup j "CompletedCount") Integer.of_json
    ; error_count = Aws.Util.option_map (Aws.Json.lookup j "ErrorCount") Integer.of_json
    ; delivery_timed_out_count =
        Aws.Util.option_map (Aws.Json.lookup j "DeliveryTimedOutCount") Integer.of_json
    ; service_role = Aws.Util.option_map (Aws.Json.lookup j "ServiceRole") String.of_json
    ; notification_config =
        Aws.Util.option_map
          (Aws.Json.lookup j "NotificationConfig")
          NotificationConfig.of_json
    ; cloud_watch_output_config =
        Aws.Util.option_map
          (Aws.Json.lookup j "CloudWatchOutputConfig")
          CloudWatchOutputConfig.of_json
    ; timeout_seconds =
        Aws.Util.option_map (Aws.Json.lookup j "TimeoutSeconds") Integer.of_json
    }
end

module SendCommandResult = struct
  type t = { command : Command.t option }

  let make ?command () = { command }

  let parse xml =
    Some { command = Aws.Util.option_bind (Aws.Xml.member "Command" xml) Command.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.command (fun f ->
               Aws.Query.Pair ("Command", Command.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.command (fun f -> "Command", Command.to_json f) ])

  let of_json j =
    { command = Aws.Util.option_map (Aws.Json.lookup j "Command") Command.of_json }
end

module InvalidNotificationConfig = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module GetConnectionStatusResponse = struct
  type t =
    { target : String.t option
    ; status : ConnectionStatus.t option
    }

  let make ?target ?status () = { target; status }

  let parse xml =
    Some
      { target = Aws.Util.option_bind (Aws.Xml.member "Target" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) ConnectionStatus.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", ConnectionStatus.to_query f))
         ; Aws.Util.option_map v.target (fun f ->
               Aws.Query.Pair ("Target", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f -> "Status", ConnectionStatus.to_json f)
         ; Aws.Util.option_map v.target (fun f -> "Target", String.to_json f)
         ])

  let of_json j =
    { target = Aws.Util.option_map (Aws.Json.lookup j "Target") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") ConnectionStatus.of_json
    }
end

module ComplianceUploadType = struct
  type t =
    | COMPLETE
    | PARTIAL

  let str_to_t = [ "PARTIAL", PARTIAL; "COMPLETE", COMPLETE ]
  let t_to_str = [ PARTIAL, "PARTIAL"; COMPLETE, "COMPLETE" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module GetParametersByPathRequest = struct
  type t =
    { path : String.t
    ; recursive : Boolean.t option
    ; parameter_filters : ParameterStringFilterList.t
    ; with_decryption : Boolean.t option
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make
      ~path
      ?recursive
      ?(parameter_filters = [])
      ?with_decryption
      ?max_results
      ?next_token
      () =
    { path; recursive; parameter_filters; with_decryption; max_results; next_token }

  let parse xml =
    Some
      { path =
          Aws.Xml.required
            "Path"
            (Aws.Util.option_bind (Aws.Xml.member "Path" xml) String.parse)
      ; recursive = Aws.Util.option_bind (Aws.Xml.member "Recursive" xml) Boolean.parse
      ; parameter_filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ParameterFilters" xml)
               ParameterStringFilterList.parse)
      ; with_decryption =
          Aws.Util.option_bind (Aws.Xml.member "WithDecryption" xml) Boolean.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.with_decryption (fun f ->
               Aws.Query.Pair ("WithDecryption", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ParameterFilters.member"
                , ParameterStringFilterList.to_query v.parameter_filters ))
         ; Aws.Util.option_map v.recursive (fun f ->
               Aws.Query.Pair ("Recursive", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Path", String.to_query v.path))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.with_decryption (fun f ->
               "WithDecryption", Boolean.to_json f)
         ; Some ("ParameterFilters", ParameterStringFilterList.to_json v.parameter_filters)
         ; Aws.Util.option_map v.recursive (fun f -> "Recursive", Boolean.to_json f)
         ; Some ("Path", String.to_json v.path)
         ])

  let of_json j =
    { path = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Path"))
    ; recursive = Aws.Util.option_map (Aws.Json.lookup j "Recursive") Boolean.of_json
    ; parameter_filters =
        ParameterStringFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ParameterFilters"))
    ; with_decryption =
        Aws.Util.option_map (Aws.Json.lookup j "WithDecryption") Boolean.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module SessionStatus = struct
  type t =
    | Connected
    | Connecting
    | Disconnected
    | Terminated
    | Terminating
    | Failed

  let str_to_t =
    [ "Failed", Failed
    ; "Terminating", Terminating
    ; "Terminated", Terminated
    ; "Disconnected", Disconnected
    ; "Connecting", Connecting
    ; "Connected", Connected
    ]

  let t_to_str =
    [ Failed, "Failed"
    ; Terminating, "Terminating"
    ; Terminated, "Terminated"
    ; Disconnected, "Disconnected"
    ; Connecting, "Connecting"
    ; Connected, "Connected"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module SessionManagerOutputUrl = struct
  type t =
    { s3_output_url : String.t option
    ; cloud_watch_output_url : String.t option
    }

  let make ?s3_output_url ?cloud_watch_output_url () =
    { s3_output_url; cloud_watch_output_url }

  let parse xml =
    Some
      { s3_output_url =
          Aws.Util.option_bind (Aws.Xml.member "S3OutputUrl" xml) String.parse
      ; cloud_watch_output_url =
          Aws.Util.option_bind (Aws.Xml.member "CloudWatchOutputUrl" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cloud_watch_output_url (fun f ->
               Aws.Query.Pair ("CloudWatchOutputUrl", String.to_query f))
         ; Aws.Util.option_map v.s3_output_url (fun f ->
               Aws.Query.Pair ("S3OutputUrl", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cloud_watch_output_url (fun f ->
               "CloudWatchOutputUrl", String.to_json f)
         ; Aws.Util.option_map v.s3_output_url (fun f -> "S3OutputUrl", String.to_json f)
         ])

  let of_json j =
    { s3_output_url = Aws.Util.option_map (Aws.Json.lookup j "S3OutputUrl") String.of_json
    ; cloud_watch_output_url =
        Aws.Util.option_map (Aws.Json.lookup j "CloudWatchOutputUrl") String.of_json
    }
end

module Session = struct
  type t =
    { session_id : String.t option
    ; target : String.t option
    ; status : SessionStatus.t option
    ; start_date : DateTime.t option
    ; end_date : DateTime.t option
    ; document_name : String.t option
    ; owner : String.t option
    ; details : String.t option
    ; output_url : SessionManagerOutputUrl.t option
    }

  let make
      ?session_id
      ?target
      ?status
      ?start_date
      ?end_date
      ?document_name
      ?owner
      ?details
      ?output_url
      () =
    { session_id
    ; target
    ; status
    ; start_date
    ; end_date
    ; document_name
    ; owner
    ; details
    ; output_url
    }

  let parse xml =
    Some
      { session_id = Aws.Util.option_bind (Aws.Xml.member "SessionId" xml) String.parse
      ; target = Aws.Util.option_bind (Aws.Xml.member "Target" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) SessionStatus.parse
      ; start_date = Aws.Util.option_bind (Aws.Xml.member "StartDate" xml) DateTime.parse
      ; end_date = Aws.Util.option_bind (Aws.Xml.member "EndDate" xml) DateTime.parse
      ; document_name =
          Aws.Util.option_bind (Aws.Xml.member "DocumentName" xml) String.parse
      ; owner = Aws.Util.option_bind (Aws.Xml.member "Owner" xml) String.parse
      ; details = Aws.Util.option_bind (Aws.Xml.member "Details" xml) String.parse
      ; output_url =
          Aws.Util.option_bind
            (Aws.Xml.member "OutputUrl" xml)
            SessionManagerOutputUrl.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.output_url (fun f ->
               Aws.Query.Pair ("OutputUrl", SessionManagerOutputUrl.to_query f))
         ; Aws.Util.option_map v.details (fun f ->
               Aws.Query.Pair ("Details", String.to_query f))
         ; Aws.Util.option_map v.owner (fun f ->
               Aws.Query.Pair ("Owner", String.to_query f))
         ; Aws.Util.option_map v.document_name (fun f ->
               Aws.Query.Pair ("DocumentName", String.to_query f))
         ; Aws.Util.option_map v.end_date (fun f ->
               Aws.Query.Pair ("EndDate", DateTime.to_query f))
         ; Aws.Util.option_map v.start_date (fun f ->
               Aws.Query.Pair ("StartDate", DateTime.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", SessionStatus.to_query f))
         ; Aws.Util.option_map v.target (fun f ->
               Aws.Query.Pair ("Target", String.to_query f))
         ; Aws.Util.option_map v.session_id (fun f ->
               Aws.Query.Pair ("SessionId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.output_url (fun f ->
               "OutputUrl", SessionManagerOutputUrl.to_json f)
         ; Aws.Util.option_map v.details (fun f -> "Details", String.to_json f)
         ; Aws.Util.option_map v.owner (fun f -> "Owner", String.to_json f)
         ; Aws.Util.option_map v.document_name (fun f -> "DocumentName", String.to_json f)
         ; Aws.Util.option_map v.end_date (fun f -> "EndDate", DateTime.to_json f)
         ; Aws.Util.option_map v.start_date (fun f -> "StartDate", DateTime.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", SessionStatus.to_json f)
         ; Aws.Util.option_map v.target (fun f -> "Target", String.to_json f)
         ; Aws.Util.option_map v.session_id (fun f -> "SessionId", String.to_json f)
         ])

  let of_json j =
    { session_id = Aws.Util.option_map (Aws.Json.lookup j "SessionId") String.of_json
    ; target = Aws.Util.option_map (Aws.Json.lookup j "Target") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") SessionStatus.of_json
    ; start_date = Aws.Util.option_map (Aws.Json.lookup j "StartDate") DateTime.of_json
    ; end_date = Aws.Util.option_map (Aws.Json.lookup j "EndDate") DateTime.of_json
    ; document_name =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentName") String.of_json
    ; owner = Aws.Util.option_map (Aws.Json.lookup j "Owner") String.of_json
    ; details = Aws.Util.option_map (Aws.Json.lookup j "Details") String.of_json
    ; output_url =
        Aws.Util.option_map
          (Aws.Json.lookup j "OutputUrl")
          SessionManagerOutputUrl.of_json
    }
end

module SessionList = struct
  type t = Session.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Session.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list Session.to_query v
  let to_json v = `List (List.map Session.to_json v)
  let of_json j = Aws.Json.to_list Session.of_json j
end

module ComplianceItemEntry = struct
  type t =
    { id : String.t option
    ; title : String.t option
    ; severity : ComplianceSeverity.t
    ; status : ComplianceStatus.t
    ; details : ComplianceItemDetails.t option
    }

  let make ?id ?title ~severity ~status ?details () =
    { id; title; severity; status; details }

  let parse xml =
    Some
      { id = Aws.Util.option_bind (Aws.Xml.member "Id" xml) String.parse
      ; title = Aws.Util.option_bind (Aws.Xml.member "Title" xml) String.parse
      ; severity =
          Aws.Xml.required
            "Severity"
            (Aws.Util.option_bind
               (Aws.Xml.member "Severity" xml)
               ComplianceSeverity.parse)
      ; status =
          Aws.Xml.required
            "Status"
            (Aws.Util.option_bind (Aws.Xml.member "Status" xml) ComplianceStatus.parse)
      ; details =
          Aws.Util.option_bind (Aws.Xml.member "Details" xml) ComplianceItemDetails.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.details (fun f ->
               Aws.Query.Pair ("Details", ComplianceItemDetails.to_query f))
         ; Some (Aws.Query.Pair ("Status", ComplianceStatus.to_query v.status))
         ; Some (Aws.Query.Pair ("Severity", ComplianceSeverity.to_query v.severity))
         ; Aws.Util.option_map v.title (fun f ->
               Aws.Query.Pair ("Title", String.to_query f))
         ; Aws.Util.option_map v.id (fun f -> Aws.Query.Pair ("Id", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.details (fun f ->
               "Details", ComplianceItemDetails.to_json f)
         ; Some ("Status", ComplianceStatus.to_json v.status)
         ; Some ("Severity", ComplianceSeverity.to_json v.severity)
         ; Aws.Util.option_map v.title (fun f -> "Title", String.to_json f)
         ; Aws.Util.option_map v.id (fun f -> "Id", String.to_json f)
         ])

  let of_json j =
    { id = Aws.Util.option_map (Aws.Json.lookup j "Id") String.of_json
    ; title = Aws.Util.option_map (Aws.Json.lookup j "Title") String.of_json
    ; severity =
        ComplianceSeverity.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Severity"))
    ; status =
        ComplianceStatus.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Status"))
    ; details =
        Aws.Util.option_map (Aws.Json.lookup j "Details") ComplianceItemDetails.of_json
    }
end

module MaintenanceWindowIdentityList = struct
  type t = MaintenanceWindowIdentity.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map MaintenanceWindowIdentity.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list MaintenanceWindowIdentity.to_query v
  let to_json v = `List (List.map MaintenanceWindowIdentity.to_json v)
  let of_json j = Aws.Json.to_list MaintenanceWindowIdentity.of_json j
end

module DescribeMaintenanceWindowsResult = struct
  type t =
    { window_identities : MaintenanceWindowIdentityList.t
    ; next_token : String.t option
    }

  let make ?(window_identities = []) ?next_token () = { window_identities; next_token }

  let parse xml =
    Some
      { window_identities =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "WindowIdentities" xml)
               MaintenanceWindowIdentityList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "WindowIdentities.member"
                , MaintenanceWindowIdentityList.to_query v.window_identities ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some
             ( "WindowIdentities"
             , MaintenanceWindowIdentityList.to_json v.window_identities )
         ])

  let of_json j =
    { window_identities =
        MaintenanceWindowIdentityList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowIdentities"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module ResourceTypeForTagging = struct
  type t =
    | Document
    | ManagedInstance
    | MaintenanceWindow
    | Parameter
    | PatchBaseline
    | OpsItem

  let str_to_t =
    [ "OpsItem", OpsItem
    ; "PatchBaseline", PatchBaseline
    ; "Parameter", Parameter
    ; "MaintenanceWindow", MaintenanceWindow
    ; "ManagedInstance", ManagedInstance
    ; "Document", Document
    ]

  let t_to_str =
    [ OpsItem, "OpsItem"
    ; PatchBaseline, "PatchBaseline"
    ; Parameter, "Parameter"
    ; MaintenanceWindow, "MaintenanceWindow"
    ; ManagedInstance, "ManagedInstance"
    ; Document, "Document"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module AddTagsToResourceRequest = struct
  type t =
    { resource_type : ResourceTypeForTagging.t
    ; resource_id : String.t
    ; tags : TagList.t
    }

  let make ~resource_type ~resource_id ~tags () = { resource_type; resource_id; tags }

  let parse xml =
    Some
      { resource_type =
          Aws.Xml.required
            "ResourceType"
            (Aws.Util.option_bind
               (Aws.Xml.member "ResourceType" xml)
               ResourceTypeForTagging.parse)
      ; resource_id =
          Aws.Xml.required
            "ResourceId"
            (Aws.Util.option_bind (Aws.Xml.member "ResourceId" xml) String.parse)
      ; tags =
          Aws.Xml.required
            "Tags"
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Some (Aws.Query.Pair ("ResourceId", String.to_query v.resource_id))
         ; Some
             (Aws.Query.Pair
                ("ResourceType", ResourceTypeForTagging.to_query v.resource_type))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tags", TagList.to_json v.tags)
         ; Some ("ResourceId", String.to_json v.resource_id)
         ; Some ("ResourceType", ResourceTypeForTagging.to_json v.resource_type)
         ])

  let of_json j =
    { resource_type =
        ResourceTypeForTagging.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ResourceType"))
    ; resource_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ResourceId"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    }
end

module PatchComplianceDataState = struct
  type t =
    | INSTALLED
    | INSTALLED_OTHER
    | INSTALLED_PENDING_REBOOT
    | INSTALLED_REJECTED
    | MISSING
    | NOT_APPLICABLE
    | FAILED

  let str_to_t =
    [ "FAILED", FAILED
    ; "NOT_APPLICABLE", NOT_APPLICABLE
    ; "MISSING", MISSING
    ; "INSTALLED_REJECTED", INSTALLED_REJECTED
    ; "INSTALLED_PENDING_REBOOT", INSTALLED_PENDING_REBOOT
    ; "INSTALLED_OTHER", INSTALLED_OTHER
    ; "INSTALLED", INSTALLED
    ]

  let t_to_str =
    [ FAILED, "FAILED"
    ; NOT_APPLICABLE, "NOT_APPLICABLE"
    ; MISSING, "MISSING"
    ; INSTALLED_REJECTED, "INSTALLED_REJECTED"
    ; INSTALLED_PENDING_REBOOT, "INSTALLED_PENDING_REBOOT"
    ; INSTALLED_OTHER, "INSTALLED_OTHER"
    ; INSTALLED, "INSTALLED"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module PatchComplianceData = struct
  type t =
    { title : String.t
    ; k_b_id : String.t
    ; classification : String.t
    ; severity : String.t
    ; state : PatchComplianceDataState.t
    ; installed_time : DateTime.t
    ; c_v_e_ids : String.t option
    }

  let make ~title ~k_b_id ~classification ~severity ~state ~installed_time ?c_v_e_ids () =
    { title; k_b_id; classification; severity; state; installed_time; c_v_e_ids }

  let parse xml =
    Some
      { title =
          Aws.Xml.required
            "Title"
            (Aws.Util.option_bind (Aws.Xml.member "Title" xml) String.parse)
      ; k_b_id =
          Aws.Xml.required
            "KBId"
            (Aws.Util.option_bind (Aws.Xml.member "KBId" xml) String.parse)
      ; classification =
          Aws.Xml.required
            "Classification"
            (Aws.Util.option_bind (Aws.Xml.member "Classification" xml) String.parse)
      ; severity =
          Aws.Xml.required
            "Severity"
            (Aws.Util.option_bind (Aws.Xml.member "Severity" xml) String.parse)
      ; state =
          Aws.Xml.required
            "State"
            (Aws.Util.option_bind
               (Aws.Xml.member "State" xml)
               PatchComplianceDataState.parse)
      ; installed_time =
          Aws.Xml.required
            "InstalledTime"
            (Aws.Util.option_bind (Aws.Xml.member "InstalledTime" xml) DateTime.parse)
      ; c_v_e_ids = Aws.Util.option_bind (Aws.Xml.member "CVEIds" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.c_v_e_ids (fun f ->
               Aws.Query.Pair ("CVEIds", String.to_query f))
         ; Some (Aws.Query.Pair ("InstalledTime", DateTime.to_query v.installed_time))
         ; Some (Aws.Query.Pair ("State", PatchComplianceDataState.to_query v.state))
         ; Some (Aws.Query.Pair ("Severity", String.to_query v.severity))
         ; Some (Aws.Query.Pair ("Classification", String.to_query v.classification))
         ; Some (Aws.Query.Pair ("KBId", String.to_query v.k_b_id))
         ; Some (Aws.Query.Pair ("Title", String.to_query v.title))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.c_v_e_ids (fun f -> "CVEIds", String.to_json f)
         ; Some ("InstalledTime", DateTime.to_json v.installed_time)
         ; Some ("State", PatchComplianceDataState.to_json v.state)
         ; Some ("Severity", String.to_json v.severity)
         ; Some ("Classification", String.to_json v.classification)
         ; Some ("KBId", String.to_json v.k_b_id)
         ; Some ("Title", String.to_json v.title)
         ])

  let of_json j =
    { title = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Title"))
    ; k_b_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "KBId"))
    ; classification =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Classification"))
    ; severity = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Severity"))
    ; state =
        PatchComplianceDataState.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "State"))
    ; installed_time =
        DateTime.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstalledTime"))
    ; c_v_e_ids = Aws.Util.option_map (Aws.Json.lookup j "CVEIds") String.of_json
    }
end

module ServiceSettingNotFound = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module ParameterMetadata = struct
  type t =
    { name : String.t option
    ; type_ : ParameterType.t option
    ; key_id : String.t option
    ; last_modified_date : DateTime.t option
    ; last_modified_user : String.t option
    ; description : String.t option
    ; allowed_pattern : String.t option
    ; version : Long.t option
    ; tier : ParameterTier.t option
    ; policies : ParameterPolicyList.t
    ; data_type : String.t option
    }

  let make
      ?name
      ?type_
      ?key_id
      ?last_modified_date
      ?last_modified_user
      ?description
      ?allowed_pattern
      ?version
      ?tier
      ?(policies = [])
      ?data_type
      () =
    { name
    ; type_
    ; key_id
    ; last_modified_date
    ; last_modified_user
    ; description
    ; allowed_pattern
    ; version
    ; tier
    ; policies
    ; data_type
    }

  let parse xml =
    Some
      { name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; type_ = Aws.Util.option_bind (Aws.Xml.member "Type" xml) ParameterType.parse
      ; key_id = Aws.Util.option_bind (Aws.Xml.member "KeyId" xml) String.parse
      ; last_modified_date =
          Aws.Util.option_bind (Aws.Xml.member "LastModifiedDate" xml) DateTime.parse
      ; last_modified_user =
          Aws.Util.option_bind (Aws.Xml.member "LastModifiedUser" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; allowed_pattern =
          Aws.Util.option_bind (Aws.Xml.member "AllowedPattern" xml) String.parse
      ; version = Aws.Util.option_bind (Aws.Xml.member "Version" xml) Long.parse
      ; tier = Aws.Util.option_bind (Aws.Xml.member "Tier" xml) ParameterTier.parse
      ; policies =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Policies" xml)
               ParameterPolicyList.parse)
      ; data_type = Aws.Util.option_bind (Aws.Xml.member "DataType" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.data_type (fun f ->
               Aws.Query.Pair ("DataType", String.to_query f))
         ; Some
             (Aws.Query.Pair ("Policies.member", ParameterPolicyList.to_query v.policies))
         ; Aws.Util.option_map v.tier (fun f ->
               Aws.Query.Pair ("Tier", ParameterTier.to_query f))
         ; Aws.Util.option_map v.version (fun f ->
               Aws.Query.Pair ("Version", Long.to_query f))
         ; Aws.Util.option_map v.allowed_pattern (fun f ->
               Aws.Query.Pair ("AllowedPattern", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.last_modified_user (fun f ->
               Aws.Query.Pair ("LastModifiedUser", String.to_query f))
         ; Aws.Util.option_map v.last_modified_date (fun f ->
               Aws.Query.Pair ("LastModifiedDate", DateTime.to_query f))
         ; Aws.Util.option_map v.key_id (fun f ->
               Aws.Query.Pair ("KeyId", String.to_query f))
         ; Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", ParameterType.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.data_type (fun f -> "DataType", String.to_json f)
         ; Some ("Policies", ParameterPolicyList.to_json v.policies)
         ; Aws.Util.option_map v.tier (fun f -> "Tier", ParameterTier.to_json f)
         ; Aws.Util.option_map v.version (fun f -> "Version", Long.to_json f)
         ; Aws.Util.option_map v.allowed_pattern (fun f ->
               "AllowedPattern", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.last_modified_user (fun f ->
               "LastModifiedUser", String.to_json f)
         ; Aws.Util.option_map v.last_modified_date (fun f ->
               "LastModifiedDate", DateTime.to_json f)
         ; Aws.Util.option_map v.key_id (fun f -> "KeyId", String.to_json f)
         ; Aws.Util.option_map v.type_ (fun f -> "Type", ParameterType.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ])

  let of_json j =
    { name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; type_ = Aws.Util.option_map (Aws.Json.lookup j "Type") ParameterType.of_json
    ; key_id = Aws.Util.option_map (Aws.Json.lookup j "KeyId") String.of_json
    ; last_modified_date =
        Aws.Util.option_map (Aws.Json.lookup j "LastModifiedDate") DateTime.of_json
    ; last_modified_user =
        Aws.Util.option_map (Aws.Json.lookup j "LastModifiedUser") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; allowed_pattern =
        Aws.Util.option_map (Aws.Json.lookup j "AllowedPattern") String.of_json
    ; version = Aws.Util.option_map (Aws.Json.lookup j "Version") Long.of_json
    ; tier = Aws.Util.option_map (Aws.Json.lookup j "Tier") ParameterTier.of_json
    ; policies =
        ParameterPolicyList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Policies"))
    ; data_type = Aws.Util.option_map (Aws.Json.lookup j "DataType") String.of_json
    }
end

module SeveritySummary = struct
  type t =
    { critical_count : Integer.t option
    ; high_count : Integer.t option
    ; medium_count : Integer.t option
    ; low_count : Integer.t option
    ; informational_count : Integer.t option
    ; unspecified_count : Integer.t option
    }

  let make
      ?critical_count
      ?high_count
      ?medium_count
      ?low_count
      ?informational_count
      ?unspecified_count
      () =
    { critical_count
    ; high_count
    ; medium_count
    ; low_count
    ; informational_count
    ; unspecified_count
    }

  let parse xml =
    Some
      { critical_count =
          Aws.Util.option_bind (Aws.Xml.member "CriticalCount" xml) Integer.parse
      ; high_count = Aws.Util.option_bind (Aws.Xml.member "HighCount" xml) Integer.parse
      ; medium_count =
          Aws.Util.option_bind (Aws.Xml.member "MediumCount" xml) Integer.parse
      ; low_count = Aws.Util.option_bind (Aws.Xml.member "LowCount" xml) Integer.parse
      ; informational_count =
          Aws.Util.option_bind (Aws.Xml.member "InformationalCount" xml) Integer.parse
      ; unspecified_count =
          Aws.Util.option_bind (Aws.Xml.member "UnspecifiedCount" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.unspecified_count (fun f ->
               Aws.Query.Pair ("UnspecifiedCount", Integer.to_query f))
         ; Aws.Util.option_map v.informational_count (fun f ->
               Aws.Query.Pair ("InformationalCount", Integer.to_query f))
         ; Aws.Util.option_map v.low_count (fun f ->
               Aws.Query.Pair ("LowCount", Integer.to_query f))
         ; Aws.Util.option_map v.medium_count (fun f ->
               Aws.Query.Pair ("MediumCount", Integer.to_query f))
         ; Aws.Util.option_map v.high_count (fun f ->
               Aws.Query.Pair ("HighCount", Integer.to_query f))
         ; Aws.Util.option_map v.critical_count (fun f ->
               Aws.Query.Pair ("CriticalCount", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.unspecified_count (fun f ->
               "UnspecifiedCount", Integer.to_json f)
         ; Aws.Util.option_map v.informational_count (fun f ->
               "InformationalCount", Integer.to_json f)
         ; Aws.Util.option_map v.low_count (fun f -> "LowCount", Integer.to_json f)
         ; Aws.Util.option_map v.medium_count (fun f -> "MediumCount", Integer.to_json f)
         ; Aws.Util.option_map v.high_count (fun f -> "HighCount", Integer.to_json f)
         ; Aws.Util.option_map v.critical_count (fun f ->
               "CriticalCount", Integer.to_json f)
         ])

  let of_json j =
    { critical_count =
        Aws.Util.option_map (Aws.Json.lookup j "CriticalCount") Integer.of_json
    ; high_count = Aws.Util.option_map (Aws.Json.lookup j "HighCount") Integer.of_json
    ; medium_count = Aws.Util.option_map (Aws.Json.lookup j "MediumCount") Integer.of_json
    ; low_count = Aws.Util.option_map (Aws.Json.lookup j "LowCount") Integer.of_json
    ; informational_count =
        Aws.Util.option_map (Aws.Json.lookup j "InformationalCount") Integer.of_json
    ; unspecified_count =
        Aws.Util.option_map (Aws.Json.lookup j "UnspecifiedCount") Integer.of_json
    }
end

module NonCompliantSummary = struct
  type t =
    { non_compliant_count : Integer.t option
    ; severity_summary : SeveritySummary.t option
    }

  let make ?non_compliant_count ?severity_summary () =
    { non_compliant_count; severity_summary }

  let parse xml =
    Some
      { non_compliant_count =
          Aws.Util.option_bind (Aws.Xml.member "NonCompliantCount" xml) Integer.parse
      ; severity_summary =
          Aws.Util.option_bind
            (Aws.Xml.member "SeveritySummary" xml)
            SeveritySummary.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.severity_summary (fun f ->
               Aws.Query.Pair ("SeveritySummary", SeveritySummary.to_query f))
         ; Aws.Util.option_map v.non_compliant_count (fun f ->
               Aws.Query.Pair ("NonCompliantCount", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.severity_summary (fun f ->
               "SeveritySummary", SeveritySummary.to_json f)
         ; Aws.Util.option_map v.non_compliant_count (fun f ->
               "NonCompliantCount", Integer.to_json f)
         ])

  let of_json j =
    { non_compliant_count =
        Aws.Util.option_map (Aws.Json.lookup j "NonCompliantCount") Integer.of_json
    ; severity_summary =
        Aws.Util.option_map (Aws.Json.lookup j "SeveritySummary") SeveritySummary.of_json
    }
end

module CompliantSummary = struct
  type t =
    { compliant_count : Integer.t option
    ; severity_summary : SeveritySummary.t option
    }

  let make ?compliant_count ?severity_summary () = { compliant_count; severity_summary }

  let parse xml =
    Some
      { compliant_count =
          Aws.Util.option_bind (Aws.Xml.member "CompliantCount" xml) Integer.parse
      ; severity_summary =
          Aws.Util.option_bind
            (Aws.Xml.member "SeveritySummary" xml)
            SeveritySummary.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.severity_summary (fun f ->
               Aws.Query.Pair ("SeveritySummary", SeveritySummary.to_query f))
         ; Aws.Util.option_map v.compliant_count (fun f ->
               Aws.Query.Pair ("CompliantCount", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.severity_summary (fun f ->
               "SeveritySummary", SeveritySummary.to_json f)
         ; Aws.Util.option_map v.compliant_count (fun f ->
               "CompliantCount", Integer.to_json f)
         ])

  let of_json j =
    { compliant_count =
        Aws.Util.option_map (Aws.Json.lookup j "CompliantCount") Integer.of_json
    ; severity_summary =
        Aws.Util.option_map (Aws.Json.lookup j "SeveritySummary") SeveritySummary.of_json
    }
end

module ResourceComplianceSummaryItem = struct
  type t =
    { compliance_type : String.t option
    ; resource_type : String.t option
    ; resource_id : String.t option
    ; status : ComplianceStatus.t option
    ; overall_severity : ComplianceSeverity.t option
    ; execution_summary : ComplianceExecutionSummary.t option
    ; compliant_summary : CompliantSummary.t option
    ; non_compliant_summary : NonCompliantSummary.t option
    }

  let make
      ?compliance_type
      ?resource_type
      ?resource_id
      ?status
      ?overall_severity
      ?execution_summary
      ?compliant_summary
      ?non_compliant_summary
      () =
    { compliance_type
    ; resource_type
    ; resource_id
    ; status
    ; overall_severity
    ; execution_summary
    ; compliant_summary
    ; non_compliant_summary
    }

  let parse xml =
    Some
      { compliance_type =
          Aws.Util.option_bind (Aws.Xml.member "ComplianceType" xml) String.parse
      ; resource_type =
          Aws.Util.option_bind (Aws.Xml.member "ResourceType" xml) String.parse
      ; resource_id = Aws.Util.option_bind (Aws.Xml.member "ResourceId" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) ComplianceStatus.parse
      ; overall_severity =
          Aws.Util.option_bind
            (Aws.Xml.member "OverallSeverity" xml)
            ComplianceSeverity.parse
      ; execution_summary =
          Aws.Util.option_bind
            (Aws.Xml.member "ExecutionSummary" xml)
            ComplianceExecutionSummary.parse
      ; compliant_summary =
          Aws.Util.option_bind
            (Aws.Xml.member "CompliantSummary" xml)
            CompliantSummary.parse
      ; non_compliant_summary =
          Aws.Util.option_bind
            (Aws.Xml.member "NonCompliantSummary" xml)
            NonCompliantSummary.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.non_compliant_summary (fun f ->
               Aws.Query.Pair ("NonCompliantSummary", NonCompliantSummary.to_query f))
         ; Aws.Util.option_map v.compliant_summary (fun f ->
               Aws.Query.Pair ("CompliantSummary", CompliantSummary.to_query f))
         ; Aws.Util.option_map v.execution_summary (fun f ->
               Aws.Query.Pair ("ExecutionSummary", ComplianceExecutionSummary.to_query f))
         ; Aws.Util.option_map v.overall_severity (fun f ->
               Aws.Query.Pair ("OverallSeverity", ComplianceSeverity.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", ComplianceStatus.to_query f))
         ; Aws.Util.option_map v.resource_id (fun f ->
               Aws.Query.Pair ("ResourceId", String.to_query f))
         ; Aws.Util.option_map v.resource_type (fun f ->
               Aws.Query.Pair ("ResourceType", String.to_query f))
         ; Aws.Util.option_map v.compliance_type (fun f ->
               Aws.Query.Pair ("ComplianceType", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.non_compliant_summary (fun f ->
               "NonCompliantSummary", NonCompliantSummary.to_json f)
         ; Aws.Util.option_map v.compliant_summary (fun f ->
               "CompliantSummary", CompliantSummary.to_json f)
         ; Aws.Util.option_map v.execution_summary (fun f ->
               "ExecutionSummary", ComplianceExecutionSummary.to_json f)
         ; Aws.Util.option_map v.overall_severity (fun f ->
               "OverallSeverity", ComplianceSeverity.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", ComplianceStatus.to_json f)
         ; Aws.Util.option_map v.resource_id (fun f -> "ResourceId", String.to_json f)
         ; Aws.Util.option_map v.resource_type (fun f -> "ResourceType", String.to_json f)
         ; Aws.Util.option_map v.compliance_type (fun f ->
               "ComplianceType", String.to_json f)
         ])

  let of_json j =
    { compliance_type =
        Aws.Util.option_map (Aws.Json.lookup j "ComplianceType") String.of_json
    ; resource_type =
        Aws.Util.option_map (Aws.Json.lookup j "ResourceType") String.of_json
    ; resource_id = Aws.Util.option_map (Aws.Json.lookup j "ResourceId") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") ComplianceStatus.of_json
    ; overall_severity =
        Aws.Util.option_map
          (Aws.Json.lookup j "OverallSeverity")
          ComplianceSeverity.of_json
    ; execution_summary =
        Aws.Util.option_map
          (Aws.Json.lookup j "ExecutionSummary")
          ComplianceExecutionSummary.of_json
    ; compliant_summary =
        Aws.Util.option_map
          (Aws.Json.lookup j "CompliantSummary")
          CompliantSummary.of_json
    ; non_compliant_summary =
        Aws.Util.option_map
          (Aws.Json.lookup j "NonCompliantSummary")
          NonCompliantSummary.of_json
    }
end

module ResourceComplianceSummaryItemList = struct
  type t = ResourceComplianceSummaryItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ResourceComplianceSummaryItem.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list ResourceComplianceSummaryItem.to_query v
  let to_json v = `List (List.map ResourceComplianceSummaryItem.to_json v)
  let of_json j = Aws.Json.to_list ResourceComplianceSummaryItem.of_json j
end

module MaintenanceWindowExecutionTaskIdentity = struct
  type t =
    { window_execution_id : String.t option
    ; task_execution_id : String.t option
    ; status : MaintenanceWindowExecutionStatus.t option
    ; status_details : String.t option
    ; start_time : DateTime.t option
    ; end_time : DateTime.t option
    ; task_arn : String.t option
    ; task_type : MaintenanceWindowTaskType.t option
    }

  let make
      ?window_execution_id
      ?task_execution_id
      ?status
      ?status_details
      ?start_time
      ?end_time
      ?task_arn
      ?task_type
      () =
    { window_execution_id
    ; task_execution_id
    ; status
    ; status_details
    ; start_time
    ; end_time
    ; task_arn
    ; task_type
    }

  let parse xml =
    Some
      { window_execution_id =
          Aws.Util.option_bind (Aws.Xml.member "WindowExecutionId" xml) String.parse
      ; task_execution_id =
          Aws.Util.option_bind (Aws.Xml.member "TaskExecutionId" xml) String.parse
      ; status =
          Aws.Util.option_bind
            (Aws.Xml.member "Status" xml)
            MaintenanceWindowExecutionStatus.parse
      ; status_details =
          Aws.Util.option_bind (Aws.Xml.member "StatusDetails" xml) String.parse
      ; start_time = Aws.Util.option_bind (Aws.Xml.member "StartTime" xml) DateTime.parse
      ; end_time = Aws.Util.option_bind (Aws.Xml.member "EndTime" xml) DateTime.parse
      ; task_arn = Aws.Util.option_bind (Aws.Xml.member "TaskArn" xml) String.parse
      ; task_type =
          Aws.Util.option_bind
            (Aws.Xml.member "TaskType" xml)
            MaintenanceWindowTaskType.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.task_type (fun f ->
               Aws.Query.Pair ("TaskType", MaintenanceWindowTaskType.to_query f))
         ; Aws.Util.option_map v.task_arn (fun f ->
               Aws.Query.Pair ("TaskArn", String.to_query f))
         ; Aws.Util.option_map v.end_time (fun f ->
               Aws.Query.Pair ("EndTime", DateTime.to_query f))
         ; Aws.Util.option_map v.start_time (fun f ->
               Aws.Query.Pair ("StartTime", DateTime.to_query f))
         ; Aws.Util.option_map v.status_details (fun f ->
               Aws.Query.Pair ("StatusDetails", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", MaintenanceWindowExecutionStatus.to_query f))
         ; Aws.Util.option_map v.task_execution_id (fun f ->
               Aws.Query.Pair ("TaskExecutionId", String.to_query f))
         ; Aws.Util.option_map v.window_execution_id (fun f ->
               Aws.Query.Pair ("WindowExecutionId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.task_type (fun f ->
               "TaskType", MaintenanceWindowTaskType.to_json f)
         ; Aws.Util.option_map v.task_arn (fun f -> "TaskArn", String.to_json f)
         ; Aws.Util.option_map v.end_time (fun f -> "EndTime", DateTime.to_json f)
         ; Aws.Util.option_map v.start_time (fun f -> "StartTime", DateTime.to_json f)
         ; Aws.Util.option_map v.status_details (fun f ->
               "StatusDetails", String.to_json f)
         ; Aws.Util.option_map v.status (fun f ->
               "Status", MaintenanceWindowExecutionStatus.to_json f)
         ; Aws.Util.option_map v.task_execution_id (fun f ->
               "TaskExecutionId", String.to_json f)
         ; Aws.Util.option_map v.window_execution_id (fun f ->
               "WindowExecutionId", String.to_json f)
         ])

  let of_json j =
    { window_execution_id =
        Aws.Util.option_map (Aws.Json.lookup j "WindowExecutionId") String.of_json
    ; task_execution_id =
        Aws.Util.option_map (Aws.Json.lookup j "TaskExecutionId") String.of_json
    ; status =
        Aws.Util.option_map
          (Aws.Json.lookup j "Status")
          MaintenanceWindowExecutionStatus.of_json
    ; status_details =
        Aws.Util.option_map (Aws.Json.lookup j "StatusDetails") String.of_json
    ; start_time = Aws.Util.option_map (Aws.Json.lookup j "StartTime") DateTime.of_json
    ; end_time = Aws.Util.option_map (Aws.Json.lookup j "EndTime") DateTime.of_json
    ; task_arn = Aws.Util.option_map (Aws.Json.lookup j "TaskArn") String.of_json
    ; task_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "TaskType")
          MaintenanceWindowTaskType.of_json
    }
end

module MaintenanceWindowExecutionTaskIdentityList = struct
  type t = MaintenanceWindowExecutionTaskIdentity.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         MaintenanceWindowExecutionTaskIdentity.parse
         (Aws.Xml.members "member" xml))

  let to_query v =
    Aws.Query.to_query_list MaintenanceWindowExecutionTaskIdentity.to_query v

  let to_json v = `List (List.map MaintenanceWindowExecutionTaskIdentity.to_json v)
  let of_json j = Aws.Json.to_list MaintenanceWindowExecutionTaskIdentity.of_json j
end

module DescribeMaintenanceWindowExecutionTasksResult = struct
  type t =
    { window_execution_task_identities : MaintenanceWindowExecutionTaskIdentityList.t
    ; next_token : String.t option
    }

  let make ?(window_execution_task_identities = []) ?next_token () =
    { window_execution_task_identities; next_token }

  let parse xml =
    Some
      { window_execution_task_identities =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "WindowExecutionTaskIdentities" xml)
               MaintenanceWindowExecutionTaskIdentityList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "WindowExecutionTaskIdentities.member"
                , MaintenanceWindowExecutionTaskIdentityList.to_query
                    v.window_execution_task_identities ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some
             ( "WindowExecutionTaskIdentities"
             , MaintenanceWindowExecutionTaskIdentityList.to_json
                 v.window_execution_task_identities )
         ])

  let of_json j =
    { window_execution_task_identities =
        MaintenanceWindowExecutionTaskIdentityList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowExecutionTaskIdentities"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module GetInventorySchemaResult = struct
  type t =
    { schemas : InventoryItemSchemaResultList.t
    ; next_token : String.t option
    }

  let make ?(schemas = []) ?next_token () = { schemas; next_token }

  let parse xml =
    Some
      { schemas =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Schemas" xml)
               InventoryItemSchemaResultList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Schemas.member", InventoryItemSchemaResultList.to_query v.schemas))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Schemas", InventoryItemSchemaResultList.to_json v.schemas)
         ])

  let of_json j =
    { schemas =
        InventoryItemSchemaResultList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Schemas"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module InstanceAssociationOutputUrl = struct
  type t = { s3_output_url : S3OutputUrl.t option }

  let make ?s3_output_url () = { s3_output_url }

  let parse xml =
    Some
      { s3_output_url =
          Aws.Util.option_bind (Aws.Xml.member "S3OutputUrl" xml) S3OutputUrl.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.s3_output_url (fun f ->
               Aws.Query.Pair ("S3OutputUrl", S3OutputUrl.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.s3_output_url (fun f ->
               "S3OutputUrl", S3OutputUrl.to_json f)
         ])

  let of_json j =
    { s3_output_url =
        Aws.Util.option_map (Aws.Json.lookup j "S3OutputUrl") S3OutputUrl.of_json
    }
end

module InstanceAssociationStatusInfo = struct
  type t =
    { association_id : String.t option
    ; name : String.t option
    ; document_version : String.t option
    ; association_version : String.t option
    ; instance_id : String.t option
    ; execution_date : DateTime.t option
    ; status : String.t option
    ; detailed_status : String.t option
    ; execution_summary : String.t option
    ; error_code : String.t option
    ; output_url : InstanceAssociationOutputUrl.t option
    ; association_name : String.t option
    }

  let make
      ?association_id
      ?name
      ?document_version
      ?association_version
      ?instance_id
      ?execution_date
      ?status
      ?detailed_status
      ?execution_summary
      ?error_code
      ?output_url
      ?association_name
      () =
    { association_id
    ; name
    ; document_version
    ; association_version
    ; instance_id
    ; execution_date
    ; status
    ; detailed_status
    ; execution_summary
    ; error_code
    ; output_url
    ; association_name
    }

  let parse xml =
    Some
      { association_id =
          Aws.Util.option_bind (Aws.Xml.member "AssociationId" xml) String.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; document_version =
          Aws.Util.option_bind (Aws.Xml.member "DocumentVersion" xml) String.parse
      ; association_version =
          Aws.Util.option_bind (Aws.Xml.member "AssociationVersion" xml) String.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse
      ; execution_date =
          Aws.Util.option_bind (Aws.Xml.member "ExecutionDate" xml) DateTime.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      ; detailed_status =
          Aws.Util.option_bind (Aws.Xml.member "DetailedStatus" xml) String.parse
      ; execution_summary =
          Aws.Util.option_bind (Aws.Xml.member "ExecutionSummary" xml) String.parse
      ; error_code = Aws.Util.option_bind (Aws.Xml.member "ErrorCode" xml) String.parse
      ; output_url =
          Aws.Util.option_bind
            (Aws.Xml.member "OutputUrl" xml)
            InstanceAssociationOutputUrl.parse
      ; association_name =
          Aws.Util.option_bind (Aws.Xml.member "AssociationName" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_name (fun f ->
               Aws.Query.Pair ("AssociationName", String.to_query f))
         ; Aws.Util.option_map v.output_url (fun f ->
               Aws.Query.Pair ("OutputUrl", InstanceAssociationOutputUrl.to_query f))
         ; Aws.Util.option_map v.error_code (fun f ->
               Aws.Query.Pair ("ErrorCode", String.to_query f))
         ; Aws.Util.option_map v.execution_summary (fun f ->
               Aws.Query.Pair ("ExecutionSummary", String.to_query f))
         ; Aws.Util.option_map v.detailed_status (fun f ->
               Aws.Query.Pair ("DetailedStatus", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.execution_date (fun f ->
               Aws.Query.Pair ("ExecutionDate", DateTime.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.association_version (fun f ->
               Aws.Query.Pair ("AssociationVersion", String.to_query f))
         ; Aws.Util.option_map v.document_version (fun f ->
               Aws.Query.Pair ("DocumentVersion", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.association_id (fun f ->
               Aws.Query.Pair ("AssociationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_name (fun f ->
               "AssociationName", String.to_json f)
         ; Aws.Util.option_map v.output_url (fun f ->
               "OutputUrl", InstanceAssociationOutputUrl.to_json f)
         ; Aws.Util.option_map v.error_code (fun f -> "ErrorCode", String.to_json f)
         ; Aws.Util.option_map v.execution_summary (fun f ->
               "ExecutionSummary", String.to_json f)
         ; Aws.Util.option_map v.detailed_status (fun f ->
               "DetailedStatus", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ; Aws.Util.option_map v.execution_date (fun f ->
               "ExecutionDate", DateTime.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "InstanceId", String.to_json f)
         ; Aws.Util.option_map v.association_version (fun f ->
               "AssociationVersion", String.to_json f)
         ; Aws.Util.option_map v.document_version (fun f ->
               "DocumentVersion", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.association_id (fun f ->
               "AssociationId", String.to_json f)
         ])

  let of_json j =
    { association_id =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationId") String.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; document_version =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentVersion") String.of_json
    ; association_version =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationVersion") String.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "InstanceId") String.of_json
    ; execution_date =
        Aws.Util.option_map (Aws.Json.lookup j "ExecutionDate") DateTime.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    ; detailed_status =
        Aws.Util.option_map (Aws.Json.lookup j "DetailedStatus") String.of_json
    ; execution_summary =
        Aws.Util.option_map (Aws.Json.lookup j "ExecutionSummary") String.of_json
    ; error_code = Aws.Util.option_map (Aws.Json.lookup j "ErrorCode") String.of_json
    ; output_url =
        Aws.Util.option_map
          (Aws.Json.lookup j "OutputUrl")
          InstanceAssociationOutputUrl.of_json
    ; association_name =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationName") String.of_json
    }
end

module InstanceAssociationStatusInfos = struct
  type t = InstanceAssociationStatusInfo.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map InstanceAssociationStatusInfo.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list InstanceAssociationStatusInfo.to_query v
  let to_json v = `List (List.map InstanceAssociationStatusInfo.to_json v)
  let of_json j = Aws.Json.to_list InstanceAssociationStatusInfo.of_json j
end

module DescribeInstanceAssociationsStatusResult = struct
  type t =
    { instance_association_status_infos : InstanceAssociationStatusInfos.t
    ; next_token : String.t option
    }

  let make ?(instance_association_status_infos = []) ?next_token () =
    { instance_association_status_infos; next_token }

  let parse xml =
    Some
      { instance_association_status_infos =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "InstanceAssociationStatusInfos" xml)
               InstanceAssociationStatusInfos.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "InstanceAssociationStatusInfos.member"
                , InstanceAssociationStatusInfos.to_query
                    v.instance_association_status_infos ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some
             ( "InstanceAssociationStatusInfos"
             , InstanceAssociationStatusInfos.to_json v.instance_association_status_infos
             )
         ])

  let of_json j =
    { instance_association_status_infos =
        InstanceAssociationStatusInfos.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceAssociationStatusInfos"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module SessionState = struct
  type t =
    | Active
    | History

  let str_to_t = [ "History", History; "Active", Active ]
  let t_to_str = [ History, "History"; Active, "Active" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DescribeSessionsRequest = struct
  type t =
    { state : SessionState.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; filters : SessionFilterList.t
    }

  let make ~state ?max_results ?next_token ?(filters = []) () =
    { state; max_results; next_token; filters }

  let parse xml =
    Some
      { state =
          Aws.Xml.required
            "State"
            (Aws.Util.option_bind (Aws.Xml.member "State" xml) SessionState.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) SessionFilterList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Filters.member", SessionFilterList.to_query v.filters))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("State", SessionState.to_query v.state))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Filters", SessionFilterList.to_json v.filters)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("State", SessionState.to_json v.state)
         ])

  let of_json j =
    { state = SessionState.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "State"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; filters =
        SessionFilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    }
end

module DescribeDocumentPermissionRequest = struct
  type t =
    { name : String.t
    ; permission_type : DocumentPermissionType.t
    }

  let make ~name ~permission_type () = { name; permission_type }

  let parse xml =
    Some
      { name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      ; permission_type =
          Aws.Xml.required
            "PermissionType"
            (Aws.Util.option_bind
               (Aws.Xml.member "PermissionType" xml)
               DocumentPermissionType.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("PermissionType", DocumentPermissionType.to_query v.permission_type))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("PermissionType", DocumentPermissionType.to_json v.permission_type)
         ; Some ("Name", String.to_json v.name)
         ])

  let of_json j =
    { name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; permission_type =
        DocumentPermissionType.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "PermissionType"))
    }
end

module UnsupportedPlatformType = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module DescribeInventoryDeletionsResult = struct
  type t =
    { inventory_deletions : InventoryDeletionsList.t
    ; next_token : String.t option
    }

  let make ?(inventory_deletions = []) ?next_token () =
    { inventory_deletions; next_token }

  let parse xml =
    Some
      { inventory_deletions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "InventoryDeletions" xml)
               InventoryDeletionsList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "InventoryDeletions.member"
                , InventoryDeletionsList.to_query v.inventory_deletions ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some
             ("InventoryDeletions", InventoryDeletionsList.to_json v.inventory_deletions)
         ])

  let of_json j =
    { inventory_deletions =
        InventoryDeletionsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InventoryDeletions"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module ParameterNotFound = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json }
end

module GetDocumentRequest = struct
  type t =
    { name : String.t
    ; version_name : String.t option
    ; document_version : String.t option
    ; document_format : DocumentFormat.t option
    }

  let make ~name ?version_name ?document_version ?document_format () =
    { name; version_name; document_version; document_format }

  let parse xml =
    Some
      { name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      ; version_name =
          Aws.Util.option_bind (Aws.Xml.member "VersionName" xml) String.parse
      ; document_version =
          Aws.Util.option_bind (Aws.Xml.member "DocumentVersion" xml) String.parse
      ; document_format =
          Aws.Util.option_bind (Aws.Xml.member "DocumentFormat" xml) DocumentFormat.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.document_format (fun f ->
               Aws.Query.Pair ("DocumentFormat", DocumentFormat.to_query f))
         ; Aws.Util.option_map v.document_version (fun f ->
               Aws.Query.Pair ("DocumentVersion", String.to_query f))
         ; Aws.Util.option_map v.version_name (fun f ->
               Aws.Query.Pair ("VersionName", String.to_query f))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.document_format (fun f ->
               "DocumentFormat", DocumentFormat.to_json f)
         ; Aws.Util.option_map v.document_version (fun f ->
               "DocumentVersion", String.to_json f)
         ; Aws.Util.option_map v.version_name (fun f -> "VersionName", String.to_json f)
         ; Some ("Name", String.to_json v.name)
         ])

  let of_json j =
    { name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; version_name = Aws.Util.option_map (Aws.Json.lookup j "VersionName") String.of_json
    ; document_version =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentVersion") String.of_json
    ; document_format =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentFormat") DocumentFormat.of_json
    }
end

module TargetParameterList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module ResolvedTargets = struct
  type t =
    { parameter_values : TargetParameterList.t
    ; truncated : Boolean.t option
    }

  let make ?(parameter_values = []) ?truncated () = { parameter_values; truncated }

  let parse xml =
    Some
      { parameter_values =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ParameterValues" xml)
               TargetParameterList.parse)
      ; truncated = Aws.Util.option_bind (Aws.Xml.member "Truncated" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.truncated (fun f ->
               Aws.Query.Pair ("Truncated", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ParameterValues.member", TargetParameterList.to_query v.parameter_values))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.truncated (fun f -> "Truncated", Boolean.to_json f)
         ; Some ("ParameterValues", TargetParameterList.to_json v.parameter_values)
         ])

  let of_json j =
    { parameter_values =
        TargetParameterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ParameterValues"))
    ; truncated = Aws.Util.option_map (Aws.Json.lookup j "Truncated") Boolean.of_json
    }
end

module InvalidFilter = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module DocumentLimitExceeded = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module DescribeMaintenanceWindowTasksRequest = struct
  type t =
    { window_id : String.t
    ; filters : MaintenanceWindowFilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ~window_id ?(filters = []) ?max_results ?next_token () =
    { window_id; filters; max_results; next_token }

  let parse xml =
    Some
      { window_id =
          Aws.Xml.required
            "WindowId"
            (Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               MaintenanceWindowFilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Filters.member", MaintenanceWindowFilterList.to_query v.filters))
         ; Some (Aws.Query.Pair ("WindowId", String.to_query v.window_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filters", MaintenanceWindowFilterList.to_json v.filters)
         ; Some ("WindowId", String.to_json v.window_id)
         ])

  let of_json j =
    { window_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowId"))
    ; filters =
        MaintenanceWindowFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module PatchDeploymentStatus = struct
  type t =
    | APPROVED
    | PENDING_APPROVAL
    | EXPLICIT_APPROVED
    | EXPLICIT_REJECTED

  let str_to_t =
    [ "EXPLICIT_REJECTED", EXPLICIT_REJECTED
    ; "EXPLICIT_APPROVED", EXPLICIT_APPROVED
    ; "PENDING_APPROVAL", PENDING_APPROVAL
    ; "APPROVED", APPROVED
    ]

  let t_to_str =
    [ EXPLICIT_REJECTED, "EXPLICIT_REJECTED"
    ; EXPLICIT_APPROVED, "EXPLICIT_APPROVED"
    ; PENDING_APPROVAL, "PENDING_APPROVAL"
    ; APPROVED, "APPROVED"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module OpsItem = struct
  type t =
    { created_by : String.t option
    ; created_time : DateTime.t option
    ; description : String.t option
    ; last_modified_by : String.t option
    ; last_modified_time : DateTime.t option
    ; notifications : OpsItemNotifications.t
    ; priority : Integer.t option
    ; related_ops_items : RelatedOpsItems.t
    ; status : OpsItemStatus.t option
    ; ops_item_id : String.t option
    ; version : String.t option
    ; title : String.t option
    ; source : String.t option
    ; operational_data : OpsItemOperationalData.t option
    ; category : String.t option
    ; severity : String.t option
    }

  let make
      ?created_by
      ?created_time
      ?description
      ?last_modified_by
      ?last_modified_time
      ?(notifications = [])
      ?priority
      ?(related_ops_items = [])
      ?status
      ?ops_item_id
      ?version
      ?title
      ?source
      ?operational_data
      ?category
      ?severity
      () =
    { created_by
    ; created_time
    ; description
    ; last_modified_by
    ; last_modified_time
    ; notifications
    ; priority
    ; related_ops_items
    ; status
    ; ops_item_id
    ; version
    ; title
    ; source
    ; operational_data
    ; category
    ; severity
    }

  let parse xml =
    Some
      { created_by = Aws.Util.option_bind (Aws.Xml.member "CreatedBy" xml) String.parse
      ; created_time =
          Aws.Util.option_bind (Aws.Xml.member "CreatedTime" xml) DateTime.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; last_modified_by =
          Aws.Util.option_bind (Aws.Xml.member "LastModifiedBy" xml) String.parse
      ; last_modified_time =
          Aws.Util.option_bind (Aws.Xml.member "LastModifiedTime" xml) DateTime.parse
      ; notifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Notifications" xml)
               OpsItemNotifications.parse)
      ; priority = Aws.Util.option_bind (Aws.Xml.member "Priority" xml) Integer.parse
      ; related_ops_items =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "RelatedOpsItems" xml)
               RelatedOpsItems.parse)
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) OpsItemStatus.parse
      ; ops_item_id = Aws.Util.option_bind (Aws.Xml.member "OpsItemId" xml) String.parse
      ; version = Aws.Util.option_bind (Aws.Xml.member "Version" xml) String.parse
      ; title = Aws.Util.option_bind (Aws.Xml.member "Title" xml) String.parse
      ; source = Aws.Util.option_bind (Aws.Xml.member "Source" xml) String.parse
      ; operational_data =
          Aws.Util.option_bind
            (Aws.Xml.member "OperationalData" xml)
            OpsItemOperationalData.parse
      ; category = Aws.Util.option_bind (Aws.Xml.member "Category" xml) String.parse
      ; severity = Aws.Util.option_bind (Aws.Xml.member "Severity" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.severity (fun f ->
               Aws.Query.Pair ("Severity", String.to_query f))
         ; Aws.Util.option_map v.category (fun f ->
               Aws.Query.Pair ("Category", String.to_query f))
         ; Aws.Util.option_map v.operational_data (fun f ->
               Aws.Query.Pair ("OperationalData", OpsItemOperationalData.to_query f))
         ; Aws.Util.option_map v.source (fun f ->
               Aws.Query.Pair ("Source", String.to_query f))
         ; Aws.Util.option_map v.title (fun f ->
               Aws.Query.Pair ("Title", String.to_query f))
         ; Aws.Util.option_map v.version (fun f ->
               Aws.Query.Pair ("Version", String.to_query f))
         ; Aws.Util.option_map v.ops_item_id (fun f ->
               Aws.Query.Pair ("OpsItemId", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", OpsItemStatus.to_query f))
         ; Some
             (Aws.Query.Pair
                ("RelatedOpsItems.member", RelatedOpsItems.to_query v.related_ops_items))
         ; Aws.Util.option_map v.priority (fun f ->
               Aws.Query.Pair ("Priority", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Notifications.member", OpsItemNotifications.to_query v.notifications))
         ; Aws.Util.option_map v.last_modified_time (fun f ->
               Aws.Query.Pair ("LastModifiedTime", DateTime.to_query f))
         ; Aws.Util.option_map v.last_modified_by (fun f ->
               Aws.Query.Pair ("LastModifiedBy", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.created_time (fun f ->
               Aws.Query.Pair ("CreatedTime", DateTime.to_query f))
         ; Aws.Util.option_map v.created_by (fun f ->
               Aws.Query.Pair ("CreatedBy", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.severity (fun f -> "Severity", String.to_json f)
         ; Aws.Util.option_map v.category (fun f -> "Category", String.to_json f)
         ; Aws.Util.option_map v.operational_data (fun f ->
               "OperationalData", OpsItemOperationalData.to_json f)
         ; Aws.Util.option_map v.source (fun f -> "Source", String.to_json f)
         ; Aws.Util.option_map v.title (fun f -> "Title", String.to_json f)
         ; Aws.Util.option_map v.version (fun f -> "Version", String.to_json f)
         ; Aws.Util.option_map v.ops_item_id (fun f -> "OpsItemId", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", OpsItemStatus.to_json f)
         ; Some ("RelatedOpsItems", RelatedOpsItems.to_json v.related_ops_items)
         ; Aws.Util.option_map v.priority (fun f -> "Priority", Integer.to_json f)
         ; Some ("Notifications", OpsItemNotifications.to_json v.notifications)
         ; Aws.Util.option_map v.last_modified_time (fun f ->
               "LastModifiedTime", DateTime.to_json f)
         ; Aws.Util.option_map v.last_modified_by (fun f ->
               "LastModifiedBy", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.created_time (fun f -> "CreatedTime", DateTime.to_json f)
         ; Aws.Util.option_map v.created_by (fun f -> "CreatedBy", String.to_json f)
         ])

  let of_json j =
    { created_by = Aws.Util.option_map (Aws.Json.lookup j "CreatedBy") String.of_json
    ; created_time =
        Aws.Util.option_map (Aws.Json.lookup j "CreatedTime") DateTime.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; last_modified_by =
        Aws.Util.option_map (Aws.Json.lookup j "LastModifiedBy") String.of_json
    ; last_modified_time =
        Aws.Util.option_map (Aws.Json.lookup j "LastModifiedTime") DateTime.of_json
    ; notifications =
        OpsItemNotifications.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Notifications"))
    ; priority = Aws.Util.option_map (Aws.Json.lookup j "Priority") Integer.of_json
    ; related_ops_items =
        RelatedOpsItems.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "RelatedOpsItems"))
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") OpsItemStatus.of_json
    ; ops_item_id = Aws.Util.option_map (Aws.Json.lookup j "OpsItemId") String.of_json
    ; version = Aws.Util.option_map (Aws.Json.lookup j "Version") String.of_json
    ; title = Aws.Util.option_map (Aws.Json.lookup j "Title") String.of_json
    ; source = Aws.Util.option_map (Aws.Json.lookup j "Source") String.of_json
    ; operational_data =
        Aws.Util.option_map
          (Aws.Json.lookup j "OperationalData")
          OpsItemOperationalData.of_json
    ; category = Aws.Util.option_map (Aws.Json.lookup j "Category") String.of_json
    ; severity = Aws.Util.option_map (Aws.Json.lookup j "Severity") String.of_json
    }
end

module GetOpsItemResponse = struct
  type t = { ops_item : OpsItem.t option }

  let make ?ops_item () = { ops_item }

  let parse xml =
    Some { ops_item = Aws.Util.option_bind (Aws.Xml.member "OpsItem" xml) OpsItem.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ops_item (fun f ->
               Aws.Query.Pair ("OpsItem", OpsItem.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ops_item (fun f -> "OpsItem", OpsItem.to_json f) ])

  let of_json j =
    { ops_item = Aws.Util.option_map (Aws.Json.lookup j "OpsItem") OpsItem.of_json }
end

module GetMaintenanceWindowTaskRequest = struct
  type t =
    { window_id : String.t
    ; window_task_id : String.t
    }

  let make ~window_id ~window_task_id () = { window_id; window_task_id }

  let parse xml =
    Some
      { window_id =
          Aws.Xml.required
            "WindowId"
            (Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse)
      ; window_task_id =
          Aws.Xml.required
            "WindowTaskId"
            (Aws.Util.option_bind (Aws.Xml.member "WindowTaskId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("WindowTaskId", String.to_query v.window_task_id))
         ; Some (Aws.Query.Pair ("WindowId", String.to_query v.window_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("WindowTaskId", String.to_json v.window_task_id)
         ; Some ("WindowId", String.to_json v.window_id)
         ])

  let of_json j =
    { window_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowId"))
    ; window_task_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowTaskId"))
    }
end

module MaintenanceWindowTaskParametersList = struct
  type t = MaintenanceWindowTaskParameters.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map MaintenanceWindowTaskParameters.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list MaintenanceWindowTaskParameters.to_query v
  let to_json v = `List (List.map MaintenanceWindowTaskParameters.to_json v)
  let of_json j = Aws.Json.to_list MaintenanceWindowTaskParameters.of_json j
end

module GetMaintenanceWindowExecutionTaskResult = struct
  type t =
    { window_execution_id : String.t option
    ; task_execution_id : String.t option
    ; task_arn : String.t option
    ; service_role : String.t option
    ; type_ : MaintenanceWindowTaskType.t option
    ; task_parameters : MaintenanceWindowTaskParametersList.t
    ; priority : Integer.t option
    ; max_concurrency : String.t option
    ; max_errors : String.t option
    ; status : MaintenanceWindowExecutionStatus.t option
    ; status_details : String.t option
    ; start_time : DateTime.t option
    ; end_time : DateTime.t option
    }

  let make
      ?window_execution_id
      ?task_execution_id
      ?task_arn
      ?service_role
      ?type_
      ?(task_parameters = [])
      ?priority
      ?max_concurrency
      ?max_errors
      ?status
      ?status_details
      ?start_time
      ?end_time
      () =
    { window_execution_id
    ; task_execution_id
    ; task_arn
    ; service_role
    ; type_
    ; task_parameters
    ; priority
    ; max_concurrency
    ; max_errors
    ; status
    ; status_details
    ; start_time
    ; end_time
    }

  let parse xml =
    Some
      { window_execution_id =
          Aws.Util.option_bind (Aws.Xml.member "WindowExecutionId" xml) String.parse
      ; task_execution_id =
          Aws.Util.option_bind (Aws.Xml.member "TaskExecutionId" xml) String.parse
      ; task_arn = Aws.Util.option_bind (Aws.Xml.member "TaskArn" xml) String.parse
      ; service_role =
          Aws.Util.option_bind (Aws.Xml.member "ServiceRole" xml) String.parse
      ; type_ =
          Aws.Util.option_bind (Aws.Xml.member "Type" xml) MaintenanceWindowTaskType.parse
      ; task_parameters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TaskParameters" xml)
               MaintenanceWindowTaskParametersList.parse)
      ; priority = Aws.Util.option_bind (Aws.Xml.member "Priority" xml) Integer.parse
      ; max_concurrency =
          Aws.Util.option_bind (Aws.Xml.member "MaxConcurrency" xml) String.parse
      ; max_errors = Aws.Util.option_bind (Aws.Xml.member "MaxErrors" xml) String.parse
      ; status =
          Aws.Util.option_bind
            (Aws.Xml.member "Status" xml)
            MaintenanceWindowExecutionStatus.parse
      ; status_details =
          Aws.Util.option_bind (Aws.Xml.member "StatusDetails" xml) String.parse
      ; start_time = Aws.Util.option_bind (Aws.Xml.member "StartTime" xml) DateTime.parse
      ; end_time = Aws.Util.option_bind (Aws.Xml.member "EndTime" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.end_time (fun f ->
               Aws.Query.Pair ("EndTime", DateTime.to_query f))
         ; Aws.Util.option_map v.start_time (fun f ->
               Aws.Query.Pair ("StartTime", DateTime.to_query f))
         ; Aws.Util.option_map v.status_details (fun f ->
               Aws.Query.Pair ("StatusDetails", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", MaintenanceWindowExecutionStatus.to_query f))
         ; Aws.Util.option_map v.max_errors (fun f ->
               Aws.Query.Pair ("MaxErrors", String.to_query f))
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               Aws.Query.Pair ("MaxConcurrency", String.to_query f))
         ; Aws.Util.option_map v.priority (fun f ->
               Aws.Query.Pair ("Priority", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TaskParameters.member"
                , MaintenanceWindowTaskParametersList.to_query v.task_parameters ))
         ; Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", MaintenanceWindowTaskType.to_query f))
         ; Aws.Util.option_map v.service_role (fun f ->
               Aws.Query.Pair ("ServiceRole", String.to_query f))
         ; Aws.Util.option_map v.task_arn (fun f ->
               Aws.Query.Pair ("TaskArn", String.to_query f))
         ; Aws.Util.option_map v.task_execution_id (fun f ->
               Aws.Query.Pair ("TaskExecutionId", String.to_query f))
         ; Aws.Util.option_map v.window_execution_id (fun f ->
               Aws.Query.Pair ("WindowExecutionId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.end_time (fun f -> "EndTime", DateTime.to_json f)
         ; Aws.Util.option_map v.start_time (fun f -> "StartTime", DateTime.to_json f)
         ; Aws.Util.option_map v.status_details (fun f ->
               "StatusDetails", String.to_json f)
         ; Aws.Util.option_map v.status (fun f ->
               "Status", MaintenanceWindowExecutionStatus.to_json f)
         ; Aws.Util.option_map v.max_errors (fun f -> "MaxErrors", String.to_json f)
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               "MaxConcurrency", String.to_json f)
         ; Aws.Util.option_map v.priority (fun f -> "Priority", Integer.to_json f)
         ; Some
             ( "TaskParameters"
             , MaintenanceWindowTaskParametersList.to_json v.task_parameters )
         ; Aws.Util.option_map v.type_ (fun f ->
               "Type", MaintenanceWindowTaskType.to_json f)
         ; Aws.Util.option_map v.service_role (fun f -> "ServiceRole", String.to_json f)
         ; Aws.Util.option_map v.task_arn (fun f -> "TaskArn", String.to_json f)
         ; Aws.Util.option_map v.task_execution_id (fun f ->
               "TaskExecutionId", String.to_json f)
         ; Aws.Util.option_map v.window_execution_id (fun f ->
               "WindowExecutionId", String.to_json f)
         ])

  let of_json j =
    { window_execution_id =
        Aws.Util.option_map (Aws.Json.lookup j "WindowExecutionId") String.of_json
    ; task_execution_id =
        Aws.Util.option_map (Aws.Json.lookup j "TaskExecutionId") String.of_json
    ; task_arn = Aws.Util.option_map (Aws.Json.lookup j "TaskArn") String.of_json
    ; service_role = Aws.Util.option_map (Aws.Json.lookup j "ServiceRole") String.of_json
    ; type_ =
        Aws.Util.option_map (Aws.Json.lookup j "Type") MaintenanceWindowTaskType.of_json
    ; task_parameters =
        MaintenanceWindowTaskParametersList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TaskParameters"))
    ; priority = Aws.Util.option_map (Aws.Json.lookup j "Priority") Integer.of_json
    ; max_concurrency =
        Aws.Util.option_map (Aws.Json.lookup j "MaxConcurrency") String.of_json
    ; max_errors = Aws.Util.option_map (Aws.Json.lookup j "MaxErrors") String.of_json
    ; status =
        Aws.Util.option_map
          (Aws.Json.lookup j "Status")
          MaintenanceWindowExecutionStatus.of_json
    ; status_details =
        Aws.Util.option_map (Aws.Json.lookup j "StatusDetails") String.of_json
    ; start_time = Aws.Util.option_map (Aws.Json.lookup j "StartTime") DateTime.of_json
    ; end_time = Aws.Util.option_map (Aws.Json.lookup j "EndTime") DateTime.of_json
    }
end

module ComplianceItemEntryList = struct
  type t = ComplianceItemEntry.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ComplianceItemEntry.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list ComplianceItemEntry.to_query v
  let to_json v = `List (List.map ComplianceItemEntry.to_json v)
  let of_json j = Aws.Json.to_list ComplianceItemEntry.of_json j
end

module PutComplianceItemsRequest = struct
  type t =
    { resource_id : String.t
    ; resource_type : String.t
    ; compliance_type : String.t
    ; execution_summary : ComplianceExecutionSummary.t
    ; items : ComplianceItemEntryList.t
    ; item_content_hash : String.t option
    ; upload_type : ComplianceUploadType.t option
    }

  let make
      ~resource_id
      ~resource_type
      ~compliance_type
      ~execution_summary
      ~items
      ?item_content_hash
      ?upload_type
      () =
    { resource_id
    ; resource_type
    ; compliance_type
    ; execution_summary
    ; items
    ; item_content_hash
    ; upload_type
    }

  let parse xml =
    Some
      { resource_id =
          Aws.Xml.required
            "ResourceId"
            (Aws.Util.option_bind (Aws.Xml.member "ResourceId" xml) String.parse)
      ; resource_type =
          Aws.Xml.required
            "ResourceType"
            (Aws.Util.option_bind (Aws.Xml.member "ResourceType" xml) String.parse)
      ; compliance_type =
          Aws.Xml.required
            "ComplianceType"
            (Aws.Util.option_bind (Aws.Xml.member "ComplianceType" xml) String.parse)
      ; execution_summary =
          Aws.Xml.required
            "ExecutionSummary"
            (Aws.Util.option_bind
               (Aws.Xml.member "ExecutionSummary" xml)
               ComplianceExecutionSummary.parse)
      ; items =
          Aws.Xml.required
            "Items"
            (Aws.Util.option_bind
               (Aws.Xml.member "Items" xml)
               ComplianceItemEntryList.parse)
      ; item_content_hash =
          Aws.Util.option_bind (Aws.Xml.member "ItemContentHash" xml) String.parse
      ; upload_type =
          Aws.Util.option_bind
            (Aws.Xml.member "UploadType" xml)
            ComplianceUploadType.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.upload_type (fun f ->
               Aws.Query.Pair ("UploadType", ComplianceUploadType.to_query f))
         ; Aws.Util.option_map v.item_content_hash (fun f ->
               Aws.Query.Pair ("ItemContentHash", String.to_query f))
         ; Some
             (Aws.Query.Pair ("Items.member", ComplianceItemEntryList.to_query v.items))
         ; Some
             (Aws.Query.Pair
                ( "ExecutionSummary"
                , ComplianceExecutionSummary.to_query v.execution_summary ))
         ; Some (Aws.Query.Pair ("ComplianceType", String.to_query v.compliance_type))
         ; Some (Aws.Query.Pair ("ResourceType", String.to_query v.resource_type))
         ; Some (Aws.Query.Pair ("ResourceId", String.to_query v.resource_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.upload_type (fun f ->
               "UploadType", ComplianceUploadType.to_json f)
         ; Aws.Util.option_map v.item_content_hash (fun f ->
               "ItemContentHash", String.to_json f)
         ; Some ("Items", ComplianceItemEntryList.to_json v.items)
         ; Some
             ("ExecutionSummary", ComplianceExecutionSummary.to_json v.execution_summary)
         ; Some ("ComplianceType", String.to_json v.compliance_type)
         ; Some ("ResourceType", String.to_json v.resource_type)
         ; Some ("ResourceId", String.to_json v.resource_id)
         ])

  let of_json j =
    { resource_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ResourceId"))
    ; resource_type =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ResourceType"))
    ; compliance_type =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ComplianceType"))
    ; execution_summary =
        ComplianceExecutionSummary.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ExecutionSummary"))
    ; items =
        ComplianceItemEntryList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Items"))
    ; item_content_hash =
        Aws.Util.option_map (Aws.Json.lookup j "ItemContentHash") String.of_json
    ; upload_type =
        Aws.Util.option_map (Aws.Json.lookup j "UploadType") ComplianceUploadType.of_json
    }
end

module GetParameterRequest = struct
  type t =
    { name : String.t
    ; with_decryption : Boolean.t option
    }

  let make ~name ?with_decryption () = { name; with_decryption }

  let parse xml =
    Some
      { name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      ; with_decryption =
          Aws.Util.option_bind (Aws.Xml.member "WithDecryption" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.with_decryption (fun f ->
               Aws.Query.Pair ("WithDecryption", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.with_decryption (fun f ->
               "WithDecryption", Boolean.to_json f)
         ; Some ("Name", String.to_json v.name)
         ])

  let of_json j =
    { name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; with_decryption =
        Aws.Util.option_map (Aws.Json.lookup j "WithDecryption") Boolean.of_json
    }
end

module GetDeployablePatchSnapshotForInstanceResult = struct
  type t =
    { instance_id : String.t option
    ; snapshot_id : String.t option
    ; snapshot_download_url : String.t option
    ; product : String.t option
    }

  let make ?instance_id ?snapshot_id ?snapshot_download_url ?product () =
    { instance_id; snapshot_id; snapshot_download_url; product }

  let parse xml =
    Some
      { instance_id = Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse
      ; snapshot_id = Aws.Util.option_bind (Aws.Xml.member "SnapshotId" xml) String.parse
      ; snapshot_download_url =
          Aws.Util.option_bind (Aws.Xml.member "SnapshotDownloadUrl" xml) String.parse
      ; product = Aws.Util.option_bind (Aws.Xml.member "Product" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.product (fun f ->
               Aws.Query.Pair ("Product", String.to_query f))
         ; Aws.Util.option_map v.snapshot_download_url (fun f ->
               Aws.Query.Pair ("SnapshotDownloadUrl", String.to_query f))
         ; Aws.Util.option_map v.snapshot_id (fun f ->
               Aws.Query.Pair ("SnapshotId", String.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.product (fun f -> "Product", String.to_json f)
         ; Aws.Util.option_map v.snapshot_download_url (fun f ->
               "SnapshotDownloadUrl", String.to_json f)
         ; Aws.Util.option_map v.snapshot_id (fun f -> "SnapshotId", String.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "InstanceId", String.to_json f)
         ])

  let of_json j =
    { instance_id = Aws.Util.option_map (Aws.Json.lookup j "InstanceId") String.of_json
    ; snapshot_id = Aws.Util.option_map (Aws.Json.lookup j "SnapshotId") String.of_json
    ; snapshot_download_url =
        Aws.Util.option_map (Aws.Json.lookup j "SnapshotDownloadUrl") String.of_json
    ; product = Aws.Util.option_map (Aws.Json.lookup j "Product") String.of_json
    }
end

module InvocationDoesNotExist = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module InvalidRole = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module Fault = struct
  type t =
    | Client
    | Server
    | Unknown

  let str_to_t = [ "Unknown", Unknown; "Server", Server; "Client", Client ]
  let t_to_str = [ Unknown, "Unknown"; Server, "Server"; Client, "Client" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module CreateAssociationBatchRequestEntry = struct
  type t =
    { name : String.t
    ; instance_id : String.t option
    ; parameters : Parameters.t option
    ; automation_target_parameter_name : String.t option
    ; document_version : String.t option
    ; targets : Targets.t
    ; schedule_expression : String.t option
    ; output_location : InstanceAssociationOutputLocation.t option
    ; association_name : String.t option
    ; max_errors : String.t option
    ; max_concurrency : String.t option
    ; compliance_severity : AssociationComplianceSeverity.t option
    ; sync_compliance : AssociationSyncCompliance.t option
    ; apply_only_at_cron_interval : Boolean.t option
    }

  let make
      ~name
      ?instance_id
      ?parameters
      ?automation_target_parameter_name
      ?document_version
      ?(targets = [])
      ?schedule_expression
      ?output_location
      ?association_name
      ?max_errors
      ?max_concurrency
      ?compliance_severity
      ?sync_compliance
      ?apply_only_at_cron_interval
      () =
    { name
    ; instance_id
    ; parameters
    ; automation_target_parameter_name
    ; document_version
    ; targets
    ; schedule_expression
    ; output_location
    ; association_name
    ; max_errors
    ; max_concurrency
    ; compliance_severity
    ; sync_compliance
    ; apply_only_at_cron_interval
    }

  let parse xml =
    Some
      { name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse
      ; parameters =
          Aws.Util.option_bind (Aws.Xml.member "Parameters" xml) Parameters.parse
      ; automation_target_parameter_name =
          Aws.Util.option_bind
            (Aws.Xml.member "AutomationTargetParameterName" xml)
            String.parse
      ; document_version =
          Aws.Util.option_bind (Aws.Xml.member "DocumentVersion" xml) String.parse
      ; targets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Targets" xml) Targets.parse)
      ; schedule_expression =
          Aws.Util.option_bind (Aws.Xml.member "ScheduleExpression" xml) String.parse
      ; output_location =
          Aws.Util.option_bind
            (Aws.Xml.member "OutputLocation" xml)
            InstanceAssociationOutputLocation.parse
      ; association_name =
          Aws.Util.option_bind (Aws.Xml.member "AssociationName" xml) String.parse
      ; max_errors = Aws.Util.option_bind (Aws.Xml.member "MaxErrors" xml) String.parse
      ; max_concurrency =
          Aws.Util.option_bind (Aws.Xml.member "MaxConcurrency" xml) String.parse
      ; compliance_severity =
          Aws.Util.option_bind
            (Aws.Xml.member "ComplianceSeverity" xml)
            AssociationComplianceSeverity.parse
      ; sync_compliance =
          Aws.Util.option_bind
            (Aws.Xml.member "SyncCompliance" xml)
            AssociationSyncCompliance.parse
      ; apply_only_at_cron_interval =
          Aws.Util.option_bind
            (Aws.Xml.member "ApplyOnlyAtCronInterval" xml)
            Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.apply_only_at_cron_interval (fun f ->
               Aws.Query.Pair ("ApplyOnlyAtCronInterval", Boolean.to_query f))
         ; Aws.Util.option_map v.sync_compliance (fun f ->
               Aws.Query.Pair ("SyncCompliance", AssociationSyncCompliance.to_query f))
         ; Aws.Util.option_map v.compliance_severity (fun f ->
               Aws.Query.Pair
                 ("ComplianceSeverity", AssociationComplianceSeverity.to_query f))
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               Aws.Query.Pair ("MaxConcurrency", String.to_query f))
         ; Aws.Util.option_map v.max_errors (fun f ->
               Aws.Query.Pair ("MaxErrors", String.to_query f))
         ; Aws.Util.option_map v.association_name (fun f ->
               Aws.Query.Pair ("AssociationName", String.to_query f))
         ; Aws.Util.option_map v.output_location (fun f ->
               Aws.Query.Pair
                 ("OutputLocation", InstanceAssociationOutputLocation.to_query f))
         ; Aws.Util.option_map v.schedule_expression (fun f ->
               Aws.Query.Pair ("ScheduleExpression", String.to_query f))
         ; Some (Aws.Query.Pair ("Targets.member", Targets.to_query v.targets))
         ; Aws.Util.option_map v.document_version (fun f ->
               Aws.Query.Pair ("DocumentVersion", String.to_query f))
         ; Aws.Util.option_map v.automation_target_parameter_name (fun f ->
               Aws.Query.Pair ("AutomationTargetParameterName", String.to_query f))
         ; Aws.Util.option_map v.parameters (fun f ->
               Aws.Query.Pair ("Parameters", Parameters.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.apply_only_at_cron_interval (fun f ->
               "ApplyOnlyAtCronInterval", Boolean.to_json f)
         ; Aws.Util.option_map v.sync_compliance (fun f ->
               "SyncCompliance", AssociationSyncCompliance.to_json f)
         ; Aws.Util.option_map v.compliance_severity (fun f ->
               "ComplianceSeverity", AssociationComplianceSeverity.to_json f)
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               "MaxConcurrency", String.to_json f)
         ; Aws.Util.option_map v.max_errors (fun f -> "MaxErrors", String.to_json f)
         ; Aws.Util.option_map v.association_name (fun f ->
               "AssociationName", String.to_json f)
         ; Aws.Util.option_map v.output_location (fun f ->
               "OutputLocation", InstanceAssociationOutputLocation.to_json f)
         ; Aws.Util.option_map v.schedule_expression (fun f ->
               "ScheduleExpression", String.to_json f)
         ; Some ("Targets", Targets.to_json v.targets)
         ; Aws.Util.option_map v.document_version (fun f ->
               "DocumentVersion", String.to_json f)
         ; Aws.Util.option_map v.automation_target_parameter_name (fun f ->
               "AutomationTargetParameterName", String.to_json f)
         ; Aws.Util.option_map v.parameters (fun f -> "Parameters", Parameters.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "InstanceId", String.to_json f)
         ; Some ("Name", String.to_json v.name)
         ])

  let of_json j =
    { name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "InstanceId") String.of_json
    ; parameters = Aws.Util.option_map (Aws.Json.lookup j "Parameters") Parameters.of_json
    ; automation_target_parameter_name =
        Aws.Util.option_map
          (Aws.Json.lookup j "AutomationTargetParameterName")
          String.of_json
    ; document_version =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentVersion") String.of_json
    ; targets = Targets.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Targets"))
    ; schedule_expression =
        Aws.Util.option_map (Aws.Json.lookup j "ScheduleExpression") String.of_json
    ; output_location =
        Aws.Util.option_map
          (Aws.Json.lookup j "OutputLocation")
          InstanceAssociationOutputLocation.of_json
    ; association_name =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationName") String.of_json
    ; max_errors = Aws.Util.option_map (Aws.Json.lookup j "MaxErrors") String.of_json
    ; max_concurrency =
        Aws.Util.option_map (Aws.Json.lookup j "MaxConcurrency") String.of_json
    ; compliance_severity =
        Aws.Util.option_map
          (Aws.Json.lookup j "ComplianceSeverity")
          AssociationComplianceSeverity.of_json
    ; sync_compliance =
        Aws.Util.option_map
          (Aws.Json.lookup j "SyncCompliance")
          AssociationSyncCompliance.of_json
    ; apply_only_at_cron_interval =
        Aws.Util.option_map (Aws.Json.lookup j "ApplyOnlyAtCronInterval") Boolean.of_json
    }
end

module FailedCreateAssociation = struct
  type t =
    { entry : CreateAssociationBatchRequestEntry.t option
    ; message : String.t option
    ; fault : Fault.t option
    }

  let make ?entry ?message ?fault () = { entry; message; fault }

  let parse xml =
    Some
      { entry =
          Aws.Util.option_bind
            (Aws.Xml.member "Entry" xml)
            CreateAssociationBatchRequestEntry.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse
      ; fault = Aws.Util.option_bind (Aws.Xml.member "Fault" xml) Fault.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.fault (fun f ->
               Aws.Query.Pair ("Fault", Fault.to_query f))
         ; Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.entry (fun f ->
               Aws.Query.Pair ("Entry", CreateAssociationBatchRequestEntry.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.fault (fun f -> "Fault", Fault.to_json f)
         ; Aws.Util.option_map v.message (fun f -> "Message", String.to_json f)
         ; Aws.Util.option_map v.entry (fun f ->
               "Entry", CreateAssociationBatchRequestEntry.to_json f)
         ])

  let of_json j =
    { entry =
        Aws.Util.option_map
          (Aws.Json.lookup j "Entry")
          CreateAssociationBatchRequestEntry.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json
    ; fault = Aws.Util.option_map (Aws.Json.lookup j "Fault") Fault.of_json
    }
end

module FailedCreateAssociationList = struct
  type t = FailedCreateAssociation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map FailedCreateAssociation.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list FailedCreateAssociation.to_query v
  let to_json v = `List (List.map FailedCreateAssociation.to_json v)
  let of_json j = Aws.Json.to_list FailedCreateAssociation.of_json j
end

module AssociationDescription = struct
  type t =
    { name : String.t option
    ; instance_id : String.t option
    ; association_version : String.t option
    ; date : DateTime.t option
    ; last_update_association_date : DateTime.t option
    ; status : AssociationStatus.t option
    ; overview : AssociationOverview.t option
    ; document_version : String.t option
    ; automation_target_parameter_name : String.t option
    ; parameters : Parameters.t option
    ; association_id : String.t option
    ; targets : Targets.t
    ; schedule_expression : String.t option
    ; output_location : InstanceAssociationOutputLocation.t option
    ; last_execution_date : DateTime.t option
    ; last_successful_execution_date : DateTime.t option
    ; association_name : String.t option
    ; max_errors : String.t option
    ; max_concurrency : String.t option
    ; compliance_severity : AssociationComplianceSeverity.t option
    ; sync_compliance : AssociationSyncCompliance.t option
    ; apply_only_at_cron_interval : Boolean.t option
    }

  let make
      ?name
      ?instance_id
      ?association_version
      ?date
      ?last_update_association_date
      ?status
      ?overview
      ?document_version
      ?automation_target_parameter_name
      ?parameters
      ?association_id
      ?(targets = [])
      ?schedule_expression
      ?output_location
      ?last_execution_date
      ?last_successful_execution_date
      ?association_name
      ?max_errors
      ?max_concurrency
      ?compliance_severity
      ?sync_compliance
      ?apply_only_at_cron_interval
      () =
    { name
    ; instance_id
    ; association_version
    ; date
    ; last_update_association_date
    ; status
    ; overview
    ; document_version
    ; automation_target_parameter_name
    ; parameters
    ; association_id
    ; targets
    ; schedule_expression
    ; output_location
    ; last_execution_date
    ; last_successful_execution_date
    ; association_name
    ; max_errors
    ; max_concurrency
    ; compliance_severity
    ; sync_compliance
    ; apply_only_at_cron_interval
    }

  let parse xml =
    Some
      { name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse
      ; association_version =
          Aws.Util.option_bind (Aws.Xml.member "AssociationVersion" xml) String.parse
      ; date = Aws.Util.option_bind (Aws.Xml.member "Date" xml) DateTime.parse
      ; last_update_association_date =
          Aws.Util.option_bind
            (Aws.Xml.member "LastUpdateAssociationDate" xml)
            DateTime.parse
      ; status =
          Aws.Util.option_bind (Aws.Xml.member "Status" xml) AssociationStatus.parse
      ; overview =
          Aws.Util.option_bind (Aws.Xml.member "Overview" xml) AssociationOverview.parse
      ; document_version =
          Aws.Util.option_bind (Aws.Xml.member "DocumentVersion" xml) String.parse
      ; automation_target_parameter_name =
          Aws.Util.option_bind
            (Aws.Xml.member "AutomationTargetParameterName" xml)
            String.parse
      ; parameters =
          Aws.Util.option_bind (Aws.Xml.member "Parameters" xml) Parameters.parse
      ; association_id =
          Aws.Util.option_bind (Aws.Xml.member "AssociationId" xml) String.parse
      ; targets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Targets" xml) Targets.parse)
      ; schedule_expression =
          Aws.Util.option_bind (Aws.Xml.member "ScheduleExpression" xml) String.parse
      ; output_location =
          Aws.Util.option_bind
            (Aws.Xml.member "OutputLocation" xml)
            InstanceAssociationOutputLocation.parse
      ; last_execution_date =
          Aws.Util.option_bind (Aws.Xml.member "LastExecutionDate" xml) DateTime.parse
      ; last_successful_execution_date =
          Aws.Util.option_bind
            (Aws.Xml.member "LastSuccessfulExecutionDate" xml)
            DateTime.parse
      ; association_name =
          Aws.Util.option_bind (Aws.Xml.member "AssociationName" xml) String.parse
      ; max_errors = Aws.Util.option_bind (Aws.Xml.member "MaxErrors" xml) String.parse
      ; max_concurrency =
          Aws.Util.option_bind (Aws.Xml.member "MaxConcurrency" xml) String.parse
      ; compliance_severity =
          Aws.Util.option_bind
            (Aws.Xml.member "ComplianceSeverity" xml)
            AssociationComplianceSeverity.parse
      ; sync_compliance =
          Aws.Util.option_bind
            (Aws.Xml.member "SyncCompliance" xml)
            AssociationSyncCompliance.parse
      ; apply_only_at_cron_interval =
          Aws.Util.option_bind
            (Aws.Xml.member "ApplyOnlyAtCronInterval" xml)
            Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.apply_only_at_cron_interval (fun f ->
               Aws.Query.Pair ("ApplyOnlyAtCronInterval", Boolean.to_query f))
         ; Aws.Util.option_map v.sync_compliance (fun f ->
               Aws.Query.Pair ("SyncCompliance", AssociationSyncCompliance.to_query f))
         ; Aws.Util.option_map v.compliance_severity (fun f ->
               Aws.Query.Pair
                 ("ComplianceSeverity", AssociationComplianceSeverity.to_query f))
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               Aws.Query.Pair ("MaxConcurrency", String.to_query f))
         ; Aws.Util.option_map v.max_errors (fun f ->
               Aws.Query.Pair ("MaxErrors", String.to_query f))
         ; Aws.Util.option_map v.association_name (fun f ->
               Aws.Query.Pair ("AssociationName", String.to_query f))
         ; Aws.Util.option_map v.last_successful_execution_date (fun f ->
               Aws.Query.Pair ("LastSuccessfulExecutionDate", DateTime.to_query f))
         ; Aws.Util.option_map v.last_execution_date (fun f ->
               Aws.Query.Pair ("LastExecutionDate", DateTime.to_query f))
         ; Aws.Util.option_map v.output_location (fun f ->
               Aws.Query.Pair
                 ("OutputLocation", InstanceAssociationOutputLocation.to_query f))
         ; Aws.Util.option_map v.schedule_expression (fun f ->
               Aws.Query.Pair ("ScheduleExpression", String.to_query f))
         ; Some (Aws.Query.Pair ("Targets.member", Targets.to_query v.targets))
         ; Aws.Util.option_map v.association_id (fun f ->
               Aws.Query.Pair ("AssociationId", String.to_query f))
         ; Aws.Util.option_map v.parameters (fun f ->
               Aws.Query.Pair ("Parameters", Parameters.to_query f))
         ; Aws.Util.option_map v.automation_target_parameter_name (fun f ->
               Aws.Query.Pair ("AutomationTargetParameterName", String.to_query f))
         ; Aws.Util.option_map v.document_version (fun f ->
               Aws.Query.Pair ("DocumentVersion", String.to_query f))
         ; Aws.Util.option_map v.overview (fun f ->
               Aws.Query.Pair ("Overview", AssociationOverview.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", AssociationStatus.to_query f))
         ; Aws.Util.option_map v.last_update_association_date (fun f ->
               Aws.Query.Pair ("LastUpdateAssociationDate", DateTime.to_query f))
         ; Aws.Util.option_map v.date (fun f ->
               Aws.Query.Pair ("Date", DateTime.to_query f))
         ; Aws.Util.option_map v.association_version (fun f ->
               Aws.Query.Pair ("AssociationVersion", String.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.apply_only_at_cron_interval (fun f ->
               "ApplyOnlyAtCronInterval", Boolean.to_json f)
         ; Aws.Util.option_map v.sync_compliance (fun f ->
               "SyncCompliance", AssociationSyncCompliance.to_json f)
         ; Aws.Util.option_map v.compliance_severity (fun f ->
               "ComplianceSeverity", AssociationComplianceSeverity.to_json f)
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               "MaxConcurrency", String.to_json f)
         ; Aws.Util.option_map v.max_errors (fun f -> "MaxErrors", String.to_json f)
         ; Aws.Util.option_map v.association_name (fun f ->
               "AssociationName", String.to_json f)
         ; Aws.Util.option_map v.last_successful_execution_date (fun f ->
               "LastSuccessfulExecutionDate", DateTime.to_json f)
         ; Aws.Util.option_map v.last_execution_date (fun f ->
               "LastExecutionDate", DateTime.to_json f)
         ; Aws.Util.option_map v.output_location (fun f ->
               "OutputLocation", InstanceAssociationOutputLocation.to_json f)
         ; Aws.Util.option_map v.schedule_expression (fun f ->
               "ScheduleExpression", String.to_json f)
         ; Some ("Targets", Targets.to_json v.targets)
         ; Aws.Util.option_map v.association_id (fun f ->
               "AssociationId", String.to_json f)
         ; Aws.Util.option_map v.parameters (fun f -> "Parameters", Parameters.to_json f)
         ; Aws.Util.option_map v.automation_target_parameter_name (fun f ->
               "AutomationTargetParameterName", String.to_json f)
         ; Aws.Util.option_map v.document_version (fun f ->
               "DocumentVersion", String.to_json f)
         ; Aws.Util.option_map v.overview (fun f ->
               "Overview", AssociationOverview.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", AssociationStatus.to_json f)
         ; Aws.Util.option_map v.last_update_association_date (fun f ->
               "LastUpdateAssociationDate", DateTime.to_json f)
         ; Aws.Util.option_map v.date (fun f -> "Date", DateTime.to_json f)
         ; Aws.Util.option_map v.association_version (fun f ->
               "AssociationVersion", String.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "InstanceId", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ])

  let of_json j =
    { name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "InstanceId") String.of_json
    ; association_version =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationVersion") String.of_json
    ; date = Aws.Util.option_map (Aws.Json.lookup j "Date") DateTime.of_json
    ; last_update_association_date =
        Aws.Util.option_map
          (Aws.Json.lookup j "LastUpdateAssociationDate")
          DateTime.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") AssociationStatus.of_json
    ; overview =
        Aws.Util.option_map (Aws.Json.lookup j "Overview") AssociationOverview.of_json
    ; document_version =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentVersion") String.of_json
    ; automation_target_parameter_name =
        Aws.Util.option_map
          (Aws.Json.lookup j "AutomationTargetParameterName")
          String.of_json
    ; parameters = Aws.Util.option_map (Aws.Json.lookup j "Parameters") Parameters.of_json
    ; association_id =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationId") String.of_json
    ; targets = Targets.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Targets"))
    ; schedule_expression =
        Aws.Util.option_map (Aws.Json.lookup j "ScheduleExpression") String.of_json
    ; output_location =
        Aws.Util.option_map
          (Aws.Json.lookup j "OutputLocation")
          InstanceAssociationOutputLocation.of_json
    ; last_execution_date =
        Aws.Util.option_map (Aws.Json.lookup j "LastExecutionDate") DateTime.of_json
    ; last_successful_execution_date =
        Aws.Util.option_map
          (Aws.Json.lookup j "LastSuccessfulExecutionDate")
          DateTime.of_json
    ; association_name =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationName") String.of_json
    ; max_errors = Aws.Util.option_map (Aws.Json.lookup j "MaxErrors") String.of_json
    ; max_concurrency =
        Aws.Util.option_map (Aws.Json.lookup j "MaxConcurrency") String.of_json
    ; compliance_severity =
        Aws.Util.option_map
          (Aws.Json.lookup j "ComplianceSeverity")
          AssociationComplianceSeverity.of_json
    ; sync_compliance =
        Aws.Util.option_map
          (Aws.Json.lookup j "SyncCompliance")
          AssociationSyncCompliance.of_json
    ; apply_only_at_cron_interval =
        Aws.Util.option_map (Aws.Json.lookup j "ApplyOnlyAtCronInterval") Boolean.of_json
    }
end

module AssociationDescriptionList = struct
  type t = AssociationDescription.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map AssociationDescription.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list AssociationDescription.to_query v
  let to_json v = `List (List.map AssociationDescription.to_json v)
  let of_json j = Aws.Json.to_list AssociationDescription.of_json j
end

module CreateAssociationBatchResult = struct
  type t =
    { successful : AssociationDescriptionList.t
    ; failed : FailedCreateAssociationList.t
    }

  let make ?(successful = []) ?(failed = []) () = { successful; failed }

  let parse xml =
    Some
      { successful =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Successful" xml)
               AssociationDescriptionList.parse)
      ; failed =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Failed" xml)
               FailedCreateAssociationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("Failed.member", FailedCreateAssociationList.to_query v.failed))
         ; Some
             (Aws.Query.Pair
                ("Successful.member", AssociationDescriptionList.to_query v.successful))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Failed", FailedCreateAssociationList.to_json v.failed)
         ; Some ("Successful", AssociationDescriptionList.to_json v.successful)
         ])

  let of_json j =
    { successful =
        AssociationDescriptionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Successful"))
    ; failed =
        FailedCreateAssociationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Failed"))
    }
end

module AssociationFilterKey = struct
  type t =
    | InstanceId
    | Name
    | AssociationId
    | AssociationStatusName
    | LastExecutedBefore
    | LastExecutedAfter
    | AssociationName
    | ResourceGroupName

  let str_to_t =
    [ "ResourceGroupName", ResourceGroupName
    ; "AssociationName", AssociationName
    ; "LastExecutedAfter", LastExecutedAfter
    ; "LastExecutedBefore", LastExecutedBefore
    ; "AssociationStatusName", AssociationStatusName
    ; "AssociationId", AssociationId
    ; "Name", Name
    ; "InstanceId", InstanceId
    ]

  let t_to_str =
    [ ResourceGroupName, "ResourceGroupName"
    ; AssociationName, "AssociationName"
    ; LastExecutedAfter, "LastExecutedAfter"
    ; LastExecutedBefore, "LastExecutedBefore"
    ; AssociationStatusName, "AssociationStatusName"
    ; AssociationId, "AssociationId"
    ; Name, "Name"
    ; InstanceId, "InstanceId"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module AssociationFilter = struct
  type t =
    { key : AssociationFilterKey.t
    ; value : String.t
    }

  let make ~key ~value () = { key; value }

  let parse xml =
    Some
      { key =
          Aws.Xml.required
            "key"
            (Aws.Util.option_bind (Aws.Xml.member "key" xml) AssociationFilterKey.parse)
      ; value =
          Aws.Xml.required
            "value"
            (Aws.Util.option_bind (Aws.Xml.member "value" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("value", String.to_query v.value))
         ; Some (Aws.Query.Pair ("key", AssociationFilterKey.to_query v.key))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("value", String.to_json v.value)
         ; Some ("key", AssociationFilterKey.to_json v.key)
         ])

  let of_json j =
    { key =
        AssociationFilterKey.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "key"))
    ; value = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "value"))
    }
end

module KeyList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module MaintenanceWindowTarget = struct
  type t =
    { window_id : String.t option
    ; window_target_id : String.t option
    ; resource_type : MaintenanceWindowResourceType.t option
    ; targets : Targets.t
    ; owner_information : String.t option
    ; name : String.t option
    ; description : String.t option
    }

  let make
      ?window_id
      ?window_target_id
      ?resource_type
      ?(targets = [])
      ?owner_information
      ?name
      ?description
      () =
    { window_id
    ; window_target_id
    ; resource_type
    ; targets
    ; owner_information
    ; name
    ; description
    }

  let parse xml =
    Some
      { window_id = Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse
      ; window_target_id =
          Aws.Util.option_bind (Aws.Xml.member "WindowTargetId" xml) String.parse
      ; resource_type =
          Aws.Util.option_bind
            (Aws.Xml.member "ResourceType" xml)
            MaintenanceWindowResourceType.parse
      ; targets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Targets" xml) Targets.parse)
      ; owner_information =
          Aws.Util.option_bind (Aws.Xml.member "OwnerInformation" xml) String.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.owner_information (fun f ->
               Aws.Query.Pair ("OwnerInformation", String.to_query f))
         ; Some (Aws.Query.Pair ("Targets.member", Targets.to_query v.targets))
         ; Aws.Util.option_map v.resource_type (fun f ->
               Aws.Query.Pair ("ResourceType", MaintenanceWindowResourceType.to_query f))
         ; Aws.Util.option_map v.window_target_id (fun f ->
               Aws.Query.Pair ("WindowTargetId", String.to_query f))
         ; Aws.Util.option_map v.window_id (fun f ->
               Aws.Query.Pair ("WindowId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.owner_information (fun f ->
               "OwnerInformation", String.to_json f)
         ; Some ("Targets", Targets.to_json v.targets)
         ; Aws.Util.option_map v.resource_type (fun f ->
               "ResourceType", MaintenanceWindowResourceType.to_json f)
         ; Aws.Util.option_map v.window_target_id (fun f ->
               "WindowTargetId", String.to_json f)
         ; Aws.Util.option_map v.window_id (fun f -> "WindowId", String.to_json f)
         ])

  let of_json j =
    { window_id = Aws.Util.option_map (Aws.Json.lookup j "WindowId") String.of_json
    ; window_target_id =
        Aws.Util.option_map (Aws.Json.lookup j "WindowTargetId") String.of_json
    ; resource_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "ResourceType")
          MaintenanceWindowResourceType.of_json
    ; targets = Targets.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Targets"))
    ; owner_information =
        Aws.Util.option_map (Aws.Json.lookup j "OwnerInformation") String.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    }
end

module MaintenanceWindowTargetList = struct
  type t = MaintenanceWindowTarget.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map MaintenanceWindowTarget.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list MaintenanceWindowTarget.to_query v
  let to_json v = `List (List.map MaintenanceWindowTarget.to_json v)
  let of_json j = Aws.Json.to_list MaintenanceWindowTarget.of_json j
end

module GetPatchBaselineForPatchGroupRequest = struct
  type t =
    { patch_group : String.t
    ; operating_system : OperatingSystem.t option
    }

  let make ~patch_group ?operating_system () = { patch_group; operating_system }

  let parse xml =
    Some
      { patch_group =
          Aws.Xml.required
            "PatchGroup"
            (Aws.Util.option_bind (Aws.Xml.member "PatchGroup" xml) String.parse)
      ; operating_system =
          Aws.Util.option_bind
            (Aws.Xml.member "OperatingSystem" xml)
            OperatingSystem.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.operating_system (fun f ->
               Aws.Query.Pair ("OperatingSystem", OperatingSystem.to_query f))
         ; Some (Aws.Query.Pair ("PatchGroup", String.to_query v.patch_group))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.operating_system (fun f ->
               "OperatingSystem", OperatingSystem.to_json f)
         ; Some ("PatchGroup", String.to_json v.patch_group)
         ])

  let of_json j =
    { patch_group =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PatchGroup"))
    ; operating_system =
        Aws.Util.option_map (Aws.Json.lookup j "OperatingSystem") OperatingSystem.of_json
    }
end

module InvalidUpdate = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module PatchStatus = struct
  type t =
    { deployment_status : PatchDeploymentStatus.t option
    ; compliance_level : PatchComplianceLevel.t option
    ; approval_date : DateTime.t option
    }

  let make ?deployment_status ?compliance_level ?approval_date () =
    { deployment_status; compliance_level; approval_date }

  let parse xml =
    Some
      { deployment_status =
          Aws.Util.option_bind
            (Aws.Xml.member "DeploymentStatus" xml)
            PatchDeploymentStatus.parse
      ; compliance_level =
          Aws.Util.option_bind
            (Aws.Xml.member "ComplianceLevel" xml)
            PatchComplianceLevel.parse
      ; approval_date =
          Aws.Util.option_bind (Aws.Xml.member "ApprovalDate" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.approval_date (fun f ->
               Aws.Query.Pair ("ApprovalDate", DateTime.to_query f))
         ; Aws.Util.option_map v.compliance_level (fun f ->
               Aws.Query.Pair ("ComplianceLevel", PatchComplianceLevel.to_query f))
         ; Aws.Util.option_map v.deployment_status (fun f ->
               Aws.Query.Pair ("DeploymentStatus", PatchDeploymentStatus.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.approval_date (fun f ->
               "ApprovalDate", DateTime.to_json f)
         ; Aws.Util.option_map v.compliance_level (fun f ->
               "ComplianceLevel", PatchComplianceLevel.to_json f)
         ; Aws.Util.option_map v.deployment_status (fun f ->
               "DeploymentStatus", PatchDeploymentStatus.to_json f)
         ])

  let of_json j =
    { deployment_status =
        Aws.Util.option_map
          (Aws.Json.lookup j "DeploymentStatus")
          PatchDeploymentStatus.of_json
    ; compliance_level =
        Aws.Util.option_map
          (Aws.Json.lookup j "ComplianceLevel")
          PatchComplianceLevel.of_json
    ; approval_date =
        Aws.Util.option_map (Aws.Json.lookup j "ApprovalDate") DateTime.of_json
    }
end

module PatchCVEIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module PatchBugzillaIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module PatchAdvisoryIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module Patch = struct
  type t =
    { id : String.t option
    ; release_date : DateTime.t option
    ; title : String.t option
    ; description : String.t option
    ; content_url : String.t option
    ; vendor : String.t option
    ; product_family : String.t option
    ; product : String.t option
    ; classification : String.t option
    ; msrc_severity : String.t option
    ; kb_number : String.t option
    ; msrc_number : String.t option
    ; language : String.t option
    ; advisory_ids : PatchAdvisoryIdList.t
    ; bugzilla_ids : PatchBugzillaIdList.t
    ; c_v_e_ids : PatchCVEIdList.t
    ; name : String.t option
    ; epoch : Integer.t option
    ; version : String.t option
    ; release : String.t option
    ; arch : String.t option
    ; severity : String.t option
    ; repository : String.t option
    }

  let make
      ?id
      ?release_date
      ?title
      ?description
      ?content_url
      ?vendor
      ?product_family
      ?product
      ?classification
      ?msrc_severity
      ?kb_number
      ?msrc_number
      ?language
      ?(advisory_ids = [])
      ?(bugzilla_ids = [])
      ?(c_v_e_ids = [])
      ?name
      ?epoch
      ?version
      ?release
      ?arch
      ?severity
      ?repository
      () =
    { id
    ; release_date
    ; title
    ; description
    ; content_url
    ; vendor
    ; product_family
    ; product
    ; classification
    ; msrc_severity
    ; kb_number
    ; msrc_number
    ; language
    ; advisory_ids
    ; bugzilla_ids
    ; c_v_e_ids
    ; name
    ; epoch
    ; version
    ; release
    ; arch
    ; severity
    ; repository
    }

  let parse xml =
    Some
      { id = Aws.Util.option_bind (Aws.Xml.member "Id" xml) String.parse
      ; release_date =
          Aws.Util.option_bind (Aws.Xml.member "ReleaseDate" xml) DateTime.parse
      ; title = Aws.Util.option_bind (Aws.Xml.member "Title" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; content_url = Aws.Util.option_bind (Aws.Xml.member "ContentUrl" xml) String.parse
      ; vendor = Aws.Util.option_bind (Aws.Xml.member "Vendor" xml) String.parse
      ; product_family =
          Aws.Util.option_bind (Aws.Xml.member "ProductFamily" xml) String.parse
      ; product = Aws.Util.option_bind (Aws.Xml.member "Product" xml) String.parse
      ; classification =
          Aws.Util.option_bind (Aws.Xml.member "Classification" xml) String.parse
      ; msrc_severity =
          Aws.Util.option_bind (Aws.Xml.member "MsrcSeverity" xml) String.parse
      ; kb_number = Aws.Util.option_bind (Aws.Xml.member "KbNumber" xml) String.parse
      ; msrc_number = Aws.Util.option_bind (Aws.Xml.member "MsrcNumber" xml) String.parse
      ; language = Aws.Util.option_bind (Aws.Xml.member "Language" xml) String.parse
      ; advisory_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AdvisoryIds" xml)
               PatchAdvisoryIdList.parse)
      ; bugzilla_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "BugzillaIds" xml)
               PatchBugzillaIdList.parse)
      ; c_v_e_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "CVEIds" xml) PatchCVEIdList.parse)
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; epoch = Aws.Util.option_bind (Aws.Xml.member "Epoch" xml) Integer.parse
      ; version = Aws.Util.option_bind (Aws.Xml.member "Version" xml) String.parse
      ; release = Aws.Util.option_bind (Aws.Xml.member "Release" xml) String.parse
      ; arch = Aws.Util.option_bind (Aws.Xml.member "Arch" xml) String.parse
      ; severity = Aws.Util.option_bind (Aws.Xml.member "Severity" xml) String.parse
      ; repository = Aws.Util.option_bind (Aws.Xml.member "Repository" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.repository (fun f ->
               Aws.Query.Pair ("Repository", String.to_query f))
         ; Aws.Util.option_map v.severity (fun f ->
               Aws.Query.Pair ("Severity", String.to_query f))
         ; Aws.Util.option_map v.arch (fun f ->
               Aws.Query.Pair ("Arch", String.to_query f))
         ; Aws.Util.option_map v.release (fun f ->
               Aws.Query.Pair ("Release", String.to_query f))
         ; Aws.Util.option_map v.version (fun f ->
               Aws.Query.Pair ("Version", String.to_query f))
         ; Aws.Util.option_map v.epoch (fun f ->
               Aws.Query.Pair ("Epoch", Integer.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Some (Aws.Query.Pair ("CVEIds.member", PatchCVEIdList.to_query v.c_v_e_ids))
         ; Some
             (Aws.Query.Pair
                ("BugzillaIds.member", PatchBugzillaIdList.to_query v.bugzilla_ids))
         ; Some
             (Aws.Query.Pair
                ("AdvisoryIds.member", PatchAdvisoryIdList.to_query v.advisory_ids))
         ; Aws.Util.option_map v.language (fun f ->
               Aws.Query.Pair ("Language", String.to_query f))
         ; Aws.Util.option_map v.msrc_number (fun f ->
               Aws.Query.Pair ("MsrcNumber", String.to_query f))
         ; Aws.Util.option_map v.kb_number (fun f ->
               Aws.Query.Pair ("KbNumber", String.to_query f))
         ; Aws.Util.option_map v.msrc_severity (fun f ->
               Aws.Query.Pair ("MsrcSeverity", String.to_query f))
         ; Aws.Util.option_map v.classification (fun f ->
               Aws.Query.Pair ("Classification", String.to_query f))
         ; Aws.Util.option_map v.product (fun f ->
               Aws.Query.Pair ("Product", String.to_query f))
         ; Aws.Util.option_map v.product_family (fun f ->
               Aws.Query.Pair ("ProductFamily", String.to_query f))
         ; Aws.Util.option_map v.vendor (fun f ->
               Aws.Query.Pair ("Vendor", String.to_query f))
         ; Aws.Util.option_map v.content_url (fun f ->
               Aws.Query.Pair ("ContentUrl", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.title (fun f ->
               Aws.Query.Pair ("Title", String.to_query f))
         ; Aws.Util.option_map v.release_date (fun f ->
               Aws.Query.Pair ("ReleaseDate", DateTime.to_query f))
         ; Aws.Util.option_map v.id (fun f -> Aws.Query.Pair ("Id", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.repository (fun f -> "Repository", String.to_json f)
         ; Aws.Util.option_map v.severity (fun f -> "Severity", String.to_json f)
         ; Aws.Util.option_map v.arch (fun f -> "Arch", String.to_json f)
         ; Aws.Util.option_map v.release (fun f -> "Release", String.to_json f)
         ; Aws.Util.option_map v.version (fun f -> "Version", String.to_json f)
         ; Aws.Util.option_map v.epoch (fun f -> "Epoch", Integer.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Some ("CVEIds", PatchCVEIdList.to_json v.c_v_e_ids)
         ; Some ("BugzillaIds", PatchBugzillaIdList.to_json v.bugzilla_ids)
         ; Some ("AdvisoryIds", PatchAdvisoryIdList.to_json v.advisory_ids)
         ; Aws.Util.option_map v.language (fun f -> "Language", String.to_json f)
         ; Aws.Util.option_map v.msrc_number (fun f -> "MsrcNumber", String.to_json f)
         ; Aws.Util.option_map v.kb_number (fun f -> "KbNumber", String.to_json f)
         ; Aws.Util.option_map v.msrc_severity (fun f -> "MsrcSeverity", String.to_json f)
         ; Aws.Util.option_map v.classification (fun f ->
               "Classification", String.to_json f)
         ; Aws.Util.option_map v.product (fun f -> "Product", String.to_json f)
         ; Aws.Util.option_map v.product_family (fun f ->
               "ProductFamily", String.to_json f)
         ; Aws.Util.option_map v.vendor (fun f -> "Vendor", String.to_json f)
         ; Aws.Util.option_map v.content_url (fun f -> "ContentUrl", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.title (fun f -> "Title", String.to_json f)
         ; Aws.Util.option_map v.release_date (fun f -> "ReleaseDate", DateTime.to_json f)
         ; Aws.Util.option_map v.id (fun f -> "Id", String.to_json f)
         ])

  let of_json j =
    { id = Aws.Util.option_map (Aws.Json.lookup j "Id") String.of_json
    ; release_date =
        Aws.Util.option_map (Aws.Json.lookup j "ReleaseDate") DateTime.of_json
    ; title = Aws.Util.option_map (Aws.Json.lookup j "Title") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; content_url = Aws.Util.option_map (Aws.Json.lookup j "ContentUrl") String.of_json
    ; vendor = Aws.Util.option_map (Aws.Json.lookup j "Vendor") String.of_json
    ; product_family =
        Aws.Util.option_map (Aws.Json.lookup j "ProductFamily") String.of_json
    ; product = Aws.Util.option_map (Aws.Json.lookup j "Product") String.of_json
    ; classification =
        Aws.Util.option_map (Aws.Json.lookup j "Classification") String.of_json
    ; msrc_severity =
        Aws.Util.option_map (Aws.Json.lookup j "MsrcSeverity") String.of_json
    ; kb_number = Aws.Util.option_map (Aws.Json.lookup j "KbNumber") String.of_json
    ; msrc_number = Aws.Util.option_map (Aws.Json.lookup j "MsrcNumber") String.of_json
    ; language = Aws.Util.option_map (Aws.Json.lookup j "Language") String.of_json
    ; advisory_ids =
        PatchAdvisoryIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AdvisoryIds"))
    ; bugzilla_ids =
        PatchBugzillaIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "BugzillaIds"))
    ; c_v_e_ids =
        PatchCVEIdList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "CVEIds"))
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; epoch = Aws.Util.option_map (Aws.Json.lookup j "Epoch") Integer.of_json
    ; version = Aws.Util.option_map (Aws.Json.lookup j "Version") String.of_json
    ; release = Aws.Util.option_map (Aws.Json.lookup j "Release") String.of_json
    ; arch = Aws.Util.option_map (Aws.Json.lookup j "Arch") String.of_json
    ; severity = Aws.Util.option_map (Aws.Json.lookup j "Severity") String.of_json
    ; repository = Aws.Util.option_map (Aws.Json.lookup j "Repository") String.of_json
    }
end

module EffectivePatch = struct
  type t =
    { patch : Patch.t option
    ; patch_status : PatchStatus.t option
    }

  let make ?patch ?patch_status () = { patch; patch_status }

  let parse xml =
    Some
      { patch = Aws.Util.option_bind (Aws.Xml.member "Patch" xml) Patch.parse
      ; patch_status =
          Aws.Util.option_bind (Aws.Xml.member "PatchStatus" xml) PatchStatus.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.patch_status (fun f ->
               Aws.Query.Pair ("PatchStatus", PatchStatus.to_query f))
         ; Aws.Util.option_map v.patch (fun f ->
               Aws.Query.Pair ("Patch", Patch.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.patch_status (fun f ->
               "PatchStatus", PatchStatus.to_json f)
         ; Aws.Util.option_map v.patch (fun f -> "Patch", Patch.to_json f)
         ])

  let of_json j =
    { patch = Aws.Util.option_map (Aws.Json.lookup j "Patch") Patch.of_json
    ; patch_status =
        Aws.Util.option_map (Aws.Json.lookup j "PatchStatus") PatchStatus.of_json
    }
end

module EffectivePatchList = struct
  type t = EffectivePatch.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map EffectivePatch.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list EffectivePatch.to_query v
  let to_json v = `List (List.map EffectivePatch.to_json v)
  let of_json j = Aws.Json.to_list EffectivePatch.of_json j
end

module DescribeEffectivePatchesForPatchBaselineResult = struct
  type t =
    { effective_patches : EffectivePatchList.t
    ; next_token : String.t option
    }

  let make ?(effective_patches = []) ?next_token () = { effective_patches; next_token }

  let parse xml =
    Some
      { effective_patches =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "EffectivePatches" xml)
               EffectivePatchList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "EffectivePatches.member"
                , EffectivePatchList.to_query v.effective_patches ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("EffectivePatches", EffectivePatchList.to_json v.effective_patches)
         ])

  let of_json j =
    { effective_patches =
        EffectivePatchList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "EffectivePatches"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module SessionManagerParameterValueList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module SessionManagerParameters = struct
  type t = (String.t, SessionManagerParameterValueList.t) Hashtbl.t

  let make elems () = elems
  let parse xml = None

  let to_query v =
    Aws.Query.to_query_hashtbl
      String.to_string
      SessionManagerParameterValueList.to_query
      v

  let to_json v =
    `Assoc
      (Hashtbl.fold
         (fun k v acc ->
           (String.to_string k, SessionManagerParameterValueList.to_json v) :: acc)
         v
         [])

  let of_json j =
    Aws.Json.to_hashtbl String.of_string SessionManagerParameterValueList.of_json j
end

module StartSessionRequest = struct
  type t =
    { target : String.t
    ; document_name : String.t option
    ; parameters : SessionManagerParameters.t option
    }

  let make ~target ?document_name ?parameters () = { target; document_name; parameters }

  let parse xml =
    Some
      { target =
          Aws.Xml.required
            "Target"
            (Aws.Util.option_bind (Aws.Xml.member "Target" xml) String.parse)
      ; document_name =
          Aws.Util.option_bind (Aws.Xml.member "DocumentName" xml) String.parse
      ; parameters =
          Aws.Util.option_bind
            (Aws.Xml.member "Parameters" xml)
            SessionManagerParameters.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.parameters (fun f ->
               Aws.Query.Pair ("Parameters", SessionManagerParameters.to_query f))
         ; Aws.Util.option_map v.document_name (fun f ->
               Aws.Query.Pair ("DocumentName", String.to_query f))
         ; Some (Aws.Query.Pair ("Target", String.to_query v.target))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.parameters (fun f ->
               "Parameters", SessionManagerParameters.to_json f)
         ; Aws.Util.option_map v.document_name (fun f -> "DocumentName", String.to_json f)
         ; Some ("Target", String.to_json v.target)
         ])

  let of_json j =
    { target = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Target"))
    ; document_name =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentName") String.of_json
    ; parameters =
        Aws.Util.option_map
          (Aws.Json.lookup j "Parameters")
          SessionManagerParameters.of_json
    }
end

module SignalType = struct
  type t =
    | Approve
    | Reject
    | StartStep
    | StopStep
    | Resume

  let str_to_t =
    [ "Resume", Resume
    ; "StopStep", StopStep
    ; "StartStep", StartStep
    ; "Reject", Reject
    ; "Approve", Approve
    ]

  let t_to_str =
    [ Resume, "Resume"
    ; StopStep, "StopStep"
    ; StartStep, "StartStep"
    ; Reject, "Reject"
    ; Approve, "Approve"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module GetDefaultPatchBaselineRequest = struct
  type t = { operating_system : OperatingSystem.t option }

  let make ?operating_system () = { operating_system }

  let parse xml =
    Some
      { operating_system =
          Aws.Util.option_bind
            (Aws.Xml.member "OperatingSystem" xml)
            OperatingSystem.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.operating_system (fun f ->
               Aws.Query.Pair ("OperatingSystem", OperatingSystem.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.operating_system (fun f ->
               "OperatingSystem", OperatingSystem.to_json f)
         ])

  let of_json j =
    { operating_system =
        Aws.Util.option_map (Aws.Json.lookup j "OperatingSystem") OperatingSystem.of_json
    }
end

module ParameterVersionNotFound = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json }
end

module DescribeMaintenanceWindowExecutionTaskInvocationsRequest = struct
  type t =
    { window_execution_id : String.t
    ; task_id : String.t
    ; filters : MaintenanceWindowFilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ~window_execution_id ~task_id ?(filters = []) ?max_results ?next_token () =
    { window_execution_id; task_id; filters; max_results; next_token }

  let parse xml =
    Some
      { window_execution_id =
          Aws.Xml.required
            "WindowExecutionId"
            (Aws.Util.option_bind (Aws.Xml.member "WindowExecutionId" xml) String.parse)
      ; task_id =
          Aws.Xml.required
            "TaskId"
            (Aws.Util.option_bind (Aws.Xml.member "TaskId" xml) String.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               MaintenanceWindowFilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Filters.member", MaintenanceWindowFilterList.to_query v.filters))
         ; Some (Aws.Query.Pair ("TaskId", String.to_query v.task_id))
         ; Some
             (Aws.Query.Pair ("WindowExecutionId", String.to_query v.window_execution_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filters", MaintenanceWindowFilterList.to_json v.filters)
         ; Some ("TaskId", String.to_json v.task_id)
         ; Some ("WindowExecutionId", String.to_json v.window_execution_id)
         ])

  let of_json j =
    { window_execution_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowExecutionId"))
    ; task_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TaskId"))
    ; filters =
        MaintenanceWindowFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module PatchPropertyEntry = struct
  type t = (String.t, String.t) Hashtbl.t

  let make elems () = elems
  let parse xml = None
  let to_query v = Aws.Query.to_query_hashtbl String.to_string String.to_query v

  let to_json v =
    `Assoc
      (Hashtbl.fold (fun k v acc -> (String.to_string k, String.to_json v) :: acc) v [])

  let of_json j = Aws.Json.to_hashtbl String.of_string String.of_json j
end

module CalendarNameOrARNList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module GetCalendarStateRequest = struct
  type t =
    { calendar_names : CalendarNameOrARNList.t
    ; at_time : String.t option
    }

  let make ~calendar_names ?at_time () = { calendar_names; at_time }

  let parse xml =
    Some
      { calendar_names =
          Aws.Xml.required
            "CalendarNames"
            (Aws.Util.option_bind
               (Aws.Xml.member "CalendarNames" xml)
               CalendarNameOrARNList.parse)
      ; at_time = Aws.Util.option_bind (Aws.Xml.member "AtTime" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.at_time (fun f ->
               Aws.Query.Pair ("AtTime", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("CalendarNames.member", CalendarNameOrARNList.to_query v.calendar_names))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.at_time (fun f -> "AtTime", String.to_json f)
         ; Some ("CalendarNames", CalendarNameOrARNList.to_json v.calendar_names)
         ])

  let of_json j =
    { calendar_names =
        CalendarNameOrARNList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "CalendarNames"))
    ; at_time = Aws.Util.option_map (Aws.Json.lookup j "AtTime") String.of_json
    }
end

module ComplianceSummaryItem = struct
  type t =
    { compliance_type : String.t option
    ; compliant_summary : CompliantSummary.t option
    ; non_compliant_summary : NonCompliantSummary.t option
    }

  let make ?compliance_type ?compliant_summary ?non_compliant_summary () =
    { compliance_type; compliant_summary; non_compliant_summary }

  let parse xml =
    Some
      { compliance_type =
          Aws.Util.option_bind (Aws.Xml.member "ComplianceType" xml) String.parse
      ; compliant_summary =
          Aws.Util.option_bind
            (Aws.Xml.member "CompliantSummary" xml)
            CompliantSummary.parse
      ; non_compliant_summary =
          Aws.Util.option_bind
            (Aws.Xml.member "NonCompliantSummary" xml)
            NonCompliantSummary.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.non_compliant_summary (fun f ->
               Aws.Query.Pair ("NonCompliantSummary", NonCompliantSummary.to_query f))
         ; Aws.Util.option_map v.compliant_summary (fun f ->
               Aws.Query.Pair ("CompliantSummary", CompliantSummary.to_query f))
         ; Aws.Util.option_map v.compliance_type (fun f ->
               Aws.Query.Pair ("ComplianceType", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.non_compliant_summary (fun f ->
               "NonCompliantSummary", NonCompliantSummary.to_json f)
         ; Aws.Util.option_map v.compliant_summary (fun f ->
               "CompliantSummary", CompliantSummary.to_json f)
         ; Aws.Util.option_map v.compliance_type (fun f ->
               "ComplianceType", String.to_json f)
         ])

  let of_json j =
    { compliance_type =
        Aws.Util.option_map (Aws.Json.lookup j "ComplianceType") String.of_json
    ; compliant_summary =
        Aws.Util.option_map
          (Aws.Json.lookup j "CompliantSummary")
          CompliantSummary.of_json
    ; non_compliant_summary =
        Aws.Util.option_map
          (Aws.Json.lookup j "NonCompliantSummary")
          NonCompliantSummary.of_json
    }
end

module ComplianceSummaryItemList = struct
  type t = ComplianceSummaryItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ComplianceSummaryItem.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list ComplianceSummaryItem.to_query v
  let to_json v = `List (List.map ComplianceSummaryItem.to_json v)
  let of_json j = Aws.Json.to_list ComplianceSummaryItem.of_json j
end

module ListComplianceSummariesResult = struct
  type t =
    { compliance_summary_items : ComplianceSummaryItemList.t
    ; next_token : String.t option
    }

  let make ?(compliance_summary_items = []) ?next_token () =
    { compliance_summary_items; next_token }

  let parse xml =
    Some
      { compliance_summary_items =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ComplianceSummaryItems" xml)
               ComplianceSummaryItemList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ComplianceSummaryItems.member"
                , ComplianceSummaryItemList.to_query v.compliance_summary_items ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some
             ( "ComplianceSummaryItems"
             , ComplianceSummaryItemList.to_json v.compliance_summary_items )
         ])

  let of_json j =
    { compliance_summary_items =
        ComplianceSummaryItemList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ComplianceSummaryItems"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module AutomationExecutionFilterKey = struct
  type t =
    | DocumentNamePrefix
    | ExecutionStatus
    | ExecutionId
    | ParentExecutionId
    | CurrentAction
    | StartTimeBefore
    | StartTimeAfter
    | AutomationType
    | TagKey
    | TargetResourceGroup

  let str_to_t =
    [ "TargetResourceGroup", TargetResourceGroup
    ; "TagKey", TagKey
    ; "AutomationType", AutomationType
    ; "StartTimeAfter", StartTimeAfter
    ; "StartTimeBefore", StartTimeBefore
    ; "CurrentAction", CurrentAction
    ; "ParentExecutionId", ParentExecutionId
    ; "ExecutionId", ExecutionId
    ; "ExecutionStatus", ExecutionStatus
    ; "DocumentNamePrefix", DocumentNamePrefix
    ]

  let t_to_str =
    [ TargetResourceGroup, "TargetResourceGroup"
    ; TagKey, "TagKey"
    ; AutomationType, "AutomationType"
    ; StartTimeAfter, "StartTimeAfter"
    ; StartTimeBefore, "StartTimeBefore"
    ; CurrentAction, "CurrentAction"
    ; ParentExecutionId, "ParentExecutionId"
    ; ExecutionId, "ExecutionId"
    ; ExecutionStatus, "ExecutionStatus"
    ; DocumentNamePrefix, "DocumentNamePrefix"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module CreatePatchBaselineResult = struct
  type t = { baseline_id : String.t option }

  let make ?baseline_id () = { baseline_id }

  let parse xml =
    Some
      { baseline_id = Aws.Util.option_bind (Aws.Xml.member "BaselineId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.baseline_id (fun f ->
               Aws.Query.Pair ("BaselineId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.baseline_id (fun f -> "BaselineId", String.to_json f) ])

  let of_json j =
    { baseline_id = Aws.Util.option_map (Aws.Json.lookup j "BaselineId") String.of_json }
end

module UpdateMaintenanceWindowRequest = struct
  type t =
    { window_id : String.t
    ; name : String.t option
    ; description : String.t option
    ; start_date : String.t option
    ; end_date : String.t option
    ; schedule : String.t option
    ; schedule_timezone : String.t option
    ; schedule_offset : Integer.t option
    ; duration : Integer.t option
    ; cutoff : Integer.t option
    ; allow_unassociated_targets : Boolean.t option
    ; enabled : Boolean.t option
    ; replace : Boolean.t option
    }

  let make
      ~window_id
      ?name
      ?description
      ?start_date
      ?end_date
      ?schedule
      ?schedule_timezone
      ?schedule_offset
      ?duration
      ?cutoff
      ?allow_unassociated_targets
      ?enabled
      ?replace
      () =
    { window_id
    ; name
    ; description
    ; start_date
    ; end_date
    ; schedule
    ; schedule_timezone
    ; schedule_offset
    ; duration
    ; cutoff
    ; allow_unassociated_targets
    ; enabled
    ; replace
    }

  let parse xml =
    Some
      { window_id =
          Aws.Xml.required
            "WindowId"
            (Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse)
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; start_date = Aws.Util.option_bind (Aws.Xml.member "StartDate" xml) String.parse
      ; end_date = Aws.Util.option_bind (Aws.Xml.member "EndDate" xml) String.parse
      ; schedule = Aws.Util.option_bind (Aws.Xml.member "Schedule" xml) String.parse
      ; schedule_timezone =
          Aws.Util.option_bind (Aws.Xml.member "ScheduleTimezone" xml) String.parse
      ; schedule_offset =
          Aws.Util.option_bind (Aws.Xml.member "ScheduleOffset" xml) Integer.parse
      ; duration = Aws.Util.option_bind (Aws.Xml.member "Duration" xml) Integer.parse
      ; cutoff = Aws.Util.option_bind (Aws.Xml.member "Cutoff" xml) Integer.parse
      ; allow_unassociated_targets =
          Aws.Util.option_bind
            (Aws.Xml.member "AllowUnassociatedTargets" xml)
            Boolean.parse
      ; enabled = Aws.Util.option_bind (Aws.Xml.member "Enabled" xml) Boolean.parse
      ; replace = Aws.Util.option_bind (Aws.Xml.member "Replace" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.replace (fun f ->
               Aws.Query.Pair ("Replace", Boolean.to_query f))
         ; Aws.Util.option_map v.enabled (fun f ->
               Aws.Query.Pair ("Enabled", Boolean.to_query f))
         ; Aws.Util.option_map v.allow_unassociated_targets (fun f ->
               Aws.Query.Pair ("AllowUnassociatedTargets", Boolean.to_query f))
         ; Aws.Util.option_map v.cutoff (fun f ->
               Aws.Query.Pair ("Cutoff", Integer.to_query f))
         ; Aws.Util.option_map v.duration (fun f ->
               Aws.Query.Pair ("Duration", Integer.to_query f))
         ; Aws.Util.option_map v.schedule_offset (fun f ->
               Aws.Query.Pair ("ScheduleOffset", Integer.to_query f))
         ; Aws.Util.option_map v.schedule_timezone (fun f ->
               Aws.Query.Pair ("ScheduleTimezone", String.to_query f))
         ; Aws.Util.option_map v.schedule (fun f ->
               Aws.Query.Pair ("Schedule", String.to_query f))
         ; Aws.Util.option_map v.end_date (fun f ->
               Aws.Query.Pair ("EndDate", String.to_query f))
         ; Aws.Util.option_map v.start_date (fun f ->
               Aws.Query.Pair ("StartDate", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Some (Aws.Query.Pair ("WindowId", String.to_query v.window_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.replace (fun f -> "Replace", Boolean.to_json f)
         ; Aws.Util.option_map v.enabled (fun f -> "Enabled", Boolean.to_json f)
         ; Aws.Util.option_map v.allow_unassociated_targets (fun f ->
               "AllowUnassociatedTargets", Boolean.to_json f)
         ; Aws.Util.option_map v.cutoff (fun f -> "Cutoff", Integer.to_json f)
         ; Aws.Util.option_map v.duration (fun f -> "Duration", Integer.to_json f)
         ; Aws.Util.option_map v.schedule_offset (fun f ->
               "ScheduleOffset", Integer.to_json f)
         ; Aws.Util.option_map v.schedule_timezone (fun f ->
               "ScheduleTimezone", String.to_json f)
         ; Aws.Util.option_map v.schedule (fun f -> "Schedule", String.to_json f)
         ; Aws.Util.option_map v.end_date (fun f -> "EndDate", String.to_json f)
         ; Aws.Util.option_map v.start_date (fun f -> "StartDate", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Some ("WindowId", String.to_json v.window_id)
         ])

  let of_json j =
    { window_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowId"))
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; start_date = Aws.Util.option_map (Aws.Json.lookup j "StartDate") String.of_json
    ; end_date = Aws.Util.option_map (Aws.Json.lookup j "EndDate") String.of_json
    ; schedule = Aws.Util.option_map (Aws.Json.lookup j "Schedule") String.of_json
    ; schedule_timezone =
        Aws.Util.option_map (Aws.Json.lookup j "ScheduleTimezone") String.of_json
    ; schedule_offset =
        Aws.Util.option_map (Aws.Json.lookup j "ScheduleOffset") Integer.of_json
    ; duration = Aws.Util.option_map (Aws.Json.lookup j "Duration") Integer.of_json
    ; cutoff = Aws.Util.option_map (Aws.Json.lookup j "Cutoff") Integer.of_json
    ; allow_unassociated_targets =
        Aws.Util.option_map (Aws.Json.lookup j "AllowUnassociatedTargets") Boolean.of_json
    ; enabled = Aws.Util.option_map (Aws.Json.lookup j "Enabled") Boolean.of_json
    ; replace = Aws.Util.option_map (Aws.Json.lookup j "Replace") Boolean.of_json
    }
end

module RegisterTargetWithMaintenanceWindowResult = struct
  type t = { window_target_id : String.t option }

  let make ?window_target_id () = { window_target_id }

  let parse xml =
    Some
      { window_target_id =
          Aws.Util.option_bind (Aws.Xml.member "WindowTargetId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.window_target_id (fun f ->
               Aws.Query.Pair ("WindowTargetId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.window_target_id (fun f ->
               "WindowTargetId", String.to_json f)
         ])

  let of_json j =
    { window_target_id =
        Aws.Util.option_map (Aws.Json.lookup j "WindowTargetId") String.of_json
    }
end

module ListDocumentVersionsRequest = struct
  type t =
    { name : String.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ~name ?max_results ?next_token () = { name; max_results; next_token }

  let parse xml =
    Some
      { name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Name", String.to_json v.name)
         ])

  let of_json j =
    { name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module UnsupportedParameterType = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json }
end

module InvalidFilterKey = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module AssociationVersionInfo = struct
  type t =
    { association_id : String.t option
    ; association_version : String.t option
    ; created_date : DateTime.t option
    ; name : String.t option
    ; document_version : String.t option
    ; parameters : Parameters.t option
    ; targets : Targets.t
    ; schedule_expression : String.t option
    ; output_location : InstanceAssociationOutputLocation.t option
    ; association_name : String.t option
    ; max_errors : String.t option
    ; max_concurrency : String.t option
    ; compliance_severity : AssociationComplianceSeverity.t option
    ; sync_compliance : AssociationSyncCompliance.t option
    ; apply_only_at_cron_interval : Boolean.t option
    }

  let make
      ?association_id
      ?association_version
      ?created_date
      ?name
      ?document_version
      ?parameters
      ?(targets = [])
      ?schedule_expression
      ?output_location
      ?association_name
      ?max_errors
      ?max_concurrency
      ?compliance_severity
      ?sync_compliance
      ?apply_only_at_cron_interval
      () =
    { association_id
    ; association_version
    ; created_date
    ; name
    ; document_version
    ; parameters
    ; targets
    ; schedule_expression
    ; output_location
    ; association_name
    ; max_errors
    ; max_concurrency
    ; compliance_severity
    ; sync_compliance
    ; apply_only_at_cron_interval
    }

  let parse xml =
    Some
      { association_id =
          Aws.Util.option_bind (Aws.Xml.member "AssociationId" xml) String.parse
      ; association_version =
          Aws.Util.option_bind (Aws.Xml.member "AssociationVersion" xml) String.parse
      ; created_date =
          Aws.Util.option_bind (Aws.Xml.member "CreatedDate" xml) DateTime.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; document_version =
          Aws.Util.option_bind (Aws.Xml.member "DocumentVersion" xml) String.parse
      ; parameters =
          Aws.Util.option_bind (Aws.Xml.member "Parameters" xml) Parameters.parse
      ; targets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Targets" xml) Targets.parse)
      ; schedule_expression =
          Aws.Util.option_bind (Aws.Xml.member "ScheduleExpression" xml) String.parse
      ; output_location =
          Aws.Util.option_bind
            (Aws.Xml.member "OutputLocation" xml)
            InstanceAssociationOutputLocation.parse
      ; association_name =
          Aws.Util.option_bind (Aws.Xml.member "AssociationName" xml) String.parse
      ; max_errors = Aws.Util.option_bind (Aws.Xml.member "MaxErrors" xml) String.parse
      ; max_concurrency =
          Aws.Util.option_bind (Aws.Xml.member "MaxConcurrency" xml) String.parse
      ; compliance_severity =
          Aws.Util.option_bind
            (Aws.Xml.member "ComplianceSeverity" xml)
            AssociationComplianceSeverity.parse
      ; sync_compliance =
          Aws.Util.option_bind
            (Aws.Xml.member "SyncCompliance" xml)
            AssociationSyncCompliance.parse
      ; apply_only_at_cron_interval =
          Aws.Util.option_bind
            (Aws.Xml.member "ApplyOnlyAtCronInterval" xml)
            Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.apply_only_at_cron_interval (fun f ->
               Aws.Query.Pair ("ApplyOnlyAtCronInterval", Boolean.to_query f))
         ; Aws.Util.option_map v.sync_compliance (fun f ->
               Aws.Query.Pair ("SyncCompliance", AssociationSyncCompliance.to_query f))
         ; Aws.Util.option_map v.compliance_severity (fun f ->
               Aws.Query.Pair
                 ("ComplianceSeverity", AssociationComplianceSeverity.to_query f))
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               Aws.Query.Pair ("MaxConcurrency", String.to_query f))
         ; Aws.Util.option_map v.max_errors (fun f ->
               Aws.Query.Pair ("MaxErrors", String.to_query f))
         ; Aws.Util.option_map v.association_name (fun f ->
               Aws.Query.Pair ("AssociationName", String.to_query f))
         ; Aws.Util.option_map v.output_location (fun f ->
               Aws.Query.Pair
                 ("OutputLocation", InstanceAssociationOutputLocation.to_query f))
         ; Aws.Util.option_map v.schedule_expression (fun f ->
               Aws.Query.Pair ("ScheduleExpression", String.to_query f))
         ; Some (Aws.Query.Pair ("Targets.member", Targets.to_query v.targets))
         ; Aws.Util.option_map v.parameters (fun f ->
               Aws.Query.Pair ("Parameters", Parameters.to_query f))
         ; Aws.Util.option_map v.document_version (fun f ->
               Aws.Query.Pair ("DocumentVersion", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.created_date (fun f ->
               Aws.Query.Pair ("CreatedDate", DateTime.to_query f))
         ; Aws.Util.option_map v.association_version (fun f ->
               Aws.Query.Pair ("AssociationVersion", String.to_query f))
         ; Aws.Util.option_map v.association_id (fun f ->
               Aws.Query.Pair ("AssociationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.apply_only_at_cron_interval (fun f ->
               "ApplyOnlyAtCronInterval", Boolean.to_json f)
         ; Aws.Util.option_map v.sync_compliance (fun f ->
               "SyncCompliance", AssociationSyncCompliance.to_json f)
         ; Aws.Util.option_map v.compliance_severity (fun f ->
               "ComplianceSeverity", AssociationComplianceSeverity.to_json f)
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               "MaxConcurrency", String.to_json f)
         ; Aws.Util.option_map v.max_errors (fun f -> "MaxErrors", String.to_json f)
         ; Aws.Util.option_map v.association_name (fun f ->
               "AssociationName", String.to_json f)
         ; Aws.Util.option_map v.output_location (fun f ->
               "OutputLocation", InstanceAssociationOutputLocation.to_json f)
         ; Aws.Util.option_map v.schedule_expression (fun f ->
               "ScheduleExpression", String.to_json f)
         ; Some ("Targets", Targets.to_json v.targets)
         ; Aws.Util.option_map v.parameters (fun f -> "Parameters", Parameters.to_json f)
         ; Aws.Util.option_map v.document_version (fun f ->
               "DocumentVersion", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.created_date (fun f -> "CreatedDate", DateTime.to_json f)
         ; Aws.Util.option_map v.association_version (fun f ->
               "AssociationVersion", String.to_json f)
         ; Aws.Util.option_map v.association_id (fun f ->
               "AssociationId", String.to_json f)
         ])

  let of_json j =
    { association_id =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationId") String.of_json
    ; association_version =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationVersion") String.of_json
    ; created_date =
        Aws.Util.option_map (Aws.Json.lookup j "CreatedDate") DateTime.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; document_version =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentVersion") String.of_json
    ; parameters = Aws.Util.option_map (Aws.Json.lookup j "Parameters") Parameters.of_json
    ; targets = Targets.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Targets"))
    ; schedule_expression =
        Aws.Util.option_map (Aws.Json.lookup j "ScheduleExpression") String.of_json
    ; output_location =
        Aws.Util.option_map
          (Aws.Json.lookup j "OutputLocation")
          InstanceAssociationOutputLocation.of_json
    ; association_name =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationName") String.of_json
    ; max_errors = Aws.Util.option_map (Aws.Json.lookup j "MaxErrors") String.of_json
    ; max_concurrency =
        Aws.Util.option_map (Aws.Json.lookup j "MaxConcurrency") String.of_json
    ; compliance_severity =
        Aws.Util.option_map
          (Aws.Json.lookup j "ComplianceSeverity")
          AssociationComplianceSeverity.of_json
    ; sync_compliance =
        Aws.Util.option_map
          (Aws.Json.lookup j "SyncCompliance")
          AssociationSyncCompliance.of_json
    ; apply_only_at_cron_interval =
        Aws.Util.option_map (Aws.Json.lookup j "ApplyOnlyAtCronInterval") Boolean.of_json
    }
end

module AssociationVersionList = struct
  type t = AssociationVersionInfo.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map AssociationVersionInfo.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list AssociationVersionInfo.to_query v
  let to_json v = `List (List.map AssociationVersionInfo.to_json v)
  let of_json j = Aws.Json.to_list AssociationVersionInfo.of_json j
end

module ListAssociationVersionsResult = struct
  type t =
    { association_versions : AssociationVersionList.t
    ; next_token : String.t option
    }

  let make ?(association_versions = []) ?next_token () =
    { association_versions; next_token }

  let parse xml =
    Some
      { association_versions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AssociationVersions" xml)
               AssociationVersionList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "AssociationVersions.member"
                , AssociationVersionList.to_query v.association_versions ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some
             ("AssociationVersions", AssociationVersionList.to_json v.association_versions)
         ])

  let of_json j =
    { association_versions =
        AssociationVersionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AssociationVersions"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module DocumentKeyValuesFilterList = struct
  type t = DocumentKeyValuesFilter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map DocumentKeyValuesFilter.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list DocumentKeyValuesFilter.to_query v
  let to_json v = `List (List.map DocumentKeyValuesFilter.to_json v)
  let of_json j = Aws.Json.to_list DocumentKeyValuesFilter.of_json j
end

module DocumentFilterKey = struct
  type t =
    | Name
    | Owner
    | PlatformTypes
    | DocumentType

  let str_to_t =
    [ "DocumentType", DocumentType
    ; "PlatformTypes", PlatformTypes
    ; "Owner", Owner
    ; "Name", Name
    ]

  let t_to_str =
    [ DocumentType, "DocumentType"
    ; PlatformTypes, "PlatformTypes"
    ; Owner, "Owner"
    ; Name, "Name"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DocumentFilter = struct
  type t =
    { key : DocumentFilterKey.t
    ; value : String.t
    }

  let make ~key ~value () = { key; value }

  let parse xml =
    Some
      { key =
          Aws.Xml.required
            "key"
            (Aws.Util.option_bind (Aws.Xml.member "key" xml) DocumentFilterKey.parse)
      ; value =
          Aws.Xml.required
            "value"
            (Aws.Util.option_bind (Aws.Xml.member "value" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("value", String.to_query v.value))
         ; Some (Aws.Query.Pair ("key", DocumentFilterKey.to_query v.key))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("value", String.to_json v.value)
         ; Some ("key", DocumentFilterKey.to_json v.key)
         ])

  let of_json j =
    { key = DocumentFilterKey.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "key"))
    ; value = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "value"))
    }
end

module DocumentFilterList = struct
  type t = DocumentFilter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map DocumentFilter.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list DocumentFilter.to_query v
  let to_json v = `List (List.map DocumentFilter.to_json v)
  let of_json j = Aws.Json.to_list DocumentFilter.of_json j
end

module ListDocumentsRequest = struct
  type t =
    { document_filter_list : DocumentFilterList.t
    ; filters : DocumentKeyValuesFilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?(document_filter_list = []) ?(filters = []) ?max_results ?next_token () =
    { document_filter_list; filters; max_results; next_token }

  let parse xml =
    Some
      { document_filter_list =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DocumentFilterList" xml)
               DocumentFilterList.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               DocumentKeyValuesFilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Filters.member", DocumentKeyValuesFilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ( "DocumentFilterList.member"
                , DocumentFilterList.to_query v.document_filter_list ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filters", DocumentKeyValuesFilterList.to_json v.filters)
         ; Some ("DocumentFilterList", DocumentFilterList.to_json v.document_filter_list)
         ])

  let of_json j =
    { document_filter_list =
        DocumentFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DocumentFilterList"))
    ; filters =
        DocumentKeyValuesFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module ResultAttribute = struct
  type t = { type_name : String.t }

  let make ~type_name () = { type_name }

  let parse xml =
    Some
      { type_name =
          Aws.Xml.required
            "TypeName"
            (Aws.Util.option_bind (Aws.Xml.member "TypeName" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TypeName", String.to_query v.type_name)) ])

  let to_json v =
    `Assoc (Aws.Util.list_filter_opt [ Some ("TypeName", String.to_json v.type_name) ])

  let of_json j =
    { type_name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TypeName")) }
end

module ResultAttributeList = struct
  type t = ResultAttribute.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ResultAttribute.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list ResultAttribute.to_query v
  let to_json v = `List (List.map ResultAttribute.to_json v)
  let of_json j = Aws.Json.to_list ResultAttribute.of_json j
end

module AutomationStepNotFoundException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module PutParameterResult = struct
  type t =
    { version : Long.t option
    ; tier : ParameterTier.t option
    }

  let make ?version ?tier () = { version; tier }

  let parse xml =
    Some
      { version = Aws.Util.option_bind (Aws.Xml.member "Version" xml) Long.parse
      ; tier = Aws.Util.option_bind (Aws.Xml.member "Tier" xml) ParameterTier.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.tier (fun f ->
               Aws.Query.Pair ("Tier", ParameterTier.to_query f))
         ; Aws.Util.option_map v.version (fun f ->
               Aws.Query.Pair ("Version", Long.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.tier (fun f -> "Tier", ParameterTier.to_json f)
         ; Aws.Util.option_map v.version (fun f -> "Version", Long.to_json f)
         ])

  let of_json j =
    { version = Aws.Util.option_map (Aws.Json.lookup j "Version") Long.of_json
    ; tier = Aws.Util.option_map (Aws.Json.lookup j "Tier") ParameterTier.of_json
    }
end

module PatchComplianceDataList = struct
  type t = PatchComplianceData.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map PatchComplianceData.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list PatchComplianceData.to_query v
  let to_json v = `List (List.map PatchComplianceData.to_json v)
  let of_json j = Aws.Json.to_list PatchComplianceData.of_json j
end

module DescribeAssociationRequest = struct
  type t =
    { name : String.t option
    ; instance_id : String.t option
    ; association_id : String.t option
    ; association_version : String.t option
    }

  let make ?name ?instance_id ?association_id ?association_version () =
    { name; instance_id; association_id; association_version }

  let parse xml =
    Some
      { name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse
      ; association_id =
          Aws.Util.option_bind (Aws.Xml.member "AssociationId" xml) String.parse
      ; association_version =
          Aws.Util.option_bind (Aws.Xml.member "AssociationVersion" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_version (fun f ->
               Aws.Query.Pair ("AssociationVersion", String.to_query f))
         ; Aws.Util.option_map v.association_id (fun f ->
               Aws.Query.Pair ("AssociationId", String.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_version (fun f ->
               "AssociationVersion", String.to_json f)
         ; Aws.Util.option_map v.association_id (fun f ->
               "AssociationId", String.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "InstanceId", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ])

  let of_json j =
    { name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "InstanceId") String.of_json
    ; association_id =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationId") String.of_json
    ; association_version =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationVersion") String.of_json
    }
end

module ItemContentMismatchException = struct
  type t =
    { type_name : String.t option
    ; message : String.t option
    }

  let make ?type_name ?message () = { type_name; message }

  let parse xml =
    Some
      { type_name = Aws.Util.option_bind (Aws.Xml.member "TypeName" xml) String.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.type_name (fun f ->
               Aws.Query.Pair ("TypeName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f)
         ; Aws.Util.option_map v.type_name (fun f -> "TypeName", String.to_json f)
         ])

  let of_json j =
    { type_name = Aws.Util.option_map (Aws.Json.lookup j "TypeName") String.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json
    }
end

module DeleteInventoryResult = struct
  type t =
    { deletion_id : String.t option
    ; type_name : String.t option
    ; deletion_summary : InventoryDeletionSummary.t option
    }

  let make ?deletion_id ?type_name ?deletion_summary () =
    { deletion_id; type_name; deletion_summary }

  let parse xml =
    Some
      { deletion_id = Aws.Util.option_bind (Aws.Xml.member "DeletionId" xml) String.parse
      ; type_name = Aws.Util.option_bind (Aws.Xml.member "TypeName" xml) String.parse
      ; deletion_summary =
          Aws.Util.option_bind
            (Aws.Xml.member "DeletionSummary" xml)
            InventoryDeletionSummary.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.deletion_summary (fun f ->
               Aws.Query.Pair ("DeletionSummary", InventoryDeletionSummary.to_query f))
         ; Aws.Util.option_map v.type_name (fun f ->
               Aws.Query.Pair ("TypeName", String.to_query f))
         ; Aws.Util.option_map v.deletion_id (fun f ->
               Aws.Query.Pair ("DeletionId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.deletion_summary (fun f ->
               "DeletionSummary", InventoryDeletionSummary.to_json f)
         ; Aws.Util.option_map v.type_name (fun f -> "TypeName", String.to_json f)
         ; Aws.Util.option_map v.deletion_id (fun f -> "DeletionId", String.to_json f)
         ])

  let of_json j =
    { deletion_id = Aws.Util.option_map (Aws.Json.lookup j "DeletionId") String.of_json
    ; type_name = Aws.Util.option_map (Aws.Json.lookup j "TypeName") String.of_json
    ; deletion_summary =
        Aws.Util.option_map
          (Aws.Json.lookup j "DeletionSummary")
          InventoryDeletionSummary.of_json
    }
end

module LabelParameterVersionResult = struct
  type t =
    { invalid_labels : ParameterLabelList.t
    ; parameter_version : Long.t option
    }

  let make ?(invalid_labels = []) ?parameter_version () =
    { invalid_labels; parameter_version }

  let parse xml =
    Some
      { invalid_labels =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "InvalidLabels" xml)
               ParameterLabelList.parse)
      ; parameter_version =
          Aws.Util.option_bind (Aws.Xml.member "ParameterVersion" xml) Long.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.parameter_version (fun f ->
               Aws.Query.Pair ("ParameterVersion", Long.to_query f))
         ; Some
             (Aws.Query.Pair
                ("InvalidLabels.member", ParameterLabelList.to_query v.invalid_labels))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.parameter_version (fun f ->
               "ParameterVersion", Long.to_json f)
         ; Some ("InvalidLabels", ParameterLabelList.to_json v.invalid_labels)
         ])

  let of_json j =
    { invalid_labels =
        ParameterLabelList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InvalidLabels"))
    ; parameter_version =
        Aws.Util.option_map (Aws.Json.lookup j "ParameterVersion") Long.of_json
    }
end

module CommandList = struct
  type t = Command.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Command.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list Command.to_query v
  let to_json v = `List (List.map Command.to_json v)
  let of_json j = Aws.Json.to_list Command.of_json j
end

module CreateOpsItemResponse = struct
  type t = { ops_item_id : String.t option }

  let make ?ops_item_id () = { ops_item_id }

  let parse xml =
    Some
      { ops_item_id = Aws.Util.option_bind (Aws.Xml.member "OpsItemId" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ops_item_id (fun f ->
               Aws.Query.Pair ("OpsItemId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ops_item_id (fun f -> "OpsItemId", String.to_json f) ])

  let of_json j =
    { ops_item_id = Aws.Util.option_map (Aws.Json.lookup j "OpsItemId") String.of_json }
end

module UpdateOpsItemResponse = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module TargetMapValueList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module DeletePatchBaselineResult = struct
  type t = { baseline_id : String.t option }

  let make ?baseline_id () = { baseline_id }

  let parse xml =
    Some
      { baseline_id = Aws.Util.option_bind (Aws.Xml.member "BaselineId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.baseline_id (fun f ->
               Aws.Query.Pair ("BaselineId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.baseline_id (fun f -> "BaselineId", String.to_json f) ])

  let of_json j =
    { baseline_id = Aws.Util.option_map (Aws.Json.lookup j "BaselineId") String.of_json }
end

module CancelMaintenanceWindowExecutionRequest = struct
  type t = { window_execution_id : String.t }

  let make ~window_execution_id () = { window_execution_id }

  let parse xml =
    Some
      { window_execution_id =
          Aws.Xml.required
            "WindowExecutionId"
            (Aws.Util.option_bind (Aws.Xml.member "WindowExecutionId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("WindowExecutionId", String.to_query v.window_execution_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("WindowExecutionId", String.to_json v.window_execution_id) ])

  let of_json j =
    { window_execution_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowExecutionId"))
    }
end

module AutomationExecutionLimitExceededException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module GetMaintenanceWindowRequest = struct
  type t = { window_id : String.t }

  let make ~window_id () = { window_id }

  let parse xml =
    Some
      { window_id =
          Aws.Xml.required
            "WindowId"
            (Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("WindowId", String.to_query v.window_id)) ])

  let to_json v =
    `Assoc (Aws.Util.list_filter_opt [ Some ("WindowId", String.to_json v.window_id) ])

  let of_json j =
    { window_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowId")) }
end

module PlatformType = struct
  type t =
    | Windows
    | Linux

  let str_to_t = [ "Linux", Linux; "Windows", Windows ]
  let t_to_str = [ Linux, "Linux"; Windows, "Windows" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module PlatformTypeList = struct
  type t = PlatformType.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map PlatformType.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list PlatformType.to_query v
  let to_json v = `List (List.map PlatformType.to_json v)
  let of_json j = Aws.Json.to_list PlatformType.of_json j
end

module StartSessionResponse = struct
  type t =
    { session_id : String.t option
    ; token_value : String.t option
    ; stream_url : String.t option
    }

  let make ?session_id ?token_value ?stream_url () =
    { session_id; token_value; stream_url }

  let parse xml =
    Some
      { session_id = Aws.Util.option_bind (Aws.Xml.member "SessionId" xml) String.parse
      ; token_value = Aws.Util.option_bind (Aws.Xml.member "TokenValue" xml) String.parse
      ; stream_url = Aws.Util.option_bind (Aws.Xml.member "StreamUrl" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.stream_url (fun f ->
               Aws.Query.Pair ("StreamUrl", String.to_query f))
         ; Aws.Util.option_map v.token_value (fun f ->
               Aws.Query.Pair ("TokenValue", String.to_query f))
         ; Aws.Util.option_map v.session_id (fun f ->
               Aws.Query.Pair ("SessionId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.stream_url (fun f -> "StreamUrl", String.to_json f)
         ; Aws.Util.option_map v.token_value (fun f -> "TokenValue", String.to_json f)
         ; Aws.Util.option_map v.session_id (fun f -> "SessionId", String.to_json f)
         ])

  let of_json j =
    { session_id = Aws.Util.option_map (Aws.Json.lookup j "SessionId") String.of_json
    ; token_value = Aws.Util.option_map (Aws.Json.lookup j "TokenValue") String.of_json
    ; stream_url = Aws.Util.option_map (Aws.Json.lookup j "StreamUrl") String.of_json
    }
end

module ParameterMaxVersionLimitExceeded = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json }
end

module PatchPropertiesList = struct
  type t = PatchPropertyEntry.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map PatchPropertyEntry.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list PatchPropertyEntry.to_query v
  let to_json v = `List (List.map PatchPropertyEntry.to_json v)
  let of_json j = Aws.Json.to_list PatchPropertyEntry.of_json j
end

module AutomationDefinitionVersionNotFoundException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module DescribeMaintenanceWindowExecutionTasksRequest = struct
  type t =
    { window_execution_id : String.t
    ; filters : MaintenanceWindowFilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ~window_execution_id ?(filters = []) ?max_results ?next_token () =
    { window_execution_id; filters; max_results; next_token }

  let parse xml =
    Some
      { window_execution_id =
          Aws.Xml.required
            "WindowExecutionId"
            (Aws.Util.option_bind (Aws.Xml.member "WindowExecutionId" xml) String.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               MaintenanceWindowFilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Filters.member", MaintenanceWindowFilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair ("WindowExecutionId", String.to_query v.window_execution_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filters", MaintenanceWindowFilterList.to_json v.filters)
         ; Some ("WindowExecutionId", String.to_json v.window_execution_id)
         ])

  let of_json j =
    { window_execution_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowExecutionId"))
    ; filters =
        MaintenanceWindowFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module GetCalendarStateResponse = struct
  type t =
    { state : CalendarState.t option
    ; at_time : String.t option
    ; next_transition_time : String.t option
    }

  let make ?state ?at_time ?next_transition_time () =
    { state; at_time; next_transition_time }

  let parse xml =
    Some
      { state = Aws.Util.option_bind (Aws.Xml.member "State" xml) CalendarState.parse
      ; at_time = Aws.Util.option_bind (Aws.Xml.member "AtTime" xml) String.parse
      ; next_transition_time =
          Aws.Util.option_bind (Aws.Xml.member "NextTransitionTime" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_transition_time (fun f ->
               Aws.Query.Pair ("NextTransitionTime", String.to_query f))
         ; Aws.Util.option_map v.at_time (fun f ->
               Aws.Query.Pair ("AtTime", String.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", CalendarState.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_transition_time (fun f ->
               "NextTransitionTime", String.to_json f)
         ; Aws.Util.option_map v.at_time (fun f -> "AtTime", String.to_json f)
         ; Aws.Util.option_map v.state (fun f -> "State", CalendarState.to_json f)
         ])

  let of_json j =
    { state = Aws.Util.option_map (Aws.Json.lookup j "State") CalendarState.of_json
    ; at_time = Aws.Util.option_map (Aws.Json.lookup j "AtTime") String.of_json
    ; next_transition_time =
        Aws.Util.option_map (Aws.Json.lookup j "NextTransitionTime") String.of_json
    }
end

module ResourceLimitExceededException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module InvalidDocumentVersion = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module PatchList = struct
  type t = Patch.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Patch.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list Patch.to_query v
  let to_json v = `List (List.map Patch.to_json v)
  let of_json j = Aws.Json.to_list Patch.of_json j
end

module DescribeAvailablePatchesResult = struct
  type t =
    { patches : PatchList.t
    ; next_token : String.t option
    }

  let make ?(patches = []) ?next_token () = { patches; next_token }

  let parse xml =
    Some
      { patches =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Patches" xml) PatchList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("Patches.member", PatchList.to_query v.patches))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Patches", PatchList.to_json v.patches)
         ])

  let of_json j =
    { patches = PatchList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Patches"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module InvalidPluginName = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module AutomationExecutionFilter = struct
  type t =
    { key : AutomationExecutionFilterKey.t
    ; values : AutomationExecutionFilterValueList.t
    }

  let make ~key ~values () = { key; values }

  let parse xml =
    Some
      { key =
          Aws.Xml.required
            "Key"
            (Aws.Util.option_bind
               (Aws.Xml.member "Key" xml)
               AutomationExecutionFilterKey.parse)
      ; values =
          Aws.Xml.required
            "Values"
            (Aws.Util.option_bind
               (Aws.Xml.member "Values" xml)
               AutomationExecutionFilterValueList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("Values.member", AutomationExecutionFilterValueList.to_query v.values))
         ; Some (Aws.Query.Pair ("Key", AutomationExecutionFilterKey.to_query v.key))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Values", AutomationExecutionFilterValueList.to_json v.values)
         ; Some ("Key", AutomationExecutionFilterKey.to_json v.key)
         ])

  let of_json j =
    { key =
        AutomationExecutionFilterKey.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Key"))
    ; values =
        AutomationExecutionFilterValueList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Values"))
    }
end

module GetPatchBaselineForPatchGroupResult = struct
  type t =
    { baseline_id : String.t option
    ; patch_group : String.t option
    ; operating_system : OperatingSystem.t option
    }

  let make ?baseline_id ?patch_group ?operating_system () =
    { baseline_id; patch_group; operating_system }

  let parse xml =
    Some
      { baseline_id = Aws.Util.option_bind (Aws.Xml.member "BaselineId" xml) String.parse
      ; patch_group = Aws.Util.option_bind (Aws.Xml.member "PatchGroup" xml) String.parse
      ; operating_system =
          Aws.Util.option_bind
            (Aws.Xml.member "OperatingSystem" xml)
            OperatingSystem.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.operating_system (fun f ->
               Aws.Query.Pair ("OperatingSystem", OperatingSystem.to_query f))
         ; Aws.Util.option_map v.patch_group (fun f ->
               Aws.Query.Pair ("PatchGroup", String.to_query f))
         ; Aws.Util.option_map v.baseline_id (fun f ->
               Aws.Query.Pair ("BaselineId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.operating_system (fun f ->
               "OperatingSystem", OperatingSystem.to_json f)
         ; Aws.Util.option_map v.patch_group (fun f -> "PatchGroup", String.to_json f)
         ; Aws.Util.option_map v.baseline_id (fun f -> "BaselineId", String.to_json f)
         ])

  let of_json j =
    { baseline_id = Aws.Util.option_map (Aws.Json.lookup j "BaselineId") String.of_json
    ; patch_group = Aws.Util.option_map (Aws.Json.lookup j "PatchGroup") String.of_json
    ; operating_system =
        Aws.Util.option_map (Aws.Json.lookup j "OperatingSystem") OperatingSystem.of_json
    }
end

module TargetMap = struct
  type t = (String.t, TargetMapValueList.t) Hashtbl.t

  let make elems () = elems
  let parse xml = None

  let to_query v =
    Aws.Query.to_query_hashtbl String.to_string TargetMapValueList.to_query v

  let to_json v =
    `Assoc
      (Hashtbl.fold
         (fun k v acc -> (String.to_string k, TargetMapValueList.to_json v) :: acc)
         v
         [])

  let of_json j = Aws.Json.to_hashtbl String.of_string TargetMapValueList.of_json j
end

module TargetMaps = struct
  type t = TargetMap.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map TargetMap.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list TargetMap.to_query v
  let to_json v = `List (List.map TargetMap.to_json v)
  let of_json j = Aws.Json.to_list TargetMap.of_json j
end

module DescribeInstancePatchesResult = struct
  type t =
    { patches : PatchComplianceDataList.t
    ; next_token : String.t option
    }

  let make ?(patches = []) ?next_token () = { patches; next_token }

  let parse xml =
    Some
      { patches =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Patches" xml)
               PatchComplianceDataList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair ("Patches.member", PatchComplianceDataList.to_query v.patches))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Patches", PatchComplianceDataList.to_json v.patches)
         ])

  let of_json j =
    { patches =
        PatchComplianceDataList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Patches"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module ComplianceTypeCountLimitExceededException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module GetMaintenanceWindowTaskResult = struct
  type t =
    { window_id : String.t option
    ; window_task_id : String.t option
    ; targets : Targets.t
    ; task_arn : String.t option
    ; service_role_arn : String.t option
    ; task_type : MaintenanceWindowTaskType.t option
    ; task_parameters : MaintenanceWindowTaskParameters.t option
    ; task_invocation_parameters : MaintenanceWindowTaskInvocationParameters.t option
    ; priority : Integer.t option
    ; max_concurrency : String.t option
    ; max_errors : String.t option
    ; logging_info : LoggingInfo.t option
    ; name : String.t option
    ; description : String.t option
    }

  let make
      ?window_id
      ?window_task_id
      ?(targets = [])
      ?task_arn
      ?service_role_arn
      ?task_type
      ?task_parameters
      ?task_invocation_parameters
      ?priority
      ?max_concurrency
      ?max_errors
      ?logging_info
      ?name
      ?description
      () =
    { window_id
    ; window_task_id
    ; targets
    ; task_arn
    ; service_role_arn
    ; task_type
    ; task_parameters
    ; task_invocation_parameters
    ; priority
    ; max_concurrency
    ; max_errors
    ; logging_info
    ; name
    ; description
    }

  let parse xml =
    Some
      { window_id = Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse
      ; window_task_id =
          Aws.Util.option_bind (Aws.Xml.member "WindowTaskId" xml) String.parse
      ; targets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Targets" xml) Targets.parse)
      ; task_arn = Aws.Util.option_bind (Aws.Xml.member "TaskArn" xml) String.parse
      ; service_role_arn =
          Aws.Util.option_bind (Aws.Xml.member "ServiceRoleArn" xml) String.parse
      ; task_type =
          Aws.Util.option_bind
            (Aws.Xml.member "TaskType" xml)
            MaintenanceWindowTaskType.parse
      ; task_parameters =
          Aws.Util.option_bind
            (Aws.Xml.member "TaskParameters" xml)
            MaintenanceWindowTaskParameters.parse
      ; task_invocation_parameters =
          Aws.Util.option_bind
            (Aws.Xml.member "TaskInvocationParameters" xml)
            MaintenanceWindowTaskInvocationParameters.parse
      ; priority = Aws.Util.option_bind (Aws.Xml.member "Priority" xml) Integer.parse
      ; max_concurrency =
          Aws.Util.option_bind (Aws.Xml.member "MaxConcurrency" xml) String.parse
      ; max_errors = Aws.Util.option_bind (Aws.Xml.member "MaxErrors" xml) String.parse
      ; logging_info =
          Aws.Util.option_bind (Aws.Xml.member "LoggingInfo" xml) LoggingInfo.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.logging_info (fun f ->
               Aws.Query.Pair ("LoggingInfo", LoggingInfo.to_query f))
         ; Aws.Util.option_map v.max_errors (fun f ->
               Aws.Query.Pair ("MaxErrors", String.to_query f))
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               Aws.Query.Pair ("MaxConcurrency", String.to_query f))
         ; Aws.Util.option_map v.priority (fun f ->
               Aws.Query.Pair ("Priority", Integer.to_query f))
         ; Aws.Util.option_map v.task_invocation_parameters (fun f ->
               Aws.Query.Pair
                 ( "TaskInvocationParameters"
                 , MaintenanceWindowTaskInvocationParameters.to_query f ))
         ; Aws.Util.option_map v.task_parameters (fun f ->
               Aws.Query.Pair
                 ("TaskParameters", MaintenanceWindowTaskParameters.to_query f))
         ; Aws.Util.option_map v.task_type (fun f ->
               Aws.Query.Pair ("TaskType", MaintenanceWindowTaskType.to_query f))
         ; Aws.Util.option_map v.service_role_arn (fun f ->
               Aws.Query.Pair ("ServiceRoleArn", String.to_query f))
         ; Aws.Util.option_map v.task_arn (fun f ->
               Aws.Query.Pair ("TaskArn", String.to_query f))
         ; Some (Aws.Query.Pair ("Targets.member", Targets.to_query v.targets))
         ; Aws.Util.option_map v.window_task_id (fun f ->
               Aws.Query.Pair ("WindowTaskId", String.to_query f))
         ; Aws.Util.option_map v.window_id (fun f ->
               Aws.Query.Pair ("WindowId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.logging_info (fun f ->
               "LoggingInfo", LoggingInfo.to_json f)
         ; Aws.Util.option_map v.max_errors (fun f -> "MaxErrors", String.to_json f)
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               "MaxConcurrency", String.to_json f)
         ; Aws.Util.option_map v.priority (fun f -> "Priority", Integer.to_json f)
         ; Aws.Util.option_map v.task_invocation_parameters (fun f ->
               ( "TaskInvocationParameters"
               , MaintenanceWindowTaskInvocationParameters.to_json f ))
         ; Aws.Util.option_map v.task_parameters (fun f ->
               "TaskParameters", MaintenanceWindowTaskParameters.to_json f)
         ; Aws.Util.option_map v.task_type (fun f ->
               "TaskType", MaintenanceWindowTaskType.to_json f)
         ; Aws.Util.option_map v.service_role_arn (fun f ->
               "ServiceRoleArn", String.to_json f)
         ; Aws.Util.option_map v.task_arn (fun f -> "TaskArn", String.to_json f)
         ; Some ("Targets", Targets.to_json v.targets)
         ; Aws.Util.option_map v.window_task_id (fun f ->
               "WindowTaskId", String.to_json f)
         ; Aws.Util.option_map v.window_id (fun f -> "WindowId", String.to_json f)
         ])

  let of_json j =
    { window_id = Aws.Util.option_map (Aws.Json.lookup j "WindowId") String.of_json
    ; window_task_id =
        Aws.Util.option_map (Aws.Json.lookup j "WindowTaskId") String.of_json
    ; targets = Targets.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Targets"))
    ; task_arn = Aws.Util.option_map (Aws.Json.lookup j "TaskArn") String.of_json
    ; service_role_arn =
        Aws.Util.option_map (Aws.Json.lookup j "ServiceRoleArn") String.of_json
    ; task_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "TaskType")
          MaintenanceWindowTaskType.of_json
    ; task_parameters =
        Aws.Util.option_map
          (Aws.Json.lookup j "TaskParameters")
          MaintenanceWindowTaskParameters.of_json
    ; task_invocation_parameters =
        Aws.Util.option_map
          (Aws.Json.lookup j "TaskInvocationParameters")
          MaintenanceWindowTaskInvocationParameters.of_json
    ; priority = Aws.Util.option_map (Aws.Json.lookup j "Priority") Integer.of_json
    ; max_concurrency =
        Aws.Util.option_map (Aws.Json.lookup j "MaxConcurrency") String.of_json
    ; max_errors = Aws.Util.option_map (Aws.Json.lookup j "MaxErrors") String.of_json
    ; logging_info =
        Aws.Util.option_map (Aws.Json.lookup j "LoggingInfo") LoggingInfo.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    }
end

module InvalidInventoryItemContextException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module OpsResultAttribute = struct
  type t = { type_name : String.t }

  let make ~type_name () = { type_name }

  let parse xml =
    Some
      { type_name =
          Aws.Xml.required
            "TypeName"
            (Aws.Util.option_bind (Aws.Xml.member "TypeName" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TypeName", String.to_query v.type_name)) ])

  let to_json v =
    `Assoc (Aws.Util.list_filter_opt [ Some ("TypeName", String.to_json v.type_name) ])

  let of_json j =
    { type_name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TypeName")) }
end

module OpsResultAttributeList = struct
  type t = OpsResultAttribute.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map OpsResultAttribute.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list OpsResultAttribute.to_query v
  let to_json v = `List (List.map OpsResultAttribute.to_json v)
  let of_json j = Aws.Json.to_list OpsResultAttribute.of_json j
end

module GetOpsSummaryRequest = struct
  type t =
    { sync_name : String.t option
    ; filters : OpsFilterList.t
    ; aggregators : OpsAggregatorList.t
    ; result_attributes : OpsResultAttributeList.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    }

  let make
      ?sync_name
      ?(filters = [])
      ?(aggregators = [])
      ?(result_attributes = [])
      ?next_token
      ?max_results
      () =
    { sync_name; filters; aggregators; result_attributes; next_token; max_results }

  let parse xml =
    Some
      { sync_name = Aws.Util.option_bind (Aws.Xml.member "SyncName" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) OpsFilterList.parse)
      ; aggregators =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Aggregators" xml)
               OpsAggregatorList.parse)
      ; result_attributes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ResultAttributes" xml)
               OpsResultAttributeList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ResultAttributes.member"
                , OpsResultAttributeList.to_query v.result_attributes ))
         ; Some
             (Aws.Query.Pair
                ("Aggregators.member", OpsAggregatorList.to_query v.aggregators))
         ; Some (Aws.Query.Pair ("Filters.member", OpsFilterList.to_query v.filters))
         ; Aws.Util.option_map v.sync_name (fun f ->
               Aws.Query.Pair ("SyncName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("ResultAttributes", OpsResultAttributeList.to_json v.result_attributes)
         ; Some ("Aggregators", OpsAggregatorList.to_json v.aggregators)
         ; Some ("Filters", OpsFilterList.to_json v.filters)
         ; Aws.Util.option_map v.sync_name (fun f -> "SyncName", String.to_json f)
         ])

  let of_json j =
    { sync_name = Aws.Util.option_map (Aws.Json.lookup j "SyncName") String.of_json
    ; filters =
        OpsFilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; aggregators =
        OpsAggregatorList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Aggregators"))
    ; result_attributes =
        OpsResultAttributeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ResultAttributes"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module ResourceInUseException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module OpsItemParameterNamesList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module OpsItemInvalidParameterException = struct
  type t =
    { parameter_names : OpsItemParameterNamesList.t
    ; message : String.t option
    }

  let make ?(parameter_names = []) ?message () = { parameter_names; message }

  let parse xml =
    Some
      { parameter_names =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ParameterNames" xml)
               OpsItemParameterNamesList.parse)
      ; message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ParameterNames.member"
                , OpsItemParameterNamesList.to_query v.parameter_names ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f)
         ; Some ("ParameterNames", OpsItemParameterNamesList.to_json v.parameter_names)
         ])

  let of_json j =
    { parameter_names =
        OpsItemParameterNamesList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ParameterNames"))
    ; message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json
    }
end

module ListTagsForResourceRequest = struct
  type t =
    { resource_type : ResourceTypeForTagging.t
    ; resource_id : String.t
    }

  let make ~resource_type ~resource_id () = { resource_type; resource_id }

  let parse xml =
    Some
      { resource_type =
          Aws.Xml.required
            "ResourceType"
            (Aws.Util.option_bind
               (Aws.Xml.member "ResourceType" xml)
               ResourceTypeForTagging.parse)
      ; resource_id =
          Aws.Xml.required
            "ResourceId"
            (Aws.Util.option_bind (Aws.Xml.member "ResourceId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("ResourceId", String.to_query v.resource_id))
         ; Some
             (Aws.Query.Pair
                ("ResourceType", ResourceTypeForTagging.to_query v.resource_type))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("ResourceId", String.to_json v.resource_id)
         ; Some ("ResourceType", ResourceTypeForTagging.to_json v.resource_type)
         ])

  let of_json j =
    { resource_type =
        ResourceTypeForTagging.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ResourceType"))
    ; resource_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ResourceId"))
    }
end

module ValidNextStepList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module FailureDetails = struct
  type t =
    { failure_stage : String.t option
    ; failure_type : String.t option
    ; details : AutomationParameterMap.t option
    }

  let make ?failure_stage ?failure_type ?details () =
    { failure_stage; failure_type; details }

  let parse xml =
    Some
      { failure_stage =
          Aws.Util.option_bind (Aws.Xml.member "FailureStage" xml) String.parse
      ; failure_type =
          Aws.Util.option_bind (Aws.Xml.member "FailureType" xml) String.parse
      ; details =
          Aws.Util.option_bind (Aws.Xml.member "Details" xml) AutomationParameterMap.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.details (fun f ->
               Aws.Query.Pair ("Details", AutomationParameterMap.to_query f))
         ; Aws.Util.option_map v.failure_type (fun f ->
               Aws.Query.Pair ("FailureType", String.to_query f))
         ; Aws.Util.option_map v.failure_stage (fun f ->
               Aws.Query.Pair ("FailureStage", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.details (fun f ->
               "Details", AutomationParameterMap.to_json f)
         ; Aws.Util.option_map v.failure_type (fun f -> "FailureType", String.to_json f)
         ; Aws.Util.option_map v.failure_stage (fun f -> "FailureStage", String.to_json f)
         ])

  let of_json j =
    { failure_stage =
        Aws.Util.option_map (Aws.Json.lookup j "FailureStage") String.of_json
    ; failure_type = Aws.Util.option_map (Aws.Json.lookup j "FailureType") String.of_json
    ; details =
        Aws.Util.option_map (Aws.Json.lookup j "Details") AutomationParameterMap.of_json
    }
end

module StepExecution = struct
  type t =
    { step_name : String.t option
    ; action : String.t option
    ; timeout_seconds : Long.t option
    ; on_failure : String.t option
    ; max_attempts : Integer.t option
    ; execution_start_time : DateTime.t option
    ; execution_end_time : DateTime.t option
    ; step_status : AutomationExecutionStatus.t option
    ; response_code : String.t option
    ; inputs : NormalStringMap.t option
    ; outputs : AutomationParameterMap.t option
    ; response : String.t option
    ; failure_message : String.t option
    ; failure_details : FailureDetails.t option
    ; step_execution_id : String.t option
    ; overridden_parameters : AutomationParameterMap.t option
    ; is_end : Boolean.t option
    ; next_step : String.t option
    ; is_critical : Boolean.t option
    ; valid_next_steps : ValidNextStepList.t
    ; targets : Targets.t
    ; target_location : TargetLocation.t option
    }

  let make
      ?step_name
      ?action
      ?timeout_seconds
      ?on_failure
      ?max_attempts
      ?execution_start_time
      ?execution_end_time
      ?step_status
      ?response_code
      ?inputs
      ?outputs
      ?response
      ?failure_message
      ?failure_details
      ?step_execution_id
      ?overridden_parameters
      ?is_end
      ?next_step
      ?is_critical
      ?(valid_next_steps = [])
      ?(targets = [])
      ?target_location
      () =
    { step_name
    ; action
    ; timeout_seconds
    ; on_failure
    ; max_attempts
    ; execution_start_time
    ; execution_end_time
    ; step_status
    ; response_code
    ; inputs
    ; outputs
    ; response
    ; failure_message
    ; failure_details
    ; step_execution_id
    ; overridden_parameters
    ; is_end
    ; next_step
    ; is_critical
    ; valid_next_steps
    ; targets
    ; target_location
    }

  let parse xml =
    Some
      { step_name = Aws.Util.option_bind (Aws.Xml.member "StepName" xml) String.parse
      ; action = Aws.Util.option_bind (Aws.Xml.member "Action" xml) String.parse
      ; timeout_seconds =
          Aws.Util.option_bind (Aws.Xml.member "TimeoutSeconds" xml) Long.parse
      ; on_failure = Aws.Util.option_bind (Aws.Xml.member "OnFailure" xml) String.parse
      ; max_attempts =
          Aws.Util.option_bind (Aws.Xml.member "MaxAttempts" xml) Integer.parse
      ; execution_start_time =
          Aws.Util.option_bind (Aws.Xml.member "ExecutionStartTime" xml) DateTime.parse
      ; execution_end_time =
          Aws.Util.option_bind (Aws.Xml.member "ExecutionEndTime" xml) DateTime.parse
      ; step_status =
          Aws.Util.option_bind
            (Aws.Xml.member "StepStatus" xml)
            AutomationExecutionStatus.parse
      ; response_code =
          Aws.Util.option_bind (Aws.Xml.member "ResponseCode" xml) String.parse
      ; inputs = Aws.Util.option_bind (Aws.Xml.member "Inputs" xml) NormalStringMap.parse
      ; outputs =
          Aws.Util.option_bind (Aws.Xml.member "Outputs" xml) AutomationParameterMap.parse
      ; response = Aws.Util.option_bind (Aws.Xml.member "Response" xml) String.parse
      ; failure_message =
          Aws.Util.option_bind (Aws.Xml.member "FailureMessage" xml) String.parse
      ; failure_details =
          Aws.Util.option_bind (Aws.Xml.member "FailureDetails" xml) FailureDetails.parse
      ; step_execution_id =
          Aws.Util.option_bind (Aws.Xml.member "StepExecutionId" xml) String.parse
      ; overridden_parameters =
          Aws.Util.option_bind
            (Aws.Xml.member "OverriddenParameters" xml)
            AutomationParameterMap.parse
      ; is_end = Aws.Util.option_bind (Aws.Xml.member "IsEnd" xml) Boolean.parse
      ; next_step = Aws.Util.option_bind (Aws.Xml.member "NextStep" xml) String.parse
      ; is_critical = Aws.Util.option_bind (Aws.Xml.member "IsCritical" xml) Boolean.parse
      ; valid_next_steps =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ValidNextSteps" xml)
               ValidNextStepList.parse)
      ; targets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Targets" xml) Targets.parse)
      ; target_location =
          Aws.Util.option_bind (Aws.Xml.member "TargetLocation" xml) TargetLocation.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.target_location (fun f ->
               Aws.Query.Pair ("TargetLocation", TargetLocation.to_query f))
         ; Some (Aws.Query.Pair ("Targets.member", Targets.to_query v.targets))
         ; Some
             (Aws.Query.Pair
                ("ValidNextSteps.member", ValidNextStepList.to_query v.valid_next_steps))
         ; Aws.Util.option_map v.is_critical (fun f ->
               Aws.Query.Pair ("IsCritical", Boolean.to_query f))
         ; Aws.Util.option_map v.next_step (fun f ->
               Aws.Query.Pair ("NextStep", String.to_query f))
         ; Aws.Util.option_map v.is_end (fun f ->
               Aws.Query.Pair ("IsEnd", Boolean.to_query f))
         ; Aws.Util.option_map v.overridden_parameters (fun f ->
               Aws.Query.Pair ("OverriddenParameters", AutomationParameterMap.to_query f))
         ; Aws.Util.option_map v.step_execution_id (fun f ->
               Aws.Query.Pair ("StepExecutionId", String.to_query f))
         ; Aws.Util.option_map v.failure_details (fun f ->
               Aws.Query.Pair ("FailureDetails", FailureDetails.to_query f))
         ; Aws.Util.option_map v.failure_message (fun f ->
               Aws.Query.Pair ("FailureMessage", String.to_query f))
         ; Aws.Util.option_map v.response (fun f ->
               Aws.Query.Pair ("Response", String.to_query f))
         ; Aws.Util.option_map v.outputs (fun f ->
               Aws.Query.Pair ("Outputs", AutomationParameterMap.to_query f))
         ; Aws.Util.option_map v.inputs (fun f ->
               Aws.Query.Pair ("Inputs", NormalStringMap.to_query f))
         ; Aws.Util.option_map v.response_code (fun f ->
               Aws.Query.Pair ("ResponseCode", String.to_query f))
         ; Aws.Util.option_map v.step_status (fun f ->
               Aws.Query.Pair ("StepStatus", AutomationExecutionStatus.to_query f))
         ; Aws.Util.option_map v.execution_end_time (fun f ->
               Aws.Query.Pair ("ExecutionEndTime", DateTime.to_query f))
         ; Aws.Util.option_map v.execution_start_time (fun f ->
               Aws.Query.Pair ("ExecutionStartTime", DateTime.to_query f))
         ; Aws.Util.option_map v.max_attempts (fun f ->
               Aws.Query.Pair ("MaxAttempts", Integer.to_query f))
         ; Aws.Util.option_map v.on_failure (fun f ->
               Aws.Query.Pair ("OnFailure", String.to_query f))
         ; Aws.Util.option_map v.timeout_seconds (fun f ->
               Aws.Query.Pair ("TimeoutSeconds", Long.to_query f))
         ; Aws.Util.option_map v.action (fun f ->
               Aws.Query.Pair ("Action", String.to_query f))
         ; Aws.Util.option_map v.step_name (fun f ->
               Aws.Query.Pair ("StepName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.target_location (fun f ->
               "TargetLocation", TargetLocation.to_json f)
         ; Some ("Targets", Targets.to_json v.targets)
         ; Some ("ValidNextSteps", ValidNextStepList.to_json v.valid_next_steps)
         ; Aws.Util.option_map v.is_critical (fun f -> "IsCritical", Boolean.to_json f)
         ; Aws.Util.option_map v.next_step (fun f -> "NextStep", String.to_json f)
         ; Aws.Util.option_map v.is_end (fun f -> "IsEnd", Boolean.to_json f)
         ; Aws.Util.option_map v.overridden_parameters (fun f ->
               "OverriddenParameters", AutomationParameterMap.to_json f)
         ; Aws.Util.option_map v.step_execution_id (fun f ->
               "StepExecutionId", String.to_json f)
         ; Aws.Util.option_map v.failure_details (fun f ->
               "FailureDetails", FailureDetails.to_json f)
         ; Aws.Util.option_map v.failure_message (fun f ->
               "FailureMessage", String.to_json f)
         ; Aws.Util.option_map v.response (fun f -> "Response", String.to_json f)
         ; Aws.Util.option_map v.outputs (fun f ->
               "Outputs", AutomationParameterMap.to_json f)
         ; Aws.Util.option_map v.inputs (fun f -> "Inputs", NormalStringMap.to_json f)
         ; Aws.Util.option_map v.response_code (fun f -> "ResponseCode", String.to_json f)
         ; Aws.Util.option_map v.step_status (fun f ->
               "StepStatus", AutomationExecutionStatus.to_json f)
         ; Aws.Util.option_map v.execution_end_time (fun f ->
               "ExecutionEndTime", DateTime.to_json f)
         ; Aws.Util.option_map v.execution_start_time (fun f ->
               "ExecutionStartTime", DateTime.to_json f)
         ; Aws.Util.option_map v.max_attempts (fun f -> "MaxAttempts", Integer.to_json f)
         ; Aws.Util.option_map v.on_failure (fun f -> "OnFailure", String.to_json f)
         ; Aws.Util.option_map v.timeout_seconds (fun f ->
               "TimeoutSeconds", Long.to_json f)
         ; Aws.Util.option_map v.action (fun f -> "Action", String.to_json f)
         ; Aws.Util.option_map v.step_name (fun f -> "StepName", String.to_json f)
         ])

  let of_json j =
    { step_name = Aws.Util.option_map (Aws.Json.lookup j "StepName") String.of_json
    ; action = Aws.Util.option_map (Aws.Json.lookup j "Action") String.of_json
    ; timeout_seconds =
        Aws.Util.option_map (Aws.Json.lookup j "TimeoutSeconds") Long.of_json
    ; on_failure = Aws.Util.option_map (Aws.Json.lookup j "OnFailure") String.of_json
    ; max_attempts = Aws.Util.option_map (Aws.Json.lookup j "MaxAttempts") Integer.of_json
    ; execution_start_time =
        Aws.Util.option_map (Aws.Json.lookup j "ExecutionStartTime") DateTime.of_json
    ; execution_end_time =
        Aws.Util.option_map (Aws.Json.lookup j "ExecutionEndTime") DateTime.of_json
    ; step_status =
        Aws.Util.option_map
          (Aws.Json.lookup j "StepStatus")
          AutomationExecutionStatus.of_json
    ; response_code =
        Aws.Util.option_map (Aws.Json.lookup j "ResponseCode") String.of_json
    ; inputs = Aws.Util.option_map (Aws.Json.lookup j "Inputs") NormalStringMap.of_json
    ; outputs =
        Aws.Util.option_map (Aws.Json.lookup j "Outputs") AutomationParameterMap.of_json
    ; response = Aws.Util.option_map (Aws.Json.lookup j "Response") String.of_json
    ; failure_message =
        Aws.Util.option_map (Aws.Json.lookup j "FailureMessage") String.of_json
    ; failure_details =
        Aws.Util.option_map (Aws.Json.lookup j "FailureDetails") FailureDetails.of_json
    ; step_execution_id =
        Aws.Util.option_map (Aws.Json.lookup j "StepExecutionId") String.of_json
    ; overridden_parameters =
        Aws.Util.option_map
          (Aws.Json.lookup j "OverriddenParameters")
          AutomationParameterMap.of_json
    ; is_end = Aws.Util.option_map (Aws.Json.lookup j "IsEnd") Boolean.of_json
    ; next_step = Aws.Util.option_map (Aws.Json.lookup j "NextStep") String.of_json
    ; is_critical = Aws.Util.option_map (Aws.Json.lookup j "IsCritical") Boolean.of_json
    ; valid_next_steps =
        ValidNextStepList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ValidNextSteps"))
    ; targets = Targets.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Targets"))
    ; target_location =
        Aws.Util.option_map (Aws.Json.lookup j "TargetLocation") TargetLocation.of_json
    }
end

module StepExecutionList = struct
  type t = StepExecution.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map StepExecution.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list StepExecution.to_query v
  let to_json v = `List (List.map StepExecution.to_json v)
  let of_json j = Aws.Json.to_list StepExecution.of_json j
end

module DescribeAutomationStepExecutionsResult = struct
  type t =
    { step_executions : StepExecutionList.t
    ; next_token : String.t option
    }

  let make ?(step_executions = []) ?next_token () = { step_executions; next_token }

  let parse xml =
    Some
      { step_executions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "StepExecutions" xml)
               StepExecutionList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("StepExecutions.member", StepExecutionList.to_query v.step_executions))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("StepExecutions", StepExecutionList.to_json v.step_executions)
         ])

  let of_json j =
    { step_executions =
        StepExecutionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "StepExecutions"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module SendAutomationSignalResult = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module InvalidItemContentException = struct
  type t =
    { type_name : String.t option
    ; message : String.t option
    }

  let make ?type_name ?message () = { type_name; message }

  let parse xml =
    Some
      { type_name = Aws.Util.option_bind (Aws.Xml.member "TypeName" xml) String.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.type_name (fun f ->
               Aws.Query.Pair ("TypeName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f)
         ; Aws.Util.option_map v.type_name (fun f -> "TypeName", String.to_json f)
         ])

  let of_json j =
    { type_name = Aws.Util.option_map (Aws.Json.lookup j "TypeName") String.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json
    }
end

module UpdatePatchBaselineResult = struct
  type t =
    { baseline_id : String.t option
    ; name : String.t option
    ; operating_system : OperatingSystem.t option
    ; global_filters : PatchFilterGroup.t option
    ; approval_rules : PatchRuleGroup.t option
    ; approved_patches : PatchIdList.t
    ; approved_patches_compliance_level : PatchComplianceLevel.t option
    ; approved_patches_enable_non_security : Boolean.t option
    ; rejected_patches : PatchIdList.t
    ; rejected_patches_action : PatchAction.t option
    ; created_date : DateTime.t option
    ; modified_date : DateTime.t option
    ; description : String.t option
    ; sources : PatchSourceList.t
    }

  let make
      ?baseline_id
      ?name
      ?operating_system
      ?global_filters
      ?approval_rules
      ?(approved_patches = [])
      ?approved_patches_compliance_level
      ?approved_patches_enable_non_security
      ?(rejected_patches = [])
      ?rejected_patches_action
      ?created_date
      ?modified_date
      ?description
      ?(sources = [])
      () =
    { baseline_id
    ; name
    ; operating_system
    ; global_filters
    ; approval_rules
    ; approved_patches
    ; approved_patches_compliance_level
    ; approved_patches_enable_non_security
    ; rejected_patches
    ; rejected_patches_action
    ; created_date
    ; modified_date
    ; description
    ; sources
    }

  let parse xml =
    Some
      { baseline_id = Aws.Util.option_bind (Aws.Xml.member "BaselineId" xml) String.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; operating_system =
          Aws.Util.option_bind
            (Aws.Xml.member "OperatingSystem" xml)
            OperatingSystem.parse
      ; global_filters =
          Aws.Util.option_bind (Aws.Xml.member "GlobalFilters" xml) PatchFilterGroup.parse
      ; approval_rules =
          Aws.Util.option_bind (Aws.Xml.member "ApprovalRules" xml) PatchRuleGroup.parse
      ; approved_patches =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ApprovedPatches" xml)
               PatchIdList.parse)
      ; approved_patches_compliance_level =
          Aws.Util.option_bind
            (Aws.Xml.member "ApprovedPatchesComplianceLevel" xml)
            PatchComplianceLevel.parse
      ; approved_patches_enable_non_security =
          Aws.Util.option_bind
            (Aws.Xml.member "ApprovedPatchesEnableNonSecurity" xml)
            Boolean.parse
      ; rejected_patches =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "RejectedPatches" xml)
               PatchIdList.parse)
      ; rejected_patches_action =
          Aws.Util.option_bind
            (Aws.Xml.member "RejectedPatchesAction" xml)
            PatchAction.parse
      ; created_date =
          Aws.Util.option_bind (Aws.Xml.member "CreatedDate" xml) DateTime.parse
      ; modified_date =
          Aws.Util.option_bind (Aws.Xml.member "ModifiedDate" xml) DateTime.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; sources =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Sources" xml) PatchSourceList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Sources.member", PatchSourceList.to_query v.sources))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.modified_date (fun f ->
               Aws.Query.Pair ("ModifiedDate", DateTime.to_query f))
         ; Aws.Util.option_map v.created_date (fun f ->
               Aws.Query.Pair ("CreatedDate", DateTime.to_query f))
         ; Aws.Util.option_map v.rejected_patches_action (fun f ->
               Aws.Query.Pair ("RejectedPatchesAction", PatchAction.to_query f))
         ; Some
             (Aws.Query.Pair
                ("RejectedPatches.member", PatchIdList.to_query v.rejected_patches))
         ; Aws.Util.option_map v.approved_patches_enable_non_security (fun f ->
               Aws.Query.Pair ("ApprovedPatchesEnableNonSecurity", Boolean.to_query f))
         ; Aws.Util.option_map v.approved_patches_compliance_level (fun f ->
               Aws.Query.Pair
                 ("ApprovedPatchesComplianceLevel", PatchComplianceLevel.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ApprovedPatches.member", PatchIdList.to_query v.approved_patches))
         ; Aws.Util.option_map v.approval_rules (fun f ->
               Aws.Query.Pair ("ApprovalRules", PatchRuleGroup.to_query f))
         ; Aws.Util.option_map v.global_filters (fun f ->
               Aws.Query.Pair ("GlobalFilters", PatchFilterGroup.to_query f))
         ; Aws.Util.option_map v.operating_system (fun f ->
               Aws.Query.Pair ("OperatingSystem", OperatingSystem.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.baseline_id (fun f ->
               Aws.Query.Pair ("BaselineId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Sources", PatchSourceList.to_json v.sources)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.modified_date (fun f ->
               "ModifiedDate", DateTime.to_json f)
         ; Aws.Util.option_map v.created_date (fun f -> "CreatedDate", DateTime.to_json f)
         ; Aws.Util.option_map v.rejected_patches_action (fun f ->
               "RejectedPatchesAction", PatchAction.to_json f)
         ; Some ("RejectedPatches", PatchIdList.to_json v.rejected_patches)
         ; Aws.Util.option_map v.approved_patches_enable_non_security (fun f ->
               "ApprovedPatchesEnableNonSecurity", Boolean.to_json f)
         ; Aws.Util.option_map v.approved_patches_compliance_level (fun f ->
               "ApprovedPatchesComplianceLevel", PatchComplianceLevel.to_json f)
         ; Some ("ApprovedPatches", PatchIdList.to_json v.approved_patches)
         ; Aws.Util.option_map v.approval_rules (fun f ->
               "ApprovalRules", PatchRuleGroup.to_json f)
         ; Aws.Util.option_map v.global_filters (fun f ->
               "GlobalFilters", PatchFilterGroup.to_json f)
         ; Aws.Util.option_map v.operating_system (fun f ->
               "OperatingSystem", OperatingSystem.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.baseline_id (fun f -> "BaselineId", String.to_json f)
         ])

  let of_json j =
    { baseline_id = Aws.Util.option_map (Aws.Json.lookup j "BaselineId") String.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; operating_system =
        Aws.Util.option_map (Aws.Json.lookup j "OperatingSystem") OperatingSystem.of_json
    ; global_filters =
        Aws.Util.option_map (Aws.Json.lookup j "GlobalFilters") PatchFilterGroup.of_json
    ; approval_rules =
        Aws.Util.option_map (Aws.Json.lookup j "ApprovalRules") PatchRuleGroup.of_json
    ; approved_patches =
        PatchIdList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ApprovedPatches"))
    ; approved_patches_compliance_level =
        Aws.Util.option_map
          (Aws.Json.lookup j "ApprovedPatchesComplianceLevel")
          PatchComplianceLevel.of_json
    ; approved_patches_enable_non_security =
        Aws.Util.option_map
          (Aws.Json.lookup j "ApprovedPatchesEnableNonSecurity")
          Boolean.of_json
    ; rejected_patches =
        PatchIdList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "RejectedPatches"))
    ; rejected_patches_action =
        Aws.Util.option_map
          (Aws.Json.lookup j "RejectedPatchesAction")
          PatchAction.of_json
    ; created_date =
        Aws.Util.option_map (Aws.Json.lookup j "CreatedDate") DateTime.of_json
    ; modified_date =
        Aws.Util.option_map (Aws.Json.lookup j "ModifiedDate") DateTime.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; sources =
        PatchSourceList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Sources"))
    }
end

module StartAutomationExecutionRequest = struct
  type t =
    { document_name : String.t
    ; document_version : String.t option
    ; parameters : AutomationParameterMap.t option
    ; client_token : String.t option
    ; mode : ExecutionMode.t option
    ; target_parameter_name : String.t option
    ; targets : Targets.t
    ; target_maps : TargetMaps.t
    ; max_concurrency : String.t option
    ; max_errors : String.t option
    ; target_locations : TargetLocations.t
    ; tags : TagList.t
    }

  let make
      ~document_name
      ?document_version
      ?parameters
      ?client_token
      ?mode
      ?target_parameter_name
      ?(targets = [])
      ?(target_maps = [])
      ?max_concurrency
      ?max_errors
      ?(target_locations = [])
      ?(tags = [])
      () =
    { document_name
    ; document_version
    ; parameters
    ; client_token
    ; mode
    ; target_parameter_name
    ; targets
    ; target_maps
    ; max_concurrency
    ; max_errors
    ; target_locations
    ; tags
    }

  let parse xml =
    Some
      { document_name =
          Aws.Xml.required
            "DocumentName"
            (Aws.Util.option_bind (Aws.Xml.member "DocumentName" xml) String.parse)
      ; document_version =
          Aws.Util.option_bind (Aws.Xml.member "DocumentVersion" xml) String.parse
      ; parameters =
          Aws.Util.option_bind
            (Aws.Xml.member "Parameters" xml)
            AutomationParameterMap.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; mode = Aws.Util.option_bind (Aws.Xml.member "Mode" xml) ExecutionMode.parse
      ; target_parameter_name =
          Aws.Util.option_bind (Aws.Xml.member "TargetParameterName" xml) String.parse
      ; targets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Targets" xml) Targets.parse)
      ; target_maps =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "TargetMaps" xml) TargetMaps.parse)
      ; max_concurrency =
          Aws.Util.option_bind (Aws.Xml.member "MaxConcurrency" xml) String.parse
      ; max_errors = Aws.Util.option_bind (Aws.Xml.member "MaxErrors" xml) String.parse
      ; target_locations =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TargetLocations" xml)
               TargetLocations.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Some
             (Aws.Query.Pair
                ("TargetLocations.member", TargetLocations.to_query v.target_locations))
         ; Aws.Util.option_map v.max_errors (fun f ->
               Aws.Query.Pair ("MaxErrors", String.to_query f))
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               Aws.Query.Pair ("MaxConcurrency", String.to_query f))
         ; Some (Aws.Query.Pair ("TargetMaps.member", TargetMaps.to_query v.target_maps))
         ; Some (Aws.Query.Pair ("Targets.member", Targets.to_query v.targets))
         ; Aws.Util.option_map v.target_parameter_name (fun f ->
               Aws.Query.Pair ("TargetParameterName", String.to_query f))
         ; Aws.Util.option_map v.mode (fun f ->
               Aws.Query.Pair ("Mode", ExecutionMode.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.parameters (fun f ->
               Aws.Query.Pair ("Parameters", AutomationParameterMap.to_query f))
         ; Aws.Util.option_map v.document_version (fun f ->
               Aws.Query.Pair ("DocumentVersion", String.to_query f))
         ; Some (Aws.Query.Pair ("DocumentName", String.to_query v.document_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tags", TagList.to_json v.tags)
         ; Some ("TargetLocations", TargetLocations.to_json v.target_locations)
         ; Aws.Util.option_map v.max_errors (fun f -> "MaxErrors", String.to_json f)
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               "MaxConcurrency", String.to_json f)
         ; Some ("TargetMaps", TargetMaps.to_json v.target_maps)
         ; Some ("Targets", Targets.to_json v.targets)
         ; Aws.Util.option_map v.target_parameter_name (fun f ->
               "TargetParameterName", String.to_json f)
         ; Aws.Util.option_map v.mode (fun f -> "Mode", ExecutionMode.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Aws.Util.option_map v.parameters (fun f ->
               "Parameters", AutomationParameterMap.to_json f)
         ; Aws.Util.option_map v.document_version (fun f ->
               "DocumentVersion", String.to_json f)
         ; Some ("DocumentName", String.to_json v.document_name)
         ])

  let of_json j =
    { document_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DocumentName"))
    ; document_version =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentVersion") String.of_json
    ; parameters =
        Aws.Util.option_map
          (Aws.Json.lookup j "Parameters")
          AutomationParameterMap.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; mode = Aws.Util.option_map (Aws.Json.lookup j "Mode") ExecutionMode.of_json
    ; target_parameter_name =
        Aws.Util.option_map (Aws.Json.lookup j "TargetParameterName") String.of_json
    ; targets = Targets.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Targets"))
    ; target_maps =
        TargetMaps.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TargetMaps"))
    ; max_concurrency =
        Aws.Util.option_map (Aws.Json.lookup j "MaxConcurrency") String.of_json
    ; max_errors = Aws.Util.option_map (Aws.Json.lookup j "MaxErrors") String.of_json
    ; target_locations =
        TargetLocations.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TargetLocations"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    }
end

module OpsItemSummaries = struct
  type t = OpsItemSummary.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map OpsItemSummary.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list OpsItemSummary.to_query v
  let to_json v = `List (List.map OpsItemSummary.to_json v)
  let of_json j = Aws.Json.to_list OpsItemSummary.of_json j
end

module DescribeOpsItemsResponse = struct
  type t =
    { next_token : String.t option
    ; ops_item_summaries : OpsItemSummaries.t
    }

  let make ?next_token ?(ops_item_summaries = []) () = { next_token; ops_item_summaries }

  let parse xml =
    Some
      { next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; ops_item_summaries =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "OpsItemSummaries" xml)
               OpsItemSummaries.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("OpsItemSummaries.member", OpsItemSummaries.to_query v.ops_item_summaries))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("OpsItemSummaries", OpsItemSummaries.to_json v.ops_item_summaries)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ])

  let of_json j =
    { next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; ops_item_summaries =
        OpsItemSummaries.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "OpsItemSummaries"))
    }
end

module CustomSchemaCountLimitExceededException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module InventoryResultEntity = struct
  type t =
    { id : String.t option
    ; data : InventoryResultItemMap.t option
    }

  let make ?id ?data () = { id; data }

  let parse xml =
    Some
      { id = Aws.Util.option_bind (Aws.Xml.member "Id" xml) String.parse
      ; data =
          Aws.Util.option_bind (Aws.Xml.member "Data" xml) InventoryResultItemMap.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.data (fun f ->
               Aws.Query.Pair ("Data", InventoryResultItemMap.to_query f))
         ; Aws.Util.option_map v.id (fun f -> Aws.Query.Pair ("Id", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.data (fun f -> "Data", InventoryResultItemMap.to_json f)
         ; Aws.Util.option_map v.id (fun f -> "Id", String.to_json f)
         ])

  let of_json j =
    { id = Aws.Util.option_map (Aws.Json.lookup j "Id") String.of_json
    ; data = Aws.Util.option_map (Aws.Json.lookup j "Data") InventoryResultItemMap.of_json
    }
end

module InvalidResourceType = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module DescribeMaintenanceWindowTargetsResult = struct
  type t =
    { targets : MaintenanceWindowTargetList.t
    ; next_token : String.t option
    }

  let make ?(targets = []) ?next_token () = { targets; next_token }

  let parse xml =
    Some
      { targets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Targets" xml)
               MaintenanceWindowTargetList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Targets.member", MaintenanceWindowTargetList.to_query v.targets))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Targets", MaintenanceWindowTargetList.to_json v.targets)
         ])

  let of_json j =
    { targets =
        MaintenanceWindowTargetList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Targets"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module InvalidOptionException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module UpdateAssociationStatusResult = struct
  type t = { association_description : AssociationDescription.t option }

  let make ?association_description () = { association_description }

  let parse xml =
    Some
      { association_description =
          Aws.Util.option_bind
            (Aws.Xml.member "AssociationDescription" xml)
            AssociationDescription.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_description (fun f ->
               Aws.Query.Pair ("AssociationDescription", AssociationDescription.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_description (fun f ->
               "AssociationDescription", AssociationDescription.to_json f)
         ])

  let of_json j =
    { association_description =
        Aws.Util.option_map
          (Aws.Json.lookup j "AssociationDescription")
          AssociationDescription.of_json
    }
end

module DeleteMaintenanceWindowRequest = struct
  type t = { window_id : String.t }

  let make ~window_id () = { window_id }

  let parse xml =
    Some
      { window_id =
          Aws.Xml.required
            "WindowId"
            (Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("WindowId", String.to_query v.window_id)) ])

  let to_json v =
    `Assoc (Aws.Util.list_filter_opt [ Some ("WindowId", String.to_json v.window_id) ])

  let of_json j =
    { window_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowId")) }
end

module AssociationExecutionTargetsFilterKey = struct
  type t =
    | Status
    | ResourceId
    | ResourceType

  let str_to_t =
    [ "ResourceType", ResourceType; "ResourceId", ResourceId; "Status", Status ]

  let t_to_str =
    [ ResourceType, "ResourceType"; ResourceId, "ResourceId"; Status, "Status" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module CreateResourceDataSyncResult = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module InvalidAssociationVersion = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module AttachmentInformation = struct
  type t = { name : String.t option }

  let make ?name () = { name }

  let parse xml =
    Some { name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.name (fun f -> "Name", String.to_json f) ])

  let of_json j = { name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json }
end

module DeregisterManagedInstanceResult = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module GetPatchBaselineRequest = struct
  type t = { baseline_id : String.t }

  let make ~baseline_id () = { baseline_id }

  let parse xml =
    Some
      { baseline_id =
          Aws.Xml.required
            "BaselineId"
            (Aws.Util.option_bind (Aws.Xml.member "BaselineId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("BaselineId", String.to_query v.baseline_id)) ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt [ Some ("BaselineId", String.to_json v.baseline_id) ])

  let of_json j =
    { baseline_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "BaselineId"))
    }
end

module InvalidPermissionType = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module GetAutomationExecutionRequest = struct
  type t = { automation_execution_id : String.t }

  let make ~automation_execution_id () = { automation_execution_id }

  let parse xml =
    Some
      { automation_execution_id =
          Aws.Xml.required
            "AutomationExecutionId"
            (Aws.Util.option_bind
               (Aws.Xml.member "AutomationExecutionId" xml)
               String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("AutomationExecutionId", String.to_query v.automation_execution_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("AutomationExecutionId", String.to_json v.automation_execution_id) ])

  let of_json j =
    { automation_execution_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AutomationExecutionId"))
    }
end

module AttachmentInformationList = struct
  type t = AttachmentInformation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map AttachmentInformation.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list AttachmentInformation.to_query v
  let to_json v = `List (List.map AttachmentInformation.to_json v)
  let of_json j = Aws.Json.to_list AttachmentInformation.of_json j
end

module ListCommandsResult = struct
  type t =
    { commands : CommandList.t
    ; next_token : String.t option
    }

  let make ?(commands = []) ?next_token () = { commands; next_token }

  let parse xml =
    Some
      { commands =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Commands" xml) CommandList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("Commands.member", CommandList.to_query v.commands))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Commands", CommandList.to_json v.commands)
         ])

  let of_json j =
    { commands =
        CommandList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Commands"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module AutomationExecutionFilterList = struct
  type t = AutomationExecutionFilter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map AutomationExecutionFilter.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list AutomationExecutionFilter.to_query v
  let to_json v = `List (List.map AutomationExecutionFilter.to_json v)
  let of_json j = Aws.Json.to_list AutomationExecutionFilter.of_json j
end

module DescribeAutomationExecutionsRequest = struct
  type t =
    { filters : AutomationExecutionFilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?(filters = []) ?max_results ?next_token () =
    { filters; max_results; next_token }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               AutomationExecutionFilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Filters.member", AutomationExecutionFilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filters", AutomationExecutionFilterList.to_json v.filters)
         ])

  let of_json j =
    { filters =
        AutomationExecutionFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module SubTypeCountLimitExceededException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module InvalidCommandId = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module ScheduledWindowExecution = struct
  type t =
    { window_id : String.t option
    ; name : String.t option
    ; execution_time : String.t option
    }

  let make ?window_id ?name ?execution_time () = { window_id; name; execution_time }

  let parse xml =
    Some
      { window_id = Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; execution_time =
          Aws.Util.option_bind (Aws.Xml.member "ExecutionTime" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.execution_time (fun f ->
               Aws.Query.Pair ("ExecutionTime", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.window_id (fun f ->
               Aws.Query.Pair ("WindowId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.execution_time (fun f ->
               "ExecutionTime", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.window_id (fun f -> "WindowId", String.to_json f)
         ])

  let of_json j =
    { window_id = Aws.Util.option_map (Aws.Json.lookup j "WindowId") String.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; execution_time =
        Aws.Util.option_map (Aws.Json.lookup j "ExecutionTime") String.of_json
    }
end

module InvalidSchedule = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module DuplicateInstanceId = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module InstancePatchStatesList = struct
  type t = InstancePatchState.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map InstancePatchState.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list InstancePatchState.to_query v
  let to_json v = `List (List.map InstancePatchState.to_json v)
  let of_json j = Aws.Json.to_list InstancePatchState.of_json j
end

module DescribeInstancePatchStatesForPatchGroupResult = struct
  type t =
    { instance_patch_states : InstancePatchStatesList.t
    ; next_token : String.t option
    }

  let make ?(instance_patch_states = []) ?next_token () =
    { instance_patch_states; next_token }

  let parse xml =
    Some
      { instance_patch_states =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "InstancePatchStates" xml)
               InstancePatchStatesList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "InstancePatchStates.member"
                , InstancePatchStatesList.to_query v.instance_patch_states ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some
             ( "InstancePatchStates"
             , InstancePatchStatesList.to_json v.instance_patch_states )
         ])

  let of_json j =
    { instance_patch_states =
        InstancePatchStatesList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InstancePatchStates"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module AssociationVersionLimitExceeded = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module InvalidParameters = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module DeleteResourceDataSyncRequest = struct
  type t =
    { sync_name : String.t
    ; sync_type : String.t option
    }

  let make ~sync_name ?sync_type () = { sync_name; sync_type }

  let parse xml =
    Some
      { sync_name =
          Aws.Xml.required
            "SyncName"
            (Aws.Util.option_bind (Aws.Xml.member "SyncName" xml) String.parse)
      ; sync_type = Aws.Util.option_bind (Aws.Xml.member "SyncType" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.sync_type (fun f ->
               Aws.Query.Pair ("SyncType", String.to_query f))
         ; Some (Aws.Query.Pair ("SyncName", String.to_query v.sync_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.sync_type (fun f -> "SyncType", String.to_json f)
         ; Some ("SyncName", String.to_json v.sync_name)
         ])

  let of_json j =
    { sync_name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SyncName"))
    ; sync_type = Aws.Util.option_map (Aws.Json.lookup j "SyncType") String.of_json
    }
end

module GetParametersByPathResult = struct
  type t =
    { parameters : ParameterList.t
    ; next_token : String.t option
    }

  let make ?(parameters = []) ?next_token () = { parameters; next_token }

  let parse xml =
    Some
      { parameters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Parameters" xml) ParameterList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair ("Parameters.member", ParameterList.to_query v.parameters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Parameters", ParameterList.to_json v.parameters)
         ])

  let of_json j =
    { parameters =
        ParameterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Parameters"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module DocumentIdentifier = struct
  type t =
    { name : String.t option
    ; owner : String.t option
    ; version_name : String.t option
    ; platform_types : PlatformTypeList.t
    ; document_version : String.t option
    ; document_type : DocumentType.t option
    ; schema_version : String.t option
    ; document_format : DocumentFormat.t option
    ; target_type : String.t option
    ; tags : TagList.t
    ; requires : DocumentRequiresList.t
    }

  let make
      ?name
      ?owner
      ?version_name
      ?(platform_types = [])
      ?document_version
      ?document_type
      ?schema_version
      ?document_format
      ?target_type
      ?(tags = [])
      ?(requires = [])
      () =
    { name
    ; owner
    ; version_name
    ; platform_types
    ; document_version
    ; document_type
    ; schema_version
    ; document_format
    ; target_type
    ; tags
    ; requires
    }

  let parse xml =
    Some
      { name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; owner = Aws.Util.option_bind (Aws.Xml.member "Owner" xml) String.parse
      ; version_name =
          Aws.Util.option_bind (Aws.Xml.member "VersionName" xml) String.parse
      ; platform_types =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "PlatformTypes" xml)
               PlatformTypeList.parse)
      ; document_version =
          Aws.Util.option_bind (Aws.Xml.member "DocumentVersion" xml) String.parse
      ; document_type =
          Aws.Util.option_bind (Aws.Xml.member "DocumentType" xml) DocumentType.parse
      ; schema_version =
          Aws.Util.option_bind (Aws.Xml.member "SchemaVersion" xml) String.parse
      ; document_format =
          Aws.Util.option_bind (Aws.Xml.member "DocumentFormat" xml) DocumentFormat.parse
      ; target_type = Aws.Util.option_bind (Aws.Xml.member "TargetType" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      ; requires =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Requires" xml)
               DocumentRequiresList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("Requires.member", DocumentRequiresList.to_query v.requires))
         ; Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Aws.Util.option_map v.target_type (fun f ->
               Aws.Query.Pair ("TargetType", String.to_query f))
         ; Aws.Util.option_map v.document_format (fun f ->
               Aws.Query.Pair ("DocumentFormat", DocumentFormat.to_query f))
         ; Aws.Util.option_map v.schema_version (fun f ->
               Aws.Query.Pair ("SchemaVersion", String.to_query f))
         ; Aws.Util.option_map v.document_type (fun f ->
               Aws.Query.Pair ("DocumentType", DocumentType.to_query f))
         ; Aws.Util.option_map v.document_version (fun f ->
               Aws.Query.Pair ("DocumentVersion", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("PlatformTypes.member", PlatformTypeList.to_query v.platform_types))
         ; Aws.Util.option_map v.version_name (fun f ->
               Aws.Query.Pair ("VersionName", String.to_query f))
         ; Aws.Util.option_map v.owner (fun f ->
               Aws.Query.Pair ("Owner", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Requires", DocumentRequiresList.to_json v.requires)
         ; Some ("Tags", TagList.to_json v.tags)
         ; Aws.Util.option_map v.target_type (fun f -> "TargetType", String.to_json f)
         ; Aws.Util.option_map v.document_format (fun f ->
               "DocumentFormat", DocumentFormat.to_json f)
         ; Aws.Util.option_map v.schema_version (fun f ->
               "SchemaVersion", String.to_json f)
         ; Aws.Util.option_map v.document_type (fun f ->
               "DocumentType", DocumentType.to_json f)
         ; Aws.Util.option_map v.document_version (fun f ->
               "DocumentVersion", String.to_json f)
         ; Some ("PlatformTypes", PlatformTypeList.to_json v.platform_types)
         ; Aws.Util.option_map v.version_name (fun f -> "VersionName", String.to_json f)
         ; Aws.Util.option_map v.owner (fun f -> "Owner", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ])

  let of_json j =
    { name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; owner = Aws.Util.option_map (Aws.Json.lookup j "Owner") String.of_json
    ; version_name = Aws.Util.option_map (Aws.Json.lookup j "VersionName") String.of_json
    ; platform_types =
        PlatformTypeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "PlatformTypes"))
    ; document_version =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentVersion") String.of_json
    ; document_type =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentType") DocumentType.of_json
    ; schema_version =
        Aws.Util.option_map (Aws.Json.lookup j "SchemaVersion") String.of_json
    ; document_format =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentFormat") DocumentFormat.of_json
    ; target_type = Aws.Util.option_map (Aws.Json.lookup j "TargetType") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    ; requires =
        DocumentRequiresList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Requires"))
    }
end

module DocumentIdentifierList = struct
  type t = DocumentIdentifier.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map DocumentIdentifier.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list DocumentIdentifier.to_query v
  let to_json v = `List (List.map DocumentIdentifier.to_json v)
  let of_json j = Aws.Json.to_list DocumentIdentifier.of_json j
end

module ResourceType = struct
  type t =
    | ManagedInstance
    | Document
    | EC2Instance

  let str_to_t =
    [ "EC2Instance", EC2Instance
    ; "Document", Document
    ; "ManagedInstance", ManagedInstance
    ]

  let t_to_str =
    [ EC2Instance, "EC2Instance"
    ; Document, "Document"
    ; ManagedInstance, "ManagedInstance"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module PingStatus = struct
  type t =
    | Online
    | ConnectionLost
    | Inactive

  let str_to_t =
    [ "Inactive", Inactive; "ConnectionLost", ConnectionLost; "Online", Online ]

  let t_to_str =
    [ Inactive, "Inactive"; ConnectionLost, "ConnectionLost"; Online, "Online" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module InstanceAggregatedAssociationOverview = struct
  type t =
    { detailed_status : String.t option
    ; instance_association_status_aggregated_count :
        InstanceAssociationStatusAggregatedCount.t option
    }

  let make ?detailed_status ?instance_association_status_aggregated_count () =
    { detailed_status; instance_association_status_aggregated_count }

  let parse xml =
    Some
      { detailed_status =
          Aws.Util.option_bind (Aws.Xml.member "DetailedStatus" xml) String.parse
      ; instance_association_status_aggregated_count =
          Aws.Util.option_bind
            (Aws.Xml.member "InstanceAssociationStatusAggregatedCount" xml)
            InstanceAssociationStatusAggregatedCount.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_association_status_aggregated_count (fun f ->
               Aws.Query.Pair
                 ( "InstanceAssociationStatusAggregatedCount"
                 , InstanceAssociationStatusAggregatedCount.to_query f ))
         ; Aws.Util.option_map v.detailed_status (fun f ->
               Aws.Query.Pair ("DetailedStatus", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_association_status_aggregated_count (fun f ->
               ( "InstanceAssociationStatusAggregatedCount"
               , InstanceAssociationStatusAggregatedCount.to_json f ))
         ; Aws.Util.option_map v.detailed_status (fun f ->
               "DetailedStatus", String.to_json f)
         ])

  let of_json j =
    { detailed_status =
        Aws.Util.option_map (Aws.Json.lookup j "DetailedStatus") String.of_json
    ; instance_association_status_aggregated_count =
        Aws.Util.option_map
          (Aws.Json.lookup j "InstanceAssociationStatusAggregatedCount")
          InstanceAssociationStatusAggregatedCount.of_json
    }
end

module InstanceInformation = struct
  type t =
    { instance_id : String.t option
    ; ping_status : PingStatus.t option
    ; last_ping_date_time : DateTime.t option
    ; agent_version : String.t option
    ; is_latest_version : Boolean.t option
    ; platform_type : PlatformType.t option
    ; platform_name : String.t option
    ; platform_version : String.t option
    ; activation_id : String.t option
    ; iam_role : String.t option
    ; registration_date : DateTime.t option
    ; resource_type : ResourceType.t option
    ; name : String.t option
    ; i_p_address : String.t option
    ; computer_name : String.t option
    ; association_status : String.t option
    ; last_association_execution_date : DateTime.t option
    ; last_successful_association_execution_date : DateTime.t option
    ; association_overview : InstanceAggregatedAssociationOverview.t option
    }

  let make
      ?instance_id
      ?ping_status
      ?last_ping_date_time
      ?agent_version
      ?is_latest_version
      ?platform_type
      ?platform_name
      ?platform_version
      ?activation_id
      ?iam_role
      ?registration_date
      ?resource_type
      ?name
      ?i_p_address
      ?computer_name
      ?association_status
      ?last_association_execution_date
      ?last_successful_association_execution_date
      ?association_overview
      () =
    { instance_id
    ; ping_status
    ; last_ping_date_time
    ; agent_version
    ; is_latest_version
    ; platform_type
    ; platform_name
    ; platform_version
    ; activation_id
    ; iam_role
    ; registration_date
    ; resource_type
    ; name
    ; i_p_address
    ; computer_name
    ; association_status
    ; last_association_execution_date
    ; last_successful_association_execution_date
    ; association_overview
    }

  let parse xml =
    Some
      { instance_id = Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse
      ; ping_status =
          Aws.Util.option_bind (Aws.Xml.member "PingStatus" xml) PingStatus.parse
      ; last_ping_date_time =
          Aws.Util.option_bind (Aws.Xml.member "LastPingDateTime" xml) DateTime.parse
      ; agent_version =
          Aws.Util.option_bind (Aws.Xml.member "AgentVersion" xml) String.parse
      ; is_latest_version =
          Aws.Util.option_bind (Aws.Xml.member "IsLatestVersion" xml) Boolean.parse
      ; platform_type =
          Aws.Util.option_bind (Aws.Xml.member "PlatformType" xml) PlatformType.parse
      ; platform_name =
          Aws.Util.option_bind (Aws.Xml.member "PlatformName" xml) String.parse
      ; platform_version =
          Aws.Util.option_bind (Aws.Xml.member "PlatformVersion" xml) String.parse
      ; activation_id =
          Aws.Util.option_bind (Aws.Xml.member "ActivationId" xml) String.parse
      ; iam_role = Aws.Util.option_bind (Aws.Xml.member "IamRole" xml) String.parse
      ; registration_date =
          Aws.Util.option_bind (Aws.Xml.member "RegistrationDate" xml) DateTime.parse
      ; resource_type =
          Aws.Util.option_bind (Aws.Xml.member "ResourceType" xml) ResourceType.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; i_p_address = Aws.Util.option_bind (Aws.Xml.member "IPAddress" xml) String.parse
      ; computer_name =
          Aws.Util.option_bind (Aws.Xml.member "ComputerName" xml) String.parse
      ; association_status =
          Aws.Util.option_bind (Aws.Xml.member "AssociationStatus" xml) String.parse
      ; last_association_execution_date =
          Aws.Util.option_bind
            (Aws.Xml.member "LastAssociationExecutionDate" xml)
            DateTime.parse
      ; last_successful_association_execution_date =
          Aws.Util.option_bind
            (Aws.Xml.member "LastSuccessfulAssociationExecutionDate" xml)
            DateTime.parse
      ; association_overview =
          Aws.Util.option_bind
            (Aws.Xml.member "AssociationOverview" xml)
            InstanceAggregatedAssociationOverview.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_overview (fun f ->
               Aws.Query.Pair
                 ("AssociationOverview", InstanceAggregatedAssociationOverview.to_query f))
         ; Aws.Util.option_map v.last_successful_association_execution_date (fun f ->
               Aws.Query.Pair
                 ("LastSuccessfulAssociationExecutionDate", DateTime.to_query f))
         ; Aws.Util.option_map v.last_association_execution_date (fun f ->
               Aws.Query.Pair ("LastAssociationExecutionDate", DateTime.to_query f))
         ; Aws.Util.option_map v.association_status (fun f ->
               Aws.Query.Pair ("AssociationStatus", String.to_query f))
         ; Aws.Util.option_map v.computer_name (fun f ->
               Aws.Query.Pair ("ComputerName", String.to_query f))
         ; Aws.Util.option_map v.i_p_address (fun f ->
               Aws.Query.Pair ("IPAddress", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.resource_type (fun f ->
               Aws.Query.Pair ("ResourceType", ResourceType.to_query f))
         ; Aws.Util.option_map v.registration_date (fun f ->
               Aws.Query.Pair ("RegistrationDate", DateTime.to_query f))
         ; Aws.Util.option_map v.iam_role (fun f ->
               Aws.Query.Pair ("IamRole", String.to_query f))
         ; Aws.Util.option_map v.activation_id (fun f ->
               Aws.Query.Pair ("ActivationId", String.to_query f))
         ; Aws.Util.option_map v.platform_version (fun f ->
               Aws.Query.Pair ("PlatformVersion", String.to_query f))
         ; Aws.Util.option_map v.platform_name (fun f ->
               Aws.Query.Pair ("PlatformName", String.to_query f))
         ; Aws.Util.option_map v.platform_type (fun f ->
               Aws.Query.Pair ("PlatformType", PlatformType.to_query f))
         ; Aws.Util.option_map v.is_latest_version (fun f ->
               Aws.Query.Pair ("IsLatestVersion", Boolean.to_query f))
         ; Aws.Util.option_map v.agent_version (fun f ->
               Aws.Query.Pair ("AgentVersion", String.to_query f))
         ; Aws.Util.option_map v.last_ping_date_time (fun f ->
               Aws.Query.Pair ("LastPingDateTime", DateTime.to_query f))
         ; Aws.Util.option_map v.ping_status (fun f ->
               Aws.Query.Pair ("PingStatus", PingStatus.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_overview (fun f ->
               "AssociationOverview", InstanceAggregatedAssociationOverview.to_json f)
         ; Aws.Util.option_map v.last_successful_association_execution_date (fun f ->
               "LastSuccessfulAssociationExecutionDate", DateTime.to_json f)
         ; Aws.Util.option_map v.last_association_execution_date (fun f ->
               "LastAssociationExecutionDate", DateTime.to_json f)
         ; Aws.Util.option_map v.association_status (fun f ->
               "AssociationStatus", String.to_json f)
         ; Aws.Util.option_map v.computer_name (fun f -> "ComputerName", String.to_json f)
         ; Aws.Util.option_map v.i_p_address (fun f -> "IPAddress", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.resource_type (fun f ->
               "ResourceType", ResourceType.to_json f)
         ; Aws.Util.option_map v.registration_date (fun f ->
               "RegistrationDate", DateTime.to_json f)
         ; Aws.Util.option_map v.iam_role (fun f -> "IamRole", String.to_json f)
         ; Aws.Util.option_map v.activation_id (fun f -> "ActivationId", String.to_json f)
         ; Aws.Util.option_map v.platform_version (fun f ->
               "PlatformVersion", String.to_json f)
         ; Aws.Util.option_map v.platform_name (fun f -> "PlatformName", String.to_json f)
         ; Aws.Util.option_map v.platform_type (fun f ->
               "PlatformType", PlatformType.to_json f)
         ; Aws.Util.option_map v.is_latest_version (fun f ->
               "IsLatestVersion", Boolean.to_json f)
         ; Aws.Util.option_map v.agent_version (fun f -> "AgentVersion", String.to_json f)
         ; Aws.Util.option_map v.last_ping_date_time (fun f ->
               "LastPingDateTime", DateTime.to_json f)
         ; Aws.Util.option_map v.ping_status (fun f -> "PingStatus", PingStatus.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "InstanceId", String.to_json f)
         ])

  let of_json j =
    { instance_id = Aws.Util.option_map (Aws.Json.lookup j "InstanceId") String.of_json
    ; ping_status =
        Aws.Util.option_map (Aws.Json.lookup j "PingStatus") PingStatus.of_json
    ; last_ping_date_time =
        Aws.Util.option_map (Aws.Json.lookup j "LastPingDateTime") DateTime.of_json
    ; agent_version =
        Aws.Util.option_map (Aws.Json.lookup j "AgentVersion") String.of_json
    ; is_latest_version =
        Aws.Util.option_map (Aws.Json.lookup j "IsLatestVersion") Boolean.of_json
    ; platform_type =
        Aws.Util.option_map (Aws.Json.lookup j "PlatformType") PlatformType.of_json
    ; platform_name =
        Aws.Util.option_map (Aws.Json.lookup j "PlatformName") String.of_json
    ; platform_version =
        Aws.Util.option_map (Aws.Json.lookup j "PlatformVersion") String.of_json
    ; activation_id =
        Aws.Util.option_map (Aws.Json.lookup j "ActivationId") String.of_json
    ; iam_role = Aws.Util.option_map (Aws.Json.lookup j "IamRole") String.of_json
    ; registration_date =
        Aws.Util.option_map (Aws.Json.lookup j "RegistrationDate") DateTime.of_json
    ; resource_type =
        Aws.Util.option_map (Aws.Json.lookup j "ResourceType") ResourceType.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; i_p_address = Aws.Util.option_map (Aws.Json.lookup j "IPAddress") String.of_json
    ; computer_name =
        Aws.Util.option_map (Aws.Json.lookup j "ComputerName") String.of_json
    ; association_status =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationStatus") String.of_json
    ; last_association_execution_date =
        Aws.Util.option_map
          (Aws.Json.lookup j "LastAssociationExecutionDate")
          DateTime.of_json
    ; last_successful_association_execution_date =
        Aws.Util.option_map
          (Aws.Json.lookup j "LastSuccessfulAssociationExecutionDate")
          DateTime.of_json
    ; association_overview =
        Aws.Util.option_map
          (Aws.Json.lookup j "AssociationOverview")
          InstanceAggregatedAssociationOverview.of_json
    }
end

module InstanceInformationList = struct
  type t = InstanceInformation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map InstanceInformation.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list InstanceInformation.to_query v
  let to_json v = `List (List.map InstanceInformation.to_json v)
  let of_json j = Aws.Json.to_list InstanceInformation.of_json j
end

module DeregisterTargetFromMaintenanceWindowRequest = struct
  type t =
    { window_id : String.t
    ; window_target_id : String.t
    ; safe : Boolean.t option
    }

  let make ~window_id ~window_target_id ?safe () = { window_id; window_target_id; safe }

  let parse xml =
    Some
      { window_id =
          Aws.Xml.required
            "WindowId"
            (Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse)
      ; window_target_id =
          Aws.Xml.required
            "WindowTargetId"
            (Aws.Util.option_bind (Aws.Xml.member "WindowTargetId" xml) String.parse)
      ; safe = Aws.Util.option_bind (Aws.Xml.member "Safe" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.safe (fun f ->
               Aws.Query.Pair ("Safe", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("WindowTargetId", String.to_query v.window_target_id))
         ; Some (Aws.Query.Pair ("WindowId", String.to_query v.window_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.safe (fun f -> "Safe", Boolean.to_json f)
         ; Some ("WindowTargetId", String.to_json v.window_target_id)
         ; Some ("WindowId", String.to_json v.window_id)
         ])

  let of_json j =
    { window_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowId"))
    ; window_target_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowTargetId"))
    ; safe = Aws.Util.option_map (Aws.Json.lookup j "Safe") Boolean.of_json
    }
end

module SendCommandRequest = struct
  type t =
    { instance_ids : InstanceIdList.t
    ; targets : Targets.t
    ; document_name : String.t
    ; document_version : String.t option
    ; document_hash : String.t option
    ; document_hash_type : DocumentHashType.t option
    ; timeout_seconds : Integer.t option
    ; comment : String.t option
    ; parameters : Parameters.t option
    ; output_s3_region : String.t option
    ; output_s3_bucket_name : String.t option
    ; output_s3_key_prefix : String.t option
    ; max_concurrency : String.t option
    ; max_errors : String.t option
    ; service_role_arn : String.t option
    ; notification_config : NotificationConfig.t option
    ; cloud_watch_output_config : CloudWatchOutputConfig.t option
    }

  let make
      ?(instance_ids = [])
      ?(targets = [])
      ~document_name
      ?document_version
      ?document_hash
      ?document_hash_type
      ?timeout_seconds
      ?comment
      ?parameters
      ?output_s3_region
      ?output_s3_bucket_name
      ?output_s3_key_prefix
      ?max_concurrency
      ?max_errors
      ?service_role_arn
      ?notification_config
      ?cloud_watch_output_config
      () =
    { instance_ids
    ; targets
    ; document_name
    ; document_version
    ; document_hash
    ; document_hash_type
    ; timeout_seconds
    ; comment
    ; parameters
    ; output_s3_region
    ; output_s3_bucket_name
    ; output_s3_key_prefix
    ; max_concurrency
    ; max_errors
    ; service_role_arn
    ; notification_config
    ; cloud_watch_output_config
    }

  let parse xml =
    Some
      { instance_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "InstanceIds" xml) InstanceIdList.parse)
      ; targets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Targets" xml) Targets.parse)
      ; document_name =
          Aws.Xml.required
            "DocumentName"
            (Aws.Util.option_bind (Aws.Xml.member "DocumentName" xml) String.parse)
      ; document_version =
          Aws.Util.option_bind (Aws.Xml.member "DocumentVersion" xml) String.parse
      ; document_hash =
          Aws.Util.option_bind (Aws.Xml.member "DocumentHash" xml) String.parse
      ; document_hash_type =
          Aws.Util.option_bind
            (Aws.Xml.member "DocumentHashType" xml)
            DocumentHashType.parse
      ; timeout_seconds =
          Aws.Util.option_bind (Aws.Xml.member "TimeoutSeconds" xml) Integer.parse
      ; comment = Aws.Util.option_bind (Aws.Xml.member "Comment" xml) String.parse
      ; parameters =
          Aws.Util.option_bind (Aws.Xml.member "Parameters" xml) Parameters.parse
      ; output_s3_region =
          Aws.Util.option_bind (Aws.Xml.member "OutputS3Region" xml) String.parse
      ; output_s3_bucket_name =
          Aws.Util.option_bind (Aws.Xml.member "OutputS3BucketName" xml) String.parse
      ; output_s3_key_prefix =
          Aws.Util.option_bind (Aws.Xml.member "OutputS3KeyPrefix" xml) String.parse
      ; max_concurrency =
          Aws.Util.option_bind (Aws.Xml.member "MaxConcurrency" xml) String.parse
      ; max_errors = Aws.Util.option_bind (Aws.Xml.member "MaxErrors" xml) String.parse
      ; service_role_arn =
          Aws.Util.option_bind (Aws.Xml.member "ServiceRoleArn" xml) String.parse
      ; notification_config =
          Aws.Util.option_bind
            (Aws.Xml.member "NotificationConfig" xml)
            NotificationConfig.parse
      ; cloud_watch_output_config =
          Aws.Util.option_bind
            (Aws.Xml.member "CloudWatchOutputConfig" xml)
            CloudWatchOutputConfig.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cloud_watch_output_config (fun f ->
               Aws.Query.Pair ("CloudWatchOutputConfig", CloudWatchOutputConfig.to_query f))
         ; Aws.Util.option_map v.notification_config (fun f ->
               Aws.Query.Pair ("NotificationConfig", NotificationConfig.to_query f))
         ; Aws.Util.option_map v.service_role_arn (fun f ->
               Aws.Query.Pair ("ServiceRoleArn", String.to_query f))
         ; Aws.Util.option_map v.max_errors (fun f ->
               Aws.Query.Pair ("MaxErrors", String.to_query f))
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               Aws.Query.Pair ("MaxConcurrency", String.to_query f))
         ; Aws.Util.option_map v.output_s3_key_prefix (fun f ->
               Aws.Query.Pair ("OutputS3KeyPrefix", String.to_query f))
         ; Aws.Util.option_map v.output_s3_bucket_name (fun f ->
               Aws.Query.Pair ("OutputS3BucketName", String.to_query f))
         ; Aws.Util.option_map v.output_s3_region (fun f ->
               Aws.Query.Pair ("OutputS3Region", String.to_query f))
         ; Aws.Util.option_map v.parameters (fun f ->
               Aws.Query.Pair ("Parameters", Parameters.to_query f))
         ; Aws.Util.option_map v.comment (fun f ->
               Aws.Query.Pair ("Comment", String.to_query f))
         ; Aws.Util.option_map v.timeout_seconds (fun f ->
               Aws.Query.Pair ("TimeoutSeconds", Integer.to_query f))
         ; Aws.Util.option_map v.document_hash_type (fun f ->
               Aws.Query.Pair ("DocumentHashType", DocumentHashType.to_query f))
         ; Aws.Util.option_map v.document_hash (fun f ->
               Aws.Query.Pair ("DocumentHash", String.to_query f))
         ; Aws.Util.option_map v.document_version (fun f ->
               Aws.Query.Pair ("DocumentVersion", String.to_query f))
         ; Some (Aws.Query.Pair ("DocumentName", String.to_query v.document_name))
         ; Some (Aws.Query.Pair ("Targets.member", Targets.to_query v.targets))
         ; Some
             (Aws.Query.Pair ("InstanceIds.member", InstanceIdList.to_query v.instance_ids))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cloud_watch_output_config (fun f ->
               "CloudWatchOutputConfig", CloudWatchOutputConfig.to_json f)
         ; Aws.Util.option_map v.notification_config (fun f ->
               "NotificationConfig", NotificationConfig.to_json f)
         ; Aws.Util.option_map v.service_role_arn (fun f ->
               "ServiceRoleArn", String.to_json f)
         ; Aws.Util.option_map v.max_errors (fun f -> "MaxErrors", String.to_json f)
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               "MaxConcurrency", String.to_json f)
         ; Aws.Util.option_map v.output_s3_key_prefix (fun f ->
               "OutputS3KeyPrefix", String.to_json f)
         ; Aws.Util.option_map v.output_s3_bucket_name (fun f ->
               "OutputS3BucketName", String.to_json f)
         ; Aws.Util.option_map v.output_s3_region (fun f ->
               "OutputS3Region", String.to_json f)
         ; Aws.Util.option_map v.parameters (fun f -> "Parameters", Parameters.to_json f)
         ; Aws.Util.option_map v.comment (fun f -> "Comment", String.to_json f)
         ; Aws.Util.option_map v.timeout_seconds (fun f ->
               "TimeoutSeconds", Integer.to_json f)
         ; Aws.Util.option_map v.document_hash_type (fun f ->
               "DocumentHashType", DocumentHashType.to_json f)
         ; Aws.Util.option_map v.document_hash (fun f -> "DocumentHash", String.to_json f)
         ; Aws.Util.option_map v.document_version (fun f ->
               "DocumentVersion", String.to_json f)
         ; Some ("DocumentName", String.to_json v.document_name)
         ; Some ("Targets", Targets.to_json v.targets)
         ; Some ("InstanceIds", InstanceIdList.to_json v.instance_ids)
         ])

  let of_json j =
    { instance_ids =
        InstanceIdList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceIds"))
    ; targets = Targets.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Targets"))
    ; document_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DocumentName"))
    ; document_version =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentVersion") String.of_json
    ; document_hash =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentHash") String.of_json
    ; document_hash_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "DocumentHashType")
          DocumentHashType.of_json
    ; timeout_seconds =
        Aws.Util.option_map (Aws.Json.lookup j "TimeoutSeconds") Integer.of_json
    ; comment = Aws.Util.option_map (Aws.Json.lookup j "Comment") String.of_json
    ; parameters = Aws.Util.option_map (Aws.Json.lookup j "Parameters") Parameters.of_json
    ; output_s3_region =
        Aws.Util.option_map (Aws.Json.lookup j "OutputS3Region") String.of_json
    ; output_s3_bucket_name =
        Aws.Util.option_map (Aws.Json.lookup j "OutputS3BucketName") String.of_json
    ; output_s3_key_prefix =
        Aws.Util.option_map (Aws.Json.lookup j "OutputS3KeyPrefix") String.of_json
    ; max_concurrency =
        Aws.Util.option_map (Aws.Json.lookup j "MaxConcurrency") String.of_json
    ; max_errors = Aws.Util.option_map (Aws.Json.lookup j "MaxErrors") String.of_json
    ; service_role_arn =
        Aws.Util.option_map (Aws.Json.lookup j "ServiceRoleArn") String.of_json
    ; notification_config =
        Aws.Util.option_map
          (Aws.Json.lookup j "NotificationConfig")
          NotificationConfig.of_json
    ; cloud_watch_output_config =
        Aws.Util.option_map
          (Aws.Json.lookup j "CloudWatchOutputConfig")
          CloudWatchOutputConfig.of_json
    }
end

module InventorySchemaDeleteOption = struct
  type t =
    | DisableSchema
    | DeleteSchema

  let str_to_t = [ "DeleteSchema", DeleteSchema; "DisableSchema", DisableSchema ]
  let t_to_str = [ DeleteSchema, "DeleteSchema"; DisableSchema, "DisableSchema" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module InstanceAssociation = struct
  type t =
    { association_id : String.t option
    ; instance_id : String.t option
    ; content : String.t option
    ; association_version : String.t option
    }

  let make ?association_id ?instance_id ?content ?association_version () =
    { association_id; instance_id; content; association_version }

  let parse xml =
    Some
      { association_id =
          Aws.Util.option_bind (Aws.Xml.member "AssociationId" xml) String.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse
      ; content = Aws.Util.option_bind (Aws.Xml.member "Content" xml) String.parse
      ; association_version =
          Aws.Util.option_bind (Aws.Xml.member "AssociationVersion" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_version (fun f ->
               Aws.Query.Pair ("AssociationVersion", String.to_query f))
         ; Aws.Util.option_map v.content (fun f ->
               Aws.Query.Pair ("Content", String.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.association_id (fun f ->
               Aws.Query.Pair ("AssociationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_version (fun f ->
               "AssociationVersion", String.to_json f)
         ; Aws.Util.option_map v.content (fun f -> "Content", String.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "InstanceId", String.to_json f)
         ; Aws.Util.option_map v.association_id (fun f ->
               "AssociationId", String.to_json f)
         ])

  let of_json j =
    { association_id =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationId") String.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "InstanceId") String.of_json
    ; content = Aws.Util.option_map (Aws.Json.lookup j "Content") String.of_json
    ; association_version =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationVersion") String.of_json
    }
end

module InstanceAssociationList = struct
  type t = InstanceAssociation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map InstanceAssociation.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list InstanceAssociation.to_query v
  let to_json v = `List (List.map InstanceAssociation.to_json v)
  let of_json j = Aws.Json.to_list InstanceAssociation.of_json j
end

module UpdateServiceSettingResult = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module TargetNotConnected = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module AssociationExecution = struct
  type t =
    { association_id : String.t option
    ; association_version : String.t option
    ; execution_id : String.t option
    ; status : String.t option
    ; detailed_status : String.t option
    ; created_time : DateTime.t option
    ; last_execution_date : DateTime.t option
    ; resource_count_by_status : String.t option
    }

  let make
      ?association_id
      ?association_version
      ?execution_id
      ?status
      ?detailed_status
      ?created_time
      ?last_execution_date
      ?resource_count_by_status
      () =
    { association_id
    ; association_version
    ; execution_id
    ; status
    ; detailed_status
    ; created_time
    ; last_execution_date
    ; resource_count_by_status
    }

  let parse xml =
    Some
      { association_id =
          Aws.Util.option_bind (Aws.Xml.member "AssociationId" xml) String.parse
      ; association_version =
          Aws.Util.option_bind (Aws.Xml.member "AssociationVersion" xml) String.parse
      ; execution_id =
          Aws.Util.option_bind (Aws.Xml.member "ExecutionId" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      ; detailed_status =
          Aws.Util.option_bind (Aws.Xml.member "DetailedStatus" xml) String.parse
      ; created_time =
          Aws.Util.option_bind (Aws.Xml.member "CreatedTime" xml) DateTime.parse
      ; last_execution_date =
          Aws.Util.option_bind (Aws.Xml.member "LastExecutionDate" xml) DateTime.parse
      ; resource_count_by_status =
          Aws.Util.option_bind (Aws.Xml.member "ResourceCountByStatus" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.resource_count_by_status (fun f ->
               Aws.Query.Pair ("ResourceCountByStatus", String.to_query f))
         ; Aws.Util.option_map v.last_execution_date (fun f ->
               Aws.Query.Pair ("LastExecutionDate", DateTime.to_query f))
         ; Aws.Util.option_map v.created_time (fun f ->
               Aws.Query.Pair ("CreatedTime", DateTime.to_query f))
         ; Aws.Util.option_map v.detailed_status (fun f ->
               Aws.Query.Pair ("DetailedStatus", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.execution_id (fun f ->
               Aws.Query.Pair ("ExecutionId", String.to_query f))
         ; Aws.Util.option_map v.association_version (fun f ->
               Aws.Query.Pair ("AssociationVersion", String.to_query f))
         ; Aws.Util.option_map v.association_id (fun f ->
               Aws.Query.Pair ("AssociationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.resource_count_by_status (fun f ->
               "ResourceCountByStatus", String.to_json f)
         ; Aws.Util.option_map v.last_execution_date (fun f ->
               "LastExecutionDate", DateTime.to_json f)
         ; Aws.Util.option_map v.created_time (fun f -> "CreatedTime", DateTime.to_json f)
         ; Aws.Util.option_map v.detailed_status (fun f ->
               "DetailedStatus", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ; Aws.Util.option_map v.execution_id (fun f -> "ExecutionId", String.to_json f)
         ; Aws.Util.option_map v.association_version (fun f ->
               "AssociationVersion", String.to_json f)
         ; Aws.Util.option_map v.association_id (fun f ->
               "AssociationId", String.to_json f)
         ])

  let of_json j =
    { association_id =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationId") String.of_json
    ; association_version =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationVersion") String.of_json
    ; execution_id = Aws.Util.option_map (Aws.Json.lookup j "ExecutionId") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    ; detailed_status =
        Aws.Util.option_map (Aws.Json.lookup j "DetailedStatus") String.of_json
    ; created_time =
        Aws.Util.option_map (Aws.Json.lookup j "CreatedTime") DateTime.of_json
    ; last_execution_date =
        Aws.Util.option_map (Aws.Json.lookup j "LastExecutionDate") DateTime.of_json
    ; resource_count_by_status =
        Aws.Util.option_map (Aws.Json.lookup j "ResourceCountByStatus") String.of_json
    }
end

module AssociationExecutionsList = struct
  type t = AssociationExecution.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map AssociationExecution.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list AssociationExecution.to_query v
  let to_json v = `List (List.map AssociationExecution.to_json v)
  let of_json j = Aws.Json.to_list AssociationExecution.of_json j
end

module DescribeAssociationExecutionsResult = struct
  type t =
    { association_executions : AssociationExecutionsList.t
    ; next_token : String.t option
    }

  let make ?(association_executions = []) ?next_token () =
    { association_executions; next_token }

  let parse xml =
    Some
      { association_executions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AssociationExecutions" xml)
               AssociationExecutionsList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "AssociationExecutions.member"
                , AssociationExecutionsList.to_query v.association_executions ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some
             ( "AssociationExecutions"
             , AssociationExecutionsList.to_json v.association_executions )
         ])

  let of_json j =
    { association_executions =
        AssociationExecutionsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AssociationExecutions"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module InvalidDocumentOperation = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module DescribeAssociationExecutionTargetsResult = struct
  type t =
    { association_execution_targets : AssociationExecutionTargetsList.t
    ; next_token : String.t option
    }

  let make ?(association_execution_targets = []) ?next_token () =
    { association_execution_targets; next_token }

  let parse xml =
    Some
      { association_execution_targets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AssociationExecutionTargets" xml)
               AssociationExecutionTargetsList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "AssociationExecutionTargets.member"
                , AssociationExecutionTargetsList.to_query v.association_execution_targets
                ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some
             ( "AssociationExecutionTargets"
             , AssociationExecutionTargetsList.to_json v.association_execution_targets )
         ])

  let of_json j =
    { association_execution_targets =
        AssociationExecutionTargetsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AssociationExecutionTargets"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module DeregisterTargetFromMaintenanceWindowResult = struct
  type t =
    { window_id : String.t option
    ; window_target_id : String.t option
    }

  let make ?window_id ?window_target_id () = { window_id; window_target_id }

  let parse xml =
    Some
      { window_id = Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse
      ; window_target_id =
          Aws.Util.option_bind (Aws.Xml.member "WindowTargetId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.window_target_id (fun f ->
               Aws.Query.Pair ("WindowTargetId", String.to_query f))
         ; Aws.Util.option_map v.window_id (fun f ->
               Aws.Query.Pair ("WindowId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.window_target_id (fun f ->
               "WindowTargetId", String.to_json f)
         ; Aws.Util.option_map v.window_id (fun f -> "WindowId", String.to_json f)
         ])

  let of_json j =
    { window_id = Aws.Util.option_map (Aws.Json.lookup j "WindowId") String.of_json
    ; window_target_id =
        Aws.Util.option_map (Aws.Json.lookup j "WindowTargetId") String.of_json
    }
end

module UpdateServiceSettingRequest = struct
  type t =
    { setting_id : String.t
    ; setting_value : String.t
    }

  let make ~setting_id ~setting_value () = { setting_id; setting_value }

  let parse xml =
    Some
      { setting_id =
          Aws.Xml.required
            "SettingId"
            (Aws.Util.option_bind (Aws.Xml.member "SettingId" xml) String.parse)
      ; setting_value =
          Aws.Xml.required
            "SettingValue"
            (Aws.Util.option_bind (Aws.Xml.member "SettingValue" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("SettingValue", String.to_query v.setting_value))
         ; Some (Aws.Query.Pair ("SettingId", String.to_query v.setting_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("SettingValue", String.to_json v.setting_value)
         ; Some ("SettingId", String.to_json v.setting_id)
         ])

  let of_json j =
    { setting_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SettingId"))
    ; setting_value =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SettingValue"))
    }
end

module StatusUnchanged = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module CreateAssociationBatchRequestEntries = struct
  type t = CreateAssociationBatchRequestEntry.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map CreateAssociationBatchRequestEntry.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list CreateAssociationBatchRequestEntry.to_query v
  let to_json v = `List (List.map CreateAssociationBatchRequestEntry.to_json v)
  let of_json j = Aws.Json.to_list CreateAssociationBatchRequestEntry.of_json j
end

module CreateAssociationBatchRequest = struct
  type t = { entries : CreateAssociationBatchRequestEntries.t }

  let make ~entries () = { entries }

  let parse xml =
    Some
      { entries =
          Aws.Xml.required
            "Entries"
            (Aws.Util.option_bind
               (Aws.Xml.member "Entries" xml)
               CreateAssociationBatchRequestEntries.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("Entries.member", CreateAssociationBatchRequestEntries.to_query v.entries))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Entries", CreateAssociationBatchRequestEntries.to_json v.entries) ])

  let of_json j =
    { entries =
        CreateAssociationBatchRequestEntries.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Entries"))
    }
end

module InvalidPolicyTypeException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json }
end

module DescribeAvailablePatchesRequest = struct
  type t =
    { filters : PatchOrchestratorFilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?(filters = []) ?max_results ?next_token () =
    { filters; max_results; next_token }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               PatchOrchestratorFilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Filters.member", PatchOrchestratorFilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filters", PatchOrchestratorFilterList.to_json v.filters)
         ])

  let of_json j =
    { filters =
        PatchOrchestratorFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module PatchSet = struct
  type t =
    | OS
    | APPLICATION

  let str_to_t = [ "APPLICATION", APPLICATION; "OS", OS ]
  let t_to_str = [ APPLICATION, "APPLICATION"; OS, "OS" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module InvalidAutomationSignalException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module ListInventoryEntriesRequest = struct
  type t =
    { instance_id : String.t
    ; type_name : String.t
    ; filters : InventoryFilterList.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    }

  let make ~instance_id ~type_name ?(filters = []) ?next_token ?max_results () =
    { instance_id; type_name; filters; next_token; max_results }

  let parse xml =
    Some
      { instance_id =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse)
      ; type_name =
          Aws.Xml.required
            "TypeName"
            (Aws.Util.option_bind (Aws.Xml.member "TypeName" xml) String.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               InventoryFilterList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair ("Filters.member", InventoryFilterList.to_query v.filters))
         ; Some (Aws.Query.Pair ("TypeName", String.to_query v.type_name))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Filters", InventoryFilterList.to_json v.filters)
         ; Some ("TypeName", String.to_json v.type_name)
         ; Some ("InstanceId", String.to_json v.instance_id)
         ])

  let of_json j =
    { instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; type_name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TypeName"))
    ; filters =
        InventoryFilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module InvalidAllowedPatternException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json }
end

module OpsEntityItemMap = struct
  type t = (String.t, OpsEntityItem.t) Hashtbl.t

  let make elems () = elems
  let parse xml = None
  let to_query v = Aws.Query.to_query_hashtbl String.to_string OpsEntityItem.to_query v

  let to_json v =
    `Assoc
      (Hashtbl.fold
         (fun k v acc -> (String.to_string k, OpsEntityItem.to_json v) :: acc)
         v
         [])

  let of_json j = Aws.Json.to_hashtbl String.of_string OpsEntityItem.of_json j
end

module DeleteMaintenanceWindowResult = struct
  type t = { window_id : String.t option }

  let make ?window_id () = { window_id }

  let parse xml =
    Some { window_id = Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.window_id (fun f ->
               Aws.Query.Pair ("WindowId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.window_id (fun f -> "WindowId", String.to_json f) ])

  let of_json j =
    { window_id = Aws.Util.option_map (Aws.Json.lookup j "WindowId") String.of_json }
end

module GetDeployablePatchSnapshotForInstanceRequest = struct
  type t =
    { instance_id : String.t
    ; snapshot_id : String.t
    }

  let make ~instance_id ~snapshot_id () = { instance_id; snapshot_id }

  let parse xml =
    Some
      { instance_id =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse)
      ; snapshot_id =
          Aws.Xml.required
            "SnapshotId"
            (Aws.Util.option_bind (Aws.Xml.member "SnapshotId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("SnapshotId", String.to_query v.snapshot_id))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("SnapshotId", String.to_json v.snapshot_id)
         ; Some ("InstanceId", String.to_json v.instance_id)
         ])

  let of_json j =
    { instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; snapshot_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SnapshotId"))
    }
end

module DescribeInstancePatchStatesForPatchGroupRequest = struct
  type t =
    { patch_group : String.t
    ; filters : InstancePatchStateFilterList.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    }

  let make ~patch_group ?(filters = []) ?next_token ?max_results () =
    { patch_group; filters; next_token; max_results }

  let parse xml =
    Some
      { patch_group =
          Aws.Xml.required
            "PatchGroup"
            (Aws.Util.option_bind (Aws.Xml.member "PatchGroup" xml) String.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               InstancePatchStateFilterList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Filters.member", InstancePatchStateFilterList.to_query v.filters))
         ; Some (Aws.Query.Pair ("PatchGroup", String.to_query v.patch_group))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Filters", InstancePatchStateFilterList.to_json v.filters)
         ; Some ("PatchGroup", String.to_json v.patch_group)
         ])

  let of_json j =
    { patch_group =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PatchGroup"))
    ; filters =
        InstancePatchStateFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module AutomationExecutionNotFoundException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module ListResourceComplianceSummariesResult = struct
  type t =
    { resource_compliance_summary_items : ResourceComplianceSummaryItemList.t
    ; next_token : String.t option
    }

  let make ?(resource_compliance_summary_items = []) ?next_token () =
    { resource_compliance_summary_items; next_token }

  let parse xml =
    Some
      { resource_compliance_summary_items =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ResourceComplianceSummaryItems" xml)
               ResourceComplianceSummaryItemList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ResourceComplianceSummaryItems.member"
                , ResourceComplianceSummaryItemList.to_query
                    v.resource_compliance_summary_items ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some
             ( "ResourceComplianceSummaryItems"
             , ResourceComplianceSummaryItemList.to_json
                 v.resource_compliance_summary_items )
         ])

  let of_json j =
    { resource_compliance_summary_items =
        ResourceComplianceSummaryItemList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ResourceComplianceSummaryItems"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module AssociationAlreadyExists = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module DescribeMaintenanceWindowExecutionsRequest = struct
  type t =
    { window_id : String.t
    ; filters : MaintenanceWindowFilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ~window_id ?(filters = []) ?max_results ?next_token () =
    { window_id; filters; max_results; next_token }

  let parse xml =
    Some
      { window_id =
          Aws.Xml.required
            "WindowId"
            (Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               MaintenanceWindowFilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Filters.member", MaintenanceWindowFilterList.to_query v.filters))
         ; Some (Aws.Query.Pair ("WindowId", String.to_query v.window_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filters", MaintenanceWindowFilterList.to_json v.filters)
         ; Some ("WindowId", String.to_json v.window_id)
         ])

  let of_json j =
    { window_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowId"))
    ; filters =
        MaintenanceWindowFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module InvalidNextToken = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module DescribePatchGroupStateRequest = struct
  type t = { patch_group : String.t }

  let make ~patch_group () = { patch_group }

  let parse xml =
    Some
      { patch_group =
          Aws.Xml.required
            "PatchGroup"
            (Aws.Util.option_bind (Aws.Xml.member "PatchGroup" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("PatchGroup", String.to_query v.patch_group)) ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt [ Some ("PatchGroup", String.to_json v.patch_group) ])

  let of_json j =
    { patch_group =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PatchGroup"))
    }
end

module InvalidDocumentType = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module OpsItemNotFoundException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module CreateMaintenanceWindowResult = struct
  type t = { window_id : String.t option }

  let make ?window_id () = { window_id }

  let parse xml =
    Some { window_id = Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.window_id (fun f ->
               Aws.Query.Pair ("WindowId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.window_id (fun f -> "WindowId", String.to_json f) ])

  let of_json j =
    { window_id = Aws.Util.option_map (Aws.Json.lookup j "WindowId") String.of_json }
end

module UpdateAssociationStatusRequest = struct
  type t =
    { name : String.t
    ; instance_id : String.t
    ; association_status : AssociationStatus.t
    }

  let make ~name ~instance_id ~association_status () =
    { name; instance_id; association_status }

  let parse xml =
    Some
      { name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      ; instance_id =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse)
      ; association_status =
          Aws.Xml.required
            "AssociationStatus"
            (Aws.Util.option_bind
               (Aws.Xml.member "AssociationStatus" xml)
               AssociationStatus.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("AssociationStatus", AssociationStatus.to_query v.association_status))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("AssociationStatus", AssociationStatus.to_json v.association_status)
         ; Some ("InstanceId", String.to_json v.instance_id)
         ; Some ("Name", String.to_json v.name)
         ])

  let of_json j =
    { name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; association_status =
        AssociationStatus.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AssociationStatus"))
    }
end

module DocumentParameter = struct
  type t =
    { name : String.t option
    ; type_ : DocumentParameterType.t option
    ; description : String.t option
    ; default_value : String.t option
    }

  let make ?name ?type_ ?description ?default_value () =
    { name; type_; description; default_value }

  let parse xml =
    Some
      { name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; type_ =
          Aws.Util.option_bind (Aws.Xml.member "Type" xml) DocumentParameterType.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; default_value =
          Aws.Util.option_bind (Aws.Xml.member "DefaultValue" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.default_value (fun f ->
               Aws.Query.Pair ("DefaultValue", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", DocumentParameterType.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.default_value (fun f -> "DefaultValue", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.type_ (fun f -> "Type", DocumentParameterType.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ])

  let of_json j =
    { name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; type_ = Aws.Util.option_map (Aws.Json.lookup j "Type") DocumentParameterType.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; default_value =
        Aws.Util.option_map (Aws.Json.lookup j "DefaultValue") String.of_json
    }
end

module DocumentParameterList = struct
  type t = DocumentParameter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map DocumentParameter.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list DocumentParameter.to_query v
  let to_json v = `List (List.map DocumentParameter.to_json v)
  let of_json j = Aws.Json.to_list DocumentParameter.of_json j
end

module DocumentDescription = struct
  type t =
    { sha1 : String.t option
    ; hash : String.t option
    ; hash_type : DocumentHashType.t option
    ; name : String.t option
    ; version_name : String.t option
    ; owner : String.t option
    ; created_date : DateTime.t option
    ; status : DocumentStatus.t option
    ; status_information : String.t option
    ; document_version : String.t option
    ; description : String.t option
    ; parameters : DocumentParameterList.t
    ; platform_types : PlatformTypeList.t
    ; document_type : DocumentType.t option
    ; schema_version : String.t option
    ; latest_version : String.t option
    ; default_version : String.t option
    ; document_format : DocumentFormat.t option
    ; target_type : String.t option
    ; tags : TagList.t
    ; attachments_information : AttachmentInformationList.t
    ; requires : DocumentRequiresList.t
    }

  let make
      ?sha1
      ?hash
      ?hash_type
      ?name
      ?version_name
      ?owner
      ?created_date
      ?status
      ?status_information
      ?document_version
      ?description
      ?(parameters = [])
      ?(platform_types = [])
      ?document_type
      ?schema_version
      ?latest_version
      ?default_version
      ?document_format
      ?target_type
      ?(tags = [])
      ?(attachments_information = [])
      ?(requires = [])
      () =
    { sha1
    ; hash
    ; hash_type
    ; name
    ; version_name
    ; owner
    ; created_date
    ; status
    ; status_information
    ; document_version
    ; description
    ; parameters
    ; platform_types
    ; document_type
    ; schema_version
    ; latest_version
    ; default_version
    ; document_format
    ; target_type
    ; tags
    ; attachments_information
    ; requires
    }

  let parse xml =
    Some
      { sha1 = Aws.Util.option_bind (Aws.Xml.member "Sha1" xml) String.parse
      ; hash = Aws.Util.option_bind (Aws.Xml.member "Hash" xml) String.parse
      ; hash_type =
          Aws.Util.option_bind (Aws.Xml.member "HashType" xml) DocumentHashType.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; version_name =
          Aws.Util.option_bind (Aws.Xml.member "VersionName" xml) String.parse
      ; owner = Aws.Util.option_bind (Aws.Xml.member "Owner" xml) String.parse
      ; created_date =
          Aws.Util.option_bind (Aws.Xml.member "CreatedDate" xml) DateTime.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) DocumentStatus.parse
      ; status_information =
          Aws.Util.option_bind (Aws.Xml.member "StatusInformation" xml) String.parse
      ; document_version =
          Aws.Util.option_bind (Aws.Xml.member "DocumentVersion" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; parameters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Parameters" xml)
               DocumentParameterList.parse)
      ; platform_types =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "PlatformTypes" xml)
               PlatformTypeList.parse)
      ; document_type =
          Aws.Util.option_bind (Aws.Xml.member "DocumentType" xml) DocumentType.parse
      ; schema_version =
          Aws.Util.option_bind (Aws.Xml.member "SchemaVersion" xml) String.parse
      ; latest_version =
          Aws.Util.option_bind (Aws.Xml.member "LatestVersion" xml) String.parse
      ; default_version =
          Aws.Util.option_bind (Aws.Xml.member "DefaultVersion" xml) String.parse
      ; document_format =
          Aws.Util.option_bind (Aws.Xml.member "DocumentFormat" xml) DocumentFormat.parse
      ; target_type = Aws.Util.option_bind (Aws.Xml.member "TargetType" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      ; attachments_information =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AttachmentsInformation" xml)
               AttachmentInformationList.parse)
      ; requires =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Requires" xml)
               DocumentRequiresList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("Requires.member", DocumentRequiresList.to_query v.requires))
         ; Some
             (Aws.Query.Pair
                ( "AttachmentsInformation.member"
                , AttachmentInformationList.to_query v.attachments_information ))
         ; Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Aws.Util.option_map v.target_type (fun f ->
               Aws.Query.Pair ("TargetType", String.to_query f))
         ; Aws.Util.option_map v.document_format (fun f ->
               Aws.Query.Pair ("DocumentFormat", DocumentFormat.to_query f))
         ; Aws.Util.option_map v.default_version (fun f ->
               Aws.Query.Pair ("DefaultVersion", String.to_query f))
         ; Aws.Util.option_map v.latest_version (fun f ->
               Aws.Query.Pair ("LatestVersion", String.to_query f))
         ; Aws.Util.option_map v.schema_version (fun f ->
               Aws.Query.Pair ("SchemaVersion", String.to_query f))
         ; Aws.Util.option_map v.document_type (fun f ->
               Aws.Query.Pair ("DocumentType", DocumentType.to_query f))
         ; Some
             (Aws.Query.Pair
                ("PlatformTypes.member", PlatformTypeList.to_query v.platform_types))
         ; Some
             (Aws.Query.Pair
                ("Parameters.member", DocumentParameterList.to_query v.parameters))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.document_version (fun f ->
               Aws.Query.Pair ("DocumentVersion", String.to_query f))
         ; Aws.Util.option_map v.status_information (fun f ->
               Aws.Query.Pair ("StatusInformation", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", DocumentStatus.to_query f))
         ; Aws.Util.option_map v.created_date (fun f ->
               Aws.Query.Pair ("CreatedDate", DateTime.to_query f))
         ; Aws.Util.option_map v.owner (fun f ->
               Aws.Query.Pair ("Owner", String.to_query f))
         ; Aws.Util.option_map v.version_name (fun f ->
               Aws.Query.Pair ("VersionName", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.hash_type (fun f ->
               Aws.Query.Pair ("HashType", DocumentHashType.to_query f))
         ; Aws.Util.option_map v.hash (fun f ->
               Aws.Query.Pair ("Hash", String.to_query f))
         ; Aws.Util.option_map v.sha1 (fun f ->
               Aws.Query.Pair ("Sha1", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Requires", DocumentRequiresList.to_json v.requires)
         ; Some
             ( "AttachmentsInformation"
             , AttachmentInformationList.to_json v.attachments_information )
         ; Some ("Tags", TagList.to_json v.tags)
         ; Aws.Util.option_map v.target_type (fun f -> "TargetType", String.to_json f)
         ; Aws.Util.option_map v.document_format (fun f ->
               "DocumentFormat", DocumentFormat.to_json f)
         ; Aws.Util.option_map v.default_version (fun f ->
               "DefaultVersion", String.to_json f)
         ; Aws.Util.option_map v.latest_version (fun f ->
               "LatestVersion", String.to_json f)
         ; Aws.Util.option_map v.schema_version (fun f ->
               "SchemaVersion", String.to_json f)
         ; Aws.Util.option_map v.document_type (fun f ->
               "DocumentType", DocumentType.to_json f)
         ; Some ("PlatformTypes", PlatformTypeList.to_json v.platform_types)
         ; Some ("Parameters", DocumentParameterList.to_json v.parameters)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.document_version (fun f ->
               "DocumentVersion", String.to_json f)
         ; Aws.Util.option_map v.status_information (fun f ->
               "StatusInformation", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", DocumentStatus.to_json f)
         ; Aws.Util.option_map v.created_date (fun f -> "CreatedDate", DateTime.to_json f)
         ; Aws.Util.option_map v.owner (fun f -> "Owner", String.to_json f)
         ; Aws.Util.option_map v.version_name (fun f -> "VersionName", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.hash_type (fun f ->
               "HashType", DocumentHashType.to_json f)
         ; Aws.Util.option_map v.hash (fun f -> "Hash", String.to_json f)
         ; Aws.Util.option_map v.sha1 (fun f -> "Sha1", String.to_json f)
         ])

  let of_json j =
    { sha1 = Aws.Util.option_map (Aws.Json.lookup j "Sha1") String.of_json
    ; hash = Aws.Util.option_map (Aws.Json.lookup j "Hash") String.of_json
    ; hash_type =
        Aws.Util.option_map (Aws.Json.lookup j "HashType") DocumentHashType.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; version_name = Aws.Util.option_map (Aws.Json.lookup j "VersionName") String.of_json
    ; owner = Aws.Util.option_map (Aws.Json.lookup j "Owner") String.of_json
    ; created_date =
        Aws.Util.option_map (Aws.Json.lookup j "CreatedDate") DateTime.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") DocumentStatus.of_json
    ; status_information =
        Aws.Util.option_map (Aws.Json.lookup j "StatusInformation") String.of_json
    ; document_version =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentVersion") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; parameters =
        DocumentParameterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Parameters"))
    ; platform_types =
        PlatformTypeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "PlatformTypes"))
    ; document_type =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentType") DocumentType.of_json
    ; schema_version =
        Aws.Util.option_map (Aws.Json.lookup j "SchemaVersion") String.of_json
    ; latest_version =
        Aws.Util.option_map (Aws.Json.lookup j "LatestVersion") String.of_json
    ; default_version =
        Aws.Util.option_map (Aws.Json.lookup j "DefaultVersion") String.of_json
    ; document_format =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentFormat") DocumentFormat.of_json
    ; target_type = Aws.Util.option_map (Aws.Json.lookup j "TargetType") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    ; attachments_information =
        AttachmentInformationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AttachmentsInformation"))
    ; requires =
        DocumentRequiresList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Requires"))
    }
end

module DescribeDocumentResult = struct
  type t = { document : DocumentDescription.t option }

  let make ?document () = { document }

  let parse xml =
    Some
      { document =
          Aws.Util.option_bind (Aws.Xml.member "Document" xml) DocumentDescription.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.document (fun f ->
               Aws.Query.Pair ("Document", DocumentDescription.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.document (fun f ->
               "Document", DocumentDescription.to_json f)
         ])

  let of_json j =
    { document =
        Aws.Util.option_map (Aws.Json.lookup j "Document") DocumentDescription.of_json
    }
end

module DeleteParameterRequest = struct
  type t = { name : String.t }

  let make ~name () = { name }

  let parse xml =
    Some
      { name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Name", String.to_query v.name)) ])

  let to_json v =
    `Assoc (Aws.Util.list_filter_opt [ Some ("Name", String.to_json v.name) ])

  let of_json j =
    { name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name")) }
end

module AssociationLimitExceeded = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module StartAssociationsOnceRequest = struct
  type t = { association_ids : AssociationIdList.t }

  let make ~association_ids () = { association_ids }

  let parse xml =
    Some
      { association_ids =
          Aws.Xml.required
            "AssociationIds"
            (Aws.Util.option_bind
               (Aws.Xml.member "AssociationIds" xml)
               AssociationIdList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("AssociationIds.member", AssociationIdList.to_query v.association_ids))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("AssociationIds", AssociationIdList.to_json v.association_ids) ])

  let of_json j =
    { association_ids =
        AssociationIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AssociationIds"))
    }
end

module DescribePatchPropertiesResult = struct
  type t =
    { properties : PatchPropertiesList.t
    ; next_token : String.t option
    }

  let make ?(properties = []) ?next_token () = { properties; next_token }

  let parse xml =
    Some
      { properties =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Properties" xml)
               PatchPropertiesList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Properties.member", PatchPropertiesList.to_query v.properties))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Properties", PatchPropertiesList.to_json v.properties)
         ])

  let of_json j =
    { properties =
        PatchPropertiesList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Properties"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module PatchBaselineIdentityList = struct
  type t = PatchBaselineIdentity.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map PatchBaselineIdentity.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list PatchBaselineIdentity.to_query v
  let to_json v = `List (List.map PatchBaselineIdentity.to_json v)
  let of_json j = Aws.Json.to_list PatchBaselineIdentity.of_json j
end

module UnsupportedCalendarException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module DescribeEffectiveInstanceAssociationsResult = struct
  type t =
    { associations : InstanceAssociationList.t
    ; next_token : String.t option
    }

  let make ?(associations = []) ?next_token () = { associations; next_token }

  let parse xml =
    Some
      { associations =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Associations" xml)
               InstanceAssociationList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Associations.member", InstanceAssociationList.to_query v.associations))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Associations", InstanceAssociationList.to_json v.associations)
         ])

  let of_json j =
    { associations =
        InstanceAssociationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Associations"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module RegisterTaskWithMaintenanceWindowRequest = struct
  type t =
    { window_id : String.t
    ; targets : Targets.t
    ; task_arn : String.t
    ; service_role_arn : String.t option
    ; task_type : MaintenanceWindowTaskType.t
    ; task_parameters : MaintenanceWindowTaskParameters.t option
    ; task_invocation_parameters : MaintenanceWindowTaskInvocationParameters.t option
    ; priority : Integer.t option
    ; max_concurrency : String.t
    ; max_errors : String.t
    ; logging_info : LoggingInfo.t option
    ; name : String.t option
    ; description : String.t option
    ; client_token : String.t option
    }

  let make
      ~window_id
      ~targets
      ~task_arn
      ?service_role_arn
      ~task_type
      ?task_parameters
      ?task_invocation_parameters
      ?priority
      ~max_concurrency
      ~max_errors
      ?logging_info
      ?name
      ?description
      ?client_token
      () =
    { window_id
    ; targets
    ; task_arn
    ; service_role_arn
    ; task_type
    ; task_parameters
    ; task_invocation_parameters
    ; priority
    ; max_concurrency
    ; max_errors
    ; logging_info
    ; name
    ; description
    ; client_token
    }

  let parse xml =
    Some
      { window_id =
          Aws.Xml.required
            "WindowId"
            (Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse)
      ; targets =
          Aws.Xml.required
            "Targets"
            (Aws.Util.option_bind (Aws.Xml.member "Targets" xml) Targets.parse)
      ; task_arn =
          Aws.Xml.required
            "TaskArn"
            (Aws.Util.option_bind (Aws.Xml.member "TaskArn" xml) String.parse)
      ; service_role_arn =
          Aws.Util.option_bind (Aws.Xml.member "ServiceRoleArn" xml) String.parse
      ; task_type =
          Aws.Xml.required
            "TaskType"
            (Aws.Util.option_bind
               (Aws.Xml.member "TaskType" xml)
               MaintenanceWindowTaskType.parse)
      ; task_parameters =
          Aws.Util.option_bind
            (Aws.Xml.member "TaskParameters" xml)
            MaintenanceWindowTaskParameters.parse
      ; task_invocation_parameters =
          Aws.Util.option_bind
            (Aws.Xml.member "TaskInvocationParameters" xml)
            MaintenanceWindowTaskInvocationParameters.parse
      ; priority = Aws.Util.option_bind (Aws.Xml.member "Priority" xml) Integer.parse
      ; max_concurrency =
          Aws.Xml.required
            "MaxConcurrency"
            (Aws.Util.option_bind (Aws.Xml.member "MaxConcurrency" xml) String.parse)
      ; max_errors =
          Aws.Xml.required
            "MaxErrors"
            (Aws.Util.option_bind (Aws.Xml.member "MaxErrors" xml) String.parse)
      ; logging_info =
          Aws.Util.option_bind (Aws.Xml.member "LoggingInfo" xml) LoggingInfo.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.logging_info (fun f ->
               Aws.Query.Pair ("LoggingInfo", LoggingInfo.to_query f))
         ; Some (Aws.Query.Pair ("MaxErrors", String.to_query v.max_errors))
         ; Some (Aws.Query.Pair ("MaxConcurrency", String.to_query v.max_concurrency))
         ; Aws.Util.option_map v.priority (fun f ->
               Aws.Query.Pair ("Priority", Integer.to_query f))
         ; Aws.Util.option_map v.task_invocation_parameters (fun f ->
               Aws.Query.Pair
                 ( "TaskInvocationParameters"
                 , MaintenanceWindowTaskInvocationParameters.to_query f ))
         ; Aws.Util.option_map v.task_parameters (fun f ->
               Aws.Query.Pair
                 ("TaskParameters", MaintenanceWindowTaskParameters.to_query f))
         ; Some
             (Aws.Query.Pair ("TaskType", MaintenanceWindowTaskType.to_query v.task_type))
         ; Aws.Util.option_map v.service_role_arn (fun f ->
               Aws.Query.Pair ("ServiceRoleArn", String.to_query f))
         ; Some (Aws.Query.Pair ("TaskArn", String.to_query v.task_arn))
         ; Some (Aws.Query.Pair ("Targets.member", Targets.to_query v.targets))
         ; Some (Aws.Query.Pair ("WindowId", String.to_query v.window_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.logging_info (fun f ->
               "LoggingInfo", LoggingInfo.to_json f)
         ; Some ("MaxErrors", String.to_json v.max_errors)
         ; Some ("MaxConcurrency", String.to_json v.max_concurrency)
         ; Aws.Util.option_map v.priority (fun f -> "Priority", Integer.to_json f)
         ; Aws.Util.option_map v.task_invocation_parameters (fun f ->
               ( "TaskInvocationParameters"
               , MaintenanceWindowTaskInvocationParameters.to_json f ))
         ; Aws.Util.option_map v.task_parameters (fun f ->
               "TaskParameters", MaintenanceWindowTaskParameters.to_json f)
         ; Some ("TaskType", MaintenanceWindowTaskType.to_json v.task_type)
         ; Aws.Util.option_map v.service_role_arn (fun f ->
               "ServiceRoleArn", String.to_json f)
         ; Some ("TaskArn", String.to_json v.task_arn)
         ; Some ("Targets", Targets.to_json v.targets)
         ; Some ("WindowId", String.to_json v.window_id)
         ])

  let of_json j =
    { window_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowId"))
    ; targets = Targets.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Targets"))
    ; task_arn = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TaskArn"))
    ; service_role_arn =
        Aws.Util.option_map (Aws.Json.lookup j "ServiceRoleArn") String.of_json
    ; task_type =
        MaintenanceWindowTaskType.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TaskType"))
    ; task_parameters =
        Aws.Util.option_map
          (Aws.Json.lookup j "TaskParameters")
          MaintenanceWindowTaskParameters.of_json
    ; task_invocation_parameters =
        Aws.Util.option_map
          (Aws.Json.lookup j "TaskInvocationParameters")
          MaintenanceWindowTaskInvocationParameters.of_json
    ; priority = Aws.Util.option_map (Aws.Json.lookup j "Priority") Integer.of_json
    ; max_concurrency =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "MaxConcurrency"))
    ; max_errors = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "MaxErrors"))
    ; logging_info =
        Aws.Util.option_map (Aws.Json.lookup j "LoggingInfo") LoggingInfo.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    }
end

module ParameterMetadataList = struct
  type t = ParameterMetadata.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ParameterMetadata.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list ParameterMetadata.to_query v
  let to_json v = `List (List.map ParameterMetadata.to_json v)
  let of_json j = Aws.Json.to_list ParameterMetadata.of_json j
end

module UpdateResourceDataSyncResult = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module InventoryResultEntityList = struct
  type t = InventoryResultEntity.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map InventoryResultEntity.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list InventoryResultEntity.to_query v
  let to_json v = `List (List.map InventoryResultEntity.to_json v)
  let of_json j = Aws.Json.to_list InventoryResultEntity.of_json j
end

module GetInventoryResult = struct
  type t =
    { entities : InventoryResultEntityList.t
    ; next_token : String.t option
    }

  let make ?(entities = []) ?next_token () = { entities; next_token }

  let parse xml =
    Some
      { entities =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Entities" xml)
               InventoryResultEntityList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Entities.member", InventoryResultEntityList.to_query v.entities))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Entities", InventoryResultEntityList.to_json v.entities)
         ])

  let of_json j =
    { entities =
        InventoryResultEntityList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Entities"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module AssociationDoesNotExist = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module FeatureNotAvailableException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module CreatePatchBaselineRequest = struct
  type t =
    { operating_system : OperatingSystem.t option
    ; name : String.t
    ; global_filters : PatchFilterGroup.t option
    ; approval_rules : PatchRuleGroup.t option
    ; approved_patches : PatchIdList.t
    ; approved_patches_compliance_level : PatchComplianceLevel.t option
    ; approved_patches_enable_non_security : Boolean.t option
    ; rejected_patches : PatchIdList.t
    ; rejected_patches_action : PatchAction.t option
    ; description : String.t option
    ; sources : PatchSourceList.t
    ; client_token : String.t option
    ; tags : TagList.t
    }

  let make
      ?operating_system
      ~name
      ?global_filters
      ?approval_rules
      ?(approved_patches = [])
      ?approved_patches_compliance_level
      ?approved_patches_enable_non_security
      ?(rejected_patches = [])
      ?rejected_patches_action
      ?description
      ?(sources = [])
      ?client_token
      ?(tags = [])
      () =
    { operating_system
    ; name
    ; global_filters
    ; approval_rules
    ; approved_patches
    ; approved_patches_compliance_level
    ; approved_patches_enable_non_security
    ; rejected_patches
    ; rejected_patches_action
    ; description
    ; sources
    ; client_token
    ; tags
    }

  let parse xml =
    Some
      { operating_system =
          Aws.Util.option_bind
            (Aws.Xml.member "OperatingSystem" xml)
            OperatingSystem.parse
      ; name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      ; global_filters =
          Aws.Util.option_bind (Aws.Xml.member "GlobalFilters" xml) PatchFilterGroup.parse
      ; approval_rules =
          Aws.Util.option_bind (Aws.Xml.member "ApprovalRules" xml) PatchRuleGroup.parse
      ; approved_patches =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ApprovedPatches" xml)
               PatchIdList.parse)
      ; approved_patches_compliance_level =
          Aws.Util.option_bind
            (Aws.Xml.member "ApprovedPatchesComplianceLevel" xml)
            PatchComplianceLevel.parse
      ; approved_patches_enable_non_security =
          Aws.Util.option_bind
            (Aws.Xml.member "ApprovedPatchesEnableNonSecurity" xml)
            Boolean.parse
      ; rejected_patches =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "RejectedPatches" xml)
               PatchIdList.parse)
      ; rejected_patches_action =
          Aws.Util.option_bind
            (Aws.Xml.member "RejectedPatchesAction" xml)
            PatchAction.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; sources =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Sources" xml) PatchSourceList.parse)
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Some (Aws.Query.Pair ("Sources.member", PatchSourceList.to_query v.sources))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.rejected_patches_action (fun f ->
               Aws.Query.Pair ("RejectedPatchesAction", PatchAction.to_query f))
         ; Some
             (Aws.Query.Pair
                ("RejectedPatches.member", PatchIdList.to_query v.rejected_patches))
         ; Aws.Util.option_map v.approved_patches_enable_non_security (fun f ->
               Aws.Query.Pair ("ApprovedPatchesEnableNonSecurity", Boolean.to_query f))
         ; Aws.Util.option_map v.approved_patches_compliance_level (fun f ->
               Aws.Query.Pair
                 ("ApprovedPatchesComplianceLevel", PatchComplianceLevel.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ApprovedPatches.member", PatchIdList.to_query v.approved_patches))
         ; Aws.Util.option_map v.approval_rules (fun f ->
               Aws.Query.Pair ("ApprovalRules", PatchRuleGroup.to_query f))
         ; Aws.Util.option_map v.global_filters (fun f ->
               Aws.Query.Pair ("GlobalFilters", PatchFilterGroup.to_query f))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ; Aws.Util.option_map v.operating_system (fun f ->
               Aws.Query.Pair ("OperatingSystem", OperatingSystem.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tags", TagList.to_json v.tags)
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Some ("Sources", PatchSourceList.to_json v.sources)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.rejected_patches_action (fun f ->
               "RejectedPatchesAction", PatchAction.to_json f)
         ; Some ("RejectedPatches", PatchIdList.to_json v.rejected_patches)
         ; Aws.Util.option_map v.approved_patches_enable_non_security (fun f ->
               "ApprovedPatchesEnableNonSecurity", Boolean.to_json f)
         ; Aws.Util.option_map v.approved_patches_compliance_level (fun f ->
               "ApprovedPatchesComplianceLevel", PatchComplianceLevel.to_json f)
         ; Some ("ApprovedPatches", PatchIdList.to_json v.approved_patches)
         ; Aws.Util.option_map v.approval_rules (fun f ->
               "ApprovalRules", PatchRuleGroup.to_json f)
         ; Aws.Util.option_map v.global_filters (fun f ->
               "GlobalFilters", PatchFilterGroup.to_json f)
         ; Some ("Name", String.to_json v.name)
         ; Aws.Util.option_map v.operating_system (fun f ->
               "OperatingSystem", OperatingSystem.to_json f)
         ])

  let of_json j =
    { operating_system =
        Aws.Util.option_map (Aws.Json.lookup j "OperatingSystem") OperatingSystem.of_json
    ; name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; global_filters =
        Aws.Util.option_map (Aws.Json.lookup j "GlobalFilters") PatchFilterGroup.of_json
    ; approval_rules =
        Aws.Util.option_map (Aws.Json.lookup j "ApprovalRules") PatchRuleGroup.of_json
    ; approved_patches =
        PatchIdList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ApprovedPatches"))
    ; approved_patches_compliance_level =
        Aws.Util.option_map
          (Aws.Json.lookup j "ApprovedPatchesComplianceLevel")
          PatchComplianceLevel.of_json
    ; approved_patches_enable_non_security =
        Aws.Util.option_map
          (Aws.Json.lookup j "ApprovedPatchesEnableNonSecurity")
          Boolean.of_json
    ; rejected_patches =
        PatchIdList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "RejectedPatches"))
    ; rejected_patches_action =
        Aws.Util.option_map
          (Aws.Json.lookup j "RejectedPatchesAction")
          PatchAction.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; sources =
        PatchSourceList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Sources"))
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    }
end

module TooManyTagsError = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module ListCommandsRequest = struct
  type t =
    { command_id : String.t option
    ; instance_id : String.t option
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; filters : CommandFilterList.t
    }

  let make ?command_id ?instance_id ?max_results ?next_token ?(filters = []) () =
    { command_id; instance_id; max_results; next_token; filters }

  let parse xml =
    Some
      { command_id = Aws.Util.option_bind (Aws.Xml.member "CommandId" xml) String.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) CommandFilterList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Filters.member", CommandFilterList.to_query v.filters))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.command_id (fun f ->
               Aws.Query.Pair ("CommandId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Filters", CommandFilterList.to_json v.filters)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "InstanceId", String.to_json f)
         ; Aws.Util.option_map v.command_id (fun f -> "CommandId", String.to_json f)
         ])

  let of_json j =
    { command_id = Aws.Util.option_map (Aws.Json.lookup j "CommandId") String.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "InstanceId") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; filters =
        CommandFilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    }
end

module OpsItemOpsDataKeysList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module TerminateSessionRequest = struct
  type t = { session_id : String.t }

  let make ~session_id () = { session_id }

  let parse xml =
    Some
      { session_id =
          Aws.Xml.required
            "SessionId"
            (Aws.Util.option_bind (Aws.Xml.member "SessionId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("SessionId", String.to_query v.session_id)) ])

  let to_json v =
    `Assoc (Aws.Util.list_filter_opt [ Some ("SessionId", String.to_json v.session_id) ])

  let of_json j =
    { session_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SessionId"))
    }
end

module StepExecutionFilterKey = struct
  type t =
    | StartTimeBefore
    | StartTimeAfter
    | StepExecutionStatus
    | StepExecutionId
    | StepName
    | Action

  let str_to_t =
    [ "Action", Action
    ; "StepName", StepName
    ; "StepExecutionId", StepExecutionId
    ; "StepExecutionStatus", StepExecutionStatus
    ; "StartTimeAfter", StartTimeAfter
    ; "StartTimeBefore", StartTimeBefore
    ]

  let t_to_str =
    [ Action, "Action"
    ; StepName, "StepName"
    ; StepExecutionId, "StepExecutionId"
    ; StepExecutionStatus, "StepExecutionStatus"
    ; StartTimeAfter, "StartTimeAfter"
    ; StartTimeBefore, "StartTimeBefore"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module InvalidAggregatorException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module MaintenanceWindowTask = struct
  type t =
    { window_id : String.t option
    ; window_task_id : String.t option
    ; task_arn : String.t option
    ; type_ : MaintenanceWindowTaskType.t option
    ; targets : Targets.t
    ; task_parameters : MaintenanceWindowTaskParameters.t option
    ; priority : Integer.t option
    ; logging_info : LoggingInfo.t option
    ; service_role_arn : String.t option
    ; max_concurrency : String.t option
    ; max_errors : String.t option
    ; name : String.t option
    ; description : String.t option
    }

  let make
      ?window_id
      ?window_task_id
      ?task_arn
      ?type_
      ?(targets = [])
      ?task_parameters
      ?priority
      ?logging_info
      ?service_role_arn
      ?max_concurrency
      ?max_errors
      ?name
      ?description
      () =
    { window_id
    ; window_task_id
    ; task_arn
    ; type_
    ; targets
    ; task_parameters
    ; priority
    ; logging_info
    ; service_role_arn
    ; max_concurrency
    ; max_errors
    ; name
    ; description
    }

  let parse xml =
    Some
      { window_id = Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse
      ; window_task_id =
          Aws.Util.option_bind (Aws.Xml.member "WindowTaskId" xml) String.parse
      ; task_arn = Aws.Util.option_bind (Aws.Xml.member "TaskArn" xml) String.parse
      ; type_ =
          Aws.Util.option_bind (Aws.Xml.member "Type" xml) MaintenanceWindowTaskType.parse
      ; targets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Targets" xml) Targets.parse)
      ; task_parameters =
          Aws.Util.option_bind
            (Aws.Xml.member "TaskParameters" xml)
            MaintenanceWindowTaskParameters.parse
      ; priority = Aws.Util.option_bind (Aws.Xml.member "Priority" xml) Integer.parse
      ; logging_info =
          Aws.Util.option_bind (Aws.Xml.member "LoggingInfo" xml) LoggingInfo.parse
      ; service_role_arn =
          Aws.Util.option_bind (Aws.Xml.member "ServiceRoleArn" xml) String.parse
      ; max_concurrency =
          Aws.Util.option_bind (Aws.Xml.member "MaxConcurrency" xml) String.parse
      ; max_errors = Aws.Util.option_bind (Aws.Xml.member "MaxErrors" xml) String.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.max_errors (fun f ->
               Aws.Query.Pair ("MaxErrors", String.to_query f))
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               Aws.Query.Pair ("MaxConcurrency", String.to_query f))
         ; Aws.Util.option_map v.service_role_arn (fun f ->
               Aws.Query.Pair ("ServiceRoleArn", String.to_query f))
         ; Aws.Util.option_map v.logging_info (fun f ->
               Aws.Query.Pair ("LoggingInfo", LoggingInfo.to_query f))
         ; Aws.Util.option_map v.priority (fun f ->
               Aws.Query.Pair ("Priority", Integer.to_query f))
         ; Aws.Util.option_map v.task_parameters (fun f ->
               Aws.Query.Pair
                 ("TaskParameters", MaintenanceWindowTaskParameters.to_query f))
         ; Some (Aws.Query.Pair ("Targets.member", Targets.to_query v.targets))
         ; Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", MaintenanceWindowTaskType.to_query f))
         ; Aws.Util.option_map v.task_arn (fun f ->
               Aws.Query.Pair ("TaskArn", String.to_query f))
         ; Aws.Util.option_map v.window_task_id (fun f ->
               Aws.Query.Pair ("WindowTaskId", String.to_query f))
         ; Aws.Util.option_map v.window_id (fun f ->
               Aws.Query.Pair ("WindowId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.max_errors (fun f -> "MaxErrors", String.to_json f)
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               "MaxConcurrency", String.to_json f)
         ; Aws.Util.option_map v.service_role_arn (fun f ->
               "ServiceRoleArn", String.to_json f)
         ; Aws.Util.option_map v.logging_info (fun f ->
               "LoggingInfo", LoggingInfo.to_json f)
         ; Aws.Util.option_map v.priority (fun f -> "Priority", Integer.to_json f)
         ; Aws.Util.option_map v.task_parameters (fun f ->
               "TaskParameters", MaintenanceWindowTaskParameters.to_json f)
         ; Some ("Targets", Targets.to_json v.targets)
         ; Aws.Util.option_map v.type_ (fun f ->
               "Type", MaintenanceWindowTaskType.to_json f)
         ; Aws.Util.option_map v.task_arn (fun f -> "TaskArn", String.to_json f)
         ; Aws.Util.option_map v.window_task_id (fun f ->
               "WindowTaskId", String.to_json f)
         ; Aws.Util.option_map v.window_id (fun f -> "WindowId", String.to_json f)
         ])

  let of_json j =
    { window_id = Aws.Util.option_map (Aws.Json.lookup j "WindowId") String.of_json
    ; window_task_id =
        Aws.Util.option_map (Aws.Json.lookup j "WindowTaskId") String.of_json
    ; task_arn = Aws.Util.option_map (Aws.Json.lookup j "TaskArn") String.of_json
    ; type_ =
        Aws.Util.option_map (Aws.Json.lookup j "Type") MaintenanceWindowTaskType.of_json
    ; targets = Targets.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Targets"))
    ; task_parameters =
        Aws.Util.option_map
          (Aws.Json.lookup j "TaskParameters")
          MaintenanceWindowTaskParameters.of_json
    ; priority = Aws.Util.option_map (Aws.Json.lookup j "Priority") Integer.of_json
    ; logging_info =
        Aws.Util.option_map (Aws.Json.lookup j "LoggingInfo") LoggingInfo.of_json
    ; service_role_arn =
        Aws.Util.option_map (Aws.Json.lookup j "ServiceRoleArn") String.of_json
    ; max_concurrency =
        Aws.Util.option_map (Aws.Json.lookup j "MaxConcurrency") String.of_json
    ; max_errors = Aws.Util.option_map (Aws.Json.lookup j "MaxErrors") String.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    }
end

module MaintenanceWindowTaskList = struct
  type t = MaintenanceWindowTask.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map MaintenanceWindowTask.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list MaintenanceWindowTask.to_query v
  let to_json v = `List (List.map MaintenanceWindowTask.to_json v)
  let of_json j = Aws.Json.to_list MaintenanceWindowTask.of_json j
end

module DescribeMaintenanceWindowTasksResult = struct
  type t =
    { tasks : MaintenanceWindowTaskList.t
    ; next_token : String.t option
    }

  let make ?(tasks = []) ?next_token () = { tasks; next_token }

  let parse xml =
    Some
      { tasks =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Tasks" xml)
               MaintenanceWindowTaskList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair ("Tasks.member", MaintenanceWindowTaskList.to_query v.tasks))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Tasks", MaintenanceWindowTaskList.to_json v.tasks)
         ])

  let of_json j =
    { tasks =
        MaintenanceWindowTaskList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Tasks"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module DeregisterPatchBaselineForPatchGroupRequest = struct
  type t =
    { baseline_id : String.t
    ; patch_group : String.t
    }

  let make ~baseline_id ~patch_group () = { baseline_id; patch_group }

  let parse xml =
    Some
      { baseline_id =
          Aws.Xml.required
            "BaselineId"
            (Aws.Util.option_bind (Aws.Xml.member "BaselineId" xml) String.parse)
      ; patch_group =
          Aws.Xml.required
            "PatchGroup"
            (Aws.Util.option_bind (Aws.Xml.member "PatchGroup" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("PatchGroup", String.to_query v.patch_group))
         ; Some (Aws.Query.Pair ("BaselineId", String.to_query v.baseline_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("PatchGroup", String.to_json v.patch_group)
         ; Some ("BaselineId", String.to_json v.baseline_id)
         ])

  let of_json j =
    { baseline_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "BaselineId"))
    ; patch_group =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PatchGroup"))
    }
end

module ListComplianceItemsResult = struct
  type t =
    { compliance_items : ComplianceItemList.t
    ; next_token : String.t option
    }

  let make ?(compliance_items = []) ?next_token () = { compliance_items; next_token }

  let parse xml =
    Some
      { compliance_items =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ComplianceItems" xml)
               ComplianceItemList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ComplianceItems.member", ComplianceItemList.to_query v.compliance_items))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("ComplianceItems", ComplianceItemList.to_json v.compliance_items)
         ])

  let of_json j =
    { compliance_items =
        ComplianceItemList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ComplianceItems"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module StepExecutionFilter = struct
  type t =
    { key : StepExecutionFilterKey.t
    ; values : StepExecutionFilterValueList.t
    }

  let make ~key ~values () = { key; values }

  let parse xml =
    Some
      { key =
          Aws.Xml.required
            "Key"
            (Aws.Util.option_bind (Aws.Xml.member "Key" xml) StepExecutionFilterKey.parse)
      ; values =
          Aws.Xml.required
            "Values"
            (Aws.Util.option_bind
               (Aws.Xml.member "Values" xml)
               StepExecutionFilterValueList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("Values.member", StepExecutionFilterValueList.to_query v.values))
         ; Some (Aws.Query.Pair ("Key", StepExecutionFilterKey.to_query v.key))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Values", StepExecutionFilterValueList.to_json v.values)
         ; Some ("Key", StepExecutionFilterKey.to_json v.key)
         ])

  let of_json j =
    { key =
        StepExecutionFilterKey.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Key"))
    ; values =
        StepExecutionFilterValueList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Values"))
    }
end

module StepExecutionFilterList = struct
  type t = StepExecutionFilter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map StepExecutionFilter.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list StepExecutionFilter.to_query v
  let to_json v = `List (List.map StepExecutionFilter.to_json v)
  let of_json j = Aws.Json.to_list StepExecutionFilter.of_json j
end

module DescribeMaintenanceWindowScheduleRequest = struct
  type t =
    { window_id : String.t option
    ; targets : Targets.t
    ; resource_type : MaintenanceWindowResourceType.t option
    ; filters : PatchOrchestratorFilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make
      ?window_id
      ?(targets = [])
      ?resource_type
      ?(filters = [])
      ?max_results
      ?next_token
      () =
    { window_id; targets; resource_type; filters; max_results; next_token }

  let parse xml =
    Some
      { window_id = Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse
      ; targets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Targets" xml) Targets.parse)
      ; resource_type =
          Aws.Util.option_bind
            (Aws.Xml.member "ResourceType" xml)
            MaintenanceWindowResourceType.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               PatchOrchestratorFilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Filters.member", PatchOrchestratorFilterList.to_query v.filters))
         ; Aws.Util.option_map v.resource_type (fun f ->
               Aws.Query.Pair ("ResourceType", MaintenanceWindowResourceType.to_query f))
         ; Some (Aws.Query.Pair ("Targets.member", Targets.to_query v.targets))
         ; Aws.Util.option_map v.window_id (fun f ->
               Aws.Query.Pair ("WindowId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filters", PatchOrchestratorFilterList.to_json v.filters)
         ; Aws.Util.option_map v.resource_type (fun f ->
               "ResourceType", MaintenanceWindowResourceType.to_json f)
         ; Some ("Targets", Targets.to_json v.targets)
         ; Aws.Util.option_map v.window_id (fun f -> "WindowId", String.to_json f)
         ])

  let of_json j =
    { window_id = Aws.Util.option_map (Aws.Json.lookup j "WindowId") String.of_json
    ; targets = Targets.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Targets"))
    ; resource_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "ResourceType")
          MaintenanceWindowResourceType.of_json
    ; filters =
        PatchOrchestratorFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module ScheduledWindowExecutionList = struct
  type t = ScheduledWindowExecution.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ScheduledWindowExecution.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list ScheduledWindowExecution.to_query v
  let to_json v = `List (List.map ScheduledWindowExecution.to_json v)
  let of_json j = Aws.Json.to_list ScheduledWindowExecution.of_json j
end

module DescribeActivationsResult = struct
  type t =
    { activation_list : ActivationList.t
    ; next_token : String.t option
    }

  let make ?(activation_list = []) ?next_token () = { activation_list; next_token }

  let parse xml =
    Some
      { activation_list =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ActivationList" xml)
               ActivationList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ActivationList.member", ActivationList.to_query v.activation_list))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("ActivationList", ActivationList.to_json v.activation_list)
         ])

  let of_json j =
    { activation_list =
        ActivationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ActivationList"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module OpsItemLimitExceededException = struct
  type t =
    { resource_types : OpsItemParameterNamesList.t
    ; limit : Integer.t option
    ; limit_type : String.t option
    ; message : String.t option
    }

  let make ?(resource_types = []) ?limit ?limit_type ?message () =
    { resource_types; limit; limit_type; message }

  let parse xml =
    Some
      { resource_types =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ResourceTypes" xml)
               OpsItemParameterNamesList.parse)
      ; limit = Aws.Util.option_bind (Aws.Xml.member "Limit" xml) Integer.parse
      ; limit_type = Aws.Util.option_bind (Aws.Xml.member "LimitType" xml) String.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.limit_type (fun f ->
               Aws.Query.Pair ("LimitType", String.to_query f))
         ; Aws.Util.option_map v.limit (fun f ->
               Aws.Query.Pair ("Limit", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ResourceTypes.member"
                , OpsItemParameterNamesList.to_query v.resource_types ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f)
         ; Aws.Util.option_map v.limit_type (fun f -> "LimitType", String.to_json f)
         ; Aws.Util.option_map v.limit (fun f -> "Limit", Integer.to_json f)
         ; Some ("ResourceTypes", OpsItemParameterNamesList.to_json v.resource_types)
         ])

  let of_json j =
    { resource_types =
        OpsItemParameterNamesList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ResourceTypes"))
    ; limit = Aws.Util.option_map (Aws.Json.lookup j "Limit") Integer.of_json
    ; limit_type = Aws.Util.option_map (Aws.Json.lookup j "LimitType") String.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json
    }
end

module InstanceInformationStringFilterList = struct
  type t = InstanceInformationStringFilter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map InstanceInformationStringFilter.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list InstanceInformationStringFilter.to_query v
  let to_json v = `List (List.map InstanceInformationStringFilter.to_json v)
  let of_json j = Aws.Json.to_list InstanceInformationStringFilter.of_json j
end

module UpdateDocumentResult = struct
  type t = { document_description : DocumentDescription.t option }

  let make ?document_description () = { document_description }

  let parse xml =
    Some
      { document_description =
          Aws.Util.option_bind
            (Aws.Xml.member "DocumentDescription" xml)
            DocumentDescription.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.document_description (fun f ->
               Aws.Query.Pair ("DocumentDescription", DocumentDescription.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.document_description (fun f ->
               "DocumentDescription", DocumentDescription.to_json f)
         ])

  let of_json j =
    { document_description =
        Aws.Util.option_map
          (Aws.Json.lookup j "DocumentDescription")
          DocumentDescription.of_json
    }
end

module ResourceDataSyncInvalidConfigurationException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module DescribeSessionsResponse = struct
  type t =
    { sessions : SessionList.t
    ; next_token : String.t option
    }

  let make ?(sessions = []) ?next_token () = { sessions; next_token }

  let parse xml =
    Some
      { sessions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Sessions" xml) SessionList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("Sessions.member", SessionList.to_query v.sessions))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Sessions", SessionList.to_json v.sessions)
         ])

  let of_json j =
    { sessions =
        SessionList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Sessions"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module DeleteDocumentRequest = struct
  type t =
    { name : String.t
    ; document_version : String.t option
    ; version_name : String.t option
    ; force : Boolean.t option
    }

  let make ~name ?document_version ?version_name ?force () =
    { name; document_version; version_name; force }

  let parse xml =
    Some
      { name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      ; document_version =
          Aws.Util.option_bind (Aws.Xml.member "DocumentVersion" xml) String.parse
      ; version_name =
          Aws.Util.option_bind (Aws.Xml.member "VersionName" xml) String.parse
      ; force = Aws.Util.option_bind (Aws.Xml.member "Force" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.force (fun f ->
               Aws.Query.Pair ("Force", Boolean.to_query f))
         ; Aws.Util.option_map v.version_name (fun f ->
               Aws.Query.Pair ("VersionName", String.to_query f))
         ; Aws.Util.option_map v.document_version (fun f ->
               Aws.Query.Pair ("DocumentVersion", String.to_query f))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.force (fun f -> "Force", Boolean.to_json f)
         ; Aws.Util.option_map v.version_name (fun f -> "VersionName", String.to_json f)
         ; Aws.Util.option_map v.document_version (fun f ->
               "DocumentVersion", String.to_json f)
         ; Some ("Name", String.to_json v.name)
         ])

  let of_json j =
    { name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; document_version =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentVersion") String.of_json
    ; version_name = Aws.Util.option_map (Aws.Json.lookup j "VersionName") String.of_json
    ; force = Aws.Util.option_map (Aws.Json.lookup j "Force") Boolean.of_json
    }
end

module CancelCommandResult = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module AutomationType = struct
  type t =
    | CrossAccount
    | Local

  let str_to_t = [ "Local", Local; "CrossAccount", CrossAccount ]
  let t_to_str = [ Local, "Local"; CrossAccount, "CrossAccount" ]
  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)
  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)
  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))
  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module AutomationExecutionMetadata = struct
  type t =
    { automation_execution_id : String.t option
    ; document_name : String.t option
    ; document_version : String.t option
    ; automation_execution_status : AutomationExecutionStatus.t option
    ; execution_start_time : DateTime.t option
    ; execution_end_time : DateTime.t option
    ; executed_by : String.t option
    ; log_file : String.t option
    ; outputs : AutomationParameterMap.t option
    ; mode : ExecutionMode.t option
    ; parent_automation_execution_id : String.t option
    ; current_step_name : String.t option
    ; current_action : String.t option
    ; failure_message : String.t option
    ; target_parameter_name : String.t option
    ; targets : Targets.t
    ; target_maps : TargetMaps.t
    ; resolved_targets : ResolvedTargets.t option
    ; max_concurrency : String.t option
    ; max_errors : String.t option
    ; target : String.t option
    ; automation_type : AutomationType.t option
    }

  let make
      ?automation_execution_id
      ?document_name
      ?document_version
      ?automation_execution_status
      ?execution_start_time
      ?execution_end_time
      ?executed_by
      ?log_file
      ?outputs
      ?mode
      ?parent_automation_execution_id
      ?current_step_name
      ?current_action
      ?failure_message
      ?target_parameter_name
      ?(targets = [])
      ?(target_maps = [])
      ?resolved_targets
      ?max_concurrency
      ?max_errors
      ?target
      ?automation_type
      () =
    { automation_execution_id
    ; document_name
    ; document_version
    ; automation_execution_status
    ; execution_start_time
    ; execution_end_time
    ; executed_by
    ; log_file
    ; outputs
    ; mode
    ; parent_automation_execution_id
    ; current_step_name
    ; current_action
    ; failure_message
    ; target_parameter_name
    ; targets
    ; target_maps
    ; resolved_targets
    ; max_concurrency
    ; max_errors
    ; target
    ; automation_type
    }

  let parse xml =
    Some
      { automation_execution_id =
          Aws.Util.option_bind (Aws.Xml.member "AutomationExecutionId" xml) String.parse
      ; document_name =
          Aws.Util.option_bind (Aws.Xml.member "DocumentName" xml) String.parse
      ; document_version =
          Aws.Util.option_bind (Aws.Xml.member "DocumentVersion" xml) String.parse
      ; automation_execution_status =
          Aws.Util.option_bind
            (Aws.Xml.member "AutomationExecutionStatus" xml)
            AutomationExecutionStatus.parse
      ; execution_start_time =
          Aws.Util.option_bind (Aws.Xml.member "ExecutionStartTime" xml) DateTime.parse
      ; execution_end_time =
          Aws.Util.option_bind (Aws.Xml.member "ExecutionEndTime" xml) DateTime.parse
      ; executed_by = Aws.Util.option_bind (Aws.Xml.member "ExecutedBy" xml) String.parse
      ; log_file = Aws.Util.option_bind (Aws.Xml.member "LogFile" xml) String.parse
      ; outputs =
          Aws.Util.option_bind (Aws.Xml.member "Outputs" xml) AutomationParameterMap.parse
      ; mode = Aws.Util.option_bind (Aws.Xml.member "Mode" xml) ExecutionMode.parse
      ; parent_automation_execution_id =
          Aws.Util.option_bind
            (Aws.Xml.member "ParentAutomationExecutionId" xml)
            String.parse
      ; current_step_name =
          Aws.Util.option_bind (Aws.Xml.member "CurrentStepName" xml) String.parse
      ; current_action =
          Aws.Util.option_bind (Aws.Xml.member "CurrentAction" xml) String.parse
      ; failure_message =
          Aws.Util.option_bind (Aws.Xml.member "FailureMessage" xml) String.parse
      ; target_parameter_name =
          Aws.Util.option_bind (Aws.Xml.member "TargetParameterName" xml) String.parse
      ; targets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Targets" xml) Targets.parse)
      ; target_maps =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "TargetMaps" xml) TargetMaps.parse)
      ; resolved_targets =
          Aws.Util.option_bind
            (Aws.Xml.member "ResolvedTargets" xml)
            ResolvedTargets.parse
      ; max_concurrency =
          Aws.Util.option_bind (Aws.Xml.member "MaxConcurrency" xml) String.parse
      ; max_errors = Aws.Util.option_bind (Aws.Xml.member "MaxErrors" xml) String.parse
      ; target = Aws.Util.option_bind (Aws.Xml.member "Target" xml) String.parse
      ; automation_type =
          Aws.Util.option_bind (Aws.Xml.member "AutomationType" xml) AutomationType.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.automation_type (fun f ->
               Aws.Query.Pair ("AutomationType", AutomationType.to_query f))
         ; Aws.Util.option_map v.target (fun f ->
               Aws.Query.Pair ("Target", String.to_query f))
         ; Aws.Util.option_map v.max_errors (fun f ->
               Aws.Query.Pair ("MaxErrors", String.to_query f))
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               Aws.Query.Pair ("MaxConcurrency", String.to_query f))
         ; Aws.Util.option_map v.resolved_targets (fun f ->
               Aws.Query.Pair ("ResolvedTargets", ResolvedTargets.to_query f))
         ; Some (Aws.Query.Pair ("TargetMaps.member", TargetMaps.to_query v.target_maps))
         ; Some (Aws.Query.Pair ("Targets.member", Targets.to_query v.targets))
         ; Aws.Util.option_map v.target_parameter_name (fun f ->
               Aws.Query.Pair ("TargetParameterName", String.to_query f))
         ; Aws.Util.option_map v.failure_message (fun f ->
               Aws.Query.Pair ("FailureMessage", String.to_query f))
         ; Aws.Util.option_map v.current_action (fun f ->
               Aws.Query.Pair ("CurrentAction", String.to_query f))
         ; Aws.Util.option_map v.current_step_name (fun f ->
               Aws.Query.Pair ("CurrentStepName", String.to_query f))
         ; Aws.Util.option_map v.parent_automation_execution_id (fun f ->
               Aws.Query.Pair ("ParentAutomationExecutionId", String.to_query f))
         ; Aws.Util.option_map v.mode (fun f ->
               Aws.Query.Pair ("Mode", ExecutionMode.to_query f))
         ; Aws.Util.option_map v.outputs (fun f ->
               Aws.Query.Pair ("Outputs", AutomationParameterMap.to_query f))
         ; Aws.Util.option_map v.log_file (fun f ->
               Aws.Query.Pair ("LogFile", String.to_query f))
         ; Aws.Util.option_map v.executed_by (fun f ->
               Aws.Query.Pair ("ExecutedBy", String.to_query f))
         ; Aws.Util.option_map v.execution_end_time (fun f ->
               Aws.Query.Pair ("ExecutionEndTime", DateTime.to_query f))
         ; Aws.Util.option_map v.execution_start_time (fun f ->
               Aws.Query.Pair ("ExecutionStartTime", DateTime.to_query f))
         ; Aws.Util.option_map v.automation_execution_status (fun f ->
               Aws.Query.Pair
                 ("AutomationExecutionStatus", AutomationExecutionStatus.to_query f))
         ; Aws.Util.option_map v.document_version (fun f ->
               Aws.Query.Pair ("DocumentVersion", String.to_query f))
         ; Aws.Util.option_map v.document_name (fun f ->
               Aws.Query.Pair ("DocumentName", String.to_query f))
         ; Aws.Util.option_map v.automation_execution_id (fun f ->
               Aws.Query.Pair ("AutomationExecutionId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.automation_type (fun f ->
               "AutomationType", AutomationType.to_json f)
         ; Aws.Util.option_map v.target (fun f -> "Target", String.to_json f)
         ; Aws.Util.option_map v.max_errors (fun f -> "MaxErrors", String.to_json f)
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               "MaxConcurrency", String.to_json f)
         ; Aws.Util.option_map v.resolved_targets (fun f ->
               "ResolvedTargets", ResolvedTargets.to_json f)
         ; Some ("TargetMaps", TargetMaps.to_json v.target_maps)
         ; Some ("Targets", Targets.to_json v.targets)
         ; Aws.Util.option_map v.target_parameter_name (fun f ->
               "TargetParameterName", String.to_json f)
         ; Aws.Util.option_map v.failure_message (fun f ->
               "FailureMessage", String.to_json f)
         ; Aws.Util.option_map v.current_action (fun f ->
               "CurrentAction", String.to_json f)
         ; Aws.Util.option_map v.current_step_name (fun f ->
               "CurrentStepName", String.to_json f)
         ; Aws.Util.option_map v.parent_automation_execution_id (fun f ->
               "ParentAutomationExecutionId", String.to_json f)
         ; Aws.Util.option_map v.mode (fun f -> "Mode", ExecutionMode.to_json f)
         ; Aws.Util.option_map v.outputs (fun f ->
               "Outputs", AutomationParameterMap.to_json f)
         ; Aws.Util.option_map v.log_file (fun f -> "LogFile", String.to_json f)
         ; Aws.Util.option_map v.executed_by (fun f -> "ExecutedBy", String.to_json f)
         ; Aws.Util.option_map v.execution_end_time (fun f ->
               "ExecutionEndTime", DateTime.to_json f)
         ; Aws.Util.option_map v.execution_start_time (fun f ->
               "ExecutionStartTime", DateTime.to_json f)
         ; Aws.Util.option_map v.automation_execution_status (fun f ->
               "AutomationExecutionStatus", AutomationExecutionStatus.to_json f)
         ; Aws.Util.option_map v.document_version (fun f ->
               "DocumentVersion", String.to_json f)
         ; Aws.Util.option_map v.document_name (fun f -> "DocumentName", String.to_json f)
         ; Aws.Util.option_map v.automation_execution_id (fun f ->
               "AutomationExecutionId", String.to_json f)
         ])

  let of_json j =
    { automation_execution_id =
        Aws.Util.option_map (Aws.Json.lookup j "AutomationExecutionId") String.of_json
    ; document_name =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentName") String.of_json
    ; document_version =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentVersion") String.of_json
    ; automation_execution_status =
        Aws.Util.option_map
          (Aws.Json.lookup j "AutomationExecutionStatus")
          AutomationExecutionStatus.of_json
    ; execution_start_time =
        Aws.Util.option_map (Aws.Json.lookup j "ExecutionStartTime") DateTime.of_json
    ; execution_end_time =
        Aws.Util.option_map (Aws.Json.lookup j "ExecutionEndTime") DateTime.of_json
    ; executed_by = Aws.Util.option_map (Aws.Json.lookup j "ExecutedBy") String.of_json
    ; log_file = Aws.Util.option_map (Aws.Json.lookup j "LogFile") String.of_json
    ; outputs =
        Aws.Util.option_map (Aws.Json.lookup j "Outputs") AutomationParameterMap.of_json
    ; mode = Aws.Util.option_map (Aws.Json.lookup j "Mode") ExecutionMode.of_json
    ; parent_automation_execution_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "ParentAutomationExecutionId")
          String.of_json
    ; current_step_name =
        Aws.Util.option_map (Aws.Json.lookup j "CurrentStepName") String.of_json
    ; current_action =
        Aws.Util.option_map (Aws.Json.lookup j "CurrentAction") String.of_json
    ; failure_message =
        Aws.Util.option_map (Aws.Json.lookup j "FailureMessage") String.of_json
    ; target_parameter_name =
        Aws.Util.option_map (Aws.Json.lookup j "TargetParameterName") String.of_json
    ; targets = Targets.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Targets"))
    ; target_maps =
        TargetMaps.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TargetMaps"))
    ; resolved_targets =
        Aws.Util.option_map (Aws.Json.lookup j "ResolvedTargets") ResolvedTargets.of_json
    ; max_concurrency =
        Aws.Util.option_map (Aws.Json.lookup j "MaxConcurrency") String.of_json
    ; max_errors = Aws.Util.option_map (Aws.Json.lookup j "MaxErrors") String.of_json
    ; target = Aws.Util.option_map (Aws.Json.lookup j "Target") String.of_json
    ; automation_type =
        Aws.Util.option_map (Aws.Json.lookup j "AutomationType") AutomationType.of_json
    }
end

module AutomationExecutionMetadataList = struct
  type t = AutomationExecutionMetadata.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map AutomationExecutionMetadata.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list AutomationExecutionMetadata.to_query v
  let to_json v = `List (List.map AutomationExecutionMetadata.to_json v)
  let of_json j = Aws.Json.to_list AutomationExecutionMetadata.of_json j
end

module UpdateResourceDataSyncRequest = struct
  type t =
    { sync_name : String.t
    ; sync_type : String.t
    ; sync_source : ResourceDataSyncSource.t
    }

  let make ~sync_name ~sync_type ~sync_source () = { sync_name; sync_type; sync_source }

  let parse xml =
    Some
      { sync_name =
          Aws.Xml.required
            "SyncName"
            (Aws.Util.option_bind (Aws.Xml.member "SyncName" xml) String.parse)
      ; sync_type =
          Aws.Xml.required
            "SyncType"
            (Aws.Util.option_bind (Aws.Xml.member "SyncType" xml) String.parse)
      ; sync_source =
          Aws.Xml.required
            "SyncSource"
            (Aws.Util.option_bind
               (Aws.Xml.member "SyncSource" xml)
               ResourceDataSyncSource.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("SyncSource", ResourceDataSyncSource.to_query v.sync_source))
         ; Some (Aws.Query.Pair ("SyncType", String.to_query v.sync_type))
         ; Some (Aws.Query.Pair ("SyncName", String.to_query v.sync_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("SyncSource", ResourceDataSyncSource.to_json v.sync_source)
         ; Some ("SyncType", String.to_json v.sync_type)
         ; Some ("SyncName", String.to_json v.sync_name)
         ])

  let of_json j =
    { sync_name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SyncName"))
    ; sync_type = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SyncType"))
    ; sync_source =
        ResourceDataSyncSource.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SyncSource"))
    }
end

module PoliciesLimitExceededException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json }
end

module InvalidTypeNameException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module OpsEntity = struct
  type t =
    { id : String.t option
    ; data : OpsEntityItemMap.t option
    }

  let make ?id ?data () = { id; data }

  let parse xml =
    Some
      { id = Aws.Util.option_bind (Aws.Xml.member "Id" xml) String.parse
      ; data = Aws.Util.option_bind (Aws.Xml.member "Data" xml) OpsEntityItemMap.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.data (fun f ->
               Aws.Query.Pair ("Data", OpsEntityItemMap.to_query f))
         ; Aws.Util.option_map v.id (fun f -> Aws.Query.Pair ("Id", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.data (fun f -> "Data", OpsEntityItemMap.to_json f)
         ; Aws.Util.option_map v.id (fun f -> "Id", String.to_json f)
         ])

  let of_json j =
    { id = Aws.Util.option_map (Aws.Json.lookup j "Id") String.of_json
    ; data = Aws.Util.option_map (Aws.Json.lookup j "Data") OpsEntityItemMap.of_json
    }
end

module OpsEntityList = struct
  type t = OpsEntity.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map OpsEntity.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list OpsEntity.to_query v
  let to_json v = `List (List.map OpsEntity.to_json v)
  let of_json j = Aws.Json.to_list OpsEntity.of_json j
end

module DocumentVersionLimitExceeded = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module DescribeInstancePatchesRequest = struct
  type t =
    { instance_id : String.t
    ; filters : PatchOrchestratorFilterList.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    }

  let make ~instance_id ?(filters = []) ?next_token ?max_results () =
    { instance_id; filters; next_token; max_results }

  let parse xml =
    Some
      { instance_id =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               PatchOrchestratorFilterList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Filters.member", PatchOrchestratorFilterList.to_query v.filters))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Filters", PatchOrchestratorFilterList.to_json v.filters)
         ; Some ("InstanceId", String.to_json v.instance_id)
         ])

  let of_json j =
    { instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; filters =
        PatchOrchestratorFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module DescribeInstanceAssociationsStatusRequest = struct
  type t =
    { instance_id : String.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ~instance_id ?max_results ?next_token () =
    { instance_id; max_results; next_token }

  let parse xml =
    Some
      { instance_id =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("InstanceId", String.to_json v.instance_id)
         ])

  let of_json j =
    { instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module AssociatedInstances = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module PutInventoryResult = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module ListAssociationsResult = struct
  type t =
    { associations : AssociationList.t
    ; next_token : String.t option
    }

  let make ?(associations = []) ?next_token () = { associations; next_token }

  let parse xml =
    Some
      { associations =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Associations" xml)
               AssociationList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Associations.member", AssociationList.to_query v.associations))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Associations", AssociationList.to_json v.associations)
         ])

  let of_json j =
    { associations =
        AssociationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Associations"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module RegisterPatchBaselineForPatchGroupResult = struct
  type t =
    { baseline_id : String.t option
    ; patch_group : String.t option
    }

  let make ?baseline_id ?patch_group () = { baseline_id; patch_group }

  let parse xml =
    Some
      { baseline_id = Aws.Util.option_bind (Aws.Xml.member "BaselineId" xml) String.parse
      ; patch_group = Aws.Util.option_bind (Aws.Xml.member "PatchGroup" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.patch_group (fun f ->
               Aws.Query.Pair ("PatchGroup", String.to_query f))
         ; Aws.Util.option_map v.baseline_id (fun f ->
               Aws.Query.Pair ("BaselineId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.patch_group (fun f -> "PatchGroup", String.to_json f)
         ; Aws.Util.option_map v.baseline_id (fun f -> "BaselineId", String.to_json f)
         ])

  let of_json j =
    { baseline_id = Aws.Util.option_map (Aws.Json.lookup j "BaselineId") String.of_json
    ; patch_group = Aws.Util.option_map (Aws.Json.lookup j "PatchGroup") String.of_json
    }
end

module ItemSizeLimitExceededException = struct
  type t =
    { type_name : String.t option
    ; message : String.t option
    }

  let make ?type_name ?message () = { type_name; message }

  let parse xml =
    Some
      { type_name = Aws.Util.option_bind (Aws.Xml.member "TypeName" xml) String.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.type_name (fun f ->
               Aws.Query.Pair ("TypeName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f)
         ; Aws.Util.option_map v.type_name (fun f -> "TypeName", String.to_json f)
         ])

  let of_json j =
    { type_name = Aws.Util.option_map (Aws.Json.lookup j "TypeName") String.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json
    }
end

module AutomationExecution = struct
  type t =
    { automation_execution_id : String.t option
    ; document_name : String.t option
    ; document_version : String.t option
    ; execution_start_time : DateTime.t option
    ; execution_end_time : DateTime.t option
    ; automation_execution_status : AutomationExecutionStatus.t option
    ; step_executions : StepExecutionList.t
    ; step_executions_truncated : Boolean.t option
    ; parameters : AutomationParameterMap.t option
    ; outputs : AutomationParameterMap.t option
    ; failure_message : String.t option
    ; mode : ExecutionMode.t option
    ; parent_automation_execution_id : String.t option
    ; executed_by : String.t option
    ; current_step_name : String.t option
    ; current_action : String.t option
    ; target_parameter_name : String.t option
    ; targets : Targets.t
    ; target_maps : TargetMaps.t
    ; resolved_targets : ResolvedTargets.t option
    ; max_concurrency : String.t option
    ; max_errors : String.t option
    ; target : String.t option
    ; target_locations : TargetLocations.t
    ; progress_counters : ProgressCounters.t option
    }

  let make
      ?automation_execution_id
      ?document_name
      ?document_version
      ?execution_start_time
      ?execution_end_time
      ?automation_execution_status
      ?(step_executions = [])
      ?step_executions_truncated
      ?parameters
      ?outputs
      ?failure_message
      ?mode
      ?parent_automation_execution_id
      ?executed_by
      ?current_step_name
      ?current_action
      ?target_parameter_name
      ?(targets = [])
      ?(target_maps = [])
      ?resolved_targets
      ?max_concurrency
      ?max_errors
      ?target
      ?(target_locations = [])
      ?progress_counters
      () =
    { automation_execution_id
    ; document_name
    ; document_version
    ; execution_start_time
    ; execution_end_time
    ; automation_execution_status
    ; step_executions
    ; step_executions_truncated
    ; parameters
    ; outputs
    ; failure_message
    ; mode
    ; parent_automation_execution_id
    ; executed_by
    ; current_step_name
    ; current_action
    ; target_parameter_name
    ; targets
    ; target_maps
    ; resolved_targets
    ; max_concurrency
    ; max_errors
    ; target
    ; target_locations
    ; progress_counters
    }

  let parse xml =
    Some
      { automation_execution_id =
          Aws.Util.option_bind (Aws.Xml.member "AutomationExecutionId" xml) String.parse
      ; document_name =
          Aws.Util.option_bind (Aws.Xml.member "DocumentName" xml) String.parse
      ; document_version =
          Aws.Util.option_bind (Aws.Xml.member "DocumentVersion" xml) String.parse
      ; execution_start_time =
          Aws.Util.option_bind (Aws.Xml.member "ExecutionStartTime" xml) DateTime.parse
      ; execution_end_time =
          Aws.Util.option_bind (Aws.Xml.member "ExecutionEndTime" xml) DateTime.parse
      ; automation_execution_status =
          Aws.Util.option_bind
            (Aws.Xml.member "AutomationExecutionStatus" xml)
            AutomationExecutionStatus.parse
      ; step_executions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "StepExecutions" xml)
               StepExecutionList.parse)
      ; step_executions_truncated =
          Aws.Util.option_bind
            (Aws.Xml.member "StepExecutionsTruncated" xml)
            Boolean.parse
      ; parameters =
          Aws.Util.option_bind
            (Aws.Xml.member "Parameters" xml)
            AutomationParameterMap.parse
      ; outputs =
          Aws.Util.option_bind (Aws.Xml.member "Outputs" xml) AutomationParameterMap.parse
      ; failure_message =
          Aws.Util.option_bind (Aws.Xml.member "FailureMessage" xml) String.parse
      ; mode = Aws.Util.option_bind (Aws.Xml.member "Mode" xml) ExecutionMode.parse
      ; parent_automation_execution_id =
          Aws.Util.option_bind
            (Aws.Xml.member "ParentAutomationExecutionId" xml)
            String.parse
      ; executed_by = Aws.Util.option_bind (Aws.Xml.member "ExecutedBy" xml) String.parse
      ; current_step_name =
          Aws.Util.option_bind (Aws.Xml.member "CurrentStepName" xml) String.parse
      ; current_action =
          Aws.Util.option_bind (Aws.Xml.member "CurrentAction" xml) String.parse
      ; target_parameter_name =
          Aws.Util.option_bind (Aws.Xml.member "TargetParameterName" xml) String.parse
      ; targets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Targets" xml) Targets.parse)
      ; target_maps =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "TargetMaps" xml) TargetMaps.parse)
      ; resolved_targets =
          Aws.Util.option_bind
            (Aws.Xml.member "ResolvedTargets" xml)
            ResolvedTargets.parse
      ; max_concurrency =
          Aws.Util.option_bind (Aws.Xml.member "MaxConcurrency" xml) String.parse
      ; max_errors = Aws.Util.option_bind (Aws.Xml.member "MaxErrors" xml) String.parse
      ; target = Aws.Util.option_bind (Aws.Xml.member "Target" xml) String.parse
      ; target_locations =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TargetLocations" xml)
               TargetLocations.parse)
      ; progress_counters =
          Aws.Util.option_bind
            (Aws.Xml.member "ProgressCounters" xml)
            ProgressCounters.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.progress_counters (fun f ->
               Aws.Query.Pair ("ProgressCounters", ProgressCounters.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TargetLocations.member", TargetLocations.to_query v.target_locations))
         ; Aws.Util.option_map v.target (fun f ->
               Aws.Query.Pair ("Target", String.to_query f))
         ; Aws.Util.option_map v.max_errors (fun f ->
               Aws.Query.Pair ("MaxErrors", String.to_query f))
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               Aws.Query.Pair ("MaxConcurrency", String.to_query f))
         ; Aws.Util.option_map v.resolved_targets (fun f ->
               Aws.Query.Pair ("ResolvedTargets", ResolvedTargets.to_query f))
         ; Some (Aws.Query.Pair ("TargetMaps.member", TargetMaps.to_query v.target_maps))
         ; Some (Aws.Query.Pair ("Targets.member", Targets.to_query v.targets))
         ; Aws.Util.option_map v.target_parameter_name (fun f ->
               Aws.Query.Pair ("TargetParameterName", String.to_query f))
         ; Aws.Util.option_map v.current_action (fun f ->
               Aws.Query.Pair ("CurrentAction", String.to_query f))
         ; Aws.Util.option_map v.current_step_name (fun f ->
               Aws.Query.Pair ("CurrentStepName", String.to_query f))
         ; Aws.Util.option_map v.executed_by (fun f ->
               Aws.Query.Pair ("ExecutedBy", String.to_query f))
         ; Aws.Util.option_map v.parent_automation_execution_id (fun f ->
               Aws.Query.Pair ("ParentAutomationExecutionId", String.to_query f))
         ; Aws.Util.option_map v.mode (fun f ->
               Aws.Query.Pair ("Mode", ExecutionMode.to_query f))
         ; Aws.Util.option_map v.failure_message (fun f ->
               Aws.Query.Pair ("FailureMessage", String.to_query f))
         ; Aws.Util.option_map v.outputs (fun f ->
               Aws.Query.Pair ("Outputs", AutomationParameterMap.to_query f))
         ; Aws.Util.option_map v.parameters (fun f ->
               Aws.Query.Pair ("Parameters", AutomationParameterMap.to_query f))
         ; Aws.Util.option_map v.step_executions_truncated (fun f ->
               Aws.Query.Pair ("StepExecutionsTruncated", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("StepExecutions.member", StepExecutionList.to_query v.step_executions))
         ; Aws.Util.option_map v.automation_execution_status (fun f ->
               Aws.Query.Pair
                 ("AutomationExecutionStatus", AutomationExecutionStatus.to_query f))
         ; Aws.Util.option_map v.execution_end_time (fun f ->
               Aws.Query.Pair ("ExecutionEndTime", DateTime.to_query f))
         ; Aws.Util.option_map v.execution_start_time (fun f ->
               Aws.Query.Pair ("ExecutionStartTime", DateTime.to_query f))
         ; Aws.Util.option_map v.document_version (fun f ->
               Aws.Query.Pair ("DocumentVersion", String.to_query f))
         ; Aws.Util.option_map v.document_name (fun f ->
               Aws.Query.Pair ("DocumentName", String.to_query f))
         ; Aws.Util.option_map v.automation_execution_id (fun f ->
               Aws.Query.Pair ("AutomationExecutionId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.progress_counters (fun f ->
               "ProgressCounters", ProgressCounters.to_json f)
         ; Some ("TargetLocations", TargetLocations.to_json v.target_locations)
         ; Aws.Util.option_map v.target (fun f -> "Target", String.to_json f)
         ; Aws.Util.option_map v.max_errors (fun f -> "MaxErrors", String.to_json f)
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               "MaxConcurrency", String.to_json f)
         ; Aws.Util.option_map v.resolved_targets (fun f ->
               "ResolvedTargets", ResolvedTargets.to_json f)
         ; Some ("TargetMaps", TargetMaps.to_json v.target_maps)
         ; Some ("Targets", Targets.to_json v.targets)
         ; Aws.Util.option_map v.target_parameter_name (fun f ->
               "TargetParameterName", String.to_json f)
         ; Aws.Util.option_map v.current_action (fun f ->
               "CurrentAction", String.to_json f)
         ; Aws.Util.option_map v.current_step_name (fun f ->
               "CurrentStepName", String.to_json f)
         ; Aws.Util.option_map v.executed_by (fun f -> "ExecutedBy", String.to_json f)
         ; Aws.Util.option_map v.parent_automation_execution_id (fun f ->
               "ParentAutomationExecutionId", String.to_json f)
         ; Aws.Util.option_map v.mode (fun f -> "Mode", ExecutionMode.to_json f)
         ; Aws.Util.option_map v.failure_message (fun f ->
               "FailureMessage", String.to_json f)
         ; Aws.Util.option_map v.outputs (fun f ->
               "Outputs", AutomationParameterMap.to_json f)
         ; Aws.Util.option_map v.parameters (fun f ->
               "Parameters", AutomationParameterMap.to_json f)
         ; Aws.Util.option_map v.step_executions_truncated (fun f ->
               "StepExecutionsTruncated", Boolean.to_json f)
         ; Some ("StepExecutions", StepExecutionList.to_json v.step_executions)
         ; Aws.Util.option_map v.automation_execution_status (fun f ->
               "AutomationExecutionStatus", AutomationExecutionStatus.to_json f)
         ; Aws.Util.option_map v.execution_end_time (fun f ->
               "ExecutionEndTime", DateTime.to_json f)
         ; Aws.Util.option_map v.execution_start_time (fun f ->
               "ExecutionStartTime", DateTime.to_json f)
         ; Aws.Util.option_map v.document_version (fun f ->
               "DocumentVersion", String.to_json f)
         ; Aws.Util.option_map v.document_name (fun f -> "DocumentName", String.to_json f)
         ; Aws.Util.option_map v.automation_execution_id (fun f ->
               "AutomationExecutionId", String.to_json f)
         ])

  let of_json j =
    { automation_execution_id =
        Aws.Util.option_map (Aws.Json.lookup j "AutomationExecutionId") String.of_json
    ; document_name =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentName") String.of_json
    ; document_version =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentVersion") String.of_json
    ; execution_start_time =
        Aws.Util.option_map (Aws.Json.lookup j "ExecutionStartTime") DateTime.of_json
    ; execution_end_time =
        Aws.Util.option_map (Aws.Json.lookup j "ExecutionEndTime") DateTime.of_json
    ; automation_execution_status =
        Aws.Util.option_map
          (Aws.Json.lookup j "AutomationExecutionStatus")
          AutomationExecutionStatus.of_json
    ; step_executions =
        StepExecutionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "StepExecutions"))
    ; step_executions_truncated =
        Aws.Util.option_map (Aws.Json.lookup j "StepExecutionsTruncated") Boolean.of_json
    ; parameters =
        Aws.Util.option_map
          (Aws.Json.lookup j "Parameters")
          AutomationParameterMap.of_json
    ; outputs =
        Aws.Util.option_map (Aws.Json.lookup j "Outputs") AutomationParameterMap.of_json
    ; failure_message =
        Aws.Util.option_map (Aws.Json.lookup j "FailureMessage") String.of_json
    ; mode = Aws.Util.option_map (Aws.Json.lookup j "Mode") ExecutionMode.of_json
    ; parent_automation_execution_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "ParentAutomationExecutionId")
          String.of_json
    ; executed_by = Aws.Util.option_map (Aws.Json.lookup j "ExecutedBy") String.of_json
    ; current_step_name =
        Aws.Util.option_map (Aws.Json.lookup j "CurrentStepName") String.of_json
    ; current_action =
        Aws.Util.option_map (Aws.Json.lookup j "CurrentAction") String.of_json
    ; target_parameter_name =
        Aws.Util.option_map (Aws.Json.lookup j "TargetParameterName") String.of_json
    ; targets = Targets.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Targets"))
    ; target_maps =
        TargetMaps.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TargetMaps"))
    ; resolved_targets =
        Aws.Util.option_map (Aws.Json.lookup j "ResolvedTargets") ResolvedTargets.of_json
    ; max_concurrency =
        Aws.Util.option_map (Aws.Json.lookup j "MaxConcurrency") String.of_json
    ; max_errors = Aws.Util.option_map (Aws.Json.lookup j "MaxErrors") String.of_json
    ; target = Aws.Util.option_map (Aws.Json.lookup j "Target") String.of_json
    ; target_locations =
        TargetLocations.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TargetLocations"))
    ; progress_counters =
        Aws.Util.option_map
          (Aws.Json.lookup j "ProgressCounters")
          ProgressCounters.of_json
    }
end

module UpdateAssociationResult = struct
  type t = { association_description : AssociationDescription.t option }

  let make ?association_description () = { association_description }

  let parse xml =
    Some
      { association_description =
          Aws.Util.option_bind
            (Aws.Xml.member "AssociationDescription" xml)
            AssociationDescription.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_description (fun f ->
               Aws.Query.Pair ("AssociationDescription", AssociationDescription.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_description (fun f ->
               "AssociationDescription", AssociationDescription.to_json f)
         ])

  let of_json j =
    { association_description =
        Aws.Util.option_map
          (Aws.Json.lookup j "AssociationDescription")
          AssociationDescription.of_json
    }
end

module InvalidResourceId = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module OpsItemAlreadyExistsException = struct
  type t =
    { message : String.t option
    ; ops_item_id : String.t option
    }

  let make ?message ?ops_item_id () = { message; ops_item_id }

  let parse xml =
    Some
      { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse
      ; ops_item_id = Aws.Util.option_bind (Aws.Xml.member "OpsItemId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ops_item_id (fun f ->
               Aws.Query.Pair ("OpsItemId", String.to_query f))
         ; Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ops_item_id (fun f -> "OpsItemId", String.to_json f)
         ; Aws.Util.option_map v.message (fun f -> "Message", String.to_json f)
         ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json
    ; ops_item_id = Aws.Util.option_map (Aws.Json.lookup j "OpsItemId") String.of_json
    }
end

module UpdatePatchBaselineRequest = struct
  type t =
    { baseline_id : String.t
    ; name : String.t option
    ; global_filters : PatchFilterGroup.t option
    ; approval_rules : PatchRuleGroup.t option
    ; approved_patches : PatchIdList.t
    ; approved_patches_compliance_level : PatchComplianceLevel.t option
    ; approved_patches_enable_non_security : Boolean.t option
    ; rejected_patches : PatchIdList.t
    ; rejected_patches_action : PatchAction.t option
    ; description : String.t option
    ; sources : PatchSourceList.t
    ; replace : Boolean.t option
    }

  let make
      ~baseline_id
      ?name
      ?global_filters
      ?approval_rules
      ?(approved_patches = [])
      ?approved_patches_compliance_level
      ?approved_patches_enable_non_security
      ?(rejected_patches = [])
      ?rejected_patches_action
      ?description
      ?(sources = [])
      ?replace
      () =
    { baseline_id
    ; name
    ; global_filters
    ; approval_rules
    ; approved_patches
    ; approved_patches_compliance_level
    ; approved_patches_enable_non_security
    ; rejected_patches
    ; rejected_patches_action
    ; description
    ; sources
    ; replace
    }

  let parse xml =
    Some
      { baseline_id =
          Aws.Xml.required
            "BaselineId"
            (Aws.Util.option_bind (Aws.Xml.member "BaselineId" xml) String.parse)
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; global_filters =
          Aws.Util.option_bind (Aws.Xml.member "GlobalFilters" xml) PatchFilterGroup.parse
      ; approval_rules =
          Aws.Util.option_bind (Aws.Xml.member "ApprovalRules" xml) PatchRuleGroup.parse
      ; approved_patches =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ApprovedPatches" xml)
               PatchIdList.parse)
      ; approved_patches_compliance_level =
          Aws.Util.option_bind
            (Aws.Xml.member "ApprovedPatchesComplianceLevel" xml)
            PatchComplianceLevel.parse
      ; approved_patches_enable_non_security =
          Aws.Util.option_bind
            (Aws.Xml.member "ApprovedPatchesEnableNonSecurity" xml)
            Boolean.parse
      ; rejected_patches =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "RejectedPatches" xml)
               PatchIdList.parse)
      ; rejected_patches_action =
          Aws.Util.option_bind
            (Aws.Xml.member "RejectedPatchesAction" xml)
            PatchAction.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; sources =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Sources" xml) PatchSourceList.parse)
      ; replace = Aws.Util.option_bind (Aws.Xml.member "Replace" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.replace (fun f ->
               Aws.Query.Pair ("Replace", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Sources.member", PatchSourceList.to_query v.sources))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.rejected_patches_action (fun f ->
               Aws.Query.Pair ("RejectedPatchesAction", PatchAction.to_query f))
         ; Some
             (Aws.Query.Pair
                ("RejectedPatches.member", PatchIdList.to_query v.rejected_patches))
         ; Aws.Util.option_map v.approved_patches_enable_non_security (fun f ->
               Aws.Query.Pair ("ApprovedPatchesEnableNonSecurity", Boolean.to_query f))
         ; Aws.Util.option_map v.approved_patches_compliance_level (fun f ->
               Aws.Query.Pair
                 ("ApprovedPatchesComplianceLevel", PatchComplianceLevel.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ApprovedPatches.member", PatchIdList.to_query v.approved_patches))
         ; Aws.Util.option_map v.approval_rules (fun f ->
               Aws.Query.Pair ("ApprovalRules", PatchRuleGroup.to_query f))
         ; Aws.Util.option_map v.global_filters (fun f ->
               Aws.Query.Pair ("GlobalFilters", PatchFilterGroup.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Some (Aws.Query.Pair ("BaselineId", String.to_query v.baseline_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.replace (fun f -> "Replace", Boolean.to_json f)
         ; Some ("Sources", PatchSourceList.to_json v.sources)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.rejected_patches_action (fun f ->
               "RejectedPatchesAction", PatchAction.to_json f)
         ; Some ("RejectedPatches", PatchIdList.to_json v.rejected_patches)
         ; Aws.Util.option_map v.approved_patches_enable_non_security (fun f ->
               "ApprovedPatchesEnableNonSecurity", Boolean.to_json f)
         ; Aws.Util.option_map v.approved_patches_compliance_level (fun f ->
               "ApprovedPatchesComplianceLevel", PatchComplianceLevel.to_json f)
         ; Some ("ApprovedPatches", PatchIdList.to_json v.approved_patches)
         ; Aws.Util.option_map v.approval_rules (fun f ->
               "ApprovalRules", PatchRuleGroup.to_json f)
         ; Aws.Util.option_map v.global_filters (fun f ->
               "GlobalFilters", PatchFilterGroup.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Some ("BaselineId", String.to_json v.baseline_id)
         ])

  let of_json j =
    { baseline_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "BaselineId"))
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; global_filters =
        Aws.Util.option_map (Aws.Json.lookup j "GlobalFilters") PatchFilterGroup.of_json
    ; approval_rules =
        Aws.Util.option_map (Aws.Json.lookup j "ApprovalRules") PatchRuleGroup.of_json
    ; approved_patches =
        PatchIdList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ApprovedPatches"))
    ; approved_patches_compliance_level =
        Aws.Util.option_map
          (Aws.Json.lookup j "ApprovedPatchesComplianceLevel")
          PatchComplianceLevel.of_json
    ; approved_patches_enable_non_security =
        Aws.Util.option_map
          (Aws.Json.lookup j "ApprovedPatchesEnableNonSecurity")
          Boolean.of_json
    ; rejected_patches =
        PatchIdList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "RejectedPatches"))
    ; rejected_patches_action =
        Aws.Util.option_map
          (Aws.Json.lookup j "RejectedPatchesAction")
          PatchAction.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; sources =
        PatchSourceList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Sources"))
    ; replace = Aws.Util.option_map (Aws.Json.lookup j "Replace") Boolean.of_json
    }
end

module InvalidTarget = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module DescribePatchBaselinesRequest = struct
  type t =
    { filters : PatchOrchestratorFilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?(filters = []) ?max_results ?next_token () =
    { filters; max_results; next_token }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               PatchOrchestratorFilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Filters.member", PatchOrchestratorFilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filters", PatchOrchestratorFilterList.to_json v.filters)
         ])

  let of_json j =
    { filters =
        PatchOrchestratorFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module CancelMaintenanceWindowExecutionResult = struct
  type t = { window_execution_id : String.t option }

  let make ?window_execution_id () = { window_execution_id }

  let parse xml =
    Some
      { window_execution_id =
          Aws.Util.option_bind (Aws.Xml.member "WindowExecutionId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.window_execution_id (fun f ->
               Aws.Query.Pair ("WindowExecutionId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.window_execution_id (fun f ->
               "WindowExecutionId", String.to_json f)
         ])

  let of_json j =
    { window_execution_id =
        Aws.Util.option_map (Aws.Json.lookup j "WindowExecutionId") String.of_json
    }
end

module TerminateSessionResponse = struct
  type t = { session_id : String.t option }

  let make ?session_id () = { session_id }

  let parse xml =
    Some
      { session_id = Aws.Util.option_bind (Aws.Xml.member "SessionId" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.session_id (fun f ->
               Aws.Query.Pair ("SessionId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.session_id (fun f -> "SessionId", String.to_json f) ])

  let of_json j =
    { session_id = Aws.Util.option_map (Aws.Json.lookup j "SessionId") String.of_json }
end

module RegisterPatchBaselineForPatchGroupRequest = struct
  type t =
    { baseline_id : String.t
    ; patch_group : String.t
    }

  let make ~baseline_id ~patch_group () = { baseline_id; patch_group }

  let parse xml =
    Some
      { baseline_id =
          Aws.Xml.required
            "BaselineId"
            (Aws.Util.option_bind (Aws.Xml.member "BaselineId" xml) String.parse)
      ; patch_group =
          Aws.Xml.required
            "PatchGroup"
            (Aws.Util.option_bind (Aws.Xml.member "PatchGroup" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("PatchGroup", String.to_query v.patch_group))
         ; Some (Aws.Query.Pair ("BaselineId", String.to_query v.baseline_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("PatchGroup", String.to_json v.patch_group)
         ; Some ("BaselineId", String.to_json v.baseline_id)
         ])

  let of_json j =
    { baseline_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "BaselineId"))
    ; patch_group =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PatchGroup"))
    }
end

module DescribeEffectiveInstanceAssociationsRequest = struct
  type t =
    { instance_id : String.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ~instance_id ?max_results ?next_token () =
    { instance_id; max_results; next_token }

  let parse xml =
    Some
      { instance_id =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("InstanceId", String.to_json v.instance_id)
         ])

  let of_json j =
    { instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module UpdateOpsItemRequest = struct
  type t =
    { description : String.t option
    ; operational_data : OpsItemOperationalData.t option
    ; operational_data_to_delete : OpsItemOpsDataKeysList.t
    ; notifications : OpsItemNotifications.t
    ; priority : Integer.t option
    ; related_ops_items : RelatedOpsItems.t
    ; status : OpsItemStatus.t option
    ; ops_item_id : String.t
    ; title : String.t option
    ; category : String.t option
    ; severity : String.t option
    }

  let make
      ?description
      ?operational_data
      ?(operational_data_to_delete = [])
      ?(notifications = [])
      ?priority
      ?(related_ops_items = [])
      ?status
      ~ops_item_id
      ?title
      ?category
      ?severity
      () =
    { description
    ; operational_data
    ; operational_data_to_delete
    ; notifications
    ; priority
    ; related_ops_items
    ; status
    ; ops_item_id
    ; title
    ; category
    ; severity
    }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; operational_data =
          Aws.Util.option_bind
            (Aws.Xml.member "OperationalData" xml)
            OpsItemOperationalData.parse
      ; operational_data_to_delete =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "OperationalDataToDelete" xml)
               OpsItemOpsDataKeysList.parse)
      ; notifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Notifications" xml)
               OpsItemNotifications.parse)
      ; priority = Aws.Util.option_bind (Aws.Xml.member "Priority" xml) Integer.parse
      ; related_ops_items =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "RelatedOpsItems" xml)
               RelatedOpsItems.parse)
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) OpsItemStatus.parse
      ; ops_item_id =
          Aws.Xml.required
            "OpsItemId"
            (Aws.Util.option_bind (Aws.Xml.member "OpsItemId" xml) String.parse)
      ; title = Aws.Util.option_bind (Aws.Xml.member "Title" xml) String.parse
      ; category = Aws.Util.option_bind (Aws.Xml.member "Category" xml) String.parse
      ; severity = Aws.Util.option_bind (Aws.Xml.member "Severity" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.severity (fun f ->
               Aws.Query.Pair ("Severity", String.to_query f))
         ; Aws.Util.option_map v.category (fun f ->
               Aws.Query.Pair ("Category", String.to_query f))
         ; Aws.Util.option_map v.title (fun f ->
               Aws.Query.Pair ("Title", String.to_query f))
         ; Some (Aws.Query.Pair ("OpsItemId", String.to_query v.ops_item_id))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", OpsItemStatus.to_query f))
         ; Some
             (Aws.Query.Pair
                ("RelatedOpsItems.member", RelatedOpsItems.to_query v.related_ops_items))
         ; Aws.Util.option_map v.priority (fun f ->
               Aws.Query.Pair ("Priority", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Notifications.member", OpsItemNotifications.to_query v.notifications))
         ; Some
             (Aws.Query.Pair
                ( "OperationalDataToDelete.member"
                , OpsItemOpsDataKeysList.to_query v.operational_data_to_delete ))
         ; Aws.Util.option_map v.operational_data (fun f ->
               Aws.Query.Pair ("OperationalData", OpsItemOperationalData.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.severity (fun f -> "Severity", String.to_json f)
         ; Aws.Util.option_map v.category (fun f -> "Category", String.to_json f)
         ; Aws.Util.option_map v.title (fun f -> "Title", String.to_json f)
         ; Some ("OpsItemId", String.to_json v.ops_item_id)
         ; Aws.Util.option_map v.status (fun f -> "Status", OpsItemStatus.to_json f)
         ; Some ("RelatedOpsItems", RelatedOpsItems.to_json v.related_ops_items)
         ; Aws.Util.option_map v.priority (fun f -> "Priority", Integer.to_json f)
         ; Some ("Notifications", OpsItemNotifications.to_json v.notifications)
         ; Some
             ( "OperationalDataToDelete"
             , OpsItemOpsDataKeysList.to_json v.operational_data_to_delete )
         ; Aws.Util.option_map v.operational_data (fun f ->
               "OperationalData", OpsItemOperationalData.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; operational_data =
        Aws.Util.option_map
          (Aws.Json.lookup j "OperationalData")
          OpsItemOperationalData.of_json
    ; operational_data_to_delete =
        OpsItemOpsDataKeysList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "OperationalDataToDelete"))
    ; notifications =
        OpsItemNotifications.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Notifications"))
    ; priority = Aws.Util.option_map (Aws.Json.lookup j "Priority") Integer.of_json
    ; related_ops_items =
        RelatedOpsItems.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "RelatedOpsItems"))
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") OpsItemStatus.of_json
    ; ops_item_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "OpsItemId"))
    ; title = Aws.Util.option_map (Aws.Json.lookup j "Title") String.of_json
    ; category = Aws.Util.option_map (Aws.Json.lookup j "Category") String.of_json
    ; severity = Aws.Util.option_map (Aws.Json.lookup j "Severity") String.of_json
    }
end

module RegisterTaskWithMaintenanceWindowResult = struct
  type t = { window_task_id : String.t option }

  let make ?window_task_id () = { window_task_id }

  let parse xml =
    Some
      { window_task_id =
          Aws.Util.option_bind (Aws.Xml.member "WindowTaskId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.window_task_id (fun f ->
               Aws.Query.Pair ("WindowTaskId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.window_task_id (fun f ->
               "WindowTaskId", String.to_json f)
         ])

  let of_json j =
    { window_task_id =
        Aws.Util.option_map (Aws.Json.lookup j "WindowTaskId") String.of_json
    }
end

module CreateActivationResult = struct
  type t =
    { activation_id : String.t option
    ; activation_code : String.t option
    }

  let make ?activation_id ?activation_code () = { activation_id; activation_code }

  let parse xml =
    Some
      { activation_id =
          Aws.Util.option_bind (Aws.Xml.member "ActivationId" xml) String.parse
      ; activation_code =
          Aws.Util.option_bind (Aws.Xml.member "ActivationCode" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.activation_code (fun f ->
               Aws.Query.Pair ("ActivationCode", String.to_query f))
         ; Aws.Util.option_map v.activation_id (fun f ->
               Aws.Query.Pair ("ActivationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.activation_code (fun f ->
               "ActivationCode", String.to_json f)
         ; Aws.Util.option_map v.activation_id (fun f -> "ActivationId", String.to_json f)
         ])

  let of_json j =
    { activation_id =
        Aws.Util.option_map (Aws.Json.lookup j "ActivationId") String.of_json
    ; activation_code =
        Aws.Util.option_map (Aws.Json.lookup j "ActivationCode") String.of_json
    }
end

module ListResourceDataSyncRequest = struct
  type t =
    { sync_type : String.t option
    ; next_token : String.t option
    ; max_results : Integer.t option
    }

  let make ?sync_type ?next_token ?max_results () = { sync_type; next_token; max_results }

  let parse xml =
    Some
      { sync_type = Aws.Util.option_bind (Aws.Xml.member "SyncType" xml) String.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.sync_type (fun f ->
               Aws.Query.Pair ("SyncType", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.sync_type (fun f -> "SyncType", String.to_json f)
         ])

  let of_json j =
    { sync_type = Aws.Util.option_map (Aws.Json.lookup j "SyncType") String.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module HierarchyLevelLimitExceededException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json }
end

module GetOpsSummaryResult = struct
  type t =
    { entities : OpsEntityList.t
    ; next_token : String.t option
    }

  let make ?(entities = []) ?next_token () = { entities; next_token }

  let parse xml =
    Some
      { entities =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Entities" xml) OpsEntityList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("Entities.member", OpsEntityList.to_query v.entities))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Entities", OpsEntityList.to_json v.entities)
         ])

  let of_json j =
    { entities =
        OpsEntityList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Entities"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module GetMaintenanceWindowExecutionTaskRequest = struct
  type t =
    { window_execution_id : String.t
    ; task_id : String.t
    }

  let make ~window_execution_id ~task_id () = { window_execution_id; task_id }

  let parse xml =
    Some
      { window_execution_id =
          Aws.Xml.required
            "WindowExecutionId"
            (Aws.Util.option_bind (Aws.Xml.member "WindowExecutionId" xml) String.parse)
      ; task_id =
          Aws.Xml.required
            "TaskId"
            (Aws.Util.option_bind (Aws.Xml.member "TaskId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TaskId", String.to_query v.task_id))
         ; Some
             (Aws.Query.Pair ("WindowExecutionId", String.to_query v.window_execution_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TaskId", String.to_json v.task_id)
         ; Some ("WindowExecutionId", String.to_json v.window_execution_id)
         ])

  let of_json j =
    { window_execution_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowExecutionId"))
    ; task_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TaskId"))
    }
end

module InvalidKeyId = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json }
end

module RemoveTagsFromResourceRequest = struct
  type t =
    { resource_type : ResourceTypeForTagging.t
    ; resource_id : String.t
    ; tag_keys : KeyList.t
    }

  let make ~resource_type ~resource_id ~tag_keys () =
    { resource_type; resource_id; tag_keys }

  let parse xml =
    Some
      { resource_type =
          Aws.Xml.required
            "ResourceType"
            (Aws.Util.option_bind
               (Aws.Xml.member "ResourceType" xml)
               ResourceTypeForTagging.parse)
      ; resource_id =
          Aws.Xml.required
            "ResourceId"
            (Aws.Util.option_bind (Aws.Xml.member "ResourceId" xml) String.parse)
      ; tag_keys =
          Aws.Xml.required
            "TagKeys"
            (Aws.Util.option_bind (Aws.Xml.member "TagKeys" xml) KeyList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagKeys.member", KeyList.to_query v.tag_keys))
         ; Some (Aws.Query.Pair ("ResourceId", String.to_query v.resource_id))
         ; Some
             (Aws.Query.Pair
                ("ResourceType", ResourceTypeForTagging.to_query v.resource_type))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagKeys", KeyList.to_json v.tag_keys)
         ; Some ("ResourceId", String.to_json v.resource_id)
         ; Some ("ResourceType", ResourceTypeForTagging.to_json v.resource_type)
         ])

  let of_json j =
    { resource_type =
        ResourceTypeForTagging.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ResourceType"))
    ; resource_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ResourceId"))
    ; tag_keys = KeyList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TagKeys"))
    }
end

module DeletePatchBaselineRequest = struct
  type t = { baseline_id : String.t }

  let make ~baseline_id () = { baseline_id }

  let parse xml =
    Some
      { baseline_id =
          Aws.Xml.required
            "BaselineId"
            (Aws.Util.option_bind (Aws.Xml.member "BaselineId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("BaselineId", String.to_query v.baseline_id)) ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt [ Some ("BaselineId", String.to_json v.baseline_id) ])

  let of_json j =
    { baseline_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "BaselineId"))
    }
end

module ResumeSessionResponse = struct
  type t =
    { session_id : String.t option
    ; token_value : String.t option
    ; stream_url : String.t option
    }

  let make ?session_id ?token_value ?stream_url () =
    { session_id; token_value; stream_url }

  let parse xml =
    Some
      { session_id = Aws.Util.option_bind (Aws.Xml.member "SessionId" xml) String.parse
      ; token_value = Aws.Util.option_bind (Aws.Xml.member "TokenValue" xml) String.parse
      ; stream_url = Aws.Util.option_bind (Aws.Xml.member "StreamUrl" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.stream_url (fun f ->
               Aws.Query.Pair ("StreamUrl", String.to_query f))
         ; Aws.Util.option_map v.token_value (fun f ->
               Aws.Query.Pair ("TokenValue", String.to_query f))
         ; Aws.Util.option_map v.session_id (fun f ->
               Aws.Query.Pair ("SessionId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.stream_url (fun f -> "StreamUrl", String.to_json f)
         ; Aws.Util.option_map v.token_value (fun f -> "TokenValue", String.to_json f)
         ; Aws.Util.option_map v.session_id (fun f -> "SessionId", String.to_json f)
         ])

  let of_json j =
    { session_id = Aws.Util.option_map (Aws.Json.lookup j "SessionId") String.of_json
    ; token_value = Aws.Util.option_map (Aws.Json.lookup j "TokenValue") String.of_json
    ; stream_url = Aws.Util.option_map (Aws.Json.lookup j "StreamUrl") String.of_json
    }
end

module DescribeAssociationExecutionsRequest = struct
  type t =
    { association_id : String.t
    ; filters : AssociationExecutionFilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ~association_id ?(filters = []) ?max_results ?next_token () =
    { association_id; filters; max_results; next_token }

  let parse xml =
    Some
      { association_id =
          Aws.Xml.required
            "AssociationId"
            (Aws.Util.option_bind (Aws.Xml.member "AssociationId" xml) String.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               AssociationExecutionFilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Filters.member", AssociationExecutionFilterList.to_query v.filters))
         ; Some (Aws.Query.Pair ("AssociationId", String.to_query v.association_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filters", AssociationExecutionFilterList.to_json v.filters)
         ; Some ("AssociationId", String.to_json v.association_id)
         ])

  let of_json j =
    { association_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "AssociationId"))
    ; filters =
        AssociationExecutionFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module LabelParameterVersionRequest = struct
  type t =
    { name : String.t
    ; parameter_version : Long.t option
    ; labels : ParameterLabelList.t
    }

  let make ~name ?parameter_version ~labels () = { name; parameter_version; labels }

  let parse xml =
    Some
      { name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      ; parameter_version =
          Aws.Util.option_bind (Aws.Xml.member "ParameterVersion" xml) Long.parse
      ; labels =
          Aws.Xml.required
            "Labels"
            (Aws.Util.option_bind (Aws.Xml.member "Labels" xml) ParameterLabelList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Labels.member", ParameterLabelList.to_query v.labels))
         ; Aws.Util.option_map v.parameter_version (fun f ->
               Aws.Query.Pair ("ParameterVersion", Long.to_query f))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Labels", ParameterLabelList.to_json v.labels)
         ; Aws.Util.option_map v.parameter_version (fun f ->
               "ParameterVersion", Long.to_json f)
         ; Some ("Name", String.to_json v.name)
         ])

  let of_json j =
    { name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; parameter_version =
        Aws.Util.option_map (Aws.Json.lookup j "ParameterVersion") Long.of_json
    ; labels =
        ParameterLabelList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Labels"))
    }
end

module ResourceDataSyncNotFoundException = struct
  type t =
    { sync_name : String.t option
    ; sync_type : String.t option
    ; message : String.t option
    }

  let make ?sync_name ?sync_type ?message () = { sync_name; sync_type; message }

  let parse xml =
    Some
      { sync_name = Aws.Util.option_bind (Aws.Xml.member "SyncName" xml) String.parse
      ; sync_type = Aws.Util.option_bind (Aws.Xml.member "SyncType" xml) String.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.sync_type (fun f ->
               Aws.Query.Pair ("SyncType", String.to_query f))
         ; Aws.Util.option_map v.sync_name (fun f ->
               Aws.Query.Pair ("SyncName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f)
         ; Aws.Util.option_map v.sync_type (fun f -> "SyncType", String.to_json f)
         ; Aws.Util.option_map v.sync_name (fun f -> "SyncName", String.to_json f)
         ])

  let of_json j =
    { sync_name = Aws.Util.option_map (Aws.Json.lookup j "SyncName") String.of_json
    ; sync_type = Aws.Util.option_map (Aws.Json.lookup j "SyncType") String.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json
    }
end

module DescribePatchPropertiesRequest = struct
  type t =
    { operating_system : OperatingSystem.t
    ; property : PatchProperty.t
    ; patch_set : PatchSet.t option
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ~operating_system ~property ?patch_set ?max_results ?next_token () =
    { operating_system; property; patch_set; max_results; next_token }

  let parse xml =
    Some
      { operating_system =
          Aws.Xml.required
            "OperatingSystem"
            (Aws.Util.option_bind
               (Aws.Xml.member "OperatingSystem" xml)
               OperatingSystem.parse)
      ; property =
          Aws.Xml.required
            "Property"
            (Aws.Util.option_bind (Aws.Xml.member "Property" xml) PatchProperty.parse)
      ; patch_set = Aws.Util.option_bind (Aws.Xml.member "PatchSet" xml) PatchSet.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.patch_set (fun f ->
               Aws.Query.Pair ("PatchSet", PatchSet.to_query f))
         ; Some (Aws.Query.Pair ("Property", PatchProperty.to_query v.property))
         ; Some
             (Aws.Query.Pair
                ("OperatingSystem", OperatingSystem.to_query v.operating_system))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.patch_set (fun f -> "PatchSet", PatchSet.to_json f)
         ; Some ("Property", PatchProperty.to_json v.property)
         ; Some ("OperatingSystem", OperatingSystem.to_json v.operating_system)
         ])

  let of_json j =
    { operating_system =
        OperatingSystem.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "OperatingSystem"))
    ; property =
        PatchProperty.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Property"))
    ; patch_set = Aws.Util.option_map (Aws.Json.lookup j "PatchSet") PatchSet.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module GetCommandInvocationRequest = struct
  type t =
    { command_id : String.t
    ; instance_id : String.t
    ; plugin_name : String.t option
    }

  let make ~command_id ~instance_id ?plugin_name () =
    { command_id; instance_id; plugin_name }

  let parse xml =
    Some
      { command_id =
          Aws.Xml.required
            "CommandId"
            (Aws.Util.option_bind (Aws.Xml.member "CommandId" xml) String.parse)
      ; instance_id =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse)
      ; plugin_name = Aws.Util.option_bind (Aws.Xml.member "PluginName" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.plugin_name (fun f ->
               Aws.Query.Pair ("PluginName", String.to_query f))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ; Some (Aws.Query.Pair ("CommandId", String.to_query v.command_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.plugin_name (fun f -> "PluginName", String.to_json f)
         ; Some ("InstanceId", String.to_json v.instance_id)
         ; Some ("CommandId", String.to_json v.command_id)
         ])

  let of_json j =
    { command_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "CommandId"))
    ; instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; plugin_name = Aws.Util.option_map (Aws.Json.lookup j "PluginName") String.of_json
    }
end

module UpdateDocumentDefaultVersionResult = struct
  type t = { description : DocumentDefaultVersionDescription.t option }

  let make ?description () = { description }

  let parse xml =
    Some
      { description =
          Aws.Util.option_bind
            (Aws.Xml.member "Description" xml)
            DocumentDefaultVersionDescription.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", DocumentDefaultVersionDescription.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f ->
               "Description", DocumentDefaultVersionDescription.to_json f)
         ])

  let of_json j =
    { description =
        Aws.Util.option_map
          (Aws.Json.lookup j "Description")
          DocumentDefaultVersionDescription.of_json
    }
end

module UpdateManagedInstanceRoleResult = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module GetAutomationExecutionResult = struct
  type t = { automation_execution : AutomationExecution.t option }

  let make ?automation_execution () = { automation_execution }

  let parse xml =
    Some
      { automation_execution =
          Aws.Util.option_bind
            (Aws.Xml.member "AutomationExecution" xml)
            AutomationExecution.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.automation_execution (fun f ->
               Aws.Query.Pair ("AutomationExecution", AutomationExecution.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.automation_execution (fun f ->
               "AutomationExecution", AutomationExecution.to_json f)
         ])

  let of_json j =
    { automation_execution =
        Aws.Util.option_map
          (Aws.Json.lookup j "AutomationExecution")
          AutomationExecution.of_json
    }
end

module DeregisterTaskFromMaintenanceWindowResult = struct
  type t =
    { window_id : String.t option
    ; window_task_id : String.t option
    }

  let make ?window_id ?window_task_id () = { window_id; window_task_id }

  let parse xml =
    Some
      { window_id = Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse
      ; window_task_id =
          Aws.Util.option_bind (Aws.Xml.member "WindowTaskId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.window_task_id (fun f ->
               Aws.Query.Pair ("WindowTaskId", String.to_query f))
         ; Aws.Util.option_map v.window_id (fun f ->
               Aws.Query.Pair ("WindowId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.window_task_id (fun f ->
               "WindowTaskId", String.to_json f)
         ; Aws.Util.option_map v.window_id (fun f -> "WindowId", String.to_json f)
         ])

  let of_json j =
    { window_id = Aws.Util.option_map (Aws.Json.lookup j "WindowId") String.of_json
    ; window_task_id =
        Aws.Util.option_map (Aws.Json.lookup j "WindowTaskId") String.of_json
    }
end

module GetInventoryRequest = struct
  type t =
    { filters : InventoryFilterList.t
    ; aggregators : InventoryAggregatorList.t
    ; result_attributes : ResultAttributeList.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    }

  let make
      ?(filters = [])
      ?(aggregators = [])
      ?(result_attributes = [])
      ?next_token
      ?max_results
      () =
    { filters; aggregators; result_attributes; next_token; max_results }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               InventoryFilterList.parse)
      ; aggregators =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Aggregators" xml)
               InventoryAggregatorList.parse)
      ; result_attributes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ResultAttributes" xml)
               ResultAttributeList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ResultAttributes.member"
                , ResultAttributeList.to_query v.result_attributes ))
         ; Some
             (Aws.Query.Pair
                ("Aggregators.member", InventoryAggregatorList.to_query v.aggregators))
         ; Some
             (Aws.Query.Pair ("Filters.member", InventoryFilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("ResultAttributes", ResultAttributeList.to_json v.result_attributes)
         ; Some ("Aggregators", InventoryAggregatorList.to_json v.aggregators)
         ; Some ("Filters", InventoryFilterList.to_json v.filters)
         ])

  let of_json j =
    { filters =
        InventoryFilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; aggregators =
        InventoryAggregatorList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Aggregators"))
    ; result_attributes =
        ResultAttributeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ResultAttributes"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module CreateAssociationResult = struct
  type t = { association_description : AssociationDescription.t option }

  let make ?association_description () = { association_description }

  let parse xml =
    Some
      { association_description =
          Aws.Util.option_bind
            (Aws.Xml.member "AssociationDescription" xml)
            AssociationDescription.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_description (fun f ->
               Aws.Query.Pair ("AssociationDescription", AssociationDescription.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_description (fun f ->
               "AssociationDescription", AssociationDescription.to_json f)
         ])

  let of_json j =
    { association_description =
        Aws.Util.option_map
          (Aws.Json.lookup j "AssociationDescription")
          AssociationDescription.of_json
    }
end

module ParameterLimitExceeded = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json }
end

module InvalidInstanceInformationFilterValue = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json }
end

module DeleteDocumentResult = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module GetServiceSettingRequest = struct
  type t = { setting_id : String.t }

  let make ~setting_id () = { setting_id }

  let parse xml =
    Some
      { setting_id =
          Aws.Xml.required
            "SettingId"
            (Aws.Util.option_bind (Aws.Xml.member "SettingId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("SettingId", String.to_query v.setting_id)) ])

  let to_json v =
    `Assoc (Aws.Util.list_filter_opt [ Some ("SettingId", String.to_json v.setting_id) ])

  let of_json j =
    { setting_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SettingId"))
    }
end

module InvalidFilterValue = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module CreateResourceDataSyncRequest = struct
  type t =
    { sync_name : String.t
    ; s3_destination : ResourceDataSyncS3Destination.t option
    ; sync_type : String.t option
    ; sync_source : ResourceDataSyncSource.t option
    }

  let make ~sync_name ?s3_destination ?sync_type ?sync_source () =
    { sync_name; s3_destination; sync_type; sync_source }

  let parse xml =
    Some
      { sync_name =
          Aws.Xml.required
            "SyncName"
            (Aws.Util.option_bind (Aws.Xml.member "SyncName" xml) String.parse)
      ; s3_destination =
          Aws.Util.option_bind
            (Aws.Xml.member "S3Destination" xml)
            ResourceDataSyncS3Destination.parse
      ; sync_type = Aws.Util.option_bind (Aws.Xml.member "SyncType" xml) String.parse
      ; sync_source =
          Aws.Util.option_bind
            (Aws.Xml.member "SyncSource" xml)
            ResourceDataSyncSource.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.sync_source (fun f ->
               Aws.Query.Pair ("SyncSource", ResourceDataSyncSource.to_query f))
         ; Aws.Util.option_map v.sync_type (fun f ->
               Aws.Query.Pair ("SyncType", String.to_query f))
         ; Aws.Util.option_map v.s3_destination (fun f ->
               Aws.Query.Pair ("S3Destination", ResourceDataSyncS3Destination.to_query f))
         ; Some (Aws.Query.Pair ("SyncName", String.to_query v.sync_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.sync_source (fun f ->
               "SyncSource", ResourceDataSyncSource.to_json f)
         ; Aws.Util.option_map v.sync_type (fun f -> "SyncType", String.to_json f)
         ; Aws.Util.option_map v.s3_destination (fun f ->
               "S3Destination", ResourceDataSyncS3Destination.to_json f)
         ; Some ("SyncName", String.to_json v.sync_name)
         ])

  let of_json j =
    { sync_name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SyncName"))
    ; s3_destination =
        Aws.Util.option_map
          (Aws.Json.lookup j "S3Destination")
          ResourceDataSyncS3Destination.of_json
    ; sync_type = Aws.Util.option_map (Aws.Json.lookup j "SyncType") String.of_json
    ; sync_source =
        Aws.Util.option_map
          (Aws.Json.lookup j "SyncSource")
          ResourceDataSyncSource.of_json
    }
end

module MaintenanceWindowExecutionTaskIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v
  let to_json v = `List (List.map String.to_json v)
  let of_json j = Aws.Json.to_list String.of_json j
end

module CreateDocumentResult = struct
  type t = { document_description : DocumentDescription.t option }

  let make ?document_description () = { document_description }

  let parse xml =
    Some
      { document_description =
          Aws.Util.option_bind
            (Aws.Xml.member "DocumentDescription" xml)
            DocumentDescription.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.document_description (fun f ->
               Aws.Query.Pair ("DocumentDescription", DocumentDescription.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.document_description (fun f ->
               "DocumentDescription", DocumentDescription.to_json f)
         ])

  let of_json j =
    { document_description =
        Aws.Util.option_map
          (Aws.Json.lookup j "DocumentDescription")
          DocumentDescription.of_json
    }
end

module DeleteActivationResult = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module UpdateManagedInstanceRoleRequest = struct
  type t =
    { instance_id : String.t
    ; iam_role : String.t
    }

  let make ~instance_id ~iam_role () = { instance_id; iam_role }

  let parse xml =
    Some
      { instance_id =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse)
      ; iam_role =
          Aws.Xml.required
            "IamRole"
            (Aws.Util.option_bind (Aws.Xml.member "IamRole" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("IamRole", String.to_query v.iam_role))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("IamRole", String.to_json v.iam_role)
         ; Some ("InstanceId", String.to_json v.instance_id)
         ])

  let of_json j =
    { instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; iam_role = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "IamRole"))
    }
end

module ParameterAlreadyExists = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json }
end

module TooManyUpdates = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module DeregisterManagedInstanceRequest = struct
  type t = { instance_id : String.t }

  let make ~instance_id () = { instance_id }

  let parse xml =
    Some
      { instance_id =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id)) ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt [ Some ("InstanceId", String.to_json v.instance_id) ])

  let of_json j =
    { instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    }
end

module InvalidPolicyAttributeException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json }
end

module InvalidDocument = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module DescribeInstancePatchStatesRequest = struct
  type t =
    { instance_ids : InstanceIdList.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    }

  let make ~instance_ids ?next_token ?max_results () =
    { instance_ids; next_token; max_results }

  let parse xml =
    Some
      { instance_ids =
          Aws.Xml.required
            "InstanceIds"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceIds" xml) InstanceIdList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair ("InstanceIds.member", InstanceIdList.to_query v.instance_ids))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("InstanceIds", InstanceIdList.to_json v.instance_ids)
         ])

  let of_json j =
    { instance_ids =
        InstanceIdList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceIds"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module AssociationFilterList = struct
  type t = AssociationFilter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map AssociationFilter.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list AssociationFilter.to_query v
  let to_json v = `List (List.map AssociationFilter.to_json v)
  let of_json j = Aws.Json.to_list AssociationFilter.of_json j
end

module UpdateMaintenanceWindowResult = struct
  type t =
    { window_id : String.t option
    ; name : String.t option
    ; description : String.t option
    ; start_date : String.t option
    ; end_date : String.t option
    ; schedule : String.t option
    ; schedule_timezone : String.t option
    ; schedule_offset : Integer.t option
    ; duration : Integer.t option
    ; cutoff : Integer.t option
    ; allow_unassociated_targets : Boolean.t option
    ; enabled : Boolean.t option
    }

  let make
      ?window_id
      ?name
      ?description
      ?start_date
      ?end_date
      ?schedule
      ?schedule_timezone
      ?schedule_offset
      ?duration
      ?cutoff
      ?allow_unassociated_targets
      ?enabled
      () =
    { window_id
    ; name
    ; description
    ; start_date
    ; end_date
    ; schedule
    ; schedule_timezone
    ; schedule_offset
    ; duration
    ; cutoff
    ; allow_unassociated_targets
    ; enabled
    }

  let parse xml =
    Some
      { window_id = Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; start_date = Aws.Util.option_bind (Aws.Xml.member "StartDate" xml) String.parse
      ; end_date = Aws.Util.option_bind (Aws.Xml.member "EndDate" xml) String.parse
      ; schedule = Aws.Util.option_bind (Aws.Xml.member "Schedule" xml) String.parse
      ; schedule_timezone =
          Aws.Util.option_bind (Aws.Xml.member "ScheduleTimezone" xml) String.parse
      ; schedule_offset =
          Aws.Util.option_bind (Aws.Xml.member "ScheduleOffset" xml) Integer.parse
      ; duration = Aws.Util.option_bind (Aws.Xml.member "Duration" xml) Integer.parse
      ; cutoff = Aws.Util.option_bind (Aws.Xml.member "Cutoff" xml) Integer.parse
      ; allow_unassociated_targets =
          Aws.Util.option_bind
            (Aws.Xml.member "AllowUnassociatedTargets" xml)
            Boolean.parse
      ; enabled = Aws.Util.option_bind (Aws.Xml.member "Enabled" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enabled (fun f ->
               Aws.Query.Pair ("Enabled", Boolean.to_query f))
         ; Aws.Util.option_map v.allow_unassociated_targets (fun f ->
               Aws.Query.Pair ("AllowUnassociatedTargets", Boolean.to_query f))
         ; Aws.Util.option_map v.cutoff (fun f ->
               Aws.Query.Pair ("Cutoff", Integer.to_query f))
         ; Aws.Util.option_map v.duration (fun f ->
               Aws.Query.Pair ("Duration", Integer.to_query f))
         ; Aws.Util.option_map v.schedule_offset (fun f ->
               Aws.Query.Pair ("ScheduleOffset", Integer.to_query f))
         ; Aws.Util.option_map v.schedule_timezone (fun f ->
               Aws.Query.Pair ("ScheduleTimezone", String.to_query f))
         ; Aws.Util.option_map v.schedule (fun f ->
               Aws.Query.Pair ("Schedule", String.to_query f))
         ; Aws.Util.option_map v.end_date (fun f ->
               Aws.Query.Pair ("EndDate", String.to_query f))
         ; Aws.Util.option_map v.start_date (fun f ->
               Aws.Query.Pair ("StartDate", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.window_id (fun f ->
               Aws.Query.Pair ("WindowId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enabled (fun f -> "Enabled", Boolean.to_json f)
         ; Aws.Util.option_map v.allow_unassociated_targets (fun f ->
               "AllowUnassociatedTargets", Boolean.to_json f)
         ; Aws.Util.option_map v.cutoff (fun f -> "Cutoff", Integer.to_json f)
         ; Aws.Util.option_map v.duration (fun f -> "Duration", Integer.to_json f)
         ; Aws.Util.option_map v.schedule_offset (fun f ->
               "ScheduleOffset", Integer.to_json f)
         ; Aws.Util.option_map v.schedule_timezone (fun f ->
               "ScheduleTimezone", String.to_json f)
         ; Aws.Util.option_map v.schedule (fun f -> "Schedule", String.to_json f)
         ; Aws.Util.option_map v.end_date (fun f -> "EndDate", String.to_json f)
         ; Aws.Util.option_map v.start_date (fun f -> "StartDate", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.window_id (fun f -> "WindowId", String.to_json f)
         ])

  let of_json j =
    { window_id = Aws.Util.option_map (Aws.Json.lookup j "WindowId") String.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; start_date = Aws.Util.option_map (Aws.Json.lookup j "StartDate") String.of_json
    ; end_date = Aws.Util.option_map (Aws.Json.lookup j "EndDate") String.of_json
    ; schedule = Aws.Util.option_map (Aws.Json.lookup j "Schedule") String.of_json
    ; schedule_timezone =
        Aws.Util.option_map (Aws.Json.lookup j "ScheduleTimezone") String.of_json
    ; schedule_offset =
        Aws.Util.option_map (Aws.Json.lookup j "ScheduleOffset") Integer.of_json
    ; duration = Aws.Util.option_map (Aws.Json.lookup j "Duration") Integer.of_json
    ; cutoff = Aws.Util.option_map (Aws.Json.lookup j "Cutoff") Integer.of_json
    ; allow_unassociated_targets =
        Aws.Util.option_map (Aws.Json.lookup j "AllowUnassociatedTargets") Boolean.of_json
    ; enabled = Aws.Util.option_map (Aws.Json.lookup j "Enabled") Boolean.of_json
    }
end

module DescribeInstanceInformationRequest = struct
  type t =
    { instance_information_filter_list : InstanceInformationFilterList.t
    ; filters : InstanceInformationStringFilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make
      ?(instance_information_filter_list = [])
      ?(filters = [])
      ?max_results
      ?next_token
      () =
    { instance_information_filter_list; filters; max_results; next_token }

  let parse xml =
    Some
      { instance_information_filter_list =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "InstanceInformationFilterList" xml)
               InstanceInformationFilterList.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               InstanceInformationStringFilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Filters.member", InstanceInformationStringFilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ( "InstanceInformationFilterList.member"
                , InstanceInformationFilterList.to_query
                    v.instance_information_filter_list ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filters", InstanceInformationStringFilterList.to_json v.filters)
         ; Some
             ( "InstanceInformationFilterList"
             , InstanceInformationFilterList.to_json v.instance_information_filter_list )
         ])

  let of_json j =
    { instance_information_filter_list =
        InstanceInformationFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceInformationFilterList"))
    ; filters =
        InstanceInformationStringFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module AssociationExecutionTargetsFilter = struct
  type t =
    { key : AssociationExecutionTargetsFilterKey.t
    ; value : String.t
    }

  let make ~key ~value () = { key; value }

  let parse xml =
    Some
      { key =
          Aws.Xml.required
            "Key"
            (Aws.Util.option_bind
               (Aws.Xml.member "Key" xml)
               AssociationExecutionTargetsFilterKey.parse)
      ; value =
          Aws.Xml.required
            "Value"
            (Aws.Util.option_bind (Aws.Xml.member "Value" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Value", String.to_query v.value))
         ; Some
             (Aws.Query.Pair ("Key", AssociationExecutionTargetsFilterKey.to_query v.key))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Value", String.to_json v.value)
         ; Some ("Key", AssociationExecutionTargetsFilterKey.to_json v.key)
         ])

  let of_json j =
    { key =
        AssociationExecutionTargetsFilterKey.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Key"))
    ; value = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Value"))
    }
end

module StartAssociationsOnceResult = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module SendAutomationSignalRequest = struct
  type t =
    { automation_execution_id : String.t
    ; signal_type : SignalType.t
    ; payload : AutomationParameterMap.t option
    }

  let make ~automation_execution_id ~signal_type ?payload () =
    { automation_execution_id; signal_type; payload }

  let parse xml =
    Some
      { automation_execution_id =
          Aws.Xml.required
            "AutomationExecutionId"
            (Aws.Util.option_bind
               (Aws.Xml.member "AutomationExecutionId" xml)
               String.parse)
      ; signal_type =
          Aws.Xml.required
            "SignalType"
            (Aws.Util.option_bind (Aws.Xml.member "SignalType" xml) SignalType.parse)
      ; payload =
          Aws.Util.option_bind (Aws.Xml.member "Payload" xml) AutomationParameterMap.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.payload (fun f ->
               Aws.Query.Pair ("Payload", AutomationParameterMap.to_query f))
         ; Some (Aws.Query.Pair ("SignalType", SignalType.to_query v.signal_type))
         ; Some
             (Aws.Query.Pair
                ("AutomationExecutionId", String.to_query v.automation_execution_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.payload (fun f ->
               "Payload", AutomationParameterMap.to_json f)
         ; Some ("SignalType", SignalType.to_json v.signal_type)
         ; Some ("AutomationExecutionId", String.to_json v.automation_execution_id)
         ])

  let of_json j =
    { automation_execution_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AutomationExecutionId"))
    ; signal_type =
        SignalType.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SignalType"))
    ; payload =
        Aws.Util.option_map (Aws.Json.lookup j "Payload") AutomationParameterMap.of_json
    }
end

module InvalidInventoryRequestException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module DeleteInventoryRequest = struct
  type t =
    { type_name : String.t
    ; schema_delete_option : InventorySchemaDeleteOption.t option
    ; dry_run : Boolean.t option
    ; client_token : String.t option
    }

  let make ~type_name ?schema_delete_option ?dry_run ?client_token () =
    { type_name; schema_delete_option; dry_run; client_token }

  let parse xml =
    Some
      { type_name =
          Aws.Xml.required
            "TypeName"
            (Aws.Util.option_bind (Aws.Xml.member "TypeName" xml) String.parse)
      ; schema_delete_option =
          Aws.Util.option_bind
            (Aws.Xml.member "SchemaDeleteOption" xml)
            InventorySchemaDeleteOption.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.schema_delete_option (fun f ->
               Aws.Query.Pair
                 ("SchemaDeleteOption", InventorySchemaDeleteOption.to_query f))
         ; Some (Aws.Query.Pair ("TypeName", String.to_query v.type_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.schema_delete_option (fun f ->
               "SchemaDeleteOption", InventorySchemaDeleteOption.to_json f)
         ; Some ("TypeName", String.to_json v.type_name)
         ])

  let of_json j =
    { type_name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TypeName"))
    ; schema_delete_option =
        Aws.Util.option_map
          (Aws.Json.lookup j "SchemaDeleteOption")
          InventorySchemaDeleteOption.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    }
end

module InternalServerError = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module CreateAssociationRequest = struct
  type t =
    { name : String.t
    ; document_version : String.t option
    ; instance_id : String.t option
    ; parameters : Parameters.t option
    ; targets : Targets.t
    ; schedule_expression : String.t option
    ; output_location : InstanceAssociationOutputLocation.t option
    ; association_name : String.t option
    ; automation_target_parameter_name : String.t option
    ; max_errors : String.t option
    ; max_concurrency : String.t option
    ; compliance_severity : AssociationComplianceSeverity.t option
    ; sync_compliance : AssociationSyncCompliance.t option
    ; apply_only_at_cron_interval : Boolean.t option
    }

  let make
      ~name
      ?document_version
      ?instance_id
      ?parameters
      ?(targets = [])
      ?schedule_expression
      ?output_location
      ?association_name
      ?automation_target_parameter_name
      ?max_errors
      ?max_concurrency
      ?compliance_severity
      ?sync_compliance
      ?apply_only_at_cron_interval
      () =
    { name
    ; document_version
    ; instance_id
    ; parameters
    ; targets
    ; schedule_expression
    ; output_location
    ; association_name
    ; automation_target_parameter_name
    ; max_errors
    ; max_concurrency
    ; compliance_severity
    ; sync_compliance
    ; apply_only_at_cron_interval
    }

  let parse xml =
    Some
      { name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      ; document_version =
          Aws.Util.option_bind (Aws.Xml.member "DocumentVersion" xml) String.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse
      ; parameters =
          Aws.Util.option_bind (Aws.Xml.member "Parameters" xml) Parameters.parse
      ; targets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Targets" xml) Targets.parse)
      ; schedule_expression =
          Aws.Util.option_bind (Aws.Xml.member "ScheduleExpression" xml) String.parse
      ; output_location =
          Aws.Util.option_bind
            (Aws.Xml.member "OutputLocation" xml)
            InstanceAssociationOutputLocation.parse
      ; association_name =
          Aws.Util.option_bind (Aws.Xml.member "AssociationName" xml) String.parse
      ; automation_target_parameter_name =
          Aws.Util.option_bind
            (Aws.Xml.member "AutomationTargetParameterName" xml)
            String.parse
      ; max_errors = Aws.Util.option_bind (Aws.Xml.member "MaxErrors" xml) String.parse
      ; max_concurrency =
          Aws.Util.option_bind (Aws.Xml.member "MaxConcurrency" xml) String.parse
      ; compliance_severity =
          Aws.Util.option_bind
            (Aws.Xml.member "ComplianceSeverity" xml)
            AssociationComplianceSeverity.parse
      ; sync_compliance =
          Aws.Util.option_bind
            (Aws.Xml.member "SyncCompliance" xml)
            AssociationSyncCompliance.parse
      ; apply_only_at_cron_interval =
          Aws.Util.option_bind
            (Aws.Xml.member "ApplyOnlyAtCronInterval" xml)
            Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.apply_only_at_cron_interval (fun f ->
               Aws.Query.Pair ("ApplyOnlyAtCronInterval", Boolean.to_query f))
         ; Aws.Util.option_map v.sync_compliance (fun f ->
               Aws.Query.Pair ("SyncCompliance", AssociationSyncCompliance.to_query f))
         ; Aws.Util.option_map v.compliance_severity (fun f ->
               Aws.Query.Pair
                 ("ComplianceSeverity", AssociationComplianceSeverity.to_query f))
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               Aws.Query.Pair ("MaxConcurrency", String.to_query f))
         ; Aws.Util.option_map v.max_errors (fun f ->
               Aws.Query.Pair ("MaxErrors", String.to_query f))
         ; Aws.Util.option_map v.automation_target_parameter_name (fun f ->
               Aws.Query.Pair ("AutomationTargetParameterName", String.to_query f))
         ; Aws.Util.option_map v.association_name (fun f ->
               Aws.Query.Pair ("AssociationName", String.to_query f))
         ; Aws.Util.option_map v.output_location (fun f ->
               Aws.Query.Pair
                 ("OutputLocation", InstanceAssociationOutputLocation.to_query f))
         ; Aws.Util.option_map v.schedule_expression (fun f ->
               Aws.Query.Pair ("ScheduleExpression", String.to_query f))
         ; Some (Aws.Query.Pair ("Targets.member", Targets.to_query v.targets))
         ; Aws.Util.option_map v.parameters (fun f ->
               Aws.Query.Pair ("Parameters", Parameters.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.document_version (fun f ->
               Aws.Query.Pair ("DocumentVersion", String.to_query f))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.apply_only_at_cron_interval (fun f ->
               "ApplyOnlyAtCronInterval", Boolean.to_json f)
         ; Aws.Util.option_map v.sync_compliance (fun f ->
               "SyncCompliance", AssociationSyncCompliance.to_json f)
         ; Aws.Util.option_map v.compliance_severity (fun f ->
               "ComplianceSeverity", AssociationComplianceSeverity.to_json f)
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               "MaxConcurrency", String.to_json f)
         ; Aws.Util.option_map v.max_errors (fun f -> "MaxErrors", String.to_json f)
         ; Aws.Util.option_map v.automation_target_parameter_name (fun f ->
               "AutomationTargetParameterName", String.to_json f)
         ; Aws.Util.option_map v.association_name (fun f ->
               "AssociationName", String.to_json f)
         ; Aws.Util.option_map v.output_location (fun f ->
               "OutputLocation", InstanceAssociationOutputLocation.to_json f)
         ; Aws.Util.option_map v.schedule_expression (fun f ->
               "ScheduleExpression", String.to_json f)
         ; Some ("Targets", Targets.to_json v.targets)
         ; Aws.Util.option_map v.parameters (fun f -> "Parameters", Parameters.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "InstanceId", String.to_json f)
         ; Aws.Util.option_map v.document_version (fun f ->
               "DocumentVersion", String.to_json f)
         ; Some ("Name", String.to_json v.name)
         ])

  let of_json j =
    { name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; document_version =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentVersion") String.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "InstanceId") String.of_json
    ; parameters = Aws.Util.option_map (Aws.Json.lookup j "Parameters") Parameters.of_json
    ; targets = Targets.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Targets"))
    ; schedule_expression =
        Aws.Util.option_map (Aws.Json.lookup j "ScheduleExpression") String.of_json
    ; output_location =
        Aws.Util.option_map
          (Aws.Json.lookup j "OutputLocation")
          InstanceAssociationOutputLocation.of_json
    ; association_name =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationName") String.of_json
    ; automation_target_parameter_name =
        Aws.Util.option_map
          (Aws.Json.lookup j "AutomationTargetParameterName")
          String.of_json
    ; max_errors = Aws.Util.option_map (Aws.Json.lookup j "MaxErrors") String.of_json
    ; max_concurrency =
        Aws.Util.option_map (Aws.Json.lookup j "MaxConcurrency") String.of_json
    ; compliance_severity =
        Aws.Util.option_map
          (Aws.Json.lookup j "ComplianceSeverity")
          AssociationComplianceSeverity.of_json
    ; sync_compliance =
        Aws.Util.option_map
          (Aws.Json.lookup j "SyncCompliance")
          AssociationSyncCompliance.of_json
    ; apply_only_at_cron_interval =
        Aws.Util.option_map (Aws.Json.lookup j "ApplyOnlyAtCronInterval") Boolean.of_json
    }
end

module DescribeDocumentRequest = struct
  type t =
    { name : String.t
    ; document_version : String.t option
    ; version_name : String.t option
    }

  let make ~name ?document_version ?version_name () =
    { name; document_version; version_name }

  let parse xml =
    Some
      { name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      ; document_version =
          Aws.Util.option_bind (Aws.Xml.member "DocumentVersion" xml) String.parse
      ; version_name =
          Aws.Util.option_bind (Aws.Xml.member "VersionName" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.version_name (fun f ->
               Aws.Query.Pair ("VersionName", String.to_query f))
         ; Aws.Util.option_map v.document_version (fun f ->
               Aws.Query.Pair ("DocumentVersion", String.to_query f))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.version_name (fun f -> "VersionName", String.to_json f)
         ; Aws.Util.option_map v.document_version (fun f ->
               "DocumentVersion", String.to_json f)
         ; Some ("Name", String.to_json v.name)
         ])

  let of_json j =
    { name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; document_version =
        Aws.Util.option_map (Aws.Json.lookup j "DocumentVersion") String.of_json
    ; version_name = Aws.Util.option_map (Aws.Json.lookup j "VersionName") String.of_json
    }
end

module ResourceDataSyncAlreadyExistsException = struct
  type t = { sync_name : String.t option }

  let make ?sync_name () = { sync_name }

  let parse xml =
    Some { sync_name = Aws.Util.option_bind (Aws.Xml.member "SyncName" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.sync_name (fun f ->
               Aws.Query.Pair ("SyncName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.sync_name (fun f -> "SyncName", String.to_json f) ])

  let of_json j =
    { sync_name = Aws.Util.option_map (Aws.Json.lookup j "SyncName") String.of_json }
end

module InvalidDeleteInventoryParametersException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module InvalidResultAttributeException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module AlreadyExistsException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module DuplicateDocumentVersionName = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module AddTagsToResourceResult = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module ListResourceComplianceSummariesRequest = struct
  type t =
    { filters : ComplianceStringFilterList.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    }

  let make ?(filters = []) ?next_token ?max_results () =
    { filters; next_token; max_results }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               ComplianceStringFilterList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Filters.member", ComplianceStringFilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Filters", ComplianceStringFilterList.to_json v.filters)
         ])

  let of_json j =
    { filters =
        ComplianceStringFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module InvalidDocumentSchemaVersion = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module ListDocumentsResult = struct
  type t =
    { document_identifiers : DocumentIdentifierList.t
    ; next_token : String.t option
    }

  let make ?(document_identifiers = []) ?next_token () =
    { document_identifiers; next_token }

  let parse xml =
    Some
      { document_identifiers =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DocumentIdentifiers" xml)
               DocumentIdentifierList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "DocumentIdentifiers.member"
                , DocumentIdentifierList.to_query v.document_identifiers ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some
             ("DocumentIdentifiers", DocumentIdentifierList.to_json v.document_identifiers)
         ])

  let of_json j =
    { document_identifiers =
        DocumentIdentifierList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DocumentIdentifiers"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module ListAssociationVersionsRequest = struct
  type t =
    { association_id : String.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ~association_id ?max_results ?next_token () =
    { association_id; max_results; next_token }

  let parse xml =
    Some
      { association_id =
          Aws.Xml.required
            "AssociationId"
            (Aws.Util.option_bind (Aws.Xml.member "AssociationId" xml) String.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("AssociationId", String.to_query v.association_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("AssociationId", String.to_json v.association_id)
         ])

  let of_json j =
    { association_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "AssociationId"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module DescribeAutomationExecutionsResult = struct
  type t =
    { automation_execution_metadata_list : AutomationExecutionMetadataList.t
    ; next_token : String.t option
    }

  let make ?(automation_execution_metadata_list = []) ?next_token () =
    { automation_execution_metadata_list; next_token }

  let parse xml =
    Some
      { automation_execution_metadata_list =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AutomationExecutionMetadataList" xml)
               AutomationExecutionMetadataList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "AutomationExecutionMetadataList.member"
                , AutomationExecutionMetadataList.to_query
                    v.automation_execution_metadata_list ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some
             ( "AutomationExecutionMetadataList"
             , AutomationExecutionMetadataList.to_json
                 v.automation_execution_metadata_list )
         ])

  let of_json j =
    { automation_execution_metadata_list =
        AutomationExecutionMetadataList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AutomationExecutionMetadataList"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module DescribeAssociationResult = struct
  type t = { association_description : AssociationDescription.t option }

  let make ?association_description () = { association_description }

  let parse xml =
    Some
      { association_description =
          Aws.Util.option_bind
            (Aws.Xml.member "AssociationDescription" xml)
            AssociationDescription.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_description (fun f ->
               Aws.Query.Pair ("AssociationDescription", AssociationDescription.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_description (fun f ->
               "AssociationDescription", AssociationDescription.to_json f)
         ])

  let of_json j =
    { association_description =
        Aws.Util.option_map
          (Aws.Json.lookup j "AssociationDescription")
          AssociationDescription.of_json
    }
end

module DeleteResourceDataSyncResult = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module GetServiceSettingResult = struct
  type t = { service_setting : ServiceSetting.t option }

  let make ?service_setting () = { service_setting }

  let parse xml =
    Some
      { service_setting =
          Aws.Util.option_bind (Aws.Xml.member "ServiceSetting" xml) ServiceSetting.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.service_setting (fun f ->
               Aws.Query.Pair ("ServiceSetting", ServiceSetting.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.service_setting (fun f ->
               "ServiceSetting", ServiceSetting.to_json f)
         ])

  let of_json j =
    { service_setting =
        Aws.Util.option_map (Aws.Json.lookup j "ServiceSetting") ServiceSetting.of_json
    }
end

module DocumentAlreadyExists = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module GetInventorySchemaRequest = struct
  type t =
    { type_name : String.t option
    ; next_token : String.t option
    ; max_results : Integer.t option
    ; aggregator : Boolean.t option
    ; sub_type : Boolean.t option
    }

  let make ?type_name ?next_token ?max_results ?aggregator ?sub_type () =
    { type_name; next_token; max_results; aggregator; sub_type }

  let parse xml =
    Some
      { type_name = Aws.Util.option_bind (Aws.Xml.member "TypeName" xml) String.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; aggregator = Aws.Util.option_bind (Aws.Xml.member "Aggregator" xml) Boolean.parse
      ; sub_type = Aws.Util.option_bind (Aws.Xml.member "SubType" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.sub_type (fun f ->
               Aws.Query.Pair ("SubType", Boolean.to_query f))
         ; Aws.Util.option_map v.aggregator (fun f ->
               Aws.Query.Pair ("Aggregator", Boolean.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.type_name (fun f ->
               Aws.Query.Pair ("TypeName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.sub_type (fun f -> "SubType", Boolean.to_json f)
         ; Aws.Util.option_map v.aggregator (fun f -> "Aggregator", Boolean.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.type_name (fun f -> "TypeName", String.to_json f)
         ])

  let of_json j =
    { type_name = Aws.Util.option_map (Aws.Json.lookup j "TypeName") String.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; aggregator = Aws.Util.option_map (Aws.Json.lookup j "Aggregator") Boolean.of_json
    ; sub_type = Aws.Util.option_map (Aws.Json.lookup j "SubType") Boolean.of_json
    }
end

module DocumentPermissionLimit = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module InvalidActivationId = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module DescribeAutomationStepExecutionsRequest = struct
  type t =
    { automation_execution_id : String.t
    ; filters : StepExecutionFilterList.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    ; reverse_order : Boolean.t option
    }

  let make
      ~automation_execution_id
      ?(filters = [])
      ?next_token
      ?max_results
      ?reverse_order
      () =
    { automation_execution_id; filters; next_token; max_results; reverse_order }

  let parse xml =
    Some
      { automation_execution_id =
          Aws.Xml.required
            "AutomationExecutionId"
            (Aws.Util.option_bind
               (Aws.Xml.member "AutomationExecutionId" xml)
               String.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               StepExecutionFilterList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; reverse_order =
          Aws.Util.option_bind (Aws.Xml.member "ReverseOrder" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.reverse_order (fun f ->
               Aws.Query.Pair ("ReverseOrder", Boolean.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair ("Filters.member", StepExecutionFilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ("AutomationExecutionId", String.to_query v.automation_execution_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.reverse_order (fun f ->
               "ReverseOrder", Boolean.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Filters", StepExecutionFilterList.to_json v.filters)
         ; Some ("AutomationExecutionId", String.to_json v.automation_execution_id)
         ])

  let of_json j =
    { automation_execution_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AutomationExecutionId"))
    ; filters =
        StepExecutionFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; reverse_order =
        Aws.Util.option_map (Aws.Json.lookup j "ReverseOrder") Boolean.of_json
    }
end

module UpdateMaintenanceWindowTargetResult = struct
  type t =
    { window_id : String.t option
    ; window_target_id : String.t option
    ; targets : Targets.t
    ; owner_information : String.t option
    ; name : String.t option
    ; description : String.t option
    }

  let make
      ?window_id
      ?window_target_id
      ?(targets = [])
      ?owner_information
      ?name
      ?description
      () =
    { window_id; window_target_id; targets; owner_information; name; description }

  let parse xml =
    Some
      { window_id = Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse
      ; window_target_id =
          Aws.Util.option_bind (Aws.Xml.member "WindowTargetId" xml) String.parse
      ; targets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Targets" xml) Targets.parse)
      ; owner_information =
          Aws.Util.option_bind (Aws.Xml.member "OwnerInformation" xml) String.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.owner_information (fun f ->
               Aws.Query.Pair ("OwnerInformation", String.to_query f))
         ; Some (Aws.Query.Pair ("Targets.member", Targets.to_query v.targets))
         ; Aws.Util.option_map v.window_target_id (fun f ->
               Aws.Query.Pair ("WindowTargetId", String.to_query f))
         ; Aws.Util.option_map v.window_id (fun f ->
               Aws.Query.Pair ("WindowId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.owner_information (fun f ->
               "OwnerInformation", String.to_json f)
         ; Some ("Targets", Targets.to_json v.targets)
         ; Aws.Util.option_map v.window_target_id (fun f ->
               "WindowTargetId", String.to_json f)
         ; Aws.Util.option_map v.window_id (fun f -> "WindowId", String.to_json f)
         ])

  let of_json j =
    { window_id = Aws.Util.option_map (Aws.Json.lookup j "WindowId") String.of_json
    ; window_target_id =
        Aws.Util.option_map (Aws.Json.lookup j "WindowTargetId") String.of_json
    ; targets = Targets.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Targets"))
    ; owner_information =
        Aws.Util.option_map (Aws.Json.lookup j "OwnerInformation") String.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    }
end

module AssociationExecutionTargetsFilterList = struct
  type t = AssociationExecutionTargetsFilter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map AssociationExecutionTargetsFilter.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list AssociationExecutionTargetsFilter.to_query v
  let to_json v = `List (List.map AssociationExecutionTargetsFilter.to_json v)
  let of_json j = Aws.Json.to_list AssociationExecutionTargetsFilter.of_json j
end

module DescribeAssociationExecutionTargetsRequest = struct
  type t =
    { association_id : String.t
    ; execution_id : String.t
    ; filters : AssociationExecutionTargetsFilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ~association_id ~execution_id ?(filters = []) ?max_results ?next_token () =
    { association_id; execution_id; filters; max_results; next_token }

  let parse xml =
    Some
      { association_id =
          Aws.Xml.required
            "AssociationId"
            (Aws.Util.option_bind (Aws.Xml.member "AssociationId" xml) String.parse)
      ; execution_id =
          Aws.Xml.required
            "ExecutionId"
            (Aws.Util.option_bind (Aws.Xml.member "ExecutionId" xml) String.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               AssociationExecutionTargetsFilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "Filters.member"
                , AssociationExecutionTargetsFilterList.to_query v.filters ))
         ; Some (Aws.Query.Pair ("ExecutionId", String.to_query v.execution_id))
         ; Some (Aws.Query.Pair ("AssociationId", String.to_query v.association_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filters", AssociationExecutionTargetsFilterList.to_json v.filters)
         ; Some ("ExecutionId", String.to_json v.execution_id)
         ; Some ("AssociationId", String.to_json v.association_id)
         ])

  let of_json j =
    { association_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "AssociationId"))
    ; execution_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ExecutionId"))
    ; filters =
        AssociationExecutionTargetsFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module InvalidAutomationStatusUpdateException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module GetMaintenanceWindowExecutionTaskInvocationResult = struct
  type t =
    { window_execution_id : String.t option
    ; task_execution_id : String.t option
    ; invocation_id : String.t option
    ; execution_id : String.t option
    ; task_type : MaintenanceWindowTaskType.t option
    ; parameters : String.t option
    ; status : MaintenanceWindowExecutionStatus.t option
    ; status_details : String.t option
    ; start_time : DateTime.t option
    ; end_time : DateTime.t option
    ; owner_information : String.t option
    ; window_target_id : String.t option
    }

  let make
      ?window_execution_id
      ?task_execution_id
      ?invocation_id
      ?execution_id
      ?task_type
      ?parameters
      ?status
      ?status_details
      ?start_time
      ?end_time
      ?owner_information
      ?window_target_id
      () =
    { window_execution_id
    ; task_execution_id
    ; invocation_id
    ; execution_id
    ; task_type
    ; parameters
    ; status
    ; status_details
    ; start_time
    ; end_time
    ; owner_information
    ; window_target_id
    }

  let parse xml =
    Some
      { window_execution_id =
          Aws.Util.option_bind (Aws.Xml.member "WindowExecutionId" xml) String.parse
      ; task_execution_id =
          Aws.Util.option_bind (Aws.Xml.member "TaskExecutionId" xml) String.parse
      ; invocation_id =
          Aws.Util.option_bind (Aws.Xml.member "InvocationId" xml) String.parse
      ; execution_id =
          Aws.Util.option_bind (Aws.Xml.member "ExecutionId" xml) String.parse
      ; task_type =
          Aws.Util.option_bind
            (Aws.Xml.member "TaskType" xml)
            MaintenanceWindowTaskType.parse
      ; parameters = Aws.Util.option_bind (Aws.Xml.member "Parameters" xml) String.parse
      ; status =
          Aws.Util.option_bind
            (Aws.Xml.member "Status" xml)
            MaintenanceWindowExecutionStatus.parse
      ; status_details =
          Aws.Util.option_bind (Aws.Xml.member "StatusDetails" xml) String.parse
      ; start_time = Aws.Util.option_bind (Aws.Xml.member "StartTime" xml) DateTime.parse
      ; end_time = Aws.Util.option_bind (Aws.Xml.member "EndTime" xml) DateTime.parse
      ; owner_information =
          Aws.Util.option_bind (Aws.Xml.member "OwnerInformation" xml) String.parse
      ; window_target_id =
          Aws.Util.option_bind (Aws.Xml.member "WindowTargetId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.window_target_id (fun f ->
               Aws.Query.Pair ("WindowTargetId", String.to_query f))
         ; Aws.Util.option_map v.owner_information (fun f ->
               Aws.Query.Pair ("OwnerInformation", String.to_query f))
         ; Aws.Util.option_map v.end_time (fun f ->
               Aws.Query.Pair ("EndTime", DateTime.to_query f))
         ; Aws.Util.option_map v.start_time (fun f ->
               Aws.Query.Pair ("StartTime", DateTime.to_query f))
         ; Aws.Util.option_map v.status_details (fun f ->
               Aws.Query.Pair ("StatusDetails", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", MaintenanceWindowExecutionStatus.to_query f))
         ; Aws.Util.option_map v.parameters (fun f ->
               Aws.Query.Pair ("Parameters", String.to_query f))
         ; Aws.Util.option_map v.task_type (fun f ->
               Aws.Query.Pair ("TaskType", MaintenanceWindowTaskType.to_query f))
         ; Aws.Util.option_map v.execution_id (fun f ->
               Aws.Query.Pair ("ExecutionId", String.to_query f))
         ; Aws.Util.option_map v.invocation_id (fun f ->
               Aws.Query.Pair ("InvocationId", String.to_query f))
         ; Aws.Util.option_map v.task_execution_id (fun f ->
               Aws.Query.Pair ("TaskExecutionId", String.to_query f))
         ; Aws.Util.option_map v.window_execution_id (fun f ->
               Aws.Query.Pair ("WindowExecutionId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.window_target_id (fun f ->
               "WindowTargetId", String.to_json f)
         ; Aws.Util.option_map v.owner_information (fun f ->
               "OwnerInformation", String.to_json f)
         ; Aws.Util.option_map v.end_time (fun f -> "EndTime", DateTime.to_json f)
         ; Aws.Util.option_map v.start_time (fun f -> "StartTime", DateTime.to_json f)
         ; Aws.Util.option_map v.status_details (fun f ->
               "StatusDetails", String.to_json f)
         ; Aws.Util.option_map v.status (fun f ->
               "Status", MaintenanceWindowExecutionStatus.to_json f)
         ; Aws.Util.option_map v.parameters (fun f -> "Parameters", String.to_json f)
         ; Aws.Util.option_map v.task_type (fun f ->
               "TaskType", MaintenanceWindowTaskType.to_json f)
         ; Aws.Util.option_map v.execution_id (fun f -> "ExecutionId", String.to_json f)
         ; Aws.Util.option_map v.invocation_id (fun f -> "InvocationId", String.to_json f)
         ; Aws.Util.option_map v.task_execution_id (fun f ->
               "TaskExecutionId", String.to_json f)
         ; Aws.Util.option_map v.window_execution_id (fun f ->
               "WindowExecutionId", String.to_json f)
         ])

  let of_json j =
    { window_execution_id =
        Aws.Util.option_map (Aws.Json.lookup j "WindowExecutionId") String.of_json
    ; task_execution_id =
        Aws.Util.option_map (Aws.Json.lookup j "TaskExecutionId") String.of_json
    ; invocation_id =
        Aws.Util.option_map (Aws.Json.lookup j "InvocationId") String.of_json
    ; execution_id = Aws.Util.option_map (Aws.Json.lookup j "ExecutionId") String.of_json
    ; task_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "TaskType")
          MaintenanceWindowTaskType.of_json
    ; parameters = Aws.Util.option_map (Aws.Json.lookup j "Parameters") String.of_json
    ; status =
        Aws.Util.option_map
          (Aws.Json.lookup j "Status")
          MaintenanceWindowExecutionStatus.of_json
    ; status_details =
        Aws.Util.option_map (Aws.Json.lookup j "StatusDetails") String.of_json
    ; start_time = Aws.Util.option_map (Aws.Json.lookup j "StartTime") DateTime.of_json
    ; end_time = Aws.Util.option_map (Aws.Json.lookup j "EndTime") DateTime.of_json
    ; owner_information =
        Aws.Util.option_map (Aws.Json.lookup j "OwnerInformation") String.of_json
    ; window_target_id =
        Aws.Util.option_map (Aws.Json.lookup j "WindowTargetId") String.of_json
    }
end

module AutomationDefinitionNotFoundException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module ResourceDataSyncCountExceededException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module DocumentVersionList = struct
  type t = DocumentVersionInfo.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map DocumentVersionInfo.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list DocumentVersionInfo.to_query v
  let to_json v = `List (List.map DocumentVersionInfo.to_json v)
  let of_json j = Aws.Json.to_list DocumentVersionInfo.of_json j
end

module ListDocumentVersionsResult = struct
  type t =
    { document_versions : DocumentVersionList.t
    ; next_token : String.t option
    }

  let make ?(document_versions = []) ?next_token () = { document_versions; next_token }

  let parse xml =
    Some
      { document_versions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DocumentVersions" xml)
               DocumentVersionList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "DocumentVersions.member"
                , DocumentVersionList.to_query v.document_versions ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("DocumentVersions", DocumentVersionList.to_json v.document_versions)
         ])

  let of_json j =
    { document_versions =
        DocumentVersionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DocumentVersions"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module DescribeInstanceInformationResult = struct
  type t =
    { instance_information_list : InstanceInformationList.t
    ; next_token : String.t option
    }

  let make ?(instance_information_list = []) ?next_token () =
    { instance_information_list; next_token }

  let parse xml =
    Some
      { instance_information_list =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "InstanceInformationList" xml)
               InstanceInformationList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "InstanceInformationList.member"
                , InstanceInformationList.to_query v.instance_information_list ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some
             ( "InstanceInformationList"
             , InstanceInformationList.to_json v.instance_information_list )
         ])

  let of_json j =
    { instance_information_list =
        InstanceInformationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceInformationList"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module DeregisterTaskFromMaintenanceWindowRequest = struct
  type t =
    { window_id : String.t
    ; window_task_id : String.t
    }

  let make ~window_id ~window_task_id () = { window_id; window_task_id }

  let parse xml =
    Some
      { window_id =
          Aws.Xml.required
            "WindowId"
            (Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse)
      ; window_task_id =
          Aws.Xml.required
            "WindowTaskId"
            (Aws.Util.option_bind (Aws.Xml.member "WindowTaskId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("WindowTaskId", String.to_query v.window_task_id))
         ; Some (Aws.Query.Pair ("WindowId", String.to_query v.window_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("WindowTaskId", String.to_json v.window_task_id)
         ; Some ("WindowId", String.to_json v.window_id)
         ])

  let of_json j =
    { window_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowId"))
    ; window_task_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowTaskId"))
    }
end

module DescribePatchGroupStateResult = struct
  type t =
    { instances : Integer.t option
    ; instances_with_installed_patches : Integer.t option
    ; instances_with_installed_other_patches : Integer.t option
    ; instances_with_installed_pending_reboot_patches : Integer.t option
    ; instances_with_installed_rejected_patches : Integer.t option
    ; instances_with_missing_patches : Integer.t option
    ; instances_with_failed_patches : Integer.t option
    ; instances_with_not_applicable_patches : Integer.t option
    ; instances_with_unreported_not_applicable_patches : Integer.t option
    }

  let make
      ?instances
      ?instances_with_installed_patches
      ?instances_with_installed_other_patches
      ?instances_with_installed_pending_reboot_patches
      ?instances_with_installed_rejected_patches
      ?instances_with_missing_patches
      ?instances_with_failed_patches
      ?instances_with_not_applicable_patches
      ?instances_with_unreported_not_applicable_patches
      () =
    { instances
    ; instances_with_installed_patches
    ; instances_with_installed_other_patches
    ; instances_with_installed_pending_reboot_patches
    ; instances_with_installed_rejected_patches
    ; instances_with_missing_patches
    ; instances_with_failed_patches
    ; instances_with_not_applicable_patches
    ; instances_with_unreported_not_applicable_patches
    }

  let parse xml =
    Some
      { instances = Aws.Util.option_bind (Aws.Xml.member "Instances" xml) Integer.parse
      ; instances_with_installed_patches =
          Aws.Util.option_bind
            (Aws.Xml.member "InstancesWithInstalledPatches" xml)
            Integer.parse
      ; instances_with_installed_other_patches =
          Aws.Util.option_bind
            (Aws.Xml.member "InstancesWithInstalledOtherPatches" xml)
            Integer.parse
      ; instances_with_installed_pending_reboot_patches =
          Aws.Util.option_bind
            (Aws.Xml.member "InstancesWithInstalledPendingRebootPatches" xml)
            Integer.parse
      ; instances_with_installed_rejected_patches =
          Aws.Util.option_bind
            (Aws.Xml.member "InstancesWithInstalledRejectedPatches" xml)
            Integer.parse
      ; instances_with_missing_patches =
          Aws.Util.option_bind
            (Aws.Xml.member "InstancesWithMissingPatches" xml)
            Integer.parse
      ; instances_with_failed_patches =
          Aws.Util.option_bind
            (Aws.Xml.member "InstancesWithFailedPatches" xml)
            Integer.parse
      ; instances_with_not_applicable_patches =
          Aws.Util.option_bind
            (Aws.Xml.member "InstancesWithNotApplicablePatches" xml)
            Integer.parse
      ; instances_with_unreported_not_applicable_patches =
          Aws.Util.option_bind
            (Aws.Xml.member "InstancesWithUnreportedNotApplicablePatches" xml)
            Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map
             v.instances_with_unreported_not_applicable_patches
             (fun f ->
               Aws.Query.Pair
                 ("InstancesWithUnreportedNotApplicablePatches", Integer.to_query f))
         ; Aws.Util.option_map v.instances_with_not_applicable_patches (fun f ->
               Aws.Query.Pair ("InstancesWithNotApplicablePatches", Integer.to_query f))
         ; Aws.Util.option_map v.instances_with_failed_patches (fun f ->
               Aws.Query.Pair ("InstancesWithFailedPatches", Integer.to_query f))
         ; Aws.Util.option_map v.instances_with_missing_patches (fun f ->
               Aws.Query.Pair ("InstancesWithMissingPatches", Integer.to_query f))
         ; Aws.Util.option_map v.instances_with_installed_rejected_patches (fun f ->
               Aws.Query.Pair ("InstancesWithInstalledRejectedPatches", Integer.to_query f))
         ; Aws.Util.option_map v.instances_with_installed_pending_reboot_patches (fun f ->
               Aws.Query.Pair
                 ("InstancesWithInstalledPendingRebootPatches", Integer.to_query f))
         ; Aws.Util.option_map v.instances_with_installed_other_patches (fun f ->
               Aws.Query.Pair ("InstancesWithInstalledOtherPatches", Integer.to_query f))
         ; Aws.Util.option_map v.instances_with_installed_patches (fun f ->
               Aws.Query.Pair ("InstancesWithInstalledPatches", Integer.to_query f))
         ; Aws.Util.option_map v.instances (fun f ->
               Aws.Query.Pair ("Instances", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map
             v.instances_with_unreported_not_applicable_patches
             (fun f -> "InstancesWithUnreportedNotApplicablePatches", Integer.to_json f)
         ; Aws.Util.option_map v.instances_with_not_applicable_patches (fun f ->
               "InstancesWithNotApplicablePatches", Integer.to_json f)
         ; Aws.Util.option_map v.instances_with_failed_patches (fun f ->
               "InstancesWithFailedPatches", Integer.to_json f)
         ; Aws.Util.option_map v.instances_with_missing_patches (fun f ->
               "InstancesWithMissingPatches", Integer.to_json f)
         ; Aws.Util.option_map v.instances_with_installed_rejected_patches (fun f ->
               "InstancesWithInstalledRejectedPatches", Integer.to_json f)
         ; Aws.Util.option_map v.instances_with_installed_pending_reboot_patches (fun f ->
               "InstancesWithInstalledPendingRebootPatches", Integer.to_json f)
         ; Aws.Util.option_map v.instances_with_installed_other_patches (fun f ->
               "InstancesWithInstalledOtherPatches", Integer.to_json f)
         ; Aws.Util.option_map v.instances_with_installed_patches (fun f ->
               "InstancesWithInstalledPatches", Integer.to_json f)
         ; Aws.Util.option_map v.instances (fun f -> "Instances", Integer.to_json f)
         ])

  let of_json j =
    { instances = Aws.Util.option_map (Aws.Json.lookup j "Instances") Integer.of_json
    ; instances_with_installed_patches =
        Aws.Util.option_map
          (Aws.Json.lookup j "InstancesWithInstalledPatches")
          Integer.of_json
    ; instances_with_installed_other_patches =
        Aws.Util.option_map
          (Aws.Json.lookup j "InstancesWithInstalledOtherPatches")
          Integer.of_json
    ; instances_with_installed_pending_reboot_patches =
        Aws.Util.option_map
          (Aws.Json.lookup j "InstancesWithInstalledPendingRebootPatches")
          Integer.of_json
    ; instances_with_installed_rejected_patches =
        Aws.Util.option_map
          (Aws.Json.lookup j "InstancesWithInstalledRejectedPatches")
          Integer.of_json
    ; instances_with_missing_patches =
        Aws.Util.option_map
          (Aws.Json.lookup j "InstancesWithMissingPatches")
          Integer.of_json
    ; instances_with_failed_patches =
        Aws.Util.option_map
          (Aws.Json.lookup j "InstancesWithFailedPatches")
          Integer.of_json
    ; instances_with_not_applicable_patches =
        Aws.Util.option_map
          (Aws.Json.lookup j "InstancesWithNotApplicablePatches")
          Integer.of_json
    ; instances_with_unreported_not_applicable_patches =
        Aws.Util.option_map
          (Aws.Json.lookup j "InstancesWithUnreportedNotApplicablePatches")
          Integer.of_json
    }
end

module GetParameterHistoryResult = struct
  type t =
    { parameters : ParameterHistoryList.t
    ; next_token : String.t option
    }

  let make ?(parameters = []) ?next_token () = { parameters; next_token }

  let parse xml =
    Some
      { parameters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Parameters" xml)
               ParameterHistoryList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Parameters.member", ParameterHistoryList.to_query v.parameters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Parameters", ParameterHistoryList.to_json v.parameters)
         ])

  let of_json j =
    { parameters =
        ParameterHistoryList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Parameters"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module GetMaintenanceWindowExecutionResult = struct
  type t =
    { window_execution_id : String.t option
    ; task_ids : MaintenanceWindowExecutionTaskIdList.t
    ; status : MaintenanceWindowExecutionStatus.t option
    ; status_details : String.t option
    ; start_time : DateTime.t option
    ; end_time : DateTime.t option
    }

  let make
      ?window_execution_id
      ?(task_ids = [])
      ?status
      ?status_details
      ?start_time
      ?end_time
      () =
    { window_execution_id; task_ids; status; status_details; start_time; end_time }

  let parse xml =
    Some
      { window_execution_id =
          Aws.Util.option_bind (Aws.Xml.member "WindowExecutionId" xml) String.parse
      ; task_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TaskIds" xml)
               MaintenanceWindowExecutionTaskIdList.parse)
      ; status =
          Aws.Util.option_bind
            (Aws.Xml.member "Status" xml)
            MaintenanceWindowExecutionStatus.parse
      ; status_details =
          Aws.Util.option_bind (Aws.Xml.member "StatusDetails" xml) String.parse
      ; start_time = Aws.Util.option_bind (Aws.Xml.member "StartTime" xml) DateTime.parse
      ; end_time = Aws.Util.option_bind (Aws.Xml.member "EndTime" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.end_time (fun f ->
               Aws.Query.Pair ("EndTime", DateTime.to_query f))
         ; Aws.Util.option_map v.start_time (fun f ->
               Aws.Query.Pair ("StartTime", DateTime.to_query f))
         ; Aws.Util.option_map v.status_details (fun f ->
               Aws.Query.Pair ("StatusDetails", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", MaintenanceWindowExecutionStatus.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TaskIds.member"
                , MaintenanceWindowExecutionTaskIdList.to_query v.task_ids ))
         ; Aws.Util.option_map v.window_execution_id (fun f ->
               Aws.Query.Pair ("WindowExecutionId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.end_time (fun f -> "EndTime", DateTime.to_json f)
         ; Aws.Util.option_map v.start_time (fun f -> "StartTime", DateTime.to_json f)
         ; Aws.Util.option_map v.status_details (fun f ->
               "StatusDetails", String.to_json f)
         ; Aws.Util.option_map v.status (fun f ->
               "Status", MaintenanceWindowExecutionStatus.to_json f)
         ; Some ("TaskIds", MaintenanceWindowExecutionTaskIdList.to_json v.task_ids)
         ; Aws.Util.option_map v.window_execution_id (fun f ->
               "WindowExecutionId", String.to_json f)
         ])

  let of_json j =
    { window_execution_id =
        Aws.Util.option_map (Aws.Json.lookup j "WindowExecutionId") String.of_json
    ; task_ids =
        MaintenanceWindowExecutionTaskIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TaskIds"))
    ; status =
        Aws.Util.option_map
          (Aws.Json.lookup j "Status")
          MaintenanceWindowExecutionStatus.of_json
    ; status_details =
        Aws.Util.option_map (Aws.Json.lookup j "StatusDetails") String.of_json
    ; start_time = Aws.Util.option_map (Aws.Json.lookup j "StartTime") DateTime.of_json
    ; end_time = Aws.Util.option_map (Aws.Json.lookup j "EndTime") DateTime.of_json
    }
end

module MaxDocumentSizeExceeded = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module ListAssociationsRequest = struct
  type t =
    { association_filter_list : AssociationFilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?(association_filter_list = []) ?max_results ?next_token () =
    { association_filter_list; max_results; next_token }

  let parse xml =
    Some
      { association_filter_list =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AssociationFilterList" xml)
               AssociationFilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "AssociationFilterList.member"
                , AssociationFilterList.to_query v.association_filter_list ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some
             ( "AssociationFilterList"
             , AssociationFilterList.to_json v.association_filter_list )
         ])

  let of_json j =
    { association_filter_list =
        AssociationFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AssociationFilterList"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module DescribeMaintenanceWindowScheduleResult = struct
  type t =
    { scheduled_window_executions : ScheduledWindowExecutionList.t
    ; next_token : String.t option
    }

  let make ?(scheduled_window_executions = []) ?next_token () =
    { scheduled_window_executions; next_token }

  let parse xml =
    Some
      { scheduled_window_executions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ScheduledWindowExecutions" xml)
               ScheduledWindowExecutionList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ScheduledWindowExecutions.member"
                , ScheduledWindowExecutionList.to_query v.scheduled_window_executions ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some
             ( "ScheduledWindowExecutions"
             , ScheduledWindowExecutionList.to_json v.scheduled_window_executions )
         ])

  let of_json j =
    { scheduled_window_executions =
        ScheduledWindowExecutionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ScheduledWindowExecutions"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module GetMaintenanceWindowExecutionTaskInvocationRequest = struct
  type t =
    { window_execution_id : String.t
    ; task_id : String.t
    ; invocation_id : String.t
    }

  let make ~window_execution_id ~task_id ~invocation_id () =
    { window_execution_id; task_id; invocation_id }

  let parse xml =
    Some
      { window_execution_id =
          Aws.Xml.required
            "WindowExecutionId"
            (Aws.Util.option_bind (Aws.Xml.member "WindowExecutionId" xml) String.parse)
      ; task_id =
          Aws.Xml.required
            "TaskId"
            (Aws.Util.option_bind (Aws.Xml.member "TaskId" xml) String.parse)
      ; invocation_id =
          Aws.Xml.required
            "InvocationId"
            (Aws.Util.option_bind (Aws.Xml.member "InvocationId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("InvocationId", String.to_query v.invocation_id))
         ; Some (Aws.Query.Pair ("TaskId", String.to_query v.task_id))
         ; Some
             (Aws.Query.Pair ("WindowExecutionId", String.to_query v.window_execution_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("InvocationId", String.to_json v.invocation_id)
         ; Some ("TaskId", String.to_json v.task_id)
         ; Some ("WindowExecutionId", String.to_json v.window_execution_id)
         ])

  let of_json j =
    { window_execution_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "WindowExecutionId"))
    ; task_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TaskId"))
    ; invocation_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InvocationId"))
    }
end

module InvalidOutputFolder = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end

module InvalidAutomationExecutionParametersException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module UpdateMaintenanceWindowTaskResult = struct
  type t =
    { window_id : String.t option
    ; window_task_id : String.t option
    ; targets : Targets.t
    ; task_arn : String.t option
    ; service_role_arn : String.t option
    ; task_parameters : MaintenanceWindowTaskParameters.t option
    ; task_invocation_parameters : MaintenanceWindowTaskInvocationParameters.t option
    ; priority : Integer.t option
    ; max_concurrency : String.t option
    ; max_errors : String.t option
    ; logging_info : LoggingInfo.t option
    ; name : String.t option
    ; description : String.t option
    }

  let make
      ?window_id
      ?window_task_id
      ?(targets = [])
      ?task_arn
      ?service_role_arn
      ?task_parameters
      ?task_invocation_parameters
      ?priority
      ?max_concurrency
      ?max_errors
      ?logging_info
      ?name
      ?description
      () =
    { window_id
    ; window_task_id
    ; targets
    ; task_arn
    ; service_role_arn
    ; task_parameters
    ; task_invocation_parameters
    ; priority
    ; max_concurrency
    ; max_errors
    ; logging_info
    ; name
    ; description
    }

  let parse xml =
    Some
      { window_id = Aws.Util.option_bind (Aws.Xml.member "WindowId" xml) String.parse
      ; window_task_id =
          Aws.Util.option_bind (Aws.Xml.member "WindowTaskId" xml) String.parse
      ; targets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Targets" xml) Targets.parse)
      ; task_arn = Aws.Util.option_bind (Aws.Xml.member "TaskArn" xml) String.parse
      ; service_role_arn =
          Aws.Util.option_bind (Aws.Xml.member "ServiceRoleArn" xml) String.parse
      ; task_parameters =
          Aws.Util.option_bind
            (Aws.Xml.member "TaskParameters" xml)
            MaintenanceWindowTaskParameters.parse
      ; task_invocation_parameters =
          Aws.Util.option_bind
            (Aws.Xml.member "TaskInvocationParameters" xml)
            MaintenanceWindowTaskInvocationParameters.parse
      ; priority = Aws.Util.option_bind (Aws.Xml.member "Priority" xml) Integer.parse
      ; max_concurrency =
          Aws.Util.option_bind (Aws.Xml.member "MaxConcurrency" xml) String.parse
      ; max_errors = Aws.Util.option_bind (Aws.Xml.member "MaxErrors" xml) String.parse
      ; logging_info =
          Aws.Util.option_bind (Aws.Xml.member "LoggingInfo" xml) LoggingInfo.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.logging_info (fun f ->
               Aws.Query.Pair ("LoggingInfo", LoggingInfo.to_query f))
         ; Aws.Util.option_map v.max_errors (fun f ->
               Aws.Query.Pair ("MaxErrors", String.to_query f))
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               Aws.Query.Pair ("MaxConcurrency", String.to_query f))
         ; Aws.Util.option_map v.priority (fun f ->
               Aws.Query.Pair ("Priority", Integer.to_query f))
         ; Aws.Util.option_map v.task_invocation_parameters (fun f ->
               Aws.Query.Pair
                 ( "TaskInvocationParameters"
                 , MaintenanceWindowTaskInvocationParameters.to_query f ))
         ; Aws.Util.option_map v.task_parameters (fun f ->
               Aws.Query.Pair
                 ("TaskParameters", MaintenanceWindowTaskParameters.to_query f))
         ; Aws.Util.option_map v.service_role_arn (fun f ->
               Aws.Query.Pair ("ServiceRoleArn", String.to_query f))
         ; Aws.Util.option_map v.task_arn (fun f ->
               Aws.Query.Pair ("TaskArn", String.to_query f))
         ; Some (Aws.Query.Pair ("Targets.member", Targets.to_query v.targets))
         ; Aws.Util.option_map v.window_task_id (fun f ->
               Aws.Query.Pair ("WindowTaskId", String.to_query f))
         ; Aws.Util.option_map v.window_id (fun f ->
               Aws.Query.Pair ("WindowId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.logging_info (fun f ->
               "LoggingInfo", LoggingInfo.to_json f)
         ; Aws.Util.option_map v.max_errors (fun f -> "MaxErrors", String.to_json f)
         ; Aws.Util.option_map v.max_concurrency (fun f ->
               "MaxConcurrency", String.to_json f)
         ; Aws.Util.option_map v.priority (fun f -> "Priority", Integer.to_json f)
         ; Aws.Util.option_map v.task_invocation_parameters (fun f ->
               ( "TaskInvocationParameters"
               , MaintenanceWindowTaskInvocationParameters.to_json f ))
         ; Aws.Util.option_map v.task_parameters (fun f ->
               "TaskParameters", MaintenanceWindowTaskParameters.to_json f)
         ; Aws.Util.option_map v.service_role_arn (fun f ->
               "ServiceRoleArn", String.to_json f)
         ; Aws.Util.option_map v.task_arn (fun f -> "TaskArn", String.to_json f)
         ; Some ("Targets", Targets.to_json v.targets)
         ; Aws.Util.option_map v.window_task_id (fun f ->
               "WindowTaskId", String.to_json f)
         ; Aws.Util.option_map v.window_id (fun f -> "WindowId", String.to_json f)
         ])

  let of_json j =
    { window_id = Aws.Util.option_map (Aws.Json.lookup j "WindowId") String.of_json
    ; window_task_id =
        Aws.Util.option_map (Aws.Json.lookup j "WindowTaskId") String.of_json
    ; targets = Targets.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Targets"))
    ; task_arn = Aws.Util.option_map (Aws.Json.lookup j "TaskArn") String.of_json
    ; service_role_arn =
        Aws.Util.option_map (Aws.Json.lookup j "ServiceRoleArn") String.of_json
    ; task_parameters =
        Aws.Util.option_map
          (Aws.Json.lookup j "TaskParameters")
          MaintenanceWindowTaskParameters.of_json
    ; task_invocation_parameters =
        Aws.Util.option_map
          (Aws.Json.lookup j "TaskInvocationParameters")
          MaintenanceWindowTaskInvocationParameters.of_json
    ; priority = Aws.Util.option_map (Aws.Json.lookup j "Priority") Integer.of_json
    ; max_concurrency =
        Aws.Util.option_map (Aws.Json.lookup j "MaxConcurrency") String.of_json
    ; max_errors = Aws.Util.option_map (Aws.Json.lookup j "MaxErrors") String.of_json
    ; logging_info =
        Aws.Util.option_map (Aws.Json.lookup j "LoggingInfo") LoggingInfo.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    }
end

module TargetInUseException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module InvalidDeletionIdException = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module DescribePatchBaselinesResult = struct
  type t =
    { baseline_identities : PatchBaselineIdentityList.t
    ; next_token : String.t option
    }

  let make ?(baseline_identities = []) ?next_token () =
    { baseline_identities; next_token }

  let parse xml =
    Some
      { baseline_identities =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "BaselineIdentities" xml)
               PatchBaselineIdentityList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "BaselineIdentities.member"
                , PatchBaselineIdentityList.to_query v.baseline_identities ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some
             ( "BaselineIdentities"
             , PatchBaselineIdentityList.to_json v.baseline_identities )
         ])

  let of_json j =
    { baseline_identities =
        PatchBaselineIdentityList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "BaselineIdentities"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module DescribeParametersResult = struct
  type t =
    { parameters : ParameterMetadataList.t
    ; next_token : String.t option
    }

  let make ?(parameters = []) ?next_token () = { parameters; next_token }

  let parse xml =
    Some
      { parameters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Parameters" xml)
               ParameterMetadataList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Parameters.member", ParameterMetadataList.to_query v.parameters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Parameters", ParameterMetadataList.to_json v.parameters)
         ])

  let of_json j =
    { parameters =
        ParameterMetadataList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Parameters"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module GetParameterResult = struct
  type t = { parameter : Parameter.t option }

  let make ?parameter () = { parameter }

  let parse xml =
    Some
      { parameter = Aws.Util.option_bind (Aws.Xml.member "Parameter" xml) Parameter.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.parameter (fun f ->
               Aws.Query.Pair ("Parameter", Parameter.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.parameter (fun f -> "Parameter", Parameter.to_json f) ])

  let of_json j =
    { parameter = Aws.Util.option_map (Aws.Json.lookup j "Parameter") Parameter.of_json }
end

module ListComplianceSummariesRequest = struct
  type t =
    { filters : ComplianceStringFilterList.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    }

  let make ?(filters = []) ?next_token ?max_results () =
    { filters; next_token; max_results }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Filters" xml)
               ComplianceStringFilterList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Filters.member", ComplianceStringFilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Filters", ComplianceStringFilterList.to_json v.filters)
         ])

  let of_json j =
    { filters =
        ComplianceStringFilterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module PutComplianceItemsResult = struct
  type t = unit

  let make () = ()
  let parse xml = Some ()
  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])
  let to_json v = `Assoc (Aws.Util.list_filter_opt [])
  let of_json j = ()
end
