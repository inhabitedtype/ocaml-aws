open Aws.BaseTypes

type calendar = CalendarLib.Calendar.t

module IPRange = struct
  type t =
    { status : String.t option
    ; c_i_d_r_i_p : String.t option
    }

  let make ?status ?c_i_d_r_i_p () = { status; c_i_d_r_i_p }

  let parse xml =
    Some
      { status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      ; c_i_d_r_i_p = Aws.Util.option_bind (Aws.Xml.member "CIDRIP" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.c_i_d_r_i_p (fun f ->
               Aws.Query.Pair ("CIDRIP", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.c_i_d_r_i_p (fun f -> "CIDRIP", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ])

  let of_json j =
    { status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    ; c_i_d_r_i_p = Aws.Util.option_map (Aws.Json.lookup j "CIDRIP") String.of_json
    }
end

module IPRangeList = struct
  type t = IPRange.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map IPRange.parse (Aws.Xml.members "IPRange" xml))

  let to_query v = Aws.Query.to_query_list IPRange.to_query v

  let to_json v = `List (List.map IPRange.to_json v)

  let of_json j = Aws.Json.to_list IPRange.of_json j
end

module EC2SecurityGroup = struct
  type t =
    { status : String.t option
    ; e_c2_security_group_name : String.t option
    ; e_c2_security_group_id : String.t option
    ; e_c2_security_group_owner_id : String.t option
    }

  let make
      ?status
      ?e_c2_security_group_name
      ?e_c2_security_group_id
      ?e_c2_security_group_owner_id
      () =
    { status
    ; e_c2_security_group_name
    ; e_c2_security_group_id
    ; e_c2_security_group_owner_id
    }

  let parse xml =
    Some
      { status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      ; e_c2_security_group_name =
          Aws.Util.option_bind (Aws.Xml.member "EC2SecurityGroupName" xml) String.parse
      ; e_c2_security_group_id =
          Aws.Util.option_bind (Aws.Xml.member "EC2SecurityGroupId" xml) String.parse
      ; e_c2_security_group_owner_id =
          Aws.Util.option_bind (Aws.Xml.member "EC2SecurityGroupOwnerId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.e_c2_security_group_owner_id (fun f ->
               Aws.Query.Pair ("EC2SecurityGroupOwnerId", String.to_query f))
         ; Aws.Util.option_map v.e_c2_security_group_id (fun f ->
               Aws.Query.Pair ("EC2SecurityGroupId", String.to_query f))
         ; Aws.Util.option_map v.e_c2_security_group_name (fun f ->
               Aws.Query.Pair ("EC2SecurityGroupName", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.e_c2_security_group_owner_id (fun f ->
               "EC2SecurityGroupOwnerId", String.to_json f)
         ; Aws.Util.option_map v.e_c2_security_group_id (fun f ->
               "EC2SecurityGroupId", String.to_json f)
         ; Aws.Util.option_map v.e_c2_security_group_name (fun f ->
               "EC2SecurityGroupName", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ])

  let of_json j =
    { status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    ; e_c2_security_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "EC2SecurityGroupName") String.of_json
    ; e_c2_security_group_id =
        Aws.Util.option_map (Aws.Json.lookup j "EC2SecurityGroupId") String.of_json
    ; e_c2_security_group_owner_id =
        Aws.Util.option_map (Aws.Json.lookup j "EC2SecurityGroupOwnerId") String.of_json
    }
end

module EC2SecurityGroupList = struct
  type t = EC2SecurityGroup.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map EC2SecurityGroup.parse (Aws.Xml.members "EC2SecurityGroup" xml))

  let to_query v = Aws.Query.to_query_list EC2SecurityGroup.to_query v

  let to_json v = `List (List.map EC2SecurityGroup.to_json v)

  let of_json j = Aws.Json.to_list EC2SecurityGroup.of_json j
end

module DBSecurityGroup = struct
  type t =
    { owner_id : String.t option
    ; d_b_security_group_name : String.t option
    ; d_b_security_group_description : String.t option
    ; vpc_id : String.t option
    ; e_c2_security_groups : EC2SecurityGroupList.t
    ; i_p_ranges : IPRangeList.t
    ; d_b_security_group_arn : String.t option
    }

  let make
      ?owner_id
      ?d_b_security_group_name
      ?d_b_security_group_description
      ?vpc_id
      ?(e_c2_security_groups = [])
      ?(i_p_ranges = [])
      ?d_b_security_group_arn
      () =
    { owner_id
    ; d_b_security_group_name
    ; d_b_security_group_description
    ; vpc_id
    ; e_c2_security_groups
    ; i_p_ranges
    ; d_b_security_group_arn
    }

  let parse xml =
    Some
      { owner_id = Aws.Util.option_bind (Aws.Xml.member "OwnerId" xml) String.parse
      ; d_b_security_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBSecurityGroupName" xml) String.parse
      ; d_b_security_group_description =
          Aws.Util.option_bind
            (Aws.Xml.member "DBSecurityGroupDescription" xml)
            String.parse
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) String.parse
      ; e_c2_security_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "EC2SecurityGroups" xml)
               EC2SecurityGroupList.parse)
      ; i_p_ranges =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "IPRanges" xml) IPRangeList.parse)
      ; d_b_security_group_arn =
          Aws.Util.option_bind (Aws.Xml.member "DBSecurityGroupArn" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_security_group_arn (fun f ->
               Aws.Query.Pair ("DBSecurityGroupArn", String.to_query f))
         ; Some (Aws.Query.Pair ("IPRanges.member", IPRangeList.to_query v.i_p_ranges))
         ; Some
             (Aws.Query.Pair
                ( "EC2SecurityGroups.member"
                , EC2SecurityGroupList.to_query v.e_c2_security_groups ))
         ; Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Aws.Util.option_map v.d_b_security_group_description (fun f ->
               Aws.Query.Pair ("DBSecurityGroupDescription", String.to_query f))
         ; Aws.Util.option_map v.d_b_security_group_name (fun f ->
               Aws.Query.Pair ("DBSecurityGroupName", String.to_query f))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_security_group_arn (fun f ->
               "DBSecurityGroupArn", String.to_json f)
         ; Some ("IPRanges", IPRangeList.to_json v.i_p_ranges)
         ; Some ("EC2SecurityGroups", EC2SecurityGroupList.to_json v.e_c2_security_groups)
         ; Aws.Util.option_map v.vpc_id (fun f -> "VpcId", String.to_json f)
         ; Aws.Util.option_map v.d_b_security_group_description (fun f ->
               "DBSecurityGroupDescription", String.to_json f)
         ; Aws.Util.option_map v.d_b_security_group_name (fun f ->
               "DBSecurityGroupName", String.to_json f)
         ; Aws.Util.option_map v.owner_id (fun f -> "OwnerId", String.to_json f)
         ])

  let of_json j =
    { owner_id = Aws.Util.option_map (Aws.Json.lookup j "OwnerId") String.of_json
    ; d_b_security_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBSecurityGroupName") String.of_json
    ; d_b_security_group_description =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBSecurityGroupDescription")
          String.of_json
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "VpcId") String.of_json
    ; e_c2_security_groups =
        EC2SecurityGroupList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "EC2SecurityGroups"))
    ; i_p_ranges =
        IPRangeList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "IPRanges"))
    ; d_b_security_group_arn =
        Aws.Util.option_map (Aws.Json.lookup j "DBSecurityGroupArn") String.of_json
    }
end

module DBSecurityGroups = struct
  type t = DBSecurityGroup.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map DBSecurityGroup.parse (Aws.Xml.members "DBSecurityGroup" xml))

  let to_query v = Aws.Query.to_query_list DBSecurityGroup.to_query v

  let to_json v = `List (List.map DBSecurityGroup.to_json v)

  let of_json j = Aws.Json.to_list DBSecurityGroup.of_json j
end

module DBSecurityGroupMessage = struct
  type t =
    { marker : String.t option
    ; d_b_security_groups : DBSecurityGroups.t
    }

  let make ?marker ?(d_b_security_groups = []) () = { marker; d_b_security_groups }

  let parse xml =
    Some
      { marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; d_b_security_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DBSecurityGroups" xml)
               DBSecurityGroups.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "DBSecurityGroups.member"
                , DBSecurityGroups.to_query v.d_b_security_groups ))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("DBSecurityGroups", DBSecurityGroups.to_json v.d_b_security_groups)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ])

  let of_json j =
    { marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; d_b_security_groups =
        DBSecurityGroups.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBSecurityGroups"))
    }
end

module VpcSecurityGroupIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "VpcSecurityGroupId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module IAMAuthMode = struct
  type t =
    | DISABLED
    | REQUIRED

  let str_to_t = [ "REQUIRED", REQUIRED; "DISABLED", DISABLED ]

  let t_to_str = [ REQUIRED, "REQUIRED"; DISABLED, "DISABLED" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module AuthScheme = struct
  type t = SECRETS

  let str_to_t = [ "SECRETS", SECRETS ]

  let t_to_str = [ SECRETS, "SECRETS" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module UserAuthConfig = struct
  type t =
    { description : String.t option
    ; user_name : String.t option
    ; auth_scheme : AuthScheme.t option
    ; secret_arn : String.t option
    ; i_a_m_auth : IAMAuthMode.t option
    }

  let make ?description ?user_name ?auth_scheme ?secret_arn ?i_a_m_auth () =
    { description; user_name; auth_scheme; secret_arn; i_a_m_auth }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; user_name = Aws.Util.option_bind (Aws.Xml.member "UserName" xml) String.parse
      ; auth_scheme =
          Aws.Util.option_bind (Aws.Xml.member "AuthScheme" xml) AuthScheme.parse
      ; secret_arn = Aws.Util.option_bind (Aws.Xml.member "SecretArn" xml) String.parse
      ; i_a_m_auth = Aws.Util.option_bind (Aws.Xml.member "IAMAuth" xml) IAMAuthMode.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.i_a_m_auth (fun f ->
               Aws.Query.Pair ("IAMAuth", IAMAuthMode.to_query f))
         ; Aws.Util.option_map v.secret_arn (fun f ->
               Aws.Query.Pair ("SecretArn", String.to_query f))
         ; Aws.Util.option_map v.auth_scheme (fun f ->
               Aws.Query.Pair ("AuthScheme", AuthScheme.to_query f))
         ; Aws.Util.option_map v.user_name (fun f ->
               Aws.Query.Pair ("UserName", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.i_a_m_auth (fun f -> "IAMAuth", IAMAuthMode.to_json f)
         ; Aws.Util.option_map v.secret_arn (fun f -> "SecretArn", String.to_json f)
         ; Aws.Util.option_map v.auth_scheme (fun f -> "AuthScheme", AuthScheme.to_json f)
         ; Aws.Util.option_map v.user_name (fun f -> "UserName", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; user_name = Aws.Util.option_map (Aws.Json.lookup j "UserName") String.of_json
    ; auth_scheme =
        Aws.Util.option_map (Aws.Json.lookup j "AuthScheme") AuthScheme.of_json
    ; secret_arn = Aws.Util.option_map (Aws.Json.lookup j "SecretArn") String.of_json
    ; i_a_m_auth = Aws.Util.option_map (Aws.Json.lookup j "IAMAuth") IAMAuthMode.of_json
    }
end

module RemoveSourceIdentifierFromSubscriptionMessage = struct
  type t =
    { subscription_name : String.t
    ; source_identifier : String.t
    }

  let make ~subscription_name ~source_identifier () =
    { subscription_name; source_identifier }

  let parse xml =
    Some
      { subscription_name =
          Aws.Xml.required
            "SubscriptionName"
            (Aws.Util.option_bind (Aws.Xml.member "SubscriptionName" xml) String.parse)
      ; source_identifier =
          Aws.Xml.required
            "SourceIdentifier"
            (Aws.Util.option_bind (Aws.Xml.member "SourceIdentifier" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("SourceIdentifier", String.to_query v.source_identifier))
         ; Some (Aws.Query.Pair ("SubscriptionName", String.to_query v.subscription_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("SourceIdentifier", String.to_json v.source_identifier)
         ; Some ("SubscriptionName", String.to_json v.subscription_name)
         ])

  let of_json j =
    { subscription_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SubscriptionName"))
    ; source_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceIdentifier"))
    }
end

module VpnDetails = struct
  type t =
    { vpn_id : String.t option
    ; vpn_tunnel_originator_i_p : String.t option
    ; vpn_gateway_ip : String.t option
    ; vpn_p_s_k : String.t option
    ; vpn_name : String.t option
    ; vpn_state : String.t option
    }

  let make
      ?vpn_id
      ?vpn_tunnel_originator_i_p
      ?vpn_gateway_ip
      ?vpn_p_s_k
      ?vpn_name
      ?vpn_state
      () =
    { vpn_id; vpn_tunnel_originator_i_p; vpn_gateway_ip; vpn_p_s_k; vpn_name; vpn_state }

  let parse xml =
    Some
      { vpn_id = Aws.Util.option_bind (Aws.Xml.member "VpnId" xml) String.parse
      ; vpn_tunnel_originator_i_p =
          Aws.Util.option_bind (Aws.Xml.member "VpnTunnelOriginatorIP" xml) String.parse
      ; vpn_gateway_ip =
          Aws.Util.option_bind (Aws.Xml.member "VpnGatewayIp" xml) String.parse
      ; vpn_p_s_k = Aws.Util.option_bind (Aws.Xml.member "VpnPSK" xml) String.parse
      ; vpn_name = Aws.Util.option_bind (Aws.Xml.member "VpnName" xml) String.parse
      ; vpn_state = Aws.Util.option_bind (Aws.Xml.member "VpnState" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpn_state (fun f ->
               Aws.Query.Pair ("VpnState", String.to_query f))
         ; Aws.Util.option_map v.vpn_name (fun f ->
               Aws.Query.Pair ("VpnName", String.to_query f))
         ; Aws.Util.option_map v.vpn_p_s_k (fun f ->
               Aws.Query.Pair ("VpnPSK", String.to_query f))
         ; Aws.Util.option_map v.vpn_gateway_ip (fun f ->
               Aws.Query.Pair ("VpnGatewayIp", String.to_query f))
         ; Aws.Util.option_map v.vpn_tunnel_originator_i_p (fun f ->
               Aws.Query.Pair ("VpnTunnelOriginatorIP", String.to_query f))
         ; Aws.Util.option_map v.vpn_id (fun f ->
               Aws.Query.Pair ("VpnId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpn_state (fun f -> "VpnState", String.to_json f)
         ; Aws.Util.option_map v.vpn_name (fun f -> "VpnName", String.to_json f)
         ; Aws.Util.option_map v.vpn_p_s_k (fun f -> "VpnPSK", String.to_json f)
         ; Aws.Util.option_map v.vpn_gateway_ip (fun f ->
               "VpnGatewayIp", String.to_json f)
         ; Aws.Util.option_map v.vpn_tunnel_originator_i_p (fun f ->
               "VpnTunnelOriginatorIP", String.to_json f)
         ; Aws.Util.option_map v.vpn_id (fun f -> "VpnId", String.to_json f)
         ])

  let of_json j =
    { vpn_id = Aws.Util.option_map (Aws.Json.lookup j "VpnId") String.of_json
    ; vpn_tunnel_originator_i_p =
        Aws.Util.option_map (Aws.Json.lookup j "VpnTunnelOriginatorIP") String.of_json
    ; vpn_gateway_ip =
        Aws.Util.option_map (Aws.Json.lookup j "VpnGatewayIp") String.of_json
    ; vpn_p_s_k = Aws.Util.option_map (Aws.Json.lookup j "VpnPSK") String.of_json
    ; vpn_name = Aws.Util.option_map (Aws.Json.lookup j "VpnName") String.of_json
    ; vpn_state = Aws.Util.option_map (Aws.Json.lookup j "VpnState") String.of_json
    }
end

module CustomAvailabilityZone = struct
  type t =
    { custom_availability_zone_id : String.t option
    ; custom_availability_zone_name : String.t option
    ; custom_availability_zone_status : String.t option
    ; vpn_details : VpnDetails.t option
    }

  let make
      ?custom_availability_zone_id
      ?custom_availability_zone_name
      ?custom_availability_zone_status
      ?vpn_details
      () =
    { custom_availability_zone_id
    ; custom_availability_zone_name
    ; custom_availability_zone_status
    ; vpn_details
    }

  let parse xml =
    Some
      { custom_availability_zone_id =
          Aws.Util.option_bind
            (Aws.Xml.member "CustomAvailabilityZoneId" xml)
            String.parse
      ; custom_availability_zone_name =
          Aws.Util.option_bind
            (Aws.Xml.member "CustomAvailabilityZoneName" xml)
            String.parse
      ; custom_availability_zone_status =
          Aws.Util.option_bind
            (Aws.Xml.member "CustomAvailabilityZoneStatus" xml)
            String.parse
      ; vpn_details =
          Aws.Util.option_bind (Aws.Xml.member "VpnDetails" xml) VpnDetails.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpn_details (fun f ->
               Aws.Query.Pair ("VpnDetails", VpnDetails.to_query f))
         ; Aws.Util.option_map v.custom_availability_zone_status (fun f ->
               Aws.Query.Pair ("CustomAvailabilityZoneStatus", String.to_query f))
         ; Aws.Util.option_map v.custom_availability_zone_name (fun f ->
               Aws.Query.Pair ("CustomAvailabilityZoneName", String.to_query f))
         ; Aws.Util.option_map v.custom_availability_zone_id (fun f ->
               Aws.Query.Pair ("CustomAvailabilityZoneId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpn_details (fun f -> "VpnDetails", VpnDetails.to_json f)
         ; Aws.Util.option_map v.custom_availability_zone_status (fun f ->
               "CustomAvailabilityZoneStatus", String.to_json f)
         ; Aws.Util.option_map v.custom_availability_zone_name (fun f ->
               "CustomAvailabilityZoneName", String.to_json f)
         ; Aws.Util.option_map v.custom_availability_zone_id (fun f ->
               "CustomAvailabilityZoneId", String.to_json f)
         ])

  let of_json j =
    { custom_availability_zone_id =
        Aws.Util.option_map (Aws.Json.lookup j "CustomAvailabilityZoneId") String.of_json
    ; custom_availability_zone_name =
        Aws.Util.option_map
          (Aws.Json.lookup j "CustomAvailabilityZoneName")
          String.of_json
    ; custom_availability_zone_status =
        Aws.Util.option_map
          (Aws.Json.lookup j "CustomAvailabilityZoneStatus")
          String.of_json
    ; vpn_details =
        Aws.Util.option_map (Aws.Json.lookup j "VpnDetails") VpnDetails.of_json
    }
end

module DoubleRange = struct
  type t =
    { from : Double.t option
    ; to_ : Double.t option
    }

  let make ?from ?to_ () = { from; to_ }

  let parse xml =
    Some
      { from = Aws.Util.option_bind (Aws.Xml.member "From" xml) Double.parse
      ; to_ = Aws.Util.option_bind (Aws.Xml.member "To" xml) Double.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.to_ (fun f -> Aws.Query.Pair ("To", Double.to_query f))
         ; Aws.Util.option_map v.from (fun f ->
               Aws.Query.Pair ("From", Double.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.to_ (fun f -> "To", Double.to_json f)
         ; Aws.Util.option_map v.from (fun f -> "From", Double.to_json f)
         ])

  let of_json j =
    { from = Aws.Util.option_map (Aws.Json.lookup j "From") Double.of_json
    ; to_ = Aws.Util.option_map (Aws.Json.lookup j "To") Double.of_json
    }
end

module StringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DBClusterEndpoint = struct
  type t =
    { d_b_cluster_endpoint_identifier : String.t option
    ; d_b_cluster_identifier : String.t option
    ; d_b_cluster_endpoint_resource_identifier : String.t option
    ; endpoint : String.t option
    ; status : String.t option
    ; endpoint_type : String.t option
    ; custom_endpoint_type : String.t option
    ; static_members : StringList.t
    ; excluded_members : StringList.t
    ; d_b_cluster_endpoint_arn : String.t option
    }

  let make
      ?d_b_cluster_endpoint_identifier
      ?d_b_cluster_identifier
      ?d_b_cluster_endpoint_resource_identifier
      ?endpoint
      ?status
      ?endpoint_type
      ?custom_endpoint_type
      ?(static_members = [])
      ?(excluded_members = [])
      ?d_b_cluster_endpoint_arn
      () =
    { d_b_cluster_endpoint_identifier
    ; d_b_cluster_identifier
    ; d_b_cluster_endpoint_resource_identifier
    ; endpoint
    ; status
    ; endpoint_type
    ; custom_endpoint_type
    ; static_members
    ; excluded_members
    ; d_b_cluster_endpoint_arn
    }

  let parse xml =
    Some
      { d_b_cluster_endpoint_identifier =
          Aws.Util.option_bind
            (Aws.Xml.member "DBClusterEndpointIdentifier" xml)
            String.parse
      ; d_b_cluster_identifier =
          Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse
      ; d_b_cluster_endpoint_resource_identifier =
          Aws.Util.option_bind
            (Aws.Xml.member "DBClusterEndpointResourceIdentifier" xml)
            String.parse
      ; endpoint = Aws.Util.option_bind (Aws.Xml.member "Endpoint" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      ; endpoint_type =
          Aws.Util.option_bind (Aws.Xml.member "EndpointType" xml) String.parse
      ; custom_endpoint_type =
          Aws.Util.option_bind (Aws.Xml.member "CustomEndpointType" xml) String.parse
      ; static_members =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "StaticMembers" xml) StringList.parse)
      ; excluded_members =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "ExcludedMembers" xml) StringList.parse)
      ; d_b_cluster_endpoint_arn =
          Aws.Util.option_bind (Aws.Xml.member "DBClusterEndpointArn" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster_endpoint_arn (fun f ->
               Aws.Query.Pair ("DBClusterEndpointArn", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ExcludedMembers.member", StringList.to_query v.excluded_members))
         ; Some
             (Aws.Query.Pair ("StaticMembers.member", StringList.to_query v.static_members))
         ; Aws.Util.option_map v.custom_endpoint_type (fun f ->
               Aws.Query.Pair ("CustomEndpointType", String.to_query f))
         ; Aws.Util.option_map v.endpoint_type (fun f ->
               Aws.Query.Pair ("EndpointType", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.endpoint (fun f ->
               Aws.Query.Pair ("Endpoint", String.to_query f))
         ; Aws.Util.option_map v.d_b_cluster_endpoint_resource_identifier (fun f ->
               Aws.Query.Pair ("DBClusterEndpointResourceIdentifier", String.to_query f))
         ; Aws.Util.option_map v.d_b_cluster_identifier (fun f ->
               Aws.Query.Pair ("DBClusterIdentifier", String.to_query f))
         ; Aws.Util.option_map v.d_b_cluster_endpoint_identifier (fun f ->
               Aws.Query.Pair ("DBClusterEndpointIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster_endpoint_arn (fun f ->
               "DBClusterEndpointArn", String.to_json f)
         ; Some ("ExcludedMembers", StringList.to_json v.excluded_members)
         ; Some ("StaticMembers", StringList.to_json v.static_members)
         ; Aws.Util.option_map v.custom_endpoint_type (fun f ->
               "CustomEndpointType", String.to_json f)
         ; Aws.Util.option_map v.endpoint_type (fun f -> "EndpointType", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ; Aws.Util.option_map v.endpoint (fun f -> "Endpoint", String.to_json f)
         ; Aws.Util.option_map v.d_b_cluster_endpoint_resource_identifier (fun f ->
               "DBClusterEndpointResourceIdentifier", String.to_json f)
         ; Aws.Util.option_map v.d_b_cluster_identifier (fun f ->
               "DBClusterIdentifier", String.to_json f)
         ; Aws.Util.option_map v.d_b_cluster_endpoint_identifier (fun f ->
               "DBClusterEndpointIdentifier", String.to_json f)
         ])

  let of_json j =
    { d_b_cluster_endpoint_identifier =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBClusterEndpointIdentifier")
          String.of_json
    ; d_b_cluster_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "DBClusterIdentifier") String.of_json
    ; d_b_cluster_endpoint_resource_identifier =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBClusterEndpointResourceIdentifier")
          String.of_json
    ; endpoint = Aws.Util.option_map (Aws.Json.lookup j "Endpoint") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    ; endpoint_type =
        Aws.Util.option_map (Aws.Json.lookup j "EndpointType") String.of_json
    ; custom_endpoint_type =
        Aws.Util.option_map (Aws.Json.lookup j "CustomEndpointType") String.of_json
    ; static_members =
        StringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "StaticMembers"))
    ; excluded_members =
        StringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ExcludedMembers"))
    ; d_b_cluster_endpoint_arn =
        Aws.Util.option_map (Aws.Json.lookup j "DBClusterEndpointArn") String.of_json
    }
end

module WriteForwardingStatus = struct
  type t =
    | Enabled
    | Disabled
    | Enabling
    | Disabling
    | Unknown

  let str_to_t =
    [ "unknown", Unknown
    ; "disabling", Disabling
    ; "enabling", Enabling
    ; "disabled", Disabled
    ; "enabled", Enabled
    ]

  let t_to_str =
    [ Unknown, "unknown"
    ; Disabling, "disabling"
    ; Enabling, "enabling"
    ; Disabled, "disabled"
    ; Enabled, "enabled"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module VpcSecurityGroupMembership = struct
  type t =
    { vpc_security_group_id : String.t option
    ; status : String.t option
    }

  let make ?vpc_security_group_id ?status () = { vpc_security_group_id; status }

  let parse xml =
    Some
      { vpc_security_group_id =
          Aws.Util.option_bind (Aws.Xml.member "VpcSecurityGroupId" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.vpc_security_group_id (fun f ->
               Aws.Query.Pair ("VpcSecurityGroupId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ; Aws.Util.option_map v.vpc_security_group_id (fun f ->
               "VpcSecurityGroupId", String.to_json f)
         ])

  let of_json j =
    { vpc_security_group_id =
        Aws.Util.option_map (Aws.Json.lookup j "VpcSecurityGroupId") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    }
end

module VpcSecurityGroupMembershipList = struct
  type t = VpcSecurityGroupMembership.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         VpcSecurityGroupMembership.parse
         (Aws.Xml.members "VpcSecurityGroupMembership" xml))

  let to_query v = Aws.Query.to_query_list VpcSecurityGroupMembership.to_query v

  let to_json v = `List (List.map VpcSecurityGroupMembership.to_json v)

  let of_json j = Aws.Json.to_list VpcSecurityGroupMembership.of_json j
end

module Tag = struct
  type t =
    { key : String.t option
    ; value : String.t option
    }

  let make ?key ?value () = { key; value }

  let parse xml =
    Some
      { key = Aws.Util.option_bind (Aws.Xml.member "Key" xml) String.parse
      ; value = Aws.Util.option_bind (Aws.Xml.member "Value" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", String.to_query f))
         ; Aws.Util.option_map v.key (fun f -> Aws.Query.Pair ("Key", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f -> "Value", String.to_json f)
         ; Aws.Util.option_map v.key (fun f -> "Key", String.to_json f)
         ])

  let of_json j =
    { key = Aws.Util.option_map (Aws.Json.lookup j "Key") String.of_json
    ; value = Aws.Util.option_map (Aws.Json.lookup j "Value") String.of_json
    }
end

module TagList = struct
  type t = Tag.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map Tag.parse (Aws.Xml.members "Tag" xml))

  let to_query v = Aws.Query.to_query_list Tag.to_query v

  let to_json v = `List (List.map Tag.to_json v)

  let of_json j = Aws.Json.to_list Tag.of_json j
end

module ScalingConfigurationInfo = struct
  type t =
    { min_capacity : Integer.t option
    ; max_capacity : Integer.t option
    ; auto_pause : Boolean.t option
    ; seconds_until_auto_pause : Integer.t option
    ; timeout_action : String.t option
    }

  let make
      ?min_capacity
      ?max_capacity
      ?auto_pause
      ?seconds_until_auto_pause
      ?timeout_action
      () =
    { min_capacity; max_capacity; auto_pause; seconds_until_auto_pause; timeout_action }

  let parse xml =
    Some
      { min_capacity =
          Aws.Util.option_bind (Aws.Xml.member "MinCapacity" xml) Integer.parse
      ; max_capacity =
          Aws.Util.option_bind (Aws.Xml.member "MaxCapacity" xml) Integer.parse
      ; auto_pause = Aws.Util.option_bind (Aws.Xml.member "AutoPause" xml) Boolean.parse
      ; seconds_until_auto_pause =
          Aws.Util.option_bind (Aws.Xml.member "SecondsUntilAutoPause" xml) Integer.parse
      ; timeout_action =
          Aws.Util.option_bind (Aws.Xml.member "TimeoutAction" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timeout_action (fun f ->
               Aws.Query.Pair ("TimeoutAction", String.to_query f))
         ; Aws.Util.option_map v.seconds_until_auto_pause (fun f ->
               Aws.Query.Pair ("SecondsUntilAutoPause", Integer.to_query f))
         ; Aws.Util.option_map v.auto_pause (fun f ->
               Aws.Query.Pair ("AutoPause", Boolean.to_query f))
         ; Aws.Util.option_map v.max_capacity (fun f ->
               Aws.Query.Pair ("MaxCapacity", Integer.to_query f))
         ; Aws.Util.option_map v.min_capacity (fun f ->
               Aws.Query.Pair ("MinCapacity", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timeout_action (fun f ->
               "TimeoutAction", String.to_json f)
         ; Aws.Util.option_map v.seconds_until_auto_pause (fun f ->
               "SecondsUntilAutoPause", Integer.to_json f)
         ; Aws.Util.option_map v.auto_pause (fun f -> "AutoPause", Boolean.to_json f)
         ; Aws.Util.option_map v.max_capacity (fun f -> "MaxCapacity", Integer.to_json f)
         ; Aws.Util.option_map v.min_capacity (fun f -> "MinCapacity", Integer.to_json f)
         ])

  let of_json j =
    { min_capacity = Aws.Util.option_map (Aws.Json.lookup j "MinCapacity") Integer.of_json
    ; max_capacity = Aws.Util.option_map (Aws.Json.lookup j "MaxCapacity") Integer.of_json
    ; auto_pause = Aws.Util.option_map (Aws.Json.lookup j "AutoPause") Boolean.of_json
    ; seconds_until_auto_pause =
        Aws.Util.option_map (Aws.Json.lookup j "SecondsUntilAutoPause") Integer.of_json
    ; timeout_action =
        Aws.Util.option_map (Aws.Json.lookup j "TimeoutAction") String.of_json
    }
end

module ReadReplicaIdentifierList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map String.parse (Aws.Xml.members "ReadReplicaIdentifier" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module LogTypeList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DomainMembership = struct
  type t =
    { domain : String.t option
    ; status : String.t option
    ; f_q_d_n : String.t option
    ; i_a_m_role_name : String.t option
    }

  let make ?domain ?status ?f_q_d_n ?i_a_m_role_name () =
    { domain; status; f_q_d_n; i_a_m_role_name }

  let parse xml =
    Some
      { domain = Aws.Util.option_bind (Aws.Xml.member "Domain" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      ; f_q_d_n = Aws.Util.option_bind (Aws.Xml.member "FQDN" xml) String.parse
      ; i_a_m_role_name =
          Aws.Util.option_bind (Aws.Xml.member "IAMRoleName" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.i_a_m_role_name (fun f ->
               Aws.Query.Pair ("IAMRoleName", String.to_query f))
         ; Aws.Util.option_map v.f_q_d_n (fun f ->
               Aws.Query.Pair ("FQDN", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.domain (fun f ->
               Aws.Query.Pair ("Domain", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.i_a_m_role_name (fun f ->
               "IAMRoleName", String.to_json f)
         ; Aws.Util.option_map v.f_q_d_n (fun f -> "FQDN", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ; Aws.Util.option_map v.domain (fun f -> "Domain", String.to_json f)
         ])

  let of_json j =
    { domain = Aws.Util.option_map (Aws.Json.lookup j "Domain") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    ; f_q_d_n = Aws.Util.option_map (Aws.Json.lookup j "FQDN") String.of_json
    ; i_a_m_role_name =
        Aws.Util.option_map (Aws.Json.lookup j "IAMRoleName") String.of_json
    }
end

module DomainMembershipList = struct
  type t = DomainMembership.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map DomainMembership.parse (Aws.Xml.members "DomainMembership" xml))

  let to_query v = Aws.Query.to_query_list DomainMembership.to_query v

  let to_json v = `List (List.map DomainMembership.to_json v)

  let of_json j = Aws.Json.to_list DomainMembership.of_json j
end

module DBClusterRole = struct
  type t =
    { role_arn : String.t option
    ; status : String.t option
    ; feature_name : String.t option
    }

  let make ?role_arn ?status ?feature_name () = { role_arn; status; feature_name }

  let parse xml =
    Some
      { role_arn = Aws.Util.option_bind (Aws.Xml.member "RoleArn" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      ; feature_name =
          Aws.Util.option_bind (Aws.Xml.member "FeatureName" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.feature_name (fun f ->
               Aws.Query.Pair ("FeatureName", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.role_arn (fun f ->
               Aws.Query.Pair ("RoleArn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.feature_name (fun f -> "FeatureName", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ; Aws.Util.option_map v.role_arn (fun f -> "RoleArn", String.to_json f)
         ])

  let of_json j =
    { role_arn = Aws.Util.option_map (Aws.Json.lookup j "RoleArn") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    ; feature_name = Aws.Util.option_map (Aws.Json.lookup j "FeatureName") String.of_json
    }
end

module DBClusterRoles = struct
  type t = DBClusterRole.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map DBClusterRole.parse (Aws.Xml.members "DBClusterRole" xml))

  let to_query v = Aws.Query.to_query_list DBClusterRole.to_query v

  let to_json v = `List (List.map DBClusterRole.to_json v)

  let of_json j = Aws.Json.to_list DBClusterRole.of_json j
end

module DBClusterOptionGroupStatus = struct
  type t =
    { d_b_cluster_option_group_name : String.t option
    ; status : String.t option
    }

  let make ?d_b_cluster_option_group_name ?status () =
    { d_b_cluster_option_group_name; status }

  let parse xml =
    Some
      { d_b_cluster_option_group_name =
          Aws.Util.option_bind
            (Aws.Xml.member "DBClusterOptionGroupName" xml)
            String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.d_b_cluster_option_group_name (fun f ->
               Aws.Query.Pair ("DBClusterOptionGroupName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ; Aws.Util.option_map v.d_b_cluster_option_group_name (fun f ->
               "DBClusterOptionGroupName", String.to_json f)
         ])

  let of_json j =
    { d_b_cluster_option_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBClusterOptionGroupName") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    }
end

module DBClusterOptionGroupMemberships = struct
  type t = DBClusterOptionGroupStatus.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         DBClusterOptionGroupStatus.parse
         (Aws.Xml.members "DBClusterOptionGroup" xml))

  let to_query v = Aws.Query.to_query_list DBClusterOptionGroupStatus.to_query v

  let to_json v = `List (List.map DBClusterOptionGroupStatus.to_json v)

  let of_json j = Aws.Json.to_list DBClusterOptionGroupStatus.of_json j
end

module DBClusterMember = struct
  type t =
    { d_b_instance_identifier : String.t option
    ; is_cluster_writer : Boolean.t option
    ; d_b_cluster_parameter_group_status : String.t option
    ; promotion_tier : Integer.t option
    }

  let make
      ?d_b_instance_identifier
      ?is_cluster_writer
      ?d_b_cluster_parameter_group_status
      ?promotion_tier
      () =
    { d_b_instance_identifier
    ; is_cluster_writer
    ; d_b_cluster_parameter_group_status
    ; promotion_tier
    }

  let parse xml =
    Some
      { d_b_instance_identifier =
          Aws.Util.option_bind (Aws.Xml.member "DBInstanceIdentifier" xml) String.parse
      ; is_cluster_writer =
          Aws.Util.option_bind (Aws.Xml.member "IsClusterWriter" xml) Boolean.parse
      ; d_b_cluster_parameter_group_status =
          Aws.Util.option_bind
            (Aws.Xml.member "DBClusterParameterGroupStatus" xml)
            String.parse
      ; promotion_tier =
          Aws.Util.option_bind (Aws.Xml.member "PromotionTier" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.promotion_tier (fun f ->
               Aws.Query.Pair ("PromotionTier", Integer.to_query f))
         ; Aws.Util.option_map v.d_b_cluster_parameter_group_status (fun f ->
               Aws.Query.Pair ("DBClusterParameterGroupStatus", String.to_query f))
         ; Aws.Util.option_map v.is_cluster_writer (fun f ->
               Aws.Query.Pair ("IsClusterWriter", Boolean.to_query f))
         ; Aws.Util.option_map v.d_b_instance_identifier (fun f ->
               Aws.Query.Pair ("DBInstanceIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.promotion_tier (fun f ->
               "PromotionTier", Integer.to_json f)
         ; Aws.Util.option_map v.d_b_cluster_parameter_group_status (fun f ->
               "DBClusterParameterGroupStatus", String.to_json f)
         ; Aws.Util.option_map v.is_cluster_writer (fun f ->
               "IsClusterWriter", Boolean.to_json f)
         ; Aws.Util.option_map v.d_b_instance_identifier (fun f ->
               "DBInstanceIdentifier", String.to_json f)
         ])

  let of_json j =
    { d_b_instance_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstanceIdentifier") String.of_json
    ; is_cluster_writer =
        Aws.Util.option_map (Aws.Json.lookup j "IsClusterWriter") Boolean.of_json
    ; d_b_cluster_parameter_group_status =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBClusterParameterGroupStatus")
          String.of_json
    ; promotion_tier =
        Aws.Util.option_map (Aws.Json.lookup j "PromotionTier") Integer.of_json
    }
end

module DBClusterMemberList = struct
  type t = DBClusterMember.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map DBClusterMember.parse (Aws.Xml.members "DBClusterMember" xml))

  let to_query v = Aws.Query.to_query_list DBClusterMember.to_query v

  let to_json v = `List (List.map DBClusterMember.to_json v)

  let of_json j = Aws.Json.to_list DBClusterMember.of_json j
end

module AvailabilityZones = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "AvailabilityZone" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module ActivityStreamStatus = struct
  type t =
    | Stopped
    | Starting
    | Started
    | Stopping

  let str_to_t =
    [ "stopping", Stopping; "started", Started; "starting", Starting; "stopped", Stopped ]

  let t_to_str =
    [ Stopping, "stopping"; Started, "started"; Starting, "starting"; Stopped, "stopped" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ActivityStreamMode = struct
  type t =
    | Sync
    | Async

  let str_to_t = [ "async", Async; "sync", Sync ]

  let t_to_str = [ Async, "async"; Sync, "sync" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DBCluster = struct
  type t =
    { allocated_storage : Integer.t option
    ; availability_zones : AvailabilityZones.t
    ; backup_retention_period : Integer.t option
    ; character_set_name : String.t option
    ; database_name : String.t option
    ; d_b_cluster_identifier : String.t option
    ; d_b_cluster_parameter_group : String.t option
    ; d_b_subnet_group : String.t option
    ; status : String.t option
    ; percent_progress : String.t option
    ; earliest_restorable_time : DateTime.t option
    ; endpoint : String.t option
    ; reader_endpoint : String.t option
    ; custom_endpoints : StringList.t
    ; multi_a_z : Boolean.t option
    ; engine : String.t option
    ; engine_version : String.t option
    ; latest_restorable_time : DateTime.t option
    ; port : Integer.t option
    ; master_username : String.t option
    ; d_b_cluster_option_group_memberships : DBClusterOptionGroupMemberships.t
    ; preferred_backup_window : String.t option
    ; preferred_maintenance_window : String.t option
    ; replication_source_identifier : String.t option
    ; read_replica_identifiers : ReadReplicaIdentifierList.t
    ; d_b_cluster_members : DBClusterMemberList.t
    ; vpc_security_groups : VpcSecurityGroupMembershipList.t
    ; hosted_zone_id : String.t option
    ; storage_encrypted : Boolean.t option
    ; kms_key_id : String.t option
    ; db_cluster_resource_id : String.t option
    ; d_b_cluster_arn : String.t option
    ; associated_roles : DBClusterRoles.t
    ; i_a_m_database_authentication_enabled : Boolean.t option
    ; clone_group_id : String.t option
    ; cluster_create_time : DateTime.t option
    ; earliest_backtrack_time : DateTime.t option
    ; backtrack_window : Long.t option
    ; backtrack_consumed_change_records : Long.t option
    ; enabled_cloudwatch_logs_exports : LogTypeList.t
    ; capacity : Integer.t option
    ; engine_mode : String.t option
    ; scaling_configuration_info : ScalingConfigurationInfo.t option
    ; deletion_protection : Boolean.t option
    ; http_endpoint_enabled : Boolean.t option
    ; activity_stream_mode : ActivityStreamMode.t option
    ; activity_stream_status : ActivityStreamStatus.t option
    ; activity_stream_kms_key_id : String.t option
    ; activity_stream_kinesis_stream_name : String.t option
    ; copy_tags_to_snapshot : Boolean.t option
    ; cross_account_clone : Boolean.t option
    ; domain_memberships : DomainMembershipList.t
    ; tag_list : TagList.t
    ; global_write_forwarding_status : WriteForwardingStatus.t option
    ; global_write_forwarding_requested : Boolean.t option
    }

  let make
      ?allocated_storage
      ?(availability_zones = [])
      ?backup_retention_period
      ?character_set_name
      ?database_name
      ?d_b_cluster_identifier
      ?d_b_cluster_parameter_group
      ?d_b_subnet_group
      ?status
      ?percent_progress
      ?earliest_restorable_time
      ?endpoint
      ?reader_endpoint
      ?(custom_endpoints = [])
      ?multi_a_z
      ?engine
      ?engine_version
      ?latest_restorable_time
      ?port
      ?master_username
      ?(d_b_cluster_option_group_memberships = [])
      ?preferred_backup_window
      ?preferred_maintenance_window
      ?replication_source_identifier
      ?(read_replica_identifiers = [])
      ?(d_b_cluster_members = [])
      ?(vpc_security_groups = [])
      ?hosted_zone_id
      ?storage_encrypted
      ?kms_key_id
      ?db_cluster_resource_id
      ?d_b_cluster_arn
      ?(associated_roles = [])
      ?i_a_m_database_authentication_enabled
      ?clone_group_id
      ?cluster_create_time
      ?earliest_backtrack_time
      ?backtrack_window
      ?backtrack_consumed_change_records
      ?(enabled_cloudwatch_logs_exports = [])
      ?capacity
      ?engine_mode
      ?scaling_configuration_info
      ?deletion_protection
      ?http_endpoint_enabled
      ?activity_stream_mode
      ?activity_stream_status
      ?activity_stream_kms_key_id
      ?activity_stream_kinesis_stream_name
      ?copy_tags_to_snapshot
      ?cross_account_clone
      ?(domain_memberships = [])
      ?(tag_list = [])
      ?global_write_forwarding_status
      ?global_write_forwarding_requested
      () =
    { allocated_storage
    ; availability_zones
    ; backup_retention_period
    ; character_set_name
    ; database_name
    ; d_b_cluster_identifier
    ; d_b_cluster_parameter_group
    ; d_b_subnet_group
    ; status
    ; percent_progress
    ; earliest_restorable_time
    ; endpoint
    ; reader_endpoint
    ; custom_endpoints
    ; multi_a_z
    ; engine
    ; engine_version
    ; latest_restorable_time
    ; port
    ; master_username
    ; d_b_cluster_option_group_memberships
    ; preferred_backup_window
    ; preferred_maintenance_window
    ; replication_source_identifier
    ; read_replica_identifiers
    ; d_b_cluster_members
    ; vpc_security_groups
    ; hosted_zone_id
    ; storage_encrypted
    ; kms_key_id
    ; db_cluster_resource_id
    ; d_b_cluster_arn
    ; associated_roles
    ; i_a_m_database_authentication_enabled
    ; clone_group_id
    ; cluster_create_time
    ; earliest_backtrack_time
    ; backtrack_window
    ; backtrack_consumed_change_records
    ; enabled_cloudwatch_logs_exports
    ; capacity
    ; engine_mode
    ; scaling_configuration_info
    ; deletion_protection
    ; http_endpoint_enabled
    ; activity_stream_mode
    ; activity_stream_status
    ; activity_stream_kms_key_id
    ; activity_stream_kinesis_stream_name
    ; copy_tags_to_snapshot
    ; cross_account_clone
    ; domain_memberships
    ; tag_list
    ; global_write_forwarding_status
    ; global_write_forwarding_requested
    }

  let parse xml =
    Some
      { allocated_storage =
          Aws.Util.option_bind (Aws.Xml.member "AllocatedStorage" xml) Integer.parse
      ; availability_zones =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AvailabilityZones" xml)
               AvailabilityZones.parse)
      ; backup_retention_period =
          Aws.Util.option_bind (Aws.Xml.member "BackupRetentionPeriod" xml) Integer.parse
      ; character_set_name =
          Aws.Util.option_bind (Aws.Xml.member "CharacterSetName" xml) String.parse
      ; database_name =
          Aws.Util.option_bind (Aws.Xml.member "DatabaseName" xml) String.parse
      ; d_b_cluster_identifier =
          Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse
      ; d_b_cluster_parameter_group =
          Aws.Util.option_bind (Aws.Xml.member "DBClusterParameterGroup" xml) String.parse
      ; d_b_subnet_group =
          Aws.Util.option_bind (Aws.Xml.member "DBSubnetGroup" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      ; percent_progress =
          Aws.Util.option_bind (Aws.Xml.member "PercentProgress" xml) String.parse
      ; earliest_restorable_time =
          Aws.Util.option_bind
            (Aws.Xml.member "EarliestRestorableTime" xml)
            DateTime.parse
      ; endpoint = Aws.Util.option_bind (Aws.Xml.member "Endpoint" xml) String.parse
      ; reader_endpoint =
          Aws.Util.option_bind (Aws.Xml.member "ReaderEndpoint" xml) String.parse
      ; custom_endpoints =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "CustomEndpoints" xml) StringList.parse)
      ; multi_a_z = Aws.Util.option_bind (Aws.Xml.member "MultiAZ" xml) Boolean.parse
      ; engine = Aws.Util.option_bind (Aws.Xml.member "Engine" xml) String.parse
      ; engine_version =
          Aws.Util.option_bind (Aws.Xml.member "EngineVersion" xml) String.parse
      ; latest_restorable_time =
          Aws.Util.option_bind (Aws.Xml.member "LatestRestorableTime" xml) DateTime.parse
      ; port = Aws.Util.option_bind (Aws.Xml.member "Port" xml) Integer.parse
      ; master_username =
          Aws.Util.option_bind (Aws.Xml.member "MasterUsername" xml) String.parse
      ; d_b_cluster_option_group_memberships =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DBClusterOptionGroupMemberships" xml)
               DBClusterOptionGroupMemberships.parse)
      ; preferred_backup_window =
          Aws.Util.option_bind (Aws.Xml.member "PreferredBackupWindow" xml) String.parse
      ; preferred_maintenance_window =
          Aws.Util.option_bind
            (Aws.Xml.member "PreferredMaintenanceWindow" xml)
            String.parse
      ; replication_source_identifier =
          Aws.Util.option_bind
            (Aws.Xml.member "ReplicationSourceIdentifier" xml)
            String.parse
      ; read_replica_identifiers =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ReadReplicaIdentifiers" xml)
               ReadReplicaIdentifierList.parse)
      ; d_b_cluster_members =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DBClusterMembers" xml)
               DBClusterMemberList.parse)
      ; vpc_security_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "VpcSecurityGroups" xml)
               VpcSecurityGroupMembershipList.parse)
      ; hosted_zone_id =
          Aws.Util.option_bind (Aws.Xml.member "HostedZoneId" xml) String.parse
      ; storage_encrypted =
          Aws.Util.option_bind (Aws.Xml.member "StorageEncrypted" xml) Boolean.parse
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "KmsKeyId" xml) String.parse
      ; db_cluster_resource_id =
          Aws.Util.option_bind (Aws.Xml.member "DbClusterResourceId" xml) String.parse
      ; d_b_cluster_arn =
          Aws.Util.option_bind (Aws.Xml.member "DBClusterArn" xml) String.parse
      ; associated_roles =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AssociatedRoles" xml)
               DBClusterRoles.parse)
      ; i_a_m_database_authentication_enabled =
          Aws.Util.option_bind
            (Aws.Xml.member "IAMDatabaseAuthenticationEnabled" xml)
            Boolean.parse
      ; clone_group_id =
          Aws.Util.option_bind (Aws.Xml.member "CloneGroupId" xml) String.parse
      ; cluster_create_time =
          Aws.Util.option_bind (Aws.Xml.member "ClusterCreateTime" xml) DateTime.parse
      ; earliest_backtrack_time =
          Aws.Util.option_bind (Aws.Xml.member "EarliestBacktrackTime" xml) DateTime.parse
      ; backtrack_window =
          Aws.Util.option_bind (Aws.Xml.member "BacktrackWindow" xml) Long.parse
      ; backtrack_consumed_change_records =
          Aws.Util.option_bind
            (Aws.Xml.member "BacktrackConsumedChangeRecords" xml)
            Long.parse
      ; enabled_cloudwatch_logs_exports =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "EnabledCloudwatchLogsExports" xml)
               LogTypeList.parse)
      ; capacity = Aws.Util.option_bind (Aws.Xml.member "Capacity" xml) Integer.parse
      ; engine_mode = Aws.Util.option_bind (Aws.Xml.member "EngineMode" xml) String.parse
      ; scaling_configuration_info =
          Aws.Util.option_bind
            (Aws.Xml.member "ScalingConfigurationInfo" xml)
            ScalingConfigurationInfo.parse
      ; deletion_protection =
          Aws.Util.option_bind (Aws.Xml.member "DeletionProtection" xml) Boolean.parse
      ; http_endpoint_enabled =
          Aws.Util.option_bind (Aws.Xml.member "HttpEndpointEnabled" xml) Boolean.parse
      ; activity_stream_mode =
          Aws.Util.option_bind
            (Aws.Xml.member "ActivityStreamMode" xml)
            ActivityStreamMode.parse
      ; activity_stream_status =
          Aws.Util.option_bind
            (Aws.Xml.member "ActivityStreamStatus" xml)
            ActivityStreamStatus.parse
      ; activity_stream_kms_key_id =
          Aws.Util.option_bind (Aws.Xml.member "ActivityStreamKmsKeyId" xml) String.parse
      ; activity_stream_kinesis_stream_name =
          Aws.Util.option_bind
            (Aws.Xml.member "ActivityStreamKinesisStreamName" xml)
            String.parse
      ; copy_tags_to_snapshot =
          Aws.Util.option_bind (Aws.Xml.member "CopyTagsToSnapshot" xml) Boolean.parse
      ; cross_account_clone =
          Aws.Util.option_bind (Aws.Xml.member "CrossAccountClone" xml) Boolean.parse
      ; domain_memberships =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DomainMemberships" xml)
               DomainMembershipList.parse)
      ; tag_list =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "TagList" xml) TagList.parse)
      ; global_write_forwarding_status =
          Aws.Util.option_bind
            (Aws.Xml.member "GlobalWriteForwardingStatus" xml)
            WriteForwardingStatus.parse
      ; global_write_forwarding_requested =
          Aws.Util.option_bind
            (Aws.Xml.member "GlobalWriteForwardingRequested" xml)
            Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.global_write_forwarding_requested (fun f ->
               Aws.Query.Pair ("GlobalWriteForwardingRequested", Boolean.to_query f))
         ; Aws.Util.option_map v.global_write_forwarding_status (fun f ->
               Aws.Query.Pair
                 ("GlobalWriteForwardingStatus", WriteForwardingStatus.to_query f))
         ; Some (Aws.Query.Pair ("TagList.member", TagList.to_query v.tag_list))
         ; Some
             (Aws.Query.Pair
                ( "DomainMemberships.member"
                , DomainMembershipList.to_query v.domain_memberships ))
         ; Aws.Util.option_map v.cross_account_clone (fun f ->
               Aws.Query.Pair ("CrossAccountClone", Boolean.to_query f))
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               Aws.Query.Pair ("CopyTagsToSnapshot", Boolean.to_query f))
         ; Aws.Util.option_map v.activity_stream_kinesis_stream_name (fun f ->
               Aws.Query.Pair ("ActivityStreamKinesisStreamName", String.to_query f))
         ; Aws.Util.option_map v.activity_stream_kms_key_id (fun f ->
               Aws.Query.Pair ("ActivityStreamKmsKeyId", String.to_query f))
         ; Aws.Util.option_map v.activity_stream_status (fun f ->
               Aws.Query.Pair ("ActivityStreamStatus", ActivityStreamStatus.to_query f))
         ; Aws.Util.option_map v.activity_stream_mode (fun f ->
               Aws.Query.Pair ("ActivityStreamMode", ActivityStreamMode.to_query f))
         ; Aws.Util.option_map v.http_endpoint_enabled (fun f ->
               Aws.Query.Pair ("HttpEndpointEnabled", Boolean.to_query f))
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               Aws.Query.Pair ("DeletionProtection", Boolean.to_query f))
         ; Aws.Util.option_map v.scaling_configuration_info (fun f ->
               Aws.Query.Pair
                 ("ScalingConfigurationInfo", ScalingConfigurationInfo.to_query f))
         ; Aws.Util.option_map v.engine_mode (fun f ->
               Aws.Query.Pair ("EngineMode", String.to_query f))
         ; Aws.Util.option_map v.capacity (fun f ->
               Aws.Query.Pair ("Capacity", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "EnabledCloudwatchLogsExports.member"
                , LogTypeList.to_query v.enabled_cloudwatch_logs_exports ))
         ; Aws.Util.option_map v.backtrack_consumed_change_records (fun f ->
               Aws.Query.Pair ("BacktrackConsumedChangeRecords", Long.to_query f))
         ; Aws.Util.option_map v.backtrack_window (fun f ->
               Aws.Query.Pair ("BacktrackWindow", Long.to_query f))
         ; Aws.Util.option_map v.earliest_backtrack_time (fun f ->
               Aws.Query.Pair ("EarliestBacktrackTime", DateTime.to_query f))
         ; Aws.Util.option_map v.cluster_create_time (fun f ->
               Aws.Query.Pair ("ClusterCreateTime", DateTime.to_query f))
         ; Aws.Util.option_map v.clone_group_id (fun f ->
               Aws.Query.Pair ("CloneGroupId", String.to_query f))
         ; Aws.Util.option_map v.i_a_m_database_authentication_enabled (fun f ->
               Aws.Query.Pair ("IAMDatabaseAuthenticationEnabled", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("AssociatedRoles.member", DBClusterRoles.to_query v.associated_roles))
         ; Aws.Util.option_map v.d_b_cluster_arn (fun f ->
               Aws.Query.Pair ("DBClusterArn", String.to_query f))
         ; Aws.Util.option_map v.db_cluster_resource_id (fun f ->
               Aws.Query.Pair ("DbClusterResourceId", String.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Aws.Util.option_map v.storage_encrypted (fun f ->
               Aws.Query.Pair ("StorageEncrypted", Boolean.to_query f))
         ; Aws.Util.option_map v.hosted_zone_id (fun f ->
               Aws.Query.Pair ("HostedZoneId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "VpcSecurityGroups.member"
                , VpcSecurityGroupMembershipList.to_query v.vpc_security_groups ))
         ; Some
             (Aws.Query.Pair
                ( "DBClusterMembers.member"
                , DBClusterMemberList.to_query v.d_b_cluster_members ))
         ; Some
             (Aws.Query.Pair
                ( "ReadReplicaIdentifiers.member"
                , ReadReplicaIdentifierList.to_query v.read_replica_identifiers ))
         ; Aws.Util.option_map v.replication_source_identifier (fun f ->
               Aws.Query.Pair ("ReplicationSourceIdentifier", String.to_query f))
         ; Aws.Util.option_map v.preferred_maintenance_window (fun f ->
               Aws.Query.Pair ("PreferredMaintenanceWindow", String.to_query f))
         ; Aws.Util.option_map v.preferred_backup_window (fun f ->
               Aws.Query.Pair ("PreferredBackupWindow", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "DBClusterOptionGroupMemberships.member"
                , DBClusterOptionGroupMemberships.to_query
                    v.d_b_cluster_option_group_memberships ))
         ; Aws.Util.option_map v.master_username (fun f ->
               Aws.Query.Pair ("MasterUsername", String.to_query f))
         ; Aws.Util.option_map v.port (fun f ->
               Aws.Query.Pair ("Port", Integer.to_query f))
         ; Aws.Util.option_map v.latest_restorable_time (fun f ->
               Aws.Query.Pair ("LatestRestorableTime", DateTime.to_query f))
         ; Aws.Util.option_map v.engine_version (fun f ->
               Aws.Query.Pair ("EngineVersion", String.to_query f))
         ; Aws.Util.option_map v.engine (fun f ->
               Aws.Query.Pair ("Engine", String.to_query f))
         ; Aws.Util.option_map v.multi_a_z (fun f ->
               Aws.Query.Pair ("MultiAZ", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("CustomEndpoints.member", StringList.to_query v.custom_endpoints))
         ; Aws.Util.option_map v.reader_endpoint (fun f ->
               Aws.Query.Pair ("ReaderEndpoint", String.to_query f))
         ; Aws.Util.option_map v.endpoint (fun f ->
               Aws.Query.Pair ("Endpoint", String.to_query f))
         ; Aws.Util.option_map v.earliest_restorable_time (fun f ->
               Aws.Query.Pair ("EarliestRestorableTime", DateTime.to_query f))
         ; Aws.Util.option_map v.percent_progress (fun f ->
               Aws.Query.Pair ("PercentProgress", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.d_b_subnet_group (fun f ->
               Aws.Query.Pair ("DBSubnetGroup", String.to_query f))
         ; Aws.Util.option_map v.d_b_cluster_parameter_group (fun f ->
               Aws.Query.Pair ("DBClusterParameterGroup", String.to_query f))
         ; Aws.Util.option_map v.d_b_cluster_identifier (fun f ->
               Aws.Query.Pair ("DBClusterIdentifier", String.to_query f))
         ; Aws.Util.option_map v.database_name (fun f ->
               Aws.Query.Pair ("DatabaseName", String.to_query f))
         ; Aws.Util.option_map v.character_set_name (fun f ->
               Aws.Query.Pair ("CharacterSetName", String.to_query f))
         ; Aws.Util.option_map v.backup_retention_period (fun f ->
               Aws.Query.Pair ("BackupRetentionPeriod", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "AvailabilityZones.member"
                , AvailabilityZones.to_query v.availability_zones ))
         ; Aws.Util.option_map v.allocated_storage (fun f ->
               Aws.Query.Pair ("AllocatedStorage", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.global_write_forwarding_requested (fun f ->
               "GlobalWriteForwardingRequested", Boolean.to_json f)
         ; Aws.Util.option_map v.global_write_forwarding_status (fun f ->
               "GlobalWriteForwardingStatus", WriteForwardingStatus.to_json f)
         ; Some ("TagList", TagList.to_json v.tag_list)
         ; Some ("DomainMemberships", DomainMembershipList.to_json v.domain_memberships)
         ; Aws.Util.option_map v.cross_account_clone (fun f ->
               "CrossAccountClone", Boolean.to_json f)
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               "CopyTagsToSnapshot", Boolean.to_json f)
         ; Aws.Util.option_map v.activity_stream_kinesis_stream_name (fun f ->
               "ActivityStreamKinesisStreamName", String.to_json f)
         ; Aws.Util.option_map v.activity_stream_kms_key_id (fun f ->
               "ActivityStreamKmsKeyId", String.to_json f)
         ; Aws.Util.option_map v.activity_stream_status (fun f ->
               "ActivityStreamStatus", ActivityStreamStatus.to_json f)
         ; Aws.Util.option_map v.activity_stream_mode (fun f ->
               "ActivityStreamMode", ActivityStreamMode.to_json f)
         ; Aws.Util.option_map v.http_endpoint_enabled (fun f ->
               "HttpEndpointEnabled", Boolean.to_json f)
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               "DeletionProtection", Boolean.to_json f)
         ; Aws.Util.option_map v.scaling_configuration_info (fun f ->
               "ScalingConfigurationInfo", ScalingConfigurationInfo.to_json f)
         ; Aws.Util.option_map v.engine_mode (fun f -> "EngineMode", String.to_json f)
         ; Aws.Util.option_map v.capacity (fun f -> "Capacity", Integer.to_json f)
         ; Some
             ( "EnabledCloudwatchLogsExports"
             , LogTypeList.to_json v.enabled_cloudwatch_logs_exports )
         ; Aws.Util.option_map v.backtrack_consumed_change_records (fun f ->
               "BacktrackConsumedChangeRecords", Long.to_json f)
         ; Aws.Util.option_map v.backtrack_window (fun f ->
               "BacktrackWindow", Long.to_json f)
         ; Aws.Util.option_map v.earliest_backtrack_time (fun f ->
               "EarliestBacktrackTime", DateTime.to_json f)
         ; Aws.Util.option_map v.cluster_create_time (fun f ->
               "ClusterCreateTime", DateTime.to_json f)
         ; Aws.Util.option_map v.clone_group_id (fun f ->
               "CloneGroupId", String.to_json f)
         ; Aws.Util.option_map v.i_a_m_database_authentication_enabled (fun f ->
               "IAMDatabaseAuthenticationEnabled", Boolean.to_json f)
         ; Some ("AssociatedRoles", DBClusterRoles.to_json v.associated_roles)
         ; Aws.Util.option_map v.d_b_cluster_arn (fun f ->
               "DBClusterArn", String.to_json f)
         ; Aws.Util.option_map v.db_cluster_resource_id (fun f ->
               "DbClusterResourceId", String.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "KmsKeyId", String.to_json f)
         ; Aws.Util.option_map v.storage_encrypted (fun f ->
               "StorageEncrypted", Boolean.to_json f)
         ; Aws.Util.option_map v.hosted_zone_id (fun f ->
               "HostedZoneId", String.to_json f)
         ; Some
             ( "VpcSecurityGroups"
             , VpcSecurityGroupMembershipList.to_json v.vpc_security_groups )
         ; Some ("DBClusterMembers", DBClusterMemberList.to_json v.d_b_cluster_members)
         ; Some
             ( "ReadReplicaIdentifiers"
             , ReadReplicaIdentifierList.to_json v.read_replica_identifiers )
         ; Aws.Util.option_map v.replication_source_identifier (fun f ->
               "ReplicationSourceIdentifier", String.to_json f)
         ; Aws.Util.option_map v.preferred_maintenance_window (fun f ->
               "PreferredMaintenanceWindow", String.to_json f)
         ; Aws.Util.option_map v.preferred_backup_window (fun f ->
               "PreferredBackupWindow", String.to_json f)
         ; Some
             ( "DBClusterOptionGroupMemberships"
             , DBClusterOptionGroupMemberships.to_json
                 v.d_b_cluster_option_group_memberships )
         ; Aws.Util.option_map v.master_username (fun f ->
               "MasterUsername", String.to_json f)
         ; Aws.Util.option_map v.port (fun f -> "Port", Integer.to_json f)
         ; Aws.Util.option_map v.latest_restorable_time (fun f ->
               "LatestRestorableTime", DateTime.to_json f)
         ; Aws.Util.option_map v.engine_version (fun f ->
               "EngineVersion", String.to_json f)
         ; Aws.Util.option_map v.engine (fun f -> "Engine", String.to_json f)
         ; Aws.Util.option_map v.multi_a_z (fun f -> "MultiAZ", Boolean.to_json f)
         ; Some ("CustomEndpoints", StringList.to_json v.custom_endpoints)
         ; Aws.Util.option_map v.reader_endpoint (fun f ->
               "ReaderEndpoint", String.to_json f)
         ; Aws.Util.option_map v.endpoint (fun f -> "Endpoint", String.to_json f)
         ; Aws.Util.option_map v.earliest_restorable_time (fun f ->
               "EarliestRestorableTime", DateTime.to_json f)
         ; Aws.Util.option_map v.percent_progress (fun f ->
               "PercentProgress", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ; Aws.Util.option_map v.d_b_subnet_group (fun f ->
               "DBSubnetGroup", String.to_json f)
         ; Aws.Util.option_map v.d_b_cluster_parameter_group (fun f ->
               "DBClusterParameterGroup", String.to_json f)
         ; Aws.Util.option_map v.d_b_cluster_identifier (fun f ->
               "DBClusterIdentifier", String.to_json f)
         ; Aws.Util.option_map v.database_name (fun f -> "DatabaseName", String.to_json f)
         ; Aws.Util.option_map v.character_set_name (fun f ->
               "CharacterSetName", String.to_json f)
         ; Aws.Util.option_map v.backup_retention_period (fun f ->
               "BackupRetentionPeriod", Integer.to_json f)
         ; Some ("AvailabilityZones", AvailabilityZones.to_json v.availability_zones)
         ; Aws.Util.option_map v.allocated_storage (fun f ->
               "AllocatedStorage", Integer.to_json f)
         ])

  let of_json j =
    { allocated_storage =
        Aws.Util.option_map (Aws.Json.lookup j "AllocatedStorage") Integer.of_json
    ; availability_zones =
        AvailabilityZones.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AvailabilityZones"))
    ; backup_retention_period =
        Aws.Util.option_map (Aws.Json.lookup j "BackupRetentionPeriod") Integer.of_json
    ; character_set_name =
        Aws.Util.option_map (Aws.Json.lookup j "CharacterSetName") String.of_json
    ; database_name =
        Aws.Util.option_map (Aws.Json.lookup j "DatabaseName") String.of_json
    ; d_b_cluster_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "DBClusterIdentifier") String.of_json
    ; d_b_cluster_parameter_group =
        Aws.Util.option_map (Aws.Json.lookup j "DBClusterParameterGroup") String.of_json
    ; d_b_subnet_group =
        Aws.Util.option_map (Aws.Json.lookup j "DBSubnetGroup") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    ; percent_progress =
        Aws.Util.option_map (Aws.Json.lookup j "PercentProgress") String.of_json
    ; earliest_restorable_time =
        Aws.Util.option_map (Aws.Json.lookup j "EarliestRestorableTime") DateTime.of_json
    ; endpoint = Aws.Util.option_map (Aws.Json.lookup j "Endpoint") String.of_json
    ; reader_endpoint =
        Aws.Util.option_map (Aws.Json.lookup j "ReaderEndpoint") String.of_json
    ; custom_endpoints =
        StringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "CustomEndpoints"))
    ; multi_a_z = Aws.Util.option_map (Aws.Json.lookup j "MultiAZ") Boolean.of_json
    ; engine = Aws.Util.option_map (Aws.Json.lookup j "Engine") String.of_json
    ; engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "EngineVersion") String.of_json
    ; latest_restorable_time =
        Aws.Util.option_map (Aws.Json.lookup j "LatestRestorableTime") DateTime.of_json
    ; port = Aws.Util.option_map (Aws.Json.lookup j "Port") Integer.of_json
    ; master_username =
        Aws.Util.option_map (Aws.Json.lookup j "MasterUsername") String.of_json
    ; d_b_cluster_option_group_memberships =
        DBClusterOptionGroupMemberships.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterOptionGroupMemberships"))
    ; preferred_backup_window =
        Aws.Util.option_map (Aws.Json.lookup j "PreferredBackupWindow") String.of_json
    ; preferred_maintenance_window =
        Aws.Util.option_map
          (Aws.Json.lookup j "PreferredMaintenanceWindow")
          String.of_json
    ; replication_source_identifier =
        Aws.Util.option_map
          (Aws.Json.lookup j "ReplicationSourceIdentifier")
          String.of_json
    ; read_replica_identifiers =
        ReadReplicaIdentifierList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ReadReplicaIdentifiers"))
    ; d_b_cluster_members =
        DBClusterMemberList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterMembers"))
    ; vpc_security_groups =
        VpcSecurityGroupMembershipList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcSecurityGroups"))
    ; hosted_zone_id =
        Aws.Util.option_map (Aws.Json.lookup j "HostedZoneId") String.of_json
    ; storage_encrypted =
        Aws.Util.option_map (Aws.Json.lookup j "StorageEncrypted") Boolean.of_json
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "KmsKeyId") String.of_json
    ; db_cluster_resource_id =
        Aws.Util.option_map (Aws.Json.lookup j "DbClusterResourceId") String.of_json
    ; d_b_cluster_arn =
        Aws.Util.option_map (Aws.Json.lookup j "DBClusterArn") String.of_json
    ; associated_roles =
        DBClusterRoles.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AssociatedRoles"))
    ; i_a_m_database_authentication_enabled =
        Aws.Util.option_map
          (Aws.Json.lookup j "IAMDatabaseAuthenticationEnabled")
          Boolean.of_json
    ; clone_group_id =
        Aws.Util.option_map (Aws.Json.lookup j "CloneGroupId") String.of_json
    ; cluster_create_time =
        Aws.Util.option_map (Aws.Json.lookup j "ClusterCreateTime") DateTime.of_json
    ; earliest_backtrack_time =
        Aws.Util.option_map (Aws.Json.lookup j "EarliestBacktrackTime") DateTime.of_json
    ; backtrack_window =
        Aws.Util.option_map (Aws.Json.lookup j "BacktrackWindow") Long.of_json
    ; backtrack_consumed_change_records =
        Aws.Util.option_map
          (Aws.Json.lookup j "BacktrackConsumedChangeRecords")
          Long.of_json
    ; enabled_cloudwatch_logs_exports =
        LogTypeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "EnabledCloudwatchLogsExports"))
    ; capacity = Aws.Util.option_map (Aws.Json.lookup j "Capacity") Integer.of_json
    ; engine_mode = Aws.Util.option_map (Aws.Json.lookup j "EngineMode") String.of_json
    ; scaling_configuration_info =
        Aws.Util.option_map
          (Aws.Json.lookup j "ScalingConfigurationInfo")
          ScalingConfigurationInfo.of_json
    ; deletion_protection =
        Aws.Util.option_map (Aws.Json.lookup j "DeletionProtection") Boolean.of_json
    ; http_endpoint_enabled =
        Aws.Util.option_map (Aws.Json.lookup j "HttpEndpointEnabled") Boolean.of_json
    ; activity_stream_mode =
        Aws.Util.option_map
          (Aws.Json.lookup j "ActivityStreamMode")
          ActivityStreamMode.of_json
    ; activity_stream_status =
        Aws.Util.option_map
          (Aws.Json.lookup j "ActivityStreamStatus")
          ActivityStreamStatus.of_json
    ; activity_stream_kms_key_id =
        Aws.Util.option_map (Aws.Json.lookup j "ActivityStreamKmsKeyId") String.of_json
    ; activity_stream_kinesis_stream_name =
        Aws.Util.option_map
          (Aws.Json.lookup j "ActivityStreamKinesisStreamName")
          String.of_json
    ; copy_tags_to_snapshot =
        Aws.Util.option_map (Aws.Json.lookup j "CopyTagsToSnapshot") Boolean.of_json
    ; cross_account_clone =
        Aws.Util.option_map (Aws.Json.lookup j "CrossAccountClone") Boolean.of_json
    ; domain_memberships =
        DomainMembershipList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DomainMemberships"))
    ; tag_list = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TagList"))
    ; global_write_forwarding_status =
        Aws.Util.option_map
          (Aws.Json.lookup j "GlobalWriteForwardingStatus")
          WriteForwardingStatus.of_json
    ; global_write_forwarding_requested =
        Aws.Util.option_map
          (Aws.Json.lookup j "GlobalWriteForwardingRequested")
          Boolean.of_json
    }
end

module DBClusterList = struct
  type t = DBCluster.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map DBCluster.parse (Aws.Xml.members "DBCluster" xml))

  let to_query v = Aws.Query.to_query_list DBCluster.to_query v

  let to_json v = `List (List.map DBCluster.to_json v)

  let of_json j = Aws.Json.to_list DBCluster.of_json j
end

module DBClusterMessage = struct
  type t =
    { marker : String.t option
    ; d_b_clusters : DBClusterList.t
    }

  let make ?marker ?(d_b_clusters = []) () = { marker; d_b_clusters }

  let parse xml =
    Some
      { marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; d_b_clusters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "DBClusters" xml) DBClusterList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("DBClusters.member", DBClusterList.to_query v.d_b_clusters))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("DBClusters", DBClusterList.to_json v.d_b_clusters)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ])

  let of_json j =
    { marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; d_b_clusters =
        DBClusterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusters"))
    }
end

module DBClusterBacktrack = struct
  type t =
    { d_b_cluster_identifier : String.t option
    ; backtrack_identifier : String.t option
    ; backtrack_to : DateTime.t option
    ; backtracked_from : DateTime.t option
    ; backtrack_request_creation_time : DateTime.t option
    ; status : String.t option
    }

  let make
      ?d_b_cluster_identifier
      ?backtrack_identifier
      ?backtrack_to
      ?backtracked_from
      ?backtrack_request_creation_time
      ?status
      () =
    { d_b_cluster_identifier
    ; backtrack_identifier
    ; backtrack_to
    ; backtracked_from
    ; backtrack_request_creation_time
    ; status
    }

  let parse xml =
    Some
      { d_b_cluster_identifier =
          Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse
      ; backtrack_identifier =
          Aws.Util.option_bind (Aws.Xml.member "BacktrackIdentifier" xml) String.parse
      ; backtrack_to =
          Aws.Util.option_bind (Aws.Xml.member "BacktrackTo" xml) DateTime.parse
      ; backtracked_from =
          Aws.Util.option_bind (Aws.Xml.member "BacktrackedFrom" xml) DateTime.parse
      ; backtrack_request_creation_time =
          Aws.Util.option_bind
            (Aws.Xml.member "BacktrackRequestCreationTime" xml)
            DateTime.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.backtrack_request_creation_time (fun f ->
               Aws.Query.Pair ("BacktrackRequestCreationTime", DateTime.to_query f))
         ; Aws.Util.option_map v.backtracked_from (fun f ->
               Aws.Query.Pair ("BacktrackedFrom", DateTime.to_query f))
         ; Aws.Util.option_map v.backtrack_to (fun f ->
               Aws.Query.Pair ("BacktrackTo", DateTime.to_query f))
         ; Aws.Util.option_map v.backtrack_identifier (fun f ->
               Aws.Query.Pair ("BacktrackIdentifier", String.to_query f))
         ; Aws.Util.option_map v.d_b_cluster_identifier (fun f ->
               Aws.Query.Pair ("DBClusterIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ; Aws.Util.option_map v.backtrack_request_creation_time (fun f ->
               "BacktrackRequestCreationTime", DateTime.to_json f)
         ; Aws.Util.option_map v.backtracked_from (fun f ->
               "BacktrackedFrom", DateTime.to_json f)
         ; Aws.Util.option_map v.backtrack_to (fun f -> "BacktrackTo", DateTime.to_json f)
         ; Aws.Util.option_map v.backtrack_identifier (fun f ->
               "BacktrackIdentifier", String.to_json f)
         ; Aws.Util.option_map v.d_b_cluster_identifier (fun f ->
               "DBClusterIdentifier", String.to_json f)
         ])

  let of_json j =
    { d_b_cluster_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "DBClusterIdentifier") String.of_json
    ; backtrack_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "BacktrackIdentifier") String.of_json
    ; backtrack_to =
        Aws.Util.option_map (Aws.Json.lookup j "BacktrackTo") DateTime.of_json
    ; backtracked_from =
        Aws.Util.option_map (Aws.Json.lookup j "BacktrackedFrom") DateTime.of_json
    ; backtrack_request_creation_time =
        Aws.Util.option_map
          (Aws.Json.lookup j "BacktrackRequestCreationTime")
          DateTime.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    }
end

module DBClusterBacktrackList = struct
  type t = DBClusterBacktrack.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map DBClusterBacktrack.parse (Aws.Xml.members "DBClusterBacktrack" xml))

  let to_query v = Aws.Query.to_query_list DBClusterBacktrack.to_query v

  let to_json v = `List (List.map DBClusterBacktrack.to_json v)

  let of_json j = Aws.Json.to_list DBClusterBacktrack.of_json j
end

module DBClusterBacktrackMessage = struct
  type t =
    { marker : String.t option
    ; d_b_cluster_backtracks : DBClusterBacktrackList.t
    }

  let make ?marker ?(d_b_cluster_backtracks = []) () = { marker; d_b_cluster_backtracks }

  let parse xml =
    Some
      { marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; d_b_cluster_backtracks =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DBClusterBacktracks" xml)
               DBClusterBacktrackList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "DBClusterBacktracks.member"
                , DBClusterBacktrackList.to_query v.d_b_cluster_backtracks ))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "DBClusterBacktracks"
             , DBClusterBacktrackList.to_json v.d_b_cluster_backtracks )
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ])

  let of_json j =
    { marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; d_b_cluster_backtracks =
        DBClusterBacktrackList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterBacktracks"))
    }
end

module CustomAvailabilityZoneList = struct
  type t = CustomAvailabilityZone.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         CustomAvailabilityZone.parse
         (Aws.Xml.members "CustomAvailabilityZone" xml))

  let to_query v = Aws.Query.to_query_list CustomAvailabilityZone.to_query v

  let to_json v = `List (List.map CustomAvailabilityZone.to_json v)

  let of_json j = Aws.Json.to_list CustomAvailabilityZone.of_json j
end

module RecurringCharge = struct
  type t =
    { recurring_charge_amount : Double.t option
    ; recurring_charge_frequency : String.t option
    }

  let make ?recurring_charge_amount ?recurring_charge_frequency () =
    { recurring_charge_amount; recurring_charge_frequency }

  let parse xml =
    Some
      { recurring_charge_amount =
          Aws.Util.option_bind (Aws.Xml.member "RecurringChargeAmount" xml) Double.parse
      ; recurring_charge_frequency =
          Aws.Util.option_bind
            (Aws.Xml.member "RecurringChargeFrequency" xml)
            String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.recurring_charge_frequency (fun f ->
               Aws.Query.Pair ("RecurringChargeFrequency", String.to_query f))
         ; Aws.Util.option_map v.recurring_charge_amount (fun f ->
               Aws.Query.Pair ("RecurringChargeAmount", Double.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.recurring_charge_frequency (fun f ->
               "RecurringChargeFrequency", String.to_json f)
         ; Aws.Util.option_map v.recurring_charge_amount (fun f ->
               "RecurringChargeAmount", Double.to_json f)
         ])

  let of_json j =
    { recurring_charge_amount =
        Aws.Util.option_map (Aws.Json.lookup j "RecurringChargeAmount") Double.of_json
    ; recurring_charge_frequency =
        Aws.Util.option_map (Aws.Json.lookup j "RecurringChargeFrequency") String.of_json
    }
end

module RecurringChargeList = struct
  type t = RecurringCharge.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map RecurringCharge.parse (Aws.Xml.members "RecurringCharge" xml))

  let to_query v = Aws.Query.to_query_list RecurringCharge.to_query v

  let to_json v = `List (List.map RecurringCharge.to_json v)

  let of_json j = Aws.Json.to_list RecurringCharge.of_json j
end

module ReservedDBInstancesOffering = struct
  type t =
    { reserved_d_b_instances_offering_id : String.t option
    ; d_b_instance_class : String.t option
    ; duration : Integer.t option
    ; fixed_price : Double.t option
    ; usage_price : Double.t option
    ; currency_code : String.t option
    ; product_description : String.t option
    ; offering_type : String.t option
    ; multi_a_z : Boolean.t option
    ; recurring_charges : RecurringChargeList.t
    }

  let make
      ?reserved_d_b_instances_offering_id
      ?d_b_instance_class
      ?duration
      ?fixed_price
      ?usage_price
      ?currency_code
      ?product_description
      ?offering_type
      ?multi_a_z
      ?(recurring_charges = [])
      () =
    { reserved_d_b_instances_offering_id
    ; d_b_instance_class
    ; duration
    ; fixed_price
    ; usage_price
    ; currency_code
    ; product_description
    ; offering_type
    ; multi_a_z
    ; recurring_charges
    }

  let parse xml =
    Some
      { reserved_d_b_instances_offering_id =
          Aws.Util.option_bind
            (Aws.Xml.member "ReservedDBInstancesOfferingId" xml)
            String.parse
      ; d_b_instance_class =
          Aws.Util.option_bind (Aws.Xml.member "DBInstanceClass" xml) String.parse
      ; duration = Aws.Util.option_bind (Aws.Xml.member "Duration" xml) Integer.parse
      ; fixed_price = Aws.Util.option_bind (Aws.Xml.member "FixedPrice" xml) Double.parse
      ; usage_price = Aws.Util.option_bind (Aws.Xml.member "UsagePrice" xml) Double.parse
      ; currency_code =
          Aws.Util.option_bind (Aws.Xml.member "CurrencyCode" xml) String.parse
      ; product_description =
          Aws.Util.option_bind (Aws.Xml.member "ProductDescription" xml) String.parse
      ; offering_type =
          Aws.Util.option_bind (Aws.Xml.member "OfferingType" xml) String.parse
      ; multi_a_z = Aws.Util.option_bind (Aws.Xml.member "MultiAZ" xml) Boolean.parse
      ; recurring_charges =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "RecurringCharges" xml)
               RecurringChargeList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "RecurringCharges.member"
                , RecurringChargeList.to_query v.recurring_charges ))
         ; Aws.Util.option_map v.multi_a_z (fun f ->
               Aws.Query.Pair ("MultiAZ", Boolean.to_query f))
         ; Aws.Util.option_map v.offering_type (fun f ->
               Aws.Query.Pair ("OfferingType", String.to_query f))
         ; Aws.Util.option_map v.product_description (fun f ->
               Aws.Query.Pair ("ProductDescription", String.to_query f))
         ; Aws.Util.option_map v.currency_code (fun f ->
               Aws.Query.Pair ("CurrencyCode", String.to_query f))
         ; Aws.Util.option_map v.usage_price (fun f ->
               Aws.Query.Pair ("UsagePrice", Double.to_query f))
         ; Aws.Util.option_map v.fixed_price (fun f ->
               Aws.Query.Pair ("FixedPrice", Double.to_query f))
         ; Aws.Util.option_map v.duration (fun f ->
               Aws.Query.Pair ("Duration", Integer.to_query f))
         ; Aws.Util.option_map v.d_b_instance_class (fun f ->
               Aws.Query.Pair ("DBInstanceClass", String.to_query f))
         ; Aws.Util.option_map v.reserved_d_b_instances_offering_id (fun f ->
               Aws.Query.Pair ("ReservedDBInstancesOfferingId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("RecurringCharges", RecurringChargeList.to_json v.recurring_charges)
         ; Aws.Util.option_map v.multi_a_z (fun f -> "MultiAZ", Boolean.to_json f)
         ; Aws.Util.option_map v.offering_type (fun f -> "OfferingType", String.to_json f)
         ; Aws.Util.option_map v.product_description (fun f ->
               "ProductDescription", String.to_json f)
         ; Aws.Util.option_map v.currency_code (fun f -> "CurrencyCode", String.to_json f)
         ; Aws.Util.option_map v.usage_price (fun f -> "UsagePrice", Double.to_json f)
         ; Aws.Util.option_map v.fixed_price (fun f -> "FixedPrice", Double.to_json f)
         ; Aws.Util.option_map v.duration (fun f -> "Duration", Integer.to_json f)
         ; Aws.Util.option_map v.d_b_instance_class (fun f ->
               "DBInstanceClass", String.to_json f)
         ; Aws.Util.option_map v.reserved_d_b_instances_offering_id (fun f ->
               "ReservedDBInstancesOfferingId", String.to_json f)
         ])

  let of_json j =
    { reserved_d_b_instances_offering_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "ReservedDBInstancesOfferingId")
          String.of_json
    ; d_b_instance_class =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstanceClass") String.of_json
    ; duration = Aws.Util.option_map (Aws.Json.lookup j "Duration") Integer.of_json
    ; fixed_price = Aws.Util.option_map (Aws.Json.lookup j "FixedPrice") Double.of_json
    ; usage_price = Aws.Util.option_map (Aws.Json.lookup j "UsagePrice") Double.of_json
    ; currency_code =
        Aws.Util.option_map (Aws.Json.lookup j "CurrencyCode") String.of_json
    ; product_description =
        Aws.Util.option_map (Aws.Json.lookup j "ProductDescription") String.of_json
    ; offering_type =
        Aws.Util.option_map (Aws.Json.lookup j "OfferingType") String.of_json
    ; multi_a_z = Aws.Util.option_map (Aws.Json.lookup j "MultiAZ") Boolean.of_json
    ; recurring_charges =
        RecurringChargeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "RecurringCharges"))
    }
end

module ReservedDBInstancesOfferingList = struct
  type t = ReservedDBInstancesOffering.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         ReservedDBInstancesOffering.parse
         (Aws.Xml.members "ReservedDBInstancesOffering" xml))

  let to_query v = Aws.Query.to_query_list ReservedDBInstancesOffering.to_query v

  let to_json v = `List (List.map ReservedDBInstancesOffering.to_json v)

  let of_json j = Aws.Json.to_list ReservedDBInstancesOffering.of_json j
end

module ReservedDBInstancesOfferingMessage = struct
  type t =
    { marker : String.t option
    ; reserved_d_b_instances_offerings : ReservedDBInstancesOfferingList.t
    }

  let make ?marker ?(reserved_d_b_instances_offerings = []) () =
    { marker; reserved_d_b_instances_offerings }

  let parse xml =
    Some
      { marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; reserved_d_b_instances_offerings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ReservedDBInstancesOfferings" xml)
               ReservedDBInstancesOfferingList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "ReservedDBInstancesOfferings.member"
                , ReservedDBInstancesOfferingList.to_query
                    v.reserved_d_b_instances_offerings ))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "ReservedDBInstancesOfferings"
             , ReservedDBInstancesOfferingList.to_json v.reserved_d_b_instances_offerings
             )
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ])

  let of_json j =
    { marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; reserved_d_b_instances_offerings =
        ReservedDBInstancesOfferingList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ReservedDBInstancesOfferings"))
    }
end

module EngineFamily = struct
  type t =
    | MYSQL
    | POSTGRESQL

  let str_to_t = [ "POSTGRESQL", POSTGRESQL; "MYSQL", MYSQL ]

  let t_to_str = [ POSTGRESQL, "POSTGRESQL"; MYSQL, "MYSQL" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module StartDBClusterResult = struct
  type t = { d_b_cluster : DBCluster.t option }

  let make ?d_b_cluster () = { d_b_cluster }

  let parse xml =
    Some
      { d_b_cluster =
          Aws.Util.option_bind (Aws.Xml.member "DBCluster" xml) DBCluster.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster (fun f ->
               Aws.Query.Pair ("DBCluster", DBCluster.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster (fun f -> "DBCluster", DBCluster.to_json f) ])

  let of_json j =
    { d_b_cluster = Aws.Util.option_map (Aws.Json.lookup j "DBCluster") DBCluster.of_json
    }
end

module BackupPolicyNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module EventSubscriptionQuotaExceededFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module CreateDBClusterEndpointMessage = struct
  type t =
    { d_b_cluster_identifier : String.t
    ; d_b_cluster_endpoint_identifier : String.t
    ; endpoint_type : String.t
    ; static_members : StringList.t
    ; excluded_members : StringList.t
    ; tags : TagList.t
    }

  let make
      ~d_b_cluster_identifier
      ~d_b_cluster_endpoint_identifier
      ~endpoint_type
      ?(static_members = [])
      ?(excluded_members = [])
      ?(tags = [])
      () =
    { d_b_cluster_identifier
    ; d_b_cluster_endpoint_identifier
    ; endpoint_type
    ; static_members
    ; excluded_members
    ; tags
    }

  let parse xml =
    Some
      { d_b_cluster_identifier =
          Aws.Xml.required
            "DBClusterIdentifier"
            (Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse)
      ; d_b_cluster_endpoint_identifier =
          Aws.Xml.required
            "DBClusterEndpointIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBClusterEndpointIdentifier" xml)
               String.parse)
      ; endpoint_type =
          Aws.Xml.required
            "EndpointType"
            (Aws.Util.option_bind (Aws.Xml.member "EndpointType" xml) String.parse)
      ; static_members =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "StaticMembers" xml) StringList.parse)
      ; excluded_members =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "ExcludedMembers" xml) StringList.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Some
             (Aws.Query.Pair
                ("ExcludedMembers.member", StringList.to_query v.excluded_members))
         ; Some
             (Aws.Query.Pair ("StaticMembers.member", StringList.to_query v.static_members))
         ; Some (Aws.Query.Pair ("EndpointType", String.to_query v.endpoint_type))
         ; Some
             (Aws.Query.Pair
                ( "DBClusterEndpointIdentifier"
                , String.to_query v.d_b_cluster_endpoint_identifier ))
         ; Some
             (Aws.Query.Pair
                ("DBClusterIdentifier", String.to_query v.d_b_cluster_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tags", TagList.to_json v.tags)
         ; Some ("ExcludedMembers", StringList.to_json v.excluded_members)
         ; Some ("StaticMembers", StringList.to_json v.static_members)
         ; Some ("EndpointType", String.to_json v.endpoint_type)
         ; Some
             ( "DBClusterEndpointIdentifier"
             , String.to_json v.d_b_cluster_endpoint_identifier )
         ; Some ("DBClusterIdentifier", String.to_json v.d_b_cluster_identifier)
         ])

  let of_json j =
    { d_b_cluster_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterIdentifier"))
    ; d_b_cluster_endpoint_identifier =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterEndpointIdentifier"))
    ; endpoint_type =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "EndpointType"))
    ; static_members =
        StringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "StaticMembers"))
    ; excluded_members =
        StringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ExcludedMembers"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    }
end

module FilterValueList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "Value" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module Filter = struct
  type t =
    { name : String.t
    ; values : FilterValueList.t
    }

  let make ~name ~values () = { name; values }

  let parse xml =
    Some
      { name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      ; values =
          Aws.Xml.required
            "Values"
            (Aws.Util.option_bind (Aws.Xml.member "Values" xml) FilterValueList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Values.member", FilterValueList.to_query v.values))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Values", FilterValueList.to_json v.values)
         ; Some ("Name", String.to_json v.name)
         ])

  let of_json j =
    { name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; values =
        FilterValueList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Values"))
    }
end

module FilterList = struct
  type t = Filter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Filter.parse (Aws.Xml.members "Filter" xml))

  let to_query v = Aws.Query.to_query_list Filter.to_query v

  let to_json v = `List (List.map Filter.to_json v)

  let of_json j = Aws.Json.to_list Filter.of_json j
end

module DescribeOrderableDBInstanceOptionsMessage = struct
  type t =
    { engine : String.t
    ; engine_version : String.t option
    ; d_b_instance_class : String.t option
    ; license_model : String.t option
    ; availability_zone_group : String.t option
    ; vpc : Boolean.t option
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    }

  let make
      ~engine
      ?engine_version
      ?d_b_instance_class
      ?license_model
      ?availability_zone_group
      ?vpc
      ?(filters = [])
      ?max_records
      ?marker
      () =
    { engine
    ; engine_version
    ; d_b_instance_class
    ; license_model
    ; availability_zone_group
    ; vpc
    ; filters
    ; max_records
    ; marker
    }

  let parse xml =
    Some
      { engine =
          Aws.Xml.required
            "Engine"
            (Aws.Util.option_bind (Aws.Xml.member "Engine" xml) String.parse)
      ; engine_version =
          Aws.Util.option_bind (Aws.Xml.member "EngineVersion" xml) String.parse
      ; d_b_instance_class =
          Aws.Util.option_bind (Aws.Xml.member "DBInstanceClass" xml) String.parse
      ; license_model =
          Aws.Util.option_bind (Aws.Xml.member "LicenseModel" xml) String.parse
      ; availability_zone_group =
          Aws.Util.option_bind (Aws.Xml.member "AvailabilityZoneGroup" xml) String.parse
      ; vpc = Aws.Util.option_bind (Aws.Xml.member "Vpc" xml) Boolean.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.vpc (fun f -> Aws.Query.Pair ("Vpc", Boolean.to_query f))
         ; Aws.Util.option_map v.availability_zone_group (fun f ->
               Aws.Query.Pair ("AvailabilityZoneGroup", String.to_query f))
         ; Aws.Util.option_map v.license_model (fun f ->
               Aws.Query.Pair ("LicenseModel", String.to_query f))
         ; Aws.Util.option_map v.d_b_instance_class (fun f ->
               Aws.Query.Pair ("DBInstanceClass", String.to_query f))
         ; Aws.Util.option_map v.engine_version (fun f ->
               Aws.Query.Pair ("EngineVersion", String.to_query f))
         ; Some (Aws.Query.Pair ("Engine", String.to_query v.engine))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.vpc (fun f -> "Vpc", Boolean.to_json f)
         ; Aws.Util.option_map v.availability_zone_group (fun f ->
               "AvailabilityZoneGroup", String.to_json f)
         ; Aws.Util.option_map v.license_model (fun f -> "LicenseModel", String.to_json f)
         ; Aws.Util.option_map v.d_b_instance_class (fun f ->
               "DBInstanceClass", String.to_json f)
         ; Aws.Util.option_map v.engine_version (fun f ->
               "EngineVersion", String.to_json f)
         ; Some ("Engine", String.to_json v.engine)
         ])

  let of_json j =
    { engine = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Engine"))
    ; engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "EngineVersion") String.of_json
    ; d_b_instance_class =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstanceClass") String.of_json
    ; license_model =
        Aws.Util.option_map (Aws.Json.lookup j "LicenseModel") String.of_json
    ; availability_zone_group =
        Aws.Util.option_map (Aws.Json.lookup j "AvailabilityZoneGroup") String.of_json
    ; vpc = Aws.Util.option_map (Aws.Json.lookup j "Vpc") Boolean.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module DBSubnetGroupNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module ReadReplicaDBClusterIdentifierList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map String.parse (Aws.Xml.members "ReadReplicaDBClusterIdentifier" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module AuthorizationQuotaExceededFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DescribeEventCategoriesMessage = struct
  type t =
    { source_type : String.t option
    ; filters : FilterList.t
    }

  let make ?source_type ?(filters = []) () = { source_type; filters }

  let parse xml =
    Some
      { source_type = Aws.Util.option_bind (Aws.Xml.member "SourceType" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.source_type (fun f ->
               Aws.Query.Pair ("SourceType", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.source_type (fun f -> "SourceType", String.to_json f)
         ])

  let of_json j =
    { source_type = Aws.Util.option_map (Aws.Json.lookup j "SourceType") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    }
end

module DeleteDBProxyRequest = struct
  type t = { d_b_proxy_name : String.t }

  let make ~d_b_proxy_name () = { d_b_proxy_name }

  let parse xml =
    Some
      { d_b_proxy_name =
          Aws.Xml.required
            "DBProxyName"
            (Aws.Util.option_bind (Aws.Xml.member "DBProxyName" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("DBProxyName", String.to_query v.d_b_proxy_name)) ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt [ Some ("DBProxyName", String.to_json v.d_b_proxy_name) ])

  let of_json j =
    { d_b_proxy_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBProxyName"))
    }
end

module KMSKeyNotAccessibleFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DBProxyNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module Outpost = struct
  type t = { arn : String.t option }

  let make ?arn () = { arn }

  let parse xml =
    Some { arn = Aws.Util.option_bind (Aws.Xml.member "Arn" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.arn (fun f -> Aws.Query.Pair ("Arn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.arn (fun f -> "Arn", String.to_json f) ])

  let of_json j = { arn = Aws.Util.option_map (Aws.Json.lookup j "Arn") String.of_json }
end

module AvailabilityZone = struct
  type t = { name : String.t option }

  let make ?name () = { name }

  let parse xml =
    Some { name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.name (fun f -> "Name", String.to_json f) ])

  let of_json j = { name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json }
end

module Subnet = struct
  type t =
    { subnet_identifier : String.t option
    ; subnet_availability_zone : AvailabilityZone.t option
    ; subnet_outpost : Outpost.t option
    ; subnet_status : String.t option
    }

  let make ?subnet_identifier ?subnet_availability_zone ?subnet_outpost ?subnet_status ()
      =
    { subnet_identifier; subnet_availability_zone; subnet_outpost; subnet_status }

  let parse xml =
    Some
      { subnet_identifier =
          Aws.Util.option_bind (Aws.Xml.member "SubnetIdentifier" xml) String.parse
      ; subnet_availability_zone =
          Aws.Util.option_bind
            (Aws.Xml.member "SubnetAvailabilityZone" xml)
            AvailabilityZone.parse
      ; subnet_outpost =
          Aws.Util.option_bind (Aws.Xml.member "SubnetOutpost" xml) Outpost.parse
      ; subnet_status =
          Aws.Util.option_bind (Aws.Xml.member "SubnetStatus" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.subnet_status (fun f ->
               Aws.Query.Pair ("SubnetStatus", String.to_query f))
         ; Aws.Util.option_map v.subnet_outpost (fun f ->
               Aws.Query.Pair ("SubnetOutpost", Outpost.to_query f))
         ; Aws.Util.option_map v.subnet_availability_zone (fun f ->
               Aws.Query.Pair ("SubnetAvailabilityZone", AvailabilityZone.to_query f))
         ; Aws.Util.option_map v.subnet_identifier (fun f ->
               Aws.Query.Pair ("SubnetIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.subnet_status (fun f -> "SubnetStatus", String.to_json f)
         ; Aws.Util.option_map v.subnet_outpost (fun f ->
               "SubnetOutpost", Outpost.to_json f)
         ; Aws.Util.option_map v.subnet_availability_zone (fun f ->
               "SubnetAvailabilityZone", AvailabilityZone.to_json f)
         ; Aws.Util.option_map v.subnet_identifier (fun f ->
               "SubnetIdentifier", String.to_json f)
         ])

  let of_json j =
    { subnet_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "SubnetIdentifier") String.of_json
    ; subnet_availability_zone =
        Aws.Util.option_map
          (Aws.Json.lookup j "SubnetAvailabilityZone")
          AvailabilityZone.of_json
    ; subnet_outpost =
        Aws.Util.option_map (Aws.Json.lookup j "SubnetOutpost") Outpost.of_json
    ; subnet_status =
        Aws.Util.option_map (Aws.Json.lookup j "SubnetStatus") String.of_json
    }
end

module SubnetList = struct
  type t = Subnet.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Subnet.parse (Aws.Xml.members "Subnet" xml))

  let to_query v = Aws.Query.to_query_list Subnet.to_query v

  let to_json v = `List (List.map Subnet.to_json v)

  let of_json j = Aws.Json.to_list Subnet.of_json j
end

module DBSubnetGroup = struct
  type t =
    { d_b_subnet_group_name : String.t option
    ; d_b_subnet_group_description : String.t option
    ; vpc_id : String.t option
    ; subnet_group_status : String.t option
    ; subnets : SubnetList.t
    ; d_b_subnet_group_arn : String.t option
    }

  let make
      ?d_b_subnet_group_name
      ?d_b_subnet_group_description
      ?vpc_id
      ?subnet_group_status
      ?(subnets = [])
      ?d_b_subnet_group_arn
      () =
    { d_b_subnet_group_name
    ; d_b_subnet_group_description
    ; vpc_id
    ; subnet_group_status
    ; subnets
    ; d_b_subnet_group_arn
    }

  let parse xml =
    Some
      { d_b_subnet_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBSubnetGroupName" xml) String.parse
      ; d_b_subnet_group_description =
          Aws.Util.option_bind
            (Aws.Xml.member "DBSubnetGroupDescription" xml)
            String.parse
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) String.parse
      ; subnet_group_status =
          Aws.Util.option_bind (Aws.Xml.member "SubnetGroupStatus" xml) String.parse
      ; subnets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Subnets" xml) SubnetList.parse)
      ; d_b_subnet_group_arn =
          Aws.Util.option_bind (Aws.Xml.member "DBSubnetGroupArn" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_subnet_group_arn (fun f ->
               Aws.Query.Pair ("DBSubnetGroupArn", String.to_query f))
         ; Some (Aws.Query.Pair ("Subnets.member", SubnetList.to_query v.subnets))
         ; Aws.Util.option_map v.subnet_group_status (fun f ->
               Aws.Query.Pair ("SubnetGroupStatus", String.to_query f))
         ; Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Aws.Util.option_map v.d_b_subnet_group_description (fun f ->
               Aws.Query.Pair ("DBSubnetGroupDescription", String.to_query f))
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               Aws.Query.Pair ("DBSubnetGroupName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_subnet_group_arn (fun f ->
               "DBSubnetGroupArn", String.to_json f)
         ; Some ("Subnets", SubnetList.to_json v.subnets)
         ; Aws.Util.option_map v.subnet_group_status (fun f ->
               "SubnetGroupStatus", String.to_json f)
         ; Aws.Util.option_map v.vpc_id (fun f -> "VpcId", String.to_json f)
         ; Aws.Util.option_map v.d_b_subnet_group_description (fun f ->
               "DBSubnetGroupDescription", String.to_json f)
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               "DBSubnetGroupName", String.to_json f)
         ])

  let of_json j =
    { d_b_subnet_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBSubnetGroupName") String.of_json
    ; d_b_subnet_group_description =
        Aws.Util.option_map (Aws.Json.lookup j "DBSubnetGroupDescription") String.of_json
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "VpcId") String.of_json
    ; subnet_group_status =
        Aws.Util.option_map (Aws.Json.lookup j "SubnetGroupStatus") String.of_json
    ; subnets = SubnetList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Subnets"))
    ; d_b_subnet_group_arn =
        Aws.Util.option_map (Aws.Json.lookup j "DBSubnetGroupArn") String.of_json
    }
end

module DBSubnetGroups = struct
  type t = DBSubnetGroup.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map DBSubnetGroup.parse (Aws.Xml.members "DBSubnetGroup" xml))

  let to_query v = Aws.Query.to_query_list DBSubnetGroup.to_query v

  let to_json v = `List (List.map DBSubnetGroup.to_json v)

  let of_json j = Aws.Json.to_list DBSubnetGroup.of_json j
end

module TargetType = struct
  type t =
    | RDS_INSTANCE
    | RDS_SERVERLESS_ENDPOINT
    | TRACKED_CLUSTER

  let str_to_t =
    [ "TRACKED_CLUSTER", TRACKED_CLUSTER
    ; "RDS_SERVERLESS_ENDPOINT", RDS_SERVERLESS_ENDPOINT
    ; "RDS_INSTANCE", RDS_INSTANCE
    ]

  let t_to_str =
    [ TRACKED_CLUSTER, "TRACKED_CLUSTER"
    ; RDS_SERVERLESS_ENDPOINT, "RDS_SERVERLESS_ENDPOINT"
    ; RDS_INSTANCE, "RDS_INSTANCE"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module TargetState = struct
  type t =
    | REGISTERING
    | AVAILABLE
    | UNAVAILABLE

  let str_to_t =
    [ "UNAVAILABLE", UNAVAILABLE; "AVAILABLE", AVAILABLE; "REGISTERING", REGISTERING ]

  let t_to_str =
    [ UNAVAILABLE, "UNAVAILABLE"; AVAILABLE, "AVAILABLE"; REGISTERING, "REGISTERING" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module TargetHealthReason = struct
  type t =
    | UNREACHABLE
    | CONNECTION_FAILED
    | AUTH_FAILURE
    | PENDING_PROXY_CAPACITY

  let str_to_t =
    [ "PENDING_PROXY_CAPACITY", PENDING_PROXY_CAPACITY
    ; "AUTH_FAILURE", AUTH_FAILURE
    ; "CONNECTION_FAILED", CONNECTION_FAILED
    ; "UNREACHABLE", UNREACHABLE
    ]

  let t_to_str =
    [ PENDING_PROXY_CAPACITY, "PENDING_PROXY_CAPACITY"
    ; AUTH_FAILURE, "AUTH_FAILURE"
    ; CONNECTION_FAILED, "CONNECTION_FAILED"
    ; UNREACHABLE, "UNREACHABLE"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module TargetHealth = struct
  type t =
    { state : TargetState.t option
    ; reason : TargetHealthReason.t option
    ; description : String.t option
    }

  let make ?state ?reason ?description () = { state; reason; description }

  let parse xml =
    Some
      { state = Aws.Util.option_bind (Aws.Xml.member "State" xml) TargetState.parse
      ; reason =
          Aws.Util.option_bind (Aws.Xml.member "Reason" xml) TargetHealthReason.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.reason (fun f ->
               Aws.Query.Pair ("Reason", TargetHealthReason.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", TargetState.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.reason (fun f -> "Reason", TargetHealthReason.to_json f)
         ; Aws.Util.option_map v.state (fun f -> "State", TargetState.to_json f)
         ])

  let of_json j =
    { state = Aws.Util.option_map (Aws.Json.lookup j "State") TargetState.of_json
    ; reason = Aws.Util.option_map (Aws.Json.lookup j "Reason") TargetHealthReason.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    }
end

module DBProxyTarget = struct
  type t =
    { target_arn : String.t option
    ; endpoint : String.t option
    ; tracked_cluster_id : String.t option
    ; rds_resource_id : String.t option
    ; port : Integer.t option
    ; type_ : TargetType.t option
    ; target_health : TargetHealth.t option
    }

  let make
      ?target_arn
      ?endpoint
      ?tracked_cluster_id
      ?rds_resource_id
      ?port
      ?type_
      ?target_health
      () =
    { target_arn
    ; endpoint
    ; tracked_cluster_id
    ; rds_resource_id
    ; port
    ; type_
    ; target_health
    }

  let parse xml =
    Some
      { target_arn = Aws.Util.option_bind (Aws.Xml.member "TargetArn" xml) String.parse
      ; endpoint = Aws.Util.option_bind (Aws.Xml.member "Endpoint" xml) String.parse
      ; tracked_cluster_id =
          Aws.Util.option_bind (Aws.Xml.member "TrackedClusterId" xml) String.parse
      ; rds_resource_id =
          Aws.Util.option_bind (Aws.Xml.member "RdsResourceId" xml) String.parse
      ; port = Aws.Util.option_bind (Aws.Xml.member "Port" xml) Integer.parse
      ; type_ = Aws.Util.option_bind (Aws.Xml.member "Type" xml) TargetType.parse
      ; target_health =
          Aws.Util.option_bind (Aws.Xml.member "TargetHealth" xml) TargetHealth.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.target_health (fun f ->
               Aws.Query.Pair ("TargetHealth", TargetHealth.to_query f))
         ; Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", TargetType.to_query f))
         ; Aws.Util.option_map v.port (fun f ->
               Aws.Query.Pair ("Port", Integer.to_query f))
         ; Aws.Util.option_map v.rds_resource_id (fun f ->
               Aws.Query.Pair ("RdsResourceId", String.to_query f))
         ; Aws.Util.option_map v.tracked_cluster_id (fun f ->
               Aws.Query.Pair ("TrackedClusterId", String.to_query f))
         ; Aws.Util.option_map v.endpoint (fun f ->
               Aws.Query.Pair ("Endpoint", String.to_query f))
         ; Aws.Util.option_map v.target_arn (fun f ->
               Aws.Query.Pair ("TargetArn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.target_health (fun f ->
               "TargetHealth", TargetHealth.to_json f)
         ; Aws.Util.option_map v.type_ (fun f -> "Type", TargetType.to_json f)
         ; Aws.Util.option_map v.port (fun f -> "Port", Integer.to_json f)
         ; Aws.Util.option_map v.rds_resource_id (fun f ->
               "RdsResourceId", String.to_json f)
         ; Aws.Util.option_map v.tracked_cluster_id (fun f ->
               "TrackedClusterId", String.to_json f)
         ; Aws.Util.option_map v.endpoint (fun f -> "Endpoint", String.to_json f)
         ; Aws.Util.option_map v.target_arn (fun f -> "TargetArn", String.to_json f)
         ])

  let of_json j =
    { target_arn = Aws.Util.option_map (Aws.Json.lookup j "TargetArn") String.of_json
    ; endpoint = Aws.Util.option_map (Aws.Json.lookup j "Endpoint") String.of_json
    ; tracked_cluster_id =
        Aws.Util.option_map (Aws.Json.lookup j "TrackedClusterId") String.of_json
    ; rds_resource_id =
        Aws.Util.option_map (Aws.Json.lookup j "RdsResourceId") String.of_json
    ; port = Aws.Util.option_map (Aws.Json.lookup j "Port") Integer.of_json
    ; type_ = Aws.Util.option_map (Aws.Json.lookup j "Type") TargetType.of_json
    ; target_health =
        Aws.Util.option_map (Aws.Json.lookup j "TargetHealth") TargetHealth.of_json
    }
end

module TargetList = struct
  type t = DBProxyTarget.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map DBProxyTarget.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list DBProxyTarget.to_query v

  let to_json v = `List (List.map DBProxyTarget.to_json v)

  let of_json j = Aws.Json.to_list DBProxyTarget.of_json j
end

module DescribeDBProxyTargetsResponse = struct
  type t =
    { targets : TargetList.t
    ; marker : String.t option
    }

  let make ?(targets = []) ?marker () = { targets; marker }

  let parse xml =
    Some
      { targets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Targets" xml) TargetList.parse)
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Some (Aws.Query.Pair ("Targets.member", TargetList.to_query v.targets))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Some ("Targets", TargetList.to_json v.targets)
         ])

  let of_json j =
    { targets = TargetList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Targets"))
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module AttributeValueList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "AttributeValue" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DBSnapshotAttribute = struct
  type t =
    { attribute_name : String.t option
    ; attribute_values : AttributeValueList.t
    }

  let make ?attribute_name ?(attribute_values = []) () =
    { attribute_name; attribute_values }

  let parse xml =
    Some
      { attribute_name =
          Aws.Util.option_bind (Aws.Xml.member "AttributeName" xml) String.parse
      ; attribute_values =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AttributeValues" xml)
               AttributeValueList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("AttributeValues.member", AttributeValueList.to_query v.attribute_values))
         ; Aws.Util.option_map v.attribute_name (fun f ->
               Aws.Query.Pair ("AttributeName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("AttributeValues", AttributeValueList.to_json v.attribute_values)
         ; Aws.Util.option_map v.attribute_name (fun f ->
               "AttributeName", String.to_json f)
         ])

  let of_json j =
    { attribute_name =
        Aws.Util.option_map (Aws.Json.lookup j "AttributeName") String.of_json
    ; attribute_values =
        AttributeValueList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AttributeValues"))
    }
end

module DBSnapshotAttributeList = struct
  type t = DBSnapshotAttribute.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map DBSnapshotAttribute.parse (Aws.Xml.members "DBSnapshotAttribute" xml))

  let to_query v = Aws.Query.to_query_list DBSnapshotAttribute.to_query v

  let to_json v = `List (List.map DBSnapshotAttribute.to_json v)

  let of_json j = Aws.Json.to_list DBSnapshotAttribute.of_json j
end

module DBSnapshotAttributesResult = struct
  type t =
    { d_b_snapshot_identifier : String.t option
    ; d_b_snapshot_attributes : DBSnapshotAttributeList.t
    }

  let make ?d_b_snapshot_identifier ?(d_b_snapshot_attributes = []) () =
    { d_b_snapshot_identifier; d_b_snapshot_attributes }

  let parse xml =
    Some
      { d_b_snapshot_identifier =
          Aws.Util.option_bind (Aws.Xml.member "DBSnapshotIdentifier" xml) String.parse
      ; d_b_snapshot_attributes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DBSnapshotAttributes" xml)
               DBSnapshotAttributeList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "DBSnapshotAttributes.member"
                , DBSnapshotAttributeList.to_query v.d_b_snapshot_attributes ))
         ; Aws.Util.option_map v.d_b_snapshot_identifier (fun f ->
               Aws.Query.Pair ("DBSnapshotIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "DBSnapshotAttributes"
             , DBSnapshotAttributeList.to_json v.d_b_snapshot_attributes )
         ; Aws.Util.option_map v.d_b_snapshot_identifier (fun f ->
               "DBSnapshotIdentifier", String.to_json f)
         ])

  let of_json j =
    { d_b_snapshot_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "DBSnapshotIdentifier") String.of_json
    ; d_b_snapshot_attributes =
        DBSnapshotAttributeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBSnapshotAttributes"))
    }
end

module ModifyDBSnapshotAttributeResult = struct
  type t = { d_b_snapshot_attributes_result : DBSnapshotAttributesResult.t option }

  let make ?d_b_snapshot_attributes_result () = { d_b_snapshot_attributes_result }

  let parse xml =
    Some
      { d_b_snapshot_attributes_result =
          Aws.Util.option_bind
            (Aws.Xml.member "DBSnapshotAttributesResult" xml)
            DBSnapshotAttributesResult.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_snapshot_attributes_result (fun f ->
               Aws.Query.Pair
                 ("DBSnapshotAttributesResult", DBSnapshotAttributesResult.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_snapshot_attributes_result (fun f ->
               "DBSnapshotAttributesResult", DBSnapshotAttributesResult.to_json f)
         ])

  let of_json j =
    { d_b_snapshot_attributes_result =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBSnapshotAttributesResult")
          DBSnapshotAttributesResult.of_json
    }
end

module DBClusterParameterGroup = struct
  type t =
    { d_b_cluster_parameter_group_name : String.t option
    ; d_b_parameter_group_family : String.t option
    ; description : String.t option
    ; d_b_cluster_parameter_group_arn : String.t option
    }

  let make
      ?d_b_cluster_parameter_group_name
      ?d_b_parameter_group_family
      ?description
      ?d_b_cluster_parameter_group_arn
      () =
    { d_b_cluster_parameter_group_name
    ; d_b_parameter_group_family
    ; description
    ; d_b_cluster_parameter_group_arn
    }

  let parse xml =
    Some
      { d_b_cluster_parameter_group_name =
          Aws.Util.option_bind
            (Aws.Xml.member "DBClusterParameterGroupName" xml)
            String.parse
      ; d_b_parameter_group_family =
          Aws.Util.option_bind (Aws.Xml.member "DBParameterGroupFamily" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; d_b_cluster_parameter_group_arn =
          Aws.Util.option_bind
            (Aws.Xml.member "DBClusterParameterGroupArn" xml)
            String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster_parameter_group_arn (fun f ->
               Aws.Query.Pair ("DBClusterParameterGroupArn", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.d_b_parameter_group_family (fun f ->
               Aws.Query.Pair ("DBParameterGroupFamily", String.to_query f))
         ; Aws.Util.option_map v.d_b_cluster_parameter_group_name (fun f ->
               Aws.Query.Pair ("DBClusterParameterGroupName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster_parameter_group_arn (fun f ->
               "DBClusterParameterGroupArn", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.d_b_parameter_group_family (fun f ->
               "DBParameterGroupFamily", String.to_json f)
         ; Aws.Util.option_map v.d_b_cluster_parameter_group_name (fun f ->
               "DBClusterParameterGroupName", String.to_json f)
         ])

  let of_json j =
    { d_b_cluster_parameter_group_name =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBClusterParameterGroupName")
          String.of_json
    ; d_b_parameter_group_family =
        Aws.Util.option_map (Aws.Json.lookup j "DBParameterGroupFamily") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; d_b_cluster_parameter_group_arn =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBClusterParameterGroupArn")
          String.of_json
    }
end

module KeyList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module RemoveTagsFromResourceMessage = struct
  type t =
    { resource_name : String.t
    ; tag_keys : KeyList.t
    }

  let make ~resource_name ~tag_keys () = { resource_name; tag_keys }

  let parse xml =
    Some
      { resource_name =
          Aws.Xml.required
            "ResourceName"
            (Aws.Util.option_bind (Aws.Xml.member "ResourceName" xml) String.parse)
      ; tag_keys =
          Aws.Xml.required
            "TagKeys"
            (Aws.Util.option_bind (Aws.Xml.member "TagKeys" xml) KeyList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagKeys.member", KeyList.to_query v.tag_keys))
         ; Some (Aws.Query.Pair ("ResourceName", String.to_query v.resource_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagKeys", KeyList.to_json v.tag_keys)
         ; Some ("ResourceName", String.to_json v.resource_name)
         ])

  let of_json j =
    { resource_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ResourceName"))
    ; tag_keys = KeyList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TagKeys"))
    }
end

module MinimumEngineVersionPerAllowedValue = struct
  type t =
    { allowed_value : String.t option
    ; minimum_engine_version : String.t option
    }

  let make ?allowed_value ?minimum_engine_version () =
    { allowed_value; minimum_engine_version }

  let parse xml =
    Some
      { allowed_value =
          Aws.Util.option_bind (Aws.Xml.member "AllowedValue" xml) String.parse
      ; minimum_engine_version =
          Aws.Util.option_bind (Aws.Xml.member "MinimumEngineVersion" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.minimum_engine_version (fun f ->
               Aws.Query.Pair ("MinimumEngineVersion", String.to_query f))
         ; Aws.Util.option_map v.allowed_value (fun f ->
               Aws.Query.Pair ("AllowedValue", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.minimum_engine_version (fun f ->
               "MinimumEngineVersion", String.to_json f)
         ; Aws.Util.option_map v.allowed_value (fun f -> "AllowedValue", String.to_json f)
         ])

  let of_json j =
    { allowed_value =
        Aws.Util.option_map (Aws.Json.lookup j "AllowedValue") String.of_json
    ; minimum_engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "MinimumEngineVersion") String.of_json
    }
end

module DeleteInstallationMediaMessage = struct
  type t = { installation_media_id : String.t }

  let make ~installation_media_id () = { installation_media_id }

  let parse xml =
    Some
      { installation_media_id =
          Aws.Xml.required
            "InstallationMediaId"
            (Aws.Util.option_bind (Aws.Xml.member "InstallationMediaId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("InstallationMediaId", String.to_query v.installation_media_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("InstallationMediaId", String.to_json v.installation_media_id) ])

  let of_json j =
    { installation_media_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstallationMediaId"))
    }
end

module StopDBInstanceMessage = struct
  type t =
    { d_b_instance_identifier : String.t
    ; d_b_snapshot_identifier : String.t option
    }

  let make ~d_b_instance_identifier ?d_b_snapshot_identifier () =
    { d_b_instance_identifier; d_b_snapshot_identifier }

  let parse xml =
    Some
      { d_b_instance_identifier =
          Aws.Xml.required
            "DBInstanceIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBInstanceIdentifier" xml)
               String.parse)
      ; d_b_snapshot_identifier =
          Aws.Util.option_bind (Aws.Xml.member "DBSnapshotIdentifier" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_snapshot_identifier (fun f ->
               Aws.Query.Pair ("DBSnapshotIdentifier", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DBInstanceIdentifier", String.to_query v.d_b_instance_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_snapshot_identifier (fun f ->
               "DBSnapshotIdentifier", String.to_json f)
         ; Some ("DBInstanceIdentifier", String.to_json v.d_b_instance_identifier)
         ])

  let of_json j =
    { d_b_instance_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBInstanceIdentifier"))
    ; d_b_snapshot_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "DBSnapshotIdentifier") String.of_json
    }
end

module EngineModeList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module AvailableProcessorFeature = struct
  type t =
    { name : String.t option
    ; default_value : String.t option
    ; allowed_values : String.t option
    }

  let make ?name ?default_value ?allowed_values () =
    { name; default_value; allowed_values }

  let parse xml =
    Some
      { name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; default_value =
          Aws.Util.option_bind (Aws.Xml.member "DefaultValue" xml) String.parse
      ; allowed_values =
          Aws.Util.option_bind (Aws.Xml.member "AllowedValues" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.allowed_values (fun f ->
               Aws.Query.Pair ("AllowedValues", String.to_query f))
         ; Aws.Util.option_map v.default_value (fun f ->
               Aws.Query.Pair ("DefaultValue", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.allowed_values (fun f ->
               "AllowedValues", String.to_json f)
         ; Aws.Util.option_map v.default_value (fun f -> "DefaultValue", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ])

  let of_json j =
    { name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; default_value =
        Aws.Util.option_map (Aws.Json.lookup j "DefaultValue") String.of_json
    ; allowed_values =
        Aws.Util.option_map (Aws.Json.lookup j "AllowedValues") String.of_json
    }
end

module AvailableProcessorFeatureList = struct
  type t = AvailableProcessorFeature.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         AvailableProcessorFeature.parse
         (Aws.Xml.members "AvailableProcessorFeature" xml))

  let to_query v = Aws.Query.to_query_list AvailableProcessorFeature.to_query v

  let to_json v = `List (List.map AvailableProcessorFeature.to_json v)

  let of_json j = Aws.Json.to_list AvailableProcessorFeature.of_json j
end

module AvailabilityZoneList = struct
  type t = AvailabilityZone.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map AvailabilityZone.parse (Aws.Xml.members "AvailabilityZone" xml))

  let to_query v = Aws.Query.to_query_list AvailabilityZone.to_query v

  let to_json v = `List (List.map AvailabilityZone.to_json v)

  let of_json j = Aws.Json.to_list AvailabilityZone.of_json j
end

module OrderableDBInstanceOption = struct
  type t =
    { engine : String.t option
    ; engine_version : String.t option
    ; d_b_instance_class : String.t option
    ; license_model : String.t option
    ; availability_zone_group : String.t option
    ; availability_zones : AvailabilityZoneList.t
    ; multi_a_z_capable : Boolean.t option
    ; read_replica_capable : Boolean.t option
    ; vpc : Boolean.t option
    ; supports_storage_encryption : Boolean.t option
    ; storage_type : String.t option
    ; supports_iops : Boolean.t option
    ; supports_enhanced_monitoring : Boolean.t option
    ; supports_i_a_m_database_authentication : Boolean.t option
    ; supports_performance_insights : Boolean.t option
    ; min_storage_size : Integer.t option
    ; max_storage_size : Integer.t option
    ; min_iops_per_db_instance : Integer.t option
    ; max_iops_per_db_instance : Integer.t option
    ; min_iops_per_gib : Double.t option
    ; max_iops_per_gib : Double.t option
    ; available_processor_features : AvailableProcessorFeatureList.t
    ; supported_engine_modes : EngineModeList.t
    ; supports_storage_autoscaling : Boolean.t option
    ; supports_kerberos_authentication : Boolean.t option
    ; outpost_capable : Boolean.t option
    ; supports_global_databases : Boolean.t option
    }

  let make
      ?engine
      ?engine_version
      ?d_b_instance_class
      ?license_model
      ?availability_zone_group
      ?(availability_zones = [])
      ?multi_a_z_capable
      ?read_replica_capable
      ?vpc
      ?supports_storage_encryption
      ?storage_type
      ?supports_iops
      ?supports_enhanced_monitoring
      ?supports_i_a_m_database_authentication
      ?supports_performance_insights
      ?min_storage_size
      ?max_storage_size
      ?min_iops_per_db_instance
      ?max_iops_per_db_instance
      ?min_iops_per_gib
      ?max_iops_per_gib
      ?(available_processor_features = [])
      ?(supported_engine_modes = [])
      ?supports_storage_autoscaling
      ?supports_kerberos_authentication
      ?outpost_capable
      ?supports_global_databases
      () =
    { engine
    ; engine_version
    ; d_b_instance_class
    ; license_model
    ; availability_zone_group
    ; availability_zones
    ; multi_a_z_capable
    ; read_replica_capable
    ; vpc
    ; supports_storage_encryption
    ; storage_type
    ; supports_iops
    ; supports_enhanced_monitoring
    ; supports_i_a_m_database_authentication
    ; supports_performance_insights
    ; min_storage_size
    ; max_storage_size
    ; min_iops_per_db_instance
    ; max_iops_per_db_instance
    ; min_iops_per_gib
    ; max_iops_per_gib
    ; available_processor_features
    ; supported_engine_modes
    ; supports_storage_autoscaling
    ; supports_kerberos_authentication
    ; outpost_capable
    ; supports_global_databases
    }

  let parse xml =
    Some
      { engine = Aws.Util.option_bind (Aws.Xml.member "Engine" xml) String.parse
      ; engine_version =
          Aws.Util.option_bind (Aws.Xml.member "EngineVersion" xml) String.parse
      ; d_b_instance_class =
          Aws.Util.option_bind (Aws.Xml.member "DBInstanceClass" xml) String.parse
      ; license_model =
          Aws.Util.option_bind (Aws.Xml.member "LicenseModel" xml) String.parse
      ; availability_zone_group =
          Aws.Util.option_bind (Aws.Xml.member "AvailabilityZoneGroup" xml) String.parse
      ; availability_zones =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AvailabilityZones" xml)
               AvailabilityZoneList.parse)
      ; multi_a_z_capable =
          Aws.Util.option_bind (Aws.Xml.member "MultiAZCapable" xml) Boolean.parse
      ; read_replica_capable =
          Aws.Util.option_bind (Aws.Xml.member "ReadReplicaCapable" xml) Boolean.parse
      ; vpc = Aws.Util.option_bind (Aws.Xml.member "Vpc" xml) Boolean.parse
      ; supports_storage_encryption =
          Aws.Util.option_bind
            (Aws.Xml.member "SupportsStorageEncryption" xml)
            Boolean.parse
      ; storage_type =
          Aws.Util.option_bind (Aws.Xml.member "StorageType" xml) String.parse
      ; supports_iops =
          Aws.Util.option_bind (Aws.Xml.member "SupportsIops" xml) Boolean.parse
      ; supports_enhanced_monitoring =
          Aws.Util.option_bind
            (Aws.Xml.member "SupportsEnhancedMonitoring" xml)
            Boolean.parse
      ; supports_i_a_m_database_authentication =
          Aws.Util.option_bind
            (Aws.Xml.member "SupportsIAMDatabaseAuthentication" xml)
            Boolean.parse
      ; supports_performance_insights =
          Aws.Util.option_bind
            (Aws.Xml.member "SupportsPerformanceInsights" xml)
            Boolean.parse
      ; min_storage_size =
          Aws.Util.option_bind (Aws.Xml.member "MinStorageSize" xml) Integer.parse
      ; max_storage_size =
          Aws.Util.option_bind (Aws.Xml.member "MaxStorageSize" xml) Integer.parse
      ; min_iops_per_db_instance =
          Aws.Util.option_bind (Aws.Xml.member "MinIopsPerDbInstance" xml) Integer.parse
      ; max_iops_per_db_instance =
          Aws.Util.option_bind (Aws.Xml.member "MaxIopsPerDbInstance" xml) Integer.parse
      ; min_iops_per_gib =
          Aws.Util.option_bind (Aws.Xml.member "MinIopsPerGib" xml) Double.parse
      ; max_iops_per_gib =
          Aws.Util.option_bind (Aws.Xml.member "MaxIopsPerGib" xml) Double.parse
      ; available_processor_features =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AvailableProcessorFeatures" xml)
               AvailableProcessorFeatureList.parse)
      ; supported_engine_modes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SupportedEngineModes" xml)
               EngineModeList.parse)
      ; supports_storage_autoscaling =
          Aws.Util.option_bind
            (Aws.Xml.member "SupportsStorageAutoscaling" xml)
            Boolean.parse
      ; supports_kerberos_authentication =
          Aws.Util.option_bind
            (Aws.Xml.member "SupportsKerberosAuthentication" xml)
            Boolean.parse
      ; outpost_capable =
          Aws.Util.option_bind (Aws.Xml.member "OutpostCapable" xml) Boolean.parse
      ; supports_global_databases =
          Aws.Util.option_bind
            (Aws.Xml.member "SupportsGlobalDatabases" xml)
            Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.supports_global_databases (fun f ->
               Aws.Query.Pair ("SupportsGlobalDatabases", Boolean.to_query f))
         ; Aws.Util.option_map v.outpost_capable (fun f ->
               Aws.Query.Pair ("OutpostCapable", Boolean.to_query f))
         ; Aws.Util.option_map v.supports_kerberos_authentication (fun f ->
               Aws.Query.Pair ("SupportsKerberosAuthentication", Boolean.to_query f))
         ; Aws.Util.option_map v.supports_storage_autoscaling (fun f ->
               Aws.Query.Pair ("SupportsStorageAutoscaling", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "SupportedEngineModes.member"
                , EngineModeList.to_query v.supported_engine_modes ))
         ; Some
             (Aws.Query.Pair
                ( "AvailableProcessorFeatures.member"
                , AvailableProcessorFeatureList.to_query v.available_processor_features ))
         ; Aws.Util.option_map v.max_iops_per_gib (fun f ->
               Aws.Query.Pair ("MaxIopsPerGib", Double.to_query f))
         ; Aws.Util.option_map v.min_iops_per_gib (fun f ->
               Aws.Query.Pair ("MinIopsPerGib", Double.to_query f))
         ; Aws.Util.option_map v.max_iops_per_db_instance (fun f ->
               Aws.Query.Pair ("MaxIopsPerDbInstance", Integer.to_query f))
         ; Aws.Util.option_map v.min_iops_per_db_instance (fun f ->
               Aws.Query.Pair ("MinIopsPerDbInstance", Integer.to_query f))
         ; Aws.Util.option_map v.max_storage_size (fun f ->
               Aws.Query.Pair ("MaxStorageSize", Integer.to_query f))
         ; Aws.Util.option_map v.min_storage_size (fun f ->
               Aws.Query.Pair ("MinStorageSize", Integer.to_query f))
         ; Aws.Util.option_map v.supports_performance_insights (fun f ->
               Aws.Query.Pair ("SupportsPerformanceInsights", Boolean.to_query f))
         ; Aws.Util.option_map v.supports_i_a_m_database_authentication (fun f ->
               Aws.Query.Pair ("SupportsIAMDatabaseAuthentication", Boolean.to_query f))
         ; Aws.Util.option_map v.supports_enhanced_monitoring (fun f ->
               Aws.Query.Pair ("SupportsEnhancedMonitoring", Boolean.to_query f))
         ; Aws.Util.option_map v.supports_iops (fun f ->
               Aws.Query.Pair ("SupportsIops", Boolean.to_query f))
         ; Aws.Util.option_map v.storage_type (fun f ->
               Aws.Query.Pair ("StorageType", String.to_query f))
         ; Aws.Util.option_map v.supports_storage_encryption (fun f ->
               Aws.Query.Pair ("SupportsStorageEncryption", Boolean.to_query f))
         ; Aws.Util.option_map v.vpc (fun f -> Aws.Query.Pair ("Vpc", Boolean.to_query f))
         ; Aws.Util.option_map v.read_replica_capable (fun f ->
               Aws.Query.Pair ("ReadReplicaCapable", Boolean.to_query f))
         ; Aws.Util.option_map v.multi_a_z_capable (fun f ->
               Aws.Query.Pair ("MultiAZCapable", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "AvailabilityZones.member"
                , AvailabilityZoneList.to_query v.availability_zones ))
         ; Aws.Util.option_map v.availability_zone_group (fun f ->
               Aws.Query.Pair ("AvailabilityZoneGroup", String.to_query f))
         ; Aws.Util.option_map v.license_model (fun f ->
               Aws.Query.Pair ("LicenseModel", String.to_query f))
         ; Aws.Util.option_map v.d_b_instance_class (fun f ->
               Aws.Query.Pair ("DBInstanceClass", String.to_query f))
         ; Aws.Util.option_map v.engine_version (fun f ->
               Aws.Query.Pair ("EngineVersion", String.to_query f))
         ; Aws.Util.option_map v.engine (fun f ->
               Aws.Query.Pair ("Engine", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.supports_global_databases (fun f ->
               "SupportsGlobalDatabases", Boolean.to_json f)
         ; Aws.Util.option_map v.outpost_capable (fun f ->
               "OutpostCapable", Boolean.to_json f)
         ; Aws.Util.option_map v.supports_kerberos_authentication (fun f ->
               "SupportsKerberosAuthentication", Boolean.to_json f)
         ; Aws.Util.option_map v.supports_storage_autoscaling (fun f ->
               "SupportsStorageAutoscaling", Boolean.to_json f)
         ; Some ("SupportedEngineModes", EngineModeList.to_json v.supported_engine_modes)
         ; Some
             ( "AvailableProcessorFeatures"
             , AvailableProcessorFeatureList.to_json v.available_processor_features )
         ; Aws.Util.option_map v.max_iops_per_gib (fun f ->
               "MaxIopsPerGib", Double.to_json f)
         ; Aws.Util.option_map v.min_iops_per_gib (fun f ->
               "MinIopsPerGib", Double.to_json f)
         ; Aws.Util.option_map v.max_iops_per_db_instance (fun f ->
               "MaxIopsPerDbInstance", Integer.to_json f)
         ; Aws.Util.option_map v.min_iops_per_db_instance (fun f ->
               "MinIopsPerDbInstance", Integer.to_json f)
         ; Aws.Util.option_map v.max_storage_size (fun f ->
               "MaxStorageSize", Integer.to_json f)
         ; Aws.Util.option_map v.min_storage_size (fun f ->
               "MinStorageSize", Integer.to_json f)
         ; Aws.Util.option_map v.supports_performance_insights (fun f ->
               "SupportsPerformanceInsights", Boolean.to_json f)
         ; Aws.Util.option_map v.supports_i_a_m_database_authentication (fun f ->
               "SupportsIAMDatabaseAuthentication", Boolean.to_json f)
         ; Aws.Util.option_map v.supports_enhanced_monitoring (fun f ->
               "SupportsEnhancedMonitoring", Boolean.to_json f)
         ; Aws.Util.option_map v.supports_iops (fun f ->
               "SupportsIops", Boolean.to_json f)
         ; Aws.Util.option_map v.storage_type (fun f -> "StorageType", String.to_json f)
         ; Aws.Util.option_map v.supports_storage_encryption (fun f ->
               "SupportsStorageEncryption", Boolean.to_json f)
         ; Aws.Util.option_map v.vpc (fun f -> "Vpc", Boolean.to_json f)
         ; Aws.Util.option_map v.read_replica_capable (fun f ->
               "ReadReplicaCapable", Boolean.to_json f)
         ; Aws.Util.option_map v.multi_a_z_capable (fun f ->
               "MultiAZCapable", Boolean.to_json f)
         ; Some ("AvailabilityZones", AvailabilityZoneList.to_json v.availability_zones)
         ; Aws.Util.option_map v.availability_zone_group (fun f ->
               "AvailabilityZoneGroup", String.to_json f)
         ; Aws.Util.option_map v.license_model (fun f -> "LicenseModel", String.to_json f)
         ; Aws.Util.option_map v.d_b_instance_class (fun f ->
               "DBInstanceClass", String.to_json f)
         ; Aws.Util.option_map v.engine_version (fun f ->
               "EngineVersion", String.to_json f)
         ; Aws.Util.option_map v.engine (fun f -> "Engine", String.to_json f)
         ])

  let of_json j =
    { engine = Aws.Util.option_map (Aws.Json.lookup j "Engine") String.of_json
    ; engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "EngineVersion") String.of_json
    ; d_b_instance_class =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstanceClass") String.of_json
    ; license_model =
        Aws.Util.option_map (Aws.Json.lookup j "LicenseModel") String.of_json
    ; availability_zone_group =
        Aws.Util.option_map (Aws.Json.lookup j "AvailabilityZoneGroup") String.of_json
    ; availability_zones =
        AvailabilityZoneList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AvailabilityZones"))
    ; multi_a_z_capable =
        Aws.Util.option_map (Aws.Json.lookup j "MultiAZCapable") Boolean.of_json
    ; read_replica_capable =
        Aws.Util.option_map (Aws.Json.lookup j "ReadReplicaCapable") Boolean.of_json
    ; vpc = Aws.Util.option_map (Aws.Json.lookup j "Vpc") Boolean.of_json
    ; supports_storage_encryption =
        Aws.Util.option_map
          (Aws.Json.lookup j "SupportsStorageEncryption")
          Boolean.of_json
    ; storage_type = Aws.Util.option_map (Aws.Json.lookup j "StorageType") String.of_json
    ; supports_iops =
        Aws.Util.option_map (Aws.Json.lookup j "SupportsIops") Boolean.of_json
    ; supports_enhanced_monitoring =
        Aws.Util.option_map
          (Aws.Json.lookup j "SupportsEnhancedMonitoring")
          Boolean.of_json
    ; supports_i_a_m_database_authentication =
        Aws.Util.option_map
          (Aws.Json.lookup j "SupportsIAMDatabaseAuthentication")
          Boolean.of_json
    ; supports_performance_insights =
        Aws.Util.option_map
          (Aws.Json.lookup j "SupportsPerformanceInsights")
          Boolean.of_json
    ; min_storage_size =
        Aws.Util.option_map (Aws.Json.lookup j "MinStorageSize") Integer.of_json
    ; max_storage_size =
        Aws.Util.option_map (Aws.Json.lookup j "MaxStorageSize") Integer.of_json
    ; min_iops_per_db_instance =
        Aws.Util.option_map (Aws.Json.lookup j "MinIopsPerDbInstance") Integer.of_json
    ; max_iops_per_db_instance =
        Aws.Util.option_map (Aws.Json.lookup j "MaxIopsPerDbInstance") Integer.of_json
    ; min_iops_per_gib =
        Aws.Util.option_map (Aws.Json.lookup j "MinIopsPerGib") Double.of_json
    ; max_iops_per_gib =
        Aws.Util.option_map (Aws.Json.lookup j "MaxIopsPerGib") Double.of_json
    ; available_processor_features =
        AvailableProcessorFeatureList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AvailableProcessorFeatures"))
    ; supported_engine_modes =
        EngineModeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SupportedEngineModes"))
    ; supports_storage_autoscaling =
        Aws.Util.option_map
          (Aws.Json.lookup j "SupportsStorageAutoscaling")
          Boolean.of_json
    ; supports_kerberos_authentication =
        Aws.Util.option_map
          (Aws.Json.lookup j "SupportsKerberosAuthentication")
          Boolean.of_json
    ; outpost_capable =
        Aws.Util.option_map (Aws.Json.lookup j "OutpostCapable") Boolean.of_json
    ; supports_global_databases =
        Aws.Util.option_map (Aws.Json.lookup j "SupportsGlobalDatabases") Boolean.of_json
    }
end

module OrderableDBInstanceOptionsList = struct
  type t = OrderableDBInstanceOption.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         OrderableDBInstanceOption.parse
         (Aws.Xml.members "OrderableDBInstanceOption" xml))

  let to_query v = Aws.Query.to_query_list OrderableDBInstanceOption.to_query v

  let to_json v = `List (List.map OrderableDBInstanceOption.to_json v)

  let of_json j = Aws.Json.to_list OrderableDBInstanceOption.of_json j
end

module OrderableDBInstanceOptionsMessage = struct
  type t =
    { orderable_d_b_instance_options : OrderableDBInstanceOptionsList.t
    ; marker : String.t option
    }

  let make ?(orderable_d_b_instance_options = []) ?marker () =
    { orderable_d_b_instance_options; marker }

  let parse xml =
    Some
      { orderable_d_b_instance_options =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "OrderableDBInstanceOptions" xml)
               OrderableDBInstanceOptionsList.parse)
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "OrderableDBInstanceOptions.member"
                , OrderableDBInstanceOptionsList.to_query v.orderable_d_b_instance_options
                ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Some
             ( "OrderableDBInstanceOptions"
             , OrderableDBInstanceOptionsList.to_json v.orderable_d_b_instance_options )
         ])

  let of_json j =
    { orderable_d_b_instance_options =
        OrderableDBInstanceOptionsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "OrderableDBInstanceOptions"))
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module SourceIdsList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "SourceId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module EventCategoriesList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "EventCategory" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module EventSubscription = struct
  type t =
    { customer_aws_id : String.t option
    ; cust_subscription_id : String.t option
    ; sns_topic_arn : String.t option
    ; status : String.t option
    ; subscription_creation_time : String.t option
    ; source_type : String.t option
    ; source_ids_list : SourceIdsList.t
    ; event_categories_list : EventCategoriesList.t
    ; enabled : Boolean.t option
    ; event_subscription_arn : String.t option
    }

  let make
      ?customer_aws_id
      ?cust_subscription_id
      ?sns_topic_arn
      ?status
      ?subscription_creation_time
      ?source_type
      ?(source_ids_list = [])
      ?(event_categories_list = [])
      ?enabled
      ?event_subscription_arn
      () =
    { customer_aws_id
    ; cust_subscription_id
    ; sns_topic_arn
    ; status
    ; subscription_creation_time
    ; source_type
    ; source_ids_list
    ; event_categories_list
    ; enabled
    ; event_subscription_arn
    }

  let parse xml =
    Some
      { customer_aws_id =
          Aws.Util.option_bind (Aws.Xml.member "CustomerAwsId" xml) String.parse
      ; cust_subscription_id =
          Aws.Util.option_bind (Aws.Xml.member "CustSubscriptionId" xml) String.parse
      ; sns_topic_arn =
          Aws.Util.option_bind (Aws.Xml.member "SnsTopicArn" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      ; subscription_creation_time =
          Aws.Util.option_bind
            (Aws.Xml.member "SubscriptionCreationTime" xml)
            String.parse
      ; source_type = Aws.Util.option_bind (Aws.Xml.member "SourceType" xml) String.parse
      ; source_ids_list =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SourceIdsList" xml)
               SourceIdsList.parse)
      ; event_categories_list =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "EventCategoriesList" xml)
               EventCategoriesList.parse)
      ; enabled = Aws.Util.option_bind (Aws.Xml.member "Enabled" xml) Boolean.parse
      ; event_subscription_arn =
          Aws.Util.option_bind (Aws.Xml.member "EventSubscriptionArn" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.event_subscription_arn (fun f ->
               Aws.Query.Pair ("EventSubscriptionArn", String.to_query f))
         ; Aws.Util.option_map v.enabled (fun f ->
               Aws.Query.Pair ("Enabled", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "EventCategoriesList.member"
                , EventCategoriesList.to_query v.event_categories_list ))
         ; Some
             (Aws.Query.Pair
                ("SourceIdsList.member", SourceIdsList.to_query v.source_ids_list))
         ; Aws.Util.option_map v.source_type (fun f ->
               Aws.Query.Pair ("SourceType", String.to_query f))
         ; Aws.Util.option_map v.subscription_creation_time (fun f ->
               Aws.Query.Pair ("SubscriptionCreationTime", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.sns_topic_arn (fun f ->
               Aws.Query.Pair ("SnsTopicArn", String.to_query f))
         ; Aws.Util.option_map v.cust_subscription_id (fun f ->
               Aws.Query.Pair ("CustSubscriptionId", String.to_query f))
         ; Aws.Util.option_map v.customer_aws_id (fun f ->
               Aws.Query.Pair ("CustomerAwsId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.event_subscription_arn (fun f ->
               "EventSubscriptionArn", String.to_json f)
         ; Aws.Util.option_map v.enabled (fun f -> "Enabled", Boolean.to_json f)
         ; Some
             ("EventCategoriesList", EventCategoriesList.to_json v.event_categories_list)
         ; Some ("SourceIdsList", SourceIdsList.to_json v.source_ids_list)
         ; Aws.Util.option_map v.source_type (fun f -> "SourceType", String.to_json f)
         ; Aws.Util.option_map v.subscription_creation_time (fun f ->
               "SubscriptionCreationTime", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ; Aws.Util.option_map v.sns_topic_arn (fun f -> "SnsTopicArn", String.to_json f)
         ; Aws.Util.option_map v.cust_subscription_id (fun f ->
               "CustSubscriptionId", String.to_json f)
         ; Aws.Util.option_map v.customer_aws_id (fun f ->
               "CustomerAwsId", String.to_json f)
         ])

  let of_json j =
    { customer_aws_id =
        Aws.Util.option_map (Aws.Json.lookup j "CustomerAwsId") String.of_json
    ; cust_subscription_id =
        Aws.Util.option_map (Aws.Json.lookup j "CustSubscriptionId") String.of_json
    ; sns_topic_arn = Aws.Util.option_map (Aws.Json.lookup j "SnsTopicArn") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    ; subscription_creation_time =
        Aws.Util.option_map (Aws.Json.lookup j "SubscriptionCreationTime") String.of_json
    ; source_type = Aws.Util.option_map (Aws.Json.lookup j "SourceType") String.of_json
    ; source_ids_list =
        SourceIdsList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceIdsList"))
    ; event_categories_list =
        EventCategoriesList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "EventCategoriesList"))
    ; enabled = Aws.Util.option_map (Aws.Json.lookup j "Enabled") Boolean.of_json
    ; event_subscription_arn =
        Aws.Util.option_map (Aws.Json.lookup j "EventSubscriptionArn") String.of_json
    }
end

module EventSubscriptionsList = struct
  type t = EventSubscription.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map EventSubscription.parse (Aws.Xml.members "EventSubscription" xml))

  let to_query v = Aws.Query.to_query_list EventSubscription.to_query v

  let to_json v = `List (List.map EventSubscription.to_json v)

  let of_json j = Aws.Json.to_list EventSubscription.of_json j
end

module DeleteDBClusterParameterGroupMessage = struct
  type t = { d_b_cluster_parameter_group_name : String.t }

  let make ~d_b_cluster_parameter_group_name () = { d_b_cluster_parameter_group_name }

  let parse xml =
    Some
      { d_b_cluster_parameter_group_name =
          Aws.Xml.required
            "DBClusterParameterGroupName"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBClusterParameterGroupName" xml)
               String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "DBClusterParameterGroupName"
                , String.to_query v.d_b_cluster_parameter_group_name ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "DBClusterParameterGroupName"
             , String.to_json v.d_b_cluster_parameter_group_name )
         ])

  let of_json j =
    { d_b_cluster_parameter_group_name =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterParameterGroupName"))
    }
end

module SNSInvalidTopicFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module ConnectionPoolConfigurationInfo = struct
  type t =
    { max_connections_percent : Integer.t option
    ; max_idle_connections_percent : Integer.t option
    ; connection_borrow_timeout : Integer.t option
    ; session_pinning_filters : StringList.t
    ; init_query : String.t option
    }

  let make
      ?max_connections_percent
      ?max_idle_connections_percent
      ?connection_borrow_timeout
      ?(session_pinning_filters = [])
      ?init_query
      () =
    { max_connections_percent
    ; max_idle_connections_percent
    ; connection_borrow_timeout
    ; session_pinning_filters
    ; init_query
    }

  let parse xml =
    Some
      { max_connections_percent =
          Aws.Util.option_bind (Aws.Xml.member "MaxConnectionsPercent" xml) Integer.parse
      ; max_idle_connections_percent =
          Aws.Util.option_bind
            (Aws.Xml.member "MaxIdleConnectionsPercent" xml)
            Integer.parse
      ; connection_borrow_timeout =
          Aws.Util.option_bind
            (Aws.Xml.member "ConnectionBorrowTimeout" xml)
            Integer.parse
      ; session_pinning_filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SessionPinningFilters" xml)
               StringList.parse)
      ; init_query = Aws.Util.option_bind (Aws.Xml.member "InitQuery" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.init_query (fun f ->
               Aws.Query.Pair ("InitQuery", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "SessionPinningFilters.member"
                , StringList.to_query v.session_pinning_filters ))
         ; Aws.Util.option_map v.connection_borrow_timeout (fun f ->
               Aws.Query.Pair ("ConnectionBorrowTimeout", Integer.to_query f))
         ; Aws.Util.option_map v.max_idle_connections_percent (fun f ->
               Aws.Query.Pair ("MaxIdleConnectionsPercent", Integer.to_query f))
         ; Aws.Util.option_map v.max_connections_percent (fun f ->
               Aws.Query.Pair ("MaxConnectionsPercent", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.init_query (fun f -> "InitQuery", String.to_json f)
         ; Some ("SessionPinningFilters", StringList.to_json v.session_pinning_filters)
         ; Aws.Util.option_map v.connection_borrow_timeout (fun f ->
               "ConnectionBorrowTimeout", Integer.to_json f)
         ; Aws.Util.option_map v.max_idle_connections_percent (fun f ->
               "MaxIdleConnectionsPercent", Integer.to_json f)
         ; Aws.Util.option_map v.max_connections_percent (fun f ->
               "MaxConnectionsPercent", Integer.to_json f)
         ])

  let of_json j =
    { max_connections_percent =
        Aws.Util.option_map (Aws.Json.lookup j "MaxConnectionsPercent") Integer.of_json
    ; max_idle_connections_percent =
        Aws.Util.option_map
          (Aws.Json.lookup j "MaxIdleConnectionsPercent")
          Integer.of_json
    ; connection_borrow_timeout =
        Aws.Util.option_map (Aws.Json.lookup j "ConnectionBorrowTimeout") Integer.of_json
    ; session_pinning_filters =
        StringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SessionPinningFilters"))
    ; init_query = Aws.Util.option_map (Aws.Json.lookup j "InitQuery") String.of_json
    }
end

module DBProxyTargetGroup = struct
  type t =
    { d_b_proxy_name : String.t option
    ; target_group_name : String.t option
    ; target_group_arn : String.t option
    ; is_default : Boolean.t option
    ; status : String.t option
    ; connection_pool_config : ConnectionPoolConfigurationInfo.t option
    ; created_date : DateTime.t option
    ; updated_date : DateTime.t option
    }

  let make
      ?d_b_proxy_name
      ?target_group_name
      ?target_group_arn
      ?is_default
      ?status
      ?connection_pool_config
      ?created_date
      ?updated_date
      () =
    { d_b_proxy_name
    ; target_group_name
    ; target_group_arn
    ; is_default
    ; status
    ; connection_pool_config
    ; created_date
    ; updated_date
    }

  let parse xml =
    Some
      { d_b_proxy_name =
          Aws.Util.option_bind (Aws.Xml.member "DBProxyName" xml) String.parse
      ; target_group_name =
          Aws.Util.option_bind (Aws.Xml.member "TargetGroupName" xml) String.parse
      ; target_group_arn =
          Aws.Util.option_bind (Aws.Xml.member "TargetGroupArn" xml) String.parse
      ; is_default = Aws.Util.option_bind (Aws.Xml.member "IsDefault" xml) Boolean.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      ; connection_pool_config =
          Aws.Util.option_bind
            (Aws.Xml.member "ConnectionPoolConfig" xml)
            ConnectionPoolConfigurationInfo.parse
      ; created_date =
          Aws.Util.option_bind (Aws.Xml.member "CreatedDate" xml) DateTime.parse
      ; updated_date =
          Aws.Util.option_bind (Aws.Xml.member "UpdatedDate" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.updated_date (fun f ->
               Aws.Query.Pair ("UpdatedDate", DateTime.to_query f))
         ; Aws.Util.option_map v.created_date (fun f ->
               Aws.Query.Pair ("CreatedDate", DateTime.to_query f))
         ; Aws.Util.option_map v.connection_pool_config (fun f ->
               Aws.Query.Pair
                 ("ConnectionPoolConfig", ConnectionPoolConfigurationInfo.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.is_default (fun f ->
               Aws.Query.Pair ("IsDefault", Boolean.to_query f))
         ; Aws.Util.option_map v.target_group_arn (fun f ->
               Aws.Query.Pair ("TargetGroupArn", String.to_query f))
         ; Aws.Util.option_map v.target_group_name (fun f ->
               Aws.Query.Pair ("TargetGroupName", String.to_query f))
         ; Aws.Util.option_map v.d_b_proxy_name (fun f ->
               Aws.Query.Pair ("DBProxyName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.updated_date (fun f -> "UpdatedDate", DateTime.to_json f)
         ; Aws.Util.option_map v.created_date (fun f -> "CreatedDate", DateTime.to_json f)
         ; Aws.Util.option_map v.connection_pool_config (fun f ->
               "ConnectionPoolConfig", ConnectionPoolConfigurationInfo.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ; Aws.Util.option_map v.is_default (fun f -> "IsDefault", Boolean.to_json f)
         ; Aws.Util.option_map v.target_group_arn (fun f ->
               "TargetGroupArn", String.to_json f)
         ; Aws.Util.option_map v.target_group_name (fun f ->
               "TargetGroupName", String.to_json f)
         ; Aws.Util.option_map v.d_b_proxy_name (fun f -> "DBProxyName", String.to_json f)
         ])

  let of_json j =
    { d_b_proxy_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBProxyName") String.of_json
    ; target_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "TargetGroupName") String.of_json
    ; target_group_arn =
        Aws.Util.option_map (Aws.Json.lookup j "TargetGroupArn") String.of_json
    ; is_default = Aws.Util.option_map (Aws.Json.lookup j "IsDefault") Boolean.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    ; connection_pool_config =
        Aws.Util.option_map
          (Aws.Json.lookup j "ConnectionPoolConfig")
          ConnectionPoolConfigurationInfo.of_json
    ; created_date =
        Aws.Util.option_map (Aws.Json.lookup j "CreatedDate") DateTime.of_json
    ; updated_date =
        Aws.Util.option_map (Aws.Json.lookup j "UpdatedDate") DateTime.of_json
    }
end

module TargetGroupList = struct
  type t = DBProxyTargetGroup.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map DBProxyTargetGroup.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list DBProxyTargetGroup.to_query v

  let to_json v = `List (List.map DBProxyTargetGroup.to_json v)

  let of_json j = Aws.Json.to_list DBProxyTargetGroup.of_json j
end

module ProcessorFeature = struct
  type t =
    { name : String.t option
    ; value : String.t option
    }

  let make ?name ?value () = { name; value }

  let parse xml =
    Some
      { name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; value = Aws.Util.option_bind (Aws.Xml.member "Value" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f -> "Value", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ])

  let of_json j =
    { name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; value = Aws.Util.option_map (Aws.Json.lookup j "Value") String.of_json
    }
end

module ProcessorFeatureList = struct
  type t = ProcessorFeature.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ProcessorFeature.parse (Aws.Xml.members "ProcessorFeature" xml))

  let to_query v = Aws.Query.to_query_list ProcessorFeature.to_query v

  let to_json v = `List (List.map ProcessorFeature.to_json v)

  let of_json j = Aws.Json.to_list ProcessorFeature.of_json j
end

module DBSnapshot = struct
  type t =
    { d_b_snapshot_identifier : String.t option
    ; d_b_instance_identifier : String.t option
    ; snapshot_create_time : DateTime.t option
    ; engine : String.t option
    ; allocated_storage : Integer.t option
    ; status : String.t option
    ; port : Integer.t option
    ; availability_zone : String.t option
    ; vpc_id : String.t option
    ; instance_create_time : DateTime.t option
    ; master_username : String.t option
    ; engine_version : String.t option
    ; license_model : String.t option
    ; snapshot_type : String.t option
    ; iops : Integer.t option
    ; option_group_name : String.t option
    ; percent_progress : Integer.t option
    ; source_region : String.t option
    ; source_d_b_snapshot_identifier : String.t option
    ; storage_type : String.t option
    ; tde_credential_arn : String.t option
    ; encrypted : Boolean.t option
    ; kms_key_id : String.t option
    ; d_b_snapshot_arn : String.t option
    ; timezone : String.t option
    ; i_a_m_database_authentication_enabled : Boolean.t option
    ; processor_features : ProcessorFeatureList.t
    ; dbi_resource_id : String.t option
    ; tag_list : TagList.t
    }

  let make
      ?d_b_snapshot_identifier
      ?d_b_instance_identifier
      ?snapshot_create_time
      ?engine
      ?allocated_storage
      ?status
      ?port
      ?availability_zone
      ?vpc_id
      ?instance_create_time
      ?master_username
      ?engine_version
      ?license_model
      ?snapshot_type
      ?iops
      ?option_group_name
      ?percent_progress
      ?source_region
      ?source_d_b_snapshot_identifier
      ?storage_type
      ?tde_credential_arn
      ?encrypted
      ?kms_key_id
      ?d_b_snapshot_arn
      ?timezone
      ?i_a_m_database_authentication_enabled
      ?(processor_features = [])
      ?dbi_resource_id
      ?(tag_list = [])
      () =
    { d_b_snapshot_identifier
    ; d_b_instance_identifier
    ; snapshot_create_time
    ; engine
    ; allocated_storage
    ; status
    ; port
    ; availability_zone
    ; vpc_id
    ; instance_create_time
    ; master_username
    ; engine_version
    ; license_model
    ; snapshot_type
    ; iops
    ; option_group_name
    ; percent_progress
    ; source_region
    ; source_d_b_snapshot_identifier
    ; storage_type
    ; tde_credential_arn
    ; encrypted
    ; kms_key_id
    ; d_b_snapshot_arn
    ; timezone
    ; i_a_m_database_authentication_enabled
    ; processor_features
    ; dbi_resource_id
    ; tag_list
    }

  let parse xml =
    Some
      { d_b_snapshot_identifier =
          Aws.Util.option_bind (Aws.Xml.member "DBSnapshotIdentifier" xml) String.parse
      ; d_b_instance_identifier =
          Aws.Util.option_bind (Aws.Xml.member "DBInstanceIdentifier" xml) String.parse
      ; snapshot_create_time =
          Aws.Util.option_bind (Aws.Xml.member "SnapshotCreateTime" xml) DateTime.parse
      ; engine = Aws.Util.option_bind (Aws.Xml.member "Engine" xml) String.parse
      ; allocated_storage =
          Aws.Util.option_bind (Aws.Xml.member "AllocatedStorage" xml) Integer.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      ; port = Aws.Util.option_bind (Aws.Xml.member "Port" xml) Integer.parse
      ; availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "AvailabilityZone" xml) String.parse
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) String.parse
      ; instance_create_time =
          Aws.Util.option_bind (Aws.Xml.member "InstanceCreateTime" xml) DateTime.parse
      ; master_username =
          Aws.Util.option_bind (Aws.Xml.member "MasterUsername" xml) String.parse
      ; engine_version =
          Aws.Util.option_bind (Aws.Xml.member "EngineVersion" xml) String.parse
      ; license_model =
          Aws.Util.option_bind (Aws.Xml.member "LicenseModel" xml) String.parse
      ; snapshot_type =
          Aws.Util.option_bind (Aws.Xml.member "SnapshotType" xml) String.parse
      ; iops = Aws.Util.option_bind (Aws.Xml.member "Iops" xml) Integer.parse
      ; option_group_name =
          Aws.Util.option_bind (Aws.Xml.member "OptionGroupName" xml) String.parse
      ; percent_progress =
          Aws.Util.option_bind (Aws.Xml.member "PercentProgress" xml) Integer.parse
      ; source_region =
          Aws.Util.option_bind (Aws.Xml.member "SourceRegion" xml) String.parse
      ; source_d_b_snapshot_identifier =
          Aws.Util.option_bind
            (Aws.Xml.member "SourceDBSnapshotIdentifier" xml)
            String.parse
      ; storage_type =
          Aws.Util.option_bind (Aws.Xml.member "StorageType" xml) String.parse
      ; tde_credential_arn =
          Aws.Util.option_bind (Aws.Xml.member "TdeCredentialArn" xml) String.parse
      ; encrypted = Aws.Util.option_bind (Aws.Xml.member "Encrypted" xml) Boolean.parse
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "KmsKeyId" xml) String.parse
      ; d_b_snapshot_arn =
          Aws.Util.option_bind (Aws.Xml.member "DBSnapshotArn" xml) String.parse
      ; timezone = Aws.Util.option_bind (Aws.Xml.member "Timezone" xml) String.parse
      ; i_a_m_database_authentication_enabled =
          Aws.Util.option_bind
            (Aws.Xml.member "IAMDatabaseAuthenticationEnabled" xml)
            Boolean.parse
      ; processor_features =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ProcessorFeatures" xml)
               ProcessorFeatureList.parse)
      ; dbi_resource_id =
          Aws.Util.option_bind (Aws.Xml.member "DbiResourceId" xml) String.parse
      ; tag_list =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "TagList" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagList.member", TagList.to_query v.tag_list))
         ; Aws.Util.option_map v.dbi_resource_id (fun f ->
               Aws.Query.Pair ("DbiResourceId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ProcessorFeatures.member"
                , ProcessorFeatureList.to_query v.processor_features ))
         ; Aws.Util.option_map v.i_a_m_database_authentication_enabled (fun f ->
               Aws.Query.Pair ("IAMDatabaseAuthenticationEnabled", Boolean.to_query f))
         ; Aws.Util.option_map v.timezone (fun f ->
               Aws.Query.Pair ("Timezone", String.to_query f))
         ; Aws.Util.option_map v.d_b_snapshot_arn (fun f ->
               Aws.Query.Pair ("DBSnapshotArn", String.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Aws.Util.option_map v.encrypted (fun f ->
               Aws.Query.Pair ("Encrypted", Boolean.to_query f))
         ; Aws.Util.option_map v.tde_credential_arn (fun f ->
               Aws.Query.Pair ("TdeCredentialArn", String.to_query f))
         ; Aws.Util.option_map v.storage_type (fun f ->
               Aws.Query.Pair ("StorageType", String.to_query f))
         ; Aws.Util.option_map v.source_d_b_snapshot_identifier (fun f ->
               Aws.Query.Pair ("SourceDBSnapshotIdentifier", String.to_query f))
         ; Aws.Util.option_map v.source_region (fun f ->
               Aws.Query.Pair ("SourceRegion", String.to_query f))
         ; Aws.Util.option_map v.percent_progress (fun f ->
               Aws.Query.Pair ("PercentProgress", Integer.to_query f))
         ; Aws.Util.option_map v.option_group_name (fun f ->
               Aws.Query.Pair ("OptionGroupName", String.to_query f))
         ; Aws.Util.option_map v.iops (fun f ->
               Aws.Query.Pair ("Iops", Integer.to_query f))
         ; Aws.Util.option_map v.snapshot_type (fun f ->
               Aws.Query.Pair ("SnapshotType", String.to_query f))
         ; Aws.Util.option_map v.license_model (fun f ->
               Aws.Query.Pair ("LicenseModel", String.to_query f))
         ; Aws.Util.option_map v.engine_version (fun f ->
               Aws.Query.Pair ("EngineVersion", String.to_query f))
         ; Aws.Util.option_map v.master_username (fun f ->
               Aws.Query.Pair ("MasterUsername", String.to_query f))
         ; Aws.Util.option_map v.instance_create_time (fun f ->
               Aws.Query.Pair ("InstanceCreateTime", DateTime.to_query f))
         ; Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ; Aws.Util.option_map v.port (fun f ->
               Aws.Query.Pair ("Port", Integer.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.allocated_storage (fun f ->
               Aws.Query.Pair ("AllocatedStorage", Integer.to_query f))
         ; Aws.Util.option_map v.engine (fun f ->
               Aws.Query.Pair ("Engine", String.to_query f))
         ; Aws.Util.option_map v.snapshot_create_time (fun f ->
               Aws.Query.Pair ("SnapshotCreateTime", DateTime.to_query f))
         ; Aws.Util.option_map v.d_b_instance_identifier (fun f ->
               Aws.Query.Pair ("DBInstanceIdentifier", String.to_query f))
         ; Aws.Util.option_map v.d_b_snapshot_identifier (fun f ->
               Aws.Query.Pair ("DBSnapshotIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagList", TagList.to_json v.tag_list)
         ; Aws.Util.option_map v.dbi_resource_id (fun f ->
               "DbiResourceId", String.to_json f)
         ; Some ("ProcessorFeatures", ProcessorFeatureList.to_json v.processor_features)
         ; Aws.Util.option_map v.i_a_m_database_authentication_enabled (fun f ->
               "IAMDatabaseAuthenticationEnabled", Boolean.to_json f)
         ; Aws.Util.option_map v.timezone (fun f -> "Timezone", String.to_json f)
         ; Aws.Util.option_map v.d_b_snapshot_arn (fun f ->
               "DBSnapshotArn", String.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "KmsKeyId", String.to_json f)
         ; Aws.Util.option_map v.encrypted (fun f -> "Encrypted", Boolean.to_json f)
         ; Aws.Util.option_map v.tde_credential_arn (fun f ->
               "TdeCredentialArn", String.to_json f)
         ; Aws.Util.option_map v.storage_type (fun f -> "StorageType", String.to_json f)
         ; Aws.Util.option_map v.source_d_b_snapshot_identifier (fun f ->
               "SourceDBSnapshotIdentifier", String.to_json f)
         ; Aws.Util.option_map v.source_region (fun f -> "SourceRegion", String.to_json f)
         ; Aws.Util.option_map v.percent_progress (fun f ->
               "PercentProgress", Integer.to_json f)
         ; Aws.Util.option_map v.option_group_name (fun f ->
               "OptionGroupName", String.to_json f)
         ; Aws.Util.option_map v.iops (fun f -> "Iops", Integer.to_json f)
         ; Aws.Util.option_map v.snapshot_type (fun f -> "SnapshotType", String.to_json f)
         ; Aws.Util.option_map v.license_model (fun f -> "LicenseModel", String.to_json f)
         ; Aws.Util.option_map v.engine_version (fun f ->
               "EngineVersion", String.to_json f)
         ; Aws.Util.option_map v.master_username (fun f ->
               "MasterUsername", String.to_json f)
         ; Aws.Util.option_map v.instance_create_time (fun f ->
               "InstanceCreateTime", DateTime.to_json f)
         ; Aws.Util.option_map v.vpc_id (fun f -> "VpcId", String.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "AvailabilityZone", String.to_json f)
         ; Aws.Util.option_map v.port (fun f -> "Port", Integer.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ; Aws.Util.option_map v.allocated_storage (fun f ->
               "AllocatedStorage", Integer.to_json f)
         ; Aws.Util.option_map v.engine (fun f -> "Engine", String.to_json f)
         ; Aws.Util.option_map v.snapshot_create_time (fun f ->
               "SnapshotCreateTime", DateTime.to_json f)
         ; Aws.Util.option_map v.d_b_instance_identifier (fun f ->
               "DBInstanceIdentifier", String.to_json f)
         ; Aws.Util.option_map v.d_b_snapshot_identifier (fun f ->
               "DBSnapshotIdentifier", String.to_json f)
         ])

  let of_json j =
    { d_b_snapshot_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "DBSnapshotIdentifier") String.of_json
    ; d_b_instance_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstanceIdentifier") String.of_json
    ; snapshot_create_time =
        Aws.Util.option_map (Aws.Json.lookup j "SnapshotCreateTime") DateTime.of_json
    ; engine = Aws.Util.option_map (Aws.Json.lookup j "Engine") String.of_json
    ; allocated_storage =
        Aws.Util.option_map (Aws.Json.lookup j "AllocatedStorage") Integer.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    ; port = Aws.Util.option_map (Aws.Json.lookup j "Port") Integer.of_json
    ; availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "AvailabilityZone") String.of_json
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "VpcId") String.of_json
    ; instance_create_time =
        Aws.Util.option_map (Aws.Json.lookup j "InstanceCreateTime") DateTime.of_json
    ; master_username =
        Aws.Util.option_map (Aws.Json.lookup j "MasterUsername") String.of_json
    ; engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "EngineVersion") String.of_json
    ; license_model =
        Aws.Util.option_map (Aws.Json.lookup j "LicenseModel") String.of_json
    ; snapshot_type =
        Aws.Util.option_map (Aws.Json.lookup j "SnapshotType") String.of_json
    ; iops = Aws.Util.option_map (Aws.Json.lookup j "Iops") Integer.of_json
    ; option_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "OptionGroupName") String.of_json
    ; percent_progress =
        Aws.Util.option_map (Aws.Json.lookup j "PercentProgress") Integer.of_json
    ; source_region =
        Aws.Util.option_map (Aws.Json.lookup j "SourceRegion") String.of_json
    ; source_d_b_snapshot_identifier =
        Aws.Util.option_map
          (Aws.Json.lookup j "SourceDBSnapshotIdentifier")
          String.of_json
    ; storage_type = Aws.Util.option_map (Aws.Json.lookup j "StorageType") String.of_json
    ; tde_credential_arn =
        Aws.Util.option_map (Aws.Json.lookup j "TdeCredentialArn") String.of_json
    ; encrypted = Aws.Util.option_map (Aws.Json.lookup j "Encrypted") Boolean.of_json
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "KmsKeyId") String.of_json
    ; d_b_snapshot_arn =
        Aws.Util.option_map (Aws.Json.lookup j "DBSnapshotArn") String.of_json
    ; timezone = Aws.Util.option_map (Aws.Json.lookup j "Timezone") String.of_json
    ; i_a_m_database_authentication_enabled =
        Aws.Util.option_map
          (Aws.Json.lookup j "IAMDatabaseAuthenticationEnabled")
          Boolean.of_json
    ; processor_features =
        ProcessorFeatureList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ProcessorFeatures"))
    ; dbi_resource_id =
        Aws.Util.option_map (Aws.Json.lookup j "DbiResourceId") String.of_json
    ; tag_list = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TagList"))
    }
end

module DeleteDBSnapshotResult = struct
  type t = { d_b_snapshot : DBSnapshot.t option }

  let make ?d_b_snapshot () = { d_b_snapshot }

  let parse xml =
    Some
      { d_b_snapshot =
          Aws.Util.option_bind (Aws.Xml.member "DBSnapshot" xml) DBSnapshot.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_snapshot (fun f ->
               Aws.Query.Pair ("DBSnapshot", DBSnapshot.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_snapshot (fun f ->
               "DBSnapshot", DBSnapshot.to_json f)
         ])

  let of_json j =
    { d_b_snapshot =
        Aws.Util.option_map (Aws.Json.lookup j "DBSnapshot") DBSnapshot.of_json
    }
end

module DBSecurityGroupNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module SubnetIdentifierList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "SubnetIdentifier" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module Timezone = struct
  type t = { timezone_name : String.t option }

  let make ?timezone_name () = { timezone_name }

  let parse xml =
    Some
      { timezone_name =
          Aws.Util.option_bind (Aws.Xml.member "TimezoneName" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timezone_name (fun f ->
               Aws.Query.Pair ("TimezoneName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timezone_name (fun f -> "TimezoneName", String.to_json f)
         ])

  let of_json j =
    { timezone_name =
        Aws.Util.option_map (Aws.Json.lookup j "TimezoneName") String.of_json
    }
end

module ModifyDBSubnetGroupMessage = struct
  type t =
    { d_b_subnet_group_name : String.t
    ; d_b_subnet_group_description : String.t option
    ; subnet_ids : SubnetIdentifierList.t
    }

  let make ~d_b_subnet_group_name ?d_b_subnet_group_description ~subnet_ids () =
    { d_b_subnet_group_name; d_b_subnet_group_description; subnet_ids }

  let parse xml =
    Some
      { d_b_subnet_group_name =
          Aws.Xml.required
            "DBSubnetGroupName"
            (Aws.Util.option_bind (Aws.Xml.member "DBSubnetGroupName" xml) String.parse)
      ; d_b_subnet_group_description =
          Aws.Util.option_bind
            (Aws.Xml.member "DBSubnetGroupDescription" xml)
            String.parse
      ; subnet_ids =
          Aws.Xml.required
            "SubnetIds"
            (Aws.Util.option_bind
               (Aws.Xml.member "SubnetIds" xml)
               SubnetIdentifierList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("SubnetIds.member", SubnetIdentifierList.to_query v.subnet_ids))
         ; Aws.Util.option_map v.d_b_subnet_group_description (fun f ->
               Aws.Query.Pair ("DBSubnetGroupDescription", String.to_query f))
         ; Some
             (Aws.Query.Pair ("DBSubnetGroupName", String.to_query v.d_b_subnet_group_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("SubnetIds", SubnetIdentifierList.to_json v.subnet_ids)
         ; Aws.Util.option_map v.d_b_subnet_group_description (fun f ->
               "DBSubnetGroupDescription", String.to_json f)
         ; Some ("DBSubnetGroupName", String.to_json v.d_b_subnet_group_name)
         ])

  let of_json j =
    { d_b_subnet_group_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBSubnetGroupName"))
    ; d_b_subnet_group_description =
        Aws.Util.option_map (Aws.Json.lookup j "DBSubnetGroupDescription") String.of_json
    ; subnet_ids =
        SubnetIdentifierList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SubnetIds"))
    }
end

module SourceType = struct
  type t =
    | Db_instance
    | Db_parameter_group
    | Db_security_group
    | Db_snapshot
    | Db_cluster
    | Db_cluster_snapshot

  let str_to_t =
    [ "db-cluster-snapshot", Db_cluster_snapshot
    ; "db-cluster", Db_cluster
    ; "db-snapshot", Db_snapshot
    ; "db-security-group", Db_security_group
    ; "db-parameter-group", Db_parameter_group
    ; "db-instance", Db_instance
    ]

  let t_to_str =
    [ Db_cluster_snapshot, "db-cluster-snapshot"
    ; Db_cluster, "db-cluster"
    ; Db_snapshot, "db-snapshot"
    ; Db_security_group, "db-security-group"
    ; Db_parameter_group, "db-parameter-group"
    ; Db_instance, "db-instance"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module Event = struct
  type t =
    { source_identifier : String.t option
    ; source_type : SourceType.t option
    ; message : String.t option
    ; event_categories : EventCategoriesList.t
    ; date : DateTime.t option
    ; source_arn : String.t option
    }

  let make
      ?source_identifier
      ?source_type
      ?message
      ?(event_categories = [])
      ?date
      ?source_arn
      () =
    { source_identifier; source_type; message; event_categories; date; source_arn }

  let parse xml =
    Some
      { source_identifier =
          Aws.Util.option_bind (Aws.Xml.member "SourceIdentifier" xml) String.parse
      ; source_type =
          Aws.Util.option_bind (Aws.Xml.member "SourceType" xml) SourceType.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse
      ; event_categories =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "EventCategories" xml)
               EventCategoriesList.parse)
      ; date = Aws.Util.option_bind (Aws.Xml.member "Date" xml) DateTime.parse
      ; source_arn = Aws.Util.option_bind (Aws.Xml.member "SourceArn" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.source_arn (fun f ->
               Aws.Query.Pair ("SourceArn", String.to_query f))
         ; Aws.Util.option_map v.date (fun f ->
               Aws.Query.Pair ("Date", DateTime.to_query f))
         ; Some
             (Aws.Query.Pair
                ("EventCategories.member", EventCategoriesList.to_query v.event_categories))
         ; Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.source_type (fun f ->
               Aws.Query.Pair ("SourceType", SourceType.to_query f))
         ; Aws.Util.option_map v.source_identifier (fun f ->
               Aws.Query.Pair ("SourceIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.source_arn (fun f -> "SourceArn", String.to_json f)
         ; Aws.Util.option_map v.date (fun f -> "Date", DateTime.to_json f)
         ; Some ("EventCategories", EventCategoriesList.to_json v.event_categories)
         ; Aws.Util.option_map v.message (fun f -> "Message", String.to_json f)
         ; Aws.Util.option_map v.source_type (fun f -> "SourceType", SourceType.to_json f)
         ; Aws.Util.option_map v.source_identifier (fun f ->
               "SourceIdentifier", String.to_json f)
         ])

  let of_json j =
    { source_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "SourceIdentifier") String.of_json
    ; source_type =
        Aws.Util.option_map (Aws.Json.lookup j "SourceType") SourceType.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json
    ; event_categories =
        EventCategoriesList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "EventCategories"))
    ; date = Aws.Util.option_map (Aws.Json.lookup j "Date") DateTime.of_json
    ; source_arn = Aws.Util.option_map (Aws.Json.lookup j "SourceArn") String.of_json
    }
end

module EventList = struct
  type t = Event.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map Event.parse (Aws.Xml.members "Event" xml))

  let to_query v = Aws.Query.to_query_list Event.to_query v

  let to_json v = `List (List.map Event.to_json v)

  let of_json j = Aws.Json.to_list Event.of_json j
end

module EventsMessage = struct
  type t =
    { marker : String.t option
    ; events : EventList.t
    }

  let make ?marker ?(events = []) () = { marker; events }

  let parse xml =
    Some
      { marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; events =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Events" xml) EventList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Events.member", EventList.to_query v.events))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Events", EventList.to_json v.events)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ])

  let of_json j =
    { marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; events = EventList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Events"))
    }
end

module DescribeOptionGroupOptionsMessage = struct
  type t =
    { engine_name : String.t
    ; major_engine_version : String.t option
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    }

  let make ~engine_name ?major_engine_version ?(filters = []) ?max_records ?marker () =
    { engine_name; major_engine_version; filters; max_records; marker }

  let parse xml =
    Some
      { engine_name =
          Aws.Xml.required
            "EngineName"
            (Aws.Util.option_bind (Aws.Xml.member "EngineName" xml) String.parse)
      ; major_engine_version =
          Aws.Util.option_bind (Aws.Xml.member "MajorEngineVersion" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.major_engine_version (fun f ->
               Aws.Query.Pair ("MajorEngineVersion", String.to_query f))
         ; Some (Aws.Query.Pair ("EngineName", String.to_query v.engine_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.major_engine_version (fun f ->
               "MajorEngineVersion", String.to_json f)
         ; Some ("EngineName", String.to_json v.engine_name)
         ])

  let of_json j =
    { engine_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "EngineName"))
    ; major_engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "MajorEngineVersion") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module DBInstanceRole = struct
  type t =
    { role_arn : String.t option
    ; feature_name : String.t option
    ; status : String.t option
    }

  let make ?role_arn ?feature_name ?status () = { role_arn; feature_name; status }

  let parse xml =
    Some
      { role_arn = Aws.Util.option_bind (Aws.Xml.member "RoleArn" xml) String.parse
      ; feature_name =
          Aws.Util.option_bind (Aws.Xml.member "FeatureName" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.feature_name (fun f ->
               Aws.Query.Pair ("FeatureName", String.to_query f))
         ; Aws.Util.option_map v.role_arn (fun f ->
               Aws.Query.Pair ("RoleArn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ; Aws.Util.option_map v.feature_name (fun f -> "FeatureName", String.to_json f)
         ; Aws.Util.option_map v.role_arn (fun f -> "RoleArn", String.to_json f)
         ])

  let of_json j =
    { role_arn = Aws.Util.option_map (Aws.Json.lookup j "RoleArn") String.of_json
    ; feature_name = Aws.Util.option_map (Aws.Json.lookup j "FeatureName") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    }
end

module DBParameterGroup = struct
  type t =
    { d_b_parameter_group_name : String.t option
    ; d_b_parameter_group_family : String.t option
    ; description : String.t option
    ; d_b_parameter_group_arn : String.t option
    }

  let make
      ?d_b_parameter_group_name
      ?d_b_parameter_group_family
      ?description
      ?d_b_parameter_group_arn
      () =
    { d_b_parameter_group_name
    ; d_b_parameter_group_family
    ; description
    ; d_b_parameter_group_arn
    }

  let parse xml =
    Some
      { d_b_parameter_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBParameterGroupName" xml) String.parse
      ; d_b_parameter_group_family =
          Aws.Util.option_bind (Aws.Xml.member "DBParameterGroupFamily" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; d_b_parameter_group_arn =
          Aws.Util.option_bind (Aws.Xml.member "DBParameterGroupArn" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_parameter_group_arn (fun f ->
               Aws.Query.Pair ("DBParameterGroupArn", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.d_b_parameter_group_family (fun f ->
               Aws.Query.Pair ("DBParameterGroupFamily", String.to_query f))
         ; Aws.Util.option_map v.d_b_parameter_group_name (fun f ->
               Aws.Query.Pair ("DBParameterGroupName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_parameter_group_arn (fun f ->
               "DBParameterGroupArn", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.d_b_parameter_group_family (fun f ->
               "DBParameterGroupFamily", String.to_json f)
         ; Aws.Util.option_map v.d_b_parameter_group_name (fun f ->
               "DBParameterGroupName", String.to_json f)
         ])

  let of_json j =
    { d_b_parameter_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBParameterGroupName") String.of_json
    ; d_b_parameter_group_family =
        Aws.Util.option_map (Aws.Json.lookup j "DBParameterGroupFamily") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; d_b_parameter_group_arn =
        Aws.Util.option_map (Aws.Json.lookup j "DBParameterGroupArn") String.of_json
    }
end

module CopyDBParameterGroupResult = struct
  type t = { d_b_parameter_group : DBParameterGroup.t option }

  let make ?d_b_parameter_group () = { d_b_parameter_group }

  let parse xml =
    Some
      { d_b_parameter_group =
          Aws.Util.option_bind
            (Aws.Xml.member "DBParameterGroup" xml)
            DBParameterGroup.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_parameter_group (fun f ->
               Aws.Query.Pair ("DBParameterGroup", DBParameterGroup.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_parameter_group (fun f ->
               "DBParameterGroup", DBParameterGroup.to_json f)
         ])

  let of_json j =
    { d_b_parameter_group =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBParameterGroup")
          DBParameterGroup.of_json
    }
end

module ReadersArnList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module GlobalClusterMember = struct
  type t =
    { d_b_cluster_arn : String.t option
    ; readers : ReadersArnList.t
    ; is_writer : Boolean.t option
    ; global_write_forwarding_status : WriteForwardingStatus.t option
    }

  let make ?d_b_cluster_arn ?(readers = []) ?is_writer ?global_write_forwarding_status ()
      =
    { d_b_cluster_arn; readers; is_writer; global_write_forwarding_status }

  let parse xml =
    Some
      { d_b_cluster_arn =
          Aws.Util.option_bind (Aws.Xml.member "DBClusterArn" xml) String.parse
      ; readers =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Readers" xml) ReadersArnList.parse)
      ; is_writer = Aws.Util.option_bind (Aws.Xml.member "IsWriter" xml) Boolean.parse
      ; global_write_forwarding_status =
          Aws.Util.option_bind
            (Aws.Xml.member "GlobalWriteForwardingStatus" xml)
            WriteForwardingStatus.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.global_write_forwarding_status (fun f ->
               Aws.Query.Pair
                 ("GlobalWriteForwardingStatus", WriteForwardingStatus.to_query f))
         ; Aws.Util.option_map v.is_writer (fun f ->
               Aws.Query.Pair ("IsWriter", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Readers.member", ReadersArnList.to_query v.readers))
         ; Aws.Util.option_map v.d_b_cluster_arn (fun f ->
               Aws.Query.Pair ("DBClusterArn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.global_write_forwarding_status (fun f ->
               "GlobalWriteForwardingStatus", WriteForwardingStatus.to_json f)
         ; Aws.Util.option_map v.is_writer (fun f -> "IsWriter", Boolean.to_json f)
         ; Some ("Readers", ReadersArnList.to_json v.readers)
         ; Aws.Util.option_map v.d_b_cluster_arn (fun f ->
               "DBClusterArn", String.to_json f)
         ])

  let of_json j =
    { d_b_cluster_arn =
        Aws.Util.option_map (Aws.Json.lookup j "DBClusterArn") String.of_json
    ; readers =
        ReadersArnList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Readers"))
    ; is_writer = Aws.Util.option_map (Aws.Json.lookup j "IsWriter") Boolean.of_json
    ; global_write_forwarding_status =
        Aws.Util.option_map
          (Aws.Json.lookup j "GlobalWriteForwardingStatus")
          WriteForwardingStatus.of_json
    }
end

module GlobalClusterMemberList = struct
  type t = GlobalClusterMember.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map GlobalClusterMember.parse (Aws.Xml.members "GlobalClusterMember" xml))

  let to_query v = Aws.Query.to_query_list GlobalClusterMember.to_query v

  let to_json v = `List (List.map GlobalClusterMember.to_json v)

  let of_json j = Aws.Json.to_list GlobalClusterMember.of_json j
end

module GlobalCluster = struct
  type t =
    { global_cluster_identifier : String.t option
    ; global_cluster_resource_id : String.t option
    ; global_cluster_arn : String.t option
    ; status : String.t option
    ; engine : String.t option
    ; engine_version : String.t option
    ; database_name : String.t option
    ; storage_encrypted : Boolean.t option
    ; deletion_protection : Boolean.t option
    ; global_cluster_members : GlobalClusterMemberList.t
    }

  let make
      ?global_cluster_identifier
      ?global_cluster_resource_id
      ?global_cluster_arn
      ?status
      ?engine
      ?engine_version
      ?database_name
      ?storage_encrypted
      ?deletion_protection
      ?(global_cluster_members = [])
      () =
    { global_cluster_identifier
    ; global_cluster_resource_id
    ; global_cluster_arn
    ; status
    ; engine
    ; engine_version
    ; database_name
    ; storage_encrypted
    ; deletion_protection
    ; global_cluster_members
    }

  let parse xml =
    Some
      { global_cluster_identifier =
          Aws.Util.option_bind (Aws.Xml.member "GlobalClusterIdentifier" xml) String.parse
      ; global_cluster_resource_id =
          Aws.Util.option_bind (Aws.Xml.member "GlobalClusterResourceId" xml) String.parse
      ; global_cluster_arn =
          Aws.Util.option_bind (Aws.Xml.member "GlobalClusterArn" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      ; engine = Aws.Util.option_bind (Aws.Xml.member "Engine" xml) String.parse
      ; engine_version =
          Aws.Util.option_bind (Aws.Xml.member "EngineVersion" xml) String.parse
      ; database_name =
          Aws.Util.option_bind (Aws.Xml.member "DatabaseName" xml) String.parse
      ; storage_encrypted =
          Aws.Util.option_bind (Aws.Xml.member "StorageEncrypted" xml) Boolean.parse
      ; deletion_protection =
          Aws.Util.option_bind (Aws.Xml.member "DeletionProtection" xml) Boolean.parse
      ; global_cluster_members =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "GlobalClusterMembers" xml)
               GlobalClusterMemberList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "GlobalClusterMembers.member"
                , GlobalClusterMemberList.to_query v.global_cluster_members ))
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               Aws.Query.Pair ("DeletionProtection", Boolean.to_query f))
         ; Aws.Util.option_map v.storage_encrypted (fun f ->
               Aws.Query.Pair ("StorageEncrypted", Boolean.to_query f))
         ; Aws.Util.option_map v.database_name (fun f ->
               Aws.Query.Pair ("DatabaseName", String.to_query f))
         ; Aws.Util.option_map v.engine_version (fun f ->
               Aws.Query.Pair ("EngineVersion", String.to_query f))
         ; Aws.Util.option_map v.engine (fun f ->
               Aws.Query.Pair ("Engine", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.global_cluster_arn (fun f ->
               Aws.Query.Pair ("GlobalClusterArn", String.to_query f))
         ; Aws.Util.option_map v.global_cluster_resource_id (fun f ->
               Aws.Query.Pair ("GlobalClusterResourceId", String.to_query f))
         ; Aws.Util.option_map v.global_cluster_identifier (fun f ->
               Aws.Query.Pair ("GlobalClusterIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "GlobalClusterMembers"
             , GlobalClusterMemberList.to_json v.global_cluster_members )
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               "DeletionProtection", Boolean.to_json f)
         ; Aws.Util.option_map v.storage_encrypted (fun f ->
               "StorageEncrypted", Boolean.to_json f)
         ; Aws.Util.option_map v.database_name (fun f -> "DatabaseName", String.to_json f)
         ; Aws.Util.option_map v.engine_version (fun f ->
               "EngineVersion", String.to_json f)
         ; Aws.Util.option_map v.engine (fun f -> "Engine", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ; Aws.Util.option_map v.global_cluster_arn (fun f ->
               "GlobalClusterArn", String.to_json f)
         ; Aws.Util.option_map v.global_cluster_resource_id (fun f ->
               "GlobalClusterResourceId", String.to_json f)
         ; Aws.Util.option_map v.global_cluster_identifier (fun f ->
               "GlobalClusterIdentifier", String.to_json f)
         ])

  let of_json j =
    { global_cluster_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "GlobalClusterIdentifier") String.of_json
    ; global_cluster_resource_id =
        Aws.Util.option_map (Aws.Json.lookup j "GlobalClusterResourceId") String.of_json
    ; global_cluster_arn =
        Aws.Util.option_map (Aws.Json.lookup j "GlobalClusterArn") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    ; engine = Aws.Util.option_map (Aws.Json.lookup j "Engine") String.of_json
    ; engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "EngineVersion") String.of_json
    ; database_name =
        Aws.Util.option_map (Aws.Json.lookup j "DatabaseName") String.of_json
    ; storage_encrypted =
        Aws.Util.option_map (Aws.Json.lookup j "StorageEncrypted") Boolean.of_json
    ; deletion_protection =
        Aws.Util.option_map (Aws.Json.lookup j "DeletionProtection") Boolean.of_json
    ; global_cluster_members =
        GlobalClusterMemberList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "GlobalClusterMembers"))
    }
end

module CreateGlobalClusterResult = struct
  type t = { global_cluster : GlobalCluster.t option }

  let make ?global_cluster () = { global_cluster }

  let parse xml =
    Some
      { global_cluster =
          Aws.Util.option_bind (Aws.Xml.member "GlobalCluster" xml) GlobalCluster.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.global_cluster (fun f ->
               Aws.Query.Pair ("GlobalCluster", GlobalCluster.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.global_cluster (fun f ->
               "GlobalCluster", GlobalCluster.to_json f)
         ])

  let of_json j =
    { global_cluster =
        Aws.Util.option_map (Aws.Json.lookup j "GlobalCluster") GlobalCluster.of_json
    }
end

module ReplicaMode = struct
  type t =
    | Open_read_only
    | Mounted

  let str_to_t = [ "mounted", Mounted; "open-read-only", Open_read_only ]

  let t_to_str = [ Mounted, "mounted"; Open_read_only, "open-read-only" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module InstallationMediaAlreadyExistsFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DBParameterGroupList = struct
  type t = DBParameterGroup.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map DBParameterGroup.parse (Aws.Xml.members "DBParameterGroup" xml))

  let to_query v = Aws.Query.to_query_list DBParameterGroup.to_query v

  let to_json v = `List (List.map DBParameterGroup.to_json v)

  let of_json j = Aws.Json.to_list DBParameterGroup.of_json j
end

module DBParameterGroupsMessage = struct
  type t =
    { marker : String.t option
    ; d_b_parameter_groups : DBParameterGroupList.t
    }

  let make ?marker ?(d_b_parameter_groups = []) () = { marker; d_b_parameter_groups }

  let parse xml =
    Some
      { marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; d_b_parameter_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DBParameterGroups" xml)
               DBParameterGroupList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "DBParameterGroups.member"
                , DBParameterGroupList.to_query v.d_b_parameter_groups ))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("DBParameterGroups", DBParameterGroupList.to_json v.d_b_parameter_groups)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ])

  let of_json j =
    { marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; d_b_parameter_groups =
        DBParameterGroupList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBParameterGroups"))
    }
end

module DBSecurityGroupMembership = struct
  type t =
    { d_b_security_group_name : String.t option
    ; status : String.t option
    }

  let make ?d_b_security_group_name ?status () = { d_b_security_group_name; status }

  let parse xml =
    Some
      { d_b_security_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBSecurityGroupName" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.d_b_security_group_name (fun f ->
               Aws.Query.Pair ("DBSecurityGroupName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ; Aws.Util.option_map v.d_b_security_group_name (fun f ->
               "DBSecurityGroupName", String.to_json f)
         ])

  let of_json j =
    { d_b_security_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBSecurityGroupName") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    }
end

module DBSecurityGroupMembershipList = struct
  type t = DBSecurityGroupMembership.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map DBSecurityGroupMembership.parse (Aws.Xml.members "DBSecurityGroup" xml))

  let to_query v = Aws.Query.to_query_list DBSecurityGroupMembership.to_query v

  let to_json v = `List (List.map DBSecurityGroupMembership.to_json v)

  let of_json j = Aws.Json.to_list DBSecurityGroupMembership.of_json j
end

module AccountQuota = struct
  type t =
    { account_quota_name : String.t option
    ; used : Long.t option
    ; max : Long.t option
    }

  let make ?account_quota_name ?used ?max () = { account_quota_name; used; max }

  let parse xml =
    Some
      { account_quota_name =
          Aws.Util.option_bind (Aws.Xml.member "AccountQuotaName" xml) String.parse
      ; used = Aws.Util.option_bind (Aws.Xml.member "Used" xml) Long.parse
      ; max = Aws.Util.option_bind (Aws.Xml.member "Max" xml) Long.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max (fun f -> Aws.Query.Pair ("Max", Long.to_query f))
         ; Aws.Util.option_map v.used (fun f -> Aws.Query.Pair ("Used", Long.to_query f))
         ; Aws.Util.option_map v.account_quota_name (fun f ->
               Aws.Query.Pair ("AccountQuotaName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max (fun f -> "Max", Long.to_json f)
         ; Aws.Util.option_map v.used (fun f -> "Used", Long.to_json f)
         ; Aws.Util.option_map v.account_quota_name (fun f ->
               "AccountQuotaName", String.to_json f)
         ])

  let of_json j =
    { account_quota_name =
        Aws.Util.option_map (Aws.Json.lookup j "AccountQuotaName") String.of_json
    ; used = Aws.Util.option_map (Aws.Json.lookup j "Used") Long.of_json
    ; max = Aws.Util.option_map (Aws.Json.lookup j "Max") Long.of_json
    }
end

module InstallationMediaFailureCause = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json }
end

module StartActivityStreamRequest = struct
  type t =
    { resource_arn : String.t
    ; mode : ActivityStreamMode.t
    ; kms_key_id : String.t
    ; apply_immediately : Boolean.t option
    }

  let make ~resource_arn ~mode ~kms_key_id ?apply_immediately () =
    { resource_arn; mode; kms_key_id; apply_immediately }

  let parse xml =
    Some
      { resource_arn =
          Aws.Xml.required
            "ResourceArn"
            (Aws.Util.option_bind (Aws.Xml.member "ResourceArn" xml) String.parse)
      ; mode =
          Aws.Xml.required
            "Mode"
            (Aws.Util.option_bind (Aws.Xml.member "Mode" xml) ActivityStreamMode.parse)
      ; kms_key_id =
          Aws.Xml.required
            "KmsKeyId"
            (Aws.Util.option_bind (Aws.Xml.member "KmsKeyId" xml) String.parse)
      ; apply_immediately =
          Aws.Util.option_bind (Aws.Xml.member "ApplyImmediately" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.apply_immediately (fun f ->
               Aws.Query.Pair ("ApplyImmediately", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("KmsKeyId", String.to_query v.kms_key_id))
         ; Some (Aws.Query.Pair ("Mode", ActivityStreamMode.to_query v.mode))
         ; Some (Aws.Query.Pair ("ResourceArn", String.to_query v.resource_arn))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.apply_immediately (fun f ->
               "ApplyImmediately", Boolean.to_json f)
         ; Some ("KmsKeyId", String.to_json v.kms_key_id)
         ; Some ("Mode", ActivityStreamMode.to_json v.mode)
         ; Some ("ResourceArn", String.to_json v.resource_arn)
         ])

  let of_json j =
    { resource_arn =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ResourceArn"))
    ; mode =
        ActivityStreamMode.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Mode"))
    ; kms_key_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "KmsKeyId"))
    ; apply_immediately =
        Aws.Util.option_map (Aws.Json.lookup j "ApplyImmediately") Boolean.of_json
    }
end

module FailoverDBClusterMessage = struct
  type t =
    { d_b_cluster_identifier : String.t
    ; target_d_b_instance_identifier : String.t option
    }

  let make ~d_b_cluster_identifier ?target_d_b_instance_identifier () =
    { d_b_cluster_identifier; target_d_b_instance_identifier }

  let parse xml =
    Some
      { d_b_cluster_identifier =
          Aws.Xml.required
            "DBClusterIdentifier"
            (Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse)
      ; target_d_b_instance_identifier =
          Aws.Util.option_bind
            (Aws.Xml.member "TargetDBInstanceIdentifier" xml)
            String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.target_d_b_instance_identifier (fun f ->
               Aws.Query.Pair ("TargetDBInstanceIdentifier", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DBClusterIdentifier", String.to_query v.d_b_cluster_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.target_d_b_instance_identifier (fun f ->
               "TargetDBInstanceIdentifier", String.to_json f)
         ; Some ("DBClusterIdentifier", String.to_json v.d_b_cluster_identifier)
         ])

  let of_json j =
    { d_b_cluster_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterIdentifier"))
    ; target_d_b_instance_identifier =
        Aws.Util.option_map
          (Aws.Json.lookup j "TargetDBInstanceIdentifier")
          String.of_json
    }
end

module DeleteGlobalClusterMessage = struct
  type t = { global_cluster_identifier : String.t }

  let make ~global_cluster_identifier () = { global_cluster_identifier }

  let parse xml =
    Some
      { global_cluster_identifier =
          Aws.Xml.required
            "GlobalClusterIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "GlobalClusterIdentifier" xml)
               String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("GlobalClusterIdentifier", String.to_query v.global_cluster_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("GlobalClusterIdentifier", String.to_json v.global_cluster_identifier) ])

  let of_json j =
    { global_cluster_identifier =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "GlobalClusterIdentifier"))
    }
end

module InvalidRestoreFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DBClusterAlreadyExistsFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module ModifyDBSnapshotResult = struct
  type t = { d_b_snapshot : DBSnapshot.t option }

  let make ?d_b_snapshot () = { d_b_snapshot }

  let parse xml =
    Some
      { d_b_snapshot =
          Aws.Util.option_bind (Aws.Xml.member "DBSnapshot" xml) DBSnapshot.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_snapshot (fun f ->
               Aws.Query.Pair ("DBSnapshot", DBSnapshot.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_snapshot (fun f ->
               "DBSnapshot", DBSnapshot.to_json f)
         ])

  let of_json j =
    { d_b_snapshot =
        Aws.Util.option_map (Aws.Json.lookup j "DBSnapshot") DBSnapshot.of_json
    }
end

module DBSnapshotNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module OptionSetting = struct
  type t =
    { name : String.t option
    ; value : String.t option
    ; default_value : String.t option
    ; description : String.t option
    ; apply_type : String.t option
    ; data_type : String.t option
    ; allowed_values : String.t option
    ; is_modifiable : Boolean.t option
    ; is_collection : Boolean.t option
    }

  let make
      ?name
      ?value
      ?default_value
      ?description
      ?apply_type
      ?data_type
      ?allowed_values
      ?is_modifiable
      ?is_collection
      () =
    { name
    ; value
    ; default_value
    ; description
    ; apply_type
    ; data_type
    ; allowed_values
    ; is_modifiable
    ; is_collection
    }

  let parse xml =
    Some
      { name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; value = Aws.Util.option_bind (Aws.Xml.member "Value" xml) String.parse
      ; default_value =
          Aws.Util.option_bind (Aws.Xml.member "DefaultValue" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; apply_type = Aws.Util.option_bind (Aws.Xml.member "ApplyType" xml) String.parse
      ; data_type = Aws.Util.option_bind (Aws.Xml.member "DataType" xml) String.parse
      ; allowed_values =
          Aws.Util.option_bind (Aws.Xml.member "AllowedValues" xml) String.parse
      ; is_modifiable =
          Aws.Util.option_bind (Aws.Xml.member "IsModifiable" xml) Boolean.parse
      ; is_collection =
          Aws.Util.option_bind (Aws.Xml.member "IsCollection" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.is_collection (fun f ->
               Aws.Query.Pair ("IsCollection", Boolean.to_query f))
         ; Aws.Util.option_map v.is_modifiable (fun f ->
               Aws.Query.Pair ("IsModifiable", Boolean.to_query f))
         ; Aws.Util.option_map v.allowed_values (fun f ->
               Aws.Query.Pair ("AllowedValues", String.to_query f))
         ; Aws.Util.option_map v.data_type (fun f ->
               Aws.Query.Pair ("DataType", String.to_query f))
         ; Aws.Util.option_map v.apply_type (fun f ->
               Aws.Query.Pair ("ApplyType", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.default_value (fun f ->
               Aws.Query.Pair ("DefaultValue", String.to_query f))
         ; Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.is_collection (fun f ->
               "IsCollection", Boolean.to_json f)
         ; Aws.Util.option_map v.is_modifiable (fun f ->
               "IsModifiable", Boolean.to_json f)
         ; Aws.Util.option_map v.allowed_values (fun f ->
               "AllowedValues", String.to_json f)
         ; Aws.Util.option_map v.data_type (fun f -> "DataType", String.to_json f)
         ; Aws.Util.option_map v.apply_type (fun f -> "ApplyType", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.default_value (fun f -> "DefaultValue", String.to_json f)
         ; Aws.Util.option_map v.value (fun f -> "Value", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ])

  let of_json j =
    { name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; value = Aws.Util.option_map (Aws.Json.lookup j "Value") String.of_json
    ; default_value =
        Aws.Util.option_map (Aws.Json.lookup j "DefaultValue") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; apply_type = Aws.Util.option_map (Aws.Json.lookup j "ApplyType") String.of_json
    ; data_type = Aws.Util.option_map (Aws.Json.lookup j "DataType") String.of_json
    ; allowed_values =
        Aws.Util.option_map (Aws.Json.lookup j "AllowedValues") String.of_json
    ; is_modifiable =
        Aws.Util.option_map (Aws.Json.lookup j "IsModifiable") Boolean.of_json
    ; is_collection =
        Aws.Util.option_map (Aws.Json.lookup j "IsCollection") Boolean.of_json
    }
end

module OptionSettingsList = struct
  type t = OptionSetting.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map OptionSetting.parse (Aws.Xml.members "OptionSetting" xml))

  let to_query v = Aws.Query.to_query_list OptionSetting.to_query v

  let to_json v = `List (List.map OptionSetting.to_json v)

  let of_json j = Aws.Json.to_list OptionSetting.of_json j
end

module StartExportTaskMessage = struct
  type t =
    { export_task_identifier : String.t
    ; source_arn : String.t
    ; s3_bucket_name : String.t
    ; iam_role_arn : String.t
    ; kms_key_id : String.t
    ; s3_prefix : String.t option
    ; export_only : StringList.t
    }

  let make
      ~export_task_identifier
      ~source_arn
      ~s3_bucket_name
      ~iam_role_arn
      ~kms_key_id
      ?s3_prefix
      ?(export_only = [])
      () =
    { export_task_identifier
    ; source_arn
    ; s3_bucket_name
    ; iam_role_arn
    ; kms_key_id
    ; s3_prefix
    ; export_only
    }

  let parse xml =
    Some
      { export_task_identifier =
          Aws.Xml.required
            "ExportTaskIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "ExportTaskIdentifier" xml)
               String.parse)
      ; source_arn =
          Aws.Xml.required
            "SourceArn"
            (Aws.Util.option_bind (Aws.Xml.member "SourceArn" xml) String.parse)
      ; s3_bucket_name =
          Aws.Xml.required
            "S3BucketName"
            (Aws.Util.option_bind (Aws.Xml.member "S3BucketName" xml) String.parse)
      ; iam_role_arn =
          Aws.Xml.required
            "IamRoleArn"
            (Aws.Util.option_bind (Aws.Xml.member "IamRoleArn" xml) String.parse)
      ; kms_key_id =
          Aws.Xml.required
            "KmsKeyId"
            (Aws.Util.option_bind (Aws.Xml.member "KmsKeyId" xml) String.parse)
      ; s3_prefix = Aws.Util.option_bind (Aws.Xml.member "S3Prefix" xml) String.parse
      ; export_only =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "ExportOnly" xml) StringList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("ExportOnly.member", StringList.to_query v.export_only))
         ; Aws.Util.option_map v.s3_prefix (fun f ->
               Aws.Query.Pair ("S3Prefix", String.to_query f))
         ; Some (Aws.Query.Pair ("KmsKeyId", String.to_query v.kms_key_id))
         ; Some (Aws.Query.Pair ("IamRoleArn", String.to_query v.iam_role_arn))
         ; Some (Aws.Query.Pair ("S3BucketName", String.to_query v.s3_bucket_name))
         ; Some (Aws.Query.Pair ("SourceArn", String.to_query v.source_arn))
         ; Some
             (Aws.Query.Pair
                ("ExportTaskIdentifier", String.to_query v.export_task_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("ExportOnly", StringList.to_json v.export_only)
         ; Aws.Util.option_map v.s3_prefix (fun f -> "S3Prefix", String.to_json f)
         ; Some ("KmsKeyId", String.to_json v.kms_key_id)
         ; Some ("IamRoleArn", String.to_json v.iam_role_arn)
         ; Some ("S3BucketName", String.to_json v.s3_bucket_name)
         ; Some ("SourceArn", String.to_json v.source_arn)
         ; Some ("ExportTaskIdentifier", String.to_json v.export_task_identifier)
         ])

  let of_json j =
    { export_task_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ExportTaskIdentifier"))
    ; source_arn = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceArn"))
    ; s3_bucket_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "S3BucketName"))
    ; iam_role_arn =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "IamRoleArn"))
    ; kms_key_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "KmsKeyId"))
    ; s3_prefix = Aws.Util.option_map (Aws.Json.lookup j "S3Prefix") String.of_json
    ; export_only =
        StringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ExportOnly"))
    }
end

module RestoreWindow = struct
  type t =
    { earliest_time : DateTime.t option
    ; latest_time : DateTime.t option
    }

  let make ?earliest_time ?latest_time () = { earliest_time; latest_time }

  let parse xml =
    Some
      { earliest_time =
          Aws.Util.option_bind (Aws.Xml.member "EarliestTime" xml) DateTime.parse
      ; latest_time =
          Aws.Util.option_bind (Aws.Xml.member "LatestTime" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.latest_time (fun f ->
               Aws.Query.Pair ("LatestTime", DateTime.to_query f))
         ; Aws.Util.option_map v.earliest_time (fun f ->
               Aws.Query.Pair ("EarliestTime", DateTime.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.latest_time (fun f -> "LatestTime", DateTime.to_json f)
         ; Aws.Util.option_map v.earliest_time (fun f ->
               "EarliestTime", DateTime.to_json f)
         ])

  let of_json j =
    { earliest_time =
        Aws.Util.option_map (Aws.Json.lookup j "EarliestTime") DateTime.of_json
    ; latest_time = Aws.Util.option_map (Aws.Json.lookup j "LatestTime") DateTime.of_json
    }
end

module DBInstanceAutomatedBackup = struct
  type t =
    { d_b_instance_arn : String.t option
    ; dbi_resource_id : String.t option
    ; region : String.t option
    ; d_b_instance_identifier : String.t option
    ; restore_window : RestoreWindow.t option
    ; allocated_storage : Integer.t option
    ; status : String.t option
    ; port : Integer.t option
    ; availability_zone : String.t option
    ; vpc_id : String.t option
    ; instance_create_time : DateTime.t option
    ; master_username : String.t option
    ; engine : String.t option
    ; engine_version : String.t option
    ; license_model : String.t option
    ; iops : Integer.t option
    ; option_group_name : String.t option
    ; tde_credential_arn : String.t option
    ; encrypted : Boolean.t option
    ; storage_type : String.t option
    ; kms_key_id : String.t option
    ; timezone : String.t option
    ; i_a_m_database_authentication_enabled : Boolean.t option
    }

  let make
      ?d_b_instance_arn
      ?dbi_resource_id
      ?region
      ?d_b_instance_identifier
      ?restore_window
      ?allocated_storage
      ?status
      ?port
      ?availability_zone
      ?vpc_id
      ?instance_create_time
      ?master_username
      ?engine
      ?engine_version
      ?license_model
      ?iops
      ?option_group_name
      ?tde_credential_arn
      ?encrypted
      ?storage_type
      ?kms_key_id
      ?timezone
      ?i_a_m_database_authentication_enabled
      () =
    { d_b_instance_arn
    ; dbi_resource_id
    ; region
    ; d_b_instance_identifier
    ; restore_window
    ; allocated_storage
    ; status
    ; port
    ; availability_zone
    ; vpc_id
    ; instance_create_time
    ; master_username
    ; engine
    ; engine_version
    ; license_model
    ; iops
    ; option_group_name
    ; tde_credential_arn
    ; encrypted
    ; storage_type
    ; kms_key_id
    ; timezone
    ; i_a_m_database_authentication_enabled
    }

  let parse xml =
    Some
      { d_b_instance_arn =
          Aws.Util.option_bind (Aws.Xml.member "DBInstanceArn" xml) String.parse
      ; dbi_resource_id =
          Aws.Util.option_bind (Aws.Xml.member "DbiResourceId" xml) String.parse
      ; region = Aws.Util.option_bind (Aws.Xml.member "Region" xml) String.parse
      ; d_b_instance_identifier =
          Aws.Util.option_bind (Aws.Xml.member "DBInstanceIdentifier" xml) String.parse
      ; restore_window =
          Aws.Util.option_bind (Aws.Xml.member "RestoreWindow" xml) RestoreWindow.parse
      ; allocated_storage =
          Aws.Util.option_bind (Aws.Xml.member "AllocatedStorage" xml) Integer.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      ; port = Aws.Util.option_bind (Aws.Xml.member "Port" xml) Integer.parse
      ; availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "AvailabilityZone" xml) String.parse
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) String.parse
      ; instance_create_time =
          Aws.Util.option_bind (Aws.Xml.member "InstanceCreateTime" xml) DateTime.parse
      ; master_username =
          Aws.Util.option_bind (Aws.Xml.member "MasterUsername" xml) String.parse
      ; engine = Aws.Util.option_bind (Aws.Xml.member "Engine" xml) String.parse
      ; engine_version =
          Aws.Util.option_bind (Aws.Xml.member "EngineVersion" xml) String.parse
      ; license_model =
          Aws.Util.option_bind (Aws.Xml.member "LicenseModel" xml) String.parse
      ; iops = Aws.Util.option_bind (Aws.Xml.member "Iops" xml) Integer.parse
      ; option_group_name =
          Aws.Util.option_bind (Aws.Xml.member "OptionGroupName" xml) String.parse
      ; tde_credential_arn =
          Aws.Util.option_bind (Aws.Xml.member "TdeCredentialArn" xml) String.parse
      ; encrypted = Aws.Util.option_bind (Aws.Xml.member "Encrypted" xml) Boolean.parse
      ; storage_type =
          Aws.Util.option_bind (Aws.Xml.member "StorageType" xml) String.parse
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "KmsKeyId" xml) String.parse
      ; timezone = Aws.Util.option_bind (Aws.Xml.member "Timezone" xml) String.parse
      ; i_a_m_database_authentication_enabled =
          Aws.Util.option_bind
            (Aws.Xml.member "IAMDatabaseAuthenticationEnabled" xml)
            Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.i_a_m_database_authentication_enabled (fun f ->
               Aws.Query.Pair ("IAMDatabaseAuthenticationEnabled", Boolean.to_query f))
         ; Aws.Util.option_map v.timezone (fun f ->
               Aws.Query.Pair ("Timezone", String.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Aws.Util.option_map v.storage_type (fun f ->
               Aws.Query.Pair ("StorageType", String.to_query f))
         ; Aws.Util.option_map v.encrypted (fun f ->
               Aws.Query.Pair ("Encrypted", Boolean.to_query f))
         ; Aws.Util.option_map v.tde_credential_arn (fun f ->
               Aws.Query.Pair ("TdeCredentialArn", String.to_query f))
         ; Aws.Util.option_map v.option_group_name (fun f ->
               Aws.Query.Pair ("OptionGroupName", String.to_query f))
         ; Aws.Util.option_map v.iops (fun f ->
               Aws.Query.Pair ("Iops", Integer.to_query f))
         ; Aws.Util.option_map v.license_model (fun f ->
               Aws.Query.Pair ("LicenseModel", String.to_query f))
         ; Aws.Util.option_map v.engine_version (fun f ->
               Aws.Query.Pair ("EngineVersion", String.to_query f))
         ; Aws.Util.option_map v.engine (fun f ->
               Aws.Query.Pair ("Engine", String.to_query f))
         ; Aws.Util.option_map v.master_username (fun f ->
               Aws.Query.Pair ("MasterUsername", String.to_query f))
         ; Aws.Util.option_map v.instance_create_time (fun f ->
               Aws.Query.Pair ("InstanceCreateTime", DateTime.to_query f))
         ; Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ; Aws.Util.option_map v.port (fun f ->
               Aws.Query.Pair ("Port", Integer.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.allocated_storage (fun f ->
               Aws.Query.Pair ("AllocatedStorage", Integer.to_query f))
         ; Aws.Util.option_map v.restore_window (fun f ->
               Aws.Query.Pair ("RestoreWindow", RestoreWindow.to_query f))
         ; Aws.Util.option_map v.d_b_instance_identifier (fun f ->
               Aws.Query.Pair ("DBInstanceIdentifier", String.to_query f))
         ; Aws.Util.option_map v.region (fun f ->
               Aws.Query.Pair ("Region", String.to_query f))
         ; Aws.Util.option_map v.dbi_resource_id (fun f ->
               Aws.Query.Pair ("DbiResourceId", String.to_query f))
         ; Aws.Util.option_map v.d_b_instance_arn (fun f ->
               Aws.Query.Pair ("DBInstanceArn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.i_a_m_database_authentication_enabled (fun f ->
               "IAMDatabaseAuthenticationEnabled", Boolean.to_json f)
         ; Aws.Util.option_map v.timezone (fun f -> "Timezone", String.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "KmsKeyId", String.to_json f)
         ; Aws.Util.option_map v.storage_type (fun f -> "StorageType", String.to_json f)
         ; Aws.Util.option_map v.encrypted (fun f -> "Encrypted", Boolean.to_json f)
         ; Aws.Util.option_map v.tde_credential_arn (fun f ->
               "TdeCredentialArn", String.to_json f)
         ; Aws.Util.option_map v.option_group_name (fun f ->
               "OptionGroupName", String.to_json f)
         ; Aws.Util.option_map v.iops (fun f -> "Iops", Integer.to_json f)
         ; Aws.Util.option_map v.license_model (fun f -> "LicenseModel", String.to_json f)
         ; Aws.Util.option_map v.engine_version (fun f ->
               "EngineVersion", String.to_json f)
         ; Aws.Util.option_map v.engine (fun f -> "Engine", String.to_json f)
         ; Aws.Util.option_map v.master_username (fun f ->
               "MasterUsername", String.to_json f)
         ; Aws.Util.option_map v.instance_create_time (fun f ->
               "InstanceCreateTime", DateTime.to_json f)
         ; Aws.Util.option_map v.vpc_id (fun f -> "VpcId", String.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "AvailabilityZone", String.to_json f)
         ; Aws.Util.option_map v.port (fun f -> "Port", Integer.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ; Aws.Util.option_map v.allocated_storage (fun f ->
               "AllocatedStorage", Integer.to_json f)
         ; Aws.Util.option_map v.restore_window (fun f ->
               "RestoreWindow", RestoreWindow.to_json f)
         ; Aws.Util.option_map v.d_b_instance_identifier (fun f ->
               "DBInstanceIdentifier", String.to_json f)
         ; Aws.Util.option_map v.region (fun f -> "Region", String.to_json f)
         ; Aws.Util.option_map v.dbi_resource_id (fun f ->
               "DbiResourceId", String.to_json f)
         ; Aws.Util.option_map v.d_b_instance_arn (fun f ->
               "DBInstanceArn", String.to_json f)
         ])

  let of_json j =
    { d_b_instance_arn =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstanceArn") String.of_json
    ; dbi_resource_id =
        Aws.Util.option_map (Aws.Json.lookup j "DbiResourceId") String.of_json
    ; region = Aws.Util.option_map (Aws.Json.lookup j "Region") String.of_json
    ; d_b_instance_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstanceIdentifier") String.of_json
    ; restore_window =
        Aws.Util.option_map (Aws.Json.lookup j "RestoreWindow") RestoreWindow.of_json
    ; allocated_storage =
        Aws.Util.option_map (Aws.Json.lookup j "AllocatedStorage") Integer.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    ; port = Aws.Util.option_map (Aws.Json.lookup j "Port") Integer.of_json
    ; availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "AvailabilityZone") String.of_json
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "VpcId") String.of_json
    ; instance_create_time =
        Aws.Util.option_map (Aws.Json.lookup j "InstanceCreateTime") DateTime.of_json
    ; master_username =
        Aws.Util.option_map (Aws.Json.lookup j "MasterUsername") String.of_json
    ; engine = Aws.Util.option_map (Aws.Json.lookup j "Engine") String.of_json
    ; engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "EngineVersion") String.of_json
    ; license_model =
        Aws.Util.option_map (Aws.Json.lookup j "LicenseModel") String.of_json
    ; iops = Aws.Util.option_map (Aws.Json.lookup j "Iops") Integer.of_json
    ; option_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "OptionGroupName") String.of_json
    ; tde_credential_arn =
        Aws.Util.option_map (Aws.Json.lookup j "TdeCredentialArn") String.of_json
    ; encrypted = Aws.Util.option_map (Aws.Json.lookup j "Encrypted") Boolean.of_json
    ; storage_type = Aws.Util.option_map (Aws.Json.lookup j "StorageType") String.of_json
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "KmsKeyId") String.of_json
    ; timezone = Aws.Util.option_map (Aws.Json.lookup j "Timezone") String.of_json
    ; i_a_m_database_authentication_enabled =
        Aws.Util.option_map
          (Aws.Json.lookup j "IAMDatabaseAuthenticationEnabled")
          Boolean.of_json
    }
end

module DBSecurityGroupNameList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map String.parse (Aws.Xml.members "DBSecurityGroupName" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module CreateDBInstanceMessage = struct
  type t =
    { d_b_name : String.t option
    ; d_b_instance_identifier : String.t
    ; allocated_storage : Integer.t option
    ; d_b_instance_class : String.t
    ; engine : String.t
    ; master_username : String.t option
    ; master_user_password : String.t option
    ; d_b_security_groups : DBSecurityGroupNameList.t
    ; vpc_security_group_ids : VpcSecurityGroupIdList.t
    ; availability_zone : String.t option
    ; d_b_subnet_group_name : String.t option
    ; preferred_maintenance_window : String.t option
    ; d_b_parameter_group_name : String.t option
    ; backup_retention_period : Integer.t option
    ; preferred_backup_window : String.t option
    ; port : Integer.t option
    ; multi_a_z : Boolean.t option
    ; engine_version : String.t option
    ; auto_minor_version_upgrade : Boolean.t option
    ; license_model : String.t option
    ; iops : Integer.t option
    ; option_group_name : String.t option
    ; character_set_name : String.t option
    ; nchar_character_set_name : String.t option
    ; publicly_accessible : Boolean.t option
    ; tags : TagList.t
    ; d_b_cluster_identifier : String.t option
    ; storage_type : String.t option
    ; tde_credential_arn : String.t option
    ; tde_credential_password : String.t option
    ; storage_encrypted : Boolean.t option
    ; kms_key_id : String.t option
    ; domain : String.t option
    ; copy_tags_to_snapshot : Boolean.t option
    ; monitoring_interval : Integer.t option
    ; monitoring_role_arn : String.t option
    ; domain_i_a_m_role_name : String.t option
    ; promotion_tier : Integer.t option
    ; timezone : String.t option
    ; enable_i_a_m_database_authentication : Boolean.t option
    ; enable_performance_insights : Boolean.t option
    ; performance_insights_k_m_s_key_id : String.t option
    ; performance_insights_retention_period : Integer.t option
    ; enable_cloudwatch_logs_exports : LogTypeList.t
    ; processor_features : ProcessorFeatureList.t
    ; deletion_protection : Boolean.t option
    ; max_allocated_storage : Integer.t option
    }

  let make
      ?d_b_name
      ~d_b_instance_identifier
      ?allocated_storage
      ~d_b_instance_class
      ~engine
      ?master_username
      ?master_user_password
      ?(d_b_security_groups = [])
      ?(vpc_security_group_ids = [])
      ?availability_zone
      ?d_b_subnet_group_name
      ?preferred_maintenance_window
      ?d_b_parameter_group_name
      ?backup_retention_period
      ?preferred_backup_window
      ?port
      ?multi_a_z
      ?engine_version
      ?auto_minor_version_upgrade
      ?license_model
      ?iops
      ?option_group_name
      ?character_set_name
      ?nchar_character_set_name
      ?publicly_accessible
      ?(tags = [])
      ?d_b_cluster_identifier
      ?storage_type
      ?tde_credential_arn
      ?tde_credential_password
      ?storage_encrypted
      ?kms_key_id
      ?domain
      ?copy_tags_to_snapshot
      ?monitoring_interval
      ?monitoring_role_arn
      ?domain_i_a_m_role_name
      ?promotion_tier
      ?timezone
      ?enable_i_a_m_database_authentication
      ?enable_performance_insights
      ?performance_insights_k_m_s_key_id
      ?performance_insights_retention_period
      ?(enable_cloudwatch_logs_exports = [])
      ?(processor_features = [])
      ?deletion_protection
      ?max_allocated_storage
      () =
    { d_b_name
    ; d_b_instance_identifier
    ; allocated_storage
    ; d_b_instance_class
    ; engine
    ; master_username
    ; master_user_password
    ; d_b_security_groups
    ; vpc_security_group_ids
    ; availability_zone
    ; d_b_subnet_group_name
    ; preferred_maintenance_window
    ; d_b_parameter_group_name
    ; backup_retention_period
    ; preferred_backup_window
    ; port
    ; multi_a_z
    ; engine_version
    ; auto_minor_version_upgrade
    ; license_model
    ; iops
    ; option_group_name
    ; character_set_name
    ; nchar_character_set_name
    ; publicly_accessible
    ; tags
    ; d_b_cluster_identifier
    ; storage_type
    ; tde_credential_arn
    ; tde_credential_password
    ; storage_encrypted
    ; kms_key_id
    ; domain
    ; copy_tags_to_snapshot
    ; monitoring_interval
    ; monitoring_role_arn
    ; domain_i_a_m_role_name
    ; promotion_tier
    ; timezone
    ; enable_i_a_m_database_authentication
    ; enable_performance_insights
    ; performance_insights_k_m_s_key_id
    ; performance_insights_retention_period
    ; enable_cloudwatch_logs_exports
    ; processor_features
    ; deletion_protection
    ; max_allocated_storage
    }

  let parse xml =
    Some
      { d_b_name = Aws.Util.option_bind (Aws.Xml.member "DBName" xml) String.parse
      ; d_b_instance_identifier =
          Aws.Xml.required
            "DBInstanceIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBInstanceIdentifier" xml)
               String.parse)
      ; allocated_storage =
          Aws.Util.option_bind (Aws.Xml.member "AllocatedStorage" xml) Integer.parse
      ; d_b_instance_class =
          Aws.Xml.required
            "DBInstanceClass"
            (Aws.Util.option_bind (Aws.Xml.member "DBInstanceClass" xml) String.parse)
      ; engine =
          Aws.Xml.required
            "Engine"
            (Aws.Util.option_bind (Aws.Xml.member "Engine" xml) String.parse)
      ; master_username =
          Aws.Util.option_bind (Aws.Xml.member "MasterUsername" xml) String.parse
      ; master_user_password =
          Aws.Util.option_bind (Aws.Xml.member "MasterUserPassword" xml) String.parse
      ; d_b_security_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DBSecurityGroups" xml)
               DBSecurityGroupNameList.parse)
      ; vpc_security_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "VpcSecurityGroupIds" xml)
               VpcSecurityGroupIdList.parse)
      ; availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "AvailabilityZone" xml) String.parse
      ; d_b_subnet_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBSubnetGroupName" xml) String.parse
      ; preferred_maintenance_window =
          Aws.Util.option_bind
            (Aws.Xml.member "PreferredMaintenanceWindow" xml)
            String.parse
      ; d_b_parameter_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBParameterGroupName" xml) String.parse
      ; backup_retention_period =
          Aws.Util.option_bind (Aws.Xml.member "BackupRetentionPeriod" xml) Integer.parse
      ; preferred_backup_window =
          Aws.Util.option_bind (Aws.Xml.member "PreferredBackupWindow" xml) String.parse
      ; port = Aws.Util.option_bind (Aws.Xml.member "Port" xml) Integer.parse
      ; multi_a_z = Aws.Util.option_bind (Aws.Xml.member "MultiAZ" xml) Boolean.parse
      ; engine_version =
          Aws.Util.option_bind (Aws.Xml.member "EngineVersion" xml) String.parse
      ; auto_minor_version_upgrade =
          Aws.Util.option_bind
            (Aws.Xml.member "AutoMinorVersionUpgrade" xml)
            Boolean.parse
      ; license_model =
          Aws.Util.option_bind (Aws.Xml.member "LicenseModel" xml) String.parse
      ; iops = Aws.Util.option_bind (Aws.Xml.member "Iops" xml) Integer.parse
      ; option_group_name =
          Aws.Util.option_bind (Aws.Xml.member "OptionGroupName" xml) String.parse
      ; character_set_name =
          Aws.Util.option_bind (Aws.Xml.member "CharacterSetName" xml) String.parse
      ; nchar_character_set_name =
          Aws.Util.option_bind (Aws.Xml.member "NcharCharacterSetName" xml) String.parse
      ; publicly_accessible =
          Aws.Util.option_bind (Aws.Xml.member "PubliclyAccessible" xml) Boolean.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      ; d_b_cluster_identifier =
          Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse
      ; storage_type =
          Aws.Util.option_bind (Aws.Xml.member "StorageType" xml) String.parse
      ; tde_credential_arn =
          Aws.Util.option_bind (Aws.Xml.member "TdeCredentialArn" xml) String.parse
      ; tde_credential_password =
          Aws.Util.option_bind (Aws.Xml.member "TdeCredentialPassword" xml) String.parse
      ; storage_encrypted =
          Aws.Util.option_bind (Aws.Xml.member "StorageEncrypted" xml) Boolean.parse
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "KmsKeyId" xml) String.parse
      ; domain = Aws.Util.option_bind (Aws.Xml.member "Domain" xml) String.parse
      ; copy_tags_to_snapshot =
          Aws.Util.option_bind (Aws.Xml.member "CopyTagsToSnapshot" xml) Boolean.parse
      ; monitoring_interval =
          Aws.Util.option_bind (Aws.Xml.member "MonitoringInterval" xml) Integer.parse
      ; monitoring_role_arn =
          Aws.Util.option_bind (Aws.Xml.member "MonitoringRoleArn" xml) String.parse
      ; domain_i_a_m_role_name =
          Aws.Util.option_bind (Aws.Xml.member "DomainIAMRoleName" xml) String.parse
      ; promotion_tier =
          Aws.Util.option_bind (Aws.Xml.member "PromotionTier" xml) Integer.parse
      ; timezone = Aws.Util.option_bind (Aws.Xml.member "Timezone" xml) String.parse
      ; enable_i_a_m_database_authentication =
          Aws.Util.option_bind
            (Aws.Xml.member "EnableIAMDatabaseAuthentication" xml)
            Boolean.parse
      ; enable_performance_insights =
          Aws.Util.option_bind
            (Aws.Xml.member "EnablePerformanceInsights" xml)
            Boolean.parse
      ; performance_insights_k_m_s_key_id =
          Aws.Util.option_bind
            (Aws.Xml.member "PerformanceInsightsKMSKeyId" xml)
            String.parse
      ; performance_insights_retention_period =
          Aws.Util.option_bind
            (Aws.Xml.member "PerformanceInsightsRetentionPeriod" xml)
            Integer.parse
      ; enable_cloudwatch_logs_exports =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "EnableCloudwatchLogsExports" xml)
               LogTypeList.parse)
      ; processor_features =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ProcessorFeatures" xml)
               ProcessorFeatureList.parse)
      ; deletion_protection =
          Aws.Util.option_bind (Aws.Xml.member "DeletionProtection" xml) Boolean.parse
      ; max_allocated_storage =
          Aws.Util.option_bind (Aws.Xml.member "MaxAllocatedStorage" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_allocated_storage (fun f ->
               Aws.Query.Pair ("MaxAllocatedStorage", Integer.to_query f))
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               Aws.Query.Pair ("DeletionProtection", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ProcessorFeatures.member"
                , ProcessorFeatureList.to_query v.processor_features ))
         ; Some
             (Aws.Query.Pair
                ( "EnableCloudwatchLogsExports.member"
                , LogTypeList.to_query v.enable_cloudwatch_logs_exports ))
         ; Aws.Util.option_map v.performance_insights_retention_period (fun f ->
               Aws.Query.Pair ("PerformanceInsightsRetentionPeriod", Integer.to_query f))
         ; Aws.Util.option_map v.performance_insights_k_m_s_key_id (fun f ->
               Aws.Query.Pair ("PerformanceInsightsKMSKeyId", String.to_query f))
         ; Aws.Util.option_map v.enable_performance_insights (fun f ->
               Aws.Query.Pair ("EnablePerformanceInsights", Boolean.to_query f))
         ; Aws.Util.option_map v.enable_i_a_m_database_authentication (fun f ->
               Aws.Query.Pair ("EnableIAMDatabaseAuthentication", Boolean.to_query f))
         ; Aws.Util.option_map v.timezone (fun f ->
               Aws.Query.Pair ("Timezone", String.to_query f))
         ; Aws.Util.option_map v.promotion_tier (fun f ->
               Aws.Query.Pair ("PromotionTier", Integer.to_query f))
         ; Aws.Util.option_map v.domain_i_a_m_role_name (fun f ->
               Aws.Query.Pair ("DomainIAMRoleName", String.to_query f))
         ; Aws.Util.option_map v.monitoring_role_arn (fun f ->
               Aws.Query.Pair ("MonitoringRoleArn", String.to_query f))
         ; Aws.Util.option_map v.monitoring_interval (fun f ->
               Aws.Query.Pair ("MonitoringInterval", Integer.to_query f))
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               Aws.Query.Pair ("CopyTagsToSnapshot", Boolean.to_query f))
         ; Aws.Util.option_map v.domain (fun f ->
               Aws.Query.Pair ("Domain", String.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Aws.Util.option_map v.storage_encrypted (fun f ->
               Aws.Query.Pair ("StorageEncrypted", Boolean.to_query f))
         ; Aws.Util.option_map v.tde_credential_password (fun f ->
               Aws.Query.Pair ("TdeCredentialPassword", String.to_query f))
         ; Aws.Util.option_map v.tde_credential_arn (fun f ->
               Aws.Query.Pair ("TdeCredentialArn", String.to_query f))
         ; Aws.Util.option_map v.storage_type (fun f ->
               Aws.Query.Pair ("StorageType", String.to_query f))
         ; Aws.Util.option_map v.d_b_cluster_identifier (fun f ->
               Aws.Query.Pair ("DBClusterIdentifier", String.to_query f))
         ; Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Aws.Util.option_map v.publicly_accessible (fun f ->
               Aws.Query.Pair ("PubliclyAccessible", Boolean.to_query f))
         ; Aws.Util.option_map v.nchar_character_set_name (fun f ->
               Aws.Query.Pair ("NcharCharacterSetName", String.to_query f))
         ; Aws.Util.option_map v.character_set_name (fun f ->
               Aws.Query.Pair ("CharacterSetName", String.to_query f))
         ; Aws.Util.option_map v.option_group_name (fun f ->
               Aws.Query.Pair ("OptionGroupName", String.to_query f))
         ; Aws.Util.option_map v.iops (fun f ->
               Aws.Query.Pair ("Iops", Integer.to_query f))
         ; Aws.Util.option_map v.license_model (fun f ->
               Aws.Query.Pair ("LicenseModel", String.to_query f))
         ; Aws.Util.option_map v.auto_minor_version_upgrade (fun f ->
               Aws.Query.Pair ("AutoMinorVersionUpgrade", Boolean.to_query f))
         ; Aws.Util.option_map v.engine_version (fun f ->
               Aws.Query.Pair ("EngineVersion", String.to_query f))
         ; Aws.Util.option_map v.multi_a_z (fun f ->
               Aws.Query.Pair ("MultiAZ", Boolean.to_query f))
         ; Aws.Util.option_map v.port (fun f ->
               Aws.Query.Pair ("Port", Integer.to_query f))
         ; Aws.Util.option_map v.preferred_backup_window (fun f ->
               Aws.Query.Pair ("PreferredBackupWindow", String.to_query f))
         ; Aws.Util.option_map v.backup_retention_period (fun f ->
               Aws.Query.Pair ("BackupRetentionPeriod", Integer.to_query f))
         ; Aws.Util.option_map v.d_b_parameter_group_name (fun f ->
               Aws.Query.Pair ("DBParameterGroupName", String.to_query f))
         ; Aws.Util.option_map v.preferred_maintenance_window (fun f ->
               Aws.Query.Pair ("PreferredMaintenanceWindow", String.to_query f))
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               Aws.Query.Pair ("DBSubnetGroupName", String.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "VpcSecurityGroupIds.member"
                , VpcSecurityGroupIdList.to_query v.vpc_security_group_ids ))
         ; Some
             (Aws.Query.Pair
                ( "DBSecurityGroups.member"
                , DBSecurityGroupNameList.to_query v.d_b_security_groups ))
         ; Aws.Util.option_map v.master_user_password (fun f ->
               Aws.Query.Pair ("MasterUserPassword", String.to_query f))
         ; Aws.Util.option_map v.master_username (fun f ->
               Aws.Query.Pair ("MasterUsername", String.to_query f))
         ; Some (Aws.Query.Pair ("Engine", String.to_query v.engine))
         ; Some (Aws.Query.Pair ("DBInstanceClass", String.to_query v.d_b_instance_class))
         ; Aws.Util.option_map v.allocated_storage (fun f ->
               Aws.Query.Pair ("AllocatedStorage", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DBInstanceIdentifier", String.to_query v.d_b_instance_identifier))
         ; Aws.Util.option_map v.d_b_name (fun f ->
               Aws.Query.Pair ("DBName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_allocated_storage (fun f ->
               "MaxAllocatedStorage", Integer.to_json f)
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               "DeletionProtection", Boolean.to_json f)
         ; Some ("ProcessorFeatures", ProcessorFeatureList.to_json v.processor_features)
         ; Some
             ( "EnableCloudwatchLogsExports"
             , LogTypeList.to_json v.enable_cloudwatch_logs_exports )
         ; Aws.Util.option_map v.performance_insights_retention_period (fun f ->
               "PerformanceInsightsRetentionPeriod", Integer.to_json f)
         ; Aws.Util.option_map v.performance_insights_k_m_s_key_id (fun f ->
               "PerformanceInsightsKMSKeyId", String.to_json f)
         ; Aws.Util.option_map v.enable_performance_insights (fun f ->
               "EnablePerformanceInsights", Boolean.to_json f)
         ; Aws.Util.option_map v.enable_i_a_m_database_authentication (fun f ->
               "EnableIAMDatabaseAuthentication", Boolean.to_json f)
         ; Aws.Util.option_map v.timezone (fun f -> "Timezone", String.to_json f)
         ; Aws.Util.option_map v.promotion_tier (fun f ->
               "PromotionTier", Integer.to_json f)
         ; Aws.Util.option_map v.domain_i_a_m_role_name (fun f ->
               "DomainIAMRoleName", String.to_json f)
         ; Aws.Util.option_map v.monitoring_role_arn (fun f ->
               "MonitoringRoleArn", String.to_json f)
         ; Aws.Util.option_map v.monitoring_interval (fun f ->
               "MonitoringInterval", Integer.to_json f)
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               "CopyTagsToSnapshot", Boolean.to_json f)
         ; Aws.Util.option_map v.domain (fun f -> "Domain", String.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "KmsKeyId", String.to_json f)
         ; Aws.Util.option_map v.storage_encrypted (fun f ->
               "StorageEncrypted", Boolean.to_json f)
         ; Aws.Util.option_map v.tde_credential_password (fun f ->
               "TdeCredentialPassword", String.to_json f)
         ; Aws.Util.option_map v.tde_credential_arn (fun f ->
               "TdeCredentialArn", String.to_json f)
         ; Aws.Util.option_map v.storage_type (fun f -> "StorageType", String.to_json f)
         ; Aws.Util.option_map v.d_b_cluster_identifier (fun f ->
               "DBClusterIdentifier", String.to_json f)
         ; Some ("Tags", TagList.to_json v.tags)
         ; Aws.Util.option_map v.publicly_accessible (fun f ->
               "PubliclyAccessible", Boolean.to_json f)
         ; Aws.Util.option_map v.nchar_character_set_name (fun f ->
               "NcharCharacterSetName", String.to_json f)
         ; Aws.Util.option_map v.character_set_name (fun f ->
               "CharacterSetName", String.to_json f)
         ; Aws.Util.option_map v.option_group_name (fun f ->
               "OptionGroupName", String.to_json f)
         ; Aws.Util.option_map v.iops (fun f -> "Iops", Integer.to_json f)
         ; Aws.Util.option_map v.license_model (fun f -> "LicenseModel", String.to_json f)
         ; Aws.Util.option_map v.auto_minor_version_upgrade (fun f ->
               "AutoMinorVersionUpgrade", Boolean.to_json f)
         ; Aws.Util.option_map v.engine_version (fun f ->
               "EngineVersion", String.to_json f)
         ; Aws.Util.option_map v.multi_a_z (fun f -> "MultiAZ", Boolean.to_json f)
         ; Aws.Util.option_map v.port (fun f -> "Port", Integer.to_json f)
         ; Aws.Util.option_map v.preferred_backup_window (fun f ->
               "PreferredBackupWindow", String.to_json f)
         ; Aws.Util.option_map v.backup_retention_period (fun f ->
               "BackupRetentionPeriod", Integer.to_json f)
         ; Aws.Util.option_map v.d_b_parameter_group_name (fun f ->
               "DBParameterGroupName", String.to_json f)
         ; Aws.Util.option_map v.preferred_maintenance_window (fun f ->
               "PreferredMaintenanceWindow", String.to_json f)
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               "DBSubnetGroupName", String.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "AvailabilityZone", String.to_json f)
         ; Some
             ( "VpcSecurityGroupIds"
             , VpcSecurityGroupIdList.to_json v.vpc_security_group_ids )
         ; Some ("DBSecurityGroups", DBSecurityGroupNameList.to_json v.d_b_security_groups)
         ; Aws.Util.option_map v.master_user_password (fun f ->
               "MasterUserPassword", String.to_json f)
         ; Aws.Util.option_map v.master_username (fun f ->
               "MasterUsername", String.to_json f)
         ; Some ("Engine", String.to_json v.engine)
         ; Some ("DBInstanceClass", String.to_json v.d_b_instance_class)
         ; Aws.Util.option_map v.allocated_storage (fun f ->
               "AllocatedStorage", Integer.to_json f)
         ; Some ("DBInstanceIdentifier", String.to_json v.d_b_instance_identifier)
         ; Aws.Util.option_map v.d_b_name (fun f -> "DBName", String.to_json f)
         ])

  let of_json j =
    { d_b_name = Aws.Util.option_map (Aws.Json.lookup j "DBName") String.of_json
    ; d_b_instance_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBInstanceIdentifier"))
    ; allocated_storage =
        Aws.Util.option_map (Aws.Json.lookup j "AllocatedStorage") Integer.of_json
    ; d_b_instance_class =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBInstanceClass"))
    ; engine = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Engine"))
    ; master_username =
        Aws.Util.option_map (Aws.Json.lookup j "MasterUsername") String.of_json
    ; master_user_password =
        Aws.Util.option_map (Aws.Json.lookup j "MasterUserPassword") String.of_json
    ; d_b_security_groups =
        DBSecurityGroupNameList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBSecurityGroups"))
    ; vpc_security_group_ids =
        VpcSecurityGroupIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcSecurityGroupIds"))
    ; availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "AvailabilityZone") String.of_json
    ; d_b_subnet_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBSubnetGroupName") String.of_json
    ; preferred_maintenance_window =
        Aws.Util.option_map
          (Aws.Json.lookup j "PreferredMaintenanceWindow")
          String.of_json
    ; d_b_parameter_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBParameterGroupName") String.of_json
    ; backup_retention_period =
        Aws.Util.option_map (Aws.Json.lookup j "BackupRetentionPeriod") Integer.of_json
    ; preferred_backup_window =
        Aws.Util.option_map (Aws.Json.lookup j "PreferredBackupWindow") String.of_json
    ; port = Aws.Util.option_map (Aws.Json.lookup j "Port") Integer.of_json
    ; multi_a_z = Aws.Util.option_map (Aws.Json.lookup j "MultiAZ") Boolean.of_json
    ; engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "EngineVersion") String.of_json
    ; auto_minor_version_upgrade =
        Aws.Util.option_map (Aws.Json.lookup j "AutoMinorVersionUpgrade") Boolean.of_json
    ; license_model =
        Aws.Util.option_map (Aws.Json.lookup j "LicenseModel") String.of_json
    ; iops = Aws.Util.option_map (Aws.Json.lookup j "Iops") Integer.of_json
    ; option_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "OptionGroupName") String.of_json
    ; character_set_name =
        Aws.Util.option_map (Aws.Json.lookup j "CharacterSetName") String.of_json
    ; nchar_character_set_name =
        Aws.Util.option_map (Aws.Json.lookup j "NcharCharacterSetName") String.of_json
    ; publicly_accessible =
        Aws.Util.option_map (Aws.Json.lookup j "PubliclyAccessible") Boolean.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    ; d_b_cluster_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "DBClusterIdentifier") String.of_json
    ; storage_type = Aws.Util.option_map (Aws.Json.lookup j "StorageType") String.of_json
    ; tde_credential_arn =
        Aws.Util.option_map (Aws.Json.lookup j "TdeCredentialArn") String.of_json
    ; tde_credential_password =
        Aws.Util.option_map (Aws.Json.lookup j "TdeCredentialPassword") String.of_json
    ; storage_encrypted =
        Aws.Util.option_map (Aws.Json.lookup j "StorageEncrypted") Boolean.of_json
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "KmsKeyId") String.of_json
    ; domain = Aws.Util.option_map (Aws.Json.lookup j "Domain") String.of_json
    ; copy_tags_to_snapshot =
        Aws.Util.option_map (Aws.Json.lookup j "CopyTagsToSnapshot") Boolean.of_json
    ; monitoring_interval =
        Aws.Util.option_map (Aws.Json.lookup j "MonitoringInterval") Integer.of_json
    ; monitoring_role_arn =
        Aws.Util.option_map (Aws.Json.lookup j "MonitoringRoleArn") String.of_json
    ; domain_i_a_m_role_name =
        Aws.Util.option_map (Aws.Json.lookup j "DomainIAMRoleName") String.of_json
    ; promotion_tier =
        Aws.Util.option_map (Aws.Json.lookup j "PromotionTier") Integer.of_json
    ; timezone = Aws.Util.option_map (Aws.Json.lookup j "Timezone") String.of_json
    ; enable_i_a_m_database_authentication =
        Aws.Util.option_map
          (Aws.Json.lookup j "EnableIAMDatabaseAuthentication")
          Boolean.of_json
    ; enable_performance_insights =
        Aws.Util.option_map
          (Aws.Json.lookup j "EnablePerformanceInsights")
          Boolean.of_json
    ; performance_insights_k_m_s_key_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "PerformanceInsightsKMSKeyId")
          String.of_json
    ; performance_insights_retention_period =
        Aws.Util.option_map
          (Aws.Json.lookup j "PerformanceInsightsRetentionPeriod")
          Integer.of_json
    ; enable_cloudwatch_logs_exports =
        LogTypeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "EnableCloudwatchLogsExports"))
    ; processor_features =
        ProcessorFeatureList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ProcessorFeatures"))
    ; deletion_protection =
        Aws.Util.option_map (Aws.Json.lookup j "DeletionProtection") Boolean.of_json
    ; max_allocated_storage =
        Aws.Util.option_map (Aws.Json.lookup j "MaxAllocatedStorage") Integer.of_json
    }
end

module CancelExportTaskMessage = struct
  type t = { export_task_identifier : String.t }

  let make ~export_task_identifier () = { export_task_identifier }

  let parse xml =
    Some
      { export_task_identifier =
          Aws.Xml.required
            "ExportTaskIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "ExportTaskIdentifier" xml)
               String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("ExportTaskIdentifier", String.to_query v.export_task_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("ExportTaskIdentifier", String.to_json v.export_task_identifier) ])

  let of_json j =
    { export_task_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ExportTaskIdentifier"))
    }
end

module OptionsDependedOn = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "OptionName" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module ReadReplicaDBInstanceIdentifierList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map String.parse (Aws.Xml.members "ReadReplicaDBInstanceIdentifier" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module PendingCloudwatchLogsExports = struct
  type t =
    { log_types_to_enable : LogTypeList.t
    ; log_types_to_disable : LogTypeList.t
    }

  let make ?(log_types_to_enable = []) ?(log_types_to_disable = []) () =
    { log_types_to_enable; log_types_to_disable }

  let parse xml =
    Some
      { log_types_to_enable =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "LogTypesToEnable" xml)
               LogTypeList.parse)
      ; log_types_to_disable =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "LogTypesToDisable" xml)
               LogTypeList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("LogTypesToDisable.member", LogTypeList.to_query v.log_types_to_disable))
         ; Some
             (Aws.Query.Pair
                ("LogTypesToEnable.member", LogTypeList.to_query v.log_types_to_enable))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("LogTypesToDisable", LogTypeList.to_json v.log_types_to_disable)
         ; Some ("LogTypesToEnable", LogTypeList.to_json v.log_types_to_enable)
         ])

  let of_json j =
    { log_types_to_enable =
        LogTypeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "LogTypesToEnable"))
    ; log_types_to_disable =
        LogTypeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "LogTypesToDisable"))
    }
end

module PendingModifiedValues = struct
  type t =
    { d_b_instance_class : String.t option
    ; allocated_storage : Integer.t option
    ; master_user_password : String.t option
    ; port : Integer.t option
    ; backup_retention_period : Integer.t option
    ; multi_a_z : Boolean.t option
    ; engine_version : String.t option
    ; license_model : String.t option
    ; iops : Integer.t option
    ; d_b_instance_identifier : String.t option
    ; storage_type : String.t option
    ; c_a_certificate_identifier : String.t option
    ; d_b_subnet_group_name : String.t option
    ; pending_cloudwatch_logs_exports : PendingCloudwatchLogsExports.t option
    ; processor_features : ProcessorFeatureList.t
    }

  let make
      ?d_b_instance_class
      ?allocated_storage
      ?master_user_password
      ?port
      ?backup_retention_period
      ?multi_a_z
      ?engine_version
      ?license_model
      ?iops
      ?d_b_instance_identifier
      ?storage_type
      ?c_a_certificate_identifier
      ?d_b_subnet_group_name
      ?pending_cloudwatch_logs_exports
      ?(processor_features = [])
      () =
    { d_b_instance_class
    ; allocated_storage
    ; master_user_password
    ; port
    ; backup_retention_period
    ; multi_a_z
    ; engine_version
    ; license_model
    ; iops
    ; d_b_instance_identifier
    ; storage_type
    ; c_a_certificate_identifier
    ; d_b_subnet_group_name
    ; pending_cloudwatch_logs_exports
    ; processor_features
    }

  let parse xml =
    Some
      { d_b_instance_class =
          Aws.Util.option_bind (Aws.Xml.member "DBInstanceClass" xml) String.parse
      ; allocated_storage =
          Aws.Util.option_bind (Aws.Xml.member "AllocatedStorage" xml) Integer.parse
      ; master_user_password =
          Aws.Util.option_bind (Aws.Xml.member "MasterUserPassword" xml) String.parse
      ; port = Aws.Util.option_bind (Aws.Xml.member "Port" xml) Integer.parse
      ; backup_retention_period =
          Aws.Util.option_bind (Aws.Xml.member "BackupRetentionPeriod" xml) Integer.parse
      ; multi_a_z = Aws.Util.option_bind (Aws.Xml.member "MultiAZ" xml) Boolean.parse
      ; engine_version =
          Aws.Util.option_bind (Aws.Xml.member "EngineVersion" xml) String.parse
      ; license_model =
          Aws.Util.option_bind (Aws.Xml.member "LicenseModel" xml) String.parse
      ; iops = Aws.Util.option_bind (Aws.Xml.member "Iops" xml) Integer.parse
      ; d_b_instance_identifier =
          Aws.Util.option_bind (Aws.Xml.member "DBInstanceIdentifier" xml) String.parse
      ; storage_type =
          Aws.Util.option_bind (Aws.Xml.member "StorageType" xml) String.parse
      ; c_a_certificate_identifier =
          Aws.Util.option_bind (Aws.Xml.member "CACertificateIdentifier" xml) String.parse
      ; d_b_subnet_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBSubnetGroupName" xml) String.parse
      ; pending_cloudwatch_logs_exports =
          Aws.Util.option_bind
            (Aws.Xml.member "PendingCloudwatchLogsExports" xml)
            PendingCloudwatchLogsExports.parse
      ; processor_features =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ProcessorFeatures" xml)
               ProcessorFeatureList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "ProcessorFeatures.member"
                , ProcessorFeatureList.to_query v.processor_features ))
         ; Aws.Util.option_map v.pending_cloudwatch_logs_exports (fun f ->
               Aws.Query.Pair
                 ("PendingCloudwatchLogsExports", PendingCloudwatchLogsExports.to_query f))
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               Aws.Query.Pair ("DBSubnetGroupName", String.to_query f))
         ; Aws.Util.option_map v.c_a_certificate_identifier (fun f ->
               Aws.Query.Pair ("CACertificateIdentifier", String.to_query f))
         ; Aws.Util.option_map v.storage_type (fun f ->
               Aws.Query.Pair ("StorageType", String.to_query f))
         ; Aws.Util.option_map v.d_b_instance_identifier (fun f ->
               Aws.Query.Pair ("DBInstanceIdentifier", String.to_query f))
         ; Aws.Util.option_map v.iops (fun f ->
               Aws.Query.Pair ("Iops", Integer.to_query f))
         ; Aws.Util.option_map v.license_model (fun f ->
               Aws.Query.Pair ("LicenseModel", String.to_query f))
         ; Aws.Util.option_map v.engine_version (fun f ->
               Aws.Query.Pair ("EngineVersion", String.to_query f))
         ; Aws.Util.option_map v.multi_a_z (fun f ->
               Aws.Query.Pair ("MultiAZ", Boolean.to_query f))
         ; Aws.Util.option_map v.backup_retention_period (fun f ->
               Aws.Query.Pair ("BackupRetentionPeriod", Integer.to_query f))
         ; Aws.Util.option_map v.port (fun f ->
               Aws.Query.Pair ("Port", Integer.to_query f))
         ; Aws.Util.option_map v.master_user_password (fun f ->
               Aws.Query.Pair ("MasterUserPassword", String.to_query f))
         ; Aws.Util.option_map v.allocated_storage (fun f ->
               Aws.Query.Pair ("AllocatedStorage", Integer.to_query f))
         ; Aws.Util.option_map v.d_b_instance_class (fun f ->
               Aws.Query.Pair ("DBInstanceClass", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("ProcessorFeatures", ProcessorFeatureList.to_json v.processor_features)
         ; Aws.Util.option_map v.pending_cloudwatch_logs_exports (fun f ->
               "PendingCloudwatchLogsExports", PendingCloudwatchLogsExports.to_json f)
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               "DBSubnetGroupName", String.to_json f)
         ; Aws.Util.option_map v.c_a_certificate_identifier (fun f ->
               "CACertificateIdentifier", String.to_json f)
         ; Aws.Util.option_map v.storage_type (fun f -> "StorageType", String.to_json f)
         ; Aws.Util.option_map v.d_b_instance_identifier (fun f ->
               "DBInstanceIdentifier", String.to_json f)
         ; Aws.Util.option_map v.iops (fun f -> "Iops", Integer.to_json f)
         ; Aws.Util.option_map v.license_model (fun f -> "LicenseModel", String.to_json f)
         ; Aws.Util.option_map v.engine_version (fun f ->
               "EngineVersion", String.to_json f)
         ; Aws.Util.option_map v.multi_a_z (fun f -> "MultiAZ", Boolean.to_json f)
         ; Aws.Util.option_map v.backup_retention_period (fun f ->
               "BackupRetentionPeriod", Integer.to_json f)
         ; Aws.Util.option_map v.port (fun f -> "Port", Integer.to_json f)
         ; Aws.Util.option_map v.master_user_password (fun f ->
               "MasterUserPassword", String.to_json f)
         ; Aws.Util.option_map v.allocated_storage (fun f ->
               "AllocatedStorage", Integer.to_json f)
         ; Aws.Util.option_map v.d_b_instance_class (fun f ->
               "DBInstanceClass", String.to_json f)
         ])

  let of_json j =
    { d_b_instance_class =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstanceClass") String.of_json
    ; allocated_storage =
        Aws.Util.option_map (Aws.Json.lookup j "AllocatedStorage") Integer.of_json
    ; master_user_password =
        Aws.Util.option_map (Aws.Json.lookup j "MasterUserPassword") String.of_json
    ; port = Aws.Util.option_map (Aws.Json.lookup j "Port") Integer.of_json
    ; backup_retention_period =
        Aws.Util.option_map (Aws.Json.lookup j "BackupRetentionPeriod") Integer.of_json
    ; multi_a_z = Aws.Util.option_map (Aws.Json.lookup j "MultiAZ") Boolean.of_json
    ; engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "EngineVersion") String.of_json
    ; license_model =
        Aws.Util.option_map (Aws.Json.lookup j "LicenseModel") String.of_json
    ; iops = Aws.Util.option_map (Aws.Json.lookup j "Iops") Integer.of_json
    ; d_b_instance_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstanceIdentifier") String.of_json
    ; storage_type = Aws.Util.option_map (Aws.Json.lookup j "StorageType") String.of_json
    ; c_a_certificate_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "CACertificateIdentifier") String.of_json
    ; d_b_subnet_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBSubnetGroupName") String.of_json
    ; pending_cloudwatch_logs_exports =
        Aws.Util.option_map
          (Aws.Json.lookup j "PendingCloudwatchLogsExports")
          PendingCloudwatchLogsExports.of_json
    ; processor_features =
        ProcessorFeatureList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ProcessorFeatures"))
    }
end

module OptionGroupMembership = struct
  type t =
    { option_group_name : String.t option
    ; status : String.t option
    }

  let make ?option_group_name ?status () = { option_group_name; status }

  let parse xml =
    Some
      { option_group_name =
          Aws.Util.option_bind (Aws.Xml.member "OptionGroupName" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.option_group_name (fun f ->
               Aws.Query.Pair ("OptionGroupName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ; Aws.Util.option_map v.option_group_name (fun f ->
               "OptionGroupName", String.to_json f)
         ])

  let of_json j =
    { option_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "OptionGroupName") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    }
end

module OptionGroupMembershipList = struct
  type t = OptionGroupMembership.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map OptionGroupMembership.parse (Aws.Xml.members "OptionGroupMembership" xml))

  let to_query v = Aws.Query.to_query_list OptionGroupMembership.to_query v

  let to_json v = `List (List.map OptionGroupMembership.to_json v)

  let of_json j = Aws.Json.to_list OptionGroupMembership.of_json j
end

module Endpoint = struct
  type t =
    { address : String.t option
    ; port : Integer.t option
    ; hosted_zone_id : String.t option
    }

  let make ?address ?port ?hosted_zone_id () = { address; port; hosted_zone_id }

  let parse xml =
    Some
      { address = Aws.Util.option_bind (Aws.Xml.member "Address" xml) String.parse
      ; port = Aws.Util.option_bind (Aws.Xml.member "Port" xml) Integer.parse
      ; hosted_zone_id =
          Aws.Util.option_bind (Aws.Xml.member "HostedZoneId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.hosted_zone_id (fun f ->
               Aws.Query.Pair ("HostedZoneId", String.to_query f))
         ; Aws.Util.option_map v.port (fun f ->
               Aws.Query.Pair ("Port", Integer.to_query f))
         ; Aws.Util.option_map v.address (fun f ->
               Aws.Query.Pair ("Address", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.hosted_zone_id (fun f ->
               "HostedZoneId", String.to_json f)
         ; Aws.Util.option_map v.port (fun f -> "Port", Integer.to_json f)
         ; Aws.Util.option_map v.address (fun f -> "Address", String.to_json f)
         ])

  let of_json j =
    { address = Aws.Util.option_map (Aws.Json.lookup j "Address") String.of_json
    ; port = Aws.Util.option_map (Aws.Json.lookup j "Port") Integer.of_json
    ; hosted_zone_id =
        Aws.Util.option_map (Aws.Json.lookup j "HostedZoneId") String.of_json
    }
end

module DBParameterGroupStatus = struct
  type t =
    { d_b_parameter_group_name : String.t option
    ; parameter_apply_status : String.t option
    }

  let make ?d_b_parameter_group_name ?parameter_apply_status () =
    { d_b_parameter_group_name; parameter_apply_status }

  let parse xml =
    Some
      { d_b_parameter_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBParameterGroupName" xml) String.parse
      ; parameter_apply_status =
          Aws.Util.option_bind (Aws.Xml.member "ParameterApplyStatus" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.parameter_apply_status (fun f ->
               Aws.Query.Pair ("ParameterApplyStatus", String.to_query f))
         ; Aws.Util.option_map v.d_b_parameter_group_name (fun f ->
               Aws.Query.Pair ("DBParameterGroupName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.parameter_apply_status (fun f ->
               "ParameterApplyStatus", String.to_json f)
         ; Aws.Util.option_map v.d_b_parameter_group_name (fun f ->
               "DBParameterGroupName", String.to_json f)
         ])

  let of_json j =
    { d_b_parameter_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBParameterGroupName") String.of_json
    ; parameter_apply_status =
        Aws.Util.option_map (Aws.Json.lookup j "ParameterApplyStatus") String.of_json
    }
end

module DBParameterGroupStatusList = struct
  type t = DBParameterGroupStatus.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map DBParameterGroupStatus.parse (Aws.Xml.members "DBParameterGroup" xml))

  let to_query v = Aws.Query.to_query_list DBParameterGroupStatus.to_query v

  let to_json v = `List (List.map DBParameterGroupStatus.to_json v)

  let of_json j = Aws.Json.to_list DBParameterGroupStatus.of_json j
end

module DBInstanceStatusInfo = struct
  type t =
    { status_type : String.t option
    ; normal : Boolean.t option
    ; status : String.t option
    ; message : String.t option
    }

  let make ?status_type ?normal ?status ?message () =
    { status_type; normal; status; message }

  let parse xml =
    Some
      { status_type = Aws.Util.option_bind (Aws.Xml.member "StatusType" xml) String.parse
      ; normal = Aws.Util.option_bind (Aws.Xml.member "Normal" xml) Boolean.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.normal (fun f ->
               Aws.Query.Pair ("Normal", Boolean.to_query f))
         ; Aws.Util.option_map v.status_type (fun f ->
               Aws.Query.Pair ("StatusType", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "Message", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ; Aws.Util.option_map v.normal (fun f -> "Normal", Boolean.to_json f)
         ; Aws.Util.option_map v.status_type (fun f -> "StatusType", String.to_json f)
         ])

  let of_json j =
    { status_type = Aws.Util.option_map (Aws.Json.lookup j "StatusType") String.of_json
    ; normal = Aws.Util.option_map (Aws.Json.lookup j "Normal") Boolean.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "Message") String.of_json
    }
end

module DBInstanceStatusInfoList = struct
  type t = DBInstanceStatusInfo.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map DBInstanceStatusInfo.parse (Aws.Xml.members "DBInstanceStatusInfo" xml))

  let to_query v = Aws.Query.to_query_list DBInstanceStatusInfo.to_query v

  let to_json v = `List (List.map DBInstanceStatusInfo.to_json v)

  let of_json j = Aws.Json.to_list DBInstanceStatusInfo.of_json j
end

module DBInstanceRoles = struct
  type t = DBInstanceRole.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map DBInstanceRole.parse (Aws.Xml.members "DBInstanceRole" xml))

  let to_query v = Aws.Query.to_query_list DBInstanceRole.to_query v

  let to_json v = `List (List.map DBInstanceRole.to_json v)

  let of_json j = Aws.Json.to_list DBInstanceRole.of_json j
end

module DBInstance = struct
  type t =
    { d_b_instance_identifier : String.t option
    ; d_b_instance_class : String.t option
    ; engine : String.t option
    ; d_b_instance_status : String.t option
    ; master_username : String.t option
    ; d_b_name : String.t option
    ; endpoint : Endpoint.t option
    ; allocated_storage : Integer.t option
    ; instance_create_time : DateTime.t option
    ; preferred_backup_window : String.t option
    ; backup_retention_period : Integer.t option
    ; d_b_security_groups : DBSecurityGroupMembershipList.t
    ; vpc_security_groups : VpcSecurityGroupMembershipList.t
    ; d_b_parameter_groups : DBParameterGroupStatusList.t
    ; availability_zone : String.t option
    ; d_b_subnet_group : DBSubnetGroup.t option
    ; preferred_maintenance_window : String.t option
    ; pending_modified_values : PendingModifiedValues.t option
    ; latest_restorable_time : DateTime.t option
    ; multi_a_z : Boolean.t option
    ; engine_version : String.t option
    ; auto_minor_version_upgrade : Boolean.t option
    ; read_replica_source_d_b_instance_identifier : String.t option
    ; read_replica_d_b_instance_identifiers : ReadReplicaDBInstanceIdentifierList.t
    ; read_replica_d_b_cluster_identifiers : ReadReplicaDBClusterIdentifierList.t
    ; replica_mode : ReplicaMode.t option
    ; license_model : String.t option
    ; iops : Integer.t option
    ; option_group_memberships : OptionGroupMembershipList.t
    ; character_set_name : String.t option
    ; nchar_character_set_name : String.t option
    ; secondary_availability_zone : String.t option
    ; publicly_accessible : Boolean.t option
    ; status_infos : DBInstanceStatusInfoList.t
    ; storage_type : String.t option
    ; tde_credential_arn : String.t option
    ; db_instance_port : Integer.t option
    ; d_b_cluster_identifier : String.t option
    ; storage_encrypted : Boolean.t option
    ; kms_key_id : String.t option
    ; dbi_resource_id : String.t option
    ; c_a_certificate_identifier : String.t option
    ; domain_memberships : DomainMembershipList.t
    ; copy_tags_to_snapshot : Boolean.t option
    ; monitoring_interval : Integer.t option
    ; enhanced_monitoring_resource_arn : String.t option
    ; monitoring_role_arn : String.t option
    ; promotion_tier : Integer.t option
    ; d_b_instance_arn : String.t option
    ; timezone : String.t option
    ; i_a_m_database_authentication_enabled : Boolean.t option
    ; performance_insights_enabled : Boolean.t option
    ; performance_insights_k_m_s_key_id : String.t option
    ; performance_insights_retention_period : Integer.t option
    ; enabled_cloudwatch_logs_exports : LogTypeList.t
    ; processor_features : ProcessorFeatureList.t
    ; deletion_protection : Boolean.t option
    ; associated_roles : DBInstanceRoles.t
    ; listener_endpoint : Endpoint.t option
    ; max_allocated_storage : Integer.t option
    ; tag_list : TagList.t
    }

  let make
      ?d_b_instance_identifier
      ?d_b_instance_class
      ?engine
      ?d_b_instance_status
      ?master_username
      ?d_b_name
      ?endpoint
      ?allocated_storage
      ?instance_create_time
      ?preferred_backup_window
      ?backup_retention_period
      ?(d_b_security_groups = [])
      ?(vpc_security_groups = [])
      ?(d_b_parameter_groups = [])
      ?availability_zone
      ?d_b_subnet_group
      ?preferred_maintenance_window
      ?pending_modified_values
      ?latest_restorable_time
      ?multi_a_z
      ?engine_version
      ?auto_minor_version_upgrade
      ?read_replica_source_d_b_instance_identifier
      ?(read_replica_d_b_instance_identifiers = [])
      ?(read_replica_d_b_cluster_identifiers = [])
      ?replica_mode
      ?license_model
      ?iops
      ?(option_group_memberships = [])
      ?character_set_name
      ?nchar_character_set_name
      ?secondary_availability_zone
      ?publicly_accessible
      ?(status_infos = [])
      ?storage_type
      ?tde_credential_arn
      ?db_instance_port
      ?d_b_cluster_identifier
      ?storage_encrypted
      ?kms_key_id
      ?dbi_resource_id
      ?c_a_certificate_identifier
      ?(domain_memberships = [])
      ?copy_tags_to_snapshot
      ?monitoring_interval
      ?enhanced_monitoring_resource_arn
      ?monitoring_role_arn
      ?promotion_tier
      ?d_b_instance_arn
      ?timezone
      ?i_a_m_database_authentication_enabled
      ?performance_insights_enabled
      ?performance_insights_k_m_s_key_id
      ?performance_insights_retention_period
      ?(enabled_cloudwatch_logs_exports = [])
      ?(processor_features = [])
      ?deletion_protection
      ?(associated_roles = [])
      ?listener_endpoint
      ?max_allocated_storage
      ?(tag_list = [])
      () =
    { d_b_instance_identifier
    ; d_b_instance_class
    ; engine
    ; d_b_instance_status
    ; master_username
    ; d_b_name
    ; endpoint
    ; allocated_storage
    ; instance_create_time
    ; preferred_backup_window
    ; backup_retention_period
    ; d_b_security_groups
    ; vpc_security_groups
    ; d_b_parameter_groups
    ; availability_zone
    ; d_b_subnet_group
    ; preferred_maintenance_window
    ; pending_modified_values
    ; latest_restorable_time
    ; multi_a_z
    ; engine_version
    ; auto_minor_version_upgrade
    ; read_replica_source_d_b_instance_identifier
    ; read_replica_d_b_instance_identifiers
    ; read_replica_d_b_cluster_identifiers
    ; replica_mode
    ; license_model
    ; iops
    ; option_group_memberships
    ; character_set_name
    ; nchar_character_set_name
    ; secondary_availability_zone
    ; publicly_accessible
    ; status_infos
    ; storage_type
    ; tde_credential_arn
    ; db_instance_port
    ; d_b_cluster_identifier
    ; storage_encrypted
    ; kms_key_id
    ; dbi_resource_id
    ; c_a_certificate_identifier
    ; domain_memberships
    ; copy_tags_to_snapshot
    ; monitoring_interval
    ; enhanced_monitoring_resource_arn
    ; monitoring_role_arn
    ; promotion_tier
    ; d_b_instance_arn
    ; timezone
    ; i_a_m_database_authentication_enabled
    ; performance_insights_enabled
    ; performance_insights_k_m_s_key_id
    ; performance_insights_retention_period
    ; enabled_cloudwatch_logs_exports
    ; processor_features
    ; deletion_protection
    ; associated_roles
    ; listener_endpoint
    ; max_allocated_storage
    ; tag_list
    }

  let parse xml =
    Some
      { d_b_instance_identifier =
          Aws.Util.option_bind (Aws.Xml.member "DBInstanceIdentifier" xml) String.parse
      ; d_b_instance_class =
          Aws.Util.option_bind (Aws.Xml.member "DBInstanceClass" xml) String.parse
      ; engine = Aws.Util.option_bind (Aws.Xml.member "Engine" xml) String.parse
      ; d_b_instance_status =
          Aws.Util.option_bind (Aws.Xml.member "DBInstanceStatus" xml) String.parse
      ; master_username =
          Aws.Util.option_bind (Aws.Xml.member "MasterUsername" xml) String.parse
      ; d_b_name = Aws.Util.option_bind (Aws.Xml.member "DBName" xml) String.parse
      ; endpoint = Aws.Util.option_bind (Aws.Xml.member "Endpoint" xml) Endpoint.parse
      ; allocated_storage =
          Aws.Util.option_bind (Aws.Xml.member "AllocatedStorage" xml) Integer.parse
      ; instance_create_time =
          Aws.Util.option_bind (Aws.Xml.member "InstanceCreateTime" xml) DateTime.parse
      ; preferred_backup_window =
          Aws.Util.option_bind (Aws.Xml.member "PreferredBackupWindow" xml) String.parse
      ; backup_retention_period =
          Aws.Util.option_bind (Aws.Xml.member "BackupRetentionPeriod" xml) Integer.parse
      ; d_b_security_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DBSecurityGroups" xml)
               DBSecurityGroupMembershipList.parse)
      ; vpc_security_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "VpcSecurityGroups" xml)
               VpcSecurityGroupMembershipList.parse)
      ; d_b_parameter_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DBParameterGroups" xml)
               DBParameterGroupStatusList.parse)
      ; availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "AvailabilityZone" xml) String.parse
      ; d_b_subnet_group =
          Aws.Util.option_bind (Aws.Xml.member "DBSubnetGroup" xml) DBSubnetGroup.parse
      ; preferred_maintenance_window =
          Aws.Util.option_bind
            (Aws.Xml.member "PreferredMaintenanceWindow" xml)
            String.parse
      ; pending_modified_values =
          Aws.Util.option_bind
            (Aws.Xml.member "PendingModifiedValues" xml)
            PendingModifiedValues.parse
      ; latest_restorable_time =
          Aws.Util.option_bind (Aws.Xml.member "LatestRestorableTime" xml) DateTime.parse
      ; multi_a_z = Aws.Util.option_bind (Aws.Xml.member "MultiAZ" xml) Boolean.parse
      ; engine_version =
          Aws.Util.option_bind (Aws.Xml.member "EngineVersion" xml) String.parse
      ; auto_minor_version_upgrade =
          Aws.Util.option_bind
            (Aws.Xml.member "AutoMinorVersionUpgrade" xml)
            Boolean.parse
      ; read_replica_source_d_b_instance_identifier =
          Aws.Util.option_bind
            (Aws.Xml.member "ReadReplicaSourceDBInstanceIdentifier" xml)
            String.parse
      ; read_replica_d_b_instance_identifiers =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ReadReplicaDBInstanceIdentifiers" xml)
               ReadReplicaDBInstanceIdentifierList.parse)
      ; read_replica_d_b_cluster_identifiers =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ReadReplicaDBClusterIdentifiers" xml)
               ReadReplicaDBClusterIdentifierList.parse)
      ; replica_mode =
          Aws.Util.option_bind (Aws.Xml.member "ReplicaMode" xml) ReplicaMode.parse
      ; license_model =
          Aws.Util.option_bind (Aws.Xml.member "LicenseModel" xml) String.parse
      ; iops = Aws.Util.option_bind (Aws.Xml.member "Iops" xml) Integer.parse
      ; option_group_memberships =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "OptionGroupMemberships" xml)
               OptionGroupMembershipList.parse)
      ; character_set_name =
          Aws.Util.option_bind (Aws.Xml.member "CharacterSetName" xml) String.parse
      ; nchar_character_set_name =
          Aws.Util.option_bind (Aws.Xml.member "NcharCharacterSetName" xml) String.parse
      ; secondary_availability_zone =
          Aws.Util.option_bind
            (Aws.Xml.member "SecondaryAvailabilityZone" xml)
            String.parse
      ; publicly_accessible =
          Aws.Util.option_bind (Aws.Xml.member "PubliclyAccessible" xml) Boolean.parse
      ; status_infos =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "StatusInfos" xml)
               DBInstanceStatusInfoList.parse)
      ; storage_type =
          Aws.Util.option_bind (Aws.Xml.member "StorageType" xml) String.parse
      ; tde_credential_arn =
          Aws.Util.option_bind (Aws.Xml.member "TdeCredentialArn" xml) String.parse
      ; db_instance_port =
          Aws.Util.option_bind (Aws.Xml.member "DbInstancePort" xml) Integer.parse
      ; d_b_cluster_identifier =
          Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse
      ; storage_encrypted =
          Aws.Util.option_bind (Aws.Xml.member "StorageEncrypted" xml) Boolean.parse
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "KmsKeyId" xml) String.parse
      ; dbi_resource_id =
          Aws.Util.option_bind (Aws.Xml.member "DbiResourceId" xml) String.parse
      ; c_a_certificate_identifier =
          Aws.Util.option_bind (Aws.Xml.member "CACertificateIdentifier" xml) String.parse
      ; domain_memberships =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DomainMemberships" xml)
               DomainMembershipList.parse)
      ; copy_tags_to_snapshot =
          Aws.Util.option_bind (Aws.Xml.member "CopyTagsToSnapshot" xml) Boolean.parse
      ; monitoring_interval =
          Aws.Util.option_bind (Aws.Xml.member "MonitoringInterval" xml) Integer.parse
      ; enhanced_monitoring_resource_arn =
          Aws.Util.option_bind
            (Aws.Xml.member "EnhancedMonitoringResourceArn" xml)
            String.parse
      ; monitoring_role_arn =
          Aws.Util.option_bind (Aws.Xml.member "MonitoringRoleArn" xml) String.parse
      ; promotion_tier =
          Aws.Util.option_bind (Aws.Xml.member "PromotionTier" xml) Integer.parse
      ; d_b_instance_arn =
          Aws.Util.option_bind (Aws.Xml.member "DBInstanceArn" xml) String.parse
      ; timezone = Aws.Util.option_bind (Aws.Xml.member "Timezone" xml) String.parse
      ; i_a_m_database_authentication_enabled =
          Aws.Util.option_bind
            (Aws.Xml.member "IAMDatabaseAuthenticationEnabled" xml)
            Boolean.parse
      ; performance_insights_enabled =
          Aws.Util.option_bind
            (Aws.Xml.member "PerformanceInsightsEnabled" xml)
            Boolean.parse
      ; performance_insights_k_m_s_key_id =
          Aws.Util.option_bind
            (Aws.Xml.member "PerformanceInsightsKMSKeyId" xml)
            String.parse
      ; performance_insights_retention_period =
          Aws.Util.option_bind
            (Aws.Xml.member "PerformanceInsightsRetentionPeriod" xml)
            Integer.parse
      ; enabled_cloudwatch_logs_exports =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "EnabledCloudwatchLogsExports" xml)
               LogTypeList.parse)
      ; processor_features =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ProcessorFeatures" xml)
               ProcessorFeatureList.parse)
      ; deletion_protection =
          Aws.Util.option_bind (Aws.Xml.member "DeletionProtection" xml) Boolean.parse
      ; associated_roles =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AssociatedRoles" xml)
               DBInstanceRoles.parse)
      ; listener_endpoint =
          Aws.Util.option_bind (Aws.Xml.member "ListenerEndpoint" xml) Endpoint.parse
      ; max_allocated_storage =
          Aws.Util.option_bind (Aws.Xml.member "MaxAllocatedStorage" xml) Integer.parse
      ; tag_list =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "TagList" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagList.member", TagList.to_query v.tag_list))
         ; Aws.Util.option_map v.max_allocated_storage (fun f ->
               Aws.Query.Pair ("MaxAllocatedStorage", Integer.to_query f))
         ; Aws.Util.option_map v.listener_endpoint (fun f ->
               Aws.Query.Pair ("ListenerEndpoint", Endpoint.to_query f))
         ; Some
             (Aws.Query.Pair
                ("AssociatedRoles.member", DBInstanceRoles.to_query v.associated_roles))
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               Aws.Query.Pair ("DeletionProtection", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ProcessorFeatures.member"
                , ProcessorFeatureList.to_query v.processor_features ))
         ; Some
             (Aws.Query.Pair
                ( "EnabledCloudwatchLogsExports.member"
                , LogTypeList.to_query v.enabled_cloudwatch_logs_exports ))
         ; Aws.Util.option_map v.performance_insights_retention_period (fun f ->
               Aws.Query.Pair ("PerformanceInsightsRetentionPeriod", Integer.to_query f))
         ; Aws.Util.option_map v.performance_insights_k_m_s_key_id (fun f ->
               Aws.Query.Pair ("PerformanceInsightsKMSKeyId", String.to_query f))
         ; Aws.Util.option_map v.performance_insights_enabled (fun f ->
               Aws.Query.Pair ("PerformanceInsightsEnabled", Boolean.to_query f))
         ; Aws.Util.option_map v.i_a_m_database_authentication_enabled (fun f ->
               Aws.Query.Pair ("IAMDatabaseAuthenticationEnabled", Boolean.to_query f))
         ; Aws.Util.option_map v.timezone (fun f ->
               Aws.Query.Pair ("Timezone", String.to_query f))
         ; Aws.Util.option_map v.d_b_instance_arn (fun f ->
               Aws.Query.Pair ("DBInstanceArn", String.to_query f))
         ; Aws.Util.option_map v.promotion_tier (fun f ->
               Aws.Query.Pair ("PromotionTier", Integer.to_query f))
         ; Aws.Util.option_map v.monitoring_role_arn (fun f ->
               Aws.Query.Pair ("MonitoringRoleArn", String.to_query f))
         ; Aws.Util.option_map v.enhanced_monitoring_resource_arn (fun f ->
               Aws.Query.Pair ("EnhancedMonitoringResourceArn", String.to_query f))
         ; Aws.Util.option_map v.monitoring_interval (fun f ->
               Aws.Query.Pair ("MonitoringInterval", Integer.to_query f))
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               Aws.Query.Pair ("CopyTagsToSnapshot", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "DomainMemberships.member"
                , DomainMembershipList.to_query v.domain_memberships ))
         ; Aws.Util.option_map v.c_a_certificate_identifier (fun f ->
               Aws.Query.Pair ("CACertificateIdentifier", String.to_query f))
         ; Aws.Util.option_map v.dbi_resource_id (fun f ->
               Aws.Query.Pair ("DbiResourceId", String.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Aws.Util.option_map v.storage_encrypted (fun f ->
               Aws.Query.Pair ("StorageEncrypted", Boolean.to_query f))
         ; Aws.Util.option_map v.d_b_cluster_identifier (fun f ->
               Aws.Query.Pair ("DBClusterIdentifier", String.to_query f))
         ; Aws.Util.option_map v.db_instance_port (fun f ->
               Aws.Query.Pair ("DbInstancePort", Integer.to_query f))
         ; Aws.Util.option_map v.tde_credential_arn (fun f ->
               Aws.Query.Pair ("TdeCredentialArn", String.to_query f))
         ; Aws.Util.option_map v.storage_type (fun f ->
               Aws.Query.Pair ("StorageType", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("StatusInfos.member", DBInstanceStatusInfoList.to_query v.status_infos))
         ; Aws.Util.option_map v.publicly_accessible (fun f ->
               Aws.Query.Pair ("PubliclyAccessible", Boolean.to_query f))
         ; Aws.Util.option_map v.secondary_availability_zone (fun f ->
               Aws.Query.Pair ("SecondaryAvailabilityZone", String.to_query f))
         ; Aws.Util.option_map v.nchar_character_set_name (fun f ->
               Aws.Query.Pair ("NcharCharacterSetName", String.to_query f))
         ; Aws.Util.option_map v.character_set_name (fun f ->
               Aws.Query.Pair ("CharacterSetName", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "OptionGroupMemberships.member"
                , OptionGroupMembershipList.to_query v.option_group_memberships ))
         ; Aws.Util.option_map v.iops (fun f ->
               Aws.Query.Pair ("Iops", Integer.to_query f))
         ; Aws.Util.option_map v.license_model (fun f ->
               Aws.Query.Pair ("LicenseModel", String.to_query f))
         ; Aws.Util.option_map v.replica_mode (fun f ->
               Aws.Query.Pair ("ReplicaMode", ReplicaMode.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ReadReplicaDBClusterIdentifiers.member"
                , ReadReplicaDBClusterIdentifierList.to_query
                    v.read_replica_d_b_cluster_identifiers ))
         ; Some
             (Aws.Query.Pair
                ( "ReadReplicaDBInstanceIdentifiers.member"
                , ReadReplicaDBInstanceIdentifierList.to_query
                    v.read_replica_d_b_instance_identifiers ))
         ; Aws.Util.option_map v.read_replica_source_d_b_instance_identifier (fun f ->
               Aws.Query.Pair ("ReadReplicaSourceDBInstanceIdentifier", String.to_query f))
         ; Aws.Util.option_map v.auto_minor_version_upgrade (fun f ->
               Aws.Query.Pair ("AutoMinorVersionUpgrade", Boolean.to_query f))
         ; Aws.Util.option_map v.engine_version (fun f ->
               Aws.Query.Pair ("EngineVersion", String.to_query f))
         ; Aws.Util.option_map v.multi_a_z (fun f ->
               Aws.Query.Pair ("MultiAZ", Boolean.to_query f))
         ; Aws.Util.option_map v.latest_restorable_time (fun f ->
               Aws.Query.Pair ("LatestRestorableTime", DateTime.to_query f))
         ; Aws.Util.option_map v.pending_modified_values (fun f ->
               Aws.Query.Pair ("PendingModifiedValues", PendingModifiedValues.to_query f))
         ; Aws.Util.option_map v.preferred_maintenance_window (fun f ->
               Aws.Query.Pair ("PreferredMaintenanceWindow", String.to_query f))
         ; Aws.Util.option_map v.d_b_subnet_group (fun f ->
               Aws.Query.Pair ("DBSubnetGroup", DBSubnetGroup.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "DBParameterGroups.member"
                , DBParameterGroupStatusList.to_query v.d_b_parameter_groups ))
         ; Some
             (Aws.Query.Pair
                ( "VpcSecurityGroups.member"
                , VpcSecurityGroupMembershipList.to_query v.vpc_security_groups ))
         ; Some
             (Aws.Query.Pair
                ( "DBSecurityGroups.member"
                , DBSecurityGroupMembershipList.to_query v.d_b_security_groups ))
         ; Aws.Util.option_map v.backup_retention_period (fun f ->
               Aws.Query.Pair ("BackupRetentionPeriod", Integer.to_query f))
         ; Aws.Util.option_map v.preferred_backup_window (fun f ->
               Aws.Query.Pair ("PreferredBackupWindow", String.to_query f))
         ; Aws.Util.option_map v.instance_create_time (fun f ->
               Aws.Query.Pair ("InstanceCreateTime", DateTime.to_query f))
         ; Aws.Util.option_map v.allocated_storage (fun f ->
               Aws.Query.Pair ("AllocatedStorage", Integer.to_query f))
         ; Aws.Util.option_map v.endpoint (fun f ->
               Aws.Query.Pair ("Endpoint", Endpoint.to_query f))
         ; Aws.Util.option_map v.d_b_name (fun f ->
               Aws.Query.Pair ("DBName", String.to_query f))
         ; Aws.Util.option_map v.master_username (fun f ->
               Aws.Query.Pair ("MasterUsername", String.to_query f))
         ; Aws.Util.option_map v.d_b_instance_status (fun f ->
               Aws.Query.Pair ("DBInstanceStatus", String.to_query f))
         ; Aws.Util.option_map v.engine (fun f ->
               Aws.Query.Pair ("Engine", String.to_query f))
         ; Aws.Util.option_map v.d_b_instance_class (fun f ->
               Aws.Query.Pair ("DBInstanceClass", String.to_query f))
         ; Aws.Util.option_map v.d_b_instance_identifier (fun f ->
               Aws.Query.Pair ("DBInstanceIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagList", TagList.to_json v.tag_list)
         ; Aws.Util.option_map v.max_allocated_storage (fun f ->
               "MaxAllocatedStorage", Integer.to_json f)
         ; Aws.Util.option_map v.listener_endpoint (fun f ->
               "ListenerEndpoint", Endpoint.to_json f)
         ; Some ("AssociatedRoles", DBInstanceRoles.to_json v.associated_roles)
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               "DeletionProtection", Boolean.to_json f)
         ; Some ("ProcessorFeatures", ProcessorFeatureList.to_json v.processor_features)
         ; Some
             ( "EnabledCloudwatchLogsExports"
             , LogTypeList.to_json v.enabled_cloudwatch_logs_exports )
         ; Aws.Util.option_map v.performance_insights_retention_period (fun f ->
               "PerformanceInsightsRetentionPeriod", Integer.to_json f)
         ; Aws.Util.option_map v.performance_insights_k_m_s_key_id (fun f ->
               "PerformanceInsightsKMSKeyId", String.to_json f)
         ; Aws.Util.option_map v.performance_insights_enabled (fun f ->
               "PerformanceInsightsEnabled", Boolean.to_json f)
         ; Aws.Util.option_map v.i_a_m_database_authentication_enabled (fun f ->
               "IAMDatabaseAuthenticationEnabled", Boolean.to_json f)
         ; Aws.Util.option_map v.timezone (fun f -> "Timezone", String.to_json f)
         ; Aws.Util.option_map v.d_b_instance_arn (fun f ->
               "DBInstanceArn", String.to_json f)
         ; Aws.Util.option_map v.promotion_tier (fun f ->
               "PromotionTier", Integer.to_json f)
         ; Aws.Util.option_map v.monitoring_role_arn (fun f ->
               "MonitoringRoleArn", String.to_json f)
         ; Aws.Util.option_map v.enhanced_monitoring_resource_arn (fun f ->
               "EnhancedMonitoringResourceArn", String.to_json f)
         ; Aws.Util.option_map v.monitoring_interval (fun f ->
               "MonitoringInterval", Integer.to_json f)
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               "CopyTagsToSnapshot", Boolean.to_json f)
         ; Some ("DomainMemberships", DomainMembershipList.to_json v.domain_memberships)
         ; Aws.Util.option_map v.c_a_certificate_identifier (fun f ->
               "CACertificateIdentifier", String.to_json f)
         ; Aws.Util.option_map v.dbi_resource_id (fun f ->
               "DbiResourceId", String.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "KmsKeyId", String.to_json f)
         ; Aws.Util.option_map v.storage_encrypted (fun f ->
               "StorageEncrypted", Boolean.to_json f)
         ; Aws.Util.option_map v.d_b_cluster_identifier (fun f ->
               "DBClusterIdentifier", String.to_json f)
         ; Aws.Util.option_map v.db_instance_port (fun f ->
               "DbInstancePort", Integer.to_json f)
         ; Aws.Util.option_map v.tde_credential_arn (fun f ->
               "TdeCredentialArn", String.to_json f)
         ; Aws.Util.option_map v.storage_type (fun f -> "StorageType", String.to_json f)
         ; Some ("StatusInfos", DBInstanceStatusInfoList.to_json v.status_infos)
         ; Aws.Util.option_map v.publicly_accessible (fun f ->
               "PubliclyAccessible", Boolean.to_json f)
         ; Aws.Util.option_map v.secondary_availability_zone (fun f ->
               "SecondaryAvailabilityZone", String.to_json f)
         ; Aws.Util.option_map v.nchar_character_set_name (fun f ->
               "NcharCharacterSetName", String.to_json f)
         ; Aws.Util.option_map v.character_set_name (fun f ->
               "CharacterSetName", String.to_json f)
         ; Some
             ( "OptionGroupMemberships"
             , OptionGroupMembershipList.to_json v.option_group_memberships )
         ; Aws.Util.option_map v.iops (fun f -> "Iops", Integer.to_json f)
         ; Aws.Util.option_map v.license_model (fun f -> "LicenseModel", String.to_json f)
         ; Aws.Util.option_map v.replica_mode (fun f ->
               "ReplicaMode", ReplicaMode.to_json f)
         ; Some
             ( "ReadReplicaDBClusterIdentifiers"
             , ReadReplicaDBClusterIdentifierList.to_json
                 v.read_replica_d_b_cluster_identifiers )
         ; Some
             ( "ReadReplicaDBInstanceIdentifiers"
             , ReadReplicaDBInstanceIdentifierList.to_json
                 v.read_replica_d_b_instance_identifiers )
         ; Aws.Util.option_map v.read_replica_source_d_b_instance_identifier (fun f ->
               "ReadReplicaSourceDBInstanceIdentifier", String.to_json f)
         ; Aws.Util.option_map v.auto_minor_version_upgrade (fun f ->
               "AutoMinorVersionUpgrade", Boolean.to_json f)
         ; Aws.Util.option_map v.engine_version (fun f ->
               "EngineVersion", String.to_json f)
         ; Aws.Util.option_map v.multi_a_z (fun f -> "MultiAZ", Boolean.to_json f)
         ; Aws.Util.option_map v.latest_restorable_time (fun f ->
               "LatestRestorableTime", DateTime.to_json f)
         ; Aws.Util.option_map v.pending_modified_values (fun f ->
               "PendingModifiedValues", PendingModifiedValues.to_json f)
         ; Aws.Util.option_map v.preferred_maintenance_window (fun f ->
               "PreferredMaintenanceWindow", String.to_json f)
         ; Aws.Util.option_map v.d_b_subnet_group (fun f ->
               "DBSubnetGroup", DBSubnetGroup.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "AvailabilityZone", String.to_json f)
         ; Some
             ( "DBParameterGroups"
             , DBParameterGroupStatusList.to_json v.d_b_parameter_groups )
         ; Some
             ( "VpcSecurityGroups"
             , VpcSecurityGroupMembershipList.to_json v.vpc_security_groups )
         ; Some
             ( "DBSecurityGroups"
             , DBSecurityGroupMembershipList.to_json v.d_b_security_groups )
         ; Aws.Util.option_map v.backup_retention_period (fun f ->
               "BackupRetentionPeriod", Integer.to_json f)
         ; Aws.Util.option_map v.preferred_backup_window (fun f ->
               "PreferredBackupWindow", String.to_json f)
         ; Aws.Util.option_map v.instance_create_time (fun f ->
               "InstanceCreateTime", DateTime.to_json f)
         ; Aws.Util.option_map v.allocated_storage (fun f ->
               "AllocatedStorage", Integer.to_json f)
         ; Aws.Util.option_map v.endpoint (fun f -> "Endpoint", Endpoint.to_json f)
         ; Aws.Util.option_map v.d_b_name (fun f -> "DBName", String.to_json f)
         ; Aws.Util.option_map v.master_username (fun f ->
               "MasterUsername", String.to_json f)
         ; Aws.Util.option_map v.d_b_instance_status (fun f ->
               "DBInstanceStatus", String.to_json f)
         ; Aws.Util.option_map v.engine (fun f -> "Engine", String.to_json f)
         ; Aws.Util.option_map v.d_b_instance_class (fun f ->
               "DBInstanceClass", String.to_json f)
         ; Aws.Util.option_map v.d_b_instance_identifier (fun f ->
               "DBInstanceIdentifier", String.to_json f)
         ])

  let of_json j =
    { d_b_instance_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstanceIdentifier") String.of_json
    ; d_b_instance_class =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstanceClass") String.of_json
    ; engine = Aws.Util.option_map (Aws.Json.lookup j "Engine") String.of_json
    ; d_b_instance_status =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstanceStatus") String.of_json
    ; master_username =
        Aws.Util.option_map (Aws.Json.lookup j "MasterUsername") String.of_json
    ; d_b_name = Aws.Util.option_map (Aws.Json.lookup j "DBName") String.of_json
    ; endpoint = Aws.Util.option_map (Aws.Json.lookup j "Endpoint") Endpoint.of_json
    ; allocated_storage =
        Aws.Util.option_map (Aws.Json.lookup j "AllocatedStorage") Integer.of_json
    ; instance_create_time =
        Aws.Util.option_map (Aws.Json.lookup j "InstanceCreateTime") DateTime.of_json
    ; preferred_backup_window =
        Aws.Util.option_map (Aws.Json.lookup j "PreferredBackupWindow") String.of_json
    ; backup_retention_period =
        Aws.Util.option_map (Aws.Json.lookup j "BackupRetentionPeriod") Integer.of_json
    ; d_b_security_groups =
        DBSecurityGroupMembershipList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBSecurityGroups"))
    ; vpc_security_groups =
        VpcSecurityGroupMembershipList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcSecurityGroups"))
    ; d_b_parameter_groups =
        DBParameterGroupStatusList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBParameterGroups"))
    ; availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "AvailabilityZone") String.of_json
    ; d_b_subnet_group =
        Aws.Util.option_map (Aws.Json.lookup j "DBSubnetGroup") DBSubnetGroup.of_json
    ; preferred_maintenance_window =
        Aws.Util.option_map
          (Aws.Json.lookup j "PreferredMaintenanceWindow")
          String.of_json
    ; pending_modified_values =
        Aws.Util.option_map
          (Aws.Json.lookup j "PendingModifiedValues")
          PendingModifiedValues.of_json
    ; latest_restorable_time =
        Aws.Util.option_map (Aws.Json.lookup j "LatestRestorableTime") DateTime.of_json
    ; multi_a_z = Aws.Util.option_map (Aws.Json.lookup j "MultiAZ") Boolean.of_json
    ; engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "EngineVersion") String.of_json
    ; auto_minor_version_upgrade =
        Aws.Util.option_map (Aws.Json.lookup j "AutoMinorVersionUpgrade") Boolean.of_json
    ; read_replica_source_d_b_instance_identifier =
        Aws.Util.option_map
          (Aws.Json.lookup j "ReadReplicaSourceDBInstanceIdentifier")
          String.of_json
    ; read_replica_d_b_instance_identifiers =
        ReadReplicaDBInstanceIdentifierList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ReadReplicaDBInstanceIdentifiers"))
    ; read_replica_d_b_cluster_identifiers =
        ReadReplicaDBClusterIdentifierList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ReadReplicaDBClusterIdentifiers"))
    ; replica_mode =
        Aws.Util.option_map (Aws.Json.lookup j "ReplicaMode") ReplicaMode.of_json
    ; license_model =
        Aws.Util.option_map (Aws.Json.lookup j "LicenseModel") String.of_json
    ; iops = Aws.Util.option_map (Aws.Json.lookup j "Iops") Integer.of_json
    ; option_group_memberships =
        OptionGroupMembershipList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "OptionGroupMemberships"))
    ; character_set_name =
        Aws.Util.option_map (Aws.Json.lookup j "CharacterSetName") String.of_json
    ; nchar_character_set_name =
        Aws.Util.option_map (Aws.Json.lookup j "NcharCharacterSetName") String.of_json
    ; secondary_availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "SecondaryAvailabilityZone") String.of_json
    ; publicly_accessible =
        Aws.Util.option_map (Aws.Json.lookup j "PubliclyAccessible") Boolean.of_json
    ; status_infos =
        DBInstanceStatusInfoList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "StatusInfos"))
    ; storage_type = Aws.Util.option_map (Aws.Json.lookup j "StorageType") String.of_json
    ; tde_credential_arn =
        Aws.Util.option_map (Aws.Json.lookup j "TdeCredentialArn") String.of_json
    ; db_instance_port =
        Aws.Util.option_map (Aws.Json.lookup j "DbInstancePort") Integer.of_json
    ; d_b_cluster_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "DBClusterIdentifier") String.of_json
    ; storage_encrypted =
        Aws.Util.option_map (Aws.Json.lookup j "StorageEncrypted") Boolean.of_json
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "KmsKeyId") String.of_json
    ; dbi_resource_id =
        Aws.Util.option_map (Aws.Json.lookup j "DbiResourceId") String.of_json
    ; c_a_certificate_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "CACertificateIdentifier") String.of_json
    ; domain_memberships =
        DomainMembershipList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DomainMemberships"))
    ; copy_tags_to_snapshot =
        Aws.Util.option_map (Aws.Json.lookup j "CopyTagsToSnapshot") Boolean.of_json
    ; monitoring_interval =
        Aws.Util.option_map (Aws.Json.lookup j "MonitoringInterval") Integer.of_json
    ; enhanced_monitoring_resource_arn =
        Aws.Util.option_map
          (Aws.Json.lookup j "EnhancedMonitoringResourceArn")
          String.of_json
    ; monitoring_role_arn =
        Aws.Util.option_map (Aws.Json.lookup j "MonitoringRoleArn") String.of_json
    ; promotion_tier =
        Aws.Util.option_map (Aws.Json.lookup j "PromotionTier") Integer.of_json
    ; d_b_instance_arn =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstanceArn") String.of_json
    ; timezone = Aws.Util.option_map (Aws.Json.lookup j "Timezone") String.of_json
    ; i_a_m_database_authentication_enabled =
        Aws.Util.option_map
          (Aws.Json.lookup j "IAMDatabaseAuthenticationEnabled")
          Boolean.of_json
    ; performance_insights_enabled =
        Aws.Util.option_map
          (Aws.Json.lookup j "PerformanceInsightsEnabled")
          Boolean.of_json
    ; performance_insights_k_m_s_key_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "PerformanceInsightsKMSKeyId")
          String.of_json
    ; performance_insights_retention_period =
        Aws.Util.option_map
          (Aws.Json.lookup j "PerformanceInsightsRetentionPeriod")
          Integer.of_json
    ; enabled_cloudwatch_logs_exports =
        LogTypeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "EnabledCloudwatchLogsExports"))
    ; processor_features =
        ProcessorFeatureList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ProcessorFeatures"))
    ; deletion_protection =
        Aws.Util.option_map (Aws.Json.lookup j "DeletionProtection") Boolean.of_json
    ; associated_roles =
        DBInstanceRoles.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AssociatedRoles"))
    ; listener_endpoint =
        Aws.Util.option_map (Aws.Json.lookup j "ListenerEndpoint") Endpoint.of_json
    ; max_allocated_storage =
        Aws.Util.option_map (Aws.Json.lookup j "MaxAllocatedStorage") Integer.of_json
    ; tag_list = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TagList"))
    }
end

module PromoteReadReplicaResult = struct
  type t = { d_b_instance : DBInstance.t option }

  let make ?d_b_instance () = { d_b_instance }

  let parse xml =
    Some
      { d_b_instance =
          Aws.Util.option_bind (Aws.Xml.member "DBInstance" xml) DBInstance.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_instance (fun f ->
               Aws.Query.Pair ("DBInstance", DBInstance.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_instance (fun f ->
               "DBInstance", DBInstance.to_json f)
         ])

  let of_json j =
    { d_b_instance =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstance") DBInstance.of_json
    }
end

module DescribeDBClusterParameterGroupsMessage = struct
  type t =
    { d_b_cluster_parameter_group_name : String.t option
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    }

  let make ?d_b_cluster_parameter_group_name ?(filters = []) ?max_records ?marker () =
    { d_b_cluster_parameter_group_name; filters; max_records; marker }

  let parse xml =
    Some
      { d_b_cluster_parameter_group_name =
          Aws.Util.option_bind
            (Aws.Xml.member "DBClusterParameterGroupName" xml)
            String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.d_b_cluster_parameter_group_name (fun f ->
               Aws.Query.Pair ("DBClusterParameterGroupName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.d_b_cluster_parameter_group_name (fun f ->
               "DBClusterParameterGroupName", String.to_json f)
         ])

  let of_json j =
    { d_b_cluster_parameter_group_name =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBClusterParameterGroupName")
          String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module DescribePendingMaintenanceActionsMessage = struct
  type t =
    { resource_identifier : String.t option
    ; filters : FilterList.t
    ; marker : String.t option
    ; max_records : Integer.t option
    }

  let make ?resource_identifier ?(filters = []) ?marker ?max_records () =
    { resource_identifier; filters; marker; max_records }

  let parse xml =
    Some
      { resource_identifier =
          Aws.Util.option_bind (Aws.Xml.member "ResourceIdentifier" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.resource_identifier (fun f ->
               Aws.Query.Pair ("ResourceIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.resource_identifier (fun f ->
               "ResourceIdentifier", String.to_json f)
         ])

  let of_json j =
    { resource_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "ResourceIdentifier") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    }
end

module ReservedDBInstance = struct
  type t =
    { reserved_d_b_instance_id : String.t option
    ; reserved_d_b_instances_offering_id : String.t option
    ; d_b_instance_class : String.t option
    ; start_time : DateTime.t option
    ; duration : Integer.t option
    ; fixed_price : Double.t option
    ; usage_price : Double.t option
    ; currency_code : String.t option
    ; d_b_instance_count : Integer.t option
    ; product_description : String.t option
    ; offering_type : String.t option
    ; multi_a_z : Boolean.t option
    ; state : String.t option
    ; recurring_charges : RecurringChargeList.t
    ; reserved_d_b_instance_arn : String.t option
    ; lease_id : String.t option
    }

  let make
      ?reserved_d_b_instance_id
      ?reserved_d_b_instances_offering_id
      ?d_b_instance_class
      ?start_time
      ?duration
      ?fixed_price
      ?usage_price
      ?currency_code
      ?d_b_instance_count
      ?product_description
      ?offering_type
      ?multi_a_z
      ?state
      ?(recurring_charges = [])
      ?reserved_d_b_instance_arn
      ?lease_id
      () =
    { reserved_d_b_instance_id
    ; reserved_d_b_instances_offering_id
    ; d_b_instance_class
    ; start_time
    ; duration
    ; fixed_price
    ; usage_price
    ; currency_code
    ; d_b_instance_count
    ; product_description
    ; offering_type
    ; multi_a_z
    ; state
    ; recurring_charges
    ; reserved_d_b_instance_arn
    ; lease_id
    }

  let parse xml =
    Some
      { reserved_d_b_instance_id =
          Aws.Util.option_bind (Aws.Xml.member "ReservedDBInstanceId" xml) String.parse
      ; reserved_d_b_instances_offering_id =
          Aws.Util.option_bind
            (Aws.Xml.member "ReservedDBInstancesOfferingId" xml)
            String.parse
      ; d_b_instance_class =
          Aws.Util.option_bind (Aws.Xml.member "DBInstanceClass" xml) String.parse
      ; start_time = Aws.Util.option_bind (Aws.Xml.member "StartTime" xml) DateTime.parse
      ; duration = Aws.Util.option_bind (Aws.Xml.member "Duration" xml) Integer.parse
      ; fixed_price = Aws.Util.option_bind (Aws.Xml.member "FixedPrice" xml) Double.parse
      ; usage_price = Aws.Util.option_bind (Aws.Xml.member "UsagePrice" xml) Double.parse
      ; currency_code =
          Aws.Util.option_bind (Aws.Xml.member "CurrencyCode" xml) String.parse
      ; d_b_instance_count =
          Aws.Util.option_bind (Aws.Xml.member "DBInstanceCount" xml) Integer.parse
      ; product_description =
          Aws.Util.option_bind (Aws.Xml.member "ProductDescription" xml) String.parse
      ; offering_type =
          Aws.Util.option_bind (Aws.Xml.member "OfferingType" xml) String.parse
      ; multi_a_z = Aws.Util.option_bind (Aws.Xml.member "MultiAZ" xml) Boolean.parse
      ; state = Aws.Util.option_bind (Aws.Xml.member "State" xml) String.parse
      ; recurring_charges =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "RecurringCharges" xml)
               RecurringChargeList.parse)
      ; reserved_d_b_instance_arn =
          Aws.Util.option_bind (Aws.Xml.member "ReservedDBInstanceArn" xml) String.parse
      ; lease_id = Aws.Util.option_bind (Aws.Xml.member "LeaseId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.lease_id (fun f ->
               Aws.Query.Pair ("LeaseId", String.to_query f))
         ; Aws.Util.option_map v.reserved_d_b_instance_arn (fun f ->
               Aws.Query.Pair ("ReservedDBInstanceArn", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "RecurringCharges.member"
                , RecurringChargeList.to_query v.recurring_charges ))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", String.to_query f))
         ; Aws.Util.option_map v.multi_a_z (fun f ->
               Aws.Query.Pair ("MultiAZ", Boolean.to_query f))
         ; Aws.Util.option_map v.offering_type (fun f ->
               Aws.Query.Pair ("OfferingType", String.to_query f))
         ; Aws.Util.option_map v.product_description (fun f ->
               Aws.Query.Pair ("ProductDescription", String.to_query f))
         ; Aws.Util.option_map v.d_b_instance_count (fun f ->
               Aws.Query.Pair ("DBInstanceCount", Integer.to_query f))
         ; Aws.Util.option_map v.currency_code (fun f ->
               Aws.Query.Pair ("CurrencyCode", String.to_query f))
         ; Aws.Util.option_map v.usage_price (fun f ->
               Aws.Query.Pair ("UsagePrice", Double.to_query f))
         ; Aws.Util.option_map v.fixed_price (fun f ->
               Aws.Query.Pair ("FixedPrice", Double.to_query f))
         ; Aws.Util.option_map v.duration (fun f ->
               Aws.Query.Pair ("Duration", Integer.to_query f))
         ; Aws.Util.option_map v.start_time (fun f ->
               Aws.Query.Pair ("StartTime", DateTime.to_query f))
         ; Aws.Util.option_map v.d_b_instance_class (fun f ->
               Aws.Query.Pair ("DBInstanceClass", String.to_query f))
         ; Aws.Util.option_map v.reserved_d_b_instances_offering_id (fun f ->
               Aws.Query.Pair ("ReservedDBInstancesOfferingId", String.to_query f))
         ; Aws.Util.option_map v.reserved_d_b_instance_id (fun f ->
               Aws.Query.Pair ("ReservedDBInstanceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.lease_id (fun f -> "LeaseId", String.to_json f)
         ; Aws.Util.option_map v.reserved_d_b_instance_arn (fun f ->
               "ReservedDBInstanceArn", String.to_json f)
         ; Some ("RecurringCharges", RecurringChargeList.to_json v.recurring_charges)
         ; Aws.Util.option_map v.state (fun f -> "State", String.to_json f)
         ; Aws.Util.option_map v.multi_a_z (fun f -> "MultiAZ", Boolean.to_json f)
         ; Aws.Util.option_map v.offering_type (fun f -> "OfferingType", String.to_json f)
         ; Aws.Util.option_map v.product_description (fun f ->
               "ProductDescription", String.to_json f)
         ; Aws.Util.option_map v.d_b_instance_count (fun f ->
               "DBInstanceCount", Integer.to_json f)
         ; Aws.Util.option_map v.currency_code (fun f -> "CurrencyCode", String.to_json f)
         ; Aws.Util.option_map v.usage_price (fun f -> "UsagePrice", Double.to_json f)
         ; Aws.Util.option_map v.fixed_price (fun f -> "FixedPrice", Double.to_json f)
         ; Aws.Util.option_map v.duration (fun f -> "Duration", Integer.to_json f)
         ; Aws.Util.option_map v.start_time (fun f -> "StartTime", DateTime.to_json f)
         ; Aws.Util.option_map v.d_b_instance_class (fun f ->
               "DBInstanceClass", String.to_json f)
         ; Aws.Util.option_map v.reserved_d_b_instances_offering_id (fun f ->
               "ReservedDBInstancesOfferingId", String.to_json f)
         ; Aws.Util.option_map v.reserved_d_b_instance_id (fun f ->
               "ReservedDBInstanceId", String.to_json f)
         ])

  let of_json j =
    { reserved_d_b_instance_id =
        Aws.Util.option_map (Aws.Json.lookup j "ReservedDBInstanceId") String.of_json
    ; reserved_d_b_instances_offering_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "ReservedDBInstancesOfferingId")
          String.of_json
    ; d_b_instance_class =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstanceClass") String.of_json
    ; start_time = Aws.Util.option_map (Aws.Json.lookup j "StartTime") DateTime.of_json
    ; duration = Aws.Util.option_map (Aws.Json.lookup j "Duration") Integer.of_json
    ; fixed_price = Aws.Util.option_map (Aws.Json.lookup j "FixedPrice") Double.of_json
    ; usage_price = Aws.Util.option_map (Aws.Json.lookup j "UsagePrice") Double.of_json
    ; currency_code =
        Aws.Util.option_map (Aws.Json.lookup j "CurrencyCode") String.of_json
    ; d_b_instance_count =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstanceCount") Integer.of_json
    ; product_description =
        Aws.Util.option_map (Aws.Json.lookup j "ProductDescription") String.of_json
    ; offering_type =
        Aws.Util.option_map (Aws.Json.lookup j "OfferingType") String.of_json
    ; multi_a_z = Aws.Util.option_map (Aws.Json.lookup j "MultiAZ") Boolean.of_json
    ; state = Aws.Util.option_map (Aws.Json.lookup j "State") String.of_json
    ; recurring_charges =
        RecurringChargeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "RecurringCharges"))
    ; reserved_d_b_instance_arn =
        Aws.Util.option_map (Aws.Json.lookup j "ReservedDBInstanceArn") String.of_json
    ; lease_id = Aws.Util.option_map (Aws.Json.lookup j "LeaseId") String.of_json
    }
end

module ReservedDBInstanceList = struct
  type t = ReservedDBInstance.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ReservedDBInstance.parse (Aws.Xml.members "ReservedDBInstance" xml))

  let to_query v = Aws.Query.to_query_list ReservedDBInstance.to_query v

  let to_json v = `List (List.map ReservedDBInstance.to_json v)

  let of_json j = Aws.Json.to_list ReservedDBInstance.of_json j
end

module DBClusterNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module ModifyDBProxyTargetGroupResponse = struct
  type t = { d_b_proxy_target_group : DBProxyTargetGroup.t option }

  let make ?d_b_proxy_target_group () = { d_b_proxy_target_group }

  let parse xml =
    Some
      { d_b_proxy_target_group =
          Aws.Util.option_bind
            (Aws.Xml.member "DBProxyTargetGroup" xml)
            DBProxyTargetGroup.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_proxy_target_group (fun f ->
               Aws.Query.Pair ("DBProxyTargetGroup", DBProxyTargetGroup.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_proxy_target_group (fun f ->
               "DBProxyTargetGroup", DBProxyTargetGroup.to_json f)
         ])

  let of_json j =
    { d_b_proxy_target_group =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBProxyTargetGroup")
          DBProxyTargetGroup.of_json
    }
end

module DBInstanceRoleNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module SnapshotQuotaExceededFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module PromoteReadReplicaDBClusterResult = struct
  type t = { d_b_cluster : DBCluster.t option }

  let make ?d_b_cluster () = { d_b_cluster }

  let parse xml =
    Some
      { d_b_cluster =
          Aws.Util.option_bind (Aws.Xml.member "DBCluster" xml) DBCluster.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster (fun f ->
               Aws.Query.Pair ("DBCluster", DBCluster.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster (fun f -> "DBCluster", DBCluster.to_json f) ])

  let of_json j =
    { d_b_cluster = Aws.Util.option_map (Aws.Json.lookup j "DBCluster") DBCluster.of_json
    }
end

module InvalidDBClusterCapacityFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module RemoveRoleFromDBClusterMessage = struct
  type t =
    { d_b_cluster_identifier : String.t
    ; role_arn : String.t
    ; feature_name : String.t option
    }

  let make ~d_b_cluster_identifier ~role_arn ?feature_name () =
    { d_b_cluster_identifier; role_arn; feature_name }

  let parse xml =
    Some
      { d_b_cluster_identifier =
          Aws.Xml.required
            "DBClusterIdentifier"
            (Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse)
      ; role_arn =
          Aws.Xml.required
            "RoleArn"
            (Aws.Util.option_bind (Aws.Xml.member "RoleArn" xml) String.parse)
      ; feature_name =
          Aws.Util.option_bind (Aws.Xml.member "FeatureName" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.feature_name (fun f ->
               Aws.Query.Pair ("FeatureName", String.to_query f))
         ; Some (Aws.Query.Pair ("RoleArn", String.to_query v.role_arn))
         ; Some
             (Aws.Query.Pair
                ("DBClusterIdentifier", String.to_query v.d_b_cluster_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.feature_name (fun f -> "FeatureName", String.to_json f)
         ; Some ("RoleArn", String.to_json v.role_arn)
         ; Some ("DBClusterIdentifier", String.to_json v.d_b_cluster_identifier)
         ])

  let of_json j =
    { d_b_cluster_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterIdentifier"))
    ; role_arn = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "RoleArn"))
    ; feature_name = Aws.Util.option_map (Aws.Json.lookup j "FeatureName") String.of_json
    }
end

module DeleteCustomAvailabilityZoneMessage = struct
  type t = { custom_availability_zone_id : String.t }

  let make ~custom_availability_zone_id () = { custom_availability_zone_id }

  let parse xml =
    Some
      { custom_availability_zone_id =
          Aws.Xml.required
            "CustomAvailabilityZoneId"
            (Aws.Util.option_bind
               (Aws.Xml.member "CustomAvailabilityZoneId" xml)
               String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("CustomAvailabilityZoneId", String.to_query v.custom_availability_zone_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("CustomAvailabilityZoneId", String.to_json v.custom_availability_zone_id)
         ])

  let of_json j =
    { custom_availability_zone_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "CustomAvailabilityZoneId"))
    }
end

module UserAuthConfigList = struct
  type t = UserAuthConfig.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map UserAuthConfig.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list UserAuthConfig.to_query v

  let to_json v = `List (List.map UserAuthConfig.to_json v)

  let of_json j = Aws.Json.to_list UserAuthConfig.of_json j
end

module CreateDBProxyRequest = struct
  type t =
    { d_b_proxy_name : String.t
    ; engine_family : EngineFamily.t
    ; auth : UserAuthConfigList.t
    ; role_arn : String.t
    ; vpc_subnet_ids : StringList.t
    ; vpc_security_group_ids : StringList.t
    ; require_t_l_s : Boolean.t option
    ; idle_client_timeout : Integer.t option
    ; debug_logging : Boolean.t option
    ; tags : TagList.t
    }

  let make
      ~d_b_proxy_name
      ~engine_family
      ~auth
      ~role_arn
      ~vpc_subnet_ids
      ?(vpc_security_group_ids = [])
      ?require_t_l_s
      ?idle_client_timeout
      ?debug_logging
      ?(tags = [])
      () =
    { d_b_proxy_name
    ; engine_family
    ; auth
    ; role_arn
    ; vpc_subnet_ids
    ; vpc_security_group_ids
    ; require_t_l_s
    ; idle_client_timeout
    ; debug_logging
    ; tags
    }

  let parse xml =
    Some
      { d_b_proxy_name =
          Aws.Xml.required
            "DBProxyName"
            (Aws.Util.option_bind (Aws.Xml.member "DBProxyName" xml) String.parse)
      ; engine_family =
          Aws.Xml.required
            "EngineFamily"
            (Aws.Util.option_bind (Aws.Xml.member "EngineFamily" xml) EngineFamily.parse)
      ; auth =
          Aws.Xml.required
            "Auth"
            (Aws.Util.option_bind (Aws.Xml.member "Auth" xml) UserAuthConfigList.parse)
      ; role_arn =
          Aws.Xml.required
            "RoleArn"
            (Aws.Util.option_bind (Aws.Xml.member "RoleArn" xml) String.parse)
      ; vpc_subnet_ids =
          Aws.Xml.required
            "VpcSubnetIds"
            (Aws.Util.option_bind (Aws.Xml.member "VpcSubnetIds" xml) StringList.parse)
      ; vpc_security_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "VpcSecurityGroupIds" xml)
               StringList.parse)
      ; require_t_l_s =
          Aws.Util.option_bind (Aws.Xml.member "RequireTLS" xml) Boolean.parse
      ; idle_client_timeout =
          Aws.Util.option_bind (Aws.Xml.member "IdleClientTimeout" xml) Integer.parse
      ; debug_logging =
          Aws.Util.option_bind (Aws.Xml.member "DebugLogging" xml) Boolean.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Aws.Util.option_map v.debug_logging (fun f ->
               Aws.Query.Pair ("DebugLogging", Boolean.to_query f))
         ; Aws.Util.option_map v.idle_client_timeout (fun f ->
               Aws.Query.Pair ("IdleClientTimeout", Integer.to_query f))
         ; Aws.Util.option_map v.require_t_l_s (fun f ->
               Aws.Query.Pair ("RequireTLS", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "VpcSecurityGroupIds.member"
                , StringList.to_query v.vpc_security_group_ids ))
         ; Some
             (Aws.Query.Pair ("VpcSubnetIds.member", StringList.to_query v.vpc_subnet_ids))
         ; Some (Aws.Query.Pair ("RoleArn", String.to_query v.role_arn))
         ; Some (Aws.Query.Pair ("Auth.member", UserAuthConfigList.to_query v.auth))
         ; Some (Aws.Query.Pair ("EngineFamily", EngineFamily.to_query v.engine_family))
         ; Some (Aws.Query.Pair ("DBProxyName", String.to_query v.d_b_proxy_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tags", TagList.to_json v.tags)
         ; Aws.Util.option_map v.debug_logging (fun f ->
               "DebugLogging", Boolean.to_json f)
         ; Aws.Util.option_map v.idle_client_timeout (fun f ->
               "IdleClientTimeout", Integer.to_json f)
         ; Aws.Util.option_map v.require_t_l_s (fun f -> "RequireTLS", Boolean.to_json f)
         ; Some ("VpcSecurityGroupIds", StringList.to_json v.vpc_security_group_ids)
         ; Some ("VpcSubnetIds", StringList.to_json v.vpc_subnet_ids)
         ; Some ("RoleArn", String.to_json v.role_arn)
         ; Some ("Auth", UserAuthConfigList.to_json v.auth)
         ; Some ("EngineFamily", EngineFamily.to_json v.engine_family)
         ; Some ("DBProxyName", String.to_json v.d_b_proxy_name)
         ])

  let of_json j =
    { d_b_proxy_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBProxyName"))
    ; engine_family =
        EngineFamily.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "EngineFamily"))
    ; auth =
        UserAuthConfigList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Auth"))
    ; role_arn = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "RoleArn"))
    ; vpc_subnet_ids =
        StringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcSubnetIds"))
    ; vpc_security_group_ids =
        StringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcSecurityGroupIds"))
    ; require_t_l_s = Aws.Util.option_map (Aws.Json.lookup j "RequireTLS") Boolean.of_json
    ; idle_client_timeout =
        Aws.Util.option_map (Aws.Json.lookup j "IdleClientTimeout") Integer.of_json
    ; debug_logging =
        Aws.Util.option_map (Aws.Json.lookup j "DebugLogging") Boolean.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    }
end

module DescribeDBClusterParametersMessage = struct
  type t =
    { d_b_cluster_parameter_group_name : String.t
    ; source : String.t option
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    }

  let make
      ~d_b_cluster_parameter_group_name
      ?source
      ?(filters = [])
      ?max_records
      ?marker
      () =
    { d_b_cluster_parameter_group_name; source; filters; max_records; marker }

  let parse xml =
    Some
      { d_b_cluster_parameter_group_name =
          Aws.Xml.required
            "DBClusterParameterGroupName"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBClusterParameterGroupName" xml)
               String.parse)
      ; source = Aws.Util.option_bind (Aws.Xml.member "Source" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.source (fun f ->
               Aws.Query.Pair ("Source", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "DBClusterParameterGroupName"
                , String.to_query v.d_b_cluster_parameter_group_name ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.source (fun f -> "Source", String.to_json f)
         ; Some
             ( "DBClusterParameterGroupName"
             , String.to_json v.d_b_cluster_parameter_group_name )
         ])

  let of_json j =
    { d_b_cluster_parameter_group_name =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterParameterGroupName"))
    ; source = Aws.Util.option_map (Aws.Json.lookup j "Source") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module ModifyDBSnapshotAttributeMessage = struct
  type t =
    { d_b_snapshot_identifier : String.t
    ; attribute_name : String.t
    ; values_to_add : AttributeValueList.t
    ; values_to_remove : AttributeValueList.t
    }

  let make
      ~d_b_snapshot_identifier
      ~attribute_name
      ?(values_to_add = [])
      ?(values_to_remove = [])
      () =
    { d_b_snapshot_identifier; attribute_name; values_to_add; values_to_remove }

  let parse xml =
    Some
      { d_b_snapshot_identifier =
          Aws.Xml.required
            "DBSnapshotIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBSnapshotIdentifier" xml)
               String.parse)
      ; attribute_name =
          Aws.Xml.required
            "AttributeName"
            (Aws.Util.option_bind (Aws.Xml.member "AttributeName" xml) String.parse)
      ; values_to_add =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ValuesToAdd" xml)
               AttributeValueList.parse)
      ; values_to_remove =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ValuesToRemove" xml)
               AttributeValueList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("ValuesToRemove.member", AttributeValueList.to_query v.values_to_remove))
         ; Some
             (Aws.Query.Pair
                ("ValuesToAdd.member", AttributeValueList.to_query v.values_to_add))
         ; Some (Aws.Query.Pair ("AttributeName", String.to_query v.attribute_name))
         ; Some
             (Aws.Query.Pair
                ("DBSnapshotIdentifier", String.to_query v.d_b_snapshot_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("ValuesToRemove", AttributeValueList.to_json v.values_to_remove)
         ; Some ("ValuesToAdd", AttributeValueList.to_json v.values_to_add)
         ; Some ("AttributeName", String.to_json v.attribute_name)
         ; Some ("DBSnapshotIdentifier", String.to_json v.d_b_snapshot_identifier)
         ])

  let of_json j =
    { d_b_snapshot_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBSnapshotIdentifier"))
    ; attribute_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "AttributeName"))
    ; values_to_add =
        AttributeValueList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ValuesToAdd"))
    ; values_to_remove =
        AttributeValueList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ValuesToRemove"))
    }
end

module AddRoleToDBInstanceMessage = struct
  type t =
    { d_b_instance_identifier : String.t
    ; role_arn : String.t
    ; feature_name : String.t
    }

  let make ~d_b_instance_identifier ~role_arn ~feature_name () =
    { d_b_instance_identifier; role_arn; feature_name }

  let parse xml =
    Some
      { d_b_instance_identifier =
          Aws.Xml.required
            "DBInstanceIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBInstanceIdentifier" xml)
               String.parse)
      ; role_arn =
          Aws.Xml.required
            "RoleArn"
            (Aws.Util.option_bind (Aws.Xml.member "RoleArn" xml) String.parse)
      ; feature_name =
          Aws.Xml.required
            "FeatureName"
            (Aws.Util.option_bind (Aws.Xml.member "FeatureName" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("FeatureName", String.to_query v.feature_name))
         ; Some (Aws.Query.Pair ("RoleArn", String.to_query v.role_arn))
         ; Some
             (Aws.Query.Pair
                ("DBInstanceIdentifier", String.to_query v.d_b_instance_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("FeatureName", String.to_json v.feature_name)
         ; Some ("RoleArn", String.to_json v.role_arn)
         ; Some ("DBInstanceIdentifier", String.to_json v.d_b_instance_identifier)
         ])

  let of_json j =
    { d_b_instance_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBInstanceIdentifier"))
    ; role_arn = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "RoleArn"))
    ; feature_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "FeatureName"))
    }
end

module StopDBInstanceResult = struct
  type t = { d_b_instance : DBInstance.t option }

  let make ?d_b_instance () = { d_b_instance }

  let parse xml =
    Some
      { d_b_instance =
          Aws.Util.option_bind (Aws.Xml.member "DBInstance" xml) DBInstance.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_instance (fun f ->
               Aws.Query.Pair ("DBInstance", DBInstance.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_instance (fun f ->
               "DBInstance", DBInstance.to_json f)
         ])

  let of_json j =
    { d_b_instance =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstance") DBInstance.of_json
    }
end

module ReservedDBInstanceNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DBSnapshotList = struct
  type t = DBSnapshot.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map DBSnapshot.parse (Aws.Xml.members "DBSnapshot" xml))

  let to_query v = Aws.Query.to_query_list DBSnapshot.to_query v

  let to_json v = `List (List.map DBSnapshot.to_json v)

  let of_json j = Aws.Json.to_list DBSnapshot.of_json j
end

module CertificateNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module InvalidDBClusterStateFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DescribeEventsMessage = struct
  type t =
    { source_identifier : String.t option
    ; source_type : SourceType.t option
    ; start_time : DateTime.t option
    ; end_time : DateTime.t option
    ; duration : Integer.t option
    ; event_categories : EventCategoriesList.t
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    }

  let make
      ?source_identifier
      ?source_type
      ?start_time
      ?end_time
      ?duration
      ?(event_categories = [])
      ?(filters = [])
      ?max_records
      ?marker
      () =
    { source_identifier
    ; source_type
    ; start_time
    ; end_time
    ; duration
    ; event_categories
    ; filters
    ; max_records
    ; marker
    }

  let parse xml =
    Some
      { source_identifier =
          Aws.Util.option_bind (Aws.Xml.member "SourceIdentifier" xml) String.parse
      ; source_type =
          Aws.Util.option_bind (Aws.Xml.member "SourceType" xml) SourceType.parse
      ; start_time = Aws.Util.option_bind (Aws.Xml.member "StartTime" xml) DateTime.parse
      ; end_time = Aws.Util.option_bind (Aws.Xml.member "EndTime" xml) DateTime.parse
      ; duration = Aws.Util.option_bind (Aws.Xml.member "Duration" xml) Integer.parse
      ; event_categories =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "EventCategories" xml)
               EventCategoriesList.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ("EventCategories.member", EventCategoriesList.to_query v.event_categories))
         ; Aws.Util.option_map v.duration (fun f ->
               Aws.Query.Pair ("Duration", Integer.to_query f))
         ; Aws.Util.option_map v.end_time (fun f ->
               Aws.Query.Pair ("EndTime", DateTime.to_query f))
         ; Aws.Util.option_map v.start_time (fun f ->
               Aws.Query.Pair ("StartTime", DateTime.to_query f))
         ; Aws.Util.option_map v.source_type (fun f ->
               Aws.Query.Pair ("SourceType", SourceType.to_query f))
         ; Aws.Util.option_map v.source_identifier (fun f ->
               Aws.Query.Pair ("SourceIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Some ("EventCategories", EventCategoriesList.to_json v.event_categories)
         ; Aws.Util.option_map v.duration (fun f -> "Duration", Integer.to_json f)
         ; Aws.Util.option_map v.end_time (fun f -> "EndTime", DateTime.to_json f)
         ; Aws.Util.option_map v.start_time (fun f -> "StartTime", DateTime.to_json f)
         ; Aws.Util.option_map v.source_type (fun f -> "SourceType", SourceType.to_json f)
         ; Aws.Util.option_map v.source_identifier (fun f ->
               "SourceIdentifier", String.to_json f)
         ])

  let of_json j =
    { source_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "SourceIdentifier") String.of_json
    ; source_type =
        Aws.Util.option_map (Aws.Json.lookup j "SourceType") SourceType.of_json
    ; start_time = Aws.Util.option_map (Aws.Json.lookup j "StartTime") DateTime.of_json
    ; end_time = Aws.Util.option_map (Aws.Json.lookup j "EndTime") DateTime.of_json
    ; duration = Aws.Util.option_map (Aws.Json.lookup j "Duration") Integer.of_json
    ; event_categories =
        EventCategoriesList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "EventCategories"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module DBClusterEndpointNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module RevokeDBSecurityGroupIngressResult = struct
  type t = { d_b_security_group : DBSecurityGroup.t option }

  let make ?d_b_security_group () = { d_b_security_group }

  let parse xml =
    Some
      { d_b_security_group =
          Aws.Util.option_bind
            (Aws.Xml.member "DBSecurityGroup" xml)
            DBSecurityGroup.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_security_group (fun f ->
               Aws.Query.Pair ("DBSecurityGroup", DBSecurityGroup.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_security_group (fun f ->
               "DBSecurityGroup", DBSecurityGroup.to_json f)
         ])

  let of_json j =
    { d_b_security_group =
        Aws.Util.option_map (Aws.Json.lookup j "DBSecurityGroup") DBSecurityGroup.of_json
    }
end

module CopyDBSnapshotMessage = struct
  type t =
    { source_d_b_snapshot_identifier : String.t
    ; target_d_b_snapshot_identifier : String.t
    ; kms_key_id : String.t option
    ; tags : TagList.t
    ; copy_tags : Boolean.t option
    ; pre_signed_url : String.t option
    ; option_group_name : String.t option
    ; target_custom_availability_zone : String.t option
    }

  let make
      ~source_d_b_snapshot_identifier
      ~target_d_b_snapshot_identifier
      ?kms_key_id
      ?(tags = [])
      ?copy_tags
      ?pre_signed_url
      ?option_group_name
      ?target_custom_availability_zone
      () =
    { source_d_b_snapshot_identifier
    ; target_d_b_snapshot_identifier
    ; kms_key_id
    ; tags
    ; copy_tags
    ; pre_signed_url
    ; option_group_name
    ; target_custom_availability_zone
    }

  let parse xml =
    Some
      { source_d_b_snapshot_identifier =
          Aws.Xml.required
            "SourceDBSnapshotIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "SourceDBSnapshotIdentifier" xml)
               String.parse)
      ; target_d_b_snapshot_identifier =
          Aws.Xml.required
            "TargetDBSnapshotIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "TargetDBSnapshotIdentifier" xml)
               String.parse)
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "KmsKeyId" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      ; copy_tags = Aws.Util.option_bind (Aws.Xml.member "CopyTags" xml) Boolean.parse
      ; pre_signed_url =
          Aws.Util.option_bind (Aws.Xml.member "PreSignedUrl" xml) String.parse
      ; option_group_name =
          Aws.Util.option_bind (Aws.Xml.member "OptionGroupName" xml) String.parse
      ; target_custom_availability_zone =
          Aws.Util.option_bind
            (Aws.Xml.member "TargetCustomAvailabilityZone" xml)
            String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.target_custom_availability_zone (fun f ->
               Aws.Query.Pair ("TargetCustomAvailabilityZone", String.to_query f))
         ; Aws.Util.option_map v.option_group_name (fun f ->
               Aws.Query.Pair ("OptionGroupName", String.to_query f))
         ; Aws.Util.option_map v.pre_signed_url (fun f ->
               Aws.Query.Pair ("PreSignedUrl", String.to_query f))
         ; Aws.Util.option_map v.copy_tags (fun f ->
               Aws.Query.Pair ("CopyTags", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TargetDBSnapshotIdentifier"
                , String.to_query v.target_d_b_snapshot_identifier ))
         ; Some
             (Aws.Query.Pair
                ( "SourceDBSnapshotIdentifier"
                , String.to_query v.source_d_b_snapshot_identifier ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.target_custom_availability_zone (fun f ->
               "TargetCustomAvailabilityZone", String.to_json f)
         ; Aws.Util.option_map v.option_group_name (fun f ->
               "OptionGroupName", String.to_json f)
         ; Aws.Util.option_map v.pre_signed_url (fun f ->
               "PreSignedUrl", String.to_json f)
         ; Aws.Util.option_map v.copy_tags (fun f -> "CopyTags", Boolean.to_json f)
         ; Some ("Tags", TagList.to_json v.tags)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "KmsKeyId", String.to_json f)
         ; Some
             ( "TargetDBSnapshotIdentifier"
             , String.to_json v.target_d_b_snapshot_identifier )
         ; Some
             ( "SourceDBSnapshotIdentifier"
             , String.to_json v.source_d_b_snapshot_identifier )
         ])

  let of_json j =
    { source_d_b_snapshot_identifier =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceDBSnapshotIdentifier"))
    ; target_d_b_snapshot_identifier =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TargetDBSnapshotIdentifier"))
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "KmsKeyId") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    ; copy_tags = Aws.Util.option_map (Aws.Json.lookup j "CopyTags") Boolean.of_json
    ; pre_signed_url =
        Aws.Util.option_map (Aws.Json.lookup j "PreSignedUrl") String.of_json
    ; option_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "OptionGroupName") String.of_json
    ; target_custom_availability_zone =
        Aws.Util.option_map
          (Aws.Json.lookup j "TargetCustomAvailabilityZone")
          String.of_json
    }
end

module ReservedDBInstanceAlreadyExistsFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module InvalidGlobalClusterStateFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module ScalingConfiguration = struct
  type t =
    { min_capacity : Integer.t option
    ; max_capacity : Integer.t option
    ; auto_pause : Boolean.t option
    ; seconds_until_auto_pause : Integer.t option
    ; timeout_action : String.t option
    }

  let make
      ?min_capacity
      ?max_capacity
      ?auto_pause
      ?seconds_until_auto_pause
      ?timeout_action
      () =
    { min_capacity; max_capacity; auto_pause; seconds_until_auto_pause; timeout_action }

  let parse xml =
    Some
      { min_capacity =
          Aws.Util.option_bind (Aws.Xml.member "MinCapacity" xml) Integer.parse
      ; max_capacity =
          Aws.Util.option_bind (Aws.Xml.member "MaxCapacity" xml) Integer.parse
      ; auto_pause = Aws.Util.option_bind (Aws.Xml.member "AutoPause" xml) Boolean.parse
      ; seconds_until_auto_pause =
          Aws.Util.option_bind (Aws.Xml.member "SecondsUntilAutoPause" xml) Integer.parse
      ; timeout_action =
          Aws.Util.option_bind (Aws.Xml.member "TimeoutAction" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timeout_action (fun f ->
               Aws.Query.Pair ("TimeoutAction", String.to_query f))
         ; Aws.Util.option_map v.seconds_until_auto_pause (fun f ->
               Aws.Query.Pair ("SecondsUntilAutoPause", Integer.to_query f))
         ; Aws.Util.option_map v.auto_pause (fun f ->
               Aws.Query.Pair ("AutoPause", Boolean.to_query f))
         ; Aws.Util.option_map v.max_capacity (fun f ->
               Aws.Query.Pair ("MaxCapacity", Integer.to_query f))
         ; Aws.Util.option_map v.min_capacity (fun f ->
               Aws.Query.Pair ("MinCapacity", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timeout_action (fun f ->
               "TimeoutAction", String.to_json f)
         ; Aws.Util.option_map v.seconds_until_auto_pause (fun f ->
               "SecondsUntilAutoPause", Integer.to_json f)
         ; Aws.Util.option_map v.auto_pause (fun f -> "AutoPause", Boolean.to_json f)
         ; Aws.Util.option_map v.max_capacity (fun f -> "MaxCapacity", Integer.to_json f)
         ; Aws.Util.option_map v.min_capacity (fun f -> "MinCapacity", Integer.to_json f)
         ])

  let of_json j =
    { min_capacity = Aws.Util.option_map (Aws.Json.lookup j "MinCapacity") Integer.of_json
    ; max_capacity = Aws.Util.option_map (Aws.Json.lookup j "MaxCapacity") Integer.of_json
    ; auto_pause = Aws.Util.option_map (Aws.Json.lookup j "AutoPause") Boolean.of_json
    ; seconds_until_auto_pause =
        Aws.Util.option_map (Aws.Json.lookup j "SecondsUntilAutoPause") Integer.of_json
    ; timeout_action =
        Aws.Util.option_map (Aws.Json.lookup j "TimeoutAction") String.of_json
    }
end

module StopActivityStreamRequest = struct
  type t =
    { resource_arn : String.t
    ; apply_immediately : Boolean.t option
    }

  let make ~resource_arn ?apply_immediately () = { resource_arn; apply_immediately }

  let parse xml =
    Some
      { resource_arn =
          Aws.Xml.required
            "ResourceArn"
            (Aws.Util.option_bind (Aws.Xml.member "ResourceArn" xml) String.parse)
      ; apply_immediately =
          Aws.Util.option_bind (Aws.Xml.member "ApplyImmediately" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.apply_immediately (fun f ->
               Aws.Query.Pair ("ApplyImmediately", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("ResourceArn", String.to_query v.resource_arn))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.apply_immediately (fun f ->
               "ApplyImmediately", Boolean.to_json f)
         ; Some ("ResourceArn", String.to_json v.resource_arn)
         ])

  let of_json j =
    { resource_arn =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ResourceArn"))
    ; apply_immediately =
        Aws.Util.option_map (Aws.Json.lookup j "ApplyImmediately") Boolean.of_json
    }
end

module ExportTask = struct
  type t =
    { export_task_identifier : String.t option
    ; source_arn : String.t option
    ; export_only : StringList.t
    ; snapshot_time : DateTime.t option
    ; task_start_time : DateTime.t option
    ; task_end_time : DateTime.t option
    ; s3_bucket : String.t option
    ; s3_prefix : String.t option
    ; iam_role_arn : String.t option
    ; kms_key_id : String.t option
    ; status : String.t option
    ; percent_progress : Integer.t option
    ; total_extracted_data_in_g_b : Integer.t option
    ; failure_cause : String.t option
    ; warning_message : String.t option
    }

  let make
      ?export_task_identifier
      ?source_arn
      ?(export_only = [])
      ?snapshot_time
      ?task_start_time
      ?task_end_time
      ?s3_bucket
      ?s3_prefix
      ?iam_role_arn
      ?kms_key_id
      ?status
      ?percent_progress
      ?total_extracted_data_in_g_b
      ?failure_cause
      ?warning_message
      () =
    { export_task_identifier
    ; source_arn
    ; export_only
    ; snapshot_time
    ; task_start_time
    ; task_end_time
    ; s3_bucket
    ; s3_prefix
    ; iam_role_arn
    ; kms_key_id
    ; status
    ; percent_progress
    ; total_extracted_data_in_g_b
    ; failure_cause
    ; warning_message
    }

  let parse xml =
    Some
      { export_task_identifier =
          Aws.Util.option_bind (Aws.Xml.member "ExportTaskIdentifier" xml) String.parse
      ; source_arn = Aws.Util.option_bind (Aws.Xml.member "SourceArn" xml) String.parse
      ; export_only =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "ExportOnly" xml) StringList.parse)
      ; snapshot_time =
          Aws.Util.option_bind (Aws.Xml.member "SnapshotTime" xml) DateTime.parse
      ; task_start_time =
          Aws.Util.option_bind (Aws.Xml.member "TaskStartTime" xml) DateTime.parse
      ; task_end_time =
          Aws.Util.option_bind (Aws.Xml.member "TaskEndTime" xml) DateTime.parse
      ; s3_bucket = Aws.Util.option_bind (Aws.Xml.member "S3Bucket" xml) String.parse
      ; s3_prefix = Aws.Util.option_bind (Aws.Xml.member "S3Prefix" xml) String.parse
      ; iam_role_arn = Aws.Util.option_bind (Aws.Xml.member "IamRoleArn" xml) String.parse
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "KmsKeyId" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      ; percent_progress =
          Aws.Util.option_bind (Aws.Xml.member "PercentProgress" xml) Integer.parse
      ; total_extracted_data_in_g_b =
          Aws.Util.option_bind (Aws.Xml.member "TotalExtractedDataInGB" xml) Integer.parse
      ; failure_cause =
          Aws.Util.option_bind (Aws.Xml.member "FailureCause" xml) String.parse
      ; warning_message =
          Aws.Util.option_bind (Aws.Xml.member "WarningMessage" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.warning_message (fun f ->
               Aws.Query.Pair ("WarningMessage", String.to_query f))
         ; Aws.Util.option_map v.failure_cause (fun f ->
               Aws.Query.Pair ("FailureCause", String.to_query f))
         ; Aws.Util.option_map v.total_extracted_data_in_g_b (fun f ->
               Aws.Query.Pair ("TotalExtractedDataInGB", Integer.to_query f))
         ; Aws.Util.option_map v.percent_progress (fun f ->
               Aws.Query.Pair ("PercentProgress", Integer.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Aws.Util.option_map v.iam_role_arn (fun f ->
               Aws.Query.Pair ("IamRoleArn", String.to_query f))
         ; Aws.Util.option_map v.s3_prefix (fun f ->
               Aws.Query.Pair ("S3Prefix", String.to_query f))
         ; Aws.Util.option_map v.s3_bucket (fun f ->
               Aws.Query.Pair ("S3Bucket", String.to_query f))
         ; Aws.Util.option_map v.task_end_time (fun f ->
               Aws.Query.Pair ("TaskEndTime", DateTime.to_query f))
         ; Aws.Util.option_map v.task_start_time (fun f ->
               Aws.Query.Pair ("TaskStartTime", DateTime.to_query f))
         ; Aws.Util.option_map v.snapshot_time (fun f ->
               Aws.Query.Pair ("SnapshotTime", DateTime.to_query f))
         ; Some (Aws.Query.Pair ("ExportOnly.member", StringList.to_query v.export_only))
         ; Aws.Util.option_map v.source_arn (fun f ->
               Aws.Query.Pair ("SourceArn", String.to_query f))
         ; Aws.Util.option_map v.export_task_identifier (fun f ->
               Aws.Query.Pair ("ExportTaskIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.warning_message (fun f ->
               "WarningMessage", String.to_json f)
         ; Aws.Util.option_map v.failure_cause (fun f -> "FailureCause", String.to_json f)
         ; Aws.Util.option_map v.total_extracted_data_in_g_b (fun f ->
               "TotalExtractedDataInGB", Integer.to_json f)
         ; Aws.Util.option_map v.percent_progress (fun f ->
               "PercentProgress", Integer.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "KmsKeyId", String.to_json f)
         ; Aws.Util.option_map v.iam_role_arn (fun f -> "IamRoleArn", String.to_json f)
         ; Aws.Util.option_map v.s3_prefix (fun f -> "S3Prefix", String.to_json f)
         ; Aws.Util.option_map v.s3_bucket (fun f -> "S3Bucket", String.to_json f)
         ; Aws.Util.option_map v.task_end_time (fun f ->
               "TaskEndTime", DateTime.to_json f)
         ; Aws.Util.option_map v.task_start_time (fun f ->
               "TaskStartTime", DateTime.to_json f)
         ; Aws.Util.option_map v.snapshot_time (fun f ->
               "SnapshotTime", DateTime.to_json f)
         ; Some ("ExportOnly", StringList.to_json v.export_only)
         ; Aws.Util.option_map v.source_arn (fun f -> "SourceArn", String.to_json f)
         ; Aws.Util.option_map v.export_task_identifier (fun f ->
               "ExportTaskIdentifier", String.to_json f)
         ])

  let of_json j =
    { export_task_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "ExportTaskIdentifier") String.of_json
    ; source_arn = Aws.Util.option_map (Aws.Json.lookup j "SourceArn") String.of_json
    ; export_only =
        StringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ExportOnly"))
    ; snapshot_time =
        Aws.Util.option_map (Aws.Json.lookup j "SnapshotTime") DateTime.of_json
    ; task_start_time =
        Aws.Util.option_map (Aws.Json.lookup j "TaskStartTime") DateTime.of_json
    ; task_end_time =
        Aws.Util.option_map (Aws.Json.lookup j "TaskEndTime") DateTime.of_json
    ; s3_bucket = Aws.Util.option_map (Aws.Json.lookup j "S3Bucket") String.of_json
    ; s3_prefix = Aws.Util.option_map (Aws.Json.lookup j "S3Prefix") String.of_json
    ; iam_role_arn = Aws.Util.option_map (Aws.Json.lookup j "IamRoleArn") String.of_json
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "KmsKeyId") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    ; percent_progress =
        Aws.Util.option_map (Aws.Json.lookup j "PercentProgress") Integer.of_json
    ; total_extracted_data_in_g_b =
        Aws.Util.option_map (Aws.Json.lookup j "TotalExtractedDataInGB") Integer.of_json
    ; failure_cause =
        Aws.Util.option_map (Aws.Json.lookup j "FailureCause") String.of_json
    ; warning_message =
        Aws.Util.option_map (Aws.Json.lookup j "WarningMessage") String.of_json
    }
end

module RevokeDBSecurityGroupIngressMessage = struct
  type t =
    { d_b_security_group_name : String.t
    ; c_i_d_r_i_p : String.t option
    ; e_c2_security_group_name : String.t option
    ; e_c2_security_group_id : String.t option
    ; e_c2_security_group_owner_id : String.t option
    }

  let make
      ~d_b_security_group_name
      ?c_i_d_r_i_p
      ?e_c2_security_group_name
      ?e_c2_security_group_id
      ?e_c2_security_group_owner_id
      () =
    { d_b_security_group_name
    ; c_i_d_r_i_p
    ; e_c2_security_group_name
    ; e_c2_security_group_id
    ; e_c2_security_group_owner_id
    }

  let parse xml =
    Some
      { d_b_security_group_name =
          Aws.Xml.required
            "DBSecurityGroupName"
            (Aws.Util.option_bind (Aws.Xml.member "DBSecurityGroupName" xml) String.parse)
      ; c_i_d_r_i_p = Aws.Util.option_bind (Aws.Xml.member "CIDRIP" xml) String.parse
      ; e_c2_security_group_name =
          Aws.Util.option_bind (Aws.Xml.member "EC2SecurityGroupName" xml) String.parse
      ; e_c2_security_group_id =
          Aws.Util.option_bind (Aws.Xml.member "EC2SecurityGroupId" xml) String.parse
      ; e_c2_security_group_owner_id =
          Aws.Util.option_bind (Aws.Xml.member "EC2SecurityGroupOwnerId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.e_c2_security_group_owner_id (fun f ->
               Aws.Query.Pair ("EC2SecurityGroupOwnerId", String.to_query f))
         ; Aws.Util.option_map v.e_c2_security_group_id (fun f ->
               Aws.Query.Pair ("EC2SecurityGroupId", String.to_query f))
         ; Aws.Util.option_map v.e_c2_security_group_name (fun f ->
               Aws.Query.Pair ("EC2SecurityGroupName", String.to_query f))
         ; Aws.Util.option_map v.c_i_d_r_i_p (fun f ->
               Aws.Query.Pair ("CIDRIP", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DBSecurityGroupName", String.to_query v.d_b_security_group_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.e_c2_security_group_owner_id (fun f ->
               "EC2SecurityGroupOwnerId", String.to_json f)
         ; Aws.Util.option_map v.e_c2_security_group_id (fun f ->
               "EC2SecurityGroupId", String.to_json f)
         ; Aws.Util.option_map v.e_c2_security_group_name (fun f ->
               "EC2SecurityGroupName", String.to_json f)
         ; Aws.Util.option_map v.c_i_d_r_i_p (fun f -> "CIDRIP", String.to_json f)
         ; Some ("DBSecurityGroupName", String.to_json v.d_b_security_group_name)
         ])

  let of_json j =
    { d_b_security_group_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBSecurityGroupName"))
    ; c_i_d_r_i_p = Aws.Util.option_map (Aws.Json.lookup j "CIDRIP") String.of_json
    ; e_c2_security_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "EC2SecurityGroupName") String.of_json
    ; e_c2_security_group_id =
        Aws.Util.option_map (Aws.Json.lookup j "EC2SecurityGroupId") String.of_json
    ; e_c2_security_group_owner_id =
        Aws.Util.option_map (Aws.Json.lookup j "EC2SecurityGroupOwnerId") String.of_json
    }
end

module DBClusterSnapshotAttribute = struct
  type t =
    { attribute_name : String.t option
    ; attribute_values : AttributeValueList.t
    }

  let make ?attribute_name ?(attribute_values = []) () =
    { attribute_name; attribute_values }

  let parse xml =
    Some
      { attribute_name =
          Aws.Util.option_bind (Aws.Xml.member "AttributeName" xml) String.parse
      ; attribute_values =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AttributeValues" xml)
               AttributeValueList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("AttributeValues.member", AttributeValueList.to_query v.attribute_values))
         ; Aws.Util.option_map v.attribute_name (fun f ->
               Aws.Query.Pair ("AttributeName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("AttributeValues", AttributeValueList.to_json v.attribute_values)
         ; Aws.Util.option_map v.attribute_name (fun f ->
               "AttributeName", String.to_json f)
         ])

  let of_json j =
    { attribute_name =
        Aws.Util.option_map (Aws.Json.lookup j "AttributeName") String.of_json
    ; attribute_values =
        AttributeValueList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AttributeValues"))
    }
end

module DBClusterSnapshotAttributeList = struct
  type t = DBClusterSnapshotAttribute.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         DBClusterSnapshotAttribute.parse
         (Aws.Xml.members "DBClusterSnapshotAttribute" xml))

  let to_query v = Aws.Query.to_query_list DBClusterSnapshotAttribute.to_query v

  let to_json v = `List (List.map DBClusterSnapshotAttribute.to_json v)

  let of_json j = Aws.Json.to_list DBClusterSnapshotAttribute.of_json j
end

module DBClusterSnapshotAttributesResult = struct
  type t =
    { d_b_cluster_snapshot_identifier : String.t option
    ; d_b_cluster_snapshot_attributes : DBClusterSnapshotAttributeList.t
    }

  let make ?d_b_cluster_snapshot_identifier ?(d_b_cluster_snapshot_attributes = []) () =
    { d_b_cluster_snapshot_identifier; d_b_cluster_snapshot_attributes }

  let parse xml =
    Some
      { d_b_cluster_snapshot_identifier =
          Aws.Util.option_bind
            (Aws.Xml.member "DBClusterSnapshotIdentifier" xml)
            String.parse
      ; d_b_cluster_snapshot_attributes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DBClusterSnapshotAttributes" xml)
               DBClusterSnapshotAttributeList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "DBClusterSnapshotAttributes.member"
                , DBClusterSnapshotAttributeList.to_query
                    v.d_b_cluster_snapshot_attributes ))
         ; Aws.Util.option_map v.d_b_cluster_snapshot_identifier (fun f ->
               Aws.Query.Pair ("DBClusterSnapshotIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "DBClusterSnapshotAttributes"
             , DBClusterSnapshotAttributeList.to_json v.d_b_cluster_snapshot_attributes )
         ; Aws.Util.option_map v.d_b_cluster_snapshot_identifier (fun f ->
               "DBClusterSnapshotIdentifier", String.to_json f)
         ])

  let of_json j =
    { d_b_cluster_snapshot_identifier =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBClusterSnapshotIdentifier")
          String.of_json
    ; d_b_cluster_snapshot_attributes =
        DBClusterSnapshotAttributeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterSnapshotAttributes"))
    }
end

module ModifyDBClusterSnapshotAttributeResult = struct
  type t =
    { d_b_cluster_snapshot_attributes_result : DBClusterSnapshotAttributesResult.t option
    }

  let make ?d_b_cluster_snapshot_attributes_result () =
    { d_b_cluster_snapshot_attributes_result }

  let parse xml =
    Some
      { d_b_cluster_snapshot_attributes_result =
          Aws.Util.option_bind
            (Aws.Xml.member "DBClusterSnapshotAttributesResult" xml)
            DBClusterSnapshotAttributesResult.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster_snapshot_attributes_result (fun f ->
               Aws.Query.Pair
                 ( "DBClusterSnapshotAttributesResult"
                 , DBClusterSnapshotAttributesResult.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster_snapshot_attributes_result (fun f ->
               ( "DBClusterSnapshotAttributesResult"
               , DBClusterSnapshotAttributesResult.to_json f ))
         ])

  let of_json j =
    { d_b_cluster_snapshot_attributes_result =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBClusterSnapshotAttributesResult")
          DBClusterSnapshotAttributesResult.of_json
    }
end

module DBProxyTargetGroupNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module StartActivityStreamResponse = struct
  type t =
    { kms_key_id : String.t option
    ; kinesis_stream_name : String.t option
    ; status : ActivityStreamStatus.t option
    ; mode : ActivityStreamMode.t option
    ; apply_immediately : Boolean.t option
    }

  let make ?kms_key_id ?kinesis_stream_name ?status ?mode ?apply_immediately () =
    { kms_key_id; kinesis_stream_name; status; mode; apply_immediately }

  let parse xml =
    Some
      { kms_key_id = Aws.Util.option_bind (Aws.Xml.member "KmsKeyId" xml) String.parse
      ; kinesis_stream_name =
          Aws.Util.option_bind (Aws.Xml.member "KinesisStreamName" xml) String.parse
      ; status =
          Aws.Util.option_bind (Aws.Xml.member "Status" xml) ActivityStreamStatus.parse
      ; mode = Aws.Util.option_bind (Aws.Xml.member "Mode" xml) ActivityStreamMode.parse
      ; apply_immediately =
          Aws.Util.option_bind (Aws.Xml.member "ApplyImmediately" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.apply_immediately (fun f ->
               Aws.Query.Pair ("ApplyImmediately", Boolean.to_query f))
         ; Aws.Util.option_map v.mode (fun f ->
               Aws.Query.Pair ("Mode", ActivityStreamMode.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", ActivityStreamStatus.to_query f))
         ; Aws.Util.option_map v.kinesis_stream_name (fun f ->
               Aws.Query.Pair ("KinesisStreamName", String.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.apply_immediately (fun f ->
               "ApplyImmediately", Boolean.to_json f)
         ; Aws.Util.option_map v.mode (fun f -> "Mode", ActivityStreamMode.to_json f)
         ; Aws.Util.option_map v.status (fun f ->
               "Status", ActivityStreamStatus.to_json f)
         ; Aws.Util.option_map v.kinesis_stream_name (fun f ->
               "KinesisStreamName", String.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "KmsKeyId", String.to_json f)
         ])

  let of_json j =
    { kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "KmsKeyId") String.of_json
    ; kinesis_stream_name =
        Aws.Util.option_map (Aws.Json.lookup j "KinesisStreamName") String.of_json
    ; status =
        Aws.Util.option_map (Aws.Json.lookup j "Status") ActivityStreamStatus.of_json
    ; mode = Aws.Util.option_map (Aws.Json.lookup j "Mode") ActivityStreamMode.of_json
    ; apply_immediately =
        Aws.Util.option_map (Aws.Json.lookup j "ApplyImmediately") Boolean.of_json
    }
end

module DeleteCustomAvailabilityZoneResult = struct
  type t = { custom_availability_zone : CustomAvailabilityZone.t option }

  let make ?custom_availability_zone () = { custom_availability_zone }

  let parse xml =
    Some
      { custom_availability_zone =
          Aws.Util.option_bind
            (Aws.Xml.member "CustomAvailabilityZone" xml)
            CustomAvailabilityZone.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.custom_availability_zone (fun f ->
               Aws.Query.Pair ("CustomAvailabilityZone", CustomAvailabilityZone.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.custom_availability_zone (fun f ->
               "CustomAvailabilityZone", CustomAvailabilityZone.to_json f)
         ])

  let of_json j =
    { custom_availability_zone =
        Aws.Util.option_map
          (Aws.Json.lookup j "CustomAvailabilityZone")
          CustomAvailabilityZone.of_json
    }
end

module DBInstanceAutomatedBackupList = struct
  type t = DBInstanceAutomatedBackup.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         DBInstanceAutomatedBackup.parse
         (Aws.Xml.members "DBInstanceAutomatedBackup" xml))

  let to_query v = Aws.Query.to_query_list DBInstanceAutomatedBackup.to_query v

  let to_json v = `List (List.map DBInstanceAutomatedBackup.to_json v)

  let of_json j = Aws.Json.to_list DBInstanceAutomatedBackup.of_json j
end

module DBInstanceAutomatedBackupMessage = struct
  type t =
    { marker : String.t option
    ; d_b_instance_automated_backups : DBInstanceAutomatedBackupList.t
    }

  let make ?marker ?(d_b_instance_automated_backups = []) () =
    { marker; d_b_instance_automated_backups }

  let parse xml =
    Some
      { marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; d_b_instance_automated_backups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DBInstanceAutomatedBackups" xml)
               DBInstanceAutomatedBackupList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "DBInstanceAutomatedBackups.member"
                , DBInstanceAutomatedBackupList.to_query v.d_b_instance_automated_backups
                ))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "DBInstanceAutomatedBackups"
             , DBInstanceAutomatedBackupList.to_json v.d_b_instance_automated_backups )
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ])

  let of_json j =
    { marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; d_b_instance_automated_backups =
        DBInstanceAutomatedBackupList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBInstanceAutomatedBackups"))
    }
end

module DeleteEventSubscriptionMessage = struct
  type t = { subscription_name : String.t }

  let make ~subscription_name () = { subscription_name }

  let parse xml =
    Some
      { subscription_name =
          Aws.Xml.required
            "SubscriptionName"
            (Aws.Util.option_bind (Aws.Xml.member "SubscriptionName" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("SubscriptionName", String.to_query v.subscription_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("SubscriptionName", String.to_json v.subscription_name) ])

  let of_json j =
    { subscription_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SubscriptionName"))
    }
end

module DBProxyAlreadyExistsFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module OptionConfiguration = struct
  type t =
    { option_name : String.t
    ; port : Integer.t option
    ; option_version : String.t option
    ; d_b_security_group_memberships : DBSecurityGroupNameList.t
    ; vpc_security_group_memberships : VpcSecurityGroupIdList.t
    ; option_settings : OptionSettingsList.t
    }

  let make
      ~option_name
      ?port
      ?option_version
      ?(d_b_security_group_memberships = [])
      ?(vpc_security_group_memberships = [])
      ?(option_settings = [])
      () =
    { option_name
    ; port
    ; option_version
    ; d_b_security_group_memberships
    ; vpc_security_group_memberships
    ; option_settings
    }

  let parse xml =
    Some
      { option_name =
          Aws.Xml.required
            "OptionName"
            (Aws.Util.option_bind (Aws.Xml.member "OptionName" xml) String.parse)
      ; port = Aws.Util.option_bind (Aws.Xml.member "Port" xml) Integer.parse
      ; option_version =
          Aws.Util.option_bind (Aws.Xml.member "OptionVersion" xml) String.parse
      ; d_b_security_group_memberships =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DBSecurityGroupMemberships" xml)
               DBSecurityGroupNameList.parse)
      ; vpc_security_group_memberships =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "VpcSecurityGroupMemberships" xml)
               VpcSecurityGroupIdList.parse)
      ; option_settings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "OptionSettings" xml)
               OptionSettingsList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("OptionSettings.member", OptionSettingsList.to_query v.option_settings))
         ; Some
             (Aws.Query.Pair
                ( "VpcSecurityGroupMemberships.member"
                , VpcSecurityGroupIdList.to_query v.vpc_security_group_memberships ))
         ; Some
             (Aws.Query.Pair
                ( "DBSecurityGroupMemberships.member"
                , DBSecurityGroupNameList.to_query v.d_b_security_group_memberships ))
         ; Aws.Util.option_map v.option_version (fun f ->
               Aws.Query.Pair ("OptionVersion", String.to_query f))
         ; Aws.Util.option_map v.port (fun f ->
               Aws.Query.Pair ("Port", Integer.to_query f))
         ; Some (Aws.Query.Pair ("OptionName", String.to_query v.option_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("OptionSettings", OptionSettingsList.to_json v.option_settings)
         ; Some
             ( "VpcSecurityGroupMemberships"
             , VpcSecurityGroupIdList.to_json v.vpc_security_group_memberships )
         ; Some
             ( "DBSecurityGroupMemberships"
             , DBSecurityGroupNameList.to_json v.d_b_security_group_memberships )
         ; Aws.Util.option_map v.option_version (fun f ->
               "OptionVersion", String.to_json f)
         ; Aws.Util.option_map v.port (fun f -> "Port", Integer.to_json f)
         ; Some ("OptionName", String.to_json v.option_name)
         ])

  let of_json j =
    { option_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "OptionName"))
    ; port = Aws.Util.option_map (Aws.Json.lookup j "Port") Integer.of_json
    ; option_version =
        Aws.Util.option_map (Aws.Json.lookup j "OptionVersion") String.of_json
    ; d_b_security_group_memberships =
        DBSecurityGroupNameList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBSecurityGroupMemberships"))
    ; vpc_security_group_memberships =
        VpcSecurityGroupIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcSecurityGroupMemberships"))
    ; option_settings =
        OptionSettingsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "OptionSettings"))
    }
end

module OptionConfigurationList = struct
  type t = OptionConfiguration.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map OptionConfiguration.parse (Aws.Xml.members "OptionConfiguration" xml))

  let to_query v = Aws.Query.to_query_list OptionConfiguration.to_query v

  let to_json v = `List (List.map OptionConfiguration.to_json v)

  let of_json j = Aws.Json.to_list OptionConfiguration.of_json j
end

module InvalidDBParameterGroupStateFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DescribeOptionGroupsMessage = struct
  type t =
    { option_group_name : String.t option
    ; filters : FilterList.t
    ; marker : String.t option
    ; max_records : Integer.t option
    ; engine_name : String.t option
    ; major_engine_version : String.t option
    }

  let make
      ?option_group_name
      ?(filters = [])
      ?marker
      ?max_records
      ?engine_name
      ?major_engine_version
      () =
    { option_group_name; filters; marker; max_records; engine_name; major_engine_version }

  let parse xml =
    Some
      { option_group_name =
          Aws.Util.option_bind (Aws.Xml.member "OptionGroupName" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; engine_name = Aws.Util.option_bind (Aws.Xml.member "EngineName" xml) String.parse
      ; major_engine_version =
          Aws.Util.option_bind (Aws.Xml.member "MajorEngineVersion" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.major_engine_version (fun f ->
               Aws.Query.Pair ("MajorEngineVersion", String.to_query f))
         ; Aws.Util.option_map v.engine_name (fun f ->
               Aws.Query.Pair ("EngineName", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.option_group_name (fun f ->
               Aws.Query.Pair ("OptionGroupName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.major_engine_version (fun f ->
               "MajorEngineVersion", String.to_json f)
         ; Aws.Util.option_map v.engine_name (fun f -> "EngineName", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.option_group_name (fun f ->
               "OptionGroupName", String.to_json f)
         ])

  let of_json j =
    { option_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "OptionGroupName") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; engine_name = Aws.Util.option_map (Aws.Json.lookup j "EngineName") String.of_json
    ; major_engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "MajorEngineVersion") String.of_json
    }
end

module ApplyMethod = struct
  type t =
    | Immediate
    | Pending_reboot

  let str_to_t = [ "pending-reboot", Pending_reboot; "immediate", Immediate ]

  let t_to_str = [ Pending_reboot, "pending-reboot"; Immediate, "immediate" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module Parameter = struct
  type t =
    { parameter_name : String.t option
    ; parameter_value : String.t option
    ; description : String.t option
    ; source : String.t option
    ; apply_type : String.t option
    ; data_type : String.t option
    ; allowed_values : String.t option
    ; is_modifiable : Boolean.t option
    ; minimum_engine_version : String.t option
    ; apply_method : ApplyMethod.t option
    ; supported_engine_modes : EngineModeList.t
    }

  let make
      ?parameter_name
      ?parameter_value
      ?description
      ?source
      ?apply_type
      ?data_type
      ?allowed_values
      ?is_modifiable
      ?minimum_engine_version
      ?apply_method
      ?(supported_engine_modes = [])
      () =
    { parameter_name
    ; parameter_value
    ; description
    ; source
    ; apply_type
    ; data_type
    ; allowed_values
    ; is_modifiable
    ; minimum_engine_version
    ; apply_method
    ; supported_engine_modes
    }

  let parse xml =
    Some
      { parameter_name =
          Aws.Util.option_bind (Aws.Xml.member "ParameterName" xml) String.parse
      ; parameter_value =
          Aws.Util.option_bind (Aws.Xml.member "ParameterValue" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; source = Aws.Util.option_bind (Aws.Xml.member "Source" xml) String.parse
      ; apply_type = Aws.Util.option_bind (Aws.Xml.member "ApplyType" xml) String.parse
      ; data_type = Aws.Util.option_bind (Aws.Xml.member "DataType" xml) String.parse
      ; allowed_values =
          Aws.Util.option_bind (Aws.Xml.member "AllowedValues" xml) String.parse
      ; is_modifiable =
          Aws.Util.option_bind (Aws.Xml.member "IsModifiable" xml) Boolean.parse
      ; minimum_engine_version =
          Aws.Util.option_bind (Aws.Xml.member "MinimumEngineVersion" xml) String.parse
      ; apply_method =
          Aws.Util.option_bind (Aws.Xml.member "ApplyMethod" xml) ApplyMethod.parse
      ; supported_engine_modes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SupportedEngineModes" xml)
               EngineModeList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "SupportedEngineModes.member"
                , EngineModeList.to_query v.supported_engine_modes ))
         ; Aws.Util.option_map v.apply_method (fun f ->
               Aws.Query.Pair ("ApplyMethod", ApplyMethod.to_query f))
         ; Aws.Util.option_map v.minimum_engine_version (fun f ->
               Aws.Query.Pair ("MinimumEngineVersion", String.to_query f))
         ; Aws.Util.option_map v.is_modifiable (fun f ->
               Aws.Query.Pair ("IsModifiable", Boolean.to_query f))
         ; Aws.Util.option_map v.allowed_values (fun f ->
               Aws.Query.Pair ("AllowedValues", String.to_query f))
         ; Aws.Util.option_map v.data_type (fun f ->
               Aws.Query.Pair ("DataType", String.to_query f))
         ; Aws.Util.option_map v.apply_type (fun f ->
               Aws.Query.Pair ("ApplyType", String.to_query f))
         ; Aws.Util.option_map v.source (fun f ->
               Aws.Query.Pair ("Source", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.parameter_value (fun f ->
               Aws.Query.Pair ("ParameterValue", String.to_query f))
         ; Aws.Util.option_map v.parameter_name (fun f ->
               Aws.Query.Pair ("ParameterName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("SupportedEngineModes", EngineModeList.to_json v.supported_engine_modes)
         ; Aws.Util.option_map v.apply_method (fun f ->
               "ApplyMethod", ApplyMethod.to_json f)
         ; Aws.Util.option_map v.minimum_engine_version (fun f ->
               "MinimumEngineVersion", String.to_json f)
         ; Aws.Util.option_map v.is_modifiable (fun f ->
               "IsModifiable", Boolean.to_json f)
         ; Aws.Util.option_map v.allowed_values (fun f ->
               "AllowedValues", String.to_json f)
         ; Aws.Util.option_map v.data_type (fun f -> "DataType", String.to_json f)
         ; Aws.Util.option_map v.apply_type (fun f -> "ApplyType", String.to_json f)
         ; Aws.Util.option_map v.source (fun f -> "Source", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.parameter_value (fun f ->
               "ParameterValue", String.to_json f)
         ; Aws.Util.option_map v.parameter_name (fun f ->
               "ParameterName", String.to_json f)
         ])

  let of_json j =
    { parameter_name =
        Aws.Util.option_map (Aws.Json.lookup j "ParameterName") String.of_json
    ; parameter_value =
        Aws.Util.option_map (Aws.Json.lookup j "ParameterValue") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; source = Aws.Util.option_map (Aws.Json.lookup j "Source") String.of_json
    ; apply_type = Aws.Util.option_map (Aws.Json.lookup j "ApplyType") String.of_json
    ; data_type = Aws.Util.option_map (Aws.Json.lookup j "DataType") String.of_json
    ; allowed_values =
        Aws.Util.option_map (Aws.Json.lookup j "AllowedValues") String.of_json
    ; is_modifiable =
        Aws.Util.option_map (Aws.Json.lookup j "IsModifiable") Boolean.of_json
    ; minimum_engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "MinimumEngineVersion") String.of_json
    ; apply_method =
        Aws.Util.option_map (Aws.Json.lookup j "ApplyMethod") ApplyMethod.of_json
    ; supported_engine_modes =
        EngineModeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SupportedEngineModes"))
    }
end

module ParametersList = struct
  type t = Parameter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Parameter.parse (Aws.Xml.members "Parameter" xml))

  let to_query v = Aws.Query.to_query_list Parameter.to_query v

  let to_json v = `List (List.map Parameter.to_json v)

  let of_json j = Aws.Json.to_list Parameter.of_json j
end

module ResetDBParameterGroupMessage = struct
  type t =
    { d_b_parameter_group_name : String.t
    ; reset_all_parameters : Boolean.t option
    ; parameters : ParametersList.t
    }

  let make ~d_b_parameter_group_name ?reset_all_parameters ?(parameters = []) () =
    { d_b_parameter_group_name; reset_all_parameters; parameters }

  let parse xml =
    Some
      { d_b_parameter_group_name =
          Aws.Xml.required
            "DBParameterGroupName"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBParameterGroupName" xml)
               String.parse)
      ; reset_all_parameters =
          Aws.Util.option_bind (Aws.Xml.member "ResetAllParameters" xml) Boolean.parse
      ; parameters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Parameters" xml) ParametersList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("Parameters.member", ParametersList.to_query v.parameters))
         ; Aws.Util.option_map v.reset_all_parameters (fun f ->
               Aws.Query.Pair ("ResetAllParameters", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DBParameterGroupName", String.to_query v.d_b_parameter_group_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Parameters", ParametersList.to_json v.parameters)
         ; Aws.Util.option_map v.reset_all_parameters (fun f ->
               "ResetAllParameters", Boolean.to_json f)
         ; Some ("DBParameterGroupName", String.to_json v.d_b_parameter_group_name)
         ])

  let of_json j =
    { d_b_parameter_group_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBParameterGroupName"))
    ; reset_all_parameters =
        Aws.Util.option_map (Aws.Json.lookup j "ResetAllParameters") Boolean.of_json
    ; parameters =
        ParametersList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Parameters"))
    }
end

module DeleteDBClusterEndpointMessage = struct
  type t = { d_b_cluster_endpoint_identifier : String.t }

  let make ~d_b_cluster_endpoint_identifier () = { d_b_cluster_endpoint_identifier }

  let parse xml =
    Some
      { d_b_cluster_endpoint_identifier =
          Aws.Xml.required
            "DBClusterEndpointIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBClusterEndpointIdentifier" xml)
               String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "DBClusterEndpointIdentifier"
                , String.to_query v.d_b_cluster_endpoint_identifier ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "DBClusterEndpointIdentifier"
             , String.to_json v.d_b_cluster_endpoint_identifier )
         ])

  let of_json j =
    { d_b_cluster_endpoint_identifier =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterEndpointIdentifier"))
    }
end

module StorageQuotaExceededFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DescribeDBProxyTargetsRequest = struct
  type t =
    { d_b_proxy_name : String.t
    ; target_group_name : String.t option
    ; filters : FilterList.t
    ; marker : String.t option
    ; max_records : Integer.t option
    }

  let make ~d_b_proxy_name ?target_group_name ?(filters = []) ?marker ?max_records () =
    { d_b_proxy_name; target_group_name; filters; marker; max_records }

  let parse xml =
    Some
      { d_b_proxy_name =
          Aws.Xml.required
            "DBProxyName"
            (Aws.Util.option_bind (Aws.Xml.member "DBProxyName" xml) String.parse)
      ; target_group_name =
          Aws.Util.option_bind (Aws.Xml.member "TargetGroupName" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.target_group_name (fun f ->
               Aws.Query.Pair ("TargetGroupName", String.to_query f))
         ; Some (Aws.Query.Pair ("DBProxyName", String.to_query v.d_b_proxy_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.target_group_name (fun f ->
               "TargetGroupName", String.to_json f)
         ; Some ("DBProxyName", String.to_json v.d_b_proxy_name)
         ])

  let of_json j =
    { d_b_proxy_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBProxyName"))
    ; target_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "TargetGroupName") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    }
end

module DBSecurityGroupQuotaExceededFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module AccountQuotaList = struct
  type t = AccountQuota.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map AccountQuota.parse (Aws.Xml.members "AccountQuota" xml))

  let to_query v = Aws.Query.to_query_list AccountQuota.to_query v

  let to_json v = `List (List.map AccountQuota.to_json v)

  let of_json j = Aws.Json.to_list AccountQuota.of_json j
end

module AccountAttributesMessage = struct
  type t = { account_quotas : AccountQuotaList.t }

  let make ?(account_quotas = []) () = { account_quotas }

  let parse xml =
    Some
      { account_quotas =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AccountQuotas" xml)
               AccountQuotaList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("AccountQuotas.member", AccountQuotaList.to_query v.account_quotas))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("AccountQuotas", AccountQuotaList.to_json v.account_quotas) ])

  let of_json j =
    { account_quotas =
        AccountQuotaList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AccountQuotas"))
    }
end

module ModifyCurrentDBClusterCapacityMessage = struct
  type t =
    { d_b_cluster_identifier : String.t
    ; capacity : Integer.t option
    ; seconds_before_timeout : Integer.t option
    ; timeout_action : String.t option
    }

  let make ~d_b_cluster_identifier ?capacity ?seconds_before_timeout ?timeout_action () =
    { d_b_cluster_identifier; capacity; seconds_before_timeout; timeout_action }

  let parse xml =
    Some
      { d_b_cluster_identifier =
          Aws.Xml.required
            "DBClusterIdentifier"
            (Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse)
      ; capacity = Aws.Util.option_bind (Aws.Xml.member "Capacity" xml) Integer.parse
      ; seconds_before_timeout =
          Aws.Util.option_bind (Aws.Xml.member "SecondsBeforeTimeout" xml) Integer.parse
      ; timeout_action =
          Aws.Util.option_bind (Aws.Xml.member "TimeoutAction" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timeout_action (fun f ->
               Aws.Query.Pair ("TimeoutAction", String.to_query f))
         ; Aws.Util.option_map v.seconds_before_timeout (fun f ->
               Aws.Query.Pair ("SecondsBeforeTimeout", Integer.to_query f))
         ; Aws.Util.option_map v.capacity (fun f ->
               Aws.Query.Pair ("Capacity", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DBClusterIdentifier", String.to_query v.d_b_cluster_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timeout_action (fun f ->
               "TimeoutAction", String.to_json f)
         ; Aws.Util.option_map v.seconds_before_timeout (fun f ->
               "SecondsBeforeTimeout", Integer.to_json f)
         ; Aws.Util.option_map v.capacity (fun f -> "Capacity", Integer.to_json f)
         ; Some ("DBClusterIdentifier", String.to_json v.d_b_cluster_identifier)
         ])

  let of_json j =
    { d_b_cluster_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterIdentifier"))
    ; capacity = Aws.Util.option_map (Aws.Json.lookup j "Capacity") Integer.of_json
    ; seconds_before_timeout =
        Aws.Util.option_map (Aws.Json.lookup j "SecondsBeforeTimeout") Integer.of_json
    ; timeout_action =
        Aws.Util.option_map (Aws.Json.lookup j "TimeoutAction") String.of_json
    }
end

module EventCategoriesMap = struct
  type t =
    { source_type : String.t option
    ; event_categories : EventCategoriesList.t
    }

  let make ?source_type ?(event_categories = []) () = { source_type; event_categories }

  let parse xml =
    Some
      { source_type = Aws.Util.option_bind (Aws.Xml.member "SourceType" xml) String.parse
      ; event_categories =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "EventCategories" xml)
               EventCategoriesList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("EventCategories.member", EventCategoriesList.to_query v.event_categories))
         ; Aws.Util.option_map v.source_type (fun f ->
               Aws.Query.Pair ("SourceType", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("EventCategories", EventCategoriesList.to_json v.event_categories)
         ; Aws.Util.option_map v.source_type (fun f -> "SourceType", String.to_json f)
         ])

  let of_json j =
    { source_type = Aws.Util.option_map (Aws.Json.lookup j "SourceType") String.of_json
    ; event_categories =
        EventCategoriesList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "EventCategories"))
    }
end

module ExportTasksList = struct
  type t = ExportTask.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ExportTask.parse (Aws.Xml.members "ExportTask" xml))

  let to_query v = Aws.Query.to_query_list ExportTask.to_query v

  let to_json v = `List (List.map ExportTask.to_json v)

  let of_json j = Aws.Json.to_list ExportTask.of_json j
end

module ExportTasksMessage = struct
  type t =
    { marker : String.t option
    ; export_tasks : ExportTasksList.t
    }

  let make ?marker ?(export_tasks = []) () = { marker; export_tasks }

  let parse xml =
    Some
      { marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; export_tasks =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ExportTasks" xml)
               ExportTasksList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("ExportTasks.member", ExportTasksList.to_query v.export_tasks))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("ExportTasks", ExportTasksList.to_json v.export_tasks)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ])

  let of_json j =
    { marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; export_tasks =
        ExportTasksList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ExportTasks"))
    }
end

module DBSubnetGroupNotAllowedFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DBProxyTargetAlreadyRegisteredFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module InstallationMedia = struct
  type t =
    { installation_media_id : String.t option
    ; custom_availability_zone_id : String.t option
    ; engine : String.t option
    ; engine_version : String.t option
    ; engine_installation_media_path : String.t option
    ; o_s_installation_media_path : String.t option
    ; status : String.t option
    ; failure_cause : InstallationMediaFailureCause.t option
    }

  let make
      ?installation_media_id
      ?custom_availability_zone_id
      ?engine
      ?engine_version
      ?engine_installation_media_path
      ?o_s_installation_media_path
      ?status
      ?failure_cause
      () =
    { installation_media_id
    ; custom_availability_zone_id
    ; engine
    ; engine_version
    ; engine_installation_media_path
    ; o_s_installation_media_path
    ; status
    ; failure_cause
    }

  let parse xml =
    Some
      { installation_media_id =
          Aws.Util.option_bind (Aws.Xml.member "InstallationMediaId" xml) String.parse
      ; custom_availability_zone_id =
          Aws.Util.option_bind
            (Aws.Xml.member "CustomAvailabilityZoneId" xml)
            String.parse
      ; engine = Aws.Util.option_bind (Aws.Xml.member "Engine" xml) String.parse
      ; engine_version =
          Aws.Util.option_bind (Aws.Xml.member "EngineVersion" xml) String.parse
      ; engine_installation_media_path =
          Aws.Util.option_bind
            (Aws.Xml.member "EngineInstallationMediaPath" xml)
            String.parse
      ; o_s_installation_media_path =
          Aws.Util.option_bind (Aws.Xml.member "OSInstallationMediaPath" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      ; failure_cause =
          Aws.Util.option_bind
            (Aws.Xml.member "FailureCause" xml)
            InstallationMediaFailureCause.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.failure_cause (fun f ->
               Aws.Query.Pair ("FailureCause", InstallationMediaFailureCause.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.o_s_installation_media_path (fun f ->
               Aws.Query.Pair ("OSInstallationMediaPath", String.to_query f))
         ; Aws.Util.option_map v.engine_installation_media_path (fun f ->
               Aws.Query.Pair ("EngineInstallationMediaPath", String.to_query f))
         ; Aws.Util.option_map v.engine_version (fun f ->
               Aws.Query.Pair ("EngineVersion", String.to_query f))
         ; Aws.Util.option_map v.engine (fun f ->
               Aws.Query.Pair ("Engine", String.to_query f))
         ; Aws.Util.option_map v.custom_availability_zone_id (fun f ->
               Aws.Query.Pair ("CustomAvailabilityZoneId", String.to_query f))
         ; Aws.Util.option_map v.installation_media_id (fun f ->
               Aws.Query.Pair ("InstallationMediaId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.failure_cause (fun f ->
               "FailureCause", InstallationMediaFailureCause.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ; Aws.Util.option_map v.o_s_installation_media_path (fun f ->
               "OSInstallationMediaPath", String.to_json f)
         ; Aws.Util.option_map v.engine_installation_media_path (fun f ->
               "EngineInstallationMediaPath", String.to_json f)
         ; Aws.Util.option_map v.engine_version (fun f ->
               "EngineVersion", String.to_json f)
         ; Aws.Util.option_map v.engine (fun f -> "Engine", String.to_json f)
         ; Aws.Util.option_map v.custom_availability_zone_id (fun f ->
               "CustomAvailabilityZoneId", String.to_json f)
         ; Aws.Util.option_map v.installation_media_id (fun f ->
               "InstallationMediaId", String.to_json f)
         ])

  let of_json j =
    { installation_media_id =
        Aws.Util.option_map (Aws.Json.lookup j "InstallationMediaId") String.of_json
    ; custom_availability_zone_id =
        Aws.Util.option_map (Aws.Json.lookup j "CustomAvailabilityZoneId") String.of_json
    ; engine = Aws.Util.option_map (Aws.Json.lookup j "Engine") String.of_json
    ; engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "EngineVersion") String.of_json
    ; engine_installation_media_path =
        Aws.Util.option_map
          (Aws.Json.lookup j "EngineInstallationMediaPath")
          String.of_json
    ; o_s_installation_media_path =
        Aws.Util.option_map (Aws.Json.lookup j "OSInstallationMediaPath") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    ; failure_cause =
        Aws.Util.option_map
          (Aws.Json.lookup j "FailureCause")
          InstallationMediaFailureCause.of_json
    }
end

module InstallationMediaList = struct
  type t = InstallationMedia.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map InstallationMedia.parse (Aws.Xml.members "InstallationMedia" xml))

  let to_query v = Aws.Query.to_query_list InstallationMedia.to_query v

  let to_json v = `List (List.map InstallationMedia.to_json v)

  let of_json j = Aws.Json.to_list InstallationMedia.of_json j
end

module InstallationMediaMessage = struct
  type t =
    { marker : String.t option
    ; installation_media : InstallationMediaList.t
    }

  let make ?marker ?(installation_media = []) () = { marker; installation_media }

  let parse xml =
    Some
      { marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; installation_media =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "InstallationMedia" xml)
               InstallationMediaList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "InstallationMedia.member"
                , InstallationMediaList.to_query v.installation_media ))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("InstallationMedia", InstallationMediaList.to_json v.installation_media)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ])

  let of_json j =
    { marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; installation_media =
        InstallationMediaList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InstallationMedia"))
    }
end

module OptionSettingConfigurationList = struct
  type t = OptionSetting.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map OptionSetting.parse (Aws.Xml.members "OptionSetting" xml))

  let to_query v = Aws.Query.to_query_list OptionSetting.to_query v

  let to_json v = `List (List.map OptionSetting.to_json v)

  let of_json j = Aws.Json.to_list OptionSetting.of_json j
end

module Option = struct
  type t =
    { option_name : String.t option
    ; option_description : String.t option
    ; persistent : Boolean.t option
    ; permanent : Boolean.t option
    ; port : Integer.t option
    ; option_version : String.t option
    ; option_settings : OptionSettingConfigurationList.t
    ; d_b_security_group_memberships : DBSecurityGroupMembershipList.t
    ; vpc_security_group_memberships : VpcSecurityGroupMembershipList.t
    }

  let make
      ?option_name
      ?option_description
      ?persistent
      ?permanent
      ?port
      ?option_version
      ?(option_settings = [])
      ?(d_b_security_group_memberships = [])
      ?(vpc_security_group_memberships = [])
      () =
    { option_name
    ; option_description
    ; persistent
    ; permanent
    ; port
    ; option_version
    ; option_settings
    ; d_b_security_group_memberships
    ; vpc_security_group_memberships
    }

  let parse xml =
    Some
      { option_name = Aws.Util.option_bind (Aws.Xml.member "OptionName" xml) String.parse
      ; option_description =
          Aws.Util.option_bind (Aws.Xml.member "OptionDescription" xml) String.parse
      ; persistent = Aws.Util.option_bind (Aws.Xml.member "Persistent" xml) Boolean.parse
      ; permanent = Aws.Util.option_bind (Aws.Xml.member "Permanent" xml) Boolean.parse
      ; port = Aws.Util.option_bind (Aws.Xml.member "Port" xml) Integer.parse
      ; option_version =
          Aws.Util.option_bind (Aws.Xml.member "OptionVersion" xml) String.parse
      ; option_settings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "OptionSettings" xml)
               OptionSettingConfigurationList.parse)
      ; d_b_security_group_memberships =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DBSecurityGroupMemberships" xml)
               DBSecurityGroupMembershipList.parse)
      ; vpc_security_group_memberships =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "VpcSecurityGroupMemberships" xml)
               VpcSecurityGroupMembershipList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "VpcSecurityGroupMemberships.member"
                , VpcSecurityGroupMembershipList.to_query v.vpc_security_group_memberships
                ))
         ; Some
             (Aws.Query.Pair
                ( "DBSecurityGroupMemberships.member"
                , DBSecurityGroupMembershipList.to_query v.d_b_security_group_memberships
                ))
         ; Some
             (Aws.Query.Pair
                ( "OptionSettings.member"
                , OptionSettingConfigurationList.to_query v.option_settings ))
         ; Aws.Util.option_map v.option_version (fun f ->
               Aws.Query.Pair ("OptionVersion", String.to_query f))
         ; Aws.Util.option_map v.port (fun f ->
               Aws.Query.Pair ("Port", Integer.to_query f))
         ; Aws.Util.option_map v.permanent (fun f ->
               Aws.Query.Pair ("Permanent", Boolean.to_query f))
         ; Aws.Util.option_map v.persistent (fun f ->
               Aws.Query.Pair ("Persistent", Boolean.to_query f))
         ; Aws.Util.option_map v.option_description (fun f ->
               Aws.Query.Pair ("OptionDescription", String.to_query f))
         ; Aws.Util.option_map v.option_name (fun f ->
               Aws.Query.Pair ("OptionName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "VpcSecurityGroupMemberships"
             , VpcSecurityGroupMembershipList.to_json v.vpc_security_group_memberships )
         ; Some
             ( "DBSecurityGroupMemberships"
             , DBSecurityGroupMembershipList.to_json v.d_b_security_group_memberships )
         ; Some
             ("OptionSettings", OptionSettingConfigurationList.to_json v.option_settings)
         ; Aws.Util.option_map v.option_version (fun f ->
               "OptionVersion", String.to_json f)
         ; Aws.Util.option_map v.port (fun f -> "Port", Integer.to_json f)
         ; Aws.Util.option_map v.permanent (fun f -> "Permanent", Boolean.to_json f)
         ; Aws.Util.option_map v.persistent (fun f -> "Persistent", Boolean.to_json f)
         ; Aws.Util.option_map v.option_description (fun f ->
               "OptionDescription", String.to_json f)
         ; Aws.Util.option_map v.option_name (fun f -> "OptionName", String.to_json f)
         ])

  let of_json j =
    { option_name = Aws.Util.option_map (Aws.Json.lookup j "OptionName") String.of_json
    ; option_description =
        Aws.Util.option_map (Aws.Json.lookup j "OptionDescription") String.of_json
    ; persistent = Aws.Util.option_map (Aws.Json.lookup j "Persistent") Boolean.of_json
    ; permanent = Aws.Util.option_map (Aws.Json.lookup j "Permanent") Boolean.of_json
    ; port = Aws.Util.option_map (Aws.Json.lookup j "Port") Integer.of_json
    ; option_version =
        Aws.Util.option_map (Aws.Json.lookup j "OptionVersion") String.of_json
    ; option_settings =
        OptionSettingConfigurationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "OptionSettings"))
    ; d_b_security_group_memberships =
        DBSecurityGroupMembershipList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBSecurityGroupMemberships"))
    ; vpc_security_group_memberships =
        VpcSecurityGroupMembershipList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcSecurityGroupMemberships"))
    }
end

module OptionsList = struct
  type t = Option.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Option.parse (Aws.Xml.members "Option" xml))

  let to_query v = Aws.Query.to_query_list Option.to_query v

  let to_json v = `List (List.map Option.to_json v)

  let of_json j = Aws.Json.to_list Option.of_json j
end

module OptionGroup = struct
  type t =
    { option_group_name : String.t option
    ; option_group_description : String.t option
    ; engine_name : String.t option
    ; major_engine_version : String.t option
    ; options : OptionsList.t
    ; allows_vpc_and_non_vpc_instance_memberships : Boolean.t option
    ; vpc_id : String.t option
    ; option_group_arn : String.t option
    }

  let make
      ?option_group_name
      ?option_group_description
      ?engine_name
      ?major_engine_version
      ?(options = [])
      ?allows_vpc_and_non_vpc_instance_memberships
      ?vpc_id
      ?option_group_arn
      () =
    { option_group_name
    ; option_group_description
    ; engine_name
    ; major_engine_version
    ; options
    ; allows_vpc_and_non_vpc_instance_memberships
    ; vpc_id
    ; option_group_arn
    }

  let parse xml =
    Some
      { option_group_name =
          Aws.Util.option_bind (Aws.Xml.member "OptionGroupName" xml) String.parse
      ; option_group_description =
          Aws.Util.option_bind (Aws.Xml.member "OptionGroupDescription" xml) String.parse
      ; engine_name = Aws.Util.option_bind (Aws.Xml.member "EngineName" xml) String.parse
      ; major_engine_version =
          Aws.Util.option_bind (Aws.Xml.member "MajorEngineVersion" xml) String.parse
      ; options =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Options" xml) OptionsList.parse)
      ; allows_vpc_and_non_vpc_instance_memberships =
          Aws.Util.option_bind
            (Aws.Xml.member "AllowsVpcAndNonVpcInstanceMemberships" xml)
            Boolean.parse
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) String.parse
      ; option_group_arn =
          Aws.Util.option_bind (Aws.Xml.member "OptionGroupArn" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.option_group_arn (fun f ->
               Aws.Query.Pair ("OptionGroupArn", String.to_query f))
         ; Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Aws.Util.option_map v.allows_vpc_and_non_vpc_instance_memberships (fun f ->
               Aws.Query.Pair ("AllowsVpcAndNonVpcInstanceMemberships", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Options.member", OptionsList.to_query v.options))
         ; Aws.Util.option_map v.major_engine_version (fun f ->
               Aws.Query.Pair ("MajorEngineVersion", String.to_query f))
         ; Aws.Util.option_map v.engine_name (fun f ->
               Aws.Query.Pair ("EngineName", String.to_query f))
         ; Aws.Util.option_map v.option_group_description (fun f ->
               Aws.Query.Pair ("OptionGroupDescription", String.to_query f))
         ; Aws.Util.option_map v.option_group_name (fun f ->
               Aws.Query.Pair ("OptionGroupName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.option_group_arn (fun f ->
               "OptionGroupArn", String.to_json f)
         ; Aws.Util.option_map v.vpc_id (fun f -> "VpcId", String.to_json f)
         ; Aws.Util.option_map v.allows_vpc_and_non_vpc_instance_memberships (fun f ->
               "AllowsVpcAndNonVpcInstanceMemberships", Boolean.to_json f)
         ; Some ("Options", OptionsList.to_json v.options)
         ; Aws.Util.option_map v.major_engine_version (fun f ->
               "MajorEngineVersion", String.to_json f)
         ; Aws.Util.option_map v.engine_name (fun f -> "EngineName", String.to_json f)
         ; Aws.Util.option_map v.option_group_description (fun f ->
               "OptionGroupDescription", String.to_json f)
         ; Aws.Util.option_map v.option_group_name (fun f ->
               "OptionGroupName", String.to_json f)
         ])

  let of_json j =
    { option_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "OptionGroupName") String.of_json
    ; option_group_description =
        Aws.Util.option_map (Aws.Json.lookup j "OptionGroupDescription") String.of_json
    ; engine_name = Aws.Util.option_map (Aws.Json.lookup j "EngineName") String.of_json
    ; major_engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "MajorEngineVersion") String.of_json
    ; options = OptionsList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Options"))
    ; allows_vpc_and_non_vpc_instance_memberships =
        Aws.Util.option_map
          (Aws.Json.lookup j "AllowsVpcAndNonVpcInstanceMemberships")
          Boolean.of_json
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "VpcId") String.of_json
    ; option_group_arn =
        Aws.Util.option_map (Aws.Json.lookup j "OptionGroupArn") String.of_json
    }
end

module CreateOptionGroupResult = struct
  type t = { option_group : OptionGroup.t option }

  let make ?option_group () = { option_group }

  let parse xml =
    Some
      { option_group =
          Aws.Util.option_bind (Aws.Xml.member "OptionGroup" xml) OptionGroup.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.option_group (fun f ->
               Aws.Query.Pair ("OptionGroup", OptionGroup.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.option_group (fun f ->
               "OptionGroup", OptionGroup.to_json f)
         ])

  let of_json j =
    { option_group =
        Aws.Util.option_map (Aws.Json.lookup j "OptionGroup") OptionGroup.of_json
    }
end

module CloudwatchLogsExportConfiguration = struct
  type t =
    { enable_log_types : LogTypeList.t
    ; disable_log_types : LogTypeList.t
    }

  let make ?(enable_log_types = []) ?(disable_log_types = []) () =
    { enable_log_types; disable_log_types }

  let parse xml =
    Some
      { enable_log_types =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "EnableLogTypes" xml) LogTypeList.parse)
      ; disable_log_types =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DisableLogTypes" xml)
               LogTypeList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("DisableLogTypes.member", LogTypeList.to_query v.disable_log_types))
         ; Some
             (Aws.Query.Pair
                ("EnableLogTypes.member", LogTypeList.to_query v.enable_log_types))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("DisableLogTypes", LogTypeList.to_json v.disable_log_types)
         ; Some ("EnableLogTypes", LogTypeList.to_json v.enable_log_types)
         ])

  let of_json j =
    { enable_log_types =
        LogTypeList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "EnableLogTypes"))
    ; disable_log_types =
        LogTypeList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DisableLogTypes"))
    }
end

module CopyDBSnapshotResult = struct
  type t = { d_b_snapshot : DBSnapshot.t option }

  let make ?d_b_snapshot () = { d_b_snapshot }

  let parse xml =
    Some
      { d_b_snapshot =
          Aws.Util.option_bind (Aws.Xml.member "DBSnapshot" xml) DBSnapshot.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_snapshot (fun f ->
               Aws.Query.Pair ("DBSnapshot", DBSnapshot.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_snapshot (fun f ->
               "DBSnapshot", DBSnapshot.to_json f)
         ])

  let of_json j =
    { d_b_snapshot =
        Aws.Util.option_map (Aws.Json.lookup j "DBSnapshot") DBSnapshot.of_json
    }
end

module DBInstanceList = struct
  type t = DBInstance.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map DBInstance.parse (Aws.Xml.members "DBInstance" xml))

  let to_query v = Aws.Query.to_query_list DBInstance.to_query v

  let to_json v = `List (List.map DBInstance.to_json v)

  let of_json j = Aws.Json.to_list DBInstance.of_json j
end

module DBInstanceMessage = struct
  type t =
    { marker : String.t option
    ; d_b_instances : DBInstanceList.t
    }

  let make ?marker ?(d_b_instances = []) () = { marker; d_b_instances }

  let parse xml =
    Some
      { marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; d_b_instances =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "DBInstances" xml) DBInstanceList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("DBInstances.member", DBInstanceList.to_query v.d_b_instances))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("DBInstances", DBInstanceList.to_json v.d_b_instances)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ])

  let of_json j =
    { marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; d_b_instances =
        DBInstanceList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBInstances"))
    }
end

module InvalidEventSubscriptionStateFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module OptionGroupAlreadyExistsFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module GlobalClusterNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DeleteEventSubscriptionResult = struct
  type t = { event_subscription : EventSubscription.t option }

  let make ?event_subscription () = { event_subscription }

  let parse xml =
    Some
      { event_subscription =
          Aws.Util.option_bind
            (Aws.Xml.member "EventSubscription" xml)
            EventSubscription.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.event_subscription (fun f ->
               Aws.Query.Pair ("EventSubscription", EventSubscription.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.event_subscription (fun f ->
               "EventSubscription", EventSubscription.to_json f)
         ])

  let of_json j =
    { event_subscription =
        Aws.Util.option_map
          (Aws.Json.lookup j "EventSubscription")
          EventSubscription.of_json
    }
end

module OptionsConflictsWith = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "OptionConflictName" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module OptionVersion = struct
  type t =
    { version : String.t option
    ; is_default : Boolean.t option
    }

  let make ?version ?is_default () = { version; is_default }

  let parse xml =
    Some
      { version = Aws.Util.option_bind (Aws.Xml.member "Version" xml) String.parse
      ; is_default = Aws.Util.option_bind (Aws.Xml.member "IsDefault" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.is_default (fun f ->
               Aws.Query.Pair ("IsDefault", Boolean.to_query f))
         ; Aws.Util.option_map v.version (fun f ->
               Aws.Query.Pair ("Version", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.is_default (fun f -> "IsDefault", Boolean.to_json f)
         ; Aws.Util.option_map v.version (fun f -> "Version", String.to_json f)
         ])

  let of_json j =
    { version = Aws.Util.option_map (Aws.Json.lookup j "Version") String.of_json
    ; is_default = Aws.Util.option_map (Aws.Json.lookup j "IsDefault") Boolean.of_json
    }
end

module OptionGroupOptionVersionsList = struct
  type t = OptionVersion.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map OptionVersion.parse (Aws.Xml.members "OptionVersion" xml))

  let to_query v = Aws.Query.to_query_list OptionVersion.to_query v

  let to_json v = `List (List.map OptionVersion.to_json v)

  let of_json j = Aws.Json.to_list OptionVersion.of_json j
end

module MinimumEngineVersionPerAllowedValueList = struct
  type t = MinimumEngineVersionPerAllowedValue.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         MinimumEngineVersionPerAllowedValue.parse
         (Aws.Xml.members "MinimumEngineVersionPerAllowedValue" xml))

  let to_query v = Aws.Query.to_query_list MinimumEngineVersionPerAllowedValue.to_query v

  let to_json v = `List (List.map MinimumEngineVersionPerAllowedValue.to_json v)

  let of_json j = Aws.Json.to_list MinimumEngineVersionPerAllowedValue.of_json j
end

module OptionGroupOptionSetting = struct
  type t =
    { setting_name : String.t option
    ; setting_description : String.t option
    ; default_value : String.t option
    ; apply_type : String.t option
    ; allowed_values : String.t option
    ; is_modifiable : Boolean.t option
    ; is_required : Boolean.t option
    ; minimum_engine_version_per_allowed_value : MinimumEngineVersionPerAllowedValueList.t
    }

  let make
      ?setting_name
      ?setting_description
      ?default_value
      ?apply_type
      ?allowed_values
      ?is_modifiable
      ?is_required
      ?(minimum_engine_version_per_allowed_value = [])
      () =
    { setting_name
    ; setting_description
    ; default_value
    ; apply_type
    ; allowed_values
    ; is_modifiable
    ; is_required
    ; minimum_engine_version_per_allowed_value
    }

  let parse xml =
    Some
      { setting_name =
          Aws.Util.option_bind (Aws.Xml.member "SettingName" xml) String.parse
      ; setting_description =
          Aws.Util.option_bind (Aws.Xml.member "SettingDescription" xml) String.parse
      ; default_value =
          Aws.Util.option_bind (Aws.Xml.member "DefaultValue" xml) String.parse
      ; apply_type = Aws.Util.option_bind (Aws.Xml.member "ApplyType" xml) String.parse
      ; allowed_values =
          Aws.Util.option_bind (Aws.Xml.member "AllowedValues" xml) String.parse
      ; is_modifiable =
          Aws.Util.option_bind (Aws.Xml.member "IsModifiable" xml) Boolean.parse
      ; is_required = Aws.Util.option_bind (Aws.Xml.member "IsRequired" xml) Boolean.parse
      ; minimum_engine_version_per_allowed_value =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "MinimumEngineVersionPerAllowedValue" xml)
               MinimumEngineVersionPerAllowedValueList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "MinimumEngineVersionPerAllowedValue.member"
                , MinimumEngineVersionPerAllowedValueList.to_query
                    v.minimum_engine_version_per_allowed_value ))
         ; Aws.Util.option_map v.is_required (fun f ->
               Aws.Query.Pair ("IsRequired", Boolean.to_query f))
         ; Aws.Util.option_map v.is_modifiable (fun f ->
               Aws.Query.Pair ("IsModifiable", Boolean.to_query f))
         ; Aws.Util.option_map v.allowed_values (fun f ->
               Aws.Query.Pair ("AllowedValues", String.to_query f))
         ; Aws.Util.option_map v.apply_type (fun f ->
               Aws.Query.Pair ("ApplyType", String.to_query f))
         ; Aws.Util.option_map v.default_value (fun f ->
               Aws.Query.Pair ("DefaultValue", String.to_query f))
         ; Aws.Util.option_map v.setting_description (fun f ->
               Aws.Query.Pair ("SettingDescription", String.to_query f))
         ; Aws.Util.option_map v.setting_name (fun f ->
               Aws.Query.Pair ("SettingName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "MinimumEngineVersionPerAllowedValue"
             , MinimumEngineVersionPerAllowedValueList.to_json
                 v.minimum_engine_version_per_allowed_value )
         ; Aws.Util.option_map v.is_required (fun f -> "IsRequired", Boolean.to_json f)
         ; Aws.Util.option_map v.is_modifiable (fun f ->
               "IsModifiable", Boolean.to_json f)
         ; Aws.Util.option_map v.allowed_values (fun f ->
               "AllowedValues", String.to_json f)
         ; Aws.Util.option_map v.apply_type (fun f -> "ApplyType", String.to_json f)
         ; Aws.Util.option_map v.default_value (fun f -> "DefaultValue", String.to_json f)
         ; Aws.Util.option_map v.setting_description (fun f ->
               "SettingDescription", String.to_json f)
         ; Aws.Util.option_map v.setting_name (fun f -> "SettingName", String.to_json f)
         ])

  let of_json j =
    { setting_name = Aws.Util.option_map (Aws.Json.lookup j "SettingName") String.of_json
    ; setting_description =
        Aws.Util.option_map (Aws.Json.lookup j "SettingDescription") String.of_json
    ; default_value =
        Aws.Util.option_map (Aws.Json.lookup j "DefaultValue") String.of_json
    ; apply_type = Aws.Util.option_map (Aws.Json.lookup j "ApplyType") String.of_json
    ; allowed_values =
        Aws.Util.option_map (Aws.Json.lookup j "AllowedValues") String.of_json
    ; is_modifiable =
        Aws.Util.option_map (Aws.Json.lookup j "IsModifiable") Boolean.of_json
    ; is_required = Aws.Util.option_map (Aws.Json.lookup j "IsRequired") Boolean.of_json
    ; minimum_engine_version_per_allowed_value =
        MinimumEngineVersionPerAllowedValueList.of_json
          (Aws.Util.of_option_exn
             (Aws.Json.lookup j "MinimumEngineVersionPerAllowedValue"))
    }
end

module OptionGroupOptionSettingsList = struct
  type t = OptionGroupOptionSetting.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         OptionGroupOptionSetting.parse
         (Aws.Xml.members "OptionGroupOptionSetting" xml))

  let to_query v = Aws.Query.to_query_list OptionGroupOptionSetting.to_query v

  let to_json v = `List (List.map OptionGroupOptionSetting.to_json v)

  let of_json j = Aws.Json.to_list OptionGroupOptionSetting.of_json j
end

module OptionGroupOption = struct
  type t =
    { name : String.t option
    ; description : String.t option
    ; engine_name : String.t option
    ; major_engine_version : String.t option
    ; minimum_required_minor_engine_version : String.t option
    ; port_required : Boolean.t option
    ; default_port : Integer.t option
    ; options_depended_on : OptionsDependedOn.t
    ; options_conflicts_with : OptionsConflictsWith.t
    ; persistent : Boolean.t option
    ; permanent : Boolean.t option
    ; requires_auto_minor_engine_version_upgrade : Boolean.t option
    ; vpc_only : Boolean.t option
    ; supports_option_version_downgrade : Boolean.t option
    ; option_group_option_settings : OptionGroupOptionSettingsList.t
    ; option_group_option_versions : OptionGroupOptionVersionsList.t
    }

  let make
      ?name
      ?description
      ?engine_name
      ?major_engine_version
      ?minimum_required_minor_engine_version
      ?port_required
      ?default_port
      ?(options_depended_on = [])
      ?(options_conflicts_with = [])
      ?persistent
      ?permanent
      ?requires_auto_minor_engine_version_upgrade
      ?vpc_only
      ?supports_option_version_downgrade
      ?(option_group_option_settings = [])
      ?(option_group_option_versions = [])
      () =
    { name
    ; description
    ; engine_name
    ; major_engine_version
    ; minimum_required_minor_engine_version
    ; port_required
    ; default_port
    ; options_depended_on
    ; options_conflicts_with
    ; persistent
    ; permanent
    ; requires_auto_minor_engine_version_upgrade
    ; vpc_only
    ; supports_option_version_downgrade
    ; option_group_option_settings
    ; option_group_option_versions
    }

  let parse xml =
    Some
      { name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; engine_name = Aws.Util.option_bind (Aws.Xml.member "EngineName" xml) String.parse
      ; major_engine_version =
          Aws.Util.option_bind (Aws.Xml.member "MajorEngineVersion" xml) String.parse
      ; minimum_required_minor_engine_version =
          Aws.Util.option_bind
            (Aws.Xml.member "MinimumRequiredMinorEngineVersion" xml)
            String.parse
      ; port_required =
          Aws.Util.option_bind (Aws.Xml.member "PortRequired" xml) Boolean.parse
      ; default_port =
          Aws.Util.option_bind (Aws.Xml.member "DefaultPort" xml) Integer.parse
      ; options_depended_on =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "OptionsDependedOn" xml)
               OptionsDependedOn.parse)
      ; options_conflicts_with =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "OptionsConflictsWith" xml)
               OptionsConflictsWith.parse)
      ; persistent = Aws.Util.option_bind (Aws.Xml.member "Persistent" xml) Boolean.parse
      ; permanent = Aws.Util.option_bind (Aws.Xml.member "Permanent" xml) Boolean.parse
      ; requires_auto_minor_engine_version_upgrade =
          Aws.Util.option_bind
            (Aws.Xml.member "RequiresAutoMinorEngineVersionUpgrade" xml)
            Boolean.parse
      ; vpc_only = Aws.Util.option_bind (Aws.Xml.member "VpcOnly" xml) Boolean.parse
      ; supports_option_version_downgrade =
          Aws.Util.option_bind
            (Aws.Xml.member "SupportsOptionVersionDowngrade" xml)
            Boolean.parse
      ; option_group_option_settings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "OptionGroupOptionSettings" xml)
               OptionGroupOptionSettingsList.parse)
      ; option_group_option_versions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "OptionGroupOptionVersions" xml)
               OptionGroupOptionVersionsList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "OptionGroupOptionVersions.member"
                , OptionGroupOptionVersionsList.to_query v.option_group_option_versions ))
         ; Some
             (Aws.Query.Pair
                ( "OptionGroupOptionSettings.member"
                , OptionGroupOptionSettingsList.to_query v.option_group_option_settings ))
         ; Aws.Util.option_map v.supports_option_version_downgrade (fun f ->
               Aws.Query.Pair ("SupportsOptionVersionDowngrade", Boolean.to_query f))
         ; Aws.Util.option_map v.vpc_only (fun f ->
               Aws.Query.Pair ("VpcOnly", Boolean.to_query f))
         ; Aws.Util.option_map v.requires_auto_minor_engine_version_upgrade (fun f ->
               Aws.Query.Pair ("RequiresAutoMinorEngineVersionUpgrade", Boolean.to_query f))
         ; Aws.Util.option_map v.permanent (fun f ->
               Aws.Query.Pair ("Permanent", Boolean.to_query f))
         ; Aws.Util.option_map v.persistent (fun f ->
               Aws.Query.Pair ("Persistent", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "OptionsConflictsWith.member"
                , OptionsConflictsWith.to_query v.options_conflicts_with ))
         ; Some
             (Aws.Query.Pair
                ( "OptionsDependedOn.member"
                , OptionsDependedOn.to_query v.options_depended_on ))
         ; Aws.Util.option_map v.default_port (fun f ->
               Aws.Query.Pair ("DefaultPort", Integer.to_query f))
         ; Aws.Util.option_map v.port_required (fun f ->
               Aws.Query.Pair ("PortRequired", Boolean.to_query f))
         ; Aws.Util.option_map v.minimum_required_minor_engine_version (fun f ->
               Aws.Query.Pair ("MinimumRequiredMinorEngineVersion", String.to_query f))
         ; Aws.Util.option_map v.major_engine_version (fun f ->
               Aws.Query.Pair ("MajorEngineVersion", String.to_query f))
         ; Aws.Util.option_map v.engine_name (fun f ->
               Aws.Query.Pair ("EngineName", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "OptionGroupOptionVersions"
             , OptionGroupOptionVersionsList.to_json v.option_group_option_versions )
         ; Some
             ( "OptionGroupOptionSettings"
             , OptionGroupOptionSettingsList.to_json v.option_group_option_settings )
         ; Aws.Util.option_map v.supports_option_version_downgrade (fun f ->
               "SupportsOptionVersionDowngrade", Boolean.to_json f)
         ; Aws.Util.option_map v.vpc_only (fun f -> "VpcOnly", Boolean.to_json f)
         ; Aws.Util.option_map v.requires_auto_minor_engine_version_upgrade (fun f ->
               "RequiresAutoMinorEngineVersionUpgrade", Boolean.to_json f)
         ; Aws.Util.option_map v.permanent (fun f -> "Permanent", Boolean.to_json f)
         ; Aws.Util.option_map v.persistent (fun f -> "Persistent", Boolean.to_json f)
         ; Some
             ( "OptionsConflictsWith"
             , OptionsConflictsWith.to_json v.options_conflicts_with )
         ; Some ("OptionsDependedOn", OptionsDependedOn.to_json v.options_depended_on)
         ; Aws.Util.option_map v.default_port (fun f -> "DefaultPort", Integer.to_json f)
         ; Aws.Util.option_map v.port_required (fun f ->
               "PortRequired", Boolean.to_json f)
         ; Aws.Util.option_map v.minimum_required_minor_engine_version (fun f ->
               "MinimumRequiredMinorEngineVersion", String.to_json f)
         ; Aws.Util.option_map v.major_engine_version (fun f ->
               "MajorEngineVersion", String.to_json f)
         ; Aws.Util.option_map v.engine_name (fun f -> "EngineName", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ])

  let of_json j =
    { name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; engine_name = Aws.Util.option_map (Aws.Json.lookup j "EngineName") String.of_json
    ; major_engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "MajorEngineVersion") String.of_json
    ; minimum_required_minor_engine_version =
        Aws.Util.option_map
          (Aws.Json.lookup j "MinimumRequiredMinorEngineVersion")
          String.of_json
    ; port_required =
        Aws.Util.option_map (Aws.Json.lookup j "PortRequired") Boolean.of_json
    ; default_port = Aws.Util.option_map (Aws.Json.lookup j "DefaultPort") Integer.of_json
    ; options_depended_on =
        OptionsDependedOn.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "OptionsDependedOn"))
    ; options_conflicts_with =
        OptionsConflictsWith.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "OptionsConflictsWith"))
    ; persistent = Aws.Util.option_map (Aws.Json.lookup j "Persistent") Boolean.of_json
    ; permanent = Aws.Util.option_map (Aws.Json.lookup j "Permanent") Boolean.of_json
    ; requires_auto_minor_engine_version_upgrade =
        Aws.Util.option_map
          (Aws.Json.lookup j "RequiresAutoMinorEngineVersionUpgrade")
          Boolean.of_json
    ; vpc_only = Aws.Util.option_map (Aws.Json.lookup j "VpcOnly") Boolean.of_json
    ; supports_option_version_downgrade =
        Aws.Util.option_map
          (Aws.Json.lookup j "SupportsOptionVersionDowngrade")
          Boolean.of_json
    ; option_group_option_settings =
        OptionGroupOptionSettingsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "OptionGroupOptionSettings"))
    ; option_group_option_versions =
        OptionGroupOptionVersionsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "OptionGroupOptionVersions"))
    }
end

module OptionGroupOptionsList = struct
  type t = OptionGroupOption.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map OptionGroupOption.parse (Aws.Xml.members "OptionGroupOption" xml))

  let to_query v = Aws.Query.to_query_list OptionGroupOption.to_query v

  let to_json v = `List (List.map OptionGroupOption.to_json v)

  let of_json j = Aws.Json.to_list OptionGroupOption.of_json j
end

module DescribeDBProxyTargetGroupsRequest = struct
  type t =
    { d_b_proxy_name : String.t
    ; target_group_name : String.t option
    ; filters : FilterList.t
    ; marker : String.t option
    ; max_records : Integer.t option
    }

  let make ~d_b_proxy_name ?target_group_name ?(filters = []) ?marker ?max_records () =
    { d_b_proxy_name; target_group_name; filters; marker; max_records }

  let parse xml =
    Some
      { d_b_proxy_name =
          Aws.Xml.required
            "DBProxyName"
            (Aws.Util.option_bind (Aws.Xml.member "DBProxyName" xml) String.parse)
      ; target_group_name =
          Aws.Util.option_bind (Aws.Xml.member "TargetGroupName" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.target_group_name (fun f ->
               Aws.Query.Pair ("TargetGroupName", String.to_query f))
         ; Some (Aws.Query.Pair ("DBProxyName", String.to_query v.d_b_proxy_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.target_group_name (fun f ->
               "TargetGroupName", String.to_json f)
         ; Some ("DBProxyName", String.to_json v.d_b_proxy_name)
         ])

  let of_json j =
    { d_b_proxy_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBProxyName"))
    ; target_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "TargetGroupName") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    }
end

module CreateCustomAvailabilityZoneResult = struct
  type t = { custom_availability_zone : CustomAvailabilityZone.t option }

  let make ?custom_availability_zone () = { custom_availability_zone }

  let parse xml =
    Some
      { custom_availability_zone =
          Aws.Util.option_bind
            (Aws.Xml.member "CustomAvailabilityZone" xml)
            CustomAvailabilityZone.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.custom_availability_zone (fun f ->
               Aws.Query.Pair ("CustomAvailabilityZone", CustomAvailabilityZone.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.custom_availability_zone (fun f ->
               "CustomAvailabilityZone", CustomAvailabilityZone.to_json f)
         ])

  let of_json j =
    { custom_availability_zone =
        Aws.Util.option_map
          (Aws.Json.lookup j "CustomAvailabilityZone")
          CustomAvailabilityZone.of_json
    }
end

module StopDBClusterResult = struct
  type t = { d_b_cluster : DBCluster.t option }

  let make ?d_b_cluster () = { d_b_cluster }

  let parse xml =
    Some
      { d_b_cluster =
          Aws.Util.option_bind (Aws.Xml.member "DBCluster" xml) DBCluster.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster (fun f ->
               Aws.Query.Pair ("DBCluster", DBCluster.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster (fun f -> "DBCluster", DBCluster.to_json f) ])

  let of_json j =
    { d_b_cluster = Aws.Util.option_map (Aws.Json.lookup j "DBCluster") DBCluster.of_json
    }
end

module DescribeDBInstancesMessage = struct
  type t =
    { d_b_instance_identifier : String.t option
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    }

  let make ?d_b_instance_identifier ?(filters = []) ?max_records ?marker () =
    { d_b_instance_identifier; filters; max_records; marker }

  let parse xml =
    Some
      { d_b_instance_identifier =
          Aws.Util.option_bind (Aws.Xml.member "DBInstanceIdentifier" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.d_b_instance_identifier (fun f ->
               Aws.Query.Pair ("DBInstanceIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.d_b_instance_identifier (fun f ->
               "DBInstanceIdentifier", String.to_json f)
         ])

  let of_json j =
    { d_b_instance_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstanceIdentifier") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module RestoreDBClusterFromSnapshotMessage = struct
  type t =
    { availability_zones : AvailabilityZones.t
    ; d_b_cluster_identifier : String.t
    ; snapshot_identifier : String.t
    ; engine : String.t
    ; engine_version : String.t option
    ; port : Integer.t option
    ; d_b_subnet_group_name : String.t option
    ; database_name : String.t option
    ; option_group_name : String.t option
    ; vpc_security_group_ids : VpcSecurityGroupIdList.t
    ; tags : TagList.t
    ; kms_key_id : String.t option
    ; enable_i_a_m_database_authentication : Boolean.t option
    ; backtrack_window : Long.t option
    ; enable_cloudwatch_logs_exports : LogTypeList.t
    ; engine_mode : String.t option
    ; scaling_configuration : ScalingConfiguration.t option
    ; d_b_cluster_parameter_group_name : String.t option
    ; deletion_protection : Boolean.t option
    ; copy_tags_to_snapshot : Boolean.t option
    ; domain : String.t option
    ; domain_i_a_m_role_name : String.t option
    }

  let make
      ?(availability_zones = [])
      ~d_b_cluster_identifier
      ~snapshot_identifier
      ~engine
      ?engine_version
      ?port
      ?d_b_subnet_group_name
      ?database_name
      ?option_group_name
      ?(vpc_security_group_ids = [])
      ?(tags = [])
      ?kms_key_id
      ?enable_i_a_m_database_authentication
      ?backtrack_window
      ?(enable_cloudwatch_logs_exports = [])
      ?engine_mode
      ?scaling_configuration
      ?d_b_cluster_parameter_group_name
      ?deletion_protection
      ?copy_tags_to_snapshot
      ?domain
      ?domain_i_a_m_role_name
      () =
    { availability_zones
    ; d_b_cluster_identifier
    ; snapshot_identifier
    ; engine
    ; engine_version
    ; port
    ; d_b_subnet_group_name
    ; database_name
    ; option_group_name
    ; vpc_security_group_ids
    ; tags
    ; kms_key_id
    ; enable_i_a_m_database_authentication
    ; backtrack_window
    ; enable_cloudwatch_logs_exports
    ; engine_mode
    ; scaling_configuration
    ; d_b_cluster_parameter_group_name
    ; deletion_protection
    ; copy_tags_to_snapshot
    ; domain
    ; domain_i_a_m_role_name
    }

  let parse xml =
    Some
      { availability_zones =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AvailabilityZones" xml)
               AvailabilityZones.parse)
      ; d_b_cluster_identifier =
          Aws.Xml.required
            "DBClusterIdentifier"
            (Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse)
      ; snapshot_identifier =
          Aws.Xml.required
            "SnapshotIdentifier"
            (Aws.Util.option_bind (Aws.Xml.member "SnapshotIdentifier" xml) String.parse)
      ; engine =
          Aws.Xml.required
            "Engine"
            (Aws.Util.option_bind (Aws.Xml.member "Engine" xml) String.parse)
      ; engine_version =
          Aws.Util.option_bind (Aws.Xml.member "EngineVersion" xml) String.parse
      ; port = Aws.Util.option_bind (Aws.Xml.member "Port" xml) Integer.parse
      ; d_b_subnet_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBSubnetGroupName" xml) String.parse
      ; database_name =
          Aws.Util.option_bind (Aws.Xml.member "DatabaseName" xml) String.parse
      ; option_group_name =
          Aws.Util.option_bind (Aws.Xml.member "OptionGroupName" xml) String.parse
      ; vpc_security_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "VpcSecurityGroupIds" xml)
               VpcSecurityGroupIdList.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "KmsKeyId" xml) String.parse
      ; enable_i_a_m_database_authentication =
          Aws.Util.option_bind
            (Aws.Xml.member "EnableIAMDatabaseAuthentication" xml)
            Boolean.parse
      ; backtrack_window =
          Aws.Util.option_bind (Aws.Xml.member "BacktrackWindow" xml) Long.parse
      ; enable_cloudwatch_logs_exports =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "EnableCloudwatchLogsExports" xml)
               LogTypeList.parse)
      ; engine_mode = Aws.Util.option_bind (Aws.Xml.member "EngineMode" xml) String.parse
      ; scaling_configuration =
          Aws.Util.option_bind
            (Aws.Xml.member "ScalingConfiguration" xml)
            ScalingConfiguration.parse
      ; d_b_cluster_parameter_group_name =
          Aws.Util.option_bind
            (Aws.Xml.member "DBClusterParameterGroupName" xml)
            String.parse
      ; deletion_protection =
          Aws.Util.option_bind (Aws.Xml.member "DeletionProtection" xml) Boolean.parse
      ; copy_tags_to_snapshot =
          Aws.Util.option_bind (Aws.Xml.member "CopyTagsToSnapshot" xml) Boolean.parse
      ; domain = Aws.Util.option_bind (Aws.Xml.member "Domain" xml) String.parse
      ; domain_i_a_m_role_name =
          Aws.Util.option_bind (Aws.Xml.member "DomainIAMRoleName" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.domain_i_a_m_role_name (fun f ->
               Aws.Query.Pair ("DomainIAMRoleName", String.to_query f))
         ; Aws.Util.option_map v.domain (fun f ->
               Aws.Query.Pair ("Domain", String.to_query f))
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               Aws.Query.Pair ("CopyTagsToSnapshot", Boolean.to_query f))
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               Aws.Query.Pair ("DeletionProtection", Boolean.to_query f))
         ; Aws.Util.option_map v.d_b_cluster_parameter_group_name (fun f ->
               Aws.Query.Pair ("DBClusterParameterGroupName", String.to_query f))
         ; Aws.Util.option_map v.scaling_configuration (fun f ->
               Aws.Query.Pair ("ScalingConfiguration", ScalingConfiguration.to_query f))
         ; Aws.Util.option_map v.engine_mode (fun f ->
               Aws.Query.Pair ("EngineMode", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "EnableCloudwatchLogsExports.member"
                , LogTypeList.to_query v.enable_cloudwatch_logs_exports ))
         ; Aws.Util.option_map v.backtrack_window (fun f ->
               Aws.Query.Pair ("BacktrackWindow", Long.to_query f))
         ; Aws.Util.option_map v.enable_i_a_m_database_authentication (fun f ->
               Aws.Query.Pair ("EnableIAMDatabaseAuthentication", Boolean.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Some
             (Aws.Query.Pair
                ( "VpcSecurityGroupIds.member"
                , VpcSecurityGroupIdList.to_query v.vpc_security_group_ids ))
         ; Aws.Util.option_map v.option_group_name (fun f ->
               Aws.Query.Pair ("OptionGroupName", String.to_query f))
         ; Aws.Util.option_map v.database_name (fun f ->
               Aws.Query.Pair ("DatabaseName", String.to_query f))
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               Aws.Query.Pair ("DBSubnetGroupName", String.to_query f))
         ; Aws.Util.option_map v.port (fun f ->
               Aws.Query.Pair ("Port", Integer.to_query f))
         ; Aws.Util.option_map v.engine_version (fun f ->
               Aws.Query.Pair ("EngineVersion", String.to_query f))
         ; Some (Aws.Query.Pair ("Engine", String.to_query v.engine))
         ; Some
             (Aws.Query.Pair ("SnapshotIdentifier", String.to_query v.snapshot_identifier))
         ; Some
             (Aws.Query.Pair
                ("DBClusterIdentifier", String.to_query v.d_b_cluster_identifier))
         ; Some
             (Aws.Query.Pair
                ( "AvailabilityZones.member"
                , AvailabilityZones.to_query v.availability_zones ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.domain_i_a_m_role_name (fun f ->
               "DomainIAMRoleName", String.to_json f)
         ; Aws.Util.option_map v.domain (fun f -> "Domain", String.to_json f)
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               "CopyTagsToSnapshot", Boolean.to_json f)
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               "DeletionProtection", Boolean.to_json f)
         ; Aws.Util.option_map v.d_b_cluster_parameter_group_name (fun f ->
               "DBClusterParameterGroupName", String.to_json f)
         ; Aws.Util.option_map v.scaling_configuration (fun f ->
               "ScalingConfiguration", ScalingConfiguration.to_json f)
         ; Aws.Util.option_map v.engine_mode (fun f -> "EngineMode", String.to_json f)
         ; Some
             ( "EnableCloudwatchLogsExports"
             , LogTypeList.to_json v.enable_cloudwatch_logs_exports )
         ; Aws.Util.option_map v.backtrack_window (fun f ->
               "BacktrackWindow", Long.to_json f)
         ; Aws.Util.option_map v.enable_i_a_m_database_authentication (fun f ->
               "EnableIAMDatabaseAuthentication", Boolean.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "KmsKeyId", String.to_json f)
         ; Some ("Tags", TagList.to_json v.tags)
         ; Some
             ( "VpcSecurityGroupIds"
             , VpcSecurityGroupIdList.to_json v.vpc_security_group_ids )
         ; Aws.Util.option_map v.option_group_name (fun f ->
               "OptionGroupName", String.to_json f)
         ; Aws.Util.option_map v.database_name (fun f -> "DatabaseName", String.to_json f)
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               "DBSubnetGroupName", String.to_json f)
         ; Aws.Util.option_map v.port (fun f -> "Port", Integer.to_json f)
         ; Aws.Util.option_map v.engine_version (fun f ->
               "EngineVersion", String.to_json f)
         ; Some ("Engine", String.to_json v.engine)
         ; Some ("SnapshotIdentifier", String.to_json v.snapshot_identifier)
         ; Some ("DBClusterIdentifier", String.to_json v.d_b_cluster_identifier)
         ; Some ("AvailabilityZones", AvailabilityZones.to_json v.availability_zones)
         ])

  let of_json j =
    { availability_zones =
        AvailabilityZones.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AvailabilityZones"))
    ; d_b_cluster_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterIdentifier"))
    ; snapshot_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SnapshotIdentifier"))
    ; engine = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Engine"))
    ; engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "EngineVersion") String.of_json
    ; port = Aws.Util.option_map (Aws.Json.lookup j "Port") Integer.of_json
    ; d_b_subnet_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBSubnetGroupName") String.of_json
    ; database_name =
        Aws.Util.option_map (Aws.Json.lookup j "DatabaseName") String.of_json
    ; option_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "OptionGroupName") String.of_json
    ; vpc_security_group_ids =
        VpcSecurityGroupIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcSecurityGroupIds"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "KmsKeyId") String.of_json
    ; enable_i_a_m_database_authentication =
        Aws.Util.option_map
          (Aws.Json.lookup j "EnableIAMDatabaseAuthentication")
          Boolean.of_json
    ; backtrack_window =
        Aws.Util.option_map (Aws.Json.lookup j "BacktrackWindow") Long.of_json
    ; enable_cloudwatch_logs_exports =
        LogTypeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "EnableCloudwatchLogsExports"))
    ; engine_mode = Aws.Util.option_map (Aws.Json.lookup j "EngineMode") String.of_json
    ; scaling_configuration =
        Aws.Util.option_map
          (Aws.Json.lookup j "ScalingConfiguration")
          ScalingConfiguration.of_json
    ; d_b_cluster_parameter_group_name =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBClusterParameterGroupName")
          String.of_json
    ; deletion_protection =
        Aws.Util.option_map (Aws.Json.lookup j "DeletionProtection") Boolean.of_json
    ; copy_tags_to_snapshot =
        Aws.Util.option_map (Aws.Json.lookup j "CopyTagsToSnapshot") Boolean.of_json
    ; domain = Aws.Util.option_map (Aws.Json.lookup j "Domain") String.of_json
    ; domain_i_a_m_role_name =
        Aws.Util.option_map (Aws.Json.lookup j "DomainIAMRoleName") String.of_json
    }
end

module RestoreDBInstanceFromDBSnapshotResult = struct
  type t = { d_b_instance : DBInstance.t option }

  let make ?d_b_instance () = { d_b_instance }

  let parse xml =
    Some
      { d_b_instance =
          Aws.Util.option_bind (Aws.Xml.member "DBInstance" xml) DBInstance.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_instance (fun f ->
               Aws.Query.Pair ("DBInstance", DBInstance.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_instance (fun f ->
               "DBInstance", DBInstance.to_json f)
         ])

  let of_json j =
    { d_b_instance =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstance") DBInstance.of_json
    }
end

module RestoreDBClusterFromSnapshotResult = struct
  type t = { d_b_cluster : DBCluster.t option }

  let make ?d_b_cluster () = { d_b_cluster }

  let parse xml =
    Some
      { d_b_cluster =
          Aws.Util.option_bind (Aws.Xml.member "DBCluster" xml) DBCluster.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster (fun f ->
               Aws.Query.Pair ("DBCluster", DBCluster.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster (fun f -> "DBCluster", DBCluster.to_json f) ])

  let of_json j =
    { d_b_cluster = Aws.Util.option_map (Aws.Json.lookup j "DBCluster") DBCluster.of_json
    }
end

module StartDBInstanceMessage = struct
  type t = { d_b_instance_identifier : String.t }

  let make ~d_b_instance_identifier () = { d_b_instance_identifier }

  let parse xml =
    Some
      { d_b_instance_identifier =
          Aws.Xml.required
            "DBInstanceIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBInstanceIdentifier" xml)
               String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("DBInstanceIdentifier", String.to_query v.d_b_instance_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("DBInstanceIdentifier", String.to_json v.d_b_instance_identifier) ])

  let of_json j =
    { d_b_instance_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBInstanceIdentifier"))
    }
end

module CharacterSet = struct
  type t =
    { character_set_name : String.t option
    ; character_set_description : String.t option
    }

  let make ?character_set_name ?character_set_description () =
    { character_set_name; character_set_description }

  let parse xml =
    Some
      { character_set_name =
          Aws.Util.option_bind (Aws.Xml.member "CharacterSetName" xml) String.parse
      ; character_set_description =
          Aws.Util.option_bind (Aws.Xml.member "CharacterSetDescription" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.character_set_description (fun f ->
               Aws.Query.Pair ("CharacterSetDescription", String.to_query f))
         ; Aws.Util.option_map v.character_set_name (fun f ->
               Aws.Query.Pair ("CharacterSetName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.character_set_description (fun f ->
               "CharacterSetDescription", String.to_json f)
         ; Aws.Util.option_map v.character_set_name (fun f ->
               "CharacterSetName", String.to_json f)
         ])

  let of_json j =
    { character_set_name =
        Aws.Util.option_map (Aws.Json.lookup j "CharacterSetName") String.of_json
    ; character_set_description =
        Aws.Util.option_map (Aws.Json.lookup j "CharacterSetDescription") String.of_json
    }
end

module SupportedCharacterSetsList = struct
  type t = CharacterSet.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map CharacterSet.parse (Aws.Xml.members "CharacterSet" xml))

  let to_query v = Aws.Query.to_query_list CharacterSet.to_query v

  let to_json v = `List (List.map CharacterSet.to_json v)

  let of_json j = Aws.Json.to_list CharacterSet.of_json j
end

module CopyDBClusterParameterGroupMessage = struct
  type t =
    { source_d_b_cluster_parameter_group_identifier : String.t
    ; target_d_b_cluster_parameter_group_identifier : String.t
    ; target_d_b_cluster_parameter_group_description : String.t
    ; tags : TagList.t
    }

  let make
      ~source_d_b_cluster_parameter_group_identifier
      ~target_d_b_cluster_parameter_group_identifier
      ~target_d_b_cluster_parameter_group_description
      ?(tags = [])
      () =
    { source_d_b_cluster_parameter_group_identifier
    ; target_d_b_cluster_parameter_group_identifier
    ; target_d_b_cluster_parameter_group_description
    ; tags
    }

  let parse xml =
    Some
      { source_d_b_cluster_parameter_group_identifier =
          Aws.Xml.required
            "SourceDBClusterParameterGroupIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "SourceDBClusterParameterGroupIdentifier" xml)
               String.parse)
      ; target_d_b_cluster_parameter_group_identifier =
          Aws.Xml.required
            "TargetDBClusterParameterGroupIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "TargetDBClusterParameterGroupIdentifier" xml)
               String.parse)
      ; target_d_b_cluster_parameter_group_description =
          Aws.Xml.required
            "TargetDBClusterParameterGroupDescription"
            (Aws.Util.option_bind
               (Aws.Xml.member "TargetDBClusterParameterGroupDescription" xml)
               String.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Some
             (Aws.Query.Pair
                ( "TargetDBClusterParameterGroupDescription"
                , String.to_query v.target_d_b_cluster_parameter_group_description ))
         ; Some
             (Aws.Query.Pair
                ( "TargetDBClusterParameterGroupIdentifier"
                , String.to_query v.target_d_b_cluster_parameter_group_identifier ))
         ; Some
             (Aws.Query.Pair
                ( "SourceDBClusterParameterGroupIdentifier"
                , String.to_query v.source_d_b_cluster_parameter_group_identifier ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tags", TagList.to_json v.tags)
         ; Some
             ( "TargetDBClusterParameterGroupDescription"
             , String.to_json v.target_d_b_cluster_parameter_group_description )
         ; Some
             ( "TargetDBClusterParameterGroupIdentifier"
             , String.to_json v.target_d_b_cluster_parameter_group_identifier )
         ; Some
             ( "SourceDBClusterParameterGroupIdentifier"
             , String.to_json v.source_d_b_cluster_parameter_group_identifier )
         ])

  let of_json j =
    { source_d_b_cluster_parameter_group_identifier =
        String.of_json
          (Aws.Util.of_option_exn
             (Aws.Json.lookup j "SourceDBClusterParameterGroupIdentifier"))
    ; target_d_b_cluster_parameter_group_identifier =
        String.of_json
          (Aws.Util.of_option_exn
             (Aws.Json.lookup j "TargetDBClusterParameterGroupIdentifier"))
    ; target_d_b_cluster_parameter_group_description =
        String.of_json
          (Aws.Util.of_option_exn
             (Aws.Json.lookup j "TargetDBClusterParameterGroupDescription"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    }
end

module CustomAvailabilityZoneAlreadyExistsFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DeleteDBParameterGroupMessage = struct
  type t = { d_b_parameter_group_name : String.t }

  let make ~d_b_parameter_group_name () = { d_b_parameter_group_name }

  let parse xml =
    Some
      { d_b_parameter_group_name =
          Aws.Xml.required
            "DBParameterGroupName"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBParameterGroupName" xml)
               String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("DBParameterGroupName", String.to_query v.d_b_parameter_group_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("DBParameterGroupName", String.to_json v.d_b_parameter_group_name) ])

  let of_json j =
    { d_b_parameter_group_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBParameterGroupName"))
    }
end

module DBSecurityGroupAlreadyExistsFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module CreateEventSubscriptionMessage = struct
  type t =
    { subscription_name : String.t
    ; sns_topic_arn : String.t
    ; source_type : String.t option
    ; event_categories : EventCategoriesList.t
    ; source_ids : SourceIdsList.t
    ; enabled : Boolean.t option
    ; tags : TagList.t
    }

  let make
      ~subscription_name
      ~sns_topic_arn
      ?source_type
      ?(event_categories = [])
      ?(source_ids = [])
      ?enabled
      ?(tags = [])
      () =
    { subscription_name
    ; sns_topic_arn
    ; source_type
    ; event_categories
    ; source_ids
    ; enabled
    ; tags
    }

  let parse xml =
    Some
      { subscription_name =
          Aws.Xml.required
            "SubscriptionName"
            (Aws.Util.option_bind (Aws.Xml.member "SubscriptionName" xml) String.parse)
      ; sns_topic_arn =
          Aws.Xml.required
            "SnsTopicArn"
            (Aws.Util.option_bind (Aws.Xml.member "SnsTopicArn" xml) String.parse)
      ; source_type = Aws.Util.option_bind (Aws.Xml.member "SourceType" xml) String.parse
      ; event_categories =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "EventCategories" xml)
               EventCategoriesList.parse)
      ; source_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "SourceIds" xml) SourceIdsList.parse)
      ; enabled = Aws.Util.option_bind (Aws.Xml.member "Enabled" xml) Boolean.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Aws.Util.option_map v.enabled (fun f ->
               Aws.Query.Pair ("Enabled", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("SourceIds.member", SourceIdsList.to_query v.source_ids))
         ; Some
             (Aws.Query.Pair
                ("EventCategories.member", EventCategoriesList.to_query v.event_categories))
         ; Aws.Util.option_map v.source_type (fun f ->
               Aws.Query.Pair ("SourceType", String.to_query f))
         ; Some (Aws.Query.Pair ("SnsTopicArn", String.to_query v.sns_topic_arn))
         ; Some (Aws.Query.Pair ("SubscriptionName", String.to_query v.subscription_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tags", TagList.to_json v.tags)
         ; Aws.Util.option_map v.enabled (fun f -> "Enabled", Boolean.to_json f)
         ; Some ("SourceIds", SourceIdsList.to_json v.source_ids)
         ; Some ("EventCategories", EventCategoriesList.to_json v.event_categories)
         ; Aws.Util.option_map v.source_type (fun f -> "SourceType", String.to_json f)
         ; Some ("SnsTopicArn", String.to_json v.sns_topic_arn)
         ; Some ("SubscriptionName", String.to_json v.subscription_name)
         ])

  let of_json j =
    { subscription_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SubscriptionName"))
    ; sns_topic_arn =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SnsTopicArn"))
    ; source_type = Aws.Util.option_map (Aws.Json.lookup j "SourceType") String.of_json
    ; event_categories =
        EventCategoriesList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "EventCategories"))
    ; source_ids =
        SourceIdsList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceIds"))
    ; enabled = Aws.Util.option_map (Aws.Json.lookup j "Enabled") Boolean.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    }
end

module UserAuthConfigInfo = struct
  type t =
    { description : String.t option
    ; user_name : String.t option
    ; auth_scheme : AuthScheme.t option
    ; secret_arn : String.t option
    ; i_a_m_auth : IAMAuthMode.t option
    }

  let make ?description ?user_name ?auth_scheme ?secret_arn ?i_a_m_auth () =
    { description; user_name; auth_scheme; secret_arn; i_a_m_auth }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; user_name = Aws.Util.option_bind (Aws.Xml.member "UserName" xml) String.parse
      ; auth_scheme =
          Aws.Util.option_bind (Aws.Xml.member "AuthScheme" xml) AuthScheme.parse
      ; secret_arn = Aws.Util.option_bind (Aws.Xml.member "SecretArn" xml) String.parse
      ; i_a_m_auth = Aws.Util.option_bind (Aws.Xml.member "IAMAuth" xml) IAMAuthMode.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.i_a_m_auth (fun f ->
               Aws.Query.Pair ("IAMAuth", IAMAuthMode.to_query f))
         ; Aws.Util.option_map v.secret_arn (fun f ->
               Aws.Query.Pair ("SecretArn", String.to_query f))
         ; Aws.Util.option_map v.auth_scheme (fun f ->
               Aws.Query.Pair ("AuthScheme", AuthScheme.to_query f))
         ; Aws.Util.option_map v.user_name (fun f ->
               Aws.Query.Pair ("UserName", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.i_a_m_auth (fun f -> "IAMAuth", IAMAuthMode.to_json f)
         ; Aws.Util.option_map v.secret_arn (fun f -> "SecretArn", String.to_json f)
         ; Aws.Util.option_map v.auth_scheme (fun f -> "AuthScheme", AuthScheme.to_json f)
         ; Aws.Util.option_map v.user_name (fun f -> "UserName", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; user_name = Aws.Util.option_map (Aws.Json.lookup j "UserName") String.of_json
    ; auth_scheme =
        Aws.Util.option_map (Aws.Json.lookup j "AuthScheme") AuthScheme.of_json
    ; secret_arn = Aws.Util.option_map (Aws.Json.lookup j "SecretArn") String.of_json
    ; i_a_m_auth = Aws.Util.option_map (Aws.Json.lookup j "IAMAuth") IAMAuthMode.of_json
    }
end

module UserAuthConfigInfoList = struct
  type t = UserAuthConfigInfo.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map UserAuthConfigInfo.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list UserAuthConfigInfo.to_query v

  let to_json v = `List (List.map UserAuthConfigInfo.to_json v)

  let of_json j = Aws.Json.to_list UserAuthConfigInfo.of_json j
end

module DBProxyStatus = struct
  type t =
    | Available
    | Modifying
    | Incompatible_network
    | Insufficient_resource_limits
    | Creating
    | Deleting
    | Suspended
    | Suspending
    | Reactivating

  let str_to_t =
    [ "reactivating", Reactivating
    ; "suspending", Suspending
    ; "suspended", Suspended
    ; "deleting", Deleting
    ; "creating", Creating
    ; "insufficient-resource-limits", Insufficient_resource_limits
    ; "incompatible-network", Incompatible_network
    ; "modifying", Modifying
    ; "available", Available
    ]

  let t_to_str =
    [ Reactivating, "reactivating"
    ; Suspending, "suspending"
    ; Suspended, "suspended"
    ; Deleting, "deleting"
    ; Creating, "creating"
    ; Insufficient_resource_limits, "insufficient-resource-limits"
    ; Incompatible_network, "incompatible-network"
    ; Modifying, "modifying"
    ; Available, "available"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DBProxy = struct
  type t =
    { d_b_proxy_name : String.t option
    ; d_b_proxy_arn : String.t option
    ; status : DBProxyStatus.t option
    ; engine_family : String.t option
    ; vpc_security_group_ids : StringList.t
    ; vpc_subnet_ids : StringList.t
    ; auth : UserAuthConfigInfoList.t
    ; role_arn : String.t option
    ; endpoint : String.t option
    ; require_t_l_s : Boolean.t option
    ; idle_client_timeout : Integer.t option
    ; debug_logging : Boolean.t option
    ; created_date : DateTime.t option
    ; updated_date : DateTime.t option
    }

  let make
      ?d_b_proxy_name
      ?d_b_proxy_arn
      ?status
      ?engine_family
      ?(vpc_security_group_ids = [])
      ?(vpc_subnet_ids = [])
      ?(auth = [])
      ?role_arn
      ?endpoint
      ?require_t_l_s
      ?idle_client_timeout
      ?debug_logging
      ?created_date
      ?updated_date
      () =
    { d_b_proxy_name
    ; d_b_proxy_arn
    ; status
    ; engine_family
    ; vpc_security_group_ids
    ; vpc_subnet_ids
    ; auth
    ; role_arn
    ; endpoint
    ; require_t_l_s
    ; idle_client_timeout
    ; debug_logging
    ; created_date
    ; updated_date
    }

  let parse xml =
    Some
      { d_b_proxy_name =
          Aws.Util.option_bind (Aws.Xml.member "DBProxyName" xml) String.parse
      ; d_b_proxy_arn =
          Aws.Util.option_bind (Aws.Xml.member "DBProxyArn" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) DBProxyStatus.parse
      ; engine_family =
          Aws.Util.option_bind (Aws.Xml.member "EngineFamily" xml) String.parse
      ; vpc_security_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "VpcSecurityGroupIds" xml)
               StringList.parse)
      ; vpc_subnet_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "VpcSubnetIds" xml) StringList.parse)
      ; auth =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Auth" xml)
               UserAuthConfigInfoList.parse)
      ; role_arn = Aws.Util.option_bind (Aws.Xml.member "RoleArn" xml) String.parse
      ; endpoint = Aws.Util.option_bind (Aws.Xml.member "Endpoint" xml) String.parse
      ; require_t_l_s =
          Aws.Util.option_bind (Aws.Xml.member "RequireTLS" xml) Boolean.parse
      ; idle_client_timeout =
          Aws.Util.option_bind (Aws.Xml.member "IdleClientTimeout" xml) Integer.parse
      ; debug_logging =
          Aws.Util.option_bind (Aws.Xml.member "DebugLogging" xml) Boolean.parse
      ; created_date =
          Aws.Util.option_bind (Aws.Xml.member "CreatedDate" xml) DateTime.parse
      ; updated_date =
          Aws.Util.option_bind (Aws.Xml.member "UpdatedDate" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.updated_date (fun f ->
               Aws.Query.Pair ("UpdatedDate", DateTime.to_query f))
         ; Aws.Util.option_map v.created_date (fun f ->
               Aws.Query.Pair ("CreatedDate", DateTime.to_query f))
         ; Aws.Util.option_map v.debug_logging (fun f ->
               Aws.Query.Pair ("DebugLogging", Boolean.to_query f))
         ; Aws.Util.option_map v.idle_client_timeout (fun f ->
               Aws.Query.Pair ("IdleClientTimeout", Integer.to_query f))
         ; Aws.Util.option_map v.require_t_l_s (fun f ->
               Aws.Query.Pair ("RequireTLS", Boolean.to_query f))
         ; Aws.Util.option_map v.endpoint (fun f ->
               Aws.Query.Pair ("Endpoint", String.to_query f))
         ; Aws.Util.option_map v.role_arn (fun f ->
               Aws.Query.Pair ("RoleArn", String.to_query f))
         ; Some (Aws.Query.Pair ("Auth.member", UserAuthConfigInfoList.to_query v.auth))
         ; Some
             (Aws.Query.Pair ("VpcSubnetIds.member", StringList.to_query v.vpc_subnet_ids))
         ; Some
             (Aws.Query.Pair
                ( "VpcSecurityGroupIds.member"
                , StringList.to_query v.vpc_security_group_ids ))
         ; Aws.Util.option_map v.engine_family (fun f ->
               Aws.Query.Pair ("EngineFamily", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", DBProxyStatus.to_query f))
         ; Aws.Util.option_map v.d_b_proxy_arn (fun f ->
               Aws.Query.Pair ("DBProxyArn", String.to_query f))
         ; Aws.Util.option_map v.d_b_proxy_name (fun f ->
               Aws.Query.Pair ("DBProxyName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.updated_date (fun f -> "UpdatedDate", DateTime.to_json f)
         ; Aws.Util.option_map v.created_date (fun f -> "CreatedDate", DateTime.to_json f)
         ; Aws.Util.option_map v.debug_logging (fun f ->
               "DebugLogging", Boolean.to_json f)
         ; Aws.Util.option_map v.idle_client_timeout (fun f ->
               "IdleClientTimeout", Integer.to_json f)
         ; Aws.Util.option_map v.require_t_l_s (fun f -> "RequireTLS", Boolean.to_json f)
         ; Aws.Util.option_map v.endpoint (fun f -> "Endpoint", String.to_json f)
         ; Aws.Util.option_map v.role_arn (fun f -> "RoleArn", String.to_json f)
         ; Some ("Auth", UserAuthConfigInfoList.to_json v.auth)
         ; Some ("VpcSubnetIds", StringList.to_json v.vpc_subnet_ids)
         ; Some ("VpcSecurityGroupIds", StringList.to_json v.vpc_security_group_ids)
         ; Aws.Util.option_map v.engine_family (fun f -> "EngineFamily", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", DBProxyStatus.to_json f)
         ; Aws.Util.option_map v.d_b_proxy_arn (fun f -> "DBProxyArn", String.to_json f)
         ; Aws.Util.option_map v.d_b_proxy_name (fun f -> "DBProxyName", String.to_json f)
         ])

  let of_json j =
    { d_b_proxy_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBProxyName") String.of_json
    ; d_b_proxy_arn = Aws.Util.option_map (Aws.Json.lookup j "DBProxyArn") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") DBProxyStatus.of_json
    ; engine_family =
        Aws.Util.option_map (Aws.Json.lookup j "EngineFamily") String.of_json
    ; vpc_security_group_ids =
        StringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcSecurityGroupIds"))
    ; vpc_subnet_ids =
        StringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcSubnetIds"))
    ; auth =
        UserAuthConfigInfoList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Auth"))
    ; role_arn = Aws.Util.option_map (Aws.Json.lookup j "RoleArn") String.of_json
    ; endpoint = Aws.Util.option_map (Aws.Json.lookup j "Endpoint") String.of_json
    ; require_t_l_s = Aws.Util.option_map (Aws.Json.lookup j "RequireTLS") Boolean.of_json
    ; idle_client_timeout =
        Aws.Util.option_map (Aws.Json.lookup j "IdleClientTimeout") Integer.of_json
    ; debug_logging =
        Aws.Util.option_map (Aws.Json.lookup j "DebugLogging") Boolean.of_json
    ; created_date =
        Aws.Util.option_map (Aws.Json.lookup j "CreatedDate") DateTime.of_json
    ; updated_date =
        Aws.Util.option_map (Aws.Json.lookup j "UpdatedDate") DateTime.of_json
    }
end

module DBProxyList = struct
  type t = DBProxy.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map DBProxy.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list DBProxy.to_query v

  let to_json v = `List (List.map DBProxy.to_json v)

  let of_json j = Aws.Json.to_list DBProxy.of_json j
end

module DescribeDBProxiesResponse = struct
  type t =
    { d_b_proxies : DBProxyList.t
    ; marker : String.t option
    }

  let make ?(d_b_proxies = []) ?marker () = { d_b_proxies; marker }

  let parse xml =
    Some
      { d_b_proxies =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "DBProxies" xml) DBProxyList.parse)
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Some (Aws.Query.Pair ("DBProxies.member", DBProxyList.to_query v.d_b_proxies))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Some ("DBProxies", DBProxyList.to_json v.d_b_proxies)
         ])

  let of_json j =
    { d_b_proxies =
        DBProxyList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBProxies"))
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module DescribeDBSnapshotAttributesResult = struct
  type t = { d_b_snapshot_attributes_result : DBSnapshotAttributesResult.t option }

  let make ?d_b_snapshot_attributes_result () = { d_b_snapshot_attributes_result }

  let parse xml =
    Some
      { d_b_snapshot_attributes_result =
          Aws.Util.option_bind
            (Aws.Xml.member "DBSnapshotAttributesResult" xml)
            DBSnapshotAttributesResult.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_snapshot_attributes_result (fun f ->
               Aws.Query.Pair
                 ("DBSnapshotAttributesResult", DBSnapshotAttributesResult.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_snapshot_attributes_result (fun f ->
               "DBSnapshotAttributesResult", DBSnapshotAttributesResult.to_json f)
         ])

  let of_json j =
    { d_b_snapshot_attributes_result =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBSnapshotAttributesResult")
          DBSnapshotAttributesResult.of_json
    }
end

module CreateEventSubscriptionResult = struct
  type t = { event_subscription : EventSubscription.t option }

  let make ?event_subscription () = { event_subscription }

  let parse xml =
    Some
      { event_subscription =
          Aws.Util.option_bind
            (Aws.Xml.member "EventSubscription" xml)
            EventSubscription.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.event_subscription (fun f ->
               Aws.Query.Pair ("EventSubscription", EventSubscription.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.event_subscription (fun f ->
               "EventSubscription", EventSubscription.to_json f)
         ])

  let of_json j =
    { event_subscription =
        Aws.Util.option_map
          (Aws.Json.lookup j "EventSubscription")
          EventSubscription.of_json
    }
end

module UpgradeTarget = struct
  type t =
    { engine : String.t option
    ; engine_version : String.t option
    ; description : String.t option
    ; auto_upgrade : Boolean.t option
    ; is_major_version_upgrade : Boolean.t option
    }

  let make ?engine ?engine_version ?description ?auto_upgrade ?is_major_version_upgrade ()
      =
    { engine; engine_version; description; auto_upgrade; is_major_version_upgrade }

  let parse xml =
    Some
      { engine = Aws.Util.option_bind (Aws.Xml.member "Engine" xml) String.parse
      ; engine_version =
          Aws.Util.option_bind (Aws.Xml.member "EngineVersion" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; auto_upgrade =
          Aws.Util.option_bind (Aws.Xml.member "AutoUpgrade" xml) Boolean.parse
      ; is_major_version_upgrade =
          Aws.Util.option_bind (Aws.Xml.member "IsMajorVersionUpgrade" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.is_major_version_upgrade (fun f ->
               Aws.Query.Pair ("IsMajorVersionUpgrade", Boolean.to_query f))
         ; Aws.Util.option_map v.auto_upgrade (fun f ->
               Aws.Query.Pair ("AutoUpgrade", Boolean.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.engine_version (fun f ->
               Aws.Query.Pair ("EngineVersion", String.to_query f))
         ; Aws.Util.option_map v.engine (fun f ->
               Aws.Query.Pair ("Engine", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.is_major_version_upgrade (fun f ->
               "IsMajorVersionUpgrade", Boolean.to_json f)
         ; Aws.Util.option_map v.auto_upgrade (fun f -> "AutoUpgrade", Boolean.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.engine_version (fun f ->
               "EngineVersion", String.to_json f)
         ; Aws.Util.option_map v.engine (fun f -> "Engine", String.to_json f)
         ])

  let of_json j =
    { engine = Aws.Util.option_map (Aws.Json.lookup j "Engine") String.of_json
    ; engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "EngineVersion") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; auto_upgrade = Aws.Util.option_map (Aws.Json.lookup j "AutoUpgrade") Boolean.of_json
    ; is_major_version_upgrade =
        Aws.Util.option_map (Aws.Json.lookup j "IsMajorVersionUpgrade") Boolean.of_json
    }
end

module DBSecurityGroupNotSupportedFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DBSnapshotMessage = struct
  type t =
    { marker : String.t option
    ; d_b_snapshots : DBSnapshotList.t
    }

  let make ?marker ?(d_b_snapshots = []) () = { marker; d_b_snapshots }

  let parse xml =
    Some
      { marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; d_b_snapshots =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "DBSnapshots" xml) DBSnapshotList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("DBSnapshots.member", DBSnapshotList.to_query v.d_b_snapshots))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("DBSnapshots", DBSnapshotList.to_json v.d_b_snapshots)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ])

  let of_json j =
    { marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; d_b_snapshots =
        DBSnapshotList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBSnapshots"))
    }
end

module DBClusterParameterGroupNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module CreateDBClusterParameterGroupResult = struct
  type t = { d_b_cluster_parameter_group : DBClusterParameterGroup.t option }

  let make ?d_b_cluster_parameter_group () = { d_b_cluster_parameter_group }

  let parse xml =
    Some
      { d_b_cluster_parameter_group =
          Aws.Util.option_bind
            (Aws.Xml.member "DBClusterParameterGroup" xml)
            DBClusterParameterGroup.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster_parameter_group (fun f ->
               Aws.Query.Pair
                 ("DBClusterParameterGroup", DBClusterParameterGroup.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster_parameter_group (fun f ->
               "DBClusterParameterGroup", DBClusterParameterGroup.to_json f)
         ])

  let of_json j =
    { d_b_cluster_parameter_group =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBClusterParameterGroup")
          DBClusterParameterGroup.of_json
    }
end

module EngineDefaults = struct
  type t =
    { d_b_parameter_group_family : String.t option
    ; marker : String.t option
    ; parameters : ParametersList.t
    }

  let make ?d_b_parameter_group_family ?marker ?(parameters = []) () =
    { d_b_parameter_group_family; marker; parameters }

  let parse xml =
    Some
      { d_b_parameter_group_family =
          Aws.Util.option_bind (Aws.Xml.member "DBParameterGroupFamily" xml) String.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; parameters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Parameters" xml) ParametersList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("Parameters.member", ParametersList.to_query v.parameters))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.d_b_parameter_group_family (fun f ->
               Aws.Query.Pair ("DBParameterGroupFamily", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Parameters", ParametersList.to_json v.parameters)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.d_b_parameter_group_family (fun f ->
               "DBParameterGroupFamily", String.to_json f)
         ])

  let of_json j =
    { d_b_parameter_group_family =
        Aws.Util.option_map (Aws.Json.lookup j "DBParameterGroupFamily") String.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; parameters =
        ParametersList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Parameters"))
    }
end

module DBProxyTargetNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DownloadDBLogFilePortionMessage = struct
  type t =
    { d_b_instance_identifier : String.t
    ; log_file_name : String.t
    ; marker : String.t option
    ; number_of_lines : Integer.t option
    }

  let make ~d_b_instance_identifier ~log_file_name ?marker ?number_of_lines () =
    { d_b_instance_identifier; log_file_name; marker; number_of_lines }

  let parse xml =
    Some
      { d_b_instance_identifier =
          Aws.Xml.required
            "DBInstanceIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBInstanceIdentifier" xml)
               String.parse)
      ; log_file_name =
          Aws.Xml.required
            "LogFileName"
            (Aws.Util.option_bind (Aws.Xml.member "LogFileName" xml) String.parse)
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; number_of_lines =
          Aws.Util.option_bind (Aws.Xml.member "NumberOfLines" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.number_of_lines (fun f ->
               Aws.Query.Pair ("NumberOfLines", Integer.to_query f))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Some (Aws.Query.Pair ("LogFileName", String.to_query v.log_file_name))
         ; Some
             (Aws.Query.Pair
                ("DBInstanceIdentifier", String.to_query v.d_b_instance_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.number_of_lines (fun f ->
               "NumberOfLines", Integer.to_json f)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Some ("LogFileName", String.to_json v.log_file_name)
         ; Some ("DBInstanceIdentifier", String.to_json v.d_b_instance_identifier)
         ])

  let of_json j =
    { d_b_instance_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBInstanceIdentifier"))
    ; log_file_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "LogFileName"))
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; number_of_lines =
        Aws.Util.option_map (Aws.Json.lookup j "NumberOfLines") Integer.of_json
    }
end

module Certificate = struct
  type t =
    { certificate_identifier : String.t option
    ; certificate_type : String.t option
    ; thumbprint : String.t option
    ; valid_from : DateTime.t option
    ; valid_till : DateTime.t option
    ; certificate_arn : String.t option
    ; customer_override : Boolean.t option
    ; customer_override_valid_till : DateTime.t option
    }

  let make
      ?certificate_identifier
      ?certificate_type
      ?thumbprint
      ?valid_from
      ?valid_till
      ?certificate_arn
      ?customer_override
      ?customer_override_valid_till
      () =
    { certificate_identifier
    ; certificate_type
    ; thumbprint
    ; valid_from
    ; valid_till
    ; certificate_arn
    ; customer_override
    ; customer_override_valid_till
    }

  let parse xml =
    Some
      { certificate_identifier =
          Aws.Util.option_bind (Aws.Xml.member "CertificateIdentifier" xml) String.parse
      ; certificate_type =
          Aws.Util.option_bind (Aws.Xml.member "CertificateType" xml) String.parse
      ; thumbprint = Aws.Util.option_bind (Aws.Xml.member "Thumbprint" xml) String.parse
      ; valid_from = Aws.Util.option_bind (Aws.Xml.member "ValidFrom" xml) DateTime.parse
      ; valid_till = Aws.Util.option_bind (Aws.Xml.member "ValidTill" xml) DateTime.parse
      ; certificate_arn =
          Aws.Util.option_bind (Aws.Xml.member "CertificateArn" xml) String.parse
      ; customer_override =
          Aws.Util.option_bind (Aws.Xml.member "CustomerOverride" xml) Boolean.parse
      ; customer_override_valid_till =
          Aws.Util.option_bind
            (Aws.Xml.member "CustomerOverrideValidTill" xml)
            DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.customer_override_valid_till (fun f ->
               Aws.Query.Pair ("CustomerOverrideValidTill", DateTime.to_query f))
         ; Aws.Util.option_map v.customer_override (fun f ->
               Aws.Query.Pair ("CustomerOverride", Boolean.to_query f))
         ; Aws.Util.option_map v.certificate_arn (fun f ->
               Aws.Query.Pair ("CertificateArn", String.to_query f))
         ; Aws.Util.option_map v.valid_till (fun f ->
               Aws.Query.Pair ("ValidTill", DateTime.to_query f))
         ; Aws.Util.option_map v.valid_from (fun f ->
               Aws.Query.Pair ("ValidFrom", DateTime.to_query f))
         ; Aws.Util.option_map v.thumbprint (fun f ->
               Aws.Query.Pair ("Thumbprint", String.to_query f))
         ; Aws.Util.option_map v.certificate_type (fun f ->
               Aws.Query.Pair ("CertificateType", String.to_query f))
         ; Aws.Util.option_map v.certificate_identifier (fun f ->
               Aws.Query.Pair ("CertificateIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.customer_override_valid_till (fun f ->
               "CustomerOverrideValidTill", DateTime.to_json f)
         ; Aws.Util.option_map v.customer_override (fun f ->
               "CustomerOverride", Boolean.to_json f)
         ; Aws.Util.option_map v.certificate_arn (fun f ->
               "CertificateArn", String.to_json f)
         ; Aws.Util.option_map v.valid_till (fun f -> "ValidTill", DateTime.to_json f)
         ; Aws.Util.option_map v.valid_from (fun f -> "ValidFrom", DateTime.to_json f)
         ; Aws.Util.option_map v.thumbprint (fun f -> "Thumbprint", String.to_json f)
         ; Aws.Util.option_map v.certificate_type (fun f ->
               "CertificateType", String.to_json f)
         ; Aws.Util.option_map v.certificate_identifier (fun f ->
               "CertificateIdentifier", String.to_json f)
         ])

  let of_json j =
    { certificate_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "CertificateIdentifier") String.of_json
    ; certificate_type =
        Aws.Util.option_map (Aws.Json.lookup j "CertificateType") String.of_json
    ; thumbprint = Aws.Util.option_map (Aws.Json.lookup j "Thumbprint") String.of_json
    ; valid_from = Aws.Util.option_map (Aws.Json.lookup j "ValidFrom") DateTime.of_json
    ; valid_till = Aws.Util.option_map (Aws.Json.lookup j "ValidTill") DateTime.of_json
    ; certificate_arn =
        Aws.Util.option_map (Aws.Json.lookup j "CertificateArn") String.of_json
    ; customer_override =
        Aws.Util.option_map (Aws.Json.lookup j "CustomerOverride") Boolean.of_json
    ; customer_override_valid_till =
        Aws.Util.option_map
          (Aws.Json.lookup j "CustomerOverrideValidTill")
          DateTime.of_json
    }
end

module ModifyCertificatesResult = struct
  type t = { certificate : Certificate.t option }

  let make ?certificate () = { certificate }

  let parse xml =
    Some
      { certificate =
          Aws.Util.option_bind (Aws.Xml.member "Certificate" xml) Certificate.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.certificate (fun f ->
               Aws.Query.Pair ("Certificate", Certificate.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.certificate (fun f ->
               "Certificate", Certificate.to_json f)
         ])

  let of_json j =
    { certificate =
        Aws.Util.option_map (Aws.Json.lookup j "Certificate") Certificate.of_json
    }
end

module InvalidDBInstanceStateFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module PendingMaintenanceAction = struct
  type t =
    { action : String.t option
    ; auto_applied_after_date : DateTime.t option
    ; forced_apply_date : DateTime.t option
    ; opt_in_status : String.t option
    ; current_apply_date : DateTime.t option
    ; description : String.t option
    }

  let make
      ?action
      ?auto_applied_after_date
      ?forced_apply_date
      ?opt_in_status
      ?current_apply_date
      ?description
      () =
    { action
    ; auto_applied_after_date
    ; forced_apply_date
    ; opt_in_status
    ; current_apply_date
    ; description
    }

  let parse xml =
    Some
      { action = Aws.Util.option_bind (Aws.Xml.member "Action" xml) String.parse
      ; auto_applied_after_date =
          Aws.Util.option_bind (Aws.Xml.member "AutoAppliedAfterDate" xml) DateTime.parse
      ; forced_apply_date =
          Aws.Util.option_bind (Aws.Xml.member "ForcedApplyDate" xml) DateTime.parse
      ; opt_in_status =
          Aws.Util.option_bind (Aws.Xml.member "OptInStatus" xml) String.parse
      ; current_apply_date =
          Aws.Util.option_bind (Aws.Xml.member "CurrentApplyDate" xml) DateTime.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.current_apply_date (fun f ->
               Aws.Query.Pair ("CurrentApplyDate", DateTime.to_query f))
         ; Aws.Util.option_map v.opt_in_status (fun f ->
               Aws.Query.Pair ("OptInStatus", String.to_query f))
         ; Aws.Util.option_map v.forced_apply_date (fun f ->
               Aws.Query.Pair ("ForcedApplyDate", DateTime.to_query f))
         ; Aws.Util.option_map v.auto_applied_after_date (fun f ->
               Aws.Query.Pair ("AutoAppliedAfterDate", DateTime.to_query f))
         ; Aws.Util.option_map v.action (fun f ->
               Aws.Query.Pair ("Action", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.current_apply_date (fun f ->
               "CurrentApplyDate", DateTime.to_json f)
         ; Aws.Util.option_map v.opt_in_status (fun f -> "OptInStatus", String.to_json f)
         ; Aws.Util.option_map v.forced_apply_date (fun f ->
               "ForcedApplyDate", DateTime.to_json f)
         ; Aws.Util.option_map v.auto_applied_after_date (fun f ->
               "AutoAppliedAfterDate", DateTime.to_json f)
         ; Aws.Util.option_map v.action (fun f -> "Action", String.to_json f)
         ])

  let of_json j =
    { action = Aws.Util.option_map (Aws.Json.lookup j "Action") String.of_json
    ; auto_applied_after_date =
        Aws.Util.option_map (Aws.Json.lookup j "AutoAppliedAfterDate") DateTime.of_json
    ; forced_apply_date =
        Aws.Util.option_map (Aws.Json.lookup j "ForcedApplyDate") DateTime.of_json
    ; opt_in_status = Aws.Util.option_map (Aws.Json.lookup j "OptInStatus") String.of_json
    ; current_apply_date =
        Aws.Util.option_map (Aws.Json.lookup j "CurrentApplyDate") DateTime.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    }
end

module PendingMaintenanceActionDetails = struct
  type t = PendingMaintenanceAction.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         PendingMaintenanceAction.parse
         (Aws.Xml.members "PendingMaintenanceAction" xml))

  let to_query v = Aws.Query.to_query_list PendingMaintenanceAction.to_query v

  let to_json v = `List (List.map PendingMaintenanceAction.to_json v)

  let of_json j = Aws.Json.to_list PendingMaintenanceAction.of_json j
end

module ModifyDBClusterEndpointMessage = struct
  type t =
    { d_b_cluster_endpoint_identifier : String.t
    ; endpoint_type : String.t option
    ; static_members : StringList.t
    ; excluded_members : StringList.t
    }

  let make
      ~d_b_cluster_endpoint_identifier
      ?endpoint_type
      ?(static_members = [])
      ?(excluded_members = [])
      () =
    { d_b_cluster_endpoint_identifier; endpoint_type; static_members; excluded_members }

  let parse xml =
    Some
      { d_b_cluster_endpoint_identifier =
          Aws.Xml.required
            "DBClusterEndpointIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBClusterEndpointIdentifier" xml)
               String.parse)
      ; endpoint_type =
          Aws.Util.option_bind (Aws.Xml.member "EndpointType" xml) String.parse
      ; static_members =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "StaticMembers" xml) StringList.parse)
      ; excluded_members =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "ExcludedMembers" xml) StringList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("ExcludedMembers.member", StringList.to_query v.excluded_members))
         ; Some
             (Aws.Query.Pair ("StaticMembers.member", StringList.to_query v.static_members))
         ; Aws.Util.option_map v.endpoint_type (fun f ->
               Aws.Query.Pair ("EndpointType", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "DBClusterEndpointIdentifier"
                , String.to_query v.d_b_cluster_endpoint_identifier ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("ExcludedMembers", StringList.to_json v.excluded_members)
         ; Some ("StaticMembers", StringList.to_json v.static_members)
         ; Aws.Util.option_map v.endpoint_type (fun f -> "EndpointType", String.to_json f)
         ; Some
             ( "DBClusterEndpointIdentifier"
             , String.to_json v.d_b_cluster_endpoint_identifier )
         ])

  let of_json j =
    { d_b_cluster_endpoint_identifier =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterEndpointIdentifier"))
    ; endpoint_type =
        Aws.Util.option_map (Aws.Json.lookup j "EndpointType") String.of_json
    ; static_members =
        StringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "StaticMembers"))
    ; excluded_members =
        StringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ExcludedMembers"))
    }
end

module InvalidDBSnapshotStateFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DescribeExportTasksMessage = struct
  type t =
    { export_task_identifier : String.t option
    ; source_arn : String.t option
    ; filters : FilterList.t
    ; marker : String.t option
    ; max_records : Integer.t option
    }

  let make ?export_task_identifier ?source_arn ?(filters = []) ?marker ?max_records () =
    { export_task_identifier; source_arn; filters; marker; max_records }

  let parse xml =
    Some
      { export_task_identifier =
          Aws.Util.option_bind (Aws.Xml.member "ExportTaskIdentifier" xml) String.parse
      ; source_arn = Aws.Util.option_bind (Aws.Xml.member "SourceArn" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.source_arn (fun f ->
               Aws.Query.Pair ("SourceArn", String.to_query f))
         ; Aws.Util.option_map v.export_task_identifier (fun f ->
               Aws.Query.Pair ("ExportTaskIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.source_arn (fun f -> "SourceArn", String.to_json f)
         ; Aws.Util.option_map v.export_task_identifier (fun f ->
               "ExportTaskIdentifier", String.to_json f)
         ])

  let of_json j =
    { export_task_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "ExportTaskIdentifier") String.of_json
    ; source_arn = Aws.Util.option_map (Aws.Json.lookup j "SourceArn") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    }
end

module ModifyGlobalClusterMessage = struct
  type t =
    { global_cluster_identifier : String.t option
    ; new_global_cluster_identifier : String.t option
    ; deletion_protection : Boolean.t option
    }

  let make
      ?global_cluster_identifier
      ?new_global_cluster_identifier
      ?deletion_protection
      () =
    { global_cluster_identifier; new_global_cluster_identifier; deletion_protection }

  let parse xml =
    Some
      { global_cluster_identifier =
          Aws.Util.option_bind (Aws.Xml.member "GlobalClusterIdentifier" xml) String.parse
      ; new_global_cluster_identifier =
          Aws.Util.option_bind
            (Aws.Xml.member "NewGlobalClusterIdentifier" xml)
            String.parse
      ; deletion_protection =
          Aws.Util.option_bind (Aws.Xml.member "DeletionProtection" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.deletion_protection (fun f ->
               Aws.Query.Pair ("DeletionProtection", Boolean.to_query f))
         ; Aws.Util.option_map v.new_global_cluster_identifier (fun f ->
               Aws.Query.Pair ("NewGlobalClusterIdentifier", String.to_query f))
         ; Aws.Util.option_map v.global_cluster_identifier (fun f ->
               Aws.Query.Pair ("GlobalClusterIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.deletion_protection (fun f ->
               "DeletionProtection", Boolean.to_json f)
         ; Aws.Util.option_map v.new_global_cluster_identifier (fun f ->
               "NewGlobalClusterIdentifier", String.to_json f)
         ; Aws.Util.option_map v.global_cluster_identifier (fun f ->
               "GlobalClusterIdentifier", String.to_json f)
         ])

  let of_json j =
    { global_cluster_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "GlobalClusterIdentifier") String.of_json
    ; new_global_cluster_identifier =
        Aws.Util.option_map
          (Aws.Json.lookup j "NewGlobalClusterIdentifier")
          String.of_json
    ; deletion_protection =
        Aws.Util.option_map (Aws.Json.lookup j "DeletionProtection") Boolean.of_json
    }
end

module CreateDBParameterGroupResult = struct
  type t = { d_b_parameter_group : DBParameterGroup.t option }

  let make ?d_b_parameter_group () = { d_b_parameter_group }

  let parse xml =
    Some
      { d_b_parameter_group =
          Aws.Util.option_bind
            (Aws.Xml.member "DBParameterGroup" xml)
            DBParameterGroup.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_parameter_group (fun f ->
               Aws.Query.Pair ("DBParameterGroup", DBParameterGroup.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_parameter_group (fun f ->
               "DBParameterGroup", DBParameterGroup.to_json f)
         ])

  let of_json j =
    { d_b_parameter_group =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBParameterGroup")
          DBParameterGroup.of_json
    }
end

module ReservedDBInstanceQuotaExceededFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module Range = struct
  type t =
    { from : Integer.t option
    ; to_ : Integer.t option
    ; step : Integer.t option
    }

  let make ?from ?to_ ?step () = { from; to_; step }

  let parse xml =
    Some
      { from = Aws.Util.option_bind (Aws.Xml.member "From" xml) Integer.parse
      ; to_ = Aws.Util.option_bind (Aws.Xml.member "To" xml) Integer.parse
      ; step = Aws.Util.option_bind (Aws.Xml.member "Step" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.step (fun f ->
               Aws.Query.Pair ("Step", Integer.to_query f))
         ; Aws.Util.option_map v.to_ (fun f -> Aws.Query.Pair ("To", Integer.to_query f))
         ; Aws.Util.option_map v.from (fun f ->
               Aws.Query.Pair ("From", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.step (fun f -> "Step", Integer.to_json f)
         ; Aws.Util.option_map v.to_ (fun f -> "To", Integer.to_json f)
         ; Aws.Util.option_map v.from (fun f -> "From", Integer.to_json f)
         ])

  let of_json j =
    { from = Aws.Util.option_map (Aws.Json.lookup j "From") Integer.of_json
    ; to_ = Aws.Util.option_map (Aws.Json.lookup j "To") Integer.of_json
    ; step = Aws.Util.option_map (Aws.Json.lookup j "Step") Integer.of_json
    }
end

module RangeList = struct
  type t = Range.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map Range.parse (Aws.Xml.members "Range" xml))

  let to_query v = Aws.Query.to_query_list Range.to_query v

  let to_json v = `List (List.map Range.to_json v)

  let of_json j = Aws.Json.to_list Range.of_json j
end

module DoubleRangeList = struct
  type t = DoubleRange.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map DoubleRange.parse (Aws.Xml.members "DoubleRange" xml))

  let to_query v = Aws.Query.to_query_list DoubleRange.to_query v

  let to_json v = `List (List.map DoubleRange.to_json v)

  let of_json j = Aws.Json.to_list DoubleRange.of_json j
end

module ValidStorageOptions = struct
  type t =
    { storage_type : String.t option
    ; storage_size : RangeList.t
    ; provisioned_iops : RangeList.t
    ; iops_to_storage_ratio : DoubleRangeList.t
    ; supports_storage_autoscaling : Boolean.t option
    }

  let make
      ?storage_type
      ?(storage_size = [])
      ?(provisioned_iops = [])
      ?(iops_to_storage_ratio = [])
      ?supports_storage_autoscaling
      () =
    { storage_type
    ; storage_size
    ; provisioned_iops
    ; iops_to_storage_ratio
    ; supports_storage_autoscaling
    }

  let parse xml =
    Some
      { storage_type =
          Aws.Util.option_bind (Aws.Xml.member "StorageType" xml) String.parse
      ; storage_size =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "StorageSize" xml) RangeList.parse)
      ; provisioned_iops =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "ProvisionedIops" xml) RangeList.parse)
      ; iops_to_storage_ratio =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "IopsToStorageRatio" xml)
               DoubleRangeList.parse)
      ; supports_storage_autoscaling =
          Aws.Util.option_bind
            (Aws.Xml.member "SupportsStorageAutoscaling" xml)
            Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.supports_storage_autoscaling (fun f ->
               Aws.Query.Pair ("SupportsStorageAutoscaling", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "IopsToStorageRatio.member"
                , DoubleRangeList.to_query v.iops_to_storage_ratio ))
         ; Some
             (Aws.Query.Pair
                ("ProvisionedIops.member", RangeList.to_query v.provisioned_iops))
         ; Some (Aws.Query.Pair ("StorageSize.member", RangeList.to_query v.storage_size))
         ; Aws.Util.option_map v.storage_type (fun f ->
               Aws.Query.Pair ("StorageType", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.supports_storage_autoscaling (fun f ->
               "SupportsStorageAutoscaling", Boolean.to_json f)
         ; Some ("IopsToStorageRatio", DoubleRangeList.to_json v.iops_to_storage_ratio)
         ; Some ("ProvisionedIops", RangeList.to_json v.provisioned_iops)
         ; Some ("StorageSize", RangeList.to_json v.storage_size)
         ; Aws.Util.option_map v.storage_type (fun f -> "StorageType", String.to_json f)
         ])

  let of_json j =
    { storage_type = Aws.Util.option_map (Aws.Json.lookup j "StorageType") String.of_json
    ; storage_size =
        RangeList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "StorageSize"))
    ; provisioned_iops =
        RangeList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ProvisionedIops"))
    ; iops_to_storage_ratio =
        DoubleRangeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "IopsToStorageRatio"))
    ; supports_storage_autoscaling =
        Aws.Util.option_map
          (Aws.Json.lookup j "SupportsStorageAutoscaling")
          Boolean.of_json
    }
end

module ValidStorageOptionsList = struct
  type t = ValidStorageOptions.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ValidStorageOptions.parse (Aws.Xml.members "ValidStorageOptions" xml))

  let to_query v = Aws.Query.to_query_list ValidStorageOptions.to_query v

  let to_json v = `List (List.map ValidStorageOptions.to_json v)

  let of_json j = Aws.Json.to_list ValidStorageOptions.of_json j
end

module ValidDBInstanceModificationsMessage = struct
  type t =
    { storage : ValidStorageOptionsList.t
    ; valid_processor_features : AvailableProcessorFeatureList.t
    }

  let make ?(storage = []) ?(valid_processor_features = []) () =
    { storage; valid_processor_features }

  let parse xml =
    Some
      { storage =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Storage" xml)
               ValidStorageOptionsList.parse)
      ; valid_processor_features =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ValidProcessorFeatures" xml)
               AvailableProcessorFeatureList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "ValidProcessorFeatures.member"
                , AvailableProcessorFeatureList.to_query v.valid_processor_features ))
         ; Some
             (Aws.Query.Pair ("Storage.member", ValidStorageOptionsList.to_query v.storage))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "ValidProcessorFeatures"
             , AvailableProcessorFeatureList.to_json v.valid_processor_features )
         ; Some ("Storage", ValidStorageOptionsList.to_json v.storage)
         ])

  let of_json j =
    { storage =
        ValidStorageOptionsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Storage"))
    ; valid_processor_features =
        AvailableProcessorFeatureList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ValidProcessorFeatures"))
    }
end

module CreateDBClusterSnapshotMessage = struct
  type t =
    { d_b_cluster_snapshot_identifier : String.t
    ; d_b_cluster_identifier : String.t
    ; tags : TagList.t
    }

  let make ~d_b_cluster_snapshot_identifier ~d_b_cluster_identifier ?(tags = []) () =
    { d_b_cluster_snapshot_identifier; d_b_cluster_identifier; tags }

  let parse xml =
    Some
      { d_b_cluster_snapshot_identifier =
          Aws.Xml.required
            "DBClusterSnapshotIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBClusterSnapshotIdentifier" xml)
               String.parse)
      ; d_b_cluster_identifier =
          Aws.Xml.required
            "DBClusterIdentifier"
            (Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Some
             (Aws.Query.Pair
                ("DBClusterIdentifier", String.to_query v.d_b_cluster_identifier))
         ; Some
             (Aws.Query.Pair
                ( "DBClusterSnapshotIdentifier"
                , String.to_query v.d_b_cluster_snapshot_identifier ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tags", TagList.to_json v.tags)
         ; Some ("DBClusterIdentifier", String.to_json v.d_b_cluster_identifier)
         ; Some
             ( "DBClusterSnapshotIdentifier"
             , String.to_json v.d_b_cluster_snapshot_identifier )
         ])

  let of_json j =
    { d_b_cluster_snapshot_identifier =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterSnapshotIdentifier"))
    ; d_b_cluster_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterIdentifier"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    }
end

module ResourceNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DBSubnetGroupMessage = struct
  type t =
    { marker : String.t option
    ; d_b_subnet_groups : DBSubnetGroups.t
    }

  let make ?marker ?(d_b_subnet_groups = []) () = { marker; d_b_subnet_groups }

  let parse xml =
    Some
      { marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; d_b_subnet_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DBSubnetGroups" xml)
               DBSubnetGroups.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("DBSubnetGroups.member", DBSubnetGroups.to_query v.d_b_subnet_groups))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("DBSubnetGroups", DBSubnetGroups.to_json v.d_b_subnet_groups)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ])

  let of_json j =
    { marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; d_b_subnet_groups =
        DBSubnetGroups.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBSubnetGroups"))
    }
end

module SubscriptionCategoryNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module OptionGroupsList = struct
  type t = OptionGroup.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map OptionGroup.parse (Aws.Xml.members "OptionGroup" xml))

  let to_query v = Aws.Query.to_query_list OptionGroup.to_query v

  let to_json v = `List (List.map OptionGroup.to_json v)

  let of_json j = Aws.Json.to_list OptionGroup.of_json j
end

module ModifyDBParameterGroupMessage = struct
  type t =
    { d_b_parameter_group_name : String.t
    ; parameters : ParametersList.t
    }

  let make ~d_b_parameter_group_name ~parameters () =
    { d_b_parameter_group_name; parameters }

  let parse xml =
    Some
      { d_b_parameter_group_name =
          Aws.Xml.required
            "DBParameterGroupName"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBParameterGroupName" xml)
               String.parse)
      ; parameters =
          Aws.Xml.required
            "Parameters"
            (Aws.Util.option_bind (Aws.Xml.member "Parameters" xml) ParametersList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("Parameters.member", ParametersList.to_query v.parameters))
         ; Some
             (Aws.Query.Pair
                ("DBParameterGroupName", String.to_query v.d_b_parameter_group_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Parameters", ParametersList.to_json v.parameters)
         ; Some ("DBParameterGroupName", String.to_json v.d_b_parameter_group_name)
         ])

  let of_json j =
    { d_b_parameter_group_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBParameterGroupName"))
    ; parameters =
        ParametersList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Parameters"))
    }
end

module RestoreDBInstanceToPointInTimeMessage = struct
  type t =
    { source_d_b_instance_identifier : String.t option
    ; target_d_b_instance_identifier : String.t
    ; restore_time : DateTime.t option
    ; use_latest_restorable_time : Boolean.t option
    ; d_b_instance_class : String.t option
    ; port : Integer.t option
    ; availability_zone : String.t option
    ; d_b_subnet_group_name : String.t option
    ; multi_a_z : Boolean.t option
    ; publicly_accessible : Boolean.t option
    ; auto_minor_version_upgrade : Boolean.t option
    ; license_model : String.t option
    ; d_b_name : String.t option
    ; engine : String.t option
    ; iops : Integer.t option
    ; option_group_name : String.t option
    ; copy_tags_to_snapshot : Boolean.t option
    ; tags : TagList.t
    ; storage_type : String.t option
    ; tde_credential_arn : String.t option
    ; tde_credential_password : String.t option
    ; vpc_security_group_ids : VpcSecurityGroupIdList.t
    ; domain : String.t option
    ; domain_i_a_m_role_name : String.t option
    ; enable_i_a_m_database_authentication : Boolean.t option
    ; enable_cloudwatch_logs_exports : LogTypeList.t
    ; processor_features : ProcessorFeatureList.t
    ; use_default_processor_features : Boolean.t option
    ; d_b_parameter_group_name : String.t option
    ; deletion_protection : Boolean.t option
    ; source_dbi_resource_id : String.t option
    ; max_allocated_storage : Integer.t option
    }

  let make
      ?source_d_b_instance_identifier
      ~target_d_b_instance_identifier
      ?restore_time
      ?use_latest_restorable_time
      ?d_b_instance_class
      ?port
      ?availability_zone
      ?d_b_subnet_group_name
      ?multi_a_z
      ?publicly_accessible
      ?auto_minor_version_upgrade
      ?license_model
      ?d_b_name
      ?engine
      ?iops
      ?option_group_name
      ?copy_tags_to_snapshot
      ?(tags = [])
      ?storage_type
      ?tde_credential_arn
      ?tde_credential_password
      ?(vpc_security_group_ids = [])
      ?domain
      ?domain_i_a_m_role_name
      ?enable_i_a_m_database_authentication
      ?(enable_cloudwatch_logs_exports = [])
      ?(processor_features = [])
      ?use_default_processor_features
      ?d_b_parameter_group_name
      ?deletion_protection
      ?source_dbi_resource_id
      ?max_allocated_storage
      () =
    { source_d_b_instance_identifier
    ; target_d_b_instance_identifier
    ; restore_time
    ; use_latest_restorable_time
    ; d_b_instance_class
    ; port
    ; availability_zone
    ; d_b_subnet_group_name
    ; multi_a_z
    ; publicly_accessible
    ; auto_minor_version_upgrade
    ; license_model
    ; d_b_name
    ; engine
    ; iops
    ; option_group_name
    ; copy_tags_to_snapshot
    ; tags
    ; storage_type
    ; tde_credential_arn
    ; tde_credential_password
    ; vpc_security_group_ids
    ; domain
    ; domain_i_a_m_role_name
    ; enable_i_a_m_database_authentication
    ; enable_cloudwatch_logs_exports
    ; processor_features
    ; use_default_processor_features
    ; d_b_parameter_group_name
    ; deletion_protection
    ; source_dbi_resource_id
    ; max_allocated_storage
    }

  let parse xml =
    Some
      { source_d_b_instance_identifier =
          Aws.Util.option_bind
            (Aws.Xml.member "SourceDBInstanceIdentifier" xml)
            String.parse
      ; target_d_b_instance_identifier =
          Aws.Xml.required
            "TargetDBInstanceIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "TargetDBInstanceIdentifier" xml)
               String.parse)
      ; restore_time =
          Aws.Util.option_bind (Aws.Xml.member "RestoreTime" xml) DateTime.parse
      ; use_latest_restorable_time =
          Aws.Util.option_bind
            (Aws.Xml.member "UseLatestRestorableTime" xml)
            Boolean.parse
      ; d_b_instance_class =
          Aws.Util.option_bind (Aws.Xml.member "DBInstanceClass" xml) String.parse
      ; port = Aws.Util.option_bind (Aws.Xml.member "Port" xml) Integer.parse
      ; availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "AvailabilityZone" xml) String.parse
      ; d_b_subnet_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBSubnetGroupName" xml) String.parse
      ; multi_a_z = Aws.Util.option_bind (Aws.Xml.member "MultiAZ" xml) Boolean.parse
      ; publicly_accessible =
          Aws.Util.option_bind (Aws.Xml.member "PubliclyAccessible" xml) Boolean.parse
      ; auto_minor_version_upgrade =
          Aws.Util.option_bind
            (Aws.Xml.member "AutoMinorVersionUpgrade" xml)
            Boolean.parse
      ; license_model =
          Aws.Util.option_bind (Aws.Xml.member "LicenseModel" xml) String.parse
      ; d_b_name = Aws.Util.option_bind (Aws.Xml.member "DBName" xml) String.parse
      ; engine = Aws.Util.option_bind (Aws.Xml.member "Engine" xml) String.parse
      ; iops = Aws.Util.option_bind (Aws.Xml.member "Iops" xml) Integer.parse
      ; option_group_name =
          Aws.Util.option_bind (Aws.Xml.member "OptionGroupName" xml) String.parse
      ; copy_tags_to_snapshot =
          Aws.Util.option_bind (Aws.Xml.member "CopyTagsToSnapshot" xml) Boolean.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      ; storage_type =
          Aws.Util.option_bind (Aws.Xml.member "StorageType" xml) String.parse
      ; tde_credential_arn =
          Aws.Util.option_bind (Aws.Xml.member "TdeCredentialArn" xml) String.parse
      ; tde_credential_password =
          Aws.Util.option_bind (Aws.Xml.member "TdeCredentialPassword" xml) String.parse
      ; vpc_security_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "VpcSecurityGroupIds" xml)
               VpcSecurityGroupIdList.parse)
      ; domain = Aws.Util.option_bind (Aws.Xml.member "Domain" xml) String.parse
      ; domain_i_a_m_role_name =
          Aws.Util.option_bind (Aws.Xml.member "DomainIAMRoleName" xml) String.parse
      ; enable_i_a_m_database_authentication =
          Aws.Util.option_bind
            (Aws.Xml.member "EnableIAMDatabaseAuthentication" xml)
            Boolean.parse
      ; enable_cloudwatch_logs_exports =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "EnableCloudwatchLogsExports" xml)
               LogTypeList.parse)
      ; processor_features =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ProcessorFeatures" xml)
               ProcessorFeatureList.parse)
      ; use_default_processor_features =
          Aws.Util.option_bind
            (Aws.Xml.member "UseDefaultProcessorFeatures" xml)
            Boolean.parse
      ; d_b_parameter_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBParameterGroupName" xml) String.parse
      ; deletion_protection =
          Aws.Util.option_bind (Aws.Xml.member "DeletionProtection" xml) Boolean.parse
      ; source_dbi_resource_id =
          Aws.Util.option_bind (Aws.Xml.member "SourceDbiResourceId" xml) String.parse
      ; max_allocated_storage =
          Aws.Util.option_bind (Aws.Xml.member "MaxAllocatedStorage" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_allocated_storage (fun f ->
               Aws.Query.Pair ("MaxAllocatedStorage", Integer.to_query f))
         ; Aws.Util.option_map v.source_dbi_resource_id (fun f ->
               Aws.Query.Pair ("SourceDbiResourceId", String.to_query f))
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               Aws.Query.Pair ("DeletionProtection", Boolean.to_query f))
         ; Aws.Util.option_map v.d_b_parameter_group_name (fun f ->
               Aws.Query.Pair ("DBParameterGroupName", String.to_query f))
         ; Aws.Util.option_map v.use_default_processor_features (fun f ->
               Aws.Query.Pair ("UseDefaultProcessorFeatures", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ProcessorFeatures.member"
                , ProcessorFeatureList.to_query v.processor_features ))
         ; Some
             (Aws.Query.Pair
                ( "EnableCloudwatchLogsExports.member"
                , LogTypeList.to_query v.enable_cloudwatch_logs_exports ))
         ; Aws.Util.option_map v.enable_i_a_m_database_authentication (fun f ->
               Aws.Query.Pair ("EnableIAMDatabaseAuthentication", Boolean.to_query f))
         ; Aws.Util.option_map v.domain_i_a_m_role_name (fun f ->
               Aws.Query.Pair ("DomainIAMRoleName", String.to_query f))
         ; Aws.Util.option_map v.domain (fun f ->
               Aws.Query.Pair ("Domain", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "VpcSecurityGroupIds.member"
                , VpcSecurityGroupIdList.to_query v.vpc_security_group_ids ))
         ; Aws.Util.option_map v.tde_credential_password (fun f ->
               Aws.Query.Pair ("TdeCredentialPassword", String.to_query f))
         ; Aws.Util.option_map v.tde_credential_arn (fun f ->
               Aws.Query.Pair ("TdeCredentialArn", String.to_query f))
         ; Aws.Util.option_map v.storage_type (fun f ->
               Aws.Query.Pair ("StorageType", String.to_query f))
         ; Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               Aws.Query.Pair ("CopyTagsToSnapshot", Boolean.to_query f))
         ; Aws.Util.option_map v.option_group_name (fun f ->
               Aws.Query.Pair ("OptionGroupName", String.to_query f))
         ; Aws.Util.option_map v.iops (fun f ->
               Aws.Query.Pair ("Iops", Integer.to_query f))
         ; Aws.Util.option_map v.engine (fun f ->
               Aws.Query.Pair ("Engine", String.to_query f))
         ; Aws.Util.option_map v.d_b_name (fun f ->
               Aws.Query.Pair ("DBName", String.to_query f))
         ; Aws.Util.option_map v.license_model (fun f ->
               Aws.Query.Pair ("LicenseModel", String.to_query f))
         ; Aws.Util.option_map v.auto_minor_version_upgrade (fun f ->
               Aws.Query.Pair ("AutoMinorVersionUpgrade", Boolean.to_query f))
         ; Aws.Util.option_map v.publicly_accessible (fun f ->
               Aws.Query.Pair ("PubliclyAccessible", Boolean.to_query f))
         ; Aws.Util.option_map v.multi_a_z (fun f ->
               Aws.Query.Pair ("MultiAZ", Boolean.to_query f))
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               Aws.Query.Pair ("DBSubnetGroupName", String.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ; Aws.Util.option_map v.port (fun f ->
               Aws.Query.Pair ("Port", Integer.to_query f))
         ; Aws.Util.option_map v.d_b_instance_class (fun f ->
               Aws.Query.Pair ("DBInstanceClass", String.to_query f))
         ; Aws.Util.option_map v.use_latest_restorable_time (fun f ->
               Aws.Query.Pair ("UseLatestRestorableTime", Boolean.to_query f))
         ; Aws.Util.option_map v.restore_time (fun f ->
               Aws.Query.Pair ("RestoreTime", DateTime.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TargetDBInstanceIdentifier"
                , String.to_query v.target_d_b_instance_identifier ))
         ; Aws.Util.option_map v.source_d_b_instance_identifier (fun f ->
               Aws.Query.Pair ("SourceDBInstanceIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_allocated_storage (fun f ->
               "MaxAllocatedStorage", Integer.to_json f)
         ; Aws.Util.option_map v.source_dbi_resource_id (fun f ->
               "SourceDbiResourceId", String.to_json f)
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               "DeletionProtection", Boolean.to_json f)
         ; Aws.Util.option_map v.d_b_parameter_group_name (fun f ->
               "DBParameterGroupName", String.to_json f)
         ; Aws.Util.option_map v.use_default_processor_features (fun f ->
               "UseDefaultProcessorFeatures", Boolean.to_json f)
         ; Some ("ProcessorFeatures", ProcessorFeatureList.to_json v.processor_features)
         ; Some
             ( "EnableCloudwatchLogsExports"
             , LogTypeList.to_json v.enable_cloudwatch_logs_exports )
         ; Aws.Util.option_map v.enable_i_a_m_database_authentication (fun f ->
               "EnableIAMDatabaseAuthentication", Boolean.to_json f)
         ; Aws.Util.option_map v.domain_i_a_m_role_name (fun f ->
               "DomainIAMRoleName", String.to_json f)
         ; Aws.Util.option_map v.domain (fun f -> "Domain", String.to_json f)
         ; Some
             ( "VpcSecurityGroupIds"
             , VpcSecurityGroupIdList.to_json v.vpc_security_group_ids )
         ; Aws.Util.option_map v.tde_credential_password (fun f ->
               "TdeCredentialPassword", String.to_json f)
         ; Aws.Util.option_map v.tde_credential_arn (fun f ->
               "TdeCredentialArn", String.to_json f)
         ; Aws.Util.option_map v.storage_type (fun f -> "StorageType", String.to_json f)
         ; Some ("Tags", TagList.to_json v.tags)
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               "CopyTagsToSnapshot", Boolean.to_json f)
         ; Aws.Util.option_map v.option_group_name (fun f ->
               "OptionGroupName", String.to_json f)
         ; Aws.Util.option_map v.iops (fun f -> "Iops", Integer.to_json f)
         ; Aws.Util.option_map v.engine (fun f -> "Engine", String.to_json f)
         ; Aws.Util.option_map v.d_b_name (fun f -> "DBName", String.to_json f)
         ; Aws.Util.option_map v.license_model (fun f -> "LicenseModel", String.to_json f)
         ; Aws.Util.option_map v.auto_minor_version_upgrade (fun f ->
               "AutoMinorVersionUpgrade", Boolean.to_json f)
         ; Aws.Util.option_map v.publicly_accessible (fun f ->
               "PubliclyAccessible", Boolean.to_json f)
         ; Aws.Util.option_map v.multi_a_z (fun f -> "MultiAZ", Boolean.to_json f)
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               "DBSubnetGroupName", String.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "AvailabilityZone", String.to_json f)
         ; Aws.Util.option_map v.port (fun f -> "Port", Integer.to_json f)
         ; Aws.Util.option_map v.d_b_instance_class (fun f ->
               "DBInstanceClass", String.to_json f)
         ; Aws.Util.option_map v.use_latest_restorable_time (fun f ->
               "UseLatestRestorableTime", Boolean.to_json f)
         ; Aws.Util.option_map v.restore_time (fun f -> "RestoreTime", DateTime.to_json f)
         ; Some
             ( "TargetDBInstanceIdentifier"
             , String.to_json v.target_d_b_instance_identifier )
         ; Aws.Util.option_map v.source_d_b_instance_identifier (fun f ->
               "SourceDBInstanceIdentifier", String.to_json f)
         ])

  let of_json j =
    { source_d_b_instance_identifier =
        Aws.Util.option_map
          (Aws.Json.lookup j "SourceDBInstanceIdentifier")
          String.of_json
    ; target_d_b_instance_identifier =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TargetDBInstanceIdentifier"))
    ; restore_time =
        Aws.Util.option_map (Aws.Json.lookup j "RestoreTime") DateTime.of_json
    ; use_latest_restorable_time =
        Aws.Util.option_map (Aws.Json.lookup j "UseLatestRestorableTime") Boolean.of_json
    ; d_b_instance_class =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstanceClass") String.of_json
    ; port = Aws.Util.option_map (Aws.Json.lookup j "Port") Integer.of_json
    ; availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "AvailabilityZone") String.of_json
    ; d_b_subnet_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBSubnetGroupName") String.of_json
    ; multi_a_z = Aws.Util.option_map (Aws.Json.lookup j "MultiAZ") Boolean.of_json
    ; publicly_accessible =
        Aws.Util.option_map (Aws.Json.lookup j "PubliclyAccessible") Boolean.of_json
    ; auto_minor_version_upgrade =
        Aws.Util.option_map (Aws.Json.lookup j "AutoMinorVersionUpgrade") Boolean.of_json
    ; license_model =
        Aws.Util.option_map (Aws.Json.lookup j "LicenseModel") String.of_json
    ; d_b_name = Aws.Util.option_map (Aws.Json.lookup j "DBName") String.of_json
    ; engine = Aws.Util.option_map (Aws.Json.lookup j "Engine") String.of_json
    ; iops = Aws.Util.option_map (Aws.Json.lookup j "Iops") Integer.of_json
    ; option_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "OptionGroupName") String.of_json
    ; copy_tags_to_snapshot =
        Aws.Util.option_map (Aws.Json.lookup j "CopyTagsToSnapshot") Boolean.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    ; storage_type = Aws.Util.option_map (Aws.Json.lookup j "StorageType") String.of_json
    ; tde_credential_arn =
        Aws.Util.option_map (Aws.Json.lookup j "TdeCredentialArn") String.of_json
    ; tde_credential_password =
        Aws.Util.option_map (Aws.Json.lookup j "TdeCredentialPassword") String.of_json
    ; vpc_security_group_ids =
        VpcSecurityGroupIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcSecurityGroupIds"))
    ; domain = Aws.Util.option_map (Aws.Json.lookup j "Domain") String.of_json
    ; domain_i_a_m_role_name =
        Aws.Util.option_map (Aws.Json.lookup j "DomainIAMRoleName") String.of_json
    ; enable_i_a_m_database_authentication =
        Aws.Util.option_map
          (Aws.Json.lookup j "EnableIAMDatabaseAuthentication")
          Boolean.of_json
    ; enable_cloudwatch_logs_exports =
        LogTypeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "EnableCloudwatchLogsExports"))
    ; processor_features =
        ProcessorFeatureList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ProcessorFeatures"))
    ; use_default_processor_features =
        Aws.Util.option_map
          (Aws.Json.lookup j "UseDefaultProcessorFeatures")
          Boolean.of_json
    ; d_b_parameter_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBParameterGroupName") String.of_json
    ; deletion_protection =
        Aws.Util.option_map (Aws.Json.lookup j "DeletionProtection") Boolean.of_json
    ; source_dbi_resource_id =
        Aws.Util.option_map (Aws.Json.lookup j "SourceDbiResourceId") String.of_json
    ; max_allocated_storage =
        Aws.Util.option_map (Aws.Json.lookup j "MaxAllocatedStorage") Integer.of_json
    }
end

module ProvisionedIopsNotAvailableInAZFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module GlobalClusterQuotaExceededFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module SubnetAlreadyInUse = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module ModifyDBProxyResponse = struct
  type t = { d_b_proxy : DBProxy.t option }

  let make ?d_b_proxy () = { d_b_proxy }

  let parse xml =
    Some { d_b_proxy = Aws.Util.option_bind (Aws.Xml.member "DBProxy" xml) DBProxy.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_proxy (fun f ->
               Aws.Query.Pair ("DBProxy", DBProxy.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_proxy (fun f -> "DBProxy", DBProxy.to_json f) ])

  let of_json j =
    { d_b_proxy = Aws.Util.option_map (Aws.Json.lookup j "DBProxy") DBProxy.of_json }
end

module InvalidDBProxyStateFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DescribeSourceRegionsMessage = struct
  type t =
    { region_name : String.t option
    ; max_records : Integer.t option
    ; marker : String.t option
    ; filters : FilterList.t
    }

  let make ?region_name ?max_records ?marker ?(filters = []) () =
    { region_name; max_records; marker; filters }

  let parse xml =
    Some
      { region_name = Aws.Util.option_bind (Aws.Xml.member "RegionName" xml) String.parse
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Aws.Util.option_map v.region_name (fun f ->
               Aws.Query.Pair ("RegionName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Aws.Util.option_map v.region_name (fun f -> "RegionName", String.to_json f)
         ])

  let of_json j =
    { region_name = Aws.Util.option_map (Aws.Json.lookup j "RegionName") String.of_json
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    }
end

module DescribeInstallationMediaMessage = struct
  type t =
    { installation_media_id : String.t option
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    }

  let make ?installation_media_id ?(filters = []) ?max_records ?marker () =
    { installation_media_id; filters; max_records; marker }

  let parse xml =
    Some
      { installation_media_id =
          Aws.Util.option_bind (Aws.Xml.member "InstallationMediaId" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.installation_media_id (fun f ->
               Aws.Query.Pair ("InstallationMediaId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.installation_media_id (fun f ->
               "InstallationMediaId", String.to_json f)
         ])

  let of_json j =
    { installation_media_id =
        Aws.Util.option_map (Aws.Json.lookup j "InstallationMediaId") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module ModifyDBSubnetGroupResult = struct
  type t = { d_b_subnet_group : DBSubnetGroup.t option }

  let make ?d_b_subnet_group () = { d_b_subnet_group }

  let parse xml =
    Some
      { d_b_subnet_group =
          Aws.Util.option_bind (Aws.Xml.member "DBSubnetGroup" xml) DBSubnetGroup.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_subnet_group (fun f ->
               Aws.Query.Pair ("DBSubnetGroup", DBSubnetGroup.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_subnet_group (fun f ->
               "DBSubnetGroup", DBSubnetGroup.to_json f)
         ])

  let of_json j =
    { d_b_subnet_group =
        Aws.Util.option_map (Aws.Json.lookup j "DBSubnetGroup") DBSubnetGroup.of_json
    }
end

module InvalidOptionGroupStateFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module AddTagsToResourceMessage = struct
  type t =
    { resource_name : String.t
    ; tags : TagList.t
    }

  let make ~resource_name ~tags () = { resource_name; tags }

  let parse xml =
    Some
      { resource_name =
          Aws.Xml.required
            "ResourceName"
            (Aws.Util.option_bind (Aws.Xml.member "ResourceName" xml) String.parse)
      ; tags =
          Aws.Xml.required
            "Tags"
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Some (Aws.Query.Pair ("ResourceName", String.to_query v.resource_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tags", TagList.to_json v.tags)
         ; Some ("ResourceName", String.to_json v.resource_name)
         ])

  let of_json j =
    { resource_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ResourceName"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    }
end

module DBClusterEndpointAlreadyExistsFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module OptionNamesList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module ModifyOptionGroupMessage = struct
  type t =
    { option_group_name : String.t
    ; options_to_include : OptionConfigurationList.t
    ; options_to_remove : OptionNamesList.t
    ; apply_immediately : Boolean.t option
    }

  let make
      ~option_group_name
      ?(options_to_include = [])
      ?(options_to_remove = [])
      ?apply_immediately
      () =
    { option_group_name; options_to_include; options_to_remove; apply_immediately }

  let parse xml =
    Some
      { option_group_name =
          Aws.Xml.required
            "OptionGroupName"
            (Aws.Util.option_bind (Aws.Xml.member "OptionGroupName" xml) String.parse)
      ; options_to_include =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "OptionsToInclude" xml)
               OptionConfigurationList.parse)
      ; options_to_remove =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "OptionsToRemove" xml)
               OptionNamesList.parse)
      ; apply_immediately =
          Aws.Util.option_bind (Aws.Xml.member "ApplyImmediately" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.apply_immediately (fun f ->
               Aws.Query.Pair ("ApplyImmediately", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("OptionsToRemove.member", OptionNamesList.to_query v.options_to_remove))
         ; Some
             (Aws.Query.Pair
                ( "OptionsToInclude.member"
                , OptionConfigurationList.to_query v.options_to_include ))
         ; Some (Aws.Query.Pair ("OptionGroupName", String.to_query v.option_group_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.apply_immediately (fun f ->
               "ApplyImmediately", Boolean.to_json f)
         ; Some ("OptionsToRemove", OptionNamesList.to_json v.options_to_remove)
         ; Some ("OptionsToInclude", OptionConfigurationList.to_json v.options_to_include)
         ; Some ("OptionGroupName", String.to_json v.option_group_name)
         ])

  let of_json j =
    { option_group_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "OptionGroupName"))
    ; options_to_include =
        OptionConfigurationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "OptionsToInclude"))
    ; options_to_remove =
        OptionNamesList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "OptionsToRemove"))
    ; apply_immediately =
        Aws.Util.option_map (Aws.Json.lookup j "ApplyImmediately") Boolean.of_json
    }
end

module InvalidSubnet = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module GlobalClusterAlreadyExistsFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DBClusterParameterGroupList = struct
  type t = DBClusterParameterGroup.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         DBClusterParameterGroup.parse
         (Aws.Xml.members "DBClusterParameterGroup" xml))

  let to_query v = Aws.Query.to_query_list DBClusterParameterGroup.to_query v

  let to_json v = `List (List.map DBClusterParameterGroup.to_json v)

  let of_json j = Aws.Json.to_list DBClusterParameterGroup.of_json j
end

module AddSourceIdentifierToSubscriptionMessage = struct
  type t =
    { subscription_name : String.t
    ; source_identifier : String.t
    }

  let make ~subscription_name ~source_identifier () =
    { subscription_name; source_identifier }

  let parse xml =
    Some
      { subscription_name =
          Aws.Xml.required
            "SubscriptionName"
            (Aws.Util.option_bind (Aws.Xml.member "SubscriptionName" xml) String.parse)
      ; source_identifier =
          Aws.Xml.required
            "SourceIdentifier"
            (Aws.Util.option_bind (Aws.Xml.member "SourceIdentifier" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("SourceIdentifier", String.to_query v.source_identifier))
         ; Some (Aws.Query.Pair ("SubscriptionName", String.to_query v.subscription_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("SourceIdentifier", String.to_json v.source_identifier)
         ; Some ("SubscriptionName", String.to_json v.subscription_name)
         ])

  let of_json j =
    { subscription_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SubscriptionName"))
    ; source_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceIdentifier"))
    }
end

module EventSubscriptionsMessage = struct
  type t =
    { marker : String.t option
    ; event_subscriptions_list : EventSubscriptionsList.t
    }

  let make ?marker ?(event_subscriptions_list = []) () =
    { marker; event_subscriptions_list }

  let parse xml =
    Some
      { marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; event_subscriptions_list =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "EventSubscriptionsList" xml)
               EventSubscriptionsList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "EventSubscriptionsList.member"
                , EventSubscriptionsList.to_query v.event_subscriptions_list ))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "EventSubscriptionsList"
             , EventSubscriptionsList.to_json v.event_subscriptions_list )
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ])

  let of_json j =
    { marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; event_subscriptions_list =
        EventSubscriptionsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "EventSubscriptionsList"))
    }
end

module DBClusterEndpointList = struct
  type t = DBClusterEndpoint.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map DBClusterEndpoint.parse (Aws.Xml.members "DBClusterEndpointList" xml))

  let to_query v = Aws.Query.to_query_list DBClusterEndpoint.to_query v

  let to_json v = `List (List.map DBClusterEndpoint.to_json v)

  let of_json j = Aws.Json.to_list DBClusterEndpoint.of_json j
end

module DBClusterEndpointMessage = struct
  type t =
    { marker : String.t option
    ; d_b_cluster_endpoints : DBClusterEndpointList.t
    }

  let make ?marker ?(d_b_cluster_endpoints = []) () = { marker; d_b_cluster_endpoints }

  let parse xml =
    Some
      { marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; d_b_cluster_endpoints =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DBClusterEndpoints" xml)
               DBClusterEndpointList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "DBClusterEndpoints.member"
                , DBClusterEndpointList.to_query v.d_b_cluster_endpoints ))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ("DBClusterEndpoints", DBClusterEndpointList.to_json v.d_b_cluster_endpoints)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ])

  let of_json j =
    { marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; d_b_cluster_endpoints =
        DBClusterEndpointList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterEndpoints"))
    }
end

module RestoreDBInstanceFromS3Message = struct
  type t =
    { d_b_name : String.t option
    ; d_b_instance_identifier : String.t
    ; allocated_storage : Integer.t option
    ; d_b_instance_class : String.t
    ; engine : String.t
    ; master_username : String.t option
    ; master_user_password : String.t option
    ; d_b_security_groups : DBSecurityGroupNameList.t
    ; vpc_security_group_ids : VpcSecurityGroupIdList.t
    ; availability_zone : String.t option
    ; d_b_subnet_group_name : String.t option
    ; preferred_maintenance_window : String.t option
    ; d_b_parameter_group_name : String.t option
    ; backup_retention_period : Integer.t option
    ; preferred_backup_window : String.t option
    ; port : Integer.t option
    ; multi_a_z : Boolean.t option
    ; engine_version : String.t option
    ; auto_minor_version_upgrade : Boolean.t option
    ; license_model : String.t option
    ; iops : Integer.t option
    ; option_group_name : String.t option
    ; publicly_accessible : Boolean.t option
    ; tags : TagList.t
    ; storage_type : String.t option
    ; storage_encrypted : Boolean.t option
    ; kms_key_id : String.t option
    ; copy_tags_to_snapshot : Boolean.t option
    ; monitoring_interval : Integer.t option
    ; monitoring_role_arn : String.t option
    ; enable_i_a_m_database_authentication : Boolean.t option
    ; source_engine : String.t
    ; source_engine_version : String.t
    ; s3_bucket_name : String.t
    ; s3_prefix : String.t option
    ; s3_ingestion_role_arn : String.t
    ; enable_performance_insights : Boolean.t option
    ; performance_insights_k_m_s_key_id : String.t option
    ; performance_insights_retention_period : Integer.t option
    ; enable_cloudwatch_logs_exports : LogTypeList.t
    ; processor_features : ProcessorFeatureList.t
    ; use_default_processor_features : Boolean.t option
    ; deletion_protection : Boolean.t option
    ; max_allocated_storage : Integer.t option
    }

  let make
      ?d_b_name
      ~d_b_instance_identifier
      ?allocated_storage
      ~d_b_instance_class
      ~engine
      ?master_username
      ?master_user_password
      ?(d_b_security_groups = [])
      ?(vpc_security_group_ids = [])
      ?availability_zone
      ?d_b_subnet_group_name
      ?preferred_maintenance_window
      ?d_b_parameter_group_name
      ?backup_retention_period
      ?preferred_backup_window
      ?port
      ?multi_a_z
      ?engine_version
      ?auto_minor_version_upgrade
      ?license_model
      ?iops
      ?option_group_name
      ?publicly_accessible
      ?(tags = [])
      ?storage_type
      ?storage_encrypted
      ?kms_key_id
      ?copy_tags_to_snapshot
      ?monitoring_interval
      ?monitoring_role_arn
      ?enable_i_a_m_database_authentication
      ~source_engine
      ~source_engine_version
      ~s3_bucket_name
      ?s3_prefix
      ~s3_ingestion_role_arn
      ?enable_performance_insights
      ?performance_insights_k_m_s_key_id
      ?performance_insights_retention_period
      ?(enable_cloudwatch_logs_exports = [])
      ?(processor_features = [])
      ?use_default_processor_features
      ?deletion_protection
      ?max_allocated_storage
      () =
    { d_b_name
    ; d_b_instance_identifier
    ; allocated_storage
    ; d_b_instance_class
    ; engine
    ; master_username
    ; master_user_password
    ; d_b_security_groups
    ; vpc_security_group_ids
    ; availability_zone
    ; d_b_subnet_group_name
    ; preferred_maintenance_window
    ; d_b_parameter_group_name
    ; backup_retention_period
    ; preferred_backup_window
    ; port
    ; multi_a_z
    ; engine_version
    ; auto_minor_version_upgrade
    ; license_model
    ; iops
    ; option_group_name
    ; publicly_accessible
    ; tags
    ; storage_type
    ; storage_encrypted
    ; kms_key_id
    ; copy_tags_to_snapshot
    ; monitoring_interval
    ; monitoring_role_arn
    ; enable_i_a_m_database_authentication
    ; source_engine
    ; source_engine_version
    ; s3_bucket_name
    ; s3_prefix
    ; s3_ingestion_role_arn
    ; enable_performance_insights
    ; performance_insights_k_m_s_key_id
    ; performance_insights_retention_period
    ; enable_cloudwatch_logs_exports
    ; processor_features
    ; use_default_processor_features
    ; deletion_protection
    ; max_allocated_storage
    }

  let parse xml =
    Some
      { d_b_name = Aws.Util.option_bind (Aws.Xml.member "DBName" xml) String.parse
      ; d_b_instance_identifier =
          Aws.Xml.required
            "DBInstanceIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBInstanceIdentifier" xml)
               String.parse)
      ; allocated_storage =
          Aws.Util.option_bind (Aws.Xml.member "AllocatedStorage" xml) Integer.parse
      ; d_b_instance_class =
          Aws.Xml.required
            "DBInstanceClass"
            (Aws.Util.option_bind (Aws.Xml.member "DBInstanceClass" xml) String.parse)
      ; engine =
          Aws.Xml.required
            "Engine"
            (Aws.Util.option_bind (Aws.Xml.member "Engine" xml) String.parse)
      ; master_username =
          Aws.Util.option_bind (Aws.Xml.member "MasterUsername" xml) String.parse
      ; master_user_password =
          Aws.Util.option_bind (Aws.Xml.member "MasterUserPassword" xml) String.parse
      ; d_b_security_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DBSecurityGroups" xml)
               DBSecurityGroupNameList.parse)
      ; vpc_security_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "VpcSecurityGroupIds" xml)
               VpcSecurityGroupIdList.parse)
      ; availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "AvailabilityZone" xml) String.parse
      ; d_b_subnet_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBSubnetGroupName" xml) String.parse
      ; preferred_maintenance_window =
          Aws.Util.option_bind
            (Aws.Xml.member "PreferredMaintenanceWindow" xml)
            String.parse
      ; d_b_parameter_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBParameterGroupName" xml) String.parse
      ; backup_retention_period =
          Aws.Util.option_bind (Aws.Xml.member "BackupRetentionPeriod" xml) Integer.parse
      ; preferred_backup_window =
          Aws.Util.option_bind (Aws.Xml.member "PreferredBackupWindow" xml) String.parse
      ; port = Aws.Util.option_bind (Aws.Xml.member "Port" xml) Integer.parse
      ; multi_a_z = Aws.Util.option_bind (Aws.Xml.member "MultiAZ" xml) Boolean.parse
      ; engine_version =
          Aws.Util.option_bind (Aws.Xml.member "EngineVersion" xml) String.parse
      ; auto_minor_version_upgrade =
          Aws.Util.option_bind
            (Aws.Xml.member "AutoMinorVersionUpgrade" xml)
            Boolean.parse
      ; license_model =
          Aws.Util.option_bind (Aws.Xml.member "LicenseModel" xml) String.parse
      ; iops = Aws.Util.option_bind (Aws.Xml.member "Iops" xml) Integer.parse
      ; option_group_name =
          Aws.Util.option_bind (Aws.Xml.member "OptionGroupName" xml) String.parse
      ; publicly_accessible =
          Aws.Util.option_bind (Aws.Xml.member "PubliclyAccessible" xml) Boolean.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      ; storage_type =
          Aws.Util.option_bind (Aws.Xml.member "StorageType" xml) String.parse
      ; storage_encrypted =
          Aws.Util.option_bind (Aws.Xml.member "StorageEncrypted" xml) Boolean.parse
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "KmsKeyId" xml) String.parse
      ; copy_tags_to_snapshot =
          Aws.Util.option_bind (Aws.Xml.member "CopyTagsToSnapshot" xml) Boolean.parse
      ; monitoring_interval =
          Aws.Util.option_bind (Aws.Xml.member "MonitoringInterval" xml) Integer.parse
      ; monitoring_role_arn =
          Aws.Util.option_bind (Aws.Xml.member "MonitoringRoleArn" xml) String.parse
      ; enable_i_a_m_database_authentication =
          Aws.Util.option_bind
            (Aws.Xml.member "EnableIAMDatabaseAuthentication" xml)
            Boolean.parse
      ; source_engine =
          Aws.Xml.required
            "SourceEngine"
            (Aws.Util.option_bind (Aws.Xml.member "SourceEngine" xml) String.parse)
      ; source_engine_version =
          Aws.Xml.required
            "SourceEngineVersion"
            (Aws.Util.option_bind (Aws.Xml.member "SourceEngineVersion" xml) String.parse)
      ; s3_bucket_name =
          Aws.Xml.required
            "S3BucketName"
            (Aws.Util.option_bind (Aws.Xml.member "S3BucketName" xml) String.parse)
      ; s3_prefix = Aws.Util.option_bind (Aws.Xml.member "S3Prefix" xml) String.parse
      ; s3_ingestion_role_arn =
          Aws.Xml.required
            "S3IngestionRoleArn"
            (Aws.Util.option_bind (Aws.Xml.member "S3IngestionRoleArn" xml) String.parse)
      ; enable_performance_insights =
          Aws.Util.option_bind
            (Aws.Xml.member "EnablePerformanceInsights" xml)
            Boolean.parse
      ; performance_insights_k_m_s_key_id =
          Aws.Util.option_bind
            (Aws.Xml.member "PerformanceInsightsKMSKeyId" xml)
            String.parse
      ; performance_insights_retention_period =
          Aws.Util.option_bind
            (Aws.Xml.member "PerformanceInsightsRetentionPeriod" xml)
            Integer.parse
      ; enable_cloudwatch_logs_exports =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "EnableCloudwatchLogsExports" xml)
               LogTypeList.parse)
      ; processor_features =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ProcessorFeatures" xml)
               ProcessorFeatureList.parse)
      ; use_default_processor_features =
          Aws.Util.option_bind
            (Aws.Xml.member "UseDefaultProcessorFeatures" xml)
            Boolean.parse
      ; deletion_protection =
          Aws.Util.option_bind (Aws.Xml.member "DeletionProtection" xml) Boolean.parse
      ; max_allocated_storage =
          Aws.Util.option_bind (Aws.Xml.member "MaxAllocatedStorage" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_allocated_storage (fun f ->
               Aws.Query.Pair ("MaxAllocatedStorage", Integer.to_query f))
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               Aws.Query.Pair ("DeletionProtection", Boolean.to_query f))
         ; Aws.Util.option_map v.use_default_processor_features (fun f ->
               Aws.Query.Pair ("UseDefaultProcessorFeatures", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ProcessorFeatures.member"
                , ProcessorFeatureList.to_query v.processor_features ))
         ; Some
             (Aws.Query.Pair
                ( "EnableCloudwatchLogsExports.member"
                , LogTypeList.to_query v.enable_cloudwatch_logs_exports ))
         ; Aws.Util.option_map v.performance_insights_retention_period (fun f ->
               Aws.Query.Pair ("PerformanceInsightsRetentionPeriod", Integer.to_query f))
         ; Aws.Util.option_map v.performance_insights_k_m_s_key_id (fun f ->
               Aws.Query.Pair ("PerformanceInsightsKMSKeyId", String.to_query f))
         ; Aws.Util.option_map v.enable_performance_insights (fun f ->
               Aws.Query.Pair ("EnablePerformanceInsights", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("S3IngestionRoleArn", String.to_query v.s3_ingestion_role_arn))
         ; Aws.Util.option_map v.s3_prefix (fun f ->
               Aws.Query.Pair ("S3Prefix", String.to_query f))
         ; Some (Aws.Query.Pair ("S3BucketName", String.to_query v.s3_bucket_name))
         ; Some
             (Aws.Query.Pair
                ("SourceEngineVersion", String.to_query v.source_engine_version))
         ; Some (Aws.Query.Pair ("SourceEngine", String.to_query v.source_engine))
         ; Aws.Util.option_map v.enable_i_a_m_database_authentication (fun f ->
               Aws.Query.Pair ("EnableIAMDatabaseAuthentication", Boolean.to_query f))
         ; Aws.Util.option_map v.monitoring_role_arn (fun f ->
               Aws.Query.Pair ("MonitoringRoleArn", String.to_query f))
         ; Aws.Util.option_map v.monitoring_interval (fun f ->
               Aws.Query.Pair ("MonitoringInterval", Integer.to_query f))
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               Aws.Query.Pair ("CopyTagsToSnapshot", Boolean.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Aws.Util.option_map v.storage_encrypted (fun f ->
               Aws.Query.Pair ("StorageEncrypted", Boolean.to_query f))
         ; Aws.Util.option_map v.storage_type (fun f ->
               Aws.Query.Pair ("StorageType", String.to_query f))
         ; Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Aws.Util.option_map v.publicly_accessible (fun f ->
               Aws.Query.Pair ("PubliclyAccessible", Boolean.to_query f))
         ; Aws.Util.option_map v.option_group_name (fun f ->
               Aws.Query.Pair ("OptionGroupName", String.to_query f))
         ; Aws.Util.option_map v.iops (fun f ->
               Aws.Query.Pair ("Iops", Integer.to_query f))
         ; Aws.Util.option_map v.license_model (fun f ->
               Aws.Query.Pair ("LicenseModel", String.to_query f))
         ; Aws.Util.option_map v.auto_minor_version_upgrade (fun f ->
               Aws.Query.Pair ("AutoMinorVersionUpgrade", Boolean.to_query f))
         ; Aws.Util.option_map v.engine_version (fun f ->
               Aws.Query.Pair ("EngineVersion", String.to_query f))
         ; Aws.Util.option_map v.multi_a_z (fun f ->
               Aws.Query.Pair ("MultiAZ", Boolean.to_query f))
         ; Aws.Util.option_map v.port (fun f ->
               Aws.Query.Pair ("Port", Integer.to_query f))
         ; Aws.Util.option_map v.preferred_backup_window (fun f ->
               Aws.Query.Pair ("PreferredBackupWindow", String.to_query f))
         ; Aws.Util.option_map v.backup_retention_period (fun f ->
               Aws.Query.Pair ("BackupRetentionPeriod", Integer.to_query f))
         ; Aws.Util.option_map v.d_b_parameter_group_name (fun f ->
               Aws.Query.Pair ("DBParameterGroupName", String.to_query f))
         ; Aws.Util.option_map v.preferred_maintenance_window (fun f ->
               Aws.Query.Pair ("PreferredMaintenanceWindow", String.to_query f))
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               Aws.Query.Pair ("DBSubnetGroupName", String.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "VpcSecurityGroupIds.member"
                , VpcSecurityGroupIdList.to_query v.vpc_security_group_ids ))
         ; Some
             (Aws.Query.Pair
                ( "DBSecurityGroups.member"
                , DBSecurityGroupNameList.to_query v.d_b_security_groups ))
         ; Aws.Util.option_map v.master_user_password (fun f ->
               Aws.Query.Pair ("MasterUserPassword", String.to_query f))
         ; Aws.Util.option_map v.master_username (fun f ->
               Aws.Query.Pair ("MasterUsername", String.to_query f))
         ; Some (Aws.Query.Pair ("Engine", String.to_query v.engine))
         ; Some (Aws.Query.Pair ("DBInstanceClass", String.to_query v.d_b_instance_class))
         ; Aws.Util.option_map v.allocated_storage (fun f ->
               Aws.Query.Pair ("AllocatedStorage", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DBInstanceIdentifier", String.to_query v.d_b_instance_identifier))
         ; Aws.Util.option_map v.d_b_name (fun f ->
               Aws.Query.Pair ("DBName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_allocated_storage (fun f ->
               "MaxAllocatedStorage", Integer.to_json f)
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               "DeletionProtection", Boolean.to_json f)
         ; Aws.Util.option_map v.use_default_processor_features (fun f ->
               "UseDefaultProcessorFeatures", Boolean.to_json f)
         ; Some ("ProcessorFeatures", ProcessorFeatureList.to_json v.processor_features)
         ; Some
             ( "EnableCloudwatchLogsExports"
             , LogTypeList.to_json v.enable_cloudwatch_logs_exports )
         ; Aws.Util.option_map v.performance_insights_retention_period (fun f ->
               "PerformanceInsightsRetentionPeriod", Integer.to_json f)
         ; Aws.Util.option_map v.performance_insights_k_m_s_key_id (fun f ->
               "PerformanceInsightsKMSKeyId", String.to_json f)
         ; Aws.Util.option_map v.enable_performance_insights (fun f ->
               "EnablePerformanceInsights", Boolean.to_json f)
         ; Some ("S3IngestionRoleArn", String.to_json v.s3_ingestion_role_arn)
         ; Aws.Util.option_map v.s3_prefix (fun f -> "S3Prefix", String.to_json f)
         ; Some ("S3BucketName", String.to_json v.s3_bucket_name)
         ; Some ("SourceEngineVersion", String.to_json v.source_engine_version)
         ; Some ("SourceEngine", String.to_json v.source_engine)
         ; Aws.Util.option_map v.enable_i_a_m_database_authentication (fun f ->
               "EnableIAMDatabaseAuthentication", Boolean.to_json f)
         ; Aws.Util.option_map v.monitoring_role_arn (fun f ->
               "MonitoringRoleArn", String.to_json f)
         ; Aws.Util.option_map v.monitoring_interval (fun f ->
               "MonitoringInterval", Integer.to_json f)
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               "CopyTagsToSnapshot", Boolean.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "KmsKeyId", String.to_json f)
         ; Aws.Util.option_map v.storage_encrypted (fun f ->
               "StorageEncrypted", Boolean.to_json f)
         ; Aws.Util.option_map v.storage_type (fun f -> "StorageType", String.to_json f)
         ; Some ("Tags", TagList.to_json v.tags)
         ; Aws.Util.option_map v.publicly_accessible (fun f ->
               "PubliclyAccessible", Boolean.to_json f)
         ; Aws.Util.option_map v.option_group_name (fun f ->
               "OptionGroupName", String.to_json f)
         ; Aws.Util.option_map v.iops (fun f -> "Iops", Integer.to_json f)
         ; Aws.Util.option_map v.license_model (fun f -> "LicenseModel", String.to_json f)
         ; Aws.Util.option_map v.auto_minor_version_upgrade (fun f ->
               "AutoMinorVersionUpgrade", Boolean.to_json f)
         ; Aws.Util.option_map v.engine_version (fun f ->
               "EngineVersion", String.to_json f)
         ; Aws.Util.option_map v.multi_a_z (fun f -> "MultiAZ", Boolean.to_json f)
         ; Aws.Util.option_map v.port (fun f -> "Port", Integer.to_json f)
         ; Aws.Util.option_map v.preferred_backup_window (fun f ->
               "PreferredBackupWindow", String.to_json f)
         ; Aws.Util.option_map v.backup_retention_period (fun f ->
               "BackupRetentionPeriod", Integer.to_json f)
         ; Aws.Util.option_map v.d_b_parameter_group_name (fun f ->
               "DBParameterGroupName", String.to_json f)
         ; Aws.Util.option_map v.preferred_maintenance_window (fun f ->
               "PreferredMaintenanceWindow", String.to_json f)
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               "DBSubnetGroupName", String.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "AvailabilityZone", String.to_json f)
         ; Some
             ( "VpcSecurityGroupIds"
             , VpcSecurityGroupIdList.to_json v.vpc_security_group_ids )
         ; Some ("DBSecurityGroups", DBSecurityGroupNameList.to_json v.d_b_security_groups)
         ; Aws.Util.option_map v.master_user_password (fun f ->
               "MasterUserPassword", String.to_json f)
         ; Aws.Util.option_map v.master_username (fun f ->
               "MasterUsername", String.to_json f)
         ; Some ("Engine", String.to_json v.engine)
         ; Some ("DBInstanceClass", String.to_json v.d_b_instance_class)
         ; Aws.Util.option_map v.allocated_storage (fun f ->
               "AllocatedStorage", Integer.to_json f)
         ; Some ("DBInstanceIdentifier", String.to_json v.d_b_instance_identifier)
         ; Aws.Util.option_map v.d_b_name (fun f -> "DBName", String.to_json f)
         ])

  let of_json j =
    { d_b_name = Aws.Util.option_map (Aws.Json.lookup j "DBName") String.of_json
    ; d_b_instance_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBInstanceIdentifier"))
    ; allocated_storage =
        Aws.Util.option_map (Aws.Json.lookup j "AllocatedStorage") Integer.of_json
    ; d_b_instance_class =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBInstanceClass"))
    ; engine = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Engine"))
    ; master_username =
        Aws.Util.option_map (Aws.Json.lookup j "MasterUsername") String.of_json
    ; master_user_password =
        Aws.Util.option_map (Aws.Json.lookup j "MasterUserPassword") String.of_json
    ; d_b_security_groups =
        DBSecurityGroupNameList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBSecurityGroups"))
    ; vpc_security_group_ids =
        VpcSecurityGroupIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcSecurityGroupIds"))
    ; availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "AvailabilityZone") String.of_json
    ; d_b_subnet_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBSubnetGroupName") String.of_json
    ; preferred_maintenance_window =
        Aws.Util.option_map
          (Aws.Json.lookup j "PreferredMaintenanceWindow")
          String.of_json
    ; d_b_parameter_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBParameterGroupName") String.of_json
    ; backup_retention_period =
        Aws.Util.option_map (Aws.Json.lookup j "BackupRetentionPeriod") Integer.of_json
    ; preferred_backup_window =
        Aws.Util.option_map (Aws.Json.lookup j "PreferredBackupWindow") String.of_json
    ; port = Aws.Util.option_map (Aws.Json.lookup j "Port") Integer.of_json
    ; multi_a_z = Aws.Util.option_map (Aws.Json.lookup j "MultiAZ") Boolean.of_json
    ; engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "EngineVersion") String.of_json
    ; auto_minor_version_upgrade =
        Aws.Util.option_map (Aws.Json.lookup j "AutoMinorVersionUpgrade") Boolean.of_json
    ; license_model =
        Aws.Util.option_map (Aws.Json.lookup j "LicenseModel") String.of_json
    ; iops = Aws.Util.option_map (Aws.Json.lookup j "Iops") Integer.of_json
    ; option_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "OptionGroupName") String.of_json
    ; publicly_accessible =
        Aws.Util.option_map (Aws.Json.lookup j "PubliclyAccessible") Boolean.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    ; storage_type = Aws.Util.option_map (Aws.Json.lookup j "StorageType") String.of_json
    ; storage_encrypted =
        Aws.Util.option_map (Aws.Json.lookup j "StorageEncrypted") Boolean.of_json
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "KmsKeyId") String.of_json
    ; copy_tags_to_snapshot =
        Aws.Util.option_map (Aws.Json.lookup j "CopyTagsToSnapshot") Boolean.of_json
    ; monitoring_interval =
        Aws.Util.option_map (Aws.Json.lookup j "MonitoringInterval") Integer.of_json
    ; monitoring_role_arn =
        Aws.Util.option_map (Aws.Json.lookup j "MonitoringRoleArn") String.of_json
    ; enable_i_a_m_database_authentication =
        Aws.Util.option_map
          (Aws.Json.lookup j "EnableIAMDatabaseAuthentication")
          Boolean.of_json
    ; source_engine =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceEngine"))
    ; source_engine_version =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceEngineVersion"))
    ; s3_bucket_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "S3BucketName"))
    ; s3_prefix = Aws.Util.option_map (Aws.Json.lookup j "S3Prefix") String.of_json
    ; s3_ingestion_role_arn =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "S3IngestionRoleArn"))
    ; enable_performance_insights =
        Aws.Util.option_map
          (Aws.Json.lookup j "EnablePerformanceInsights")
          Boolean.of_json
    ; performance_insights_k_m_s_key_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "PerformanceInsightsKMSKeyId")
          String.of_json
    ; performance_insights_retention_period =
        Aws.Util.option_map
          (Aws.Json.lookup j "PerformanceInsightsRetentionPeriod")
          Integer.of_json
    ; enable_cloudwatch_logs_exports =
        LogTypeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "EnableCloudwatchLogsExports"))
    ; processor_features =
        ProcessorFeatureList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ProcessorFeatures"))
    ; use_default_processor_features =
        Aws.Util.option_map
          (Aws.Json.lookup j "UseDefaultProcessorFeatures")
          Boolean.of_json
    ; deletion_protection =
        Aws.Util.option_map (Aws.Json.lookup j "DeletionProtection") Boolean.of_json
    ; max_allocated_storage =
        Aws.Util.option_map (Aws.Json.lookup j "MaxAllocatedStorage") Integer.of_json
    }
end

module DBClusterSnapshot = struct
  type t =
    { availability_zones : AvailabilityZones.t
    ; d_b_cluster_snapshot_identifier : String.t option
    ; d_b_cluster_identifier : String.t option
    ; snapshot_create_time : DateTime.t option
    ; engine : String.t option
    ; allocated_storage : Integer.t option
    ; status : String.t option
    ; port : Integer.t option
    ; vpc_id : String.t option
    ; cluster_create_time : DateTime.t option
    ; master_username : String.t option
    ; engine_version : String.t option
    ; license_model : String.t option
    ; snapshot_type : String.t option
    ; percent_progress : Integer.t option
    ; storage_encrypted : Boolean.t option
    ; kms_key_id : String.t option
    ; d_b_cluster_snapshot_arn : String.t option
    ; source_d_b_cluster_snapshot_arn : String.t option
    ; i_a_m_database_authentication_enabled : Boolean.t option
    ; tag_list : TagList.t
    }

  let make
      ?(availability_zones = [])
      ?d_b_cluster_snapshot_identifier
      ?d_b_cluster_identifier
      ?snapshot_create_time
      ?engine
      ?allocated_storage
      ?status
      ?port
      ?vpc_id
      ?cluster_create_time
      ?master_username
      ?engine_version
      ?license_model
      ?snapshot_type
      ?percent_progress
      ?storage_encrypted
      ?kms_key_id
      ?d_b_cluster_snapshot_arn
      ?source_d_b_cluster_snapshot_arn
      ?i_a_m_database_authentication_enabled
      ?(tag_list = [])
      () =
    { availability_zones
    ; d_b_cluster_snapshot_identifier
    ; d_b_cluster_identifier
    ; snapshot_create_time
    ; engine
    ; allocated_storage
    ; status
    ; port
    ; vpc_id
    ; cluster_create_time
    ; master_username
    ; engine_version
    ; license_model
    ; snapshot_type
    ; percent_progress
    ; storage_encrypted
    ; kms_key_id
    ; d_b_cluster_snapshot_arn
    ; source_d_b_cluster_snapshot_arn
    ; i_a_m_database_authentication_enabled
    ; tag_list
    }

  let parse xml =
    Some
      { availability_zones =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AvailabilityZones" xml)
               AvailabilityZones.parse)
      ; d_b_cluster_snapshot_identifier =
          Aws.Util.option_bind
            (Aws.Xml.member "DBClusterSnapshotIdentifier" xml)
            String.parse
      ; d_b_cluster_identifier =
          Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse
      ; snapshot_create_time =
          Aws.Util.option_bind (Aws.Xml.member "SnapshotCreateTime" xml) DateTime.parse
      ; engine = Aws.Util.option_bind (Aws.Xml.member "Engine" xml) String.parse
      ; allocated_storage =
          Aws.Util.option_bind (Aws.Xml.member "AllocatedStorage" xml) Integer.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      ; port = Aws.Util.option_bind (Aws.Xml.member "Port" xml) Integer.parse
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) String.parse
      ; cluster_create_time =
          Aws.Util.option_bind (Aws.Xml.member "ClusterCreateTime" xml) DateTime.parse
      ; master_username =
          Aws.Util.option_bind (Aws.Xml.member "MasterUsername" xml) String.parse
      ; engine_version =
          Aws.Util.option_bind (Aws.Xml.member "EngineVersion" xml) String.parse
      ; license_model =
          Aws.Util.option_bind (Aws.Xml.member "LicenseModel" xml) String.parse
      ; snapshot_type =
          Aws.Util.option_bind (Aws.Xml.member "SnapshotType" xml) String.parse
      ; percent_progress =
          Aws.Util.option_bind (Aws.Xml.member "PercentProgress" xml) Integer.parse
      ; storage_encrypted =
          Aws.Util.option_bind (Aws.Xml.member "StorageEncrypted" xml) Boolean.parse
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "KmsKeyId" xml) String.parse
      ; d_b_cluster_snapshot_arn =
          Aws.Util.option_bind (Aws.Xml.member "DBClusterSnapshotArn" xml) String.parse
      ; source_d_b_cluster_snapshot_arn =
          Aws.Util.option_bind
            (Aws.Xml.member "SourceDBClusterSnapshotArn" xml)
            String.parse
      ; i_a_m_database_authentication_enabled =
          Aws.Util.option_bind
            (Aws.Xml.member "IAMDatabaseAuthenticationEnabled" xml)
            Boolean.parse
      ; tag_list =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "TagList" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagList.member", TagList.to_query v.tag_list))
         ; Aws.Util.option_map v.i_a_m_database_authentication_enabled (fun f ->
               Aws.Query.Pair ("IAMDatabaseAuthenticationEnabled", Boolean.to_query f))
         ; Aws.Util.option_map v.source_d_b_cluster_snapshot_arn (fun f ->
               Aws.Query.Pair ("SourceDBClusterSnapshotArn", String.to_query f))
         ; Aws.Util.option_map v.d_b_cluster_snapshot_arn (fun f ->
               Aws.Query.Pair ("DBClusterSnapshotArn", String.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Aws.Util.option_map v.storage_encrypted (fun f ->
               Aws.Query.Pair ("StorageEncrypted", Boolean.to_query f))
         ; Aws.Util.option_map v.percent_progress (fun f ->
               Aws.Query.Pair ("PercentProgress", Integer.to_query f))
         ; Aws.Util.option_map v.snapshot_type (fun f ->
               Aws.Query.Pair ("SnapshotType", String.to_query f))
         ; Aws.Util.option_map v.license_model (fun f ->
               Aws.Query.Pair ("LicenseModel", String.to_query f))
         ; Aws.Util.option_map v.engine_version (fun f ->
               Aws.Query.Pair ("EngineVersion", String.to_query f))
         ; Aws.Util.option_map v.master_username (fun f ->
               Aws.Query.Pair ("MasterUsername", String.to_query f))
         ; Aws.Util.option_map v.cluster_create_time (fun f ->
               Aws.Query.Pair ("ClusterCreateTime", DateTime.to_query f))
         ; Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Aws.Util.option_map v.port (fun f ->
               Aws.Query.Pair ("Port", Integer.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.allocated_storage (fun f ->
               Aws.Query.Pair ("AllocatedStorage", Integer.to_query f))
         ; Aws.Util.option_map v.engine (fun f ->
               Aws.Query.Pair ("Engine", String.to_query f))
         ; Aws.Util.option_map v.snapshot_create_time (fun f ->
               Aws.Query.Pair ("SnapshotCreateTime", DateTime.to_query f))
         ; Aws.Util.option_map v.d_b_cluster_identifier (fun f ->
               Aws.Query.Pair ("DBClusterIdentifier", String.to_query f))
         ; Aws.Util.option_map v.d_b_cluster_snapshot_identifier (fun f ->
               Aws.Query.Pair ("DBClusterSnapshotIdentifier", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "AvailabilityZones.member"
                , AvailabilityZones.to_query v.availability_zones ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagList", TagList.to_json v.tag_list)
         ; Aws.Util.option_map v.i_a_m_database_authentication_enabled (fun f ->
               "IAMDatabaseAuthenticationEnabled", Boolean.to_json f)
         ; Aws.Util.option_map v.source_d_b_cluster_snapshot_arn (fun f ->
               "SourceDBClusterSnapshotArn", String.to_json f)
         ; Aws.Util.option_map v.d_b_cluster_snapshot_arn (fun f ->
               "DBClusterSnapshotArn", String.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "KmsKeyId", String.to_json f)
         ; Aws.Util.option_map v.storage_encrypted (fun f ->
               "StorageEncrypted", Boolean.to_json f)
         ; Aws.Util.option_map v.percent_progress (fun f ->
               "PercentProgress", Integer.to_json f)
         ; Aws.Util.option_map v.snapshot_type (fun f -> "SnapshotType", String.to_json f)
         ; Aws.Util.option_map v.license_model (fun f -> "LicenseModel", String.to_json f)
         ; Aws.Util.option_map v.engine_version (fun f ->
               "EngineVersion", String.to_json f)
         ; Aws.Util.option_map v.master_username (fun f ->
               "MasterUsername", String.to_json f)
         ; Aws.Util.option_map v.cluster_create_time (fun f ->
               "ClusterCreateTime", DateTime.to_json f)
         ; Aws.Util.option_map v.vpc_id (fun f -> "VpcId", String.to_json f)
         ; Aws.Util.option_map v.port (fun f -> "Port", Integer.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ; Aws.Util.option_map v.allocated_storage (fun f ->
               "AllocatedStorage", Integer.to_json f)
         ; Aws.Util.option_map v.engine (fun f -> "Engine", String.to_json f)
         ; Aws.Util.option_map v.snapshot_create_time (fun f ->
               "SnapshotCreateTime", DateTime.to_json f)
         ; Aws.Util.option_map v.d_b_cluster_identifier (fun f ->
               "DBClusterIdentifier", String.to_json f)
         ; Aws.Util.option_map v.d_b_cluster_snapshot_identifier (fun f ->
               "DBClusterSnapshotIdentifier", String.to_json f)
         ; Some ("AvailabilityZones", AvailabilityZones.to_json v.availability_zones)
         ])

  let of_json j =
    { availability_zones =
        AvailabilityZones.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AvailabilityZones"))
    ; d_b_cluster_snapshot_identifier =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBClusterSnapshotIdentifier")
          String.of_json
    ; d_b_cluster_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "DBClusterIdentifier") String.of_json
    ; snapshot_create_time =
        Aws.Util.option_map (Aws.Json.lookup j "SnapshotCreateTime") DateTime.of_json
    ; engine = Aws.Util.option_map (Aws.Json.lookup j "Engine") String.of_json
    ; allocated_storage =
        Aws.Util.option_map (Aws.Json.lookup j "AllocatedStorage") Integer.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    ; port = Aws.Util.option_map (Aws.Json.lookup j "Port") Integer.of_json
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "VpcId") String.of_json
    ; cluster_create_time =
        Aws.Util.option_map (Aws.Json.lookup j "ClusterCreateTime") DateTime.of_json
    ; master_username =
        Aws.Util.option_map (Aws.Json.lookup j "MasterUsername") String.of_json
    ; engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "EngineVersion") String.of_json
    ; license_model =
        Aws.Util.option_map (Aws.Json.lookup j "LicenseModel") String.of_json
    ; snapshot_type =
        Aws.Util.option_map (Aws.Json.lookup j "SnapshotType") String.of_json
    ; percent_progress =
        Aws.Util.option_map (Aws.Json.lookup j "PercentProgress") Integer.of_json
    ; storage_encrypted =
        Aws.Util.option_map (Aws.Json.lookup j "StorageEncrypted") Boolean.of_json
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "KmsKeyId") String.of_json
    ; d_b_cluster_snapshot_arn =
        Aws.Util.option_map (Aws.Json.lookup j "DBClusterSnapshotArn") String.of_json
    ; source_d_b_cluster_snapshot_arn =
        Aws.Util.option_map
          (Aws.Json.lookup j "SourceDBClusterSnapshotArn")
          String.of_json
    ; i_a_m_database_authentication_enabled =
        Aws.Util.option_map
          (Aws.Json.lookup j "IAMDatabaseAuthenticationEnabled")
          Boolean.of_json
    ; tag_list = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TagList"))
    }
end

module CreateDBClusterResult = struct
  type t = { d_b_cluster : DBCluster.t option }

  let make ?d_b_cluster () = { d_b_cluster }

  let parse xml =
    Some
      { d_b_cluster =
          Aws.Util.option_bind (Aws.Xml.member "DBCluster" xml) DBCluster.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster (fun f ->
               Aws.Query.Pair ("DBCluster", DBCluster.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster (fun f -> "DBCluster", DBCluster.to_json f) ])

  let of_json j =
    { d_b_cluster = Aws.Util.option_map (Aws.Json.lookup j "DBCluster") DBCluster.of_json
    }
end

module CertificateList = struct
  type t = Certificate.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Certificate.parse (Aws.Xml.members "Certificate" xml))

  let to_query v = Aws.Query.to_query_list Certificate.to_query v

  let to_json v = `List (List.map Certificate.to_json v)

  let of_json j = Aws.Json.to_list Certificate.of_json j
end

module DBClusterSnapshotAlreadyExistsFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DBClusterParameterGroupNameMessage = struct
  type t = { d_b_cluster_parameter_group_name : String.t option }

  let make ?d_b_cluster_parameter_group_name () = { d_b_cluster_parameter_group_name }

  let parse xml =
    Some
      { d_b_cluster_parameter_group_name =
          Aws.Util.option_bind
            (Aws.Xml.member "DBClusterParameterGroupName" xml)
            String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster_parameter_group_name (fun f ->
               Aws.Query.Pair ("DBClusterParameterGroupName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster_parameter_group_name (fun f ->
               "DBClusterParameterGroupName", String.to_json f)
         ])

  let of_json j =
    { d_b_cluster_parameter_group_name =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBClusterParameterGroupName")
          String.of_json
    }
end

module ModifyDBClusterMessage = struct
  type t =
    { d_b_cluster_identifier : String.t
    ; new_d_b_cluster_identifier : String.t option
    ; apply_immediately : Boolean.t option
    ; backup_retention_period : Integer.t option
    ; d_b_cluster_parameter_group_name : String.t option
    ; vpc_security_group_ids : VpcSecurityGroupIdList.t
    ; port : Integer.t option
    ; master_user_password : String.t option
    ; option_group_name : String.t option
    ; preferred_backup_window : String.t option
    ; preferred_maintenance_window : String.t option
    ; enable_i_a_m_database_authentication : Boolean.t option
    ; backtrack_window : Long.t option
    ; cloudwatch_logs_export_configuration : CloudwatchLogsExportConfiguration.t option
    ; engine_version : String.t option
    ; allow_major_version_upgrade : Boolean.t option
    ; d_b_instance_parameter_group_name : String.t option
    ; domain : String.t option
    ; domain_i_a_m_role_name : String.t option
    ; scaling_configuration : ScalingConfiguration.t option
    ; deletion_protection : Boolean.t option
    ; enable_http_endpoint : Boolean.t option
    ; copy_tags_to_snapshot : Boolean.t option
    ; enable_global_write_forwarding : Boolean.t option
    }

  let make
      ~d_b_cluster_identifier
      ?new_d_b_cluster_identifier
      ?apply_immediately
      ?backup_retention_period
      ?d_b_cluster_parameter_group_name
      ?(vpc_security_group_ids = [])
      ?port
      ?master_user_password
      ?option_group_name
      ?preferred_backup_window
      ?preferred_maintenance_window
      ?enable_i_a_m_database_authentication
      ?backtrack_window
      ?cloudwatch_logs_export_configuration
      ?engine_version
      ?allow_major_version_upgrade
      ?d_b_instance_parameter_group_name
      ?domain
      ?domain_i_a_m_role_name
      ?scaling_configuration
      ?deletion_protection
      ?enable_http_endpoint
      ?copy_tags_to_snapshot
      ?enable_global_write_forwarding
      () =
    { d_b_cluster_identifier
    ; new_d_b_cluster_identifier
    ; apply_immediately
    ; backup_retention_period
    ; d_b_cluster_parameter_group_name
    ; vpc_security_group_ids
    ; port
    ; master_user_password
    ; option_group_name
    ; preferred_backup_window
    ; preferred_maintenance_window
    ; enable_i_a_m_database_authentication
    ; backtrack_window
    ; cloudwatch_logs_export_configuration
    ; engine_version
    ; allow_major_version_upgrade
    ; d_b_instance_parameter_group_name
    ; domain
    ; domain_i_a_m_role_name
    ; scaling_configuration
    ; deletion_protection
    ; enable_http_endpoint
    ; copy_tags_to_snapshot
    ; enable_global_write_forwarding
    }

  let parse xml =
    Some
      { d_b_cluster_identifier =
          Aws.Xml.required
            "DBClusterIdentifier"
            (Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse)
      ; new_d_b_cluster_identifier =
          Aws.Util.option_bind (Aws.Xml.member "NewDBClusterIdentifier" xml) String.parse
      ; apply_immediately =
          Aws.Util.option_bind (Aws.Xml.member "ApplyImmediately" xml) Boolean.parse
      ; backup_retention_period =
          Aws.Util.option_bind (Aws.Xml.member "BackupRetentionPeriod" xml) Integer.parse
      ; d_b_cluster_parameter_group_name =
          Aws.Util.option_bind
            (Aws.Xml.member "DBClusterParameterGroupName" xml)
            String.parse
      ; vpc_security_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "VpcSecurityGroupIds" xml)
               VpcSecurityGroupIdList.parse)
      ; port = Aws.Util.option_bind (Aws.Xml.member "Port" xml) Integer.parse
      ; master_user_password =
          Aws.Util.option_bind (Aws.Xml.member "MasterUserPassword" xml) String.parse
      ; option_group_name =
          Aws.Util.option_bind (Aws.Xml.member "OptionGroupName" xml) String.parse
      ; preferred_backup_window =
          Aws.Util.option_bind (Aws.Xml.member "PreferredBackupWindow" xml) String.parse
      ; preferred_maintenance_window =
          Aws.Util.option_bind
            (Aws.Xml.member "PreferredMaintenanceWindow" xml)
            String.parse
      ; enable_i_a_m_database_authentication =
          Aws.Util.option_bind
            (Aws.Xml.member "EnableIAMDatabaseAuthentication" xml)
            Boolean.parse
      ; backtrack_window =
          Aws.Util.option_bind (Aws.Xml.member "BacktrackWindow" xml) Long.parse
      ; cloudwatch_logs_export_configuration =
          Aws.Util.option_bind
            (Aws.Xml.member "CloudwatchLogsExportConfiguration" xml)
            CloudwatchLogsExportConfiguration.parse
      ; engine_version =
          Aws.Util.option_bind (Aws.Xml.member "EngineVersion" xml) String.parse
      ; allow_major_version_upgrade =
          Aws.Util.option_bind
            (Aws.Xml.member "AllowMajorVersionUpgrade" xml)
            Boolean.parse
      ; d_b_instance_parameter_group_name =
          Aws.Util.option_bind
            (Aws.Xml.member "DBInstanceParameterGroupName" xml)
            String.parse
      ; domain = Aws.Util.option_bind (Aws.Xml.member "Domain" xml) String.parse
      ; domain_i_a_m_role_name =
          Aws.Util.option_bind (Aws.Xml.member "DomainIAMRoleName" xml) String.parse
      ; scaling_configuration =
          Aws.Util.option_bind
            (Aws.Xml.member "ScalingConfiguration" xml)
            ScalingConfiguration.parse
      ; deletion_protection =
          Aws.Util.option_bind (Aws.Xml.member "DeletionProtection" xml) Boolean.parse
      ; enable_http_endpoint =
          Aws.Util.option_bind (Aws.Xml.member "EnableHttpEndpoint" xml) Boolean.parse
      ; copy_tags_to_snapshot =
          Aws.Util.option_bind (Aws.Xml.member "CopyTagsToSnapshot" xml) Boolean.parse
      ; enable_global_write_forwarding =
          Aws.Util.option_bind
            (Aws.Xml.member "EnableGlobalWriteForwarding" xml)
            Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enable_global_write_forwarding (fun f ->
               Aws.Query.Pair ("EnableGlobalWriteForwarding", Boolean.to_query f))
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               Aws.Query.Pair ("CopyTagsToSnapshot", Boolean.to_query f))
         ; Aws.Util.option_map v.enable_http_endpoint (fun f ->
               Aws.Query.Pair ("EnableHttpEndpoint", Boolean.to_query f))
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               Aws.Query.Pair ("DeletionProtection", Boolean.to_query f))
         ; Aws.Util.option_map v.scaling_configuration (fun f ->
               Aws.Query.Pair ("ScalingConfiguration", ScalingConfiguration.to_query f))
         ; Aws.Util.option_map v.domain_i_a_m_role_name (fun f ->
               Aws.Query.Pair ("DomainIAMRoleName", String.to_query f))
         ; Aws.Util.option_map v.domain (fun f ->
               Aws.Query.Pair ("Domain", String.to_query f))
         ; Aws.Util.option_map v.d_b_instance_parameter_group_name (fun f ->
               Aws.Query.Pair ("DBInstanceParameterGroupName", String.to_query f))
         ; Aws.Util.option_map v.allow_major_version_upgrade (fun f ->
               Aws.Query.Pair ("AllowMajorVersionUpgrade", Boolean.to_query f))
         ; Aws.Util.option_map v.engine_version (fun f ->
               Aws.Query.Pair ("EngineVersion", String.to_query f))
         ; Aws.Util.option_map v.cloudwatch_logs_export_configuration (fun f ->
               Aws.Query.Pair
                 ( "CloudwatchLogsExportConfiguration"
                 , CloudwatchLogsExportConfiguration.to_query f ))
         ; Aws.Util.option_map v.backtrack_window (fun f ->
               Aws.Query.Pair ("BacktrackWindow", Long.to_query f))
         ; Aws.Util.option_map v.enable_i_a_m_database_authentication (fun f ->
               Aws.Query.Pair ("EnableIAMDatabaseAuthentication", Boolean.to_query f))
         ; Aws.Util.option_map v.preferred_maintenance_window (fun f ->
               Aws.Query.Pair ("PreferredMaintenanceWindow", String.to_query f))
         ; Aws.Util.option_map v.preferred_backup_window (fun f ->
               Aws.Query.Pair ("PreferredBackupWindow", String.to_query f))
         ; Aws.Util.option_map v.option_group_name (fun f ->
               Aws.Query.Pair ("OptionGroupName", String.to_query f))
         ; Aws.Util.option_map v.master_user_password (fun f ->
               Aws.Query.Pair ("MasterUserPassword", String.to_query f))
         ; Aws.Util.option_map v.port (fun f ->
               Aws.Query.Pair ("Port", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "VpcSecurityGroupIds.member"
                , VpcSecurityGroupIdList.to_query v.vpc_security_group_ids ))
         ; Aws.Util.option_map v.d_b_cluster_parameter_group_name (fun f ->
               Aws.Query.Pair ("DBClusterParameterGroupName", String.to_query f))
         ; Aws.Util.option_map v.backup_retention_period (fun f ->
               Aws.Query.Pair ("BackupRetentionPeriod", Integer.to_query f))
         ; Aws.Util.option_map v.apply_immediately (fun f ->
               Aws.Query.Pair ("ApplyImmediately", Boolean.to_query f))
         ; Aws.Util.option_map v.new_d_b_cluster_identifier (fun f ->
               Aws.Query.Pair ("NewDBClusterIdentifier", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DBClusterIdentifier", String.to_query v.d_b_cluster_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enable_global_write_forwarding (fun f ->
               "EnableGlobalWriteForwarding", Boolean.to_json f)
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               "CopyTagsToSnapshot", Boolean.to_json f)
         ; Aws.Util.option_map v.enable_http_endpoint (fun f ->
               "EnableHttpEndpoint", Boolean.to_json f)
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               "DeletionProtection", Boolean.to_json f)
         ; Aws.Util.option_map v.scaling_configuration (fun f ->
               "ScalingConfiguration", ScalingConfiguration.to_json f)
         ; Aws.Util.option_map v.domain_i_a_m_role_name (fun f ->
               "DomainIAMRoleName", String.to_json f)
         ; Aws.Util.option_map v.domain (fun f -> "Domain", String.to_json f)
         ; Aws.Util.option_map v.d_b_instance_parameter_group_name (fun f ->
               "DBInstanceParameterGroupName", String.to_json f)
         ; Aws.Util.option_map v.allow_major_version_upgrade (fun f ->
               "AllowMajorVersionUpgrade", Boolean.to_json f)
         ; Aws.Util.option_map v.engine_version (fun f ->
               "EngineVersion", String.to_json f)
         ; Aws.Util.option_map v.cloudwatch_logs_export_configuration (fun f ->
               ( "CloudwatchLogsExportConfiguration"
               , CloudwatchLogsExportConfiguration.to_json f ))
         ; Aws.Util.option_map v.backtrack_window (fun f ->
               "BacktrackWindow", Long.to_json f)
         ; Aws.Util.option_map v.enable_i_a_m_database_authentication (fun f ->
               "EnableIAMDatabaseAuthentication", Boolean.to_json f)
         ; Aws.Util.option_map v.preferred_maintenance_window (fun f ->
               "PreferredMaintenanceWindow", String.to_json f)
         ; Aws.Util.option_map v.preferred_backup_window (fun f ->
               "PreferredBackupWindow", String.to_json f)
         ; Aws.Util.option_map v.option_group_name (fun f ->
               "OptionGroupName", String.to_json f)
         ; Aws.Util.option_map v.master_user_password (fun f ->
               "MasterUserPassword", String.to_json f)
         ; Aws.Util.option_map v.port (fun f -> "Port", Integer.to_json f)
         ; Some
             ( "VpcSecurityGroupIds"
             , VpcSecurityGroupIdList.to_json v.vpc_security_group_ids )
         ; Aws.Util.option_map v.d_b_cluster_parameter_group_name (fun f ->
               "DBClusterParameterGroupName", String.to_json f)
         ; Aws.Util.option_map v.backup_retention_period (fun f ->
               "BackupRetentionPeriod", Integer.to_json f)
         ; Aws.Util.option_map v.apply_immediately (fun f ->
               "ApplyImmediately", Boolean.to_json f)
         ; Aws.Util.option_map v.new_d_b_cluster_identifier (fun f ->
               "NewDBClusterIdentifier", String.to_json f)
         ; Some ("DBClusterIdentifier", String.to_json v.d_b_cluster_identifier)
         ])

  let of_json j =
    { d_b_cluster_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterIdentifier"))
    ; new_d_b_cluster_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "NewDBClusterIdentifier") String.of_json
    ; apply_immediately =
        Aws.Util.option_map (Aws.Json.lookup j "ApplyImmediately") Boolean.of_json
    ; backup_retention_period =
        Aws.Util.option_map (Aws.Json.lookup j "BackupRetentionPeriod") Integer.of_json
    ; d_b_cluster_parameter_group_name =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBClusterParameterGroupName")
          String.of_json
    ; vpc_security_group_ids =
        VpcSecurityGroupIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcSecurityGroupIds"))
    ; port = Aws.Util.option_map (Aws.Json.lookup j "Port") Integer.of_json
    ; master_user_password =
        Aws.Util.option_map (Aws.Json.lookup j "MasterUserPassword") String.of_json
    ; option_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "OptionGroupName") String.of_json
    ; preferred_backup_window =
        Aws.Util.option_map (Aws.Json.lookup j "PreferredBackupWindow") String.of_json
    ; preferred_maintenance_window =
        Aws.Util.option_map
          (Aws.Json.lookup j "PreferredMaintenanceWindow")
          String.of_json
    ; enable_i_a_m_database_authentication =
        Aws.Util.option_map
          (Aws.Json.lookup j "EnableIAMDatabaseAuthentication")
          Boolean.of_json
    ; backtrack_window =
        Aws.Util.option_map (Aws.Json.lookup j "BacktrackWindow") Long.of_json
    ; cloudwatch_logs_export_configuration =
        Aws.Util.option_map
          (Aws.Json.lookup j "CloudwatchLogsExportConfiguration")
          CloudwatchLogsExportConfiguration.of_json
    ; engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "EngineVersion") String.of_json
    ; allow_major_version_upgrade =
        Aws.Util.option_map (Aws.Json.lookup j "AllowMajorVersionUpgrade") Boolean.of_json
    ; d_b_instance_parameter_group_name =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBInstanceParameterGroupName")
          String.of_json
    ; domain = Aws.Util.option_map (Aws.Json.lookup j "Domain") String.of_json
    ; domain_i_a_m_role_name =
        Aws.Util.option_map (Aws.Json.lookup j "DomainIAMRoleName") String.of_json
    ; scaling_configuration =
        Aws.Util.option_map
          (Aws.Json.lookup j "ScalingConfiguration")
          ScalingConfiguration.of_json
    ; deletion_protection =
        Aws.Util.option_map (Aws.Json.lookup j "DeletionProtection") Boolean.of_json
    ; enable_http_endpoint =
        Aws.Util.option_map (Aws.Json.lookup j "EnableHttpEndpoint") Boolean.of_json
    ; copy_tags_to_snapshot =
        Aws.Util.option_map (Aws.Json.lookup j "CopyTagsToSnapshot") Boolean.of_json
    ; enable_global_write_forwarding =
        Aws.Util.option_map
          (Aws.Json.lookup j "EnableGlobalWriteForwarding")
          Boolean.of_json
    }
end

module AuthorizationAlreadyExistsFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module RebootDBInstanceMessage = struct
  type t =
    { d_b_instance_identifier : String.t
    ; force_failover : Boolean.t option
    }

  let make ~d_b_instance_identifier ?force_failover () =
    { d_b_instance_identifier; force_failover }

  let parse xml =
    Some
      { d_b_instance_identifier =
          Aws.Xml.required
            "DBInstanceIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBInstanceIdentifier" xml)
               String.parse)
      ; force_failover =
          Aws.Util.option_bind (Aws.Xml.member "ForceFailover" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.force_failover (fun f ->
               Aws.Query.Pair ("ForceFailover", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DBInstanceIdentifier", String.to_query v.d_b_instance_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.force_failover (fun f ->
               "ForceFailover", Boolean.to_json f)
         ; Some ("DBInstanceIdentifier", String.to_json v.d_b_instance_identifier)
         ])

  let of_json j =
    { d_b_instance_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBInstanceIdentifier"))
    ; force_failover =
        Aws.Util.option_map (Aws.Json.lookup j "ForceFailover") Boolean.of_json
    }
end

module TagListMessage = struct
  type t = { tag_list : TagList.t }

  let make ?(tag_list = []) () = { tag_list }

  let parse xml =
    Some
      { tag_list =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "TagList" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagList.member", TagList.to_query v.tag_list)) ])

  let to_json v =
    `Assoc (Aws.Util.list_filter_opt [ Some ("TagList", TagList.to_json v.tag_list) ])

  let of_json j =
    { tag_list = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TagList")) }
end

module DescribeDBClusterBacktracksMessage = struct
  type t =
    { d_b_cluster_identifier : String.t
    ; backtrack_identifier : String.t option
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    }

  let make
      ~d_b_cluster_identifier
      ?backtrack_identifier
      ?(filters = [])
      ?max_records
      ?marker
      () =
    { d_b_cluster_identifier; backtrack_identifier; filters; max_records; marker }

  let parse xml =
    Some
      { d_b_cluster_identifier =
          Aws.Xml.required
            "DBClusterIdentifier"
            (Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse)
      ; backtrack_identifier =
          Aws.Util.option_bind (Aws.Xml.member "BacktrackIdentifier" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.backtrack_identifier (fun f ->
               Aws.Query.Pair ("BacktrackIdentifier", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DBClusterIdentifier", String.to_query v.d_b_cluster_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.backtrack_identifier (fun f ->
               "BacktrackIdentifier", String.to_json f)
         ; Some ("DBClusterIdentifier", String.to_json v.d_b_cluster_identifier)
         ])

  let of_json j =
    { d_b_cluster_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterIdentifier"))
    ; backtrack_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "BacktrackIdentifier") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module DescribeDBClusterSnapshotAttributesMessage = struct
  type t = { d_b_cluster_snapshot_identifier : String.t }

  let make ~d_b_cluster_snapshot_identifier () = { d_b_cluster_snapshot_identifier }

  let parse xml =
    Some
      { d_b_cluster_snapshot_identifier =
          Aws.Xml.required
            "DBClusterSnapshotIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBClusterSnapshotIdentifier" xml)
               String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "DBClusterSnapshotIdentifier"
                , String.to_query v.d_b_cluster_snapshot_identifier ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "DBClusterSnapshotIdentifier"
             , String.to_json v.d_b_cluster_snapshot_identifier )
         ])

  let of_json j =
    { d_b_cluster_snapshot_identifier =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterSnapshotIdentifier"))
    }
end

module DescribeCustomAvailabilityZonesMessage = struct
  type t =
    { custom_availability_zone_id : String.t option
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    }

  let make ?custom_availability_zone_id ?(filters = []) ?max_records ?marker () =
    { custom_availability_zone_id; filters; max_records; marker }

  let parse xml =
    Some
      { custom_availability_zone_id =
          Aws.Util.option_bind
            (Aws.Xml.member "CustomAvailabilityZoneId" xml)
            String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.custom_availability_zone_id (fun f ->
               Aws.Query.Pair ("CustomAvailabilityZoneId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.custom_availability_zone_id (fun f ->
               "CustomAvailabilityZoneId", String.to_json f)
         ])

  let of_json j =
    { custom_availability_zone_id =
        Aws.Util.option_map (Aws.Json.lookup j "CustomAvailabilityZoneId") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module InvalidExportOnlyFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module ReservedDBInstancesOfferingNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DescribeDBSubnetGroupsMessage = struct
  type t =
    { d_b_subnet_group_name : String.t option
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    }

  let make ?d_b_subnet_group_name ?(filters = []) ?max_records ?marker () =
    { d_b_subnet_group_name; filters; max_records; marker }

  let parse xml =
    Some
      { d_b_subnet_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBSubnetGroupName" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               Aws.Query.Pair ("DBSubnetGroupName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               "DBSubnetGroupName", String.to_json f)
         ])

  let of_json j =
    { d_b_subnet_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBSubnetGroupName") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module DBProxyQuotaExceededFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module ConnectionPoolConfiguration = struct
  type t =
    { max_connections_percent : Integer.t option
    ; max_idle_connections_percent : Integer.t option
    ; connection_borrow_timeout : Integer.t option
    ; session_pinning_filters : StringList.t
    ; init_query : String.t option
    }

  let make
      ?max_connections_percent
      ?max_idle_connections_percent
      ?connection_borrow_timeout
      ?(session_pinning_filters = [])
      ?init_query
      () =
    { max_connections_percent
    ; max_idle_connections_percent
    ; connection_borrow_timeout
    ; session_pinning_filters
    ; init_query
    }

  let parse xml =
    Some
      { max_connections_percent =
          Aws.Util.option_bind (Aws.Xml.member "MaxConnectionsPercent" xml) Integer.parse
      ; max_idle_connections_percent =
          Aws.Util.option_bind
            (Aws.Xml.member "MaxIdleConnectionsPercent" xml)
            Integer.parse
      ; connection_borrow_timeout =
          Aws.Util.option_bind
            (Aws.Xml.member "ConnectionBorrowTimeout" xml)
            Integer.parse
      ; session_pinning_filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SessionPinningFilters" xml)
               StringList.parse)
      ; init_query = Aws.Util.option_bind (Aws.Xml.member "InitQuery" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.init_query (fun f ->
               Aws.Query.Pair ("InitQuery", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "SessionPinningFilters.member"
                , StringList.to_query v.session_pinning_filters ))
         ; Aws.Util.option_map v.connection_borrow_timeout (fun f ->
               Aws.Query.Pair ("ConnectionBorrowTimeout", Integer.to_query f))
         ; Aws.Util.option_map v.max_idle_connections_percent (fun f ->
               Aws.Query.Pair ("MaxIdleConnectionsPercent", Integer.to_query f))
         ; Aws.Util.option_map v.max_connections_percent (fun f ->
               Aws.Query.Pair ("MaxConnectionsPercent", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.init_query (fun f -> "InitQuery", String.to_json f)
         ; Some ("SessionPinningFilters", StringList.to_json v.session_pinning_filters)
         ; Aws.Util.option_map v.connection_borrow_timeout (fun f ->
               "ConnectionBorrowTimeout", Integer.to_json f)
         ; Aws.Util.option_map v.max_idle_connections_percent (fun f ->
               "MaxIdleConnectionsPercent", Integer.to_json f)
         ; Aws.Util.option_map v.max_connections_percent (fun f ->
               "MaxConnectionsPercent", Integer.to_json f)
         ])

  let of_json j =
    { max_connections_percent =
        Aws.Util.option_map (Aws.Json.lookup j "MaxConnectionsPercent") Integer.of_json
    ; max_idle_connections_percent =
        Aws.Util.option_map
          (Aws.Json.lookup j "MaxIdleConnectionsPercent")
          Integer.of_json
    ; connection_borrow_timeout =
        Aws.Util.option_map (Aws.Json.lookup j "ConnectionBorrowTimeout") Integer.of_json
    ; session_pinning_filters =
        StringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SessionPinningFilters"))
    ; init_query = Aws.Util.option_map (Aws.Json.lookup j "InitQuery") String.of_json
    }
end

module ModifyDBProxyTargetGroupRequest = struct
  type t =
    { target_group_name : String.t
    ; d_b_proxy_name : String.t
    ; connection_pool_config : ConnectionPoolConfiguration.t option
    ; new_name : String.t option
    }

  let make ~target_group_name ~d_b_proxy_name ?connection_pool_config ?new_name () =
    { target_group_name; d_b_proxy_name; connection_pool_config; new_name }

  let parse xml =
    Some
      { target_group_name =
          Aws.Xml.required
            "TargetGroupName"
            (Aws.Util.option_bind (Aws.Xml.member "TargetGroupName" xml) String.parse)
      ; d_b_proxy_name =
          Aws.Xml.required
            "DBProxyName"
            (Aws.Util.option_bind (Aws.Xml.member "DBProxyName" xml) String.parse)
      ; connection_pool_config =
          Aws.Util.option_bind
            (Aws.Xml.member "ConnectionPoolConfig" xml)
            ConnectionPoolConfiguration.parse
      ; new_name = Aws.Util.option_bind (Aws.Xml.member "NewName" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.new_name (fun f ->
               Aws.Query.Pair ("NewName", String.to_query f))
         ; Aws.Util.option_map v.connection_pool_config (fun f ->
               Aws.Query.Pair
                 ("ConnectionPoolConfig", ConnectionPoolConfiguration.to_query f))
         ; Some (Aws.Query.Pair ("DBProxyName", String.to_query v.d_b_proxy_name))
         ; Some (Aws.Query.Pair ("TargetGroupName", String.to_query v.target_group_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.new_name (fun f -> "NewName", String.to_json f)
         ; Aws.Util.option_map v.connection_pool_config (fun f ->
               "ConnectionPoolConfig", ConnectionPoolConfiguration.to_json f)
         ; Some ("DBProxyName", String.to_json v.d_b_proxy_name)
         ; Some ("TargetGroupName", String.to_json v.target_group_name)
         ])

  let of_json j =
    { target_group_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TargetGroupName"))
    ; d_b_proxy_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBProxyName"))
    ; connection_pool_config =
        Aws.Util.option_map
          (Aws.Json.lookup j "ConnectionPoolConfig")
          ConnectionPoolConfiguration.of_json
    ; new_name = Aws.Util.option_map (Aws.Json.lookup j "NewName") String.of_json
    }
end

module CreateDBSnapshotResult = struct
  type t = { d_b_snapshot : DBSnapshot.t option }

  let make ?d_b_snapshot () = { d_b_snapshot }

  let parse xml =
    Some
      { d_b_snapshot =
          Aws.Util.option_bind (Aws.Xml.member "DBSnapshot" xml) DBSnapshot.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_snapshot (fun f ->
               Aws.Query.Pair ("DBSnapshot", DBSnapshot.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_snapshot (fun f ->
               "DBSnapshot", DBSnapshot.to_json f)
         ])

  let of_json j =
    { d_b_snapshot =
        Aws.Util.option_map (Aws.Json.lookup j "DBSnapshot") DBSnapshot.of_json
    }
end

module SharedSnapshotQuotaExceededFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DescribeDBSecurityGroupsMessage = struct
  type t =
    { d_b_security_group_name : String.t option
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    }

  let make ?d_b_security_group_name ?(filters = []) ?max_records ?marker () =
    { d_b_security_group_name; filters; max_records; marker }

  let parse xml =
    Some
      { d_b_security_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBSecurityGroupName" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.d_b_security_group_name (fun f ->
               Aws.Query.Pair ("DBSecurityGroupName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.d_b_security_group_name (fun f ->
               "DBSecurityGroupName", String.to_json f)
         ])

  let of_json j =
    { d_b_security_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBSecurityGroupName") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module DBClusterRoleNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module InvalidDBClusterSnapshotStateFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DescribeDBInstanceAutomatedBackupsMessage = struct
  type t =
    { dbi_resource_id : String.t option
    ; d_b_instance_identifier : String.t option
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    }

  let make
      ?dbi_resource_id
      ?d_b_instance_identifier
      ?(filters = [])
      ?max_records
      ?marker
      () =
    { dbi_resource_id; d_b_instance_identifier; filters; max_records; marker }

  let parse xml =
    Some
      { dbi_resource_id =
          Aws.Util.option_bind (Aws.Xml.member "DbiResourceId" xml) String.parse
      ; d_b_instance_identifier =
          Aws.Util.option_bind (Aws.Xml.member "DBInstanceIdentifier" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.d_b_instance_identifier (fun f ->
               Aws.Query.Pair ("DBInstanceIdentifier", String.to_query f))
         ; Aws.Util.option_map v.dbi_resource_id (fun f ->
               Aws.Query.Pair ("DbiResourceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.d_b_instance_identifier (fun f ->
               "DBInstanceIdentifier", String.to_json f)
         ; Aws.Util.option_map v.dbi_resource_id (fun f ->
               "DbiResourceId", String.to_json f)
         ])

  let of_json j =
    { dbi_resource_id =
        Aws.Util.option_map (Aws.Json.lookup j "DbiResourceId") String.of_json
    ; d_b_instance_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstanceIdentifier") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module DeleteDBClusterResult = struct
  type t = { d_b_cluster : DBCluster.t option }

  let make ?d_b_cluster () = { d_b_cluster }

  let parse xml =
    Some
      { d_b_cluster =
          Aws.Util.option_bind (Aws.Xml.member "DBCluster" xml) DBCluster.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster (fun f ->
               Aws.Query.Pair ("DBCluster", DBCluster.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster (fun f -> "DBCluster", DBCluster.to_json f) ])

  let of_json j =
    { d_b_cluster = Aws.Util.option_map (Aws.Json.lookup j "DBCluster") DBCluster.of_json
    }
end

module CreateDBProxyResponse = struct
  type t = { d_b_proxy : DBProxy.t option }

  let make ?d_b_proxy () = { d_b_proxy }

  let parse xml =
    Some { d_b_proxy = Aws.Util.option_bind (Aws.Xml.member "DBProxy" xml) DBProxy.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_proxy (fun f ->
               Aws.Query.Pair ("DBProxy", DBProxy.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_proxy (fun f -> "DBProxy", DBProxy.to_json f) ])

  let of_json j =
    { d_b_proxy = Aws.Util.option_map (Aws.Json.lookup j "DBProxy") DBProxy.of_json }
end

module DBParameterGroupAlreadyExistsFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module ModifyEventSubscriptionResult = struct
  type t = { event_subscription : EventSubscription.t option }

  let make ?event_subscription () = { event_subscription }

  let parse xml =
    Some
      { event_subscription =
          Aws.Util.option_bind
            (Aws.Xml.member "EventSubscription" xml)
            EventSubscription.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.event_subscription (fun f ->
               Aws.Query.Pair ("EventSubscription", EventSubscription.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.event_subscription (fun f ->
               "EventSubscription", EventSubscription.to_json f)
         ])

  let of_json j =
    { event_subscription =
        Aws.Util.option_map
          (Aws.Json.lookup j "EventSubscription")
          EventSubscription.of_json
    }
end

module IamRoleMissingPermissionsFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DescribeDBClusterEndpointsMessage = struct
  type t =
    { d_b_cluster_identifier : String.t option
    ; d_b_cluster_endpoint_identifier : String.t option
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    }

  let make
      ?d_b_cluster_identifier
      ?d_b_cluster_endpoint_identifier
      ?(filters = [])
      ?max_records
      ?marker
      () =
    { d_b_cluster_identifier
    ; d_b_cluster_endpoint_identifier
    ; filters
    ; max_records
    ; marker
    }

  let parse xml =
    Some
      { d_b_cluster_identifier =
          Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse
      ; d_b_cluster_endpoint_identifier =
          Aws.Util.option_bind
            (Aws.Xml.member "DBClusterEndpointIdentifier" xml)
            String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.d_b_cluster_endpoint_identifier (fun f ->
               Aws.Query.Pair ("DBClusterEndpointIdentifier", String.to_query f))
         ; Aws.Util.option_map v.d_b_cluster_identifier (fun f ->
               Aws.Query.Pair ("DBClusterIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.d_b_cluster_endpoint_identifier (fun f ->
               "DBClusterEndpointIdentifier", String.to_json f)
         ; Aws.Util.option_map v.d_b_cluster_identifier (fun f ->
               "DBClusterIdentifier", String.to_json f)
         ])

  let of_json j =
    { d_b_cluster_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "DBClusterIdentifier") String.of_json
    ; d_b_cluster_endpoint_identifier =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBClusterEndpointIdentifier")
          String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module ModifyDBClusterResult = struct
  type t = { d_b_cluster : DBCluster.t option }

  let make ?d_b_cluster () = { d_b_cluster }

  let parse xml =
    Some
      { d_b_cluster =
          Aws.Util.option_bind (Aws.Xml.member "DBCluster" xml) DBCluster.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster (fun f ->
               Aws.Query.Pair ("DBCluster", DBCluster.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster (fun f -> "DBCluster", DBCluster.to_json f) ])

  let of_json j =
    { d_b_cluster = Aws.Util.option_map (Aws.Json.lookup j "DBCluster") DBCluster.of_json
    }
end

module CreateDBSubnetGroupResult = struct
  type t = { d_b_subnet_group : DBSubnetGroup.t option }

  let make ?d_b_subnet_group () = { d_b_subnet_group }

  let parse xml =
    Some
      { d_b_subnet_group =
          Aws.Util.option_bind (Aws.Xml.member "DBSubnetGroup" xml) DBSubnetGroup.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_subnet_group (fun f ->
               Aws.Query.Pair ("DBSubnetGroup", DBSubnetGroup.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_subnet_group (fun f ->
               "DBSubnetGroup", DBSubnetGroup.to_json f)
         ])

  let of_json j =
    { d_b_subnet_group =
        Aws.Util.option_map (Aws.Json.lookup j "DBSubnetGroup") DBSubnetGroup.of_json
    }
end

module FeatureNameList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module InstanceQuotaExceededFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DescribeEngineDefaultParametersMessage = struct
  type t =
    { d_b_parameter_group_family : String.t
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    }

  let make ~d_b_parameter_group_family ?(filters = []) ?max_records ?marker () =
    { d_b_parameter_group_family; filters; max_records; marker }

  let parse xml =
    Some
      { d_b_parameter_group_family =
          Aws.Xml.required
            "DBParameterGroupFamily"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBParameterGroupFamily" xml)
               String.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ("DBParameterGroupFamily", String.to_query v.d_b_parameter_group_family))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Some ("DBParameterGroupFamily", String.to_json v.d_b_parameter_group_family)
         ])

  let of_json j =
    { d_b_parameter_group_family =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBParameterGroupFamily"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module ListTagsForResourceMessage = struct
  type t =
    { resource_name : String.t
    ; filters : FilterList.t
    }

  let make ~resource_name ?(filters = []) () = { resource_name; filters }

  let parse xml =
    Some
      { resource_name =
          Aws.Xml.required
            "ResourceName"
            (Aws.Util.option_bind (Aws.Xml.member "ResourceName" xml) String.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Some (Aws.Query.Pair ("ResourceName", String.to_query v.resource_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Filters", FilterList.to_json v.filters)
         ; Some ("ResourceName", String.to_json v.resource_name)
         ])

  let of_json j =
    { resource_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ResourceName"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    }
end

module DBClusterSnapshotList = struct
  type t = DBClusterSnapshot.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map DBClusterSnapshot.parse (Aws.Xml.members "DBClusterSnapshot" xml))

  let to_query v = Aws.Query.to_query_list DBClusterSnapshot.to_query v

  let to_json v = `List (List.map DBClusterSnapshot.to_json v)

  let of_json j = Aws.Json.to_list DBClusterSnapshot.of_json j
end

module DBClusterSnapshotMessage = struct
  type t =
    { marker : String.t option
    ; d_b_cluster_snapshots : DBClusterSnapshotList.t
    }

  let make ?marker ?(d_b_cluster_snapshots = []) () = { marker; d_b_cluster_snapshots }

  let parse xml =
    Some
      { marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; d_b_cluster_snapshots =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DBClusterSnapshots" xml)
               DBClusterSnapshotList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "DBClusterSnapshots.member"
                , DBClusterSnapshotList.to_query v.d_b_cluster_snapshots ))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ("DBClusterSnapshots", DBClusterSnapshotList.to_json v.d_b_cluster_snapshots)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ])

  let of_json j =
    { marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; d_b_cluster_snapshots =
        DBClusterSnapshotList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterSnapshots"))
    }
end

module DBParameterGroupNameMessage = struct
  type t = { d_b_parameter_group_name : String.t option }

  let make ?d_b_parameter_group_name () = { d_b_parameter_group_name }

  let parse xml =
    Some
      { d_b_parameter_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBParameterGroupName" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_parameter_group_name (fun f ->
               Aws.Query.Pair ("DBParameterGroupName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_parameter_group_name (fun f ->
               "DBParameterGroupName", String.to_json f)
         ])

  let of_json j =
    { d_b_parameter_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBParameterGroupName") String.of_json
    }
end

module StartDBClusterMessage = struct
  type t = { d_b_cluster_identifier : String.t }

  let make ~d_b_cluster_identifier () = { d_b_cluster_identifier }

  let parse xml =
    Some
      { d_b_cluster_identifier =
          Aws.Xml.required
            "DBClusterIdentifier"
            (Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("DBClusterIdentifier", String.to_query v.d_b_cluster_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("DBClusterIdentifier", String.to_json v.d_b_cluster_identifier) ])

  let of_json j =
    { d_b_cluster_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterIdentifier"))
    }
end

module DescribeDBParametersMessage = struct
  type t =
    { d_b_parameter_group_name : String.t
    ; source : String.t option
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    }

  let make ~d_b_parameter_group_name ?source ?(filters = []) ?max_records ?marker () =
    { d_b_parameter_group_name; source; filters; max_records; marker }

  let parse xml =
    Some
      { d_b_parameter_group_name =
          Aws.Xml.required
            "DBParameterGroupName"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBParameterGroupName" xml)
               String.parse)
      ; source = Aws.Util.option_bind (Aws.Xml.member "Source" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.source (fun f ->
               Aws.Query.Pair ("Source", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DBParameterGroupName", String.to_query v.d_b_parameter_group_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.source (fun f -> "Source", String.to_json f)
         ; Some ("DBParameterGroupName", String.to_json v.d_b_parameter_group_name)
         ])

  let of_json j =
    { d_b_parameter_group_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBParameterGroupName"))
    ; source = Aws.Util.option_map (Aws.Json.lookup j "Source") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module CreateDBParameterGroupMessage = struct
  type t =
    { d_b_parameter_group_name : String.t
    ; d_b_parameter_group_family : String.t
    ; description : String.t
    ; tags : TagList.t
    }

  let make
      ~d_b_parameter_group_name
      ~d_b_parameter_group_family
      ~description
      ?(tags = [])
      () =
    { d_b_parameter_group_name; d_b_parameter_group_family; description; tags }

  let parse xml =
    Some
      { d_b_parameter_group_name =
          Aws.Xml.required
            "DBParameterGroupName"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBParameterGroupName" xml)
               String.parse)
      ; d_b_parameter_group_family =
          Aws.Xml.required
            "DBParameterGroupFamily"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBParameterGroupFamily" xml)
               String.parse)
      ; description =
          Aws.Xml.required
            "Description"
            (Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Some (Aws.Query.Pair ("Description", String.to_query v.description))
         ; Some
             (Aws.Query.Pair
                ("DBParameterGroupFamily", String.to_query v.d_b_parameter_group_family))
         ; Some
             (Aws.Query.Pair
                ("DBParameterGroupName", String.to_query v.d_b_parameter_group_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tags", TagList.to_json v.tags)
         ; Some ("Description", String.to_json v.description)
         ; Some ("DBParameterGroupFamily", String.to_json v.d_b_parameter_group_family)
         ; Some ("DBParameterGroupName", String.to_json v.d_b_parameter_group_name)
         ])

  let of_json j =
    { d_b_parameter_group_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBParameterGroupName"))
    ; d_b_parameter_group_family =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBParameterGroupFamily"))
    ; description =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Description"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    }
end

module ExportTaskNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module PurchaseReservedDBInstancesOfferingMessage = struct
  type t =
    { reserved_d_b_instances_offering_id : String.t
    ; reserved_d_b_instance_id : String.t option
    ; d_b_instance_count : Integer.t option
    ; tags : TagList.t
    }

  let make
      ~reserved_d_b_instances_offering_id
      ?reserved_d_b_instance_id
      ?d_b_instance_count
      ?(tags = [])
      () =
    { reserved_d_b_instances_offering_id
    ; reserved_d_b_instance_id
    ; d_b_instance_count
    ; tags
    }

  let parse xml =
    Some
      { reserved_d_b_instances_offering_id =
          Aws.Xml.required
            "ReservedDBInstancesOfferingId"
            (Aws.Util.option_bind
               (Aws.Xml.member "ReservedDBInstancesOfferingId" xml)
               String.parse)
      ; reserved_d_b_instance_id =
          Aws.Util.option_bind (Aws.Xml.member "ReservedDBInstanceId" xml) String.parse
      ; d_b_instance_count =
          Aws.Util.option_bind (Aws.Xml.member "DBInstanceCount" xml) Integer.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Aws.Util.option_map v.d_b_instance_count (fun f ->
               Aws.Query.Pair ("DBInstanceCount", Integer.to_query f))
         ; Aws.Util.option_map v.reserved_d_b_instance_id (fun f ->
               Aws.Query.Pair ("ReservedDBInstanceId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ReservedDBInstancesOfferingId"
                , String.to_query v.reserved_d_b_instances_offering_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tags", TagList.to_json v.tags)
         ; Aws.Util.option_map v.d_b_instance_count (fun f ->
               "DBInstanceCount", Integer.to_json f)
         ; Aws.Util.option_map v.reserved_d_b_instance_id (fun f ->
               "ReservedDBInstanceId", String.to_json f)
         ; Some
             ( "ReservedDBInstancesOfferingId"
             , String.to_json v.reserved_d_b_instances_offering_id )
         ])

  let of_json j =
    { reserved_d_b_instances_offering_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ReservedDBInstancesOfferingId"))
    ; reserved_d_b_instance_id =
        Aws.Util.option_map (Aws.Json.lookup j "ReservedDBInstanceId") String.of_json
    ; d_b_instance_count =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstanceCount") Integer.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    }
end

module SourceRegion = struct
  type t =
    { region_name : String.t option
    ; endpoint : String.t option
    ; status : String.t option
    }

  let make ?region_name ?endpoint ?status () = { region_name; endpoint; status }

  let parse xml =
    Some
      { region_name = Aws.Util.option_bind (Aws.Xml.member "RegionName" xml) String.parse
      ; endpoint = Aws.Util.option_bind (Aws.Xml.member "Endpoint" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.endpoint (fun f ->
               Aws.Query.Pair ("Endpoint", String.to_query f))
         ; Aws.Util.option_map v.region_name (fun f ->
               Aws.Query.Pair ("RegionName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ; Aws.Util.option_map v.endpoint (fun f -> "Endpoint", String.to_json f)
         ; Aws.Util.option_map v.region_name (fun f -> "RegionName", String.to_json f)
         ])

  let of_json j =
    { region_name = Aws.Util.option_map (Aws.Json.lookup j "RegionName") String.of_json
    ; endpoint = Aws.Util.option_map (Aws.Json.lookup j "Endpoint") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    }
end

module SourceRegionList = struct
  type t = SourceRegion.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map SourceRegion.parse (Aws.Xml.members "SourceRegion" xml))

  let to_query v = Aws.Query.to_query_list SourceRegion.to_query v

  let to_json v = `List (List.map SourceRegion.to_json v)

  let of_json j = Aws.Json.to_list SourceRegion.of_json j
end

module SourceRegionMessage = struct
  type t =
    { marker : String.t option
    ; source_regions : SourceRegionList.t
    }

  let make ?marker ?(source_regions = []) () = { marker; source_regions }

  let parse xml =
    Some
      { marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; source_regions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SourceRegions" xml)
               SourceRegionList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("SourceRegions.member", SourceRegionList.to_query v.source_regions))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("SourceRegions", SourceRegionList.to_json v.source_regions)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ])

  let of_json j =
    { marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; source_regions =
        SourceRegionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceRegions"))
    }
end

module ModifyEventSubscriptionMessage = struct
  type t =
    { subscription_name : String.t
    ; sns_topic_arn : String.t option
    ; source_type : String.t option
    ; event_categories : EventCategoriesList.t
    ; enabled : Boolean.t option
    }

  let make
      ~subscription_name
      ?sns_topic_arn
      ?source_type
      ?(event_categories = [])
      ?enabled
      () =
    { subscription_name; sns_topic_arn; source_type; event_categories; enabled }

  let parse xml =
    Some
      { subscription_name =
          Aws.Xml.required
            "SubscriptionName"
            (Aws.Util.option_bind (Aws.Xml.member "SubscriptionName" xml) String.parse)
      ; sns_topic_arn =
          Aws.Util.option_bind (Aws.Xml.member "SnsTopicArn" xml) String.parse
      ; source_type = Aws.Util.option_bind (Aws.Xml.member "SourceType" xml) String.parse
      ; event_categories =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "EventCategories" xml)
               EventCategoriesList.parse)
      ; enabled = Aws.Util.option_bind (Aws.Xml.member "Enabled" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enabled (fun f ->
               Aws.Query.Pair ("Enabled", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("EventCategories.member", EventCategoriesList.to_query v.event_categories))
         ; Aws.Util.option_map v.source_type (fun f ->
               Aws.Query.Pair ("SourceType", String.to_query f))
         ; Aws.Util.option_map v.sns_topic_arn (fun f ->
               Aws.Query.Pair ("SnsTopicArn", String.to_query f))
         ; Some (Aws.Query.Pair ("SubscriptionName", String.to_query v.subscription_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enabled (fun f -> "Enabled", Boolean.to_json f)
         ; Some ("EventCategories", EventCategoriesList.to_json v.event_categories)
         ; Aws.Util.option_map v.source_type (fun f -> "SourceType", String.to_json f)
         ; Aws.Util.option_map v.sns_topic_arn (fun f -> "SnsTopicArn", String.to_json f)
         ; Some ("SubscriptionName", String.to_json v.subscription_name)
         ])

  let of_json j =
    { subscription_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SubscriptionName"))
    ; sns_topic_arn = Aws.Util.option_map (Aws.Json.lookup j "SnsTopicArn") String.of_json
    ; source_type = Aws.Util.option_map (Aws.Json.lookup j "SourceType") String.of_json
    ; event_categories =
        EventCategoriesList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "EventCategories"))
    ; enabled = Aws.Util.option_map (Aws.Json.lookup j "Enabled") Boolean.of_json
    }
end

module ModifyDBProxyRequest = struct
  type t =
    { d_b_proxy_name : String.t
    ; new_d_b_proxy_name : String.t option
    ; auth : UserAuthConfigList.t
    ; require_t_l_s : Boolean.t option
    ; idle_client_timeout : Integer.t option
    ; debug_logging : Boolean.t option
    ; role_arn : String.t option
    ; security_groups : StringList.t
    }

  let make
      ~d_b_proxy_name
      ?new_d_b_proxy_name
      ?(auth = [])
      ?require_t_l_s
      ?idle_client_timeout
      ?debug_logging
      ?role_arn
      ?(security_groups = [])
      () =
    { d_b_proxy_name
    ; new_d_b_proxy_name
    ; auth
    ; require_t_l_s
    ; idle_client_timeout
    ; debug_logging
    ; role_arn
    ; security_groups
    }

  let parse xml =
    Some
      { d_b_proxy_name =
          Aws.Xml.required
            "DBProxyName"
            (Aws.Util.option_bind (Aws.Xml.member "DBProxyName" xml) String.parse)
      ; new_d_b_proxy_name =
          Aws.Util.option_bind (Aws.Xml.member "NewDBProxyName" xml) String.parse
      ; auth =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Auth" xml) UserAuthConfigList.parse)
      ; require_t_l_s =
          Aws.Util.option_bind (Aws.Xml.member "RequireTLS" xml) Boolean.parse
      ; idle_client_timeout =
          Aws.Util.option_bind (Aws.Xml.member "IdleClientTimeout" xml) Integer.parse
      ; debug_logging =
          Aws.Util.option_bind (Aws.Xml.member "DebugLogging" xml) Boolean.parse
      ; role_arn = Aws.Util.option_bind (Aws.Xml.member "RoleArn" xml) String.parse
      ; security_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "SecurityGroups" xml) StringList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("SecurityGroups.member", StringList.to_query v.security_groups))
         ; Aws.Util.option_map v.role_arn (fun f ->
               Aws.Query.Pair ("RoleArn", String.to_query f))
         ; Aws.Util.option_map v.debug_logging (fun f ->
               Aws.Query.Pair ("DebugLogging", Boolean.to_query f))
         ; Aws.Util.option_map v.idle_client_timeout (fun f ->
               Aws.Query.Pair ("IdleClientTimeout", Integer.to_query f))
         ; Aws.Util.option_map v.require_t_l_s (fun f ->
               Aws.Query.Pair ("RequireTLS", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Auth.member", UserAuthConfigList.to_query v.auth))
         ; Aws.Util.option_map v.new_d_b_proxy_name (fun f ->
               Aws.Query.Pair ("NewDBProxyName", String.to_query f))
         ; Some (Aws.Query.Pair ("DBProxyName", String.to_query v.d_b_proxy_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("SecurityGroups", StringList.to_json v.security_groups)
         ; Aws.Util.option_map v.role_arn (fun f -> "RoleArn", String.to_json f)
         ; Aws.Util.option_map v.debug_logging (fun f ->
               "DebugLogging", Boolean.to_json f)
         ; Aws.Util.option_map v.idle_client_timeout (fun f ->
               "IdleClientTimeout", Integer.to_json f)
         ; Aws.Util.option_map v.require_t_l_s (fun f -> "RequireTLS", Boolean.to_json f)
         ; Some ("Auth", UserAuthConfigList.to_json v.auth)
         ; Aws.Util.option_map v.new_d_b_proxy_name (fun f ->
               "NewDBProxyName", String.to_json f)
         ; Some ("DBProxyName", String.to_json v.d_b_proxy_name)
         ])

  let of_json j =
    { d_b_proxy_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBProxyName"))
    ; new_d_b_proxy_name =
        Aws.Util.option_map (Aws.Json.lookup j "NewDBProxyName") String.of_json
    ; auth =
        UserAuthConfigList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Auth"))
    ; require_t_l_s = Aws.Util.option_map (Aws.Json.lookup j "RequireTLS") Boolean.of_json
    ; idle_client_timeout =
        Aws.Util.option_map (Aws.Json.lookup j "IdleClientTimeout") Integer.of_json
    ; debug_logging =
        Aws.Util.option_map (Aws.Json.lookup j "DebugLogging") Boolean.of_json
    ; role_arn = Aws.Util.option_map (Aws.Json.lookup j "RoleArn") String.of_json
    ; security_groups =
        StringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SecurityGroups"))
    }
end

module DescribeDBClusterSnapshotsMessage = struct
  type t =
    { d_b_cluster_identifier : String.t option
    ; d_b_cluster_snapshot_identifier : String.t option
    ; snapshot_type : String.t option
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    ; include_shared : Boolean.t option
    ; include_public : Boolean.t option
    }

  let make
      ?d_b_cluster_identifier
      ?d_b_cluster_snapshot_identifier
      ?snapshot_type
      ?(filters = [])
      ?max_records
      ?marker
      ?include_shared
      ?include_public
      () =
    { d_b_cluster_identifier
    ; d_b_cluster_snapshot_identifier
    ; snapshot_type
    ; filters
    ; max_records
    ; marker
    ; include_shared
    ; include_public
    }

  let parse xml =
    Some
      { d_b_cluster_identifier =
          Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse
      ; d_b_cluster_snapshot_identifier =
          Aws.Util.option_bind
            (Aws.Xml.member "DBClusterSnapshotIdentifier" xml)
            String.parse
      ; snapshot_type =
          Aws.Util.option_bind (Aws.Xml.member "SnapshotType" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; include_shared =
          Aws.Util.option_bind (Aws.Xml.member "IncludeShared" xml) Boolean.parse
      ; include_public =
          Aws.Util.option_bind (Aws.Xml.member "IncludePublic" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.include_public (fun f ->
               Aws.Query.Pair ("IncludePublic", Boolean.to_query f))
         ; Aws.Util.option_map v.include_shared (fun f ->
               Aws.Query.Pair ("IncludeShared", Boolean.to_query f))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.snapshot_type (fun f ->
               Aws.Query.Pair ("SnapshotType", String.to_query f))
         ; Aws.Util.option_map v.d_b_cluster_snapshot_identifier (fun f ->
               Aws.Query.Pair ("DBClusterSnapshotIdentifier", String.to_query f))
         ; Aws.Util.option_map v.d_b_cluster_identifier (fun f ->
               Aws.Query.Pair ("DBClusterIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.include_public (fun f ->
               "IncludePublic", Boolean.to_json f)
         ; Aws.Util.option_map v.include_shared (fun f ->
               "IncludeShared", Boolean.to_json f)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.snapshot_type (fun f -> "SnapshotType", String.to_json f)
         ; Aws.Util.option_map v.d_b_cluster_snapshot_identifier (fun f ->
               "DBClusterSnapshotIdentifier", String.to_json f)
         ; Aws.Util.option_map v.d_b_cluster_identifier (fun f ->
               "DBClusterIdentifier", String.to_json f)
         ])

  let of_json j =
    { d_b_cluster_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "DBClusterIdentifier") String.of_json
    ; d_b_cluster_snapshot_identifier =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBClusterSnapshotIdentifier")
          String.of_json
    ; snapshot_type =
        Aws.Util.option_map (Aws.Json.lookup j "SnapshotType") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; include_shared =
        Aws.Util.option_map (Aws.Json.lookup j "IncludeShared") Boolean.of_json
    ; include_public =
        Aws.Util.option_map (Aws.Json.lookup j "IncludePublic") Boolean.of_json
    }
end

module DeleteDBInstanceResult = struct
  type t = { d_b_instance : DBInstance.t option }

  let make ?d_b_instance () = { d_b_instance }

  let parse xml =
    Some
      { d_b_instance =
          Aws.Util.option_bind (Aws.Xml.member "DBInstance" xml) DBInstance.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_instance (fun f ->
               Aws.Query.Pair ("DBInstance", DBInstance.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_instance (fun f ->
               "DBInstance", DBInstance.to_json f)
         ])

  let of_json j =
    { d_b_instance =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstance") DBInstance.of_json
    }
end

module DBSubnetGroupAlreadyExistsFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module PromoteReadReplicaDBClusterMessage = struct
  type t = { d_b_cluster_identifier : String.t }

  let make ~d_b_cluster_identifier () = { d_b_cluster_identifier }

  let parse xml =
    Some
      { d_b_cluster_identifier =
          Aws.Xml.required
            "DBClusterIdentifier"
            (Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("DBClusterIdentifier", String.to_query v.d_b_cluster_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("DBClusterIdentifier", String.to_json v.d_b_cluster_identifier) ])

  let of_json j =
    { d_b_cluster_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterIdentifier"))
    }
end

module InsufficientDBClusterCapacityFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DescribeDBParameterGroupsMessage = struct
  type t =
    { d_b_parameter_group_name : String.t option
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    }

  let make ?d_b_parameter_group_name ?(filters = []) ?max_records ?marker () =
    { d_b_parameter_group_name; filters; max_records; marker }

  let parse xml =
    Some
      { d_b_parameter_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBParameterGroupName" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.d_b_parameter_group_name (fun f ->
               Aws.Query.Pair ("DBParameterGroupName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.d_b_parameter_group_name (fun f ->
               "DBParameterGroupName", String.to_json f)
         ])

  let of_json j =
    { d_b_parameter_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBParameterGroupName") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module OptionGroups = struct
  type t =
    { option_groups_list : OptionGroupsList.t
    ; marker : String.t option
    }

  let make ?(option_groups_list = []) ?marker () = { option_groups_list; marker }

  let parse xml =
    Some
      { option_groups_list =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "OptionGroupsList" xml)
               OptionGroupsList.parse)
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("OptionGroupsList.member", OptionGroupsList.to_query v.option_groups_list))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Some ("OptionGroupsList", OptionGroupsList.to_json v.option_groups_list)
         ])

  let of_json j =
    { option_groups_list =
        OptionGroupsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "OptionGroupsList"))
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module ExportTaskAlreadyExistsFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module CreateCustomAvailabilityZoneMessage = struct
  type t =
    { custom_availability_zone_name : String.t
    ; existing_vpn_id : String.t option
    ; new_vpn_tunnel_name : String.t option
    ; vpn_tunnel_originator_i_p : String.t option
    }

  let make
      ~custom_availability_zone_name
      ?existing_vpn_id
      ?new_vpn_tunnel_name
      ?vpn_tunnel_originator_i_p
      () =
    { custom_availability_zone_name
    ; existing_vpn_id
    ; new_vpn_tunnel_name
    ; vpn_tunnel_originator_i_p
    }

  let parse xml =
    Some
      { custom_availability_zone_name =
          Aws.Xml.required
            "CustomAvailabilityZoneName"
            (Aws.Util.option_bind
               (Aws.Xml.member "CustomAvailabilityZoneName" xml)
               String.parse)
      ; existing_vpn_id =
          Aws.Util.option_bind (Aws.Xml.member "ExistingVpnId" xml) String.parse
      ; new_vpn_tunnel_name =
          Aws.Util.option_bind (Aws.Xml.member "NewVpnTunnelName" xml) String.parse
      ; vpn_tunnel_originator_i_p =
          Aws.Util.option_bind (Aws.Xml.member "VpnTunnelOriginatorIP" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpn_tunnel_originator_i_p (fun f ->
               Aws.Query.Pair ("VpnTunnelOriginatorIP", String.to_query f))
         ; Aws.Util.option_map v.new_vpn_tunnel_name (fun f ->
               Aws.Query.Pair ("NewVpnTunnelName", String.to_query f))
         ; Aws.Util.option_map v.existing_vpn_id (fun f ->
               Aws.Query.Pair ("ExistingVpnId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "CustomAvailabilityZoneName"
                , String.to_query v.custom_availability_zone_name ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpn_tunnel_originator_i_p (fun f ->
               "VpnTunnelOriginatorIP", String.to_json f)
         ; Aws.Util.option_map v.new_vpn_tunnel_name (fun f ->
               "NewVpnTunnelName", String.to_json f)
         ; Aws.Util.option_map v.existing_vpn_id (fun f ->
               "ExistingVpnId", String.to_json f)
         ; Some
             ("CustomAvailabilityZoneName", String.to_json v.custom_availability_zone_name)
         ])

  let of_json j =
    { custom_availability_zone_name =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "CustomAvailabilityZoneName"))
    ; existing_vpn_id =
        Aws.Util.option_map (Aws.Json.lookup j "ExistingVpnId") String.of_json
    ; new_vpn_tunnel_name =
        Aws.Util.option_map (Aws.Json.lookup j "NewVpnTunnelName") String.of_json
    ; vpn_tunnel_originator_i_p =
        Aws.Util.option_map (Aws.Json.lookup j "VpnTunnelOriginatorIP") String.of_json
    }
end

module SourceNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module AuthorizeDBSecurityGroupIngressResult = struct
  type t = { d_b_security_group : DBSecurityGroup.t option }

  let make ?d_b_security_group () = { d_b_security_group }

  let parse xml =
    Some
      { d_b_security_group =
          Aws.Util.option_bind
            (Aws.Xml.member "DBSecurityGroup" xml)
            DBSecurityGroup.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_security_group (fun f ->
               Aws.Query.Pair ("DBSecurityGroup", DBSecurityGroup.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_security_group (fun f ->
               "DBSecurityGroup", DBSecurityGroup.to_json f)
         ])

  let of_json j =
    { d_b_security_group =
        Aws.Util.option_map (Aws.Json.lookup j "DBSecurityGroup") DBSecurityGroup.of_json
    }
end

module CreateDBInstanceReadReplicaMessage = struct
  type t =
    { d_b_instance_identifier : String.t
    ; source_d_b_instance_identifier : String.t
    ; d_b_instance_class : String.t option
    ; availability_zone : String.t option
    ; port : Integer.t option
    ; multi_a_z : Boolean.t option
    ; auto_minor_version_upgrade : Boolean.t option
    ; iops : Integer.t option
    ; option_group_name : String.t option
    ; d_b_parameter_group_name : String.t option
    ; publicly_accessible : Boolean.t option
    ; tags : TagList.t
    ; d_b_subnet_group_name : String.t option
    ; vpc_security_group_ids : VpcSecurityGroupIdList.t
    ; storage_type : String.t option
    ; copy_tags_to_snapshot : Boolean.t option
    ; monitoring_interval : Integer.t option
    ; monitoring_role_arn : String.t option
    ; kms_key_id : String.t option
    ; pre_signed_url : String.t option
    ; enable_i_a_m_database_authentication : Boolean.t option
    ; enable_performance_insights : Boolean.t option
    ; performance_insights_k_m_s_key_id : String.t option
    ; performance_insights_retention_period : Integer.t option
    ; enable_cloudwatch_logs_exports : LogTypeList.t
    ; processor_features : ProcessorFeatureList.t
    ; use_default_processor_features : Boolean.t option
    ; deletion_protection : Boolean.t option
    ; domain : String.t option
    ; domain_i_a_m_role_name : String.t option
    ; replica_mode : ReplicaMode.t option
    ; max_allocated_storage : Integer.t option
    }

  let make
      ~d_b_instance_identifier
      ~source_d_b_instance_identifier
      ?d_b_instance_class
      ?availability_zone
      ?port
      ?multi_a_z
      ?auto_minor_version_upgrade
      ?iops
      ?option_group_name
      ?d_b_parameter_group_name
      ?publicly_accessible
      ?(tags = [])
      ?d_b_subnet_group_name
      ?(vpc_security_group_ids = [])
      ?storage_type
      ?copy_tags_to_snapshot
      ?monitoring_interval
      ?monitoring_role_arn
      ?kms_key_id
      ?pre_signed_url
      ?enable_i_a_m_database_authentication
      ?enable_performance_insights
      ?performance_insights_k_m_s_key_id
      ?performance_insights_retention_period
      ?(enable_cloudwatch_logs_exports = [])
      ?(processor_features = [])
      ?use_default_processor_features
      ?deletion_protection
      ?domain
      ?domain_i_a_m_role_name
      ?replica_mode
      ?max_allocated_storage
      () =
    { d_b_instance_identifier
    ; source_d_b_instance_identifier
    ; d_b_instance_class
    ; availability_zone
    ; port
    ; multi_a_z
    ; auto_minor_version_upgrade
    ; iops
    ; option_group_name
    ; d_b_parameter_group_name
    ; publicly_accessible
    ; tags
    ; d_b_subnet_group_name
    ; vpc_security_group_ids
    ; storage_type
    ; copy_tags_to_snapshot
    ; monitoring_interval
    ; monitoring_role_arn
    ; kms_key_id
    ; pre_signed_url
    ; enable_i_a_m_database_authentication
    ; enable_performance_insights
    ; performance_insights_k_m_s_key_id
    ; performance_insights_retention_period
    ; enable_cloudwatch_logs_exports
    ; processor_features
    ; use_default_processor_features
    ; deletion_protection
    ; domain
    ; domain_i_a_m_role_name
    ; replica_mode
    ; max_allocated_storage
    }

  let parse xml =
    Some
      { d_b_instance_identifier =
          Aws.Xml.required
            "DBInstanceIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBInstanceIdentifier" xml)
               String.parse)
      ; source_d_b_instance_identifier =
          Aws.Xml.required
            "SourceDBInstanceIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "SourceDBInstanceIdentifier" xml)
               String.parse)
      ; d_b_instance_class =
          Aws.Util.option_bind (Aws.Xml.member "DBInstanceClass" xml) String.parse
      ; availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "AvailabilityZone" xml) String.parse
      ; port = Aws.Util.option_bind (Aws.Xml.member "Port" xml) Integer.parse
      ; multi_a_z = Aws.Util.option_bind (Aws.Xml.member "MultiAZ" xml) Boolean.parse
      ; auto_minor_version_upgrade =
          Aws.Util.option_bind
            (Aws.Xml.member "AutoMinorVersionUpgrade" xml)
            Boolean.parse
      ; iops = Aws.Util.option_bind (Aws.Xml.member "Iops" xml) Integer.parse
      ; option_group_name =
          Aws.Util.option_bind (Aws.Xml.member "OptionGroupName" xml) String.parse
      ; d_b_parameter_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBParameterGroupName" xml) String.parse
      ; publicly_accessible =
          Aws.Util.option_bind (Aws.Xml.member "PubliclyAccessible" xml) Boolean.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      ; d_b_subnet_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBSubnetGroupName" xml) String.parse
      ; vpc_security_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "VpcSecurityGroupIds" xml)
               VpcSecurityGroupIdList.parse)
      ; storage_type =
          Aws.Util.option_bind (Aws.Xml.member "StorageType" xml) String.parse
      ; copy_tags_to_snapshot =
          Aws.Util.option_bind (Aws.Xml.member "CopyTagsToSnapshot" xml) Boolean.parse
      ; monitoring_interval =
          Aws.Util.option_bind (Aws.Xml.member "MonitoringInterval" xml) Integer.parse
      ; monitoring_role_arn =
          Aws.Util.option_bind (Aws.Xml.member "MonitoringRoleArn" xml) String.parse
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "KmsKeyId" xml) String.parse
      ; pre_signed_url =
          Aws.Util.option_bind (Aws.Xml.member "PreSignedUrl" xml) String.parse
      ; enable_i_a_m_database_authentication =
          Aws.Util.option_bind
            (Aws.Xml.member "EnableIAMDatabaseAuthentication" xml)
            Boolean.parse
      ; enable_performance_insights =
          Aws.Util.option_bind
            (Aws.Xml.member "EnablePerformanceInsights" xml)
            Boolean.parse
      ; performance_insights_k_m_s_key_id =
          Aws.Util.option_bind
            (Aws.Xml.member "PerformanceInsightsKMSKeyId" xml)
            String.parse
      ; performance_insights_retention_period =
          Aws.Util.option_bind
            (Aws.Xml.member "PerformanceInsightsRetentionPeriod" xml)
            Integer.parse
      ; enable_cloudwatch_logs_exports =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "EnableCloudwatchLogsExports" xml)
               LogTypeList.parse)
      ; processor_features =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ProcessorFeatures" xml)
               ProcessorFeatureList.parse)
      ; use_default_processor_features =
          Aws.Util.option_bind
            (Aws.Xml.member "UseDefaultProcessorFeatures" xml)
            Boolean.parse
      ; deletion_protection =
          Aws.Util.option_bind (Aws.Xml.member "DeletionProtection" xml) Boolean.parse
      ; domain = Aws.Util.option_bind (Aws.Xml.member "Domain" xml) String.parse
      ; domain_i_a_m_role_name =
          Aws.Util.option_bind (Aws.Xml.member "DomainIAMRoleName" xml) String.parse
      ; replica_mode =
          Aws.Util.option_bind (Aws.Xml.member "ReplicaMode" xml) ReplicaMode.parse
      ; max_allocated_storage =
          Aws.Util.option_bind (Aws.Xml.member "MaxAllocatedStorage" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_allocated_storage (fun f ->
               Aws.Query.Pair ("MaxAllocatedStorage", Integer.to_query f))
         ; Aws.Util.option_map v.replica_mode (fun f ->
               Aws.Query.Pair ("ReplicaMode", ReplicaMode.to_query f))
         ; Aws.Util.option_map v.domain_i_a_m_role_name (fun f ->
               Aws.Query.Pair ("DomainIAMRoleName", String.to_query f))
         ; Aws.Util.option_map v.domain (fun f ->
               Aws.Query.Pair ("Domain", String.to_query f))
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               Aws.Query.Pair ("DeletionProtection", Boolean.to_query f))
         ; Aws.Util.option_map v.use_default_processor_features (fun f ->
               Aws.Query.Pair ("UseDefaultProcessorFeatures", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ProcessorFeatures.member"
                , ProcessorFeatureList.to_query v.processor_features ))
         ; Some
             (Aws.Query.Pair
                ( "EnableCloudwatchLogsExports.member"
                , LogTypeList.to_query v.enable_cloudwatch_logs_exports ))
         ; Aws.Util.option_map v.performance_insights_retention_period (fun f ->
               Aws.Query.Pair ("PerformanceInsightsRetentionPeriod", Integer.to_query f))
         ; Aws.Util.option_map v.performance_insights_k_m_s_key_id (fun f ->
               Aws.Query.Pair ("PerformanceInsightsKMSKeyId", String.to_query f))
         ; Aws.Util.option_map v.enable_performance_insights (fun f ->
               Aws.Query.Pair ("EnablePerformanceInsights", Boolean.to_query f))
         ; Aws.Util.option_map v.enable_i_a_m_database_authentication (fun f ->
               Aws.Query.Pair ("EnableIAMDatabaseAuthentication", Boolean.to_query f))
         ; Aws.Util.option_map v.pre_signed_url (fun f ->
               Aws.Query.Pair ("PreSignedUrl", String.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Aws.Util.option_map v.monitoring_role_arn (fun f ->
               Aws.Query.Pair ("MonitoringRoleArn", String.to_query f))
         ; Aws.Util.option_map v.monitoring_interval (fun f ->
               Aws.Query.Pair ("MonitoringInterval", Integer.to_query f))
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               Aws.Query.Pair ("CopyTagsToSnapshot", Boolean.to_query f))
         ; Aws.Util.option_map v.storage_type (fun f ->
               Aws.Query.Pair ("StorageType", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "VpcSecurityGroupIds.member"
                , VpcSecurityGroupIdList.to_query v.vpc_security_group_ids ))
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               Aws.Query.Pair ("DBSubnetGroupName", String.to_query f))
         ; Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Aws.Util.option_map v.publicly_accessible (fun f ->
               Aws.Query.Pair ("PubliclyAccessible", Boolean.to_query f))
         ; Aws.Util.option_map v.d_b_parameter_group_name (fun f ->
               Aws.Query.Pair ("DBParameterGroupName", String.to_query f))
         ; Aws.Util.option_map v.option_group_name (fun f ->
               Aws.Query.Pair ("OptionGroupName", String.to_query f))
         ; Aws.Util.option_map v.iops (fun f ->
               Aws.Query.Pair ("Iops", Integer.to_query f))
         ; Aws.Util.option_map v.auto_minor_version_upgrade (fun f ->
               Aws.Query.Pair ("AutoMinorVersionUpgrade", Boolean.to_query f))
         ; Aws.Util.option_map v.multi_a_z (fun f ->
               Aws.Query.Pair ("MultiAZ", Boolean.to_query f))
         ; Aws.Util.option_map v.port (fun f ->
               Aws.Query.Pair ("Port", Integer.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ; Aws.Util.option_map v.d_b_instance_class (fun f ->
               Aws.Query.Pair ("DBInstanceClass", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "SourceDBInstanceIdentifier"
                , String.to_query v.source_d_b_instance_identifier ))
         ; Some
             (Aws.Query.Pair
                ("DBInstanceIdentifier", String.to_query v.d_b_instance_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_allocated_storage (fun f ->
               "MaxAllocatedStorage", Integer.to_json f)
         ; Aws.Util.option_map v.replica_mode (fun f ->
               "ReplicaMode", ReplicaMode.to_json f)
         ; Aws.Util.option_map v.domain_i_a_m_role_name (fun f ->
               "DomainIAMRoleName", String.to_json f)
         ; Aws.Util.option_map v.domain (fun f -> "Domain", String.to_json f)
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               "DeletionProtection", Boolean.to_json f)
         ; Aws.Util.option_map v.use_default_processor_features (fun f ->
               "UseDefaultProcessorFeatures", Boolean.to_json f)
         ; Some ("ProcessorFeatures", ProcessorFeatureList.to_json v.processor_features)
         ; Some
             ( "EnableCloudwatchLogsExports"
             , LogTypeList.to_json v.enable_cloudwatch_logs_exports )
         ; Aws.Util.option_map v.performance_insights_retention_period (fun f ->
               "PerformanceInsightsRetentionPeriod", Integer.to_json f)
         ; Aws.Util.option_map v.performance_insights_k_m_s_key_id (fun f ->
               "PerformanceInsightsKMSKeyId", String.to_json f)
         ; Aws.Util.option_map v.enable_performance_insights (fun f ->
               "EnablePerformanceInsights", Boolean.to_json f)
         ; Aws.Util.option_map v.enable_i_a_m_database_authentication (fun f ->
               "EnableIAMDatabaseAuthentication", Boolean.to_json f)
         ; Aws.Util.option_map v.pre_signed_url (fun f ->
               "PreSignedUrl", String.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "KmsKeyId", String.to_json f)
         ; Aws.Util.option_map v.monitoring_role_arn (fun f ->
               "MonitoringRoleArn", String.to_json f)
         ; Aws.Util.option_map v.monitoring_interval (fun f ->
               "MonitoringInterval", Integer.to_json f)
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               "CopyTagsToSnapshot", Boolean.to_json f)
         ; Aws.Util.option_map v.storage_type (fun f -> "StorageType", String.to_json f)
         ; Some
             ( "VpcSecurityGroupIds"
             , VpcSecurityGroupIdList.to_json v.vpc_security_group_ids )
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               "DBSubnetGroupName", String.to_json f)
         ; Some ("Tags", TagList.to_json v.tags)
         ; Aws.Util.option_map v.publicly_accessible (fun f ->
               "PubliclyAccessible", Boolean.to_json f)
         ; Aws.Util.option_map v.d_b_parameter_group_name (fun f ->
               "DBParameterGroupName", String.to_json f)
         ; Aws.Util.option_map v.option_group_name (fun f ->
               "OptionGroupName", String.to_json f)
         ; Aws.Util.option_map v.iops (fun f -> "Iops", Integer.to_json f)
         ; Aws.Util.option_map v.auto_minor_version_upgrade (fun f ->
               "AutoMinorVersionUpgrade", Boolean.to_json f)
         ; Aws.Util.option_map v.multi_a_z (fun f -> "MultiAZ", Boolean.to_json f)
         ; Aws.Util.option_map v.port (fun f -> "Port", Integer.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "AvailabilityZone", String.to_json f)
         ; Aws.Util.option_map v.d_b_instance_class (fun f ->
               "DBInstanceClass", String.to_json f)
         ; Some
             ( "SourceDBInstanceIdentifier"
             , String.to_json v.source_d_b_instance_identifier )
         ; Some ("DBInstanceIdentifier", String.to_json v.d_b_instance_identifier)
         ])

  let of_json j =
    { d_b_instance_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBInstanceIdentifier"))
    ; source_d_b_instance_identifier =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceDBInstanceIdentifier"))
    ; d_b_instance_class =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstanceClass") String.of_json
    ; availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "AvailabilityZone") String.of_json
    ; port = Aws.Util.option_map (Aws.Json.lookup j "Port") Integer.of_json
    ; multi_a_z = Aws.Util.option_map (Aws.Json.lookup j "MultiAZ") Boolean.of_json
    ; auto_minor_version_upgrade =
        Aws.Util.option_map (Aws.Json.lookup j "AutoMinorVersionUpgrade") Boolean.of_json
    ; iops = Aws.Util.option_map (Aws.Json.lookup j "Iops") Integer.of_json
    ; option_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "OptionGroupName") String.of_json
    ; d_b_parameter_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBParameterGroupName") String.of_json
    ; publicly_accessible =
        Aws.Util.option_map (Aws.Json.lookup j "PubliclyAccessible") Boolean.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    ; d_b_subnet_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBSubnetGroupName") String.of_json
    ; vpc_security_group_ids =
        VpcSecurityGroupIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcSecurityGroupIds"))
    ; storage_type = Aws.Util.option_map (Aws.Json.lookup j "StorageType") String.of_json
    ; copy_tags_to_snapshot =
        Aws.Util.option_map (Aws.Json.lookup j "CopyTagsToSnapshot") Boolean.of_json
    ; monitoring_interval =
        Aws.Util.option_map (Aws.Json.lookup j "MonitoringInterval") Integer.of_json
    ; monitoring_role_arn =
        Aws.Util.option_map (Aws.Json.lookup j "MonitoringRoleArn") String.of_json
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "KmsKeyId") String.of_json
    ; pre_signed_url =
        Aws.Util.option_map (Aws.Json.lookup j "PreSignedUrl") String.of_json
    ; enable_i_a_m_database_authentication =
        Aws.Util.option_map
          (Aws.Json.lookup j "EnableIAMDatabaseAuthentication")
          Boolean.of_json
    ; enable_performance_insights =
        Aws.Util.option_map
          (Aws.Json.lookup j "EnablePerformanceInsights")
          Boolean.of_json
    ; performance_insights_k_m_s_key_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "PerformanceInsightsKMSKeyId")
          String.of_json
    ; performance_insights_retention_period =
        Aws.Util.option_map
          (Aws.Json.lookup j "PerformanceInsightsRetentionPeriod")
          Integer.of_json
    ; enable_cloudwatch_logs_exports =
        LogTypeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "EnableCloudwatchLogsExports"))
    ; processor_features =
        ProcessorFeatureList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ProcessorFeatures"))
    ; use_default_processor_features =
        Aws.Util.option_map
          (Aws.Json.lookup j "UseDefaultProcessorFeatures")
          Boolean.of_json
    ; deletion_protection =
        Aws.Util.option_map (Aws.Json.lookup j "DeletionProtection") Boolean.of_json
    ; domain = Aws.Util.option_map (Aws.Json.lookup j "Domain") String.of_json
    ; domain_i_a_m_role_name =
        Aws.Util.option_map (Aws.Json.lookup j "DomainIAMRoleName") String.of_json
    ; replica_mode =
        Aws.Util.option_map (Aws.Json.lookup j "ReplicaMode") ReplicaMode.of_json
    ; max_allocated_storage =
        Aws.Util.option_map (Aws.Json.lookup j "MaxAllocatedStorage") Integer.of_json
    }
end

module CertificateMessage = struct
  type t =
    { certificates : CertificateList.t
    ; marker : String.t option
    }

  let make ?(certificates = []) ?marker () = { certificates; marker }

  let parse xml =
    Some
      { certificates =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Certificates" xml)
               CertificateList.parse)
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Certificates.member", CertificateList.to_query v.certificates))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Some ("Certificates", CertificateList.to_json v.certificates)
         ])

  let of_json j =
    { certificates =
        CertificateList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Certificates"))
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module SubscriptionAlreadyExistFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module RestoreDBInstanceFromS3Result = struct
  type t = { d_b_instance : DBInstance.t option }

  let make ?d_b_instance () = { d_b_instance }

  let parse xml =
    Some
      { d_b_instance =
          Aws.Util.option_bind (Aws.Xml.member "DBInstance" xml) DBInstance.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_instance (fun f ->
               Aws.Query.Pair ("DBInstance", DBInstance.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_instance (fun f ->
               "DBInstance", DBInstance.to_json f)
         ])

  let of_json j =
    { d_b_instance =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstance") DBInstance.of_json
    }
end

module DescribeDBEngineVersionsMessage = struct
  type t =
    { engine : String.t option
    ; engine_version : String.t option
    ; d_b_parameter_group_family : String.t option
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    ; default_only : Boolean.t option
    ; list_supported_character_sets : Boolean.t option
    ; list_supported_timezones : Boolean.t option
    ; include_all : Boolean.t option
    }

  let make
      ?engine
      ?engine_version
      ?d_b_parameter_group_family
      ?(filters = [])
      ?max_records
      ?marker
      ?default_only
      ?list_supported_character_sets
      ?list_supported_timezones
      ?include_all
      () =
    { engine
    ; engine_version
    ; d_b_parameter_group_family
    ; filters
    ; max_records
    ; marker
    ; default_only
    ; list_supported_character_sets
    ; list_supported_timezones
    ; include_all
    }

  let parse xml =
    Some
      { engine = Aws.Util.option_bind (Aws.Xml.member "Engine" xml) String.parse
      ; engine_version =
          Aws.Util.option_bind (Aws.Xml.member "EngineVersion" xml) String.parse
      ; d_b_parameter_group_family =
          Aws.Util.option_bind (Aws.Xml.member "DBParameterGroupFamily" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; default_only =
          Aws.Util.option_bind (Aws.Xml.member "DefaultOnly" xml) Boolean.parse
      ; list_supported_character_sets =
          Aws.Util.option_bind
            (Aws.Xml.member "ListSupportedCharacterSets" xml)
            Boolean.parse
      ; list_supported_timezones =
          Aws.Util.option_bind (Aws.Xml.member "ListSupportedTimezones" xml) Boolean.parse
      ; include_all = Aws.Util.option_bind (Aws.Xml.member "IncludeAll" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.include_all (fun f ->
               Aws.Query.Pair ("IncludeAll", Boolean.to_query f))
         ; Aws.Util.option_map v.list_supported_timezones (fun f ->
               Aws.Query.Pair ("ListSupportedTimezones", Boolean.to_query f))
         ; Aws.Util.option_map v.list_supported_character_sets (fun f ->
               Aws.Query.Pair ("ListSupportedCharacterSets", Boolean.to_query f))
         ; Aws.Util.option_map v.default_only (fun f ->
               Aws.Query.Pair ("DefaultOnly", Boolean.to_query f))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.d_b_parameter_group_family (fun f ->
               Aws.Query.Pair ("DBParameterGroupFamily", String.to_query f))
         ; Aws.Util.option_map v.engine_version (fun f ->
               Aws.Query.Pair ("EngineVersion", String.to_query f))
         ; Aws.Util.option_map v.engine (fun f ->
               Aws.Query.Pair ("Engine", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.include_all (fun f -> "IncludeAll", Boolean.to_json f)
         ; Aws.Util.option_map v.list_supported_timezones (fun f ->
               "ListSupportedTimezones", Boolean.to_json f)
         ; Aws.Util.option_map v.list_supported_character_sets (fun f ->
               "ListSupportedCharacterSets", Boolean.to_json f)
         ; Aws.Util.option_map v.default_only (fun f -> "DefaultOnly", Boolean.to_json f)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.d_b_parameter_group_family (fun f ->
               "DBParameterGroupFamily", String.to_json f)
         ; Aws.Util.option_map v.engine_version (fun f ->
               "EngineVersion", String.to_json f)
         ; Aws.Util.option_map v.engine (fun f -> "Engine", String.to_json f)
         ])

  let of_json j =
    { engine = Aws.Util.option_map (Aws.Json.lookup j "Engine") String.of_json
    ; engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "EngineVersion") String.of_json
    ; d_b_parameter_group_family =
        Aws.Util.option_map (Aws.Json.lookup j "DBParameterGroupFamily") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; default_only = Aws.Util.option_map (Aws.Json.lookup j "DefaultOnly") Boolean.of_json
    ; list_supported_character_sets =
        Aws.Util.option_map
          (Aws.Json.lookup j "ListSupportedCharacterSets")
          Boolean.of_json
    ; list_supported_timezones =
        Aws.Util.option_map (Aws.Json.lookup j "ListSupportedTimezones") Boolean.of_json
    ; include_all = Aws.Util.option_map (Aws.Json.lookup j "IncludeAll") Boolean.of_json
    }
end

module DeleteOptionGroupMessage = struct
  type t = { option_group_name : String.t }

  let make ~option_group_name () = { option_group_name }

  let parse xml =
    Some
      { option_group_name =
          Aws.Xml.required
            "OptionGroupName"
            (Aws.Util.option_bind (Aws.Xml.member "OptionGroupName" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("OptionGroupName", String.to_query v.option_group_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("OptionGroupName", String.to_json v.option_group_name) ])

  let of_json j =
    { option_group_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "OptionGroupName"))
    }
end

module CreateDBClusterParameterGroupMessage = struct
  type t =
    { d_b_cluster_parameter_group_name : String.t
    ; d_b_parameter_group_family : String.t
    ; description : String.t
    ; tags : TagList.t
    }

  let make
      ~d_b_cluster_parameter_group_name
      ~d_b_parameter_group_family
      ~description
      ?(tags = [])
      () =
    { d_b_cluster_parameter_group_name; d_b_parameter_group_family; description; tags }

  let parse xml =
    Some
      { d_b_cluster_parameter_group_name =
          Aws.Xml.required
            "DBClusterParameterGroupName"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBClusterParameterGroupName" xml)
               String.parse)
      ; d_b_parameter_group_family =
          Aws.Xml.required
            "DBParameterGroupFamily"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBParameterGroupFamily" xml)
               String.parse)
      ; description =
          Aws.Xml.required
            "Description"
            (Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Some (Aws.Query.Pair ("Description", String.to_query v.description))
         ; Some
             (Aws.Query.Pair
                ("DBParameterGroupFamily", String.to_query v.d_b_parameter_group_family))
         ; Some
             (Aws.Query.Pair
                ( "DBClusterParameterGroupName"
                , String.to_query v.d_b_cluster_parameter_group_name ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tags", TagList.to_json v.tags)
         ; Some ("Description", String.to_json v.description)
         ; Some ("DBParameterGroupFamily", String.to_json v.d_b_parameter_group_family)
         ; Some
             ( "DBClusterParameterGroupName"
             , String.to_json v.d_b_cluster_parameter_group_name )
         ])

  let of_json j =
    { d_b_cluster_parameter_group_name =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterParameterGroupName"))
    ; d_b_parameter_group_family =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBParameterGroupFamily"))
    ; description =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Description"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    }
end

module ApplyPendingMaintenanceActionMessage = struct
  type t =
    { resource_identifier : String.t
    ; apply_action : String.t
    ; opt_in_type : String.t
    }

  let make ~resource_identifier ~apply_action ~opt_in_type () =
    { resource_identifier; apply_action; opt_in_type }

  let parse xml =
    Some
      { resource_identifier =
          Aws.Xml.required
            "ResourceIdentifier"
            (Aws.Util.option_bind (Aws.Xml.member "ResourceIdentifier" xml) String.parse)
      ; apply_action =
          Aws.Xml.required
            "ApplyAction"
            (Aws.Util.option_bind (Aws.Xml.member "ApplyAction" xml) String.parse)
      ; opt_in_type =
          Aws.Xml.required
            "OptInType"
            (Aws.Util.option_bind (Aws.Xml.member "OptInType" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("OptInType", String.to_query v.opt_in_type))
         ; Some (Aws.Query.Pair ("ApplyAction", String.to_query v.apply_action))
         ; Some
             (Aws.Query.Pair ("ResourceIdentifier", String.to_query v.resource_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("OptInType", String.to_json v.opt_in_type)
         ; Some ("ApplyAction", String.to_json v.apply_action)
         ; Some ("ResourceIdentifier", String.to_json v.resource_identifier)
         ])

  let of_json j =
    { resource_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ResourceIdentifier"))
    ; apply_action =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ApplyAction"))
    ; opt_in_type =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "OptInType"))
    }
end

module RestoreDBInstanceToPointInTimeResult = struct
  type t = { d_b_instance : DBInstance.t option }

  let make ?d_b_instance () = { d_b_instance }

  let parse xml =
    Some
      { d_b_instance =
          Aws.Util.option_bind (Aws.Xml.member "DBInstance" xml) DBInstance.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_instance (fun f ->
               Aws.Query.Pair ("DBInstance", DBInstance.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_instance (fun f ->
               "DBInstance", DBInstance.to_json f)
         ])

  let of_json j =
    { d_b_instance =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstance") DBInstance.of_json
    }
end

module PurchaseReservedDBInstancesOfferingResult = struct
  type t = { reserved_d_b_instance : ReservedDBInstance.t option }

  let make ?reserved_d_b_instance () = { reserved_d_b_instance }

  let parse xml =
    Some
      { reserved_d_b_instance =
          Aws.Util.option_bind
            (Aws.Xml.member "ReservedDBInstance" xml)
            ReservedDBInstance.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.reserved_d_b_instance (fun f ->
               Aws.Query.Pair ("ReservedDBInstance", ReservedDBInstance.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.reserved_d_b_instance (fun f ->
               "ReservedDBInstance", ReservedDBInstance.to_json f)
         ])

  let of_json j =
    { reserved_d_b_instance =
        Aws.Util.option_map
          (Aws.Json.lookup j "ReservedDBInstance")
          ReservedDBInstance.of_json
    }
end

module CreateDBSecurityGroupMessage = struct
  type t =
    { d_b_security_group_name : String.t
    ; d_b_security_group_description : String.t
    ; tags : TagList.t
    }

  let make ~d_b_security_group_name ~d_b_security_group_description ?(tags = []) () =
    { d_b_security_group_name; d_b_security_group_description; tags }

  let parse xml =
    Some
      { d_b_security_group_name =
          Aws.Xml.required
            "DBSecurityGroupName"
            (Aws.Util.option_bind (Aws.Xml.member "DBSecurityGroupName" xml) String.parse)
      ; d_b_security_group_description =
          Aws.Xml.required
            "DBSecurityGroupDescription"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBSecurityGroupDescription" xml)
               String.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Some
             (Aws.Query.Pair
                ( "DBSecurityGroupDescription"
                , String.to_query v.d_b_security_group_description ))
         ; Some
             (Aws.Query.Pair
                ("DBSecurityGroupName", String.to_query v.d_b_security_group_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tags", TagList.to_json v.tags)
         ; Some
             ( "DBSecurityGroupDescription"
             , String.to_json v.d_b_security_group_description )
         ; Some ("DBSecurityGroupName", String.to_json v.d_b_security_group_name)
         ])

  let of_json j =
    { d_b_security_group_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBSecurityGroupName"))
    ; d_b_security_group_description =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBSecurityGroupDescription"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    }
end

module GlobalClusterList = struct
  type t = GlobalCluster.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map GlobalCluster.parse (Aws.Xml.members "GlobalClusterMember" xml))

  let to_query v = Aws.Query.to_query_list GlobalCluster.to_query v

  let to_json v = `List (List.map GlobalCluster.to_json v)

  let of_json j = Aws.Json.to_list GlobalCluster.of_json j
end

module DBClusterRoleQuotaExceededFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module RestoreDBInstanceFromDBSnapshotMessage = struct
  type t =
    { d_b_instance_identifier : String.t
    ; d_b_snapshot_identifier : String.t
    ; d_b_instance_class : String.t option
    ; port : Integer.t option
    ; availability_zone : String.t option
    ; d_b_subnet_group_name : String.t option
    ; multi_a_z : Boolean.t option
    ; publicly_accessible : Boolean.t option
    ; auto_minor_version_upgrade : Boolean.t option
    ; license_model : String.t option
    ; d_b_name : String.t option
    ; engine : String.t option
    ; iops : Integer.t option
    ; option_group_name : String.t option
    ; tags : TagList.t
    ; storage_type : String.t option
    ; tde_credential_arn : String.t option
    ; tde_credential_password : String.t option
    ; vpc_security_group_ids : VpcSecurityGroupIdList.t
    ; domain : String.t option
    ; copy_tags_to_snapshot : Boolean.t option
    ; domain_i_a_m_role_name : String.t option
    ; enable_i_a_m_database_authentication : Boolean.t option
    ; enable_cloudwatch_logs_exports : LogTypeList.t
    ; processor_features : ProcessorFeatureList.t
    ; use_default_processor_features : Boolean.t option
    ; d_b_parameter_group_name : String.t option
    ; deletion_protection : Boolean.t option
    }

  let make
      ~d_b_instance_identifier
      ~d_b_snapshot_identifier
      ?d_b_instance_class
      ?port
      ?availability_zone
      ?d_b_subnet_group_name
      ?multi_a_z
      ?publicly_accessible
      ?auto_minor_version_upgrade
      ?license_model
      ?d_b_name
      ?engine
      ?iops
      ?option_group_name
      ?(tags = [])
      ?storage_type
      ?tde_credential_arn
      ?tde_credential_password
      ?(vpc_security_group_ids = [])
      ?domain
      ?copy_tags_to_snapshot
      ?domain_i_a_m_role_name
      ?enable_i_a_m_database_authentication
      ?(enable_cloudwatch_logs_exports = [])
      ?(processor_features = [])
      ?use_default_processor_features
      ?d_b_parameter_group_name
      ?deletion_protection
      () =
    { d_b_instance_identifier
    ; d_b_snapshot_identifier
    ; d_b_instance_class
    ; port
    ; availability_zone
    ; d_b_subnet_group_name
    ; multi_a_z
    ; publicly_accessible
    ; auto_minor_version_upgrade
    ; license_model
    ; d_b_name
    ; engine
    ; iops
    ; option_group_name
    ; tags
    ; storage_type
    ; tde_credential_arn
    ; tde_credential_password
    ; vpc_security_group_ids
    ; domain
    ; copy_tags_to_snapshot
    ; domain_i_a_m_role_name
    ; enable_i_a_m_database_authentication
    ; enable_cloudwatch_logs_exports
    ; processor_features
    ; use_default_processor_features
    ; d_b_parameter_group_name
    ; deletion_protection
    }

  let parse xml =
    Some
      { d_b_instance_identifier =
          Aws.Xml.required
            "DBInstanceIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBInstanceIdentifier" xml)
               String.parse)
      ; d_b_snapshot_identifier =
          Aws.Xml.required
            "DBSnapshotIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBSnapshotIdentifier" xml)
               String.parse)
      ; d_b_instance_class =
          Aws.Util.option_bind (Aws.Xml.member "DBInstanceClass" xml) String.parse
      ; port = Aws.Util.option_bind (Aws.Xml.member "Port" xml) Integer.parse
      ; availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "AvailabilityZone" xml) String.parse
      ; d_b_subnet_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBSubnetGroupName" xml) String.parse
      ; multi_a_z = Aws.Util.option_bind (Aws.Xml.member "MultiAZ" xml) Boolean.parse
      ; publicly_accessible =
          Aws.Util.option_bind (Aws.Xml.member "PubliclyAccessible" xml) Boolean.parse
      ; auto_minor_version_upgrade =
          Aws.Util.option_bind
            (Aws.Xml.member "AutoMinorVersionUpgrade" xml)
            Boolean.parse
      ; license_model =
          Aws.Util.option_bind (Aws.Xml.member "LicenseModel" xml) String.parse
      ; d_b_name = Aws.Util.option_bind (Aws.Xml.member "DBName" xml) String.parse
      ; engine = Aws.Util.option_bind (Aws.Xml.member "Engine" xml) String.parse
      ; iops = Aws.Util.option_bind (Aws.Xml.member "Iops" xml) Integer.parse
      ; option_group_name =
          Aws.Util.option_bind (Aws.Xml.member "OptionGroupName" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      ; storage_type =
          Aws.Util.option_bind (Aws.Xml.member "StorageType" xml) String.parse
      ; tde_credential_arn =
          Aws.Util.option_bind (Aws.Xml.member "TdeCredentialArn" xml) String.parse
      ; tde_credential_password =
          Aws.Util.option_bind (Aws.Xml.member "TdeCredentialPassword" xml) String.parse
      ; vpc_security_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "VpcSecurityGroupIds" xml)
               VpcSecurityGroupIdList.parse)
      ; domain = Aws.Util.option_bind (Aws.Xml.member "Domain" xml) String.parse
      ; copy_tags_to_snapshot =
          Aws.Util.option_bind (Aws.Xml.member "CopyTagsToSnapshot" xml) Boolean.parse
      ; domain_i_a_m_role_name =
          Aws.Util.option_bind (Aws.Xml.member "DomainIAMRoleName" xml) String.parse
      ; enable_i_a_m_database_authentication =
          Aws.Util.option_bind
            (Aws.Xml.member "EnableIAMDatabaseAuthentication" xml)
            Boolean.parse
      ; enable_cloudwatch_logs_exports =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "EnableCloudwatchLogsExports" xml)
               LogTypeList.parse)
      ; processor_features =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ProcessorFeatures" xml)
               ProcessorFeatureList.parse)
      ; use_default_processor_features =
          Aws.Util.option_bind
            (Aws.Xml.member "UseDefaultProcessorFeatures" xml)
            Boolean.parse
      ; d_b_parameter_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBParameterGroupName" xml) String.parse
      ; deletion_protection =
          Aws.Util.option_bind (Aws.Xml.member "DeletionProtection" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.deletion_protection (fun f ->
               Aws.Query.Pair ("DeletionProtection", Boolean.to_query f))
         ; Aws.Util.option_map v.d_b_parameter_group_name (fun f ->
               Aws.Query.Pair ("DBParameterGroupName", String.to_query f))
         ; Aws.Util.option_map v.use_default_processor_features (fun f ->
               Aws.Query.Pair ("UseDefaultProcessorFeatures", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ProcessorFeatures.member"
                , ProcessorFeatureList.to_query v.processor_features ))
         ; Some
             (Aws.Query.Pair
                ( "EnableCloudwatchLogsExports.member"
                , LogTypeList.to_query v.enable_cloudwatch_logs_exports ))
         ; Aws.Util.option_map v.enable_i_a_m_database_authentication (fun f ->
               Aws.Query.Pair ("EnableIAMDatabaseAuthentication", Boolean.to_query f))
         ; Aws.Util.option_map v.domain_i_a_m_role_name (fun f ->
               Aws.Query.Pair ("DomainIAMRoleName", String.to_query f))
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               Aws.Query.Pair ("CopyTagsToSnapshot", Boolean.to_query f))
         ; Aws.Util.option_map v.domain (fun f ->
               Aws.Query.Pair ("Domain", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "VpcSecurityGroupIds.member"
                , VpcSecurityGroupIdList.to_query v.vpc_security_group_ids ))
         ; Aws.Util.option_map v.tde_credential_password (fun f ->
               Aws.Query.Pair ("TdeCredentialPassword", String.to_query f))
         ; Aws.Util.option_map v.tde_credential_arn (fun f ->
               Aws.Query.Pair ("TdeCredentialArn", String.to_query f))
         ; Aws.Util.option_map v.storage_type (fun f ->
               Aws.Query.Pair ("StorageType", String.to_query f))
         ; Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Aws.Util.option_map v.option_group_name (fun f ->
               Aws.Query.Pair ("OptionGroupName", String.to_query f))
         ; Aws.Util.option_map v.iops (fun f ->
               Aws.Query.Pair ("Iops", Integer.to_query f))
         ; Aws.Util.option_map v.engine (fun f ->
               Aws.Query.Pair ("Engine", String.to_query f))
         ; Aws.Util.option_map v.d_b_name (fun f ->
               Aws.Query.Pair ("DBName", String.to_query f))
         ; Aws.Util.option_map v.license_model (fun f ->
               Aws.Query.Pair ("LicenseModel", String.to_query f))
         ; Aws.Util.option_map v.auto_minor_version_upgrade (fun f ->
               Aws.Query.Pair ("AutoMinorVersionUpgrade", Boolean.to_query f))
         ; Aws.Util.option_map v.publicly_accessible (fun f ->
               Aws.Query.Pair ("PubliclyAccessible", Boolean.to_query f))
         ; Aws.Util.option_map v.multi_a_z (fun f ->
               Aws.Query.Pair ("MultiAZ", Boolean.to_query f))
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               Aws.Query.Pair ("DBSubnetGroupName", String.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ; Aws.Util.option_map v.port (fun f ->
               Aws.Query.Pair ("Port", Integer.to_query f))
         ; Aws.Util.option_map v.d_b_instance_class (fun f ->
               Aws.Query.Pair ("DBInstanceClass", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DBSnapshotIdentifier", String.to_query v.d_b_snapshot_identifier))
         ; Some
             (Aws.Query.Pair
                ("DBInstanceIdentifier", String.to_query v.d_b_instance_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.deletion_protection (fun f ->
               "DeletionProtection", Boolean.to_json f)
         ; Aws.Util.option_map v.d_b_parameter_group_name (fun f ->
               "DBParameterGroupName", String.to_json f)
         ; Aws.Util.option_map v.use_default_processor_features (fun f ->
               "UseDefaultProcessorFeatures", Boolean.to_json f)
         ; Some ("ProcessorFeatures", ProcessorFeatureList.to_json v.processor_features)
         ; Some
             ( "EnableCloudwatchLogsExports"
             , LogTypeList.to_json v.enable_cloudwatch_logs_exports )
         ; Aws.Util.option_map v.enable_i_a_m_database_authentication (fun f ->
               "EnableIAMDatabaseAuthentication", Boolean.to_json f)
         ; Aws.Util.option_map v.domain_i_a_m_role_name (fun f ->
               "DomainIAMRoleName", String.to_json f)
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               "CopyTagsToSnapshot", Boolean.to_json f)
         ; Aws.Util.option_map v.domain (fun f -> "Domain", String.to_json f)
         ; Some
             ( "VpcSecurityGroupIds"
             , VpcSecurityGroupIdList.to_json v.vpc_security_group_ids )
         ; Aws.Util.option_map v.tde_credential_password (fun f ->
               "TdeCredentialPassword", String.to_json f)
         ; Aws.Util.option_map v.tde_credential_arn (fun f ->
               "TdeCredentialArn", String.to_json f)
         ; Aws.Util.option_map v.storage_type (fun f -> "StorageType", String.to_json f)
         ; Some ("Tags", TagList.to_json v.tags)
         ; Aws.Util.option_map v.option_group_name (fun f ->
               "OptionGroupName", String.to_json f)
         ; Aws.Util.option_map v.iops (fun f -> "Iops", Integer.to_json f)
         ; Aws.Util.option_map v.engine (fun f -> "Engine", String.to_json f)
         ; Aws.Util.option_map v.d_b_name (fun f -> "DBName", String.to_json f)
         ; Aws.Util.option_map v.license_model (fun f -> "LicenseModel", String.to_json f)
         ; Aws.Util.option_map v.auto_minor_version_upgrade (fun f ->
               "AutoMinorVersionUpgrade", Boolean.to_json f)
         ; Aws.Util.option_map v.publicly_accessible (fun f ->
               "PubliclyAccessible", Boolean.to_json f)
         ; Aws.Util.option_map v.multi_a_z (fun f -> "MultiAZ", Boolean.to_json f)
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               "DBSubnetGroupName", String.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "AvailabilityZone", String.to_json f)
         ; Aws.Util.option_map v.port (fun f -> "Port", Integer.to_json f)
         ; Aws.Util.option_map v.d_b_instance_class (fun f ->
               "DBInstanceClass", String.to_json f)
         ; Some ("DBSnapshotIdentifier", String.to_json v.d_b_snapshot_identifier)
         ; Some ("DBInstanceIdentifier", String.to_json v.d_b_instance_identifier)
         ])

  let of_json j =
    { d_b_instance_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBInstanceIdentifier"))
    ; d_b_snapshot_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBSnapshotIdentifier"))
    ; d_b_instance_class =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstanceClass") String.of_json
    ; port = Aws.Util.option_map (Aws.Json.lookup j "Port") Integer.of_json
    ; availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "AvailabilityZone") String.of_json
    ; d_b_subnet_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBSubnetGroupName") String.of_json
    ; multi_a_z = Aws.Util.option_map (Aws.Json.lookup j "MultiAZ") Boolean.of_json
    ; publicly_accessible =
        Aws.Util.option_map (Aws.Json.lookup j "PubliclyAccessible") Boolean.of_json
    ; auto_minor_version_upgrade =
        Aws.Util.option_map (Aws.Json.lookup j "AutoMinorVersionUpgrade") Boolean.of_json
    ; license_model =
        Aws.Util.option_map (Aws.Json.lookup j "LicenseModel") String.of_json
    ; d_b_name = Aws.Util.option_map (Aws.Json.lookup j "DBName") String.of_json
    ; engine = Aws.Util.option_map (Aws.Json.lookup j "Engine") String.of_json
    ; iops = Aws.Util.option_map (Aws.Json.lookup j "Iops") Integer.of_json
    ; option_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "OptionGroupName") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    ; storage_type = Aws.Util.option_map (Aws.Json.lookup j "StorageType") String.of_json
    ; tde_credential_arn =
        Aws.Util.option_map (Aws.Json.lookup j "TdeCredentialArn") String.of_json
    ; tde_credential_password =
        Aws.Util.option_map (Aws.Json.lookup j "TdeCredentialPassword") String.of_json
    ; vpc_security_group_ids =
        VpcSecurityGroupIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcSecurityGroupIds"))
    ; domain = Aws.Util.option_map (Aws.Json.lookup j "Domain") String.of_json
    ; copy_tags_to_snapshot =
        Aws.Util.option_map (Aws.Json.lookup j "CopyTagsToSnapshot") Boolean.of_json
    ; domain_i_a_m_role_name =
        Aws.Util.option_map (Aws.Json.lookup j "DomainIAMRoleName") String.of_json
    ; enable_i_a_m_database_authentication =
        Aws.Util.option_map
          (Aws.Json.lookup j "EnableIAMDatabaseAuthentication")
          Boolean.of_json
    ; enable_cloudwatch_logs_exports =
        LogTypeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "EnableCloudwatchLogsExports"))
    ; processor_features =
        ProcessorFeatureList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ProcessorFeatures"))
    ; use_default_processor_features =
        Aws.Util.option_map
          (Aws.Json.lookup j "UseDefaultProcessorFeatures")
          Boolean.of_json
    ; d_b_parameter_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBParameterGroupName") String.of_json
    ; deletion_protection =
        Aws.Util.option_map (Aws.Json.lookup j "DeletionProtection") Boolean.of_json
    }
end

module RemoveSourceIdentifierFromSubscriptionResult = struct
  type t = { event_subscription : EventSubscription.t option }

  let make ?event_subscription () = { event_subscription }

  let parse xml =
    Some
      { event_subscription =
          Aws.Util.option_bind
            (Aws.Xml.member "EventSubscription" xml)
            EventSubscription.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.event_subscription (fun f ->
               Aws.Query.Pair ("EventSubscription", EventSubscription.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.event_subscription (fun f ->
               "EventSubscription", EventSubscription.to_json f)
         ])

  let of_json j =
    { event_subscription =
        Aws.Util.option_map
          (Aws.Json.lookup j "EventSubscription")
          EventSubscription.of_json
    }
end

module CopyOptionGroupResult = struct
  type t = { option_group : OptionGroup.t option }

  let make ?option_group () = { option_group }

  let parse xml =
    Some
      { option_group =
          Aws.Util.option_bind (Aws.Xml.member "OptionGroup" xml) OptionGroup.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.option_group (fun f ->
               Aws.Query.Pair ("OptionGroup", OptionGroup.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.option_group (fun f ->
               "OptionGroup", OptionGroup.to_json f)
         ])

  let of_json j =
    { option_group =
        Aws.Util.option_map (Aws.Json.lookup j "OptionGroup") OptionGroup.of_json
    }
end

module DBClusterParameterGroupDetails = struct
  type t =
    { parameters : ParametersList.t
    ; marker : String.t option
    }

  let make ?(parameters = []) ?marker () = { parameters; marker }

  let parse xml =
    Some
      { parameters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Parameters" xml) ParametersList.parse)
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Some
             (Aws.Query.Pair ("Parameters.member", ParametersList.to_query v.parameters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Some ("Parameters", ParametersList.to_json v.parameters)
         ])

  let of_json j =
    { parameters =
        ParametersList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Parameters"))
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module DescribeReservedDBInstancesMessage = struct
  type t =
    { reserved_d_b_instance_id : String.t option
    ; reserved_d_b_instances_offering_id : String.t option
    ; d_b_instance_class : String.t option
    ; duration : String.t option
    ; product_description : String.t option
    ; offering_type : String.t option
    ; multi_a_z : Boolean.t option
    ; lease_id : String.t option
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    }

  let make
      ?reserved_d_b_instance_id
      ?reserved_d_b_instances_offering_id
      ?d_b_instance_class
      ?duration
      ?product_description
      ?offering_type
      ?multi_a_z
      ?lease_id
      ?(filters = [])
      ?max_records
      ?marker
      () =
    { reserved_d_b_instance_id
    ; reserved_d_b_instances_offering_id
    ; d_b_instance_class
    ; duration
    ; product_description
    ; offering_type
    ; multi_a_z
    ; lease_id
    ; filters
    ; max_records
    ; marker
    }

  let parse xml =
    Some
      { reserved_d_b_instance_id =
          Aws.Util.option_bind (Aws.Xml.member "ReservedDBInstanceId" xml) String.parse
      ; reserved_d_b_instances_offering_id =
          Aws.Util.option_bind
            (Aws.Xml.member "ReservedDBInstancesOfferingId" xml)
            String.parse
      ; d_b_instance_class =
          Aws.Util.option_bind (Aws.Xml.member "DBInstanceClass" xml) String.parse
      ; duration = Aws.Util.option_bind (Aws.Xml.member "Duration" xml) String.parse
      ; product_description =
          Aws.Util.option_bind (Aws.Xml.member "ProductDescription" xml) String.parse
      ; offering_type =
          Aws.Util.option_bind (Aws.Xml.member "OfferingType" xml) String.parse
      ; multi_a_z = Aws.Util.option_bind (Aws.Xml.member "MultiAZ" xml) Boolean.parse
      ; lease_id = Aws.Util.option_bind (Aws.Xml.member "LeaseId" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.lease_id (fun f ->
               Aws.Query.Pair ("LeaseId", String.to_query f))
         ; Aws.Util.option_map v.multi_a_z (fun f ->
               Aws.Query.Pair ("MultiAZ", Boolean.to_query f))
         ; Aws.Util.option_map v.offering_type (fun f ->
               Aws.Query.Pair ("OfferingType", String.to_query f))
         ; Aws.Util.option_map v.product_description (fun f ->
               Aws.Query.Pair ("ProductDescription", String.to_query f))
         ; Aws.Util.option_map v.duration (fun f ->
               Aws.Query.Pair ("Duration", String.to_query f))
         ; Aws.Util.option_map v.d_b_instance_class (fun f ->
               Aws.Query.Pair ("DBInstanceClass", String.to_query f))
         ; Aws.Util.option_map v.reserved_d_b_instances_offering_id (fun f ->
               Aws.Query.Pair ("ReservedDBInstancesOfferingId", String.to_query f))
         ; Aws.Util.option_map v.reserved_d_b_instance_id (fun f ->
               Aws.Query.Pair ("ReservedDBInstanceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.lease_id (fun f -> "LeaseId", String.to_json f)
         ; Aws.Util.option_map v.multi_a_z (fun f -> "MultiAZ", Boolean.to_json f)
         ; Aws.Util.option_map v.offering_type (fun f -> "OfferingType", String.to_json f)
         ; Aws.Util.option_map v.product_description (fun f ->
               "ProductDescription", String.to_json f)
         ; Aws.Util.option_map v.duration (fun f -> "Duration", String.to_json f)
         ; Aws.Util.option_map v.d_b_instance_class (fun f ->
               "DBInstanceClass", String.to_json f)
         ; Aws.Util.option_map v.reserved_d_b_instances_offering_id (fun f ->
               "ReservedDBInstancesOfferingId", String.to_json f)
         ; Aws.Util.option_map v.reserved_d_b_instance_id (fun f ->
               "ReservedDBInstanceId", String.to_json f)
         ])

  let of_json j =
    { reserved_d_b_instance_id =
        Aws.Util.option_map (Aws.Json.lookup j "ReservedDBInstanceId") String.of_json
    ; reserved_d_b_instances_offering_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "ReservedDBInstancesOfferingId")
          String.of_json
    ; d_b_instance_class =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstanceClass") String.of_json
    ; duration = Aws.Util.option_map (Aws.Json.lookup j "Duration") String.of_json
    ; product_description =
        Aws.Util.option_map (Aws.Json.lookup j "ProductDescription") String.of_json
    ; offering_type =
        Aws.Util.option_map (Aws.Json.lookup j "OfferingType") String.of_json
    ; multi_a_z = Aws.Util.option_map (Aws.Json.lookup j "MultiAZ") Boolean.of_json
    ; lease_id = Aws.Util.option_map (Aws.Json.lookup j "LeaseId") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module OptionGroupQuotaExceededFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module SNSTopicArnNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DescribeDBLogFilesDetails = struct
  type t =
    { log_file_name : String.t option
    ; last_written : Long.t option
    ; size : Long.t option
    }

  let make ?log_file_name ?last_written ?size () = { log_file_name; last_written; size }

  let parse xml =
    Some
      { log_file_name =
          Aws.Util.option_bind (Aws.Xml.member "LogFileName" xml) String.parse
      ; last_written = Aws.Util.option_bind (Aws.Xml.member "LastWritten" xml) Long.parse
      ; size = Aws.Util.option_bind (Aws.Xml.member "Size" xml) Long.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.size (fun f -> Aws.Query.Pair ("Size", Long.to_query f))
         ; Aws.Util.option_map v.last_written (fun f ->
               Aws.Query.Pair ("LastWritten", Long.to_query f))
         ; Aws.Util.option_map v.log_file_name (fun f ->
               Aws.Query.Pair ("LogFileName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.size (fun f -> "Size", Long.to_json f)
         ; Aws.Util.option_map v.last_written (fun f -> "LastWritten", Long.to_json f)
         ; Aws.Util.option_map v.log_file_name (fun f -> "LogFileName", String.to_json f)
         ])

  let of_json j =
    { log_file_name = Aws.Util.option_map (Aws.Json.lookup j "LogFileName") String.of_json
    ; last_written = Aws.Util.option_map (Aws.Json.lookup j "LastWritten") Long.of_json
    ; size = Aws.Util.option_map (Aws.Json.lookup j "Size") Long.of_json
    }
end

module DescribeDBLogFilesList = struct
  type t = DescribeDBLogFilesDetails.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         DescribeDBLogFilesDetails.parse
         (Aws.Xml.members "DescribeDBLogFilesDetails" xml))

  let to_query v = Aws.Query.to_query_list DescribeDBLogFilesDetails.to_query v

  let to_json v = `List (List.map DescribeDBLogFilesDetails.to_json v)

  let of_json j = Aws.Json.to_list DescribeDBLogFilesDetails.of_json j
end

module DescribeDBLogFilesResponse = struct
  type t =
    { describe_d_b_log_files : DescribeDBLogFilesList.t
    ; marker : String.t option
    }

  let make ?(describe_d_b_log_files = []) ?marker () = { describe_d_b_log_files; marker }

  let parse xml =
    Some
      { describe_d_b_log_files =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DescribeDBLogFiles" xml)
               DescribeDBLogFilesList.parse)
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "DescribeDBLogFiles.member"
                , DescribeDBLogFilesList.to_query v.describe_d_b_log_files ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Some
             ( "DescribeDBLogFiles"
             , DescribeDBLogFilesList.to_json v.describe_d_b_log_files )
         ])

  let of_json j =
    { describe_d_b_log_files =
        DescribeDBLogFilesList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DescribeDBLogFiles"))
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module DBInstanceRoleAlreadyExistsFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DBClusterParameterGroupsMessage = struct
  type t =
    { marker : String.t option
    ; d_b_cluster_parameter_groups : DBClusterParameterGroupList.t
    }

  let make ?marker ?(d_b_cluster_parameter_groups = []) () =
    { marker; d_b_cluster_parameter_groups }

  let parse xml =
    Some
      { marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; d_b_cluster_parameter_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DBClusterParameterGroups" xml)
               DBClusterParameterGroupList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "DBClusterParameterGroups.member"
                , DBClusterParameterGroupList.to_query v.d_b_cluster_parameter_groups ))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "DBClusterParameterGroups"
             , DBClusterParameterGroupList.to_json v.d_b_cluster_parameter_groups )
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ])

  let of_json j =
    { marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; d_b_cluster_parameter_groups =
        DBClusterParameterGroupList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterParameterGroups"))
    }
end

module DBClusterBacktrackNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DescribeValidDBInstanceModificationsMessage = struct
  type t = { d_b_instance_identifier : String.t }

  let make ~d_b_instance_identifier () = { d_b_instance_identifier }

  let parse xml =
    Some
      { d_b_instance_identifier =
          Aws.Xml.required
            "DBInstanceIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBInstanceIdentifier" xml)
               String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("DBInstanceIdentifier", String.to_query v.d_b_instance_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("DBInstanceIdentifier", String.to_json v.d_b_instance_identifier) ])

  let of_json j =
    { d_b_instance_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBInstanceIdentifier"))
    }
end

module InstallationMediaNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module SubscriptionNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module ResourcePendingMaintenanceActions = struct
  type t =
    { resource_identifier : String.t option
    ; pending_maintenance_action_details : PendingMaintenanceActionDetails.t
    }

  let make ?resource_identifier ?(pending_maintenance_action_details = []) () =
    { resource_identifier; pending_maintenance_action_details }

  let parse xml =
    Some
      { resource_identifier =
          Aws.Util.option_bind (Aws.Xml.member "ResourceIdentifier" xml) String.parse
      ; pending_maintenance_action_details =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "PendingMaintenanceActionDetails" xml)
               PendingMaintenanceActionDetails.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "PendingMaintenanceActionDetails.member"
                , PendingMaintenanceActionDetails.to_query
                    v.pending_maintenance_action_details ))
         ; Aws.Util.option_map v.resource_identifier (fun f ->
               Aws.Query.Pair ("ResourceIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "PendingMaintenanceActionDetails"
             , PendingMaintenanceActionDetails.to_json
                 v.pending_maintenance_action_details )
         ; Aws.Util.option_map v.resource_identifier (fun f ->
               "ResourceIdentifier", String.to_json f)
         ])

  let of_json j =
    { resource_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "ResourceIdentifier") String.of_json
    ; pending_maintenance_action_details =
        PendingMaintenanceActionDetails.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "PendingMaintenanceActionDetails"))
    }
end

module PendingMaintenanceActions = struct
  type t = ResourcePendingMaintenanceActions.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         ResourcePendingMaintenanceActions.parse
         (Aws.Xml.members "ResourcePendingMaintenanceActions" xml))

  let to_query v = Aws.Query.to_query_list ResourcePendingMaintenanceActions.to_query v

  let to_json v = `List (List.map ResourcePendingMaintenanceActions.to_json v)

  let of_json j = Aws.Json.to_list ResourcePendingMaintenanceActions.of_json j
end

module ModifyDBClusterSnapshotAttributeMessage = struct
  type t =
    { d_b_cluster_snapshot_identifier : String.t
    ; attribute_name : String.t
    ; values_to_add : AttributeValueList.t
    ; values_to_remove : AttributeValueList.t
    }

  let make
      ~d_b_cluster_snapshot_identifier
      ~attribute_name
      ?(values_to_add = [])
      ?(values_to_remove = [])
      () =
    { d_b_cluster_snapshot_identifier; attribute_name; values_to_add; values_to_remove }

  let parse xml =
    Some
      { d_b_cluster_snapshot_identifier =
          Aws.Xml.required
            "DBClusterSnapshotIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBClusterSnapshotIdentifier" xml)
               String.parse)
      ; attribute_name =
          Aws.Xml.required
            "AttributeName"
            (Aws.Util.option_bind (Aws.Xml.member "AttributeName" xml) String.parse)
      ; values_to_add =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ValuesToAdd" xml)
               AttributeValueList.parse)
      ; values_to_remove =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ValuesToRemove" xml)
               AttributeValueList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("ValuesToRemove.member", AttributeValueList.to_query v.values_to_remove))
         ; Some
             (Aws.Query.Pair
                ("ValuesToAdd.member", AttributeValueList.to_query v.values_to_add))
         ; Some (Aws.Query.Pair ("AttributeName", String.to_query v.attribute_name))
         ; Some
             (Aws.Query.Pair
                ( "DBClusterSnapshotIdentifier"
                , String.to_query v.d_b_cluster_snapshot_identifier ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("ValuesToRemove", AttributeValueList.to_json v.values_to_remove)
         ; Some ("ValuesToAdd", AttributeValueList.to_json v.values_to_add)
         ; Some ("AttributeName", String.to_json v.attribute_name)
         ; Some
             ( "DBClusterSnapshotIdentifier"
             , String.to_json v.d_b_cluster_snapshot_identifier )
         ])

  let of_json j =
    { d_b_cluster_snapshot_identifier =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterSnapshotIdentifier"))
    ; attribute_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "AttributeName"))
    ; values_to_add =
        AttributeValueList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ValuesToAdd"))
    ; values_to_remove =
        AttributeValueList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ValuesToRemove"))
    }
end

module DescribeDBProxiesRequest = struct
  type t =
    { d_b_proxy_name : String.t option
    ; filters : FilterList.t
    ; marker : String.t option
    ; max_records : Integer.t option
    }

  let make ?d_b_proxy_name ?(filters = []) ?marker ?max_records () =
    { d_b_proxy_name; filters; marker; max_records }

  let parse xml =
    Some
      { d_b_proxy_name =
          Aws.Util.option_bind (Aws.Xml.member "DBProxyName" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.d_b_proxy_name (fun f ->
               Aws.Query.Pair ("DBProxyName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.d_b_proxy_name (fun f -> "DBProxyName", String.to_json f)
         ])

  let of_json j =
    { d_b_proxy_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBProxyName") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    }
end

module DeleteDBInstanceAutomatedBackupMessage = struct
  type t = { dbi_resource_id : String.t }

  let make ~dbi_resource_id () = { dbi_resource_id }

  let parse xml =
    Some
      { dbi_resource_id =
          Aws.Xml.required
            "DbiResourceId"
            (Aws.Util.option_bind (Aws.Xml.member "DbiResourceId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("DbiResourceId", String.to_query v.dbi_resource_id)) ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("DbiResourceId", String.to_json v.dbi_resource_id) ])

  let of_json j =
    { dbi_resource_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DbiResourceId"))
    }
end

module DBInstanceAlreadyExistsFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DeleteDBSecurityGroupMessage = struct
  type t = { d_b_security_group_name : String.t }

  let make ~d_b_security_group_name () = { d_b_security_group_name }

  let parse xml =
    Some
      { d_b_security_group_name =
          Aws.Xml.required
            "DBSecurityGroupName"
            (Aws.Util.option_bind (Aws.Xml.member "DBSecurityGroupName" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("DBSecurityGroupName", String.to_query v.d_b_security_group_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("DBSecurityGroupName", String.to_json v.d_b_security_group_name) ])

  let of_json j =
    { d_b_security_group_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBSecurityGroupName"))
    }
end

module DBParameterGroupNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module RemoveFromGlobalClusterMessage = struct
  type t =
    { global_cluster_identifier : String.t option
    ; db_cluster_identifier : String.t option
    }

  let make ?global_cluster_identifier ?db_cluster_identifier () =
    { global_cluster_identifier; db_cluster_identifier }

  let parse xml =
    Some
      { global_cluster_identifier =
          Aws.Util.option_bind (Aws.Xml.member "GlobalClusterIdentifier" xml) String.parse
      ; db_cluster_identifier =
          Aws.Util.option_bind (Aws.Xml.member "DbClusterIdentifier" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.db_cluster_identifier (fun f ->
               Aws.Query.Pair ("DbClusterIdentifier", String.to_query f))
         ; Aws.Util.option_map v.global_cluster_identifier (fun f ->
               Aws.Query.Pair ("GlobalClusterIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.db_cluster_identifier (fun f ->
               "DbClusterIdentifier", String.to_json f)
         ; Aws.Util.option_map v.global_cluster_identifier (fun f ->
               "GlobalClusterIdentifier", String.to_json f)
         ])

  let of_json j =
    { global_cluster_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "GlobalClusterIdentifier") String.of_json
    ; db_cluster_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "DbClusterIdentifier") String.of_json
    }
end

module RebootDBInstanceResult = struct
  type t = { d_b_instance : DBInstance.t option }

  let make ?d_b_instance () = { d_b_instance }

  let parse xml =
    Some
      { d_b_instance =
          Aws.Util.option_bind (Aws.Xml.member "DBInstance" xml) DBInstance.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_instance (fun f ->
               Aws.Query.Pair ("DBInstance", DBInstance.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_instance (fun f ->
               "DBInstance", DBInstance.to_json f)
         ])

  let of_json j =
    { d_b_instance =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstance") DBInstance.of_json
    }
end

module InvalidDBSubnetStateFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module EventCategoriesMapList = struct
  type t = EventCategoriesMap.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map EventCategoriesMap.parse (Aws.Xml.members "EventCategoriesMap" xml))

  let to_query v = Aws.Query.to_query_list EventCategoriesMap.to_query v

  let to_json v = `List (List.map EventCategoriesMap.to_json v)

  let of_json j = Aws.Json.to_list EventCategoriesMap.of_json j
end

module DeregisterDBProxyTargetsResponse = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module RestoreDBClusterToPointInTimeResult = struct
  type t = { d_b_cluster : DBCluster.t option }

  let make ?d_b_cluster () = { d_b_cluster }

  let parse xml =
    Some
      { d_b_cluster =
          Aws.Util.option_bind (Aws.Xml.member "DBCluster" xml) DBCluster.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster (fun f ->
               Aws.Query.Pair ("DBCluster", DBCluster.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster (fun f -> "DBCluster", DBCluster.to_json f) ])

  let of_json j =
    { d_b_cluster = Aws.Util.option_map (Aws.Json.lookup j "DBCluster") DBCluster.of_json
    }
end

module GlobalClustersMessage = struct
  type t =
    { marker : String.t option
    ; global_clusters : GlobalClusterList.t
    }

  let make ?marker ?(global_clusters = []) () = { marker; global_clusters }

  let parse xml =
    Some
      { marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; global_clusters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "GlobalClusters" xml)
               GlobalClusterList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("GlobalClusters.member", GlobalClusterList.to_query v.global_clusters))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("GlobalClusters", GlobalClusterList.to_json v.global_clusters)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ])

  let of_json j =
    { marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; global_clusters =
        GlobalClusterList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "GlobalClusters"))
    }
end

module DescribeDBSnapshotAttributesMessage = struct
  type t = { d_b_snapshot_identifier : String.t }

  let make ~d_b_snapshot_identifier () = { d_b_snapshot_identifier }

  let parse xml =
    Some
      { d_b_snapshot_identifier =
          Aws.Xml.required
            "DBSnapshotIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBSnapshotIdentifier" xml)
               String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("DBSnapshotIdentifier", String.to_query v.d_b_snapshot_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("DBSnapshotIdentifier", String.to_json v.d_b_snapshot_identifier) ])

  let of_json j =
    { d_b_snapshot_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBSnapshotIdentifier"))
    }
end

module CreateDBSecurityGroupResult = struct
  type t = { d_b_security_group : DBSecurityGroup.t option }

  let make ?d_b_security_group () = { d_b_security_group }

  let parse xml =
    Some
      { d_b_security_group =
          Aws.Util.option_bind
            (Aws.Xml.member "DBSecurityGroup" xml)
            DBSecurityGroup.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_security_group (fun f ->
               Aws.Query.Pair ("DBSecurityGroup", DBSecurityGroup.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_security_group (fun f ->
               "DBSecurityGroup", DBSecurityGroup.to_json f)
         ])

  let of_json j =
    { d_b_security_group =
        Aws.Util.option_map (Aws.Json.lookup j "DBSecurityGroup") DBSecurityGroup.of_json
    }
end

module DescribeCertificatesMessage = struct
  type t =
    { certificate_identifier : String.t option
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    }

  let make ?certificate_identifier ?(filters = []) ?max_records ?marker () =
    { certificate_identifier; filters; max_records; marker }

  let parse xml =
    Some
      { certificate_identifier =
          Aws.Util.option_bind (Aws.Xml.member "CertificateIdentifier" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.certificate_identifier (fun f ->
               Aws.Query.Pair ("CertificateIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.certificate_identifier (fun f ->
               "CertificateIdentifier", String.to_json f)
         ])

  let of_json j =
    { certificate_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "CertificateIdentifier") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module ModifyGlobalClusterResult = struct
  type t = { global_cluster : GlobalCluster.t option }

  let make ?global_cluster () = { global_cluster }

  let parse xml =
    Some
      { global_cluster =
          Aws.Util.option_bind (Aws.Xml.member "GlobalCluster" xml) GlobalCluster.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.global_cluster (fun f ->
               Aws.Query.Pair ("GlobalCluster", GlobalCluster.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.global_cluster (fun f ->
               "GlobalCluster", GlobalCluster.to_json f)
         ])

  let of_json j =
    { global_cluster =
        Aws.Util.option_map (Aws.Json.lookup j "GlobalCluster") GlobalCluster.of_json
    }
end

module InsufficientDBInstanceCapacityFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module ValidUpgradeTargetList = struct
  type t = UpgradeTarget.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map UpgradeTarget.parse (Aws.Xml.members "UpgradeTarget" xml))

  let to_query v = Aws.Query.to_query_list UpgradeTarget.to_query v

  let to_json v = `List (List.map UpgradeTarget.to_json v)

  let of_json j = Aws.Json.to_list UpgradeTarget.of_json j
end

module SupportedTimezonesList = struct
  type t = Timezone.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Timezone.parse (Aws.Xml.members "Timezone" xml))

  let to_query v = Aws.Query.to_query_list Timezone.to_query v

  let to_json v = `List (List.map Timezone.to_json v)

  let of_json j = Aws.Json.to_list Timezone.of_json j
end

module DBEngineVersion = struct
  type t =
    { engine : String.t option
    ; engine_version : String.t option
    ; d_b_parameter_group_family : String.t option
    ; d_b_engine_description : String.t option
    ; d_b_engine_version_description : String.t option
    ; default_character_set : CharacterSet.t option
    ; supported_character_sets : SupportedCharacterSetsList.t
    ; supported_nchar_character_sets : SupportedCharacterSetsList.t
    ; valid_upgrade_target : ValidUpgradeTargetList.t
    ; supported_timezones : SupportedTimezonesList.t
    ; exportable_log_types : LogTypeList.t
    ; supports_log_exports_to_cloudwatch_logs : Boolean.t option
    ; supports_read_replica : Boolean.t option
    ; supported_engine_modes : EngineModeList.t
    ; supported_feature_names : FeatureNameList.t
    ; status : String.t option
    ; supports_parallel_query : Boolean.t option
    ; supports_global_databases : Boolean.t option
    }

  let make
      ?engine
      ?engine_version
      ?d_b_parameter_group_family
      ?d_b_engine_description
      ?d_b_engine_version_description
      ?default_character_set
      ?(supported_character_sets = [])
      ?(supported_nchar_character_sets = [])
      ?(valid_upgrade_target = [])
      ?(supported_timezones = [])
      ?(exportable_log_types = [])
      ?supports_log_exports_to_cloudwatch_logs
      ?supports_read_replica
      ?(supported_engine_modes = [])
      ?(supported_feature_names = [])
      ?status
      ?supports_parallel_query
      ?supports_global_databases
      () =
    { engine
    ; engine_version
    ; d_b_parameter_group_family
    ; d_b_engine_description
    ; d_b_engine_version_description
    ; default_character_set
    ; supported_character_sets
    ; supported_nchar_character_sets
    ; valid_upgrade_target
    ; supported_timezones
    ; exportable_log_types
    ; supports_log_exports_to_cloudwatch_logs
    ; supports_read_replica
    ; supported_engine_modes
    ; supported_feature_names
    ; status
    ; supports_parallel_query
    ; supports_global_databases
    }

  let parse xml =
    Some
      { engine = Aws.Util.option_bind (Aws.Xml.member "Engine" xml) String.parse
      ; engine_version =
          Aws.Util.option_bind (Aws.Xml.member "EngineVersion" xml) String.parse
      ; d_b_parameter_group_family =
          Aws.Util.option_bind (Aws.Xml.member "DBParameterGroupFamily" xml) String.parse
      ; d_b_engine_description =
          Aws.Util.option_bind (Aws.Xml.member "DBEngineDescription" xml) String.parse
      ; d_b_engine_version_description =
          Aws.Util.option_bind
            (Aws.Xml.member "DBEngineVersionDescription" xml)
            String.parse
      ; default_character_set =
          Aws.Util.option_bind
            (Aws.Xml.member "DefaultCharacterSet" xml)
            CharacterSet.parse
      ; supported_character_sets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SupportedCharacterSets" xml)
               SupportedCharacterSetsList.parse)
      ; supported_nchar_character_sets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SupportedNcharCharacterSets" xml)
               SupportedCharacterSetsList.parse)
      ; valid_upgrade_target =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ValidUpgradeTarget" xml)
               ValidUpgradeTargetList.parse)
      ; supported_timezones =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SupportedTimezones" xml)
               SupportedTimezonesList.parse)
      ; exportable_log_types =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ExportableLogTypes" xml)
               LogTypeList.parse)
      ; supports_log_exports_to_cloudwatch_logs =
          Aws.Util.option_bind
            (Aws.Xml.member "SupportsLogExportsToCloudwatchLogs" xml)
            Boolean.parse
      ; supports_read_replica =
          Aws.Util.option_bind (Aws.Xml.member "SupportsReadReplica" xml) Boolean.parse
      ; supported_engine_modes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SupportedEngineModes" xml)
               EngineModeList.parse)
      ; supported_feature_names =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SupportedFeatureNames" xml)
               FeatureNameList.parse)
      ; status = Aws.Util.option_bind (Aws.Xml.member "Status" xml) String.parse
      ; supports_parallel_query =
          Aws.Util.option_bind (Aws.Xml.member "SupportsParallelQuery" xml) Boolean.parse
      ; supports_global_databases =
          Aws.Util.option_bind
            (Aws.Xml.member "SupportsGlobalDatabases" xml)
            Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.supports_global_databases (fun f ->
               Aws.Query.Pair ("SupportsGlobalDatabases", Boolean.to_query f))
         ; Aws.Util.option_map v.supports_parallel_query (fun f ->
               Aws.Query.Pair ("SupportsParallelQuery", Boolean.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "SupportedFeatureNames.member"
                , FeatureNameList.to_query v.supported_feature_names ))
         ; Some
             (Aws.Query.Pair
                ( "SupportedEngineModes.member"
                , EngineModeList.to_query v.supported_engine_modes ))
         ; Aws.Util.option_map v.supports_read_replica (fun f ->
               Aws.Query.Pair ("SupportsReadReplica", Boolean.to_query f))
         ; Aws.Util.option_map v.supports_log_exports_to_cloudwatch_logs (fun f ->
               Aws.Query.Pair ("SupportsLogExportsToCloudwatchLogs", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ExportableLogTypes.member", LogTypeList.to_query v.exportable_log_types))
         ; Some
             (Aws.Query.Pair
                ( "SupportedTimezones.member"
                , SupportedTimezonesList.to_query v.supported_timezones ))
         ; Some
             (Aws.Query.Pair
                ( "ValidUpgradeTarget.member"
                , ValidUpgradeTargetList.to_query v.valid_upgrade_target ))
         ; Some
             (Aws.Query.Pair
                ( "SupportedNcharCharacterSets.member"
                , SupportedCharacterSetsList.to_query v.supported_nchar_character_sets ))
         ; Some
             (Aws.Query.Pair
                ( "SupportedCharacterSets.member"
                , SupportedCharacterSetsList.to_query v.supported_character_sets ))
         ; Aws.Util.option_map v.default_character_set (fun f ->
               Aws.Query.Pair ("DefaultCharacterSet", CharacterSet.to_query f))
         ; Aws.Util.option_map v.d_b_engine_version_description (fun f ->
               Aws.Query.Pair ("DBEngineVersionDescription", String.to_query f))
         ; Aws.Util.option_map v.d_b_engine_description (fun f ->
               Aws.Query.Pair ("DBEngineDescription", String.to_query f))
         ; Aws.Util.option_map v.d_b_parameter_group_family (fun f ->
               Aws.Query.Pair ("DBParameterGroupFamily", String.to_query f))
         ; Aws.Util.option_map v.engine_version (fun f ->
               Aws.Query.Pair ("EngineVersion", String.to_query f))
         ; Aws.Util.option_map v.engine (fun f ->
               Aws.Query.Pair ("Engine", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.supports_global_databases (fun f ->
               "SupportsGlobalDatabases", Boolean.to_json f)
         ; Aws.Util.option_map v.supports_parallel_query (fun f ->
               "SupportsParallelQuery", Boolean.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "Status", String.to_json f)
         ; Some
             ("SupportedFeatureNames", FeatureNameList.to_json v.supported_feature_names)
         ; Some ("SupportedEngineModes", EngineModeList.to_json v.supported_engine_modes)
         ; Aws.Util.option_map v.supports_read_replica (fun f ->
               "SupportsReadReplica", Boolean.to_json f)
         ; Aws.Util.option_map v.supports_log_exports_to_cloudwatch_logs (fun f ->
               "SupportsLogExportsToCloudwatchLogs", Boolean.to_json f)
         ; Some ("ExportableLogTypes", LogTypeList.to_json v.exportable_log_types)
         ; Some
             ("SupportedTimezones", SupportedTimezonesList.to_json v.supported_timezones)
         ; Some
             ("ValidUpgradeTarget", ValidUpgradeTargetList.to_json v.valid_upgrade_target)
         ; Some
             ( "SupportedNcharCharacterSets"
             , SupportedCharacterSetsList.to_json v.supported_nchar_character_sets )
         ; Some
             ( "SupportedCharacterSets"
             , SupportedCharacterSetsList.to_json v.supported_character_sets )
         ; Aws.Util.option_map v.default_character_set (fun f ->
               "DefaultCharacterSet", CharacterSet.to_json f)
         ; Aws.Util.option_map v.d_b_engine_version_description (fun f ->
               "DBEngineVersionDescription", String.to_json f)
         ; Aws.Util.option_map v.d_b_engine_description (fun f ->
               "DBEngineDescription", String.to_json f)
         ; Aws.Util.option_map v.d_b_parameter_group_family (fun f ->
               "DBParameterGroupFamily", String.to_json f)
         ; Aws.Util.option_map v.engine_version (fun f ->
               "EngineVersion", String.to_json f)
         ; Aws.Util.option_map v.engine (fun f -> "Engine", String.to_json f)
         ])

  let of_json j =
    { engine = Aws.Util.option_map (Aws.Json.lookup j "Engine") String.of_json
    ; engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "EngineVersion") String.of_json
    ; d_b_parameter_group_family =
        Aws.Util.option_map (Aws.Json.lookup j "DBParameterGroupFamily") String.of_json
    ; d_b_engine_description =
        Aws.Util.option_map (Aws.Json.lookup j "DBEngineDescription") String.of_json
    ; d_b_engine_version_description =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBEngineVersionDescription")
          String.of_json
    ; default_character_set =
        Aws.Util.option_map (Aws.Json.lookup j "DefaultCharacterSet") CharacterSet.of_json
    ; supported_character_sets =
        SupportedCharacterSetsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SupportedCharacterSets"))
    ; supported_nchar_character_sets =
        SupportedCharacterSetsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SupportedNcharCharacterSets"))
    ; valid_upgrade_target =
        ValidUpgradeTargetList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ValidUpgradeTarget"))
    ; supported_timezones =
        SupportedTimezonesList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SupportedTimezones"))
    ; exportable_log_types =
        LogTypeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ExportableLogTypes"))
    ; supports_log_exports_to_cloudwatch_logs =
        Aws.Util.option_map
          (Aws.Json.lookup j "SupportsLogExportsToCloudwatchLogs")
          Boolean.of_json
    ; supports_read_replica =
        Aws.Util.option_map (Aws.Json.lookup j "SupportsReadReplica") Boolean.of_json
    ; supported_engine_modes =
        EngineModeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SupportedEngineModes"))
    ; supported_feature_names =
        FeatureNameList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SupportedFeatureNames"))
    ; status = Aws.Util.option_map (Aws.Json.lookup j "Status") String.of_json
    ; supports_parallel_query =
        Aws.Util.option_map (Aws.Json.lookup j "SupportsParallelQuery") Boolean.of_json
    ; supports_global_databases =
        Aws.Util.option_map (Aws.Json.lookup j "SupportsGlobalDatabases") Boolean.of_json
    }
end

module CopyDBParameterGroupMessage = struct
  type t =
    { source_d_b_parameter_group_identifier : String.t
    ; target_d_b_parameter_group_identifier : String.t
    ; target_d_b_parameter_group_description : String.t
    ; tags : TagList.t
    }

  let make
      ~source_d_b_parameter_group_identifier
      ~target_d_b_parameter_group_identifier
      ~target_d_b_parameter_group_description
      ?(tags = [])
      () =
    { source_d_b_parameter_group_identifier
    ; target_d_b_parameter_group_identifier
    ; target_d_b_parameter_group_description
    ; tags
    }

  let parse xml =
    Some
      { source_d_b_parameter_group_identifier =
          Aws.Xml.required
            "SourceDBParameterGroupIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "SourceDBParameterGroupIdentifier" xml)
               String.parse)
      ; target_d_b_parameter_group_identifier =
          Aws.Xml.required
            "TargetDBParameterGroupIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "TargetDBParameterGroupIdentifier" xml)
               String.parse)
      ; target_d_b_parameter_group_description =
          Aws.Xml.required
            "TargetDBParameterGroupDescription"
            (Aws.Util.option_bind
               (Aws.Xml.member "TargetDBParameterGroupDescription" xml)
               String.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Some
             (Aws.Query.Pair
                ( "TargetDBParameterGroupDescription"
                , String.to_query v.target_d_b_parameter_group_description ))
         ; Some
             (Aws.Query.Pair
                ( "TargetDBParameterGroupIdentifier"
                , String.to_query v.target_d_b_parameter_group_identifier ))
         ; Some
             (Aws.Query.Pair
                ( "SourceDBParameterGroupIdentifier"
                , String.to_query v.source_d_b_parameter_group_identifier ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tags", TagList.to_json v.tags)
         ; Some
             ( "TargetDBParameterGroupDescription"
             , String.to_json v.target_d_b_parameter_group_description )
         ; Some
             ( "TargetDBParameterGroupIdentifier"
             , String.to_json v.target_d_b_parameter_group_identifier )
         ; Some
             ( "SourceDBParameterGroupIdentifier"
             , String.to_json v.source_d_b_parameter_group_identifier )
         ])

  let of_json j =
    { source_d_b_parameter_group_identifier =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceDBParameterGroupIdentifier"))
    ; target_d_b_parameter_group_identifier =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TargetDBParameterGroupIdentifier"))
    ; target_d_b_parameter_group_description =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TargetDBParameterGroupDescription"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    }
end

module DeregisterDBProxyTargetsRequest = struct
  type t =
    { d_b_proxy_name : String.t
    ; target_group_name : String.t option
    ; d_b_instance_identifiers : StringList.t
    ; d_b_cluster_identifiers : StringList.t
    }

  let make
      ~d_b_proxy_name
      ?target_group_name
      ?(d_b_instance_identifiers = [])
      ?(d_b_cluster_identifiers = [])
      () =
    { d_b_proxy_name
    ; target_group_name
    ; d_b_instance_identifiers
    ; d_b_cluster_identifiers
    }

  let parse xml =
    Some
      { d_b_proxy_name =
          Aws.Xml.required
            "DBProxyName"
            (Aws.Util.option_bind (Aws.Xml.member "DBProxyName" xml) String.parse)
      ; target_group_name =
          Aws.Util.option_bind (Aws.Xml.member "TargetGroupName" xml) String.parse
      ; d_b_instance_identifiers =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DBInstanceIdentifiers" xml)
               StringList.parse)
      ; d_b_cluster_identifiers =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DBClusterIdentifiers" xml)
               StringList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "DBClusterIdentifiers.member"
                , StringList.to_query v.d_b_cluster_identifiers ))
         ; Some
             (Aws.Query.Pair
                ( "DBInstanceIdentifiers.member"
                , StringList.to_query v.d_b_instance_identifiers ))
         ; Aws.Util.option_map v.target_group_name (fun f ->
               Aws.Query.Pair ("TargetGroupName", String.to_query f))
         ; Some (Aws.Query.Pair ("DBProxyName", String.to_query v.d_b_proxy_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("DBClusterIdentifiers", StringList.to_json v.d_b_cluster_identifiers)
         ; Some ("DBInstanceIdentifiers", StringList.to_json v.d_b_instance_identifiers)
         ; Aws.Util.option_map v.target_group_name (fun f ->
               "TargetGroupName", String.to_json f)
         ; Some ("DBProxyName", String.to_json v.d_b_proxy_name)
         ])

  let of_json j =
    { d_b_proxy_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBProxyName"))
    ; target_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "TargetGroupName") String.of_json
    ; d_b_instance_identifiers =
        StringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBInstanceIdentifiers"))
    ; d_b_cluster_identifiers =
        StringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterIdentifiers"))
    }
end

module CreateDBSnapshotMessage = struct
  type t =
    { d_b_snapshot_identifier : String.t
    ; d_b_instance_identifier : String.t
    ; tags : TagList.t
    }

  let make ~d_b_snapshot_identifier ~d_b_instance_identifier ?(tags = []) () =
    { d_b_snapshot_identifier; d_b_instance_identifier; tags }

  let parse xml =
    Some
      { d_b_snapshot_identifier =
          Aws.Xml.required
            "DBSnapshotIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBSnapshotIdentifier" xml)
               String.parse)
      ; d_b_instance_identifier =
          Aws.Xml.required
            "DBInstanceIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBInstanceIdentifier" xml)
               String.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Some
             (Aws.Query.Pair
                ("DBInstanceIdentifier", String.to_query v.d_b_instance_identifier))
         ; Some
             (Aws.Query.Pair
                ("DBSnapshotIdentifier", String.to_query v.d_b_snapshot_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tags", TagList.to_json v.tags)
         ; Some ("DBInstanceIdentifier", String.to_json v.d_b_instance_identifier)
         ; Some ("DBSnapshotIdentifier", String.to_json v.d_b_snapshot_identifier)
         ])

  let of_json j =
    { d_b_snapshot_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBSnapshotIdentifier"))
    ; d_b_instance_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBInstanceIdentifier"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    }
end

module DescribeEngineDefaultClusterParametersResult = struct
  type t = { engine_defaults : EngineDefaults.t option }

  let make ?engine_defaults () = { engine_defaults }

  let parse xml =
    Some
      { engine_defaults =
          Aws.Util.option_bind (Aws.Xml.member "EngineDefaults" xml) EngineDefaults.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.engine_defaults (fun f ->
               Aws.Query.Pair ("EngineDefaults", EngineDefaults.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.engine_defaults (fun f ->
               "EngineDefaults", EngineDefaults.to_json f)
         ])

  let of_json j =
    { engine_defaults =
        Aws.Util.option_map (Aws.Json.lookup j "EngineDefaults") EngineDefaults.of_json
    }
end

module ModifyDBInstanceResult = struct
  type t = { d_b_instance : DBInstance.t option }

  let make ?d_b_instance () = { d_b_instance }

  let parse xml =
    Some
      { d_b_instance =
          Aws.Util.option_bind (Aws.Xml.member "DBInstance" xml) DBInstance.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_instance (fun f ->
               Aws.Query.Pair ("DBInstance", DBInstance.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_instance (fun f ->
               "DBInstance", DBInstance.to_json f)
         ])

  let of_json j =
    { d_b_instance =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstance") DBInstance.of_json
    }
end

module DBParameterGroupQuotaExceededFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module RegisterDBProxyTargetsRequest = struct
  type t =
    { d_b_proxy_name : String.t
    ; target_group_name : String.t option
    ; d_b_instance_identifiers : StringList.t
    ; d_b_cluster_identifiers : StringList.t
    }

  let make
      ~d_b_proxy_name
      ?target_group_name
      ?(d_b_instance_identifiers = [])
      ?(d_b_cluster_identifiers = [])
      () =
    { d_b_proxy_name
    ; target_group_name
    ; d_b_instance_identifiers
    ; d_b_cluster_identifiers
    }

  let parse xml =
    Some
      { d_b_proxy_name =
          Aws.Xml.required
            "DBProxyName"
            (Aws.Util.option_bind (Aws.Xml.member "DBProxyName" xml) String.parse)
      ; target_group_name =
          Aws.Util.option_bind (Aws.Xml.member "TargetGroupName" xml) String.parse
      ; d_b_instance_identifiers =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DBInstanceIdentifiers" xml)
               StringList.parse)
      ; d_b_cluster_identifiers =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DBClusterIdentifiers" xml)
               StringList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "DBClusterIdentifiers.member"
                , StringList.to_query v.d_b_cluster_identifiers ))
         ; Some
             (Aws.Query.Pair
                ( "DBInstanceIdentifiers.member"
                , StringList.to_query v.d_b_instance_identifiers ))
         ; Aws.Util.option_map v.target_group_name (fun f ->
               Aws.Query.Pair ("TargetGroupName", String.to_query f))
         ; Some (Aws.Query.Pair ("DBProxyName", String.to_query v.d_b_proxy_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("DBClusterIdentifiers", StringList.to_json v.d_b_cluster_identifiers)
         ; Some ("DBInstanceIdentifiers", StringList.to_json v.d_b_instance_identifiers)
         ; Aws.Util.option_map v.target_group_name (fun f ->
               "TargetGroupName", String.to_json f)
         ; Some ("DBProxyName", String.to_json v.d_b_proxy_name)
         ])

  let of_json j =
    { d_b_proxy_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBProxyName"))
    ; target_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "TargetGroupName") String.of_json
    ; d_b_instance_identifiers =
        StringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBInstanceIdentifiers"))
    ; d_b_cluster_identifiers =
        StringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterIdentifiers"))
    }
end

module InvalidDBClusterEndpointStateFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module ResetDBClusterParameterGroupMessage = struct
  type t =
    { d_b_cluster_parameter_group_name : String.t
    ; reset_all_parameters : Boolean.t option
    ; parameters : ParametersList.t
    }

  let make ~d_b_cluster_parameter_group_name ?reset_all_parameters ?(parameters = []) () =
    { d_b_cluster_parameter_group_name; reset_all_parameters; parameters }

  let parse xml =
    Some
      { d_b_cluster_parameter_group_name =
          Aws.Xml.required
            "DBClusterParameterGroupName"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBClusterParameterGroupName" xml)
               String.parse)
      ; reset_all_parameters =
          Aws.Util.option_bind (Aws.Xml.member "ResetAllParameters" xml) Boolean.parse
      ; parameters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Parameters" xml) ParametersList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("Parameters.member", ParametersList.to_query v.parameters))
         ; Aws.Util.option_map v.reset_all_parameters (fun f ->
               Aws.Query.Pair ("ResetAllParameters", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "DBClusterParameterGroupName"
                , String.to_query v.d_b_cluster_parameter_group_name ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Parameters", ParametersList.to_json v.parameters)
         ; Aws.Util.option_map v.reset_all_parameters (fun f ->
               "ResetAllParameters", Boolean.to_json f)
         ; Some
             ( "DBClusterParameterGroupName"
             , String.to_json v.d_b_cluster_parameter_group_name )
         ])

  let of_json j =
    { d_b_cluster_parameter_group_name =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterParameterGroupName"))
    ; reset_all_parameters =
        Aws.Util.option_map (Aws.Json.lookup j "ResetAllParameters") Boolean.of_json
    ; parameters =
        ParametersList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Parameters"))
    }
end

module OptionGroupNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DescribeReservedDBInstancesOfferingsMessage = struct
  type t =
    { reserved_d_b_instances_offering_id : String.t option
    ; d_b_instance_class : String.t option
    ; duration : String.t option
    ; product_description : String.t option
    ; offering_type : String.t option
    ; multi_a_z : Boolean.t option
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    }

  let make
      ?reserved_d_b_instances_offering_id
      ?d_b_instance_class
      ?duration
      ?product_description
      ?offering_type
      ?multi_a_z
      ?(filters = [])
      ?max_records
      ?marker
      () =
    { reserved_d_b_instances_offering_id
    ; d_b_instance_class
    ; duration
    ; product_description
    ; offering_type
    ; multi_a_z
    ; filters
    ; max_records
    ; marker
    }

  let parse xml =
    Some
      { reserved_d_b_instances_offering_id =
          Aws.Util.option_bind
            (Aws.Xml.member "ReservedDBInstancesOfferingId" xml)
            String.parse
      ; d_b_instance_class =
          Aws.Util.option_bind (Aws.Xml.member "DBInstanceClass" xml) String.parse
      ; duration = Aws.Util.option_bind (Aws.Xml.member "Duration" xml) String.parse
      ; product_description =
          Aws.Util.option_bind (Aws.Xml.member "ProductDescription" xml) String.parse
      ; offering_type =
          Aws.Util.option_bind (Aws.Xml.member "OfferingType" xml) String.parse
      ; multi_a_z = Aws.Util.option_bind (Aws.Xml.member "MultiAZ" xml) Boolean.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.multi_a_z (fun f ->
               Aws.Query.Pair ("MultiAZ", Boolean.to_query f))
         ; Aws.Util.option_map v.offering_type (fun f ->
               Aws.Query.Pair ("OfferingType", String.to_query f))
         ; Aws.Util.option_map v.product_description (fun f ->
               Aws.Query.Pair ("ProductDescription", String.to_query f))
         ; Aws.Util.option_map v.duration (fun f ->
               Aws.Query.Pair ("Duration", String.to_query f))
         ; Aws.Util.option_map v.d_b_instance_class (fun f ->
               Aws.Query.Pair ("DBInstanceClass", String.to_query f))
         ; Aws.Util.option_map v.reserved_d_b_instances_offering_id (fun f ->
               Aws.Query.Pair ("ReservedDBInstancesOfferingId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.multi_a_z (fun f -> "MultiAZ", Boolean.to_json f)
         ; Aws.Util.option_map v.offering_type (fun f -> "OfferingType", String.to_json f)
         ; Aws.Util.option_map v.product_description (fun f ->
               "ProductDescription", String.to_json f)
         ; Aws.Util.option_map v.duration (fun f -> "Duration", String.to_json f)
         ; Aws.Util.option_map v.d_b_instance_class (fun f ->
               "DBInstanceClass", String.to_json f)
         ; Aws.Util.option_map v.reserved_d_b_instances_offering_id (fun f ->
               "ReservedDBInstancesOfferingId", String.to_json f)
         ])

  let of_json j =
    { reserved_d_b_instances_offering_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "ReservedDBInstancesOfferingId")
          String.of_json
    ; d_b_instance_class =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstanceClass") String.of_json
    ; duration = Aws.Util.option_map (Aws.Json.lookup j "Duration") String.of_json
    ; product_description =
        Aws.Util.option_map (Aws.Json.lookup j "ProductDescription") String.of_json
    ; offering_type =
        Aws.Util.option_map (Aws.Json.lookup j "OfferingType") String.of_json
    ; multi_a_z = Aws.Util.option_map (Aws.Json.lookup j "MultiAZ") Boolean.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module ModifyDBInstanceMessage = struct
  type t =
    { d_b_instance_identifier : String.t
    ; allocated_storage : Integer.t option
    ; d_b_instance_class : String.t option
    ; d_b_subnet_group_name : String.t option
    ; d_b_security_groups : DBSecurityGroupNameList.t
    ; vpc_security_group_ids : VpcSecurityGroupIdList.t
    ; apply_immediately : Boolean.t option
    ; master_user_password : String.t option
    ; d_b_parameter_group_name : String.t option
    ; backup_retention_period : Integer.t option
    ; preferred_backup_window : String.t option
    ; preferred_maintenance_window : String.t option
    ; multi_a_z : Boolean.t option
    ; engine_version : String.t option
    ; allow_major_version_upgrade : Boolean.t option
    ; auto_minor_version_upgrade : Boolean.t option
    ; license_model : String.t option
    ; iops : Integer.t option
    ; option_group_name : String.t option
    ; new_d_b_instance_identifier : String.t option
    ; storage_type : String.t option
    ; tde_credential_arn : String.t option
    ; tde_credential_password : String.t option
    ; c_a_certificate_identifier : String.t option
    ; domain : String.t option
    ; copy_tags_to_snapshot : Boolean.t option
    ; monitoring_interval : Integer.t option
    ; d_b_port_number : Integer.t option
    ; publicly_accessible : Boolean.t option
    ; monitoring_role_arn : String.t option
    ; domain_i_a_m_role_name : String.t option
    ; promotion_tier : Integer.t option
    ; enable_i_a_m_database_authentication : Boolean.t option
    ; enable_performance_insights : Boolean.t option
    ; performance_insights_k_m_s_key_id : String.t option
    ; performance_insights_retention_period : Integer.t option
    ; cloudwatch_logs_export_configuration : CloudwatchLogsExportConfiguration.t option
    ; processor_features : ProcessorFeatureList.t
    ; use_default_processor_features : Boolean.t option
    ; deletion_protection : Boolean.t option
    ; max_allocated_storage : Integer.t option
    ; certificate_rotation_restart : Boolean.t option
    ; replica_mode : ReplicaMode.t option
    }

  let make
      ~d_b_instance_identifier
      ?allocated_storage
      ?d_b_instance_class
      ?d_b_subnet_group_name
      ?(d_b_security_groups = [])
      ?(vpc_security_group_ids = [])
      ?apply_immediately
      ?master_user_password
      ?d_b_parameter_group_name
      ?backup_retention_period
      ?preferred_backup_window
      ?preferred_maintenance_window
      ?multi_a_z
      ?engine_version
      ?allow_major_version_upgrade
      ?auto_minor_version_upgrade
      ?license_model
      ?iops
      ?option_group_name
      ?new_d_b_instance_identifier
      ?storage_type
      ?tde_credential_arn
      ?tde_credential_password
      ?c_a_certificate_identifier
      ?domain
      ?copy_tags_to_snapshot
      ?monitoring_interval
      ?d_b_port_number
      ?publicly_accessible
      ?monitoring_role_arn
      ?domain_i_a_m_role_name
      ?promotion_tier
      ?enable_i_a_m_database_authentication
      ?enable_performance_insights
      ?performance_insights_k_m_s_key_id
      ?performance_insights_retention_period
      ?cloudwatch_logs_export_configuration
      ?(processor_features = [])
      ?use_default_processor_features
      ?deletion_protection
      ?max_allocated_storage
      ?certificate_rotation_restart
      ?replica_mode
      () =
    { d_b_instance_identifier
    ; allocated_storage
    ; d_b_instance_class
    ; d_b_subnet_group_name
    ; d_b_security_groups
    ; vpc_security_group_ids
    ; apply_immediately
    ; master_user_password
    ; d_b_parameter_group_name
    ; backup_retention_period
    ; preferred_backup_window
    ; preferred_maintenance_window
    ; multi_a_z
    ; engine_version
    ; allow_major_version_upgrade
    ; auto_minor_version_upgrade
    ; license_model
    ; iops
    ; option_group_name
    ; new_d_b_instance_identifier
    ; storage_type
    ; tde_credential_arn
    ; tde_credential_password
    ; c_a_certificate_identifier
    ; domain
    ; copy_tags_to_snapshot
    ; monitoring_interval
    ; d_b_port_number
    ; publicly_accessible
    ; monitoring_role_arn
    ; domain_i_a_m_role_name
    ; promotion_tier
    ; enable_i_a_m_database_authentication
    ; enable_performance_insights
    ; performance_insights_k_m_s_key_id
    ; performance_insights_retention_period
    ; cloudwatch_logs_export_configuration
    ; processor_features
    ; use_default_processor_features
    ; deletion_protection
    ; max_allocated_storage
    ; certificate_rotation_restart
    ; replica_mode
    }

  let parse xml =
    Some
      { d_b_instance_identifier =
          Aws.Xml.required
            "DBInstanceIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBInstanceIdentifier" xml)
               String.parse)
      ; allocated_storage =
          Aws.Util.option_bind (Aws.Xml.member "AllocatedStorage" xml) Integer.parse
      ; d_b_instance_class =
          Aws.Util.option_bind (Aws.Xml.member "DBInstanceClass" xml) String.parse
      ; d_b_subnet_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBSubnetGroupName" xml) String.parse
      ; d_b_security_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DBSecurityGroups" xml)
               DBSecurityGroupNameList.parse)
      ; vpc_security_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "VpcSecurityGroupIds" xml)
               VpcSecurityGroupIdList.parse)
      ; apply_immediately =
          Aws.Util.option_bind (Aws.Xml.member "ApplyImmediately" xml) Boolean.parse
      ; master_user_password =
          Aws.Util.option_bind (Aws.Xml.member "MasterUserPassword" xml) String.parse
      ; d_b_parameter_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBParameterGroupName" xml) String.parse
      ; backup_retention_period =
          Aws.Util.option_bind (Aws.Xml.member "BackupRetentionPeriod" xml) Integer.parse
      ; preferred_backup_window =
          Aws.Util.option_bind (Aws.Xml.member "PreferredBackupWindow" xml) String.parse
      ; preferred_maintenance_window =
          Aws.Util.option_bind
            (Aws.Xml.member "PreferredMaintenanceWindow" xml)
            String.parse
      ; multi_a_z = Aws.Util.option_bind (Aws.Xml.member "MultiAZ" xml) Boolean.parse
      ; engine_version =
          Aws.Util.option_bind (Aws.Xml.member "EngineVersion" xml) String.parse
      ; allow_major_version_upgrade =
          Aws.Util.option_bind
            (Aws.Xml.member "AllowMajorVersionUpgrade" xml)
            Boolean.parse
      ; auto_minor_version_upgrade =
          Aws.Util.option_bind
            (Aws.Xml.member "AutoMinorVersionUpgrade" xml)
            Boolean.parse
      ; license_model =
          Aws.Util.option_bind (Aws.Xml.member "LicenseModel" xml) String.parse
      ; iops = Aws.Util.option_bind (Aws.Xml.member "Iops" xml) Integer.parse
      ; option_group_name =
          Aws.Util.option_bind (Aws.Xml.member "OptionGroupName" xml) String.parse
      ; new_d_b_instance_identifier =
          Aws.Util.option_bind (Aws.Xml.member "NewDBInstanceIdentifier" xml) String.parse
      ; storage_type =
          Aws.Util.option_bind (Aws.Xml.member "StorageType" xml) String.parse
      ; tde_credential_arn =
          Aws.Util.option_bind (Aws.Xml.member "TdeCredentialArn" xml) String.parse
      ; tde_credential_password =
          Aws.Util.option_bind (Aws.Xml.member "TdeCredentialPassword" xml) String.parse
      ; c_a_certificate_identifier =
          Aws.Util.option_bind (Aws.Xml.member "CACertificateIdentifier" xml) String.parse
      ; domain = Aws.Util.option_bind (Aws.Xml.member "Domain" xml) String.parse
      ; copy_tags_to_snapshot =
          Aws.Util.option_bind (Aws.Xml.member "CopyTagsToSnapshot" xml) Boolean.parse
      ; monitoring_interval =
          Aws.Util.option_bind (Aws.Xml.member "MonitoringInterval" xml) Integer.parse
      ; d_b_port_number =
          Aws.Util.option_bind (Aws.Xml.member "DBPortNumber" xml) Integer.parse
      ; publicly_accessible =
          Aws.Util.option_bind (Aws.Xml.member "PubliclyAccessible" xml) Boolean.parse
      ; monitoring_role_arn =
          Aws.Util.option_bind (Aws.Xml.member "MonitoringRoleArn" xml) String.parse
      ; domain_i_a_m_role_name =
          Aws.Util.option_bind (Aws.Xml.member "DomainIAMRoleName" xml) String.parse
      ; promotion_tier =
          Aws.Util.option_bind (Aws.Xml.member "PromotionTier" xml) Integer.parse
      ; enable_i_a_m_database_authentication =
          Aws.Util.option_bind
            (Aws.Xml.member "EnableIAMDatabaseAuthentication" xml)
            Boolean.parse
      ; enable_performance_insights =
          Aws.Util.option_bind
            (Aws.Xml.member "EnablePerformanceInsights" xml)
            Boolean.parse
      ; performance_insights_k_m_s_key_id =
          Aws.Util.option_bind
            (Aws.Xml.member "PerformanceInsightsKMSKeyId" xml)
            String.parse
      ; performance_insights_retention_period =
          Aws.Util.option_bind
            (Aws.Xml.member "PerformanceInsightsRetentionPeriod" xml)
            Integer.parse
      ; cloudwatch_logs_export_configuration =
          Aws.Util.option_bind
            (Aws.Xml.member "CloudwatchLogsExportConfiguration" xml)
            CloudwatchLogsExportConfiguration.parse
      ; processor_features =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ProcessorFeatures" xml)
               ProcessorFeatureList.parse)
      ; use_default_processor_features =
          Aws.Util.option_bind
            (Aws.Xml.member "UseDefaultProcessorFeatures" xml)
            Boolean.parse
      ; deletion_protection =
          Aws.Util.option_bind (Aws.Xml.member "DeletionProtection" xml) Boolean.parse
      ; max_allocated_storage =
          Aws.Util.option_bind (Aws.Xml.member "MaxAllocatedStorage" xml) Integer.parse
      ; certificate_rotation_restart =
          Aws.Util.option_bind
            (Aws.Xml.member "CertificateRotationRestart" xml)
            Boolean.parse
      ; replica_mode =
          Aws.Util.option_bind (Aws.Xml.member "ReplicaMode" xml) ReplicaMode.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.replica_mode (fun f ->
               Aws.Query.Pair ("ReplicaMode", ReplicaMode.to_query f))
         ; Aws.Util.option_map v.certificate_rotation_restart (fun f ->
               Aws.Query.Pair ("CertificateRotationRestart", Boolean.to_query f))
         ; Aws.Util.option_map v.max_allocated_storage (fun f ->
               Aws.Query.Pair ("MaxAllocatedStorage", Integer.to_query f))
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               Aws.Query.Pair ("DeletionProtection", Boolean.to_query f))
         ; Aws.Util.option_map v.use_default_processor_features (fun f ->
               Aws.Query.Pair ("UseDefaultProcessorFeatures", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ProcessorFeatures.member"
                , ProcessorFeatureList.to_query v.processor_features ))
         ; Aws.Util.option_map v.cloudwatch_logs_export_configuration (fun f ->
               Aws.Query.Pair
                 ( "CloudwatchLogsExportConfiguration"
                 , CloudwatchLogsExportConfiguration.to_query f ))
         ; Aws.Util.option_map v.performance_insights_retention_period (fun f ->
               Aws.Query.Pair ("PerformanceInsightsRetentionPeriod", Integer.to_query f))
         ; Aws.Util.option_map v.performance_insights_k_m_s_key_id (fun f ->
               Aws.Query.Pair ("PerformanceInsightsKMSKeyId", String.to_query f))
         ; Aws.Util.option_map v.enable_performance_insights (fun f ->
               Aws.Query.Pair ("EnablePerformanceInsights", Boolean.to_query f))
         ; Aws.Util.option_map v.enable_i_a_m_database_authentication (fun f ->
               Aws.Query.Pair ("EnableIAMDatabaseAuthentication", Boolean.to_query f))
         ; Aws.Util.option_map v.promotion_tier (fun f ->
               Aws.Query.Pair ("PromotionTier", Integer.to_query f))
         ; Aws.Util.option_map v.domain_i_a_m_role_name (fun f ->
               Aws.Query.Pair ("DomainIAMRoleName", String.to_query f))
         ; Aws.Util.option_map v.monitoring_role_arn (fun f ->
               Aws.Query.Pair ("MonitoringRoleArn", String.to_query f))
         ; Aws.Util.option_map v.publicly_accessible (fun f ->
               Aws.Query.Pair ("PubliclyAccessible", Boolean.to_query f))
         ; Aws.Util.option_map v.d_b_port_number (fun f ->
               Aws.Query.Pair ("DBPortNumber", Integer.to_query f))
         ; Aws.Util.option_map v.monitoring_interval (fun f ->
               Aws.Query.Pair ("MonitoringInterval", Integer.to_query f))
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               Aws.Query.Pair ("CopyTagsToSnapshot", Boolean.to_query f))
         ; Aws.Util.option_map v.domain (fun f ->
               Aws.Query.Pair ("Domain", String.to_query f))
         ; Aws.Util.option_map v.c_a_certificate_identifier (fun f ->
               Aws.Query.Pair ("CACertificateIdentifier", String.to_query f))
         ; Aws.Util.option_map v.tde_credential_password (fun f ->
               Aws.Query.Pair ("TdeCredentialPassword", String.to_query f))
         ; Aws.Util.option_map v.tde_credential_arn (fun f ->
               Aws.Query.Pair ("TdeCredentialArn", String.to_query f))
         ; Aws.Util.option_map v.storage_type (fun f ->
               Aws.Query.Pair ("StorageType", String.to_query f))
         ; Aws.Util.option_map v.new_d_b_instance_identifier (fun f ->
               Aws.Query.Pair ("NewDBInstanceIdentifier", String.to_query f))
         ; Aws.Util.option_map v.option_group_name (fun f ->
               Aws.Query.Pair ("OptionGroupName", String.to_query f))
         ; Aws.Util.option_map v.iops (fun f ->
               Aws.Query.Pair ("Iops", Integer.to_query f))
         ; Aws.Util.option_map v.license_model (fun f ->
               Aws.Query.Pair ("LicenseModel", String.to_query f))
         ; Aws.Util.option_map v.auto_minor_version_upgrade (fun f ->
               Aws.Query.Pair ("AutoMinorVersionUpgrade", Boolean.to_query f))
         ; Aws.Util.option_map v.allow_major_version_upgrade (fun f ->
               Aws.Query.Pair ("AllowMajorVersionUpgrade", Boolean.to_query f))
         ; Aws.Util.option_map v.engine_version (fun f ->
               Aws.Query.Pair ("EngineVersion", String.to_query f))
         ; Aws.Util.option_map v.multi_a_z (fun f ->
               Aws.Query.Pair ("MultiAZ", Boolean.to_query f))
         ; Aws.Util.option_map v.preferred_maintenance_window (fun f ->
               Aws.Query.Pair ("PreferredMaintenanceWindow", String.to_query f))
         ; Aws.Util.option_map v.preferred_backup_window (fun f ->
               Aws.Query.Pair ("PreferredBackupWindow", String.to_query f))
         ; Aws.Util.option_map v.backup_retention_period (fun f ->
               Aws.Query.Pair ("BackupRetentionPeriod", Integer.to_query f))
         ; Aws.Util.option_map v.d_b_parameter_group_name (fun f ->
               Aws.Query.Pair ("DBParameterGroupName", String.to_query f))
         ; Aws.Util.option_map v.master_user_password (fun f ->
               Aws.Query.Pair ("MasterUserPassword", String.to_query f))
         ; Aws.Util.option_map v.apply_immediately (fun f ->
               Aws.Query.Pair ("ApplyImmediately", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "VpcSecurityGroupIds.member"
                , VpcSecurityGroupIdList.to_query v.vpc_security_group_ids ))
         ; Some
             (Aws.Query.Pair
                ( "DBSecurityGroups.member"
                , DBSecurityGroupNameList.to_query v.d_b_security_groups ))
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               Aws.Query.Pair ("DBSubnetGroupName", String.to_query f))
         ; Aws.Util.option_map v.d_b_instance_class (fun f ->
               Aws.Query.Pair ("DBInstanceClass", String.to_query f))
         ; Aws.Util.option_map v.allocated_storage (fun f ->
               Aws.Query.Pair ("AllocatedStorage", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DBInstanceIdentifier", String.to_query v.d_b_instance_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.replica_mode (fun f ->
               "ReplicaMode", ReplicaMode.to_json f)
         ; Aws.Util.option_map v.certificate_rotation_restart (fun f ->
               "CertificateRotationRestart", Boolean.to_json f)
         ; Aws.Util.option_map v.max_allocated_storage (fun f ->
               "MaxAllocatedStorage", Integer.to_json f)
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               "DeletionProtection", Boolean.to_json f)
         ; Aws.Util.option_map v.use_default_processor_features (fun f ->
               "UseDefaultProcessorFeatures", Boolean.to_json f)
         ; Some ("ProcessorFeatures", ProcessorFeatureList.to_json v.processor_features)
         ; Aws.Util.option_map v.cloudwatch_logs_export_configuration (fun f ->
               ( "CloudwatchLogsExportConfiguration"
               , CloudwatchLogsExportConfiguration.to_json f ))
         ; Aws.Util.option_map v.performance_insights_retention_period (fun f ->
               "PerformanceInsightsRetentionPeriod", Integer.to_json f)
         ; Aws.Util.option_map v.performance_insights_k_m_s_key_id (fun f ->
               "PerformanceInsightsKMSKeyId", String.to_json f)
         ; Aws.Util.option_map v.enable_performance_insights (fun f ->
               "EnablePerformanceInsights", Boolean.to_json f)
         ; Aws.Util.option_map v.enable_i_a_m_database_authentication (fun f ->
               "EnableIAMDatabaseAuthentication", Boolean.to_json f)
         ; Aws.Util.option_map v.promotion_tier (fun f ->
               "PromotionTier", Integer.to_json f)
         ; Aws.Util.option_map v.domain_i_a_m_role_name (fun f ->
               "DomainIAMRoleName", String.to_json f)
         ; Aws.Util.option_map v.monitoring_role_arn (fun f ->
               "MonitoringRoleArn", String.to_json f)
         ; Aws.Util.option_map v.publicly_accessible (fun f ->
               "PubliclyAccessible", Boolean.to_json f)
         ; Aws.Util.option_map v.d_b_port_number (fun f ->
               "DBPortNumber", Integer.to_json f)
         ; Aws.Util.option_map v.monitoring_interval (fun f ->
               "MonitoringInterval", Integer.to_json f)
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               "CopyTagsToSnapshot", Boolean.to_json f)
         ; Aws.Util.option_map v.domain (fun f -> "Domain", String.to_json f)
         ; Aws.Util.option_map v.c_a_certificate_identifier (fun f ->
               "CACertificateIdentifier", String.to_json f)
         ; Aws.Util.option_map v.tde_credential_password (fun f ->
               "TdeCredentialPassword", String.to_json f)
         ; Aws.Util.option_map v.tde_credential_arn (fun f ->
               "TdeCredentialArn", String.to_json f)
         ; Aws.Util.option_map v.storage_type (fun f -> "StorageType", String.to_json f)
         ; Aws.Util.option_map v.new_d_b_instance_identifier (fun f ->
               "NewDBInstanceIdentifier", String.to_json f)
         ; Aws.Util.option_map v.option_group_name (fun f ->
               "OptionGroupName", String.to_json f)
         ; Aws.Util.option_map v.iops (fun f -> "Iops", Integer.to_json f)
         ; Aws.Util.option_map v.license_model (fun f -> "LicenseModel", String.to_json f)
         ; Aws.Util.option_map v.auto_minor_version_upgrade (fun f ->
               "AutoMinorVersionUpgrade", Boolean.to_json f)
         ; Aws.Util.option_map v.allow_major_version_upgrade (fun f ->
               "AllowMajorVersionUpgrade", Boolean.to_json f)
         ; Aws.Util.option_map v.engine_version (fun f ->
               "EngineVersion", String.to_json f)
         ; Aws.Util.option_map v.multi_a_z (fun f -> "MultiAZ", Boolean.to_json f)
         ; Aws.Util.option_map v.preferred_maintenance_window (fun f ->
               "PreferredMaintenanceWindow", String.to_json f)
         ; Aws.Util.option_map v.preferred_backup_window (fun f ->
               "PreferredBackupWindow", String.to_json f)
         ; Aws.Util.option_map v.backup_retention_period (fun f ->
               "BackupRetentionPeriod", Integer.to_json f)
         ; Aws.Util.option_map v.d_b_parameter_group_name (fun f ->
               "DBParameterGroupName", String.to_json f)
         ; Aws.Util.option_map v.master_user_password (fun f ->
               "MasterUserPassword", String.to_json f)
         ; Aws.Util.option_map v.apply_immediately (fun f ->
               "ApplyImmediately", Boolean.to_json f)
         ; Some
             ( "VpcSecurityGroupIds"
             , VpcSecurityGroupIdList.to_json v.vpc_security_group_ids )
         ; Some ("DBSecurityGroups", DBSecurityGroupNameList.to_json v.d_b_security_groups)
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               "DBSubnetGroupName", String.to_json f)
         ; Aws.Util.option_map v.d_b_instance_class (fun f ->
               "DBInstanceClass", String.to_json f)
         ; Aws.Util.option_map v.allocated_storage (fun f ->
               "AllocatedStorage", Integer.to_json f)
         ; Some ("DBInstanceIdentifier", String.to_json v.d_b_instance_identifier)
         ])

  let of_json j =
    { d_b_instance_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBInstanceIdentifier"))
    ; allocated_storage =
        Aws.Util.option_map (Aws.Json.lookup j "AllocatedStorage") Integer.of_json
    ; d_b_instance_class =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstanceClass") String.of_json
    ; d_b_subnet_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBSubnetGroupName") String.of_json
    ; d_b_security_groups =
        DBSecurityGroupNameList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBSecurityGroups"))
    ; vpc_security_group_ids =
        VpcSecurityGroupIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcSecurityGroupIds"))
    ; apply_immediately =
        Aws.Util.option_map (Aws.Json.lookup j "ApplyImmediately") Boolean.of_json
    ; master_user_password =
        Aws.Util.option_map (Aws.Json.lookup j "MasterUserPassword") String.of_json
    ; d_b_parameter_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBParameterGroupName") String.of_json
    ; backup_retention_period =
        Aws.Util.option_map (Aws.Json.lookup j "BackupRetentionPeriod") Integer.of_json
    ; preferred_backup_window =
        Aws.Util.option_map (Aws.Json.lookup j "PreferredBackupWindow") String.of_json
    ; preferred_maintenance_window =
        Aws.Util.option_map
          (Aws.Json.lookup j "PreferredMaintenanceWindow")
          String.of_json
    ; multi_a_z = Aws.Util.option_map (Aws.Json.lookup j "MultiAZ") Boolean.of_json
    ; engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "EngineVersion") String.of_json
    ; allow_major_version_upgrade =
        Aws.Util.option_map (Aws.Json.lookup j "AllowMajorVersionUpgrade") Boolean.of_json
    ; auto_minor_version_upgrade =
        Aws.Util.option_map (Aws.Json.lookup j "AutoMinorVersionUpgrade") Boolean.of_json
    ; license_model =
        Aws.Util.option_map (Aws.Json.lookup j "LicenseModel") String.of_json
    ; iops = Aws.Util.option_map (Aws.Json.lookup j "Iops") Integer.of_json
    ; option_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "OptionGroupName") String.of_json
    ; new_d_b_instance_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "NewDBInstanceIdentifier") String.of_json
    ; storage_type = Aws.Util.option_map (Aws.Json.lookup j "StorageType") String.of_json
    ; tde_credential_arn =
        Aws.Util.option_map (Aws.Json.lookup j "TdeCredentialArn") String.of_json
    ; tde_credential_password =
        Aws.Util.option_map (Aws.Json.lookup j "TdeCredentialPassword") String.of_json
    ; c_a_certificate_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "CACertificateIdentifier") String.of_json
    ; domain = Aws.Util.option_map (Aws.Json.lookup j "Domain") String.of_json
    ; copy_tags_to_snapshot =
        Aws.Util.option_map (Aws.Json.lookup j "CopyTagsToSnapshot") Boolean.of_json
    ; monitoring_interval =
        Aws.Util.option_map (Aws.Json.lookup j "MonitoringInterval") Integer.of_json
    ; d_b_port_number =
        Aws.Util.option_map (Aws.Json.lookup j "DBPortNumber") Integer.of_json
    ; publicly_accessible =
        Aws.Util.option_map (Aws.Json.lookup j "PubliclyAccessible") Boolean.of_json
    ; monitoring_role_arn =
        Aws.Util.option_map (Aws.Json.lookup j "MonitoringRoleArn") String.of_json
    ; domain_i_a_m_role_name =
        Aws.Util.option_map (Aws.Json.lookup j "DomainIAMRoleName") String.of_json
    ; promotion_tier =
        Aws.Util.option_map (Aws.Json.lookup j "PromotionTier") Integer.of_json
    ; enable_i_a_m_database_authentication =
        Aws.Util.option_map
          (Aws.Json.lookup j "EnableIAMDatabaseAuthentication")
          Boolean.of_json
    ; enable_performance_insights =
        Aws.Util.option_map
          (Aws.Json.lookup j "EnablePerformanceInsights")
          Boolean.of_json
    ; performance_insights_k_m_s_key_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "PerformanceInsightsKMSKeyId")
          String.of_json
    ; performance_insights_retention_period =
        Aws.Util.option_map
          (Aws.Json.lookup j "PerformanceInsightsRetentionPeriod")
          Integer.of_json
    ; cloudwatch_logs_export_configuration =
        Aws.Util.option_map
          (Aws.Json.lookup j "CloudwatchLogsExportConfiguration")
          CloudwatchLogsExportConfiguration.of_json
    ; processor_features =
        ProcessorFeatureList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ProcessorFeatures"))
    ; use_default_processor_features =
        Aws.Util.option_map
          (Aws.Json.lookup j "UseDefaultProcessorFeatures")
          Boolean.of_json
    ; deletion_protection =
        Aws.Util.option_map (Aws.Json.lookup j "DeletionProtection") Boolean.of_json
    ; max_allocated_storage =
        Aws.Util.option_map (Aws.Json.lookup j "MaxAllocatedStorage") Integer.of_json
    ; certificate_rotation_restart =
        Aws.Util.option_map
          (Aws.Json.lookup j "CertificateRotationRestart")
          Boolean.of_json
    ; replica_mode =
        Aws.Util.option_map (Aws.Json.lookup j "ReplicaMode") ReplicaMode.of_json
    }
end

module InvalidDBSubnetGroupFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module ModifyOptionGroupResult = struct
  type t = { option_group : OptionGroup.t option }

  let make ?option_group () = { option_group }

  let parse xml =
    Some
      { option_group =
          Aws.Util.option_bind (Aws.Xml.member "OptionGroup" xml) OptionGroup.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.option_group (fun f ->
               Aws.Query.Pair ("OptionGroup", OptionGroup.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.option_group (fun f ->
               "OptionGroup", OptionGroup.to_json f)
         ])

  let of_json j =
    { option_group =
        Aws.Util.option_map (Aws.Json.lookup j "OptionGroup") OptionGroup.of_json
    }
end

module ModifyDBClusterParameterGroupMessage = struct
  type t =
    { d_b_cluster_parameter_group_name : String.t
    ; parameters : ParametersList.t
    }

  let make ~d_b_cluster_parameter_group_name ~parameters () =
    { d_b_cluster_parameter_group_name; parameters }

  let parse xml =
    Some
      { d_b_cluster_parameter_group_name =
          Aws.Xml.required
            "DBClusterParameterGroupName"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBClusterParameterGroupName" xml)
               String.parse)
      ; parameters =
          Aws.Xml.required
            "Parameters"
            (Aws.Util.option_bind (Aws.Xml.member "Parameters" xml) ParametersList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("Parameters.member", ParametersList.to_query v.parameters))
         ; Some
             (Aws.Query.Pair
                ( "DBClusterParameterGroupName"
                , String.to_query v.d_b_cluster_parameter_group_name ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Parameters", ParametersList.to_json v.parameters)
         ; Some
             ( "DBClusterParameterGroupName"
             , String.to_json v.d_b_cluster_parameter_group_name )
         ])

  let of_json j =
    { d_b_cluster_parameter_group_name =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterParameterGroupName"))
    ; parameters =
        ParametersList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Parameters"))
    }
end

module DBInstanceAutomatedBackupNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module CreateDBClusterMessage = struct
  type t =
    { availability_zones : AvailabilityZones.t
    ; backup_retention_period : Integer.t option
    ; character_set_name : String.t option
    ; database_name : String.t option
    ; d_b_cluster_identifier : String.t
    ; d_b_cluster_parameter_group_name : String.t option
    ; vpc_security_group_ids : VpcSecurityGroupIdList.t
    ; d_b_subnet_group_name : String.t option
    ; engine : String.t
    ; engine_version : String.t option
    ; port : Integer.t option
    ; master_username : String.t option
    ; master_user_password : String.t option
    ; option_group_name : String.t option
    ; preferred_backup_window : String.t option
    ; preferred_maintenance_window : String.t option
    ; replication_source_identifier : String.t option
    ; tags : TagList.t
    ; storage_encrypted : Boolean.t option
    ; kms_key_id : String.t option
    ; pre_signed_url : String.t option
    ; enable_i_a_m_database_authentication : Boolean.t option
    ; backtrack_window : Long.t option
    ; enable_cloudwatch_logs_exports : LogTypeList.t
    ; engine_mode : String.t option
    ; scaling_configuration : ScalingConfiguration.t option
    ; deletion_protection : Boolean.t option
    ; global_cluster_identifier : String.t option
    ; enable_http_endpoint : Boolean.t option
    ; copy_tags_to_snapshot : Boolean.t option
    ; domain : String.t option
    ; domain_i_a_m_role_name : String.t option
    ; enable_global_write_forwarding : Boolean.t option
    }

  let make
      ?(availability_zones = [])
      ?backup_retention_period
      ?character_set_name
      ?database_name
      ~d_b_cluster_identifier
      ?d_b_cluster_parameter_group_name
      ?(vpc_security_group_ids = [])
      ?d_b_subnet_group_name
      ~engine
      ?engine_version
      ?port
      ?master_username
      ?master_user_password
      ?option_group_name
      ?preferred_backup_window
      ?preferred_maintenance_window
      ?replication_source_identifier
      ?(tags = [])
      ?storage_encrypted
      ?kms_key_id
      ?pre_signed_url
      ?enable_i_a_m_database_authentication
      ?backtrack_window
      ?(enable_cloudwatch_logs_exports = [])
      ?engine_mode
      ?scaling_configuration
      ?deletion_protection
      ?global_cluster_identifier
      ?enable_http_endpoint
      ?copy_tags_to_snapshot
      ?domain
      ?domain_i_a_m_role_name
      ?enable_global_write_forwarding
      () =
    { availability_zones
    ; backup_retention_period
    ; character_set_name
    ; database_name
    ; d_b_cluster_identifier
    ; d_b_cluster_parameter_group_name
    ; vpc_security_group_ids
    ; d_b_subnet_group_name
    ; engine
    ; engine_version
    ; port
    ; master_username
    ; master_user_password
    ; option_group_name
    ; preferred_backup_window
    ; preferred_maintenance_window
    ; replication_source_identifier
    ; tags
    ; storage_encrypted
    ; kms_key_id
    ; pre_signed_url
    ; enable_i_a_m_database_authentication
    ; backtrack_window
    ; enable_cloudwatch_logs_exports
    ; engine_mode
    ; scaling_configuration
    ; deletion_protection
    ; global_cluster_identifier
    ; enable_http_endpoint
    ; copy_tags_to_snapshot
    ; domain
    ; domain_i_a_m_role_name
    ; enable_global_write_forwarding
    }

  let parse xml =
    Some
      { availability_zones =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AvailabilityZones" xml)
               AvailabilityZones.parse)
      ; backup_retention_period =
          Aws.Util.option_bind (Aws.Xml.member "BackupRetentionPeriod" xml) Integer.parse
      ; character_set_name =
          Aws.Util.option_bind (Aws.Xml.member "CharacterSetName" xml) String.parse
      ; database_name =
          Aws.Util.option_bind (Aws.Xml.member "DatabaseName" xml) String.parse
      ; d_b_cluster_identifier =
          Aws.Xml.required
            "DBClusterIdentifier"
            (Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse)
      ; d_b_cluster_parameter_group_name =
          Aws.Util.option_bind
            (Aws.Xml.member "DBClusterParameterGroupName" xml)
            String.parse
      ; vpc_security_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "VpcSecurityGroupIds" xml)
               VpcSecurityGroupIdList.parse)
      ; d_b_subnet_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBSubnetGroupName" xml) String.parse
      ; engine =
          Aws.Xml.required
            "Engine"
            (Aws.Util.option_bind (Aws.Xml.member "Engine" xml) String.parse)
      ; engine_version =
          Aws.Util.option_bind (Aws.Xml.member "EngineVersion" xml) String.parse
      ; port = Aws.Util.option_bind (Aws.Xml.member "Port" xml) Integer.parse
      ; master_username =
          Aws.Util.option_bind (Aws.Xml.member "MasterUsername" xml) String.parse
      ; master_user_password =
          Aws.Util.option_bind (Aws.Xml.member "MasterUserPassword" xml) String.parse
      ; option_group_name =
          Aws.Util.option_bind (Aws.Xml.member "OptionGroupName" xml) String.parse
      ; preferred_backup_window =
          Aws.Util.option_bind (Aws.Xml.member "PreferredBackupWindow" xml) String.parse
      ; preferred_maintenance_window =
          Aws.Util.option_bind
            (Aws.Xml.member "PreferredMaintenanceWindow" xml)
            String.parse
      ; replication_source_identifier =
          Aws.Util.option_bind
            (Aws.Xml.member "ReplicationSourceIdentifier" xml)
            String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      ; storage_encrypted =
          Aws.Util.option_bind (Aws.Xml.member "StorageEncrypted" xml) Boolean.parse
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "KmsKeyId" xml) String.parse
      ; pre_signed_url =
          Aws.Util.option_bind (Aws.Xml.member "PreSignedUrl" xml) String.parse
      ; enable_i_a_m_database_authentication =
          Aws.Util.option_bind
            (Aws.Xml.member "EnableIAMDatabaseAuthentication" xml)
            Boolean.parse
      ; backtrack_window =
          Aws.Util.option_bind (Aws.Xml.member "BacktrackWindow" xml) Long.parse
      ; enable_cloudwatch_logs_exports =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "EnableCloudwatchLogsExports" xml)
               LogTypeList.parse)
      ; engine_mode = Aws.Util.option_bind (Aws.Xml.member "EngineMode" xml) String.parse
      ; scaling_configuration =
          Aws.Util.option_bind
            (Aws.Xml.member "ScalingConfiguration" xml)
            ScalingConfiguration.parse
      ; deletion_protection =
          Aws.Util.option_bind (Aws.Xml.member "DeletionProtection" xml) Boolean.parse
      ; global_cluster_identifier =
          Aws.Util.option_bind (Aws.Xml.member "GlobalClusterIdentifier" xml) String.parse
      ; enable_http_endpoint =
          Aws.Util.option_bind (Aws.Xml.member "EnableHttpEndpoint" xml) Boolean.parse
      ; copy_tags_to_snapshot =
          Aws.Util.option_bind (Aws.Xml.member "CopyTagsToSnapshot" xml) Boolean.parse
      ; domain = Aws.Util.option_bind (Aws.Xml.member "Domain" xml) String.parse
      ; domain_i_a_m_role_name =
          Aws.Util.option_bind (Aws.Xml.member "DomainIAMRoleName" xml) String.parse
      ; enable_global_write_forwarding =
          Aws.Util.option_bind
            (Aws.Xml.member "EnableGlobalWriteForwarding" xml)
            Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enable_global_write_forwarding (fun f ->
               Aws.Query.Pair ("EnableGlobalWriteForwarding", Boolean.to_query f))
         ; Aws.Util.option_map v.domain_i_a_m_role_name (fun f ->
               Aws.Query.Pair ("DomainIAMRoleName", String.to_query f))
         ; Aws.Util.option_map v.domain (fun f ->
               Aws.Query.Pair ("Domain", String.to_query f))
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               Aws.Query.Pair ("CopyTagsToSnapshot", Boolean.to_query f))
         ; Aws.Util.option_map v.enable_http_endpoint (fun f ->
               Aws.Query.Pair ("EnableHttpEndpoint", Boolean.to_query f))
         ; Aws.Util.option_map v.global_cluster_identifier (fun f ->
               Aws.Query.Pair ("GlobalClusterIdentifier", String.to_query f))
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               Aws.Query.Pair ("DeletionProtection", Boolean.to_query f))
         ; Aws.Util.option_map v.scaling_configuration (fun f ->
               Aws.Query.Pair ("ScalingConfiguration", ScalingConfiguration.to_query f))
         ; Aws.Util.option_map v.engine_mode (fun f ->
               Aws.Query.Pair ("EngineMode", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "EnableCloudwatchLogsExports.member"
                , LogTypeList.to_query v.enable_cloudwatch_logs_exports ))
         ; Aws.Util.option_map v.backtrack_window (fun f ->
               Aws.Query.Pair ("BacktrackWindow", Long.to_query f))
         ; Aws.Util.option_map v.enable_i_a_m_database_authentication (fun f ->
               Aws.Query.Pair ("EnableIAMDatabaseAuthentication", Boolean.to_query f))
         ; Aws.Util.option_map v.pre_signed_url (fun f ->
               Aws.Query.Pair ("PreSignedUrl", String.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Aws.Util.option_map v.storage_encrypted (fun f ->
               Aws.Query.Pair ("StorageEncrypted", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Aws.Util.option_map v.replication_source_identifier (fun f ->
               Aws.Query.Pair ("ReplicationSourceIdentifier", String.to_query f))
         ; Aws.Util.option_map v.preferred_maintenance_window (fun f ->
               Aws.Query.Pair ("PreferredMaintenanceWindow", String.to_query f))
         ; Aws.Util.option_map v.preferred_backup_window (fun f ->
               Aws.Query.Pair ("PreferredBackupWindow", String.to_query f))
         ; Aws.Util.option_map v.option_group_name (fun f ->
               Aws.Query.Pair ("OptionGroupName", String.to_query f))
         ; Aws.Util.option_map v.master_user_password (fun f ->
               Aws.Query.Pair ("MasterUserPassword", String.to_query f))
         ; Aws.Util.option_map v.master_username (fun f ->
               Aws.Query.Pair ("MasterUsername", String.to_query f))
         ; Aws.Util.option_map v.port (fun f ->
               Aws.Query.Pair ("Port", Integer.to_query f))
         ; Aws.Util.option_map v.engine_version (fun f ->
               Aws.Query.Pair ("EngineVersion", String.to_query f))
         ; Some (Aws.Query.Pair ("Engine", String.to_query v.engine))
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               Aws.Query.Pair ("DBSubnetGroupName", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "VpcSecurityGroupIds.member"
                , VpcSecurityGroupIdList.to_query v.vpc_security_group_ids ))
         ; Aws.Util.option_map v.d_b_cluster_parameter_group_name (fun f ->
               Aws.Query.Pair ("DBClusterParameterGroupName", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DBClusterIdentifier", String.to_query v.d_b_cluster_identifier))
         ; Aws.Util.option_map v.database_name (fun f ->
               Aws.Query.Pair ("DatabaseName", String.to_query f))
         ; Aws.Util.option_map v.character_set_name (fun f ->
               Aws.Query.Pair ("CharacterSetName", String.to_query f))
         ; Aws.Util.option_map v.backup_retention_period (fun f ->
               Aws.Query.Pair ("BackupRetentionPeriod", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "AvailabilityZones.member"
                , AvailabilityZones.to_query v.availability_zones ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enable_global_write_forwarding (fun f ->
               "EnableGlobalWriteForwarding", Boolean.to_json f)
         ; Aws.Util.option_map v.domain_i_a_m_role_name (fun f ->
               "DomainIAMRoleName", String.to_json f)
         ; Aws.Util.option_map v.domain (fun f -> "Domain", String.to_json f)
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               "CopyTagsToSnapshot", Boolean.to_json f)
         ; Aws.Util.option_map v.enable_http_endpoint (fun f ->
               "EnableHttpEndpoint", Boolean.to_json f)
         ; Aws.Util.option_map v.global_cluster_identifier (fun f ->
               "GlobalClusterIdentifier", String.to_json f)
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               "DeletionProtection", Boolean.to_json f)
         ; Aws.Util.option_map v.scaling_configuration (fun f ->
               "ScalingConfiguration", ScalingConfiguration.to_json f)
         ; Aws.Util.option_map v.engine_mode (fun f -> "EngineMode", String.to_json f)
         ; Some
             ( "EnableCloudwatchLogsExports"
             , LogTypeList.to_json v.enable_cloudwatch_logs_exports )
         ; Aws.Util.option_map v.backtrack_window (fun f ->
               "BacktrackWindow", Long.to_json f)
         ; Aws.Util.option_map v.enable_i_a_m_database_authentication (fun f ->
               "EnableIAMDatabaseAuthentication", Boolean.to_json f)
         ; Aws.Util.option_map v.pre_signed_url (fun f ->
               "PreSignedUrl", String.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "KmsKeyId", String.to_json f)
         ; Aws.Util.option_map v.storage_encrypted (fun f ->
               "StorageEncrypted", Boolean.to_json f)
         ; Some ("Tags", TagList.to_json v.tags)
         ; Aws.Util.option_map v.replication_source_identifier (fun f ->
               "ReplicationSourceIdentifier", String.to_json f)
         ; Aws.Util.option_map v.preferred_maintenance_window (fun f ->
               "PreferredMaintenanceWindow", String.to_json f)
         ; Aws.Util.option_map v.preferred_backup_window (fun f ->
               "PreferredBackupWindow", String.to_json f)
         ; Aws.Util.option_map v.option_group_name (fun f ->
               "OptionGroupName", String.to_json f)
         ; Aws.Util.option_map v.master_user_password (fun f ->
               "MasterUserPassword", String.to_json f)
         ; Aws.Util.option_map v.master_username (fun f ->
               "MasterUsername", String.to_json f)
         ; Aws.Util.option_map v.port (fun f -> "Port", Integer.to_json f)
         ; Aws.Util.option_map v.engine_version (fun f ->
               "EngineVersion", String.to_json f)
         ; Some ("Engine", String.to_json v.engine)
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               "DBSubnetGroupName", String.to_json f)
         ; Some
             ( "VpcSecurityGroupIds"
             , VpcSecurityGroupIdList.to_json v.vpc_security_group_ids )
         ; Aws.Util.option_map v.d_b_cluster_parameter_group_name (fun f ->
               "DBClusterParameterGroupName", String.to_json f)
         ; Some ("DBClusterIdentifier", String.to_json v.d_b_cluster_identifier)
         ; Aws.Util.option_map v.database_name (fun f -> "DatabaseName", String.to_json f)
         ; Aws.Util.option_map v.character_set_name (fun f ->
               "CharacterSetName", String.to_json f)
         ; Aws.Util.option_map v.backup_retention_period (fun f ->
               "BackupRetentionPeriod", Integer.to_json f)
         ; Some ("AvailabilityZones", AvailabilityZones.to_json v.availability_zones)
         ])

  let of_json j =
    { availability_zones =
        AvailabilityZones.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AvailabilityZones"))
    ; backup_retention_period =
        Aws.Util.option_map (Aws.Json.lookup j "BackupRetentionPeriod") Integer.of_json
    ; character_set_name =
        Aws.Util.option_map (Aws.Json.lookup j "CharacterSetName") String.of_json
    ; database_name =
        Aws.Util.option_map (Aws.Json.lookup j "DatabaseName") String.of_json
    ; d_b_cluster_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterIdentifier"))
    ; d_b_cluster_parameter_group_name =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBClusterParameterGroupName")
          String.of_json
    ; vpc_security_group_ids =
        VpcSecurityGroupIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcSecurityGroupIds"))
    ; d_b_subnet_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBSubnetGroupName") String.of_json
    ; engine = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Engine"))
    ; engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "EngineVersion") String.of_json
    ; port = Aws.Util.option_map (Aws.Json.lookup j "Port") Integer.of_json
    ; master_username =
        Aws.Util.option_map (Aws.Json.lookup j "MasterUsername") String.of_json
    ; master_user_password =
        Aws.Util.option_map (Aws.Json.lookup j "MasterUserPassword") String.of_json
    ; option_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "OptionGroupName") String.of_json
    ; preferred_backup_window =
        Aws.Util.option_map (Aws.Json.lookup j "PreferredBackupWindow") String.of_json
    ; preferred_maintenance_window =
        Aws.Util.option_map
          (Aws.Json.lookup j "PreferredMaintenanceWindow")
          String.of_json
    ; replication_source_identifier =
        Aws.Util.option_map
          (Aws.Json.lookup j "ReplicationSourceIdentifier")
          String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    ; storage_encrypted =
        Aws.Util.option_map (Aws.Json.lookup j "StorageEncrypted") Boolean.of_json
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "KmsKeyId") String.of_json
    ; pre_signed_url =
        Aws.Util.option_map (Aws.Json.lookup j "PreSignedUrl") String.of_json
    ; enable_i_a_m_database_authentication =
        Aws.Util.option_map
          (Aws.Json.lookup j "EnableIAMDatabaseAuthentication")
          Boolean.of_json
    ; backtrack_window =
        Aws.Util.option_map (Aws.Json.lookup j "BacktrackWindow") Long.of_json
    ; enable_cloudwatch_logs_exports =
        LogTypeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "EnableCloudwatchLogsExports"))
    ; engine_mode = Aws.Util.option_map (Aws.Json.lookup j "EngineMode") String.of_json
    ; scaling_configuration =
        Aws.Util.option_map
          (Aws.Json.lookup j "ScalingConfiguration")
          ScalingConfiguration.of_json
    ; deletion_protection =
        Aws.Util.option_map (Aws.Json.lookup j "DeletionProtection") Boolean.of_json
    ; global_cluster_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "GlobalClusterIdentifier") String.of_json
    ; enable_http_endpoint =
        Aws.Util.option_map (Aws.Json.lookup j "EnableHttpEndpoint") Boolean.of_json
    ; copy_tags_to_snapshot =
        Aws.Util.option_map (Aws.Json.lookup j "CopyTagsToSnapshot") Boolean.of_json
    ; domain = Aws.Util.option_map (Aws.Json.lookup j "Domain") String.of_json
    ; domain_i_a_m_role_name =
        Aws.Util.option_map (Aws.Json.lookup j "DomainIAMRoleName") String.of_json
    ; enable_global_write_forwarding =
        Aws.Util.option_map
          (Aws.Json.lookup j "EnableGlobalWriteForwarding")
          Boolean.of_json
    }
end

module DBSubnetGroupQuotaExceededFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DBInstanceRoleQuotaExceededFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DescribeDBClustersMessage = struct
  type t =
    { d_b_cluster_identifier : String.t option
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    ; include_shared : Boolean.t option
    }

  let make ?d_b_cluster_identifier ?(filters = []) ?max_records ?marker ?include_shared ()
      =
    { d_b_cluster_identifier; filters; max_records; marker; include_shared }

  let parse xml =
    Some
      { d_b_cluster_identifier =
          Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; include_shared =
          Aws.Util.option_bind (Aws.Xml.member "IncludeShared" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.include_shared (fun f ->
               Aws.Query.Pair ("IncludeShared", Boolean.to_query f))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.d_b_cluster_identifier (fun f ->
               Aws.Query.Pair ("DBClusterIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.include_shared (fun f ->
               "IncludeShared", Boolean.to_json f)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.d_b_cluster_identifier (fun f ->
               "DBClusterIdentifier", String.to_json f)
         ])

  let of_json j =
    { d_b_cluster_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "DBClusterIdentifier") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; include_shared =
        Aws.Util.option_map (Aws.Json.lookup j "IncludeShared") Boolean.of_json
    }
end

module CopyDBClusterSnapshotMessage = struct
  type t =
    { source_d_b_cluster_snapshot_identifier : String.t
    ; target_d_b_cluster_snapshot_identifier : String.t
    ; kms_key_id : String.t option
    ; pre_signed_url : String.t option
    ; copy_tags : Boolean.t option
    ; tags : TagList.t
    }

  let make
      ~source_d_b_cluster_snapshot_identifier
      ~target_d_b_cluster_snapshot_identifier
      ?kms_key_id
      ?pre_signed_url
      ?copy_tags
      ?(tags = [])
      () =
    { source_d_b_cluster_snapshot_identifier
    ; target_d_b_cluster_snapshot_identifier
    ; kms_key_id
    ; pre_signed_url
    ; copy_tags
    ; tags
    }

  let parse xml =
    Some
      { source_d_b_cluster_snapshot_identifier =
          Aws.Xml.required
            "SourceDBClusterSnapshotIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "SourceDBClusterSnapshotIdentifier" xml)
               String.parse)
      ; target_d_b_cluster_snapshot_identifier =
          Aws.Xml.required
            "TargetDBClusterSnapshotIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "TargetDBClusterSnapshotIdentifier" xml)
               String.parse)
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "KmsKeyId" xml) String.parse
      ; pre_signed_url =
          Aws.Util.option_bind (Aws.Xml.member "PreSignedUrl" xml) String.parse
      ; copy_tags = Aws.Util.option_bind (Aws.Xml.member "CopyTags" xml) Boolean.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Aws.Util.option_map v.copy_tags (fun f ->
               Aws.Query.Pair ("CopyTags", Boolean.to_query f))
         ; Aws.Util.option_map v.pre_signed_url (fun f ->
               Aws.Query.Pair ("PreSignedUrl", String.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TargetDBClusterSnapshotIdentifier"
                , String.to_query v.target_d_b_cluster_snapshot_identifier ))
         ; Some
             (Aws.Query.Pair
                ( "SourceDBClusterSnapshotIdentifier"
                , String.to_query v.source_d_b_cluster_snapshot_identifier ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tags", TagList.to_json v.tags)
         ; Aws.Util.option_map v.copy_tags (fun f -> "CopyTags", Boolean.to_json f)
         ; Aws.Util.option_map v.pre_signed_url (fun f ->
               "PreSignedUrl", String.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "KmsKeyId", String.to_json f)
         ; Some
             ( "TargetDBClusterSnapshotIdentifier"
             , String.to_json v.target_d_b_cluster_snapshot_identifier )
         ; Some
             ( "SourceDBClusterSnapshotIdentifier"
             , String.to_json v.source_d_b_cluster_snapshot_identifier )
         ])

  let of_json j =
    { source_d_b_cluster_snapshot_identifier =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceDBClusterSnapshotIdentifier"))
    ; target_d_b_cluster_snapshot_identifier =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TargetDBClusterSnapshotIdentifier"))
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "KmsKeyId") String.of_json
    ; pre_signed_url =
        Aws.Util.option_map (Aws.Json.lookup j "PreSignedUrl") String.of_json
    ; copy_tags = Aws.Util.option_map (Aws.Json.lookup j "CopyTags") Boolean.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    }
end

module CopyDBClusterSnapshotResult = struct
  type t = { d_b_cluster_snapshot : DBClusterSnapshot.t option }

  let make ?d_b_cluster_snapshot () = { d_b_cluster_snapshot }

  let parse xml =
    Some
      { d_b_cluster_snapshot =
          Aws.Util.option_bind
            (Aws.Xml.member "DBClusterSnapshot" xml)
            DBClusterSnapshot.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster_snapshot (fun f ->
               Aws.Query.Pair ("DBClusterSnapshot", DBClusterSnapshot.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster_snapshot (fun f ->
               "DBClusterSnapshot", DBClusterSnapshot.to_json f)
         ])

  let of_json j =
    { d_b_cluster_snapshot =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBClusterSnapshot")
          DBClusterSnapshot.of_json
    }
end

module DBClusterCapacityInfo = struct
  type t =
    { d_b_cluster_identifier : String.t option
    ; pending_capacity : Integer.t option
    ; current_capacity : Integer.t option
    ; seconds_before_timeout : Integer.t option
    ; timeout_action : String.t option
    }

  let make
      ?d_b_cluster_identifier
      ?pending_capacity
      ?current_capacity
      ?seconds_before_timeout
      ?timeout_action
      () =
    { d_b_cluster_identifier
    ; pending_capacity
    ; current_capacity
    ; seconds_before_timeout
    ; timeout_action
    }

  let parse xml =
    Some
      { d_b_cluster_identifier =
          Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse
      ; pending_capacity =
          Aws.Util.option_bind (Aws.Xml.member "PendingCapacity" xml) Integer.parse
      ; current_capacity =
          Aws.Util.option_bind (Aws.Xml.member "CurrentCapacity" xml) Integer.parse
      ; seconds_before_timeout =
          Aws.Util.option_bind (Aws.Xml.member "SecondsBeforeTimeout" xml) Integer.parse
      ; timeout_action =
          Aws.Util.option_bind (Aws.Xml.member "TimeoutAction" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timeout_action (fun f ->
               Aws.Query.Pair ("TimeoutAction", String.to_query f))
         ; Aws.Util.option_map v.seconds_before_timeout (fun f ->
               Aws.Query.Pair ("SecondsBeforeTimeout", Integer.to_query f))
         ; Aws.Util.option_map v.current_capacity (fun f ->
               Aws.Query.Pair ("CurrentCapacity", Integer.to_query f))
         ; Aws.Util.option_map v.pending_capacity (fun f ->
               Aws.Query.Pair ("PendingCapacity", Integer.to_query f))
         ; Aws.Util.option_map v.d_b_cluster_identifier (fun f ->
               Aws.Query.Pair ("DBClusterIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timeout_action (fun f ->
               "TimeoutAction", String.to_json f)
         ; Aws.Util.option_map v.seconds_before_timeout (fun f ->
               "SecondsBeforeTimeout", Integer.to_json f)
         ; Aws.Util.option_map v.current_capacity (fun f ->
               "CurrentCapacity", Integer.to_json f)
         ; Aws.Util.option_map v.pending_capacity (fun f ->
               "PendingCapacity", Integer.to_json f)
         ; Aws.Util.option_map v.d_b_cluster_identifier (fun f ->
               "DBClusterIdentifier", String.to_json f)
         ])

  let of_json j =
    { d_b_cluster_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "DBClusterIdentifier") String.of_json
    ; pending_capacity =
        Aws.Util.option_map (Aws.Json.lookup j "PendingCapacity") Integer.of_json
    ; current_capacity =
        Aws.Util.option_map (Aws.Json.lookup j "CurrentCapacity") Integer.of_json
    ; seconds_before_timeout =
        Aws.Util.option_map (Aws.Json.lookup j "SecondsBeforeTimeout") Integer.of_json
    ; timeout_action =
        Aws.Util.option_map (Aws.Json.lookup j "TimeoutAction") String.of_json
    }
end

module InvalidExportSourceStateFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DescribeDBSnapshotsMessage = struct
  type t =
    { d_b_instance_identifier : String.t option
    ; d_b_snapshot_identifier : String.t option
    ; snapshot_type : String.t option
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    ; include_shared : Boolean.t option
    ; include_public : Boolean.t option
    ; dbi_resource_id : String.t option
    }

  let make
      ?d_b_instance_identifier
      ?d_b_snapshot_identifier
      ?snapshot_type
      ?(filters = [])
      ?max_records
      ?marker
      ?include_shared
      ?include_public
      ?dbi_resource_id
      () =
    { d_b_instance_identifier
    ; d_b_snapshot_identifier
    ; snapshot_type
    ; filters
    ; max_records
    ; marker
    ; include_shared
    ; include_public
    ; dbi_resource_id
    }

  let parse xml =
    Some
      { d_b_instance_identifier =
          Aws.Util.option_bind (Aws.Xml.member "DBInstanceIdentifier" xml) String.parse
      ; d_b_snapshot_identifier =
          Aws.Util.option_bind (Aws.Xml.member "DBSnapshotIdentifier" xml) String.parse
      ; snapshot_type =
          Aws.Util.option_bind (Aws.Xml.member "SnapshotType" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; include_shared =
          Aws.Util.option_bind (Aws.Xml.member "IncludeShared" xml) Boolean.parse
      ; include_public =
          Aws.Util.option_bind (Aws.Xml.member "IncludePublic" xml) Boolean.parse
      ; dbi_resource_id =
          Aws.Util.option_bind (Aws.Xml.member "DbiResourceId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dbi_resource_id (fun f ->
               Aws.Query.Pair ("DbiResourceId", String.to_query f))
         ; Aws.Util.option_map v.include_public (fun f ->
               Aws.Query.Pair ("IncludePublic", Boolean.to_query f))
         ; Aws.Util.option_map v.include_shared (fun f ->
               Aws.Query.Pair ("IncludeShared", Boolean.to_query f))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.snapshot_type (fun f ->
               Aws.Query.Pair ("SnapshotType", String.to_query f))
         ; Aws.Util.option_map v.d_b_snapshot_identifier (fun f ->
               Aws.Query.Pair ("DBSnapshotIdentifier", String.to_query f))
         ; Aws.Util.option_map v.d_b_instance_identifier (fun f ->
               Aws.Query.Pair ("DBInstanceIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dbi_resource_id (fun f ->
               "DbiResourceId", String.to_json f)
         ; Aws.Util.option_map v.include_public (fun f ->
               "IncludePublic", Boolean.to_json f)
         ; Aws.Util.option_map v.include_shared (fun f ->
               "IncludeShared", Boolean.to_json f)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.snapshot_type (fun f -> "SnapshotType", String.to_json f)
         ; Aws.Util.option_map v.d_b_snapshot_identifier (fun f ->
               "DBSnapshotIdentifier", String.to_json f)
         ; Aws.Util.option_map v.d_b_instance_identifier (fun f ->
               "DBInstanceIdentifier", String.to_json f)
         ])

  let of_json j =
    { d_b_instance_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstanceIdentifier") String.of_json
    ; d_b_snapshot_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "DBSnapshotIdentifier") String.of_json
    ; snapshot_type =
        Aws.Util.option_map (Aws.Json.lookup j "SnapshotType") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; include_shared =
        Aws.Util.option_map (Aws.Json.lookup j "IncludeShared") Boolean.of_json
    ; include_public =
        Aws.Util.option_map (Aws.Json.lookup j "IncludePublic") Boolean.of_json
    ; dbi_resource_id =
        Aws.Util.option_map (Aws.Json.lookup j "DbiResourceId") String.of_json
    }
end

module EventCategoriesMessage = struct
  type t = { event_categories_map_list : EventCategoriesMapList.t }

  let make ?(event_categories_map_list = []) () = { event_categories_map_list }

  let parse xml =
    Some
      { event_categories_map_list =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "EventCategoriesMapList" xml)
               EventCategoriesMapList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "EventCategoriesMapList.member"
                , EventCategoriesMapList.to_query v.event_categories_map_list ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "EventCategoriesMapList"
             , EventCategoriesMapList.to_json v.event_categories_map_list )
         ])

  let of_json j =
    { event_categories_map_list =
        EventCategoriesMapList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "EventCategoriesMapList"))
    }
end

module DBLogFileNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module RestoreDBClusterToPointInTimeMessage = struct
  type t =
    { d_b_cluster_identifier : String.t
    ; restore_type : String.t option
    ; source_d_b_cluster_identifier : String.t
    ; restore_to_time : DateTime.t option
    ; use_latest_restorable_time : Boolean.t option
    ; port : Integer.t option
    ; d_b_subnet_group_name : String.t option
    ; option_group_name : String.t option
    ; vpc_security_group_ids : VpcSecurityGroupIdList.t
    ; tags : TagList.t
    ; kms_key_id : String.t option
    ; enable_i_a_m_database_authentication : Boolean.t option
    ; backtrack_window : Long.t option
    ; enable_cloudwatch_logs_exports : LogTypeList.t
    ; d_b_cluster_parameter_group_name : String.t option
    ; deletion_protection : Boolean.t option
    ; copy_tags_to_snapshot : Boolean.t option
    ; domain : String.t option
    ; domain_i_a_m_role_name : String.t option
    }

  let make
      ~d_b_cluster_identifier
      ?restore_type
      ~source_d_b_cluster_identifier
      ?restore_to_time
      ?use_latest_restorable_time
      ?port
      ?d_b_subnet_group_name
      ?option_group_name
      ?(vpc_security_group_ids = [])
      ?(tags = [])
      ?kms_key_id
      ?enable_i_a_m_database_authentication
      ?backtrack_window
      ?(enable_cloudwatch_logs_exports = [])
      ?d_b_cluster_parameter_group_name
      ?deletion_protection
      ?copy_tags_to_snapshot
      ?domain
      ?domain_i_a_m_role_name
      () =
    { d_b_cluster_identifier
    ; restore_type
    ; source_d_b_cluster_identifier
    ; restore_to_time
    ; use_latest_restorable_time
    ; port
    ; d_b_subnet_group_name
    ; option_group_name
    ; vpc_security_group_ids
    ; tags
    ; kms_key_id
    ; enable_i_a_m_database_authentication
    ; backtrack_window
    ; enable_cloudwatch_logs_exports
    ; d_b_cluster_parameter_group_name
    ; deletion_protection
    ; copy_tags_to_snapshot
    ; domain
    ; domain_i_a_m_role_name
    }

  let parse xml =
    Some
      { d_b_cluster_identifier =
          Aws.Xml.required
            "DBClusterIdentifier"
            (Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse)
      ; restore_type =
          Aws.Util.option_bind (Aws.Xml.member "RestoreType" xml) String.parse
      ; source_d_b_cluster_identifier =
          Aws.Xml.required
            "SourceDBClusterIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "SourceDBClusterIdentifier" xml)
               String.parse)
      ; restore_to_time =
          Aws.Util.option_bind (Aws.Xml.member "RestoreToTime" xml) DateTime.parse
      ; use_latest_restorable_time =
          Aws.Util.option_bind
            (Aws.Xml.member "UseLatestRestorableTime" xml)
            Boolean.parse
      ; port = Aws.Util.option_bind (Aws.Xml.member "Port" xml) Integer.parse
      ; d_b_subnet_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBSubnetGroupName" xml) String.parse
      ; option_group_name =
          Aws.Util.option_bind (Aws.Xml.member "OptionGroupName" xml) String.parse
      ; vpc_security_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "VpcSecurityGroupIds" xml)
               VpcSecurityGroupIdList.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "KmsKeyId" xml) String.parse
      ; enable_i_a_m_database_authentication =
          Aws.Util.option_bind
            (Aws.Xml.member "EnableIAMDatabaseAuthentication" xml)
            Boolean.parse
      ; backtrack_window =
          Aws.Util.option_bind (Aws.Xml.member "BacktrackWindow" xml) Long.parse
      ; enable_cloudwatch_logs_exports =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "EnableCloudwatchLogsExports" xml)
               LogTypeList.parse)
      ; d_b_cluster_parameter_group_name =
          Aws.Util.option_bind
            (Aws.Xml.member "DBClusterParameterGroupName" xml)
            String.parse
      ; deletion_protection =
          Aws.Util.option_bind (Aws.Xml.member "DeletionProtection" xml) Boolean.parse
      ; copy_tags_to_snapshot =
          Aws.Util.option_bind (Aws.Xml.member "CopyTagsToSnapshot" xml) Boolean.parse
      ; domain = Aws.Util.option_bind (Aws.Xml.member "Domain" xml) String.parse
      ; domain_i_a_m_role_name =
          Aws.Util.option_bind (Aws.Xml.member "DomainIAMRoleName" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.domain_i_a_m_role_name (fun f ->
               Aws.Query.Pair ("DomainIAMRoleName", String.to_query f))
         ; Aws.Util.option_map v.domain (fun f ->
               Aws.Query.Pair ("Domain", String.to_query f))
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               Aws.Query.Pair ("CopyTagsToSnapshot", Boolean.to_query f))
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               Aws.Query.Pair ("DeletionProtection", Boolean.to_query f))
         ; Aws.Util.option_map v.d_b_cluster_parameter_group_name (fun f ->
               Aws.Query.Pair ("DBClusterParameterGroupName", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "EnableCloudwatchLogsExports.member"
                , LogTypeList.to_query v.enable_cloudwatch_logs_exports ))
         ; Aws.Util.option_map v.backtrack_window (fun f ->
               Aws.Query.Pair ("BacktrackWindow", Long.to_query f))
         ; Aws.Util.option_map v.enable_i_a_m_database_authentication (fun f ->
               Aws.Query.Pair ("EnableIAMDatabaseAuthentication", Boolean.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Some
             (Aws.Query.Pair
                ( "VpcSecurityGroupIds.member"
                , VpcSecurityGroupIdList.to_query v.vpc_security_group_ids ))
         ; Aws.Util.option_map v.option_group_name (fun f ->
               Aws.Query.Pair ("OptionGroupName", String.to_query f))
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               Aws.Query.Pair ("DBSubnetGroupName", String.to_query f))
         ; Aws.Util.option_map v.port (fun f ->
               Aws.Query.Pair ("Port", Integer.to_query f))
         ; Aws.Util.option_map v.use_latest_restorable_time (fun f ->
               Aws.Query.Pair ("UseLatestRestorableTime", Boolean.to_query f))
         ; Aws.Util.option_map v.restore_to_time (fun f ->
               Aws.Query.Pair ("RestoreToTime", DateTime.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "SourceDBClusterIdentifier"
                , String.to_query v.source_d_b_cluster_identifier ))
         ; Aws.Util.option_map v.restore_type (fun f ->
               Aws.Query.Pair ("RestoreType", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DBClusterIdentifier", String.to_query v.d_b_cluster_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.domain_i_a_m_role_name (fun f ->
               "DomainIAMRoleName", String.to_json f)
         ; Aws.Util.option_map v.domain (fun f -> "Domain", String.to_json f)
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               "CopyTagsToSnapshot", Boolean.to_json f)
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               "DeletionProtection", Boolean.to_json f)
         ; Aws.Util.option_map v.d_b_cluster_parameter_group_name (fun f ->
               "DBClusterParameterGroupName", String.to_json f)
         ; Some
             ( "EnableCloudwatchLogsExports"
             , LogTypeList.to_json v.enable_cloudwatch_logs_exports )
         ; Aws.Util.option_map v.backtrack_window (fun f ->
               "BacktrackWindow", Long.to_json f)
         ; Aws.Util.option_map v.enable_i_a_m_database_authentication (fun f ->
               "EnableIAMDatabaseAuthentication", Boolean.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "KmsKeyId", String.to_json f)
         ; Some ("Tags", TagList.to_json v.tags)
         ; Some
             ( "VpcSecurityGroupIds"
             , VpcSecurityGroupIdList.to_json v.vpc_security_group_ids )
         ; Aws.Util.option_map v.option_group_name (fun f ->
               "OptionGroupName", String.to_json f)
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               "DBSubnetGroupName", String.to_json f)
         ; Aws.Util.option_map v.port (fun f -> "Port", Integer.to_json f)
         ; Aws.Util.option_map v.use_latest_restorable_time (fun f ->
               "UseLatestRestorableTime", Boolean.to_json f)
         ; Aws.Util.option_map v.restore_to_time (fun f ->
               "RestoreToTime", DateTime.to_json f)
         ; Some
             ("SourceDBClusterIdentifier", String.to_json v.source_d_b_cluster_identifier)
         ; Aws.Util.option_map v.restore_type (fun f -> "RestoreType", String.to_json f)
         ; Some ("DBClusterIdentifier", String.to_json v.d_b_cluster_identifier)
         ])

  let of_json j =
    { d_b_cluster_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterIdentifier"))
    ; restore_type = Aws.Util.option_map (Aws.Json.lookup j "RestoreType") String.of_json
    ; source_d_b_cluster_identifier =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceDBClusterIdentifier"))
    ; restore_to_time =
        Aws.Util.option_map (Aws.Json.lookup j "RestoreToTime") DateTime.of_json
    ; use_latest_restorable_time =
        Aws.Util.option_map (Aws.Json.lookup j "UseLatestRestorableTime") Boolean.of_json
    ; port = Aws.Util.option_map (Aws.Json.lookup j "Port") Integer.of_json
    ; d_b_subnet_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBSubnetGroupName") String.of_json
    ; option_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "OptionGroupName") String.of_json
    ; vpc_security_group_ids =
        VpcSecurityGroupIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcSecurityGroupIds"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "KmsKeyId") String.of_json
    ; enable_i_a_m_database_authentication =
        Aws.Util.option_map
          (Aws.Json.lookup j "EnableIAMDatabaseAuthentication")
          Boolean.of_json
    ; backtrack_window =
        Aws.Util.option_map (Aws.Json.lookup j "BacktrackWindow") Long.of_json
    ; enable_cloudwatch_logs_exports =
        LogTypeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "EnableCloudwatchLogsExports"))
    ; d_b_cluster_parameter_group_name =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBClusterParameterGroupName")
          String.of_json
    ; deletion_protection =
        Aws.Util.option_map (Aws.Json.lookup j "DeletionProtection") Boolean.of_json
    ; copy_tags_to_snapshot =
        Aws.Util.option_map (Aws.Json.lookup j "CopyTagsToSnapshot") Boolean.of_json
    ; domain = Aws.Util.option_map (Aws.Json.lookup j "Domain") String.of_json
    ; domain_i_a_m_role_name =
        Aws.Util.option_map (Aws.Json.lookup j "DomainIAMRoleName") String.of_json
    }
end

module DBUpgradeDependencyFailureFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DownloadDBLogFilePortionDetails = struct
  type t =
    { log_file_data : String.t option
    ; marker : String.t option
    ; additional_data_pending : Boolean.t option
    }

  let make ?log_file_data ?marker ?additional_data_pending () =
    { log_file_data; marker; additional_data_pending }

  let parse xml =
    Some
      { log_file_data =
          Aws.Util.option_bind (Aws.Xml.member "LogFileData" xml) String.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; additional_data_pending =
          Aws.Util.option_bind (Aws.Xml.member "AdditionalDataPending" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.additional_data_pending (fun f ->
               Aws.Query.Pair ("AdditionalDataPending", Boolean.to_query f))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.log_file_data (fun f ->
               Aws.Query.Pair ("LogFileData", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.additional_data_pending (fun f ->
               "AdditionalDataPending", Boolean.to_json f)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.log_file_data (fun f -> "LogFileData", String.to_json f)
         ])

  let of_json j =
    { log_file_data = Aws.Util.option_map (Aws.Json.lookup j "LogFileData") String.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; additional_data_pending =
        Aws.Util.option_map (Aws.Json.lookup j "AdditionalDataPending") Boolean.of_json
    }
end

module InvalidDBInstanceAutomatedBackupStateFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DBEngineVersionList = struct
  type t = DBEngineVersion.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map DBEngineVersion.parse (Aws.Xml.members "DBEngineVersion" xml))

  let to_query v = Aws.Query.to_query_list DBEngineVersion.to_query v

  let to_json v = `List (List.map DBEngineVersion.to_json v)

  let of_json j = Aws.Json.to_list DBEngineVersion.of_json j
end

module DBEngineVersionMessage = struct
  type t =
    { marker : String.t option
    ; d_b_engine_versions : DBEngineVersionList.t
    }

  let make ?marker ?(d_b_engine_versions = []) () = { marker; d_b_engine_versions }

  let parse xml =
    Some
      { marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; d_b_engine_versions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DBEngineVersions" xml)
               DBEngineVersionList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "DBEngineVersions.member"
                , DBEngineVersionList.to_query v.d_b_engine_versions ))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("DBEngineVersions", DBEngineVersionList.to_json v.d_b_engine_versions)
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ])

  let of_json j =
    { marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; d_b_engine_versions =
        DBEngineVersionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBEngineVersions"))
    }
end

module DeleteDBInstanceAutomatedBackupResult = struct
  type t = { d_b_instance_automated_backup : DBInstanceAutomatedBackup.t option }

  let make ?d_b_instance_automated_backup () = { d_b_instance_automated_backup }

  let parse xml =
    Some
      { d_b_instance_automated_backup =
          Aws.Util.option_bind
            (Aws.Xml.member "DBInstanceAutomatedBackup" xml)
            DBInstanceAutomatedBackup.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_instance_automated_backup (fun f ->
               Aws.Query.Pair
                 ("DBInstanceAutomatedBackup", DBInstanceAutomatedBackup.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_instance_automated_backup (fun f ->
               "DBInstanceAutomatedBackup", DBInstanceAutomatedBackup.to_json f)
         ])

  let of_json j =
    { d_b_instance_automated_backup =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBInstanceAutomatedBackup")
          DBInstanceAutomatedBackup.of_json
    }
end

module DBClusterEndpointQuotaExceededFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module AuthorizeDBSecurityGroupIngressMessage = struct
  type t =
    { d_b_security_group_name : String.t
    ; c_i_d_r_i_p : String.t option
    ; e_c2_security_group_name : String.t option
    ; e_c2_security_group_id : String.t option
    ; e_c2_security_group_owner_id : String.t option
    }

  let make
      ~d_b_security_group_name
      ?c_i_d_r_i_p
      ?e_c2_security_group_name
      ?e_c2_security_group_id
      ?e_c2_security_group_owner_id
      () =
    { d_b_security_group_name
    ; c_i_d_r_i_p
    ; e_c2_security_group_name
    ; e_c2_security_group_id
    ; e_c2_security_group_owner_id
    }

  let parse xml =
    Some
      { d_b_security_group_name =
          Aws.Xml.required
            "DBSecurityGroupName"
            (Aws.Util.option_bind (Aws.Xml.member "DBSecurityGroupName" xml) String.parse)
      ; c_i_d_r_i_p = Aws.Util.option_bind (Aws.Xml.member "CIDRIP" xml) String.parse
      ; e_c2_security_group_name =
          Aws.Util.option_bind (Aws.Xml.member "EC2SecurityGroupName" xml) String.parse
      ; e_c2_security_group_id =
          Aws.Util.option_bind (Aws.Xml.member "EC2SecurityGroupId" xml) String.parse
      ; e_c2_security_group_owner_id =
          Aws.Util.option_bind (Aws.Xml.member "EC2SecurityGroupOwnerId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.e_c2_security_group_owner_id (fun f ->
               Aws.Query.Pair ("EC2SecurityGroupOwnerId", String.to_query f))
         ; Aws.Util.option_map v.e_c2_security_group_id (fun f ->
               Aws.Query.Pair ("EC2SecurityGroupId", String.to_query f))
         ; Aws.Util.option_map v.e_c2_security_group_name (fun f ->
               Aws.Query.Pair ("EC2SecurityGroupName", String.to_query f))
         ; Aws.Util.option_map v.c_i_d_r_i_p (fun f ->
               Aws.Query.Pair ("CIDRIP", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DBSecurityGroupName", String.to_query v.d_b_security_group_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.e_c2_security_group_owner_id (fun f ->
               "EC2SecurityGroupOwnerId", String.to_json f)
         ; Aws.Util.option_map v.e_c2_security_group_id (fun f ->
               "EC2SecurityGroupId", String.to_json f)
         ; Aws.Util.option_map v.e_c2_security_group_name (fun f ->
               "EC2SecurityGroupName", String.to_json f)
         ; Aws.Util.option_map v.c_i_d_r_i_p (fun f -> "CIDRIP", String.to_json f)
         ; Some ("DBSecurityGroupName", String.to_json v.d_b_security_group_name)
         ])

  let of_json j =
    { d_b_security_group_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBSecurityGroupName"))
    ; c_i_d_r_i_p = Aws.Util.option_map (Aws.Json.lookup j "CIDRIP") String.of_json
    ; e_c2_security_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "EC2SecurityGroupName") String.of_json
    ; e_c2_security_group_id =
        Aws.Util.option_map (Aws.Json.lookup j "EC2SecurityGroupId") String.of_json
    ; e_c2_security_group_owner_id =
        Aws.Util.option_map (Aws.Json.lookup j "EC2SecurityGroupOwnerId") String.of_json
    }
end

module RegisterDBProxyTargetsResponse = struct
  type t = { d_b_proxy_targets : TargetList.t }

  let make ?(d_b_proxy_targets = []) () = { d_b_proxy_targets }

  let parse xml =
    Some
      { d_b_proxy_targets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "DBProxyTargets" xml) TargetList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("DBProxyTargets.member", TargetList.to_query v.d_b_proxy_targets))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("DBProxyTargets", TargetList.to_json v.d_b_proxy_targets) ])

  let of_json j =
    { d_b_proxy_targets =
        TargetList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBProxyTargets"))
    }
end

module RestoreDBClusterFromS3Result = struct
  type t = { d_b_cluster : DBCluster.t option }

  let make ?d_b_cluster () = { d_b_cluster }

  let parse xml =
    Some
      { d_b_cluster =
          Aws.Util.option_bind (Aws.Xml.member "DBCluster" xml) DBCluster.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster (fun f ->
               Aws.Query.Pair ("DBCluster", DBCluster.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster (fun f -> "DBCluster", DBCluster.to_json f) ])

  let of_json j =
    { d_b_cluster = Aws.Util.option_map (Aws.Json.lookup j "DBCluster") DBCluster.of_json
    }
end

module DescribeDBProxyTargetGroupsResponse = struct
  type t =
    { target_groups : TargetGroupList.t
    ; marker : String.t option
    }

  let make ?(target_groups = []) ?marker () = { target_groups; marker }

  let parse xml =
    Some
      { target_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TargetGroups" xml)
               TargetGroupList.parse)
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TargetGroups.member", TargetGroupList.to_query v.target_groups))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Some ("TargetGroups", TargetGroupList.to_json v.target_groups)
         ])

  let of_json j =
    { target_groups =
        TargetGroupList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TargetGroups"))
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module CustomAvailabilityZoneNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module ModifyDBSnapshotMessage = struct
  type t =
    { d_b_snapshot_identifier : String.t
    ; engine_version : String.t option
    ; option_group_name : String.t option
    }

  let make ~d_b_snapshot_identifier ?engine_version ?option_group_name () =
    { d_b_snapshot_identifier; engine_version; option_group_name }

  let parse xml =
    Some
      { d_b_snapshot_identifier =
          Aws.Xml.required
            "DBSnapshotIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBSnapshotIdentifier" xml)
               String.parse)
      ; engine_version =
          Aws.Util.option_bind (Aws.Xml.member "EngineVersion" xml) String.parse
      ; option_group_name =
          Aws.Util.option_bind (Aws.Xml.member "OptionGroupName" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.option_group_name (fun f ->
               Aws.Query.Pair ("OptionGroupName", String.to_query f))
         ; Aws.Util.option_map v.engine_version (fun f ->
               Aws.Query.Pair ("EngineVersion", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DBSnapshotIdentifier", String.to_query v.d_b_snapshot_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.option_group_name (fun f ->
               "OptionGroupName", String.to_json f)
         ; Aws.Util.option_map v.engine_version (fun f ->
               "EngineVersion", String.to_json f)
         ; Some ("DBSnapshotIdentifier", String.to_json v.d_b_snapshot_identifier)
         ])

  let of_json j =
    { d_b_snapshot_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBSnapshotIdentifier"))
    ; engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "EngineVersion") String.of_json
    ; option_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "OptionGroupName") String.of_json
    }
end

module PendingMaintenanceActionsMessage = struct
  type t =
    { pending_maintenance_actions : PendingMaintenanceActions.t
    ; marker : String.t option
    }

  let make ?(pending_maintenance_actions = []) ?marker () =
    { pending_maintenance_actions; marker }

  let parse xml =
    Some
      { pending_maintenance_actions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "PendingMaintenanceActions" xml)
               PendingMaintenanceActions.parse)
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "PendingMaintenanceActions.member"
                , PendingMaintenanceActions.to_query v.pending_maintenance_actions ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Some
             ( "PendingMaintenanceActions"
             , PendingMaintenanceActions.to_json v.pending_maintenance_actions )
         ])

  let of_json j =
    { pending_maintenance_actions =
        PendingMaintenanceActions.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "PendingMaintenanceActions"))
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module DescribeDBClusterSnapshotAttributesResult = struct
  type t =
    { d_b_cluster_snapshot_attributes_result : DBClusterSnapshotAttributesResult.t option
    }

  let make ?d_b_cluster_snapshot_attributes_result () =
    { d_b_cluster_snapshot_attributes_result }

  let parse xml =
    Some
      { d_b_cluster_snapshot_attributes_result =
          Aws.Util.option_bind
            (Aws.Xml.member "DBClusterSnapshotAttributesResult" xml)
            DBClusterSnapshotAttributesResult.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster_snapshot_attributes_result (fun f ->
               Aws.Query.Pair
                 ( "DBClusterSnapshotAttributesResult"
                 , DBClusterSnapshotAttributesResult.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster_snapshot_attributes_result (fun f ->
               ( "DBClusterSnapshotAttributesResult"
               , DBClusterSnapshotAttributesResult.to_json f ))
         ])

  let of_json j =
    { d_b_cluster_snapshot_attributes_result =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBClusterSnapshotAttributesResult")
          DBClusterSnapshotAttributesResult.of_json
    }
end

module DeleteDBProxyResponse = struct
  type t = { d_b_proxy : DBProxy.t option }

  let make ?d_b_proxy () = { d_b_proxy }

  let parse xml =
    Some { d_b_proxy = Aws.Util.option_bind (Aws.Xml.member "DBProxy" xml) DBProxy.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_proxy (fun f ->
               Aws.Query.Pair ("DBProxy", DBProxy.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_proxy (fun f -> "DBProxy", DBProxy.to_json f) ])

  let of_json j =
    { d_b_proxy = Aws.Util.option_map (Aws.Json.lookup j "DBProxy") DBProxy.of_json }
end

module InvalidVPCNetworkStateFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module CreateOptionGroupMessage = struct
  type t =
    { option_group_name : String.t
    ; engine_name : String.t
    ; major_engine_version : String.t
    ; option_group_description : String.t
    ; tags : TagList.t
    }

  let make
      ~option_group_name
      ~engine_name
      ~major_engine_version
      ~option_group_description
      ?(tags = [])
      () =
    { option_group_name
    ; engine_name
    ; major_engine_version
    ; option_group_description
    ; tags
    }

  let parse xml =
    Some
      { option_group_name =
          Aws.Xml.required
            "OptionGroupName"
            (Aws.Util.option_bind (Aws.Xml.member "OptionGroupName" xml) String.parse)
      ; engine_name =
          Aws.Xml.required
            "EngineName"
            (Aws.Util.option_bind (Aws.Xml.member "EngineName" xml) String.parse)
      ; major_engine_version =
          Aws.Xml.required
            "MajorEngineVersion"
            (Aws.Util.option_bind (Aws.Xml.member "MajorEngineVersion" xml) String.parse)
      ; option_group_description =
          Aws.Xml.required
            "OptionGroupDescription"
            (Aws.Util.option_bind
               (Aws.Xml.member "OptionGroupDescription" xml)
               String.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Some
             (Aws.Query.Pair
                ("OptionGroupDescription", String.to_query v.option_group_description))
         ; Some
             (Aws.Query.Pair ("MajorEngineVersion", String.to_query v.major_engine_version))
         ; Some (Aws.Query.Pair ("EngineName", String.to_query v.engine_name))
         ; Some (Aws.Query.Pair ("OptionGroupName", String.to_query v.option_group_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tags", TagList.to_json v.tags)
         ; Some ("OptionGroupDescription", String.to_json v.option_group_description)
         ; Some ("MajorEngineVersion", String.to_json v.major_engine_version)
         ; Some ("EngineName", String.to_json v.engine_name)
         ; Some ("OptionGroupName", String.to_json v.option_group_name)
         ])

  let of_json j =
    { option_group_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "OptionGroupName"))
    ; engine_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "EngineName"))
    ; major_engine_version =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "MajorEngineVersion"))
    ; option_group_description =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "OptionGroupDescription"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    }
end

module CreateDBClusterSnapshotResult = struct
  type t = { d_b_cluster_snapshot : DBClusterSnapshot.t option }

  let make ?d_b_cluster_snapshot () = { d_b_cluster_snapshot }

  let parse xml =
    Some
      { d_b_cluster_snapshot =
          Aws.Util.option_bind
            (Aws.Xml.member "DBClusterSnapshot" xml)
            DBClusterSnapshot.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster_snapshot (fun f ->
               Aws.Query.Pair ("DBClusterSnapshot", DBClusterSnapshot.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster_snapshot (fun f ->
               "DBClusterSnapshot", DBClusterSnapshot.to_json f)
         ])

  let of_json j =
    { d_b_cluster_snapshot =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBClusterSnapshot")
          DBClusterSnapshot.of_json
    }
end

module SNSNoAuthorizationFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module InsufficientAvailableIPsInSubnetFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module StopDBClusterMessage = struct
  type t = { d_b_cluster_identifier : String.t }

  let make ~d_b_cluster_identifier () = { d_b_cluster_identifier }

  let parse xml =
    Some
      { d_b_cluster_identifier =
          Aws.Xml.required
            "DBClusterIdentifier"
            (Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("DBClusterIdentifier", String.to_query v.d_b_cluster_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("DBClusterIdentifier", String.to_json v.d_b_cluster_identifier) ])

  let of_json j =
    { d_b_cluster_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterIdentifier"))
    }
end

module ApplyPendingMaintenanceActionResult = struct
  type t =
    { resource_pending_maintenance_actions : ResourcePendingMaintenanceActions.t option }

  let make ?resource_pending_maintenance_actions () =
    { resource_pending_maintenance_actions }

  let parse xml =
    Some
      { resource_pending_maintenance_actions =
          Aws.Util.option_bind
            (Aws.Xml.member "ResourcePendingMaintenanceActions" xml)
            ResourcePendingMaintenanceActions.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.resource_pending_maintenance_actions (fun f ->
               Aws.Query.Pair
                 ( "ResourcePendingMaintenanceActions"
                 , ResourcePendingMaintenanceActions.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.resource_pending_maintenance_actions (fun f ->
               ( "ResourcePendingMaintenanceActions"
               , ResourcePendingMaintenanceActions.to_json f ))
         ])

  let of_json j =
    { resource_pending_maintenance_actions =
        Aws.Util.option_map
          (Aws.Json.lookup j "ResourcePendingMaintenanceActions")
          ResourcePendingMaintenanceActions.of_json
    }
end

module ModifyCertificatesMessage = struct
  type t =
    { certificate_identifier : String.t option
    ; remove_customer_override : Boolean.t option
    }

  let make ?certificate_identifier ?remove_customer_override () =
    { certificate_identifier; remove_customer_override }

  let parse xml =
    Some
      { certificate_identifier =
          Aws.Util.option_bind (Aws.Xml.member "CertificateIdentifier" xml) String.parse
      ; remove_customer_override =
          Aws.Util.option_bind (Aws.Xml.member "RemoveCustomerOverride" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.remove_customer_override (fun f ->
               Aws.Query.Pair ("RemoveCustomerOverride", Boolean.to_query f))
         ; Aws.Util.option_map v.certificate_identifier (fun f ->
               Aws.Query.Pair ("CertificateIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.remove_customer_override (fun f ->
               "RemoveCustomerOverride", Boolean.to_json f)
         ; Aws.Util.option_map v.certificate_identifier (fun f ->
               "CertificateIdentifier", String.to_json f)
         ])

  let of_json j =
    { certificate_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "CertificateIdentifier") String.of_json
    ; remove_customer_override =
        Aws.Util.option_map (Aws.Json.lookup j "RemoveCustomerOverride") Boolean.of_json
    }
end

module DeleteGlobalClusterResult = struct
  type t = { global_cluster : GlobalCluster.t option }

  let make ?global_cluster () = { global_cluster }

  let parse xml =
    Some
      { global_cluster =
          Aws.Util.option_bind (Aws.Xml.member "GlobalCluster" xml) GlobalCluster.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.global_cluster (fun f ->
               Aws.Query.Pair ("GlobalCluster", GlobalCluster.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.global_cluster (fun f ->
               "GlobalCluster", GlobalCluster.to_json f)
         ])

  let of_json j =
    { global_cluster =
        Aws.Util.option_map (Aws.Json.lookup j "GlobalCluster") GlobalCluster.of_json
    }
end

module CustomAvailabilityZoneQuotaExceededFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DBParameterGroupDetails = struct
  type t =
    { parameters : ParametersList.t
    ; marker : String.t option
    }

  let make ?(parameters = []) ?marker () = { parameters; marker }

  let parse xml =
    Some
      { parameters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Parameters" xml) ParametersList.parse)
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Some
             (Aws.Query.Pair ("Parameters.member", ParametersList.to_query v.parameters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Some ("Parameters", ParametersList.to_json v.parameters)
         ])

  let of_json j =
    { parameters =
        ParametersList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Parameters"))
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module ReservedDBInstanceMessage = struct
  type t =
    { marker : String.t option
    ; reserved_d_b_instances : ReservedDBInstanceList.t
    }

  let make ?marker ?(reserved_d_b_instances = []) () = { marker; reserved_d_b_instances }

  let parse xml =
    Some
      { marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; reserved_d_b_instances =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ReservedDBInstances" xml)
               ReservedDBInstanceList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "ReservedDBInstances.member"
                , ReservedDBInstanceList.to_query v.reserved_d_b_instances ))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "ReservedDBInstances"
             , ReservedDBInstanceList.to_json v.reserved_d_b_instances )
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ])

  let of_json j =
    { marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; reserved_d_b_instances =
        ReservedDBInstanceList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ReservedDBInstances"))
    }
end

module RemoveRoleFromDBInstanceMessage = struct
  type t =
    { d_b_instance_identifier : String.t
    ; role_arn : String.t
    ; feature_name : String.t
    }

  let make ~d_b_instance_identifier ~role_arn ~feature_name () =
    { d_b_instance_identifier; role_arn; feature_name }

  let parse xml =
    Some
      { d_b_instance_identifier =
          Aws.Xml.required
            "DBInstanceIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBInstanceIdentifier" xml)
               String.parse)
      ; role_arn =
          Aws.Xml.required
            "RoleArn"
            (Aws.Util.option_bind (Aws.Xml.member "RoleArn" xml) String.parse)
      ; feature_name =
          Aws.Xml.required
            "FeatureName"
            (Aws.Util.option_bind (Aws.Xml.member "FeatureName" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("FeatureName", String.to_query v.feature_name))
         ; Some (Aws.Query.Pair ("RoleArn", String.to_query v.role_arn))
         ; Some
             (Aws.Query.Pair
                ("DBInstanceIdentifier", String.to_query v.d_b_instance_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("FeatureName", String.to_json v.feature_name)
         ; Some ("RoleArn", String.to_json v.role_arn)
         ; Some ("DBInstanceIdentifier", String.to_json v.d_b_instance_identifier)
         ])

  let of_json j =
    { d_b_instance_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBInstanceIdentifier"))
    ; role_arn = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "RoleArn"))
    ; feature_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "FeatureName"))
    }
end

module StorageTypeNotSupportedFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DBSubnetQuotaExceededFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DBClusterSnapshotNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module ImportInstallationMediaMessage = struct
  type t =
    { custom_availability_zone_id : String.t
    ; engine : String.t
    ; engine_version : String.t
    ; engine_installation_media_path : String.t
    ; o_s_installation_media_path : String.t
    }

  let make
      ~custom_availability_zone_id
      ~engine
      ~engine_version
      ~engine_installation_media_path
      ~o_s_installation_media_path
      () =
    { custom_availability_zone_id
    ; engine
    ; engine_version
    ; engine_installation_media_path
    ; o_s_installation_media_path
    }

  let parse xml =
    Some
      { custom_availability_zone_id =
          Aws.Xml.required
            "CustomAvailabilityZoneId"
            (Aws.Util.option_bind
               (Aws.Xml.member "CustomAvailabilityZoneId" xml)
               String.parse)
      ; engine =
          Aws.Xml.required
            "Engine"
            (Aws.Util.option_bind (Aws.Xml.member "Engine" xml) String.parse)
      ; engine_version =
          Aws.Xml.required
            "EngineVersion"
            (Aws.Util.option_bind (Aws.Xml.member "EngineVersion" xml) String.parse)
      ; engine_installation_media_path =
          Aws.Xml.required
            "EngineInstallationMediaPath"
            (Aws.Util.option_bind
               (Aws.Xml.member "EngineInstallationMediaPath" xml)
               String.parse)
      ; o_s_installation_media_path =
          Aws.Xml.required
            "OSInstallationMediaPath"
            (Aws.Util.option_bind
               (Aws.Xml.member "OSInstallationMediaPath" xml)
               String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("OSInstallationMediaPath", String.to_query v.o_s_installation_media_path))
         ; Some
             (Aws.Query.Pair
                ( "EngineInstallationMediaPath"
                , String.to_query v.engine_installation_media_path ))
         ; Some (Aws.Query.Pair ("EngineVersion", String.to_query v.engine_version))
         ; Some (Aws.Query.Pair ("Engine", String.to_query v.engine))
         ; Some
             (Aws.Query.Pair
                ("CustomAvailabilityZoneId", String.to_query v.custom_availability_zone_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("OSInstallationMediaPath", String.to_json v.o_s_installation_media_path)
         ; Some
             ( "EngineInstallationMediaPath"
             , String.to_json v.engine_installation_media_path )
         ; Some ("EngineVersion", String.to_json v.engine_version)
         ; Some ("Engine", String.to_json v.engine)
         ; Some ("CustomAvailabilityZoneId", String.to_json v.custom_availability_zone_id)
         ])

  let of_json j =
    { custom_availability_zone_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "CustomAvailabilityZoneId"))
    ; engine = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Engine"))
    ; engine_version =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "EngineVersion"))
    ; engine_installation_media_path =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "EngineInstallationMediaPath"))
    ; o_s_installation_media_path =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "OSInstallationMediaPath"))
    }
end

module DescribeEngineDefaultClusterParametersMessage = struct
  type t =
    { d_b_parameter_group_family : String.t
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    }

  let make ~d_b_parameter_group_family ?(filters = []) ?max_records ?marker () =
    { d_b_parameter_group_family; filters; max_records; marker }

  let parse xml =
    Some
      { d_b_parameter_group_family =
          Aws.Xml.required
            "DBParameterGroupFamily"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBParameterGroupFamily" xml)
               String.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ("DBParameterGroupFamily", String.to_query v.d_b_parameter_group_family))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Some ("DBParameterGroupFamily", String.to_json v.d_b_parameter_group_family)
         ])

  let of_json j =
    { d_b_parameter_group_family =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBParameterGroupFamily"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module PointInTimeRestoreNotEnabledFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module InvalidDBSecurityGroupStateFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DescribeEngineDefaultParametersResult = struct
  type t = { engine_defaults : EngineDefaults.t }

  let make ~engine_defaults () = { engine_defaults }

  let parse xml =
    Some
      { engine_defaults =
          Aws.Xml.required
            "EngineDefaults"
            (Aws.Util.option_bind
               (Aws.Xml.member "EngineDefaults" xml)
               EngineDefaults.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("EngineDefaults", EngineDefaults.to_query v.engine_defaults))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("EngineDefaults", EngineDefaults.to_json v.engine_defaults) ])

  let of_json j =
    { engine_defaults =
        EngineDefaults.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "EngineDefaults"))
    }
end

module InvalidExportTaskStateFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DomainNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DeleteDBClusterMessage = struct
  type t =
    { d_b_cluster_identifier : String.t
    ; skip_final_snapshot : Boolean.t option
    ; final_d_b_snapshot_identifier : String.t option
    }

  let make ~d_b_cluster_identifier ?skip_final_snapshot ?final_d_b_snapshot_identifier ()
      =
    { d_b_cluster_identifier; skip_final_snapshot; final_d_b_snapshot_identifier }

  let parse xml =
    Some
      { d_b_cluster_identifier =
          Aws.Xml.required
            "DBClusterIdentifier"
            (Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse)
      ; skip_final_snapshot =
          Aws.Util.option_bind (Aws.Xml.member "SkipFinalSnapshot" xml) Boolean.parse
      ; final_d_b_snapshot_identifier =
          Aws.Util.option_bind
            (Aws.Xml.member "FinalDBSnapshotIdentifier" xml)
            String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.final_d_b_snapshot_identifier (fun f ->
               Aws.Query.Pair ("FinalDBSnapshotIdentifier", String.to_query f))
         ; Aws.Util.option_map v.skip_final_snapshot (fun f ->
               Aws.Query.Pair ("SkipFinalSnapshot", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DBClusterIdentifier", String.to_query v.d_b_cluster_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.final_d_b_snapshot_identifier (fun f ->
               "FinalDBSnapshotIdentifier", String.to_json f)
         ; Aws.Util.option_map v.skip_final_snapshot (fun f ->
               "SkipFinalSnapshot", Boolean.to_json f)
         ; Some ("DBClusterIdentifier", String.to_json v.d_b_cluster_identifier)
         ])

  let of_json j =
    { d_b_cluster_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterIdentifier"))
    ; skip_final_snapshot =
        Aws.Util.option_map (Aws.Json.lookup j "SkipFinalSnapshot") Boolean.of_json
    ; final_d_b_snapshot_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "FinalDBSnapshotIdentifier") String.of_json
    }
end

module DBSubnetGroupDoesNotCoverEnoughAZs = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module RestoreDBClusterFromS3Message = struct
  type t =
    { availability_zones : AvailabilityZones.t
    ; backup_retention_period : Integer.t option
    ; character_set_name : String.t option
    ; database_name : String.t option
    ; d_b_cluster_identifier : String.t
    ; d_b_cluster_parameter_group_name : String.t option
    ; vpc_security_group_ids : VpcSecurityGroupIdList.t
    ; d_b_subnet_group_name : String.t option
    ; engine : String.t
    ; engine_version : String.t option
    ; port : Integer.t option
    ; master_username : String.t
    ; master_user_password : String.t
    ; option_group_name : String.t option
    ; preferred_backup_window : String.t option
    ; preferred_maintenance_window : String.t option
    ; tags : TagList.t
    ; storage_encrypted : Boolean.t option
    ; kms_key_id : String.t option
    ; enable_i_a_m_database_authentication : Boolean.t option
    ; source_engine : String.t
    ; source_engine_version : String.t
    ; s3_bucket_name : String.t
    ; s3_prefix : String.t option
    ; s3_ingestion_role_arn : String.t
    ; backtrack_window : Long.t option
    ; enable_cloudwatch_logs_exports : LogTypeList.t
    ; deletion_protection : Boolean.t option
    ; copy_tags_to_snapshot : Boolean.t option
    ; domain : String.t option
    ; domain_i_a_m_role_name : String.t option
    }

  let make
      ?(availability_zones = [])
      ?backup_retention_period
      ?character_set_name
      ?database_name
      ~d_b_cluster_identifier
      ?d_b_cluster_parameter_group_name
      ?(vpc_security_group_ids = [])
      ?d_b_subnet_group_name
      ~engine
      ?engine_version
      ?port
      ~master_username
      ~master_user_password
      ?option_group_name
      ?preferred_backup_window
      ?preferred_maintenance_window
      ?(tags = [])
      ?storage_encrypted
      ?kms_key_id
      ?enable_i_a_m_database_authentication
      ~source_engine
      ~source_engine_version
      ~s3_bucket_name
      ?s3_prefix
      ~s3_ingestion_role_arn
      ?backtrack_window
      ?(enable_cloudwatch_logs_exports = [])
      ?deletion_protection
      ?copy_tags_to_snapshot
      ?domain
      ?domain_i_a_m_role_name
      () =
    { availability_zones
    ; backup_retention_period
    ; character_set_name
    ; database_name
    ; d_b_cluster_identifier
    ; d_b_cluster_parameter_group_name
    ; vpc_security_group_ids
    ; d_b_subnet_group_name
    ; engine
    ; engine_version
    ; port
    ; master_username
    ; master_user_password
    ; option_group_name
    ; preferred_backup_window
    ; preferred_maintenance_window
    ; tags
    ; storage_encrypted
    ; kms_key_id
    ; enable_i_a_m_database_authentication
    ; source_engine
    ; source_engine_version
    ; s3_bucket_name
    ; s3_prefix
    ; s3_ingestion_role_arn
    ; backtrack_window
    ; enable_cloudwatch_logs_exports
    ; deletion_protection
    ; copy_tags_to_snapshot
    ; domain
    ; domain_i_a_m_role_name
    }

  let parse xml =
    Some
      { availability_zones =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AvailabilityZones" xml)
               AvailabilityZones.parse)
      ; backup_retention_period =
          Aws.Util.option_bind (Aws.Xml.member "BackupRetentionPeriod" xml) Integer.parse
      ; character_set_name =
          Aws.Util.option_bind (Aws.Xml.member "CharacterSetName" xml) String.parse
      ; database_name =
          Aws.Util.option_bind (Aws.Xml.member "DatabaseName" xml) String.parse
      ; d_b_cluster_identifier =
          Aws.Xml.required
            "DBClusterIdentifier"
            (Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse)
      ; d_b_cluster_parameter_group_name =
          Aws.Util.option_bind
            (Aws.Xml.member "DBClusterParameterGroupName" xml)
            String.parse
      ; vpc_security_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "VpcSecurityGroupIds" xml)
               VpcSecurityGroupIdList.parse)
      ; d_b_subnet_group_name =
          Aws.Util.option_bind (Aws.Xml.member "DBSubnetGroupName" xml) String.parse
      ; engine =
          Aws.Xml.required
            "Engine"
            (Aws.Util.option_bind (Aws.Xml.member "Engine" xml) String.parse)
      ; engine_version =
          Aws.Util.option_bind (Aws.Xml.member "EngineVersion" xml) String.parse
      ; port = Aws.Util.option_bind (Aws.Xml.member "Port" xml) Integer.parse
      ; master_username =
          Aws.Xml.required
            "MasterUsername"
            (Aws.Util.option_bind (Aws.Xml.member "MasterUsername" xml) String.parse)
      ; master_user_password =
          Aws.Xml.required
            "MasterUserPassword"
            (Aws.Util.option_bind (Aws.Xml.member "MasterUserPassword" xml) String.parse)
      ; option_group_name =
          Aws.Util.option_bind (Aws.Xml.member "OptionGroupName" xml) String.parse
      ; preferred_backup_window =
          Aws.Util.option_bind (Aws.Xml.member "PreferredBackupWindow" xml) String.parse
      ; preferred_maintenance_window =
          Aws.Util.option_bind
            (Aws.Xml.member "PreferredMaintenanceWindow" xml)
            String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      ; storage_encrypted =
          Aws.Util.option_bind (Aws.Xml.member "StorageEncrypted" xml) Boolean.parse
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "KmsKeyId" xml) String.parse
      ; enable_i_a_m_database_authentication =
          Aws.Util.option_bind
            (Aws.Xml.member "EnableIAMDatabaseAuthentication" xml)
            Boolean.parse
      ; source_engine =
          Aws.Xml.required
            "SourceEngine"
            (Aws.Util.option_bind (Aws.Xml.member "SourceEngine" xml) String.parse)
      ; source_engine_version =
          Aws.Xml.required
            "SourceEngineVersion"
            (Aws.Util.option_bind (Aws.Xml.member "SourceEngineVersion" xml) String.parse)
      ; s3_bucket_name =
          Aws.Xml.required
            "S3BucketName"
            (Aws.Util.option_bind (Aws.Xml.member "S3BucketName" xml) String.parse)
      ; s3_prefix = Aws.Util.option_bind (Aws.Xml.member "S3Prefix" xml) String.parse
      ; s3_ingestion_role_arn =
          Aws.Xml.required
            "S3IngestionRoleArn"
            (Aws.Util.option_bind (Aws.Xml.member "S3IngestionRoleArn" xml) String.parse)
      ; backtrack_window =
          Aws.Util.option_bind (Aws.Xml.member "BacktrackWindow" xml) Long.parse
      ; enable_cloudwatch_logs_exports =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "EnableCloudwatchLogsExports" xml)
               LogTypeList.parse)
      ; deletion_protection =
          Aws.Util.option_bind (Aws.Xml.member "DeletionProtection" xml) Boolean.parse
      ; copy_tags_to_snapshot =
          Aws.Util.option_bind (Aws.Xml.member "CopyTagsToSnapshot" xml) Boolean.parse
      ; domain = Aws.Util.option_bind (Aws.Xml.member "Domain" xml) String.parse
      ; domain_i_a_m_role_name =
          Aws.Util.option_bind (Aws.Xml.member "DomainIAMRoleName" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.domain_i_a_m_role_name (fun f ->
               Aws.Query.Pair ("DomainIAMRoleName", String.to_query f))
         ; Aws.Util.option_map v.domain (fun f ->
               Aws.Query.Pair ("Domain", String.to_query f))
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               Aws.Query.Pair ("CopyTagsToSnapshot", Boolean.to_query f))
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               Aws.Query.Pair ("DeletionProtection", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "EnableCloudwatchLogsExports.member"
                , LogTypeList.to_query v.enable_cloudwatch_logs_exports ))
         ; Aws.Util.option_map v.backtrack_window (fun f ->
               Aws.Query.Pair ("BacktrackWindow", Long.to_query f))
         ; Some
             (Aws.Query.Pair
                ("S3IngestionRoleArn", String.to_query v.s3_ingestion_role_arn))
         ; Aws.Util.option_map v.s3_prefix (fun f ->
               Aws.Query.Pair ("S3Prefix", String.to_query f))
         ; Some (Aws.Query.Pair ("S3BucketName", String.to_query v.s3_bucket_name))
         ; Some
             (Aws.Query.Pair
                ("SourceEngineVersion", String.to_query v.source_engine_version))
         ; Some (Aws.Query.Pair ("SourceEngine", String.to_query v.source_engine))
         ; Aws.Util.option_map v.enable_i_a_m_database_authentication (fun f ->
               Aws.Query.Pair ("EnableIAMDatabaseAuthentication", Boolean.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Aws.Util.option_map v.storage_encrypted (fun f ->
               Aws.Query.Pair ("StorageEncrypted", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Aws.Util.option_map v.preferred_maintenance_window (fun f ->
               Aws.Query.Pair ("PreferredMaintenanceWindow", String.to_query f))
         ; Aws.Util.option_map v.preferred_backup_window (fun f ->
               Aws.Query.Pair ("PreferredBackupWindow", String.to_query f))
         ; Aws.Util.option_map v.option_group_name (fun f ->
               Aws.Query.Pair ("OptionGroupName", String.to_query f))
         ; Some
             (Aws.Query.Pair ("MasterUserPassword", String.to_query v.master_user_password))
         ; Some (Aws.Query.Pair ("MasterUsername", String.to_query v.master_username))
         ; Aws.Util.option_map v.port (fun f ->
               Aws.Query.Pair ("Port", Integer.to_query f))
         ; Aws.Util.option_map v.engine_version (fun f ->
               Aws.Query.Pair ("EngineVersion", String.to_query f))
         ; Some (Aws.Query.Pair ("Engine", String.to_query v.engine))
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               Aws.Query.Pair ("DBSubnetGroupName", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "VpcSecurityGroupIds.member"
                , VpcSecurityGroupIdList.to_query v.vpc_security_group_ids ))
         ; Aws.Util.option_map v.d_b_cluster_parameter_group_name (fun f ->
               Aws.Query.Pair ("DBClusterParameterGroupName", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DBClusterIdentifier", String.to_query v.d_b_cluster_identifier))
         ; Aws.Util.option_map v.database_name (fun f ->
               Aws.Query.Pair ("DatabaseName", String.to_query f))
         ; Aws.Util.option_map v.character_set_name (fun f ->
               Aws.Query.Pair ("CharacterSetName", String.to_query f))
         ; Aws.Util.option_map v.backup_retention_period (fun f ->
               Aws.Query.Pair ("BackupRetentionPeriod", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "AvailabilityZones.member"
                , AvailabilityZones.to_query v.availability_zones ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.domain_i_a_m_role_name (fun f ->
               "DomainIAMRoleName", String.to_json f)
         ; Aws.Util.option_map v.domain (fun f -> "Domain", String.to_json f)
         ; Aws.Util.option_map v.copy_tags_to_snapshot (fun f ->
               "CopyTagsToSnapshot", Boolean.to_json f)
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               "DeletionProtection", Boolean.to_json f)
         ; Some
             ( "EnableCloudwatchLogsExports"
             , LogTypeList.to_json v.enable_cloudwatch_logs_exports )
         ; Aws.Util.option_map v.backtrack_window (fun f ->
               "BacktrackWindow", Long.to_json f)
         ; Some ("S3IngestionRoleArn", String.to_json v.s3_ingestion_role_arn)
         ; Aws.Util.option_map v.s3_prefix (fun f -> "S3Prefix", String.to_json f)
         ; Some ("S3BucketName", String.to_json v.s3_bucket_name)
         ; Some ("SourceEngineVersion", String.to_json v.source_engine_version)
         ; Some ("SourceEngine", String.to_json v.source_engine)
         ; Aws.Util.option_map v.enable_i_a_m_database_authentication (fun f ->
               "EnableIAMDatabaseAuthentication", Boolean.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "KmsKeyId", String.to_json f)
         ; Aws.Util.option_map v.storage_encrypted (fun f ->
               "StorageEncrypted", Boolean.to_json f)
         ; Some ("Tags", TagList.to_json v.tags)
         ; Aws.Util.option_map v.preferred_maintenance_window (fun f ->
               "PreferredMaintenanceWindow", String.to_json f)
         ; Aws.Util.option_map v.preferred_backup_window (fun f ->
               "PreferredBackupWindow", String.to_json f)
         ; Aws.Util.option_map v.option_group_name (fun f ->
               "OptionGroupName", String.to_json f)
         ; Some ("MasterUserPassword", String.to_json v.master_user_password)
         ; Some ("MasterUsername", String.to_json v.master_username)
         ; Aws.Util.option_map v.port (fun f -> "Port", Integer.to_json f)
         ; Aws.Util.option_map v.engine_version (fun f ->
               "EngineVersion", String.to_json f)
         ; Some ("Engine", String.to_json v.engine)
         ; Aws.Util.option_map v.d_b_subnet_group_name (fun f ->
               "DBSubnetGroupName", String.to_json f)
         ; Some
             ( "VpcSecurityGroupIds"
             , VpcSecurityGroupIdList.to_json v.vpc_security_group_ids )
         ; Aws.Util.option_map v.d_b_cluster_parameter_group_name (fun f ->
               "DBClusterParameterGroupName", String.to_json f)
         ; Some ("DBClusterIdentifier", String.to_json v.d_b_cluster_identifier)
         ; Aws.Util.option_map v.database_name (fun f -> "DatabaseName", String.to_json f)
         ; Aws.Util.option_map v.character_set_name (fun f ->
               "CharacterSetName", String.to_json f)
         ; Aws.Util.option_map v.backup_retention_period (fun f ->
               "BackupRetentionPeriod", Integer.to_json f)
         ; Some ("AvailabilityZones", AvailabilityZones.to_json v.availability_zones)
         ])

  let of_json j =
    { availability_zones =
        AvailabilityZones.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AvailabilityZones"))
    ; backup_retention_period =
        Aws.Util.option_map (Aws.Json.lookup j "BackupRetentionPeriod") Integer.of_json
    ; character_set_name =
        Aws.Util.option_map (Aws.Json.lookup j "CharacterSetName") String.of_json
    ; database_name =
        Aws.Util.option_map (Aws.Json.lookup j "DatabaseName") String.of_json
    ; d_b_cluster_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterIdentifier"))
    ; d_b_cluster_parameter_group_name =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBClusterParameterGroupName")
          String.of_json
    ; vpc_security_group_ids =
        VpcSecurityGroupIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcSecurityGroupIds"))
    ; d_b_subnet_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "DBSubnetGroupName") String.of_json
    ; engine = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Engine"))
    ; engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "EngineVersion") String.of_json
    ; port = Aws.Util.option_map (Aws.Json.lookup j "Port") Integer.of_json
    ; master_username =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "MasterUsername"))
    ; master_user_password =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "MasterUserPassword"))
    ; option_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "OptionGroupName") String.of_json
    ; preferred_backup_window =
        Aws.Util.option_map (Aws.Json.lookup j "PreferredBackupWindow") String.of_json
    ; preferred_maintenance_window =
        Aws.Util.option_map
          (Aws.Json.lookup j "PreferredMaintenanceWindow")
          String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    ; storage_encrypted =
        Aws.Util.option_map (Aws.Json.lookup j "StorageEncrypted") Boolean.of_json
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "KmsKeyId") String.of_json
    ; enable_i_a_m_database_authentication =
        Aws.Util.option_map
          (Aws.Json.lookup j "EnableIAMDatabaseAuthentication")
          Boolean.of_json
    ; source_engine =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceEngine"))
    ; source_engine_version =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceEngineVersion"))
    ; s3_bucket_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "S3BucketName"))
    ; s3_prefix = Aws.Util.option_map (Aws.Json.lookup j "S3Prefix") String.of_json
    ; s3_ingestion_role_arn =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "S3IngestionRoleArn"))
    ; backtrack_window =
        Aws.Util.option_map (Aws.Json.lookup j "BacktrackWindow") Long.of_json
    ; enable_cloudwatch_logs_exports =
        LogTypeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "EnableCloudwatchLogsExports"))
    ; deletion_protection =
        Aws.Util.option_map (Aws.Json.lookup j "DeletionProtection") Boolean.of_json
    ; copy_tags_to_snapshot =
        Aws.Util.option_map (Aws.Json.lookup j "CopyTagsToSnapshot") Boolean.of_json
    ; domain = Aws.Util.option_map (Aws.Json.lookup j "Domain") String.of_json
    ; domain_i_a_m_role_name =
        Aws.Util.option_map (Aws.Json.lookup j "DomainIAMRoleName") String.of_json
    }
end

module DeleteDBClusterSnapshotMessage = struct
  type t = { d_b_cluster_snapshot_identifier : String.t }

  let make ~d_b_cluster_snapshot_identifier () = { d_b_cluster_snapshot_identifier }

  let parse xml =
    Some
      { d_b_cluster_snapshot_identifier =
          Aws.Xml.required
            "DBClusterSnapshotIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBClusterSnapshotIdentifier" xml)
               String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "DBClusterSnapshotIdentifier"
                , String.to_query v.d_b_cluster_snapshot_identifier ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "DBClusterSnapshotIdentifier"
             , String.to_json v.d_b_cluster_snapshot_identifier )
         ])

  let of_json j =
    { d_b_cluster_snapshot_identifier =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterSnapshotIdentifier"))
    }
end

module RemoveFromGlobalClusterResult = struct
  type t = { global_cluster : GlobalCluster.t option }

  let make ?global_cluster () = { global_cluster }

  let parse xml =
    Some
      { global_cluster =
          Aws.Util.option_bind (Aws.Xml.member "GlobalCluster" xml) GlobalCluster.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.global_cluster (fun f ->
               Aws.Query.Pair ("GlobalCluster", GlobalCluster.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.global_cluster (fun f ->
               "GlobalCluster", GlobalCluster.to_json f)
         ])

  let of_json j =
    { global_cluster =
        Aws.Util.option_map (Aws.Json.lookup j "GlobalCluster") GlobalCluster.of_json
    }
end

module CreateDBInstanceResult = struct
  type t = { d_b_instance : DBInstance.t option }

  let make ?d_b_instance () = { d_b_instance }

  let parse xml =
    Some
      { d_b_instance =
          Aws.Util.option_bind (Aws.Xml.member "DBInstance" xml) DBInstance.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_instance (fun f ->
               Aws.Query.Pair ("DBInstance", DBInstance.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_instance (fun f ->
               "DBInstance", DBInstance.to_json f)
         ])

  let of_json j =
    { d_b_instance =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstance") DBInstance.of_json
    }
end

module DBSnapshotAlreadyExistsFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DeleteDBClusterSnapshotResult = struct
  type t = { d_b_cluster_snapshot : DBClusterSnapshot.t option }

  let make ?d_b_cluster_snapshot () = { d_b_cluster_snapshot }

  let parse xml =
    Some
      { d_b_cluster_snapshot =
          Aws.Util.option_bind
            (Aws.Xml.member "DBClusterSnapshot" xml)
            DBClusterSnapshot.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster_snapshot (fun f ->
               Aws.Query.Pair ("DBClusterSnapshot", DBClusterSnapshot.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster_snapshot (fun f ->
               "DBClusterSnapshot", DBClusterSnapshot.to_json f)
         ])

  let of_json j =
    { d_b_cluster_snapshot =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBClusterSnapshot")
          DBClusterSnapshot.of_json
    }
end

module InvalidDBSubnetGroupStateFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module CustomAvailabilityZoneMessage = struct
  type t =
    { marker : String.t option
    ; custom_availability_zones : CustomAvailabilityZoneList.t
    }

  let make ?marker ?(custom_availability_zones = []) () =
    { marker; custom_availability_zones }

  let parse xml =
    Some
      { marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      ; custom_availability_zones =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "CustomAvailabilityZones" xml)
               CustomAvailabilityZoneList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "CustomAvailabilityZones.member"
                , CustomAvailabilityZoneList.to_query v.custom_availability_zones ))
         ; Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "CustomAvailabilityZones"
             , CustomAvailabilityZoneList.to_json v.custom_availability_zones )
         ; Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ])

  let of_json j =
    { marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    ; custom_availability_zones =
        CustomAvailabilityZoneList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "CustomAvailabilityZones"))
    }
end

module IamRoleNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DescribeGlobalClustersMessage = struct
  type t =
    { global_cluster_identifier : String.t option
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    }

  let make ?global_cluster_identifier ?(filters = []) ?max_records ?marker () =
    { global_cluster_identifier; filters; max_records; marker }

  let parse xml =
    Some
      { global_cluster_identifier =
          Aws.Util.option_bind (Aws.Xml.member "GlobalClusterIdentifier" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.global_cluster_identifier (fun f ->
               Aws.Query.Pair ("GlobalClusterIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.global_cluster_identifier (fun f ->
               "GlobalClusterIdentifier", String.to_json f)
         ])

  let of_json j =
    { global_cluster_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "GlobalClusterIdentifier") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module InvalidS3BucketFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DBInstanceNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module AddRoleToDBClusterMessage = struct
  type t =
    { d_b_cluster_identifier : String.t
    ; role_arn : String.t
    ; feature_name : String.t option
    }

  let make ~d_b_cluster_identifier ~role_arn ?feature_name () =
    { d_b_cluster_identifier; role_arn; feature_name }

  let parse xml =
    Some
      { d_b_cluster_identifier =
          Aws.Xml.required
            "DBClusterIdentifier"
            (Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse)
      ; role_arn =
          Aws.Xml.required
            "RoleArn"
            (Aws.Util.option_bind (Aws.Xml.member "RoleArn" xml) String.parse)
      ; feature_name =
          Aws.Util.option_bind (Aws.Xml.member "FeatureName" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.feature_name (fun f ->
               Aws.Query.Pair ("FeatureName", String.to_query f))
         ; Some (Aws.Query.Pair ("RoleArn", String.to_query v.role_arn))
         ; Some
             (Aws.Query.Pair
                ("DBClusterIdentifier", String.to_query v.d_b_cluster_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.feature_name (fun f -> "FeatureName", String.to_json f)
         ; Some ("RoleArn", String.to_json v.role_arn)
         ; Some ("DBClusterIdentifier", String.to_json v.d_b_cluster_identifier)
         ])

  let of_json j =
    { d_b_cluster_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterIdentifier"))
    ; role_arn = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "RoleArn"))
    ; feature_name = Aws.Util.option_map (Aws.Json.lookup j "FeatureName") String.of_json
    }
end

module DescribeAccountAttributesMessage = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DBClusterRoleAlreadyExistsFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module DescribeEventSubscriptionsMessage = struct
  type t =
    { subscription_name : String.t option
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    }

  let make ?subscription_name ?(filters = []) ?max_records ?marker () =
    { subscription_name; filters; max_records; marker }

  let parse xml =
    Some
      { subscription_name =
          Aws.Util.option_bind (Aws.Xml.member "SubscriptionName" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.subscription_name (fun f ->
               Aws.Query.Pair ("SubscriptionName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.subscription_name (fun f ->
               "SubscriptionName", String.to_json f)
         ])

  let of_json j =
    { subscription_name =
        Aws.Util.option_map (Aws.Json.lookup j "SubscriptionName") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module AddSourceIdentifierToSubscriptionResult = struct
  type t = { event_subscription : EventSubscription.t option }

  let make ?event_subscription () = { event_subscription }

  let parse xml =
    Some
      { event_subscription =
          Aws.Util.option_bind
            (Aws.Xml.member "EventSubscription" xml)
            EventSubscription.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.event_subscription (fun f ->
               Aws.Query.Pair ("EventSubscription", EventSubscription.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.event_subscription (fun f ->
               "EventSubscription", EventSubscription.to_json f)
         ])

  let of_json j =
    { event_subscription =
        Aws.Util.option_map
          (Aws.Json.lookup j "EventSubscription")
          EventSubscription.of_json
    }
end

module DeleteDBSubnetGroupMessage = struct
  type t = { d_b_subnet_group_name : String.t }

  let make ~d_b_subnet_group_name () = { d_b_subnet_group_name }

  let parse xml =
    Some
      { d_b_subnet_group_name =
          Aws.Xml.required
            "DBSubnetGroupName"
            (Aws.Util.option_bind (Aws.Xml.member "DBSubnetGroupName" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("DBSubnetGroupName", String.to_query v.d_b_subnet_group_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("DBSubnetGroupName", String.to_json v.d_b_subnet_group_name) ])

  let of_json j =
    { d_b_subnet_group_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBSubnetGroupName"))
    }
end

module CreateDBInstanceReadReplicaResult = struct
  type t = { d_b_instance : DBInstance.t option }

  let make ?d_b_instance () = { d_b_instance }

  let parse xml =
    Some
      { d_b_instance =
          Aws.Util.option_bind (Aws.Xml.member "DBInstance" xml) DBInstance.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_instance (fun f ->
               Aws.Query.Pair ("DBInstance", DBInstance.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_instance (fun f ->
               "DBInstance", DBInstance.to_json f)
         ])

  let of_json j =
    { d_b_instance =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstance") DBInstance.of_json
    }
end

module DescribeValidDBInstanceModificationsResult = struct
  type t =
    { valid_d_b_instance_modifications_message :
        ValidDBInstanceModificationsMessage.t option
    }

  let make ?valid_d_b_instance_modifications_message () =
    { valid_d_b_instance_modifications_message }

  let parse xml =
    Some
      { valid_d_b_instance_modifications_message =
          Aws.Util.option_bind
            (Aws.Xml.member "ValidDBInstanceModificationsMessage" xml)
            ValidDBInstanceModificationsMessage.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.valid_d_b_instance_modifications_message (fun f ->
               Aws.Query.Pair
                 ( "ValidDBInstanceModificationsMessage"
                 , ValidDBInstanceModificationsMessage.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.valid_d_b_instance_modifications_message (fun f ->
               ( "ValidDBInstanceModificationsMessage"
               , ValidDBInstanceModificationsMessage.to_json f ))
         ])

  let of_json j =
    { valid_d_b_instance_modifications_message =
        Aws.Util.option_map
          (Aws.Json.lookup j "ValidDBInstanceModificationsMessage")
          ValidDBInstanceModificationsMessage.of_json
    }
end

module CopyDBClusterParameterGroupResult = struct
  type t = { d_b_cluster_parameter_group : DBClusterParameterGroup.t option }

  let make ?d_b_cluster_parameter_group () = { d_b_cluster_parameter_group }

  let parse xml =
    Some
      { d_b_cluster_parameter_group =
          Aws.Util.option_bind
            (Aws.Xml.member "DBClusterParameterGroup" xml)
            DBClusterParameterGroup.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster_parameter_group (fun f ->
               Aws.Query.Pair
                 ("DBClusterParameterGroup", DBClusterParameterGroup.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster_parameter_group (fun f ->
               "DBClusterParameterGroup", DBClusterParameterGroup.to_json f)
         ])

  let of_json j =
    { d_b_cluster_parameter_group =
        Aws.Util.option_map
          (Aws.Json.lookup j "DBClusterParameterGroup")
          DBClusterParameterGroup.of_json
    }
end

module DeleteDBSnapshotMessage = struct
  type t = { d_b_snapshot_identifier : String.t }

  let make ~d_b_snapshot_identifier () = { d_b_snapshot_identifier }

  let parse xml =
    Some
      { d_b_snapshot_identifier =
          Aws.Xml.required
            "DBSnapshotIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBSnapshotIdentifier" xml)
               String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("DBSnapshotIdentifier", String.to_query v.d_b_snapshot_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("DBSnapshotIdentifier", String.to_json v.d_b_snapshot_identifier) ])

  let of_json j =
    { d_b_snapshot_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBSnapshotIdentifier"))
    }
end

module CreateDBSubnetGroupMessage = struct
  type t =
    { d_b_subnet_group_name : String.t
    ; d_b_subnet_group_description : String.t
    ; subnet_ids : SubnetIdentifierList.t
    ; tags : TagList.t
    }

  let make
      ~d_b_subnet_group_name
      ~d_b_subnet_group_description
      ~subnet_ids
      ?(tags = [])
      () =
    { d_b_subnet_group_name; d_b_subnet_group_description; subnet_ids; tags }

  let parse xml =
    Some
      { d_b_subnet_group_name =
          Aws.Xml.required
            "DBSubnetGroupName"
            (Aws.Util.option_bind (Aws.Xml.member "DBSubnetGroupName" xml) String.parse)
      ; d_b_subnet_group_description =
          Aws.Xml.required
            "DBSubnetGroupDescription"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBSubnetGroupDescription" xml)
               String.parse)
      ; subnet_ids =
          Aws.Xml.required
            "SubnetIds"
            (Aws.Util.option_bind
               (Aws.Xml.member "SubnetIds" xml)
               SubnetIdentifierList.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Some
             (Aws.Query.Pair
                ("SubnetIds.member", SubnetIdentifierList.to_query v.subnet_ids))
         ; Some
             (Aws.Query.Pair
                ( "DBSubnetGroupDescription"
                , String.to_query v.d_b_subnet_group_description ))
         ; Some
             (Aws.Query.Pair ("DBSubnetGroupName", String.to_query v.d_b_subnet_group_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tags", TagList.to_json v.tags)
         ; Some ("SubnetIds", SubnetIdentifierList.to_json v.subnet_ids)
         ; Some ("DBSubnetGroupDescription", String.to_json v.d_b_subnet_group_description)
         ; Some ("DBSubnetGroupName", String.to_json v.d_b_subnet_group_name)
         ])

  let of_json j =
    { d_b_subnet_group_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBSubnetGroupName"))
    ; d_b_subnet_group_description =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DBSubnetGroupDescription"))
    ; subnet_ids =
        SubnetIdentifierList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SubnetIds"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    }
end

module DBClusterQuotaExceededFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module AuthorizationNotFoundFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module StopActivityStreamResponse = struct
  type t =
    { kms_key_id : String.t option
    ; kinesis_stream_name : String.t option
    ; status : ActivityStreamStatus.t option
    }

  let make ?kms_key_id ?kinesis_stream_name ?status () =
    { kms_key_id; kinesis_stream_name; status }

  let parse xml =
    Some
      { kms_key_id = Aws.Util.option_bind (Aws.Xml.member "KmsKeyId" xml) String.parse
      ; kinesis_stream_name =
          Aws.Util.option_bind (Aws.Xml.member "KinesisStreamName" xml) String.parse
      ; status =
          Aws.Util.option_bind (Aws.Xml.member "Status" xml) ActivityStreamStatus.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", ActivityStreamStatus.to_query f))
         ; Aws.Util.option_map v.kinesis_stream_name (fun f ->
               Aws.Query.Pair ("KinesisStreamName", String.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               "Status", ActivityStreamStatus.to_json f)
         ; Aws.Util.option_map v.kinesis_stream_name (fun f ->
               "KinesisStreamName", String.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "KmsKeyId", String.to_json f)
         ])

  let of_json j =
    { kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "KmsKeyId") String.of_json
    ; kinesis_stream_name =
        Aws.Util.option_map (Aws.Json.lookup j "KinesisStreamName") String.of_json
    ; status =
        Aws.Util.option_map (Aws.Json.lookup j "Status") ActivityStreamStatus.of_json
    }
end

module InsufficientStorageClusterCapacityFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module BacktrackDBClusterMessage = struct
  type t =
    { d_b_cluster_identifier : String.t
    ; backtrack_to : DateTime.t
    ; force : Boolean.t option
    ; use_earliest_time_on_point_in_time_unavailable : Boolean.t option
    }

  let make
      ~d_b_cluster_identifier
      ~backtrack_to
      ?force
      ?use_earliest_time_on_point_in_time_unavailable
      () =
    { d_b_cluster_identifier
    ; backtrack_to
    ; force
    ; use_earliest_time_on_point_in_time_unavailable
    }

  let parse xml =
    Some
      { d_b_cluster_identifier =
          Aws.Xml.required
            "DBClusterIdentifier"
            (Aws.Util.option_bind (Aws.Xml.member "DBClusterIdentifier" xml) String.parse)
      ; backtrack_to =
          Aws.Xml.required
            "BacktrackTo"
            (Aws.Util.option_bind (Aws.Xml.member "BacktrackTo" xml) DateTime.parse)
      ; force = Aws.Util.option_bind (Aws.Xml.member "Force" xml) Boolean.parse
      ; use_earliest_time_on_point_in_time_unavailable =
          Aws.Util.option_bind
            (Aws.Xml.member "UseEarliestTimeOnPointInTimeUnavailable" xml)
            Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.use_earliest_time_on_point_in_time_unavailable (fun f ->
               Aws.Query.Pair
                 ("UseEarliestTimeOnPointInTimeUnavailable", Boolean.to_query f))
         ; Aws.Util.option_map v.force (fun f ->
               Aws.Query.Pair ("Force", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("BacktrackTo", DateTime.to_query v.backtrack_to))
         ; Some
             (Aws.Query.Pair
                ("DBClusterIdentifier", String.to_query v.d_b_cluster_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.use_earliest_time_on_point_in_time_unavailable (fun f ->
               "UseEarliestTimeOnPointInTimeUnavailable", Boolean.to_json f)
         ; Aws.Util.option_map v.force (fun f -> "Force", Boolean.to_json f)
         ; Some ("BacktrackTo", DateTime.to_json v.backtrack_to)
         ; Some ("DBClusterIdentifier", String.to_json v.d_b_cluster_identifier)
         ])

  let of_json j =
    { d_b_cluster_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBClusterIdentifier"))
    ; backtrack_to =
        DateTime.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "BacktrackTo"))
    ; force = Aws.Util.option_map (Aws.Json.lookup j "Force") Boolean.of_json
    ; use_earliest_time_on_point_in_time_unavailable =
        Aws.Util.option_map
          (Aws.Json.lookup j "UseEarliestTimeOnPointInTimeUnavailable")
          Boolean.of_json
    }
end

module DescribeDBLogFilesMessage = struct
  type t =
    { d_b_instance_identifier : String.t
    ; filename_contains : String.t option
    ; file_last_written : Long.t option
    ; file_size : Long.t option
    ; filters : FilterList.t
    ; max_records : Integer.t option
    ; marker : String.t option
    }

  let make
      ~d_b_instance_identifier
      ?filename_contains
      ?file_last_written
      ?file_size
      ?(filters = [])
      ?max_records
      ?marker
      () =
    { d_b_instance_identifier
    ; filename_contains
    ; file_last_written
    ; file_size
    ; filters
    ; max_records
    ; marker
    }

  let parse xml =
    Some
      { d_b_instance_identifier =
          Aws.Xml.required
            "DBInstanceIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBInstanceIdentifier" xml)
               String.parse)
      ; filename_contains =
          Aws.Util.option_bind (Aws.Xml.member "FilenameContains" xml) String.parse
      ; file_last_written =
          Aws.Util.option_bind (Aws.Xml.member "FileLastWritten" xml) Long.parse
      ; file_size = Aws.Util.option_bind (Aws.Xml.member "FileSize" xml) Long.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; max_records = Aws.Util.option_bind (Aws.Xml.member "MaxRecords" xml) Integer.parse
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Aws.Util.option_map v.max_records (fun f ->
               Aws.Query.Pair ("MaxRecords", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filters.member", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.file_size (fun f ->
               Aws.Query.Pair ("FileSize", Long.to_query f))
         ; Aws.Util.option_map v.file_last_written (fun f ->
               Aws.Query.Pair ("FileLastWritten", Long.to_query f))
         ; Aws.Util.option_map v.filename_contains (fun f ->
               Aws.Query.Pair ("FilenameContains", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DBInstanceIdentifier", String.to_query v.d_b_instance_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Aws.Util.option_map v.max_records (fun f -> "MaxRecords", Integer.to_json f)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.file_size (fun f -> "FileSize", Long.to_json f)
         ; Aws.Util.option_map v.file_last_written (fun f ->
               "FileLastWritten", Long.to_json f)
         ; Aws.Util.option_map v.filename_contains (fun f ->
               "FilenameContains", String.to_json f)
         ; Some ("DBInstanceIdentifier", String.to_json v.d_b_instance_identifier)
         ])

  let of_json j =
    { d_b_instance_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBInstanceIdentifier"))
    ; filename_contains =
        Aws.Util.option_map (Aws.Json.lookup j "FilenameContains") String.of_json
    ; file_last_written =
        Aws.Util.option_map (Aws.Json.lookup j "FileLastWritten") Long.of_json
    ; file_size = Aws.Util.option_map (Aws.Json.lookup j "FileSize") Long.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; max_records = Aws.Util.option_map (Aws.Json.lookup j "MaxRecords") Integer.of_json
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module StartDBInstanceResult = struct
  type t = { d_b_instance : DBInstance.t option }

  let make ?d_b_instance () = { d_b_instance }

  let parse xml =
    Some
      { d_b_instance =
          Aws.Util.option_bind (Aws.Xml.member "DBInstance" xml) DBInstance.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_instance (fun f ->
               Aws.Query.Pair ("DBInstance", DBInstance.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_instance (fun f ->
               "DBInstance", DBInstance.to_json f)
         ])

  let of_json j =
    { d_b_instance =
        Aws.Util.option_map (Aws.Json.lookup j "DBInstance") DBInstance.of_json
    }
end

module OptionGroupOptionsMessage = struct
  type t =
    { option_group_options : OptionGroupOptionsList.t
    ; marker : String.t option
    }

  let make ?(option_group_options = []) ?marker () = { option_group_options; marker }

  let parse xml =
    Some
      { option_group_options =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "OptionGroupOptions" xml)
               OptionGroupOptionsList.parse)
      ; marker = Aws.Util.option_bind (Aws.Xml.member "Marker" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f ->
               Aws.Query.Pair ("Marker", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "OptionGroupOptions.member"
                , OptionGroupOptionsList.to_query v.option_group_options ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.marker (fun f -> "Marker", String.to_json f)
         ; Some
             ("OptionGroupOptions", OptionGroupOptionsList.to_json v.option_group_options)
         ])

  let of_json j =
    { option_group_options =
        OptionGroupOptionsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "OptionGroupOptions"))
    ; marker = Aws.Util.option_map (Aws.Json.lookup j "Marker") String.of_json
    }
end

module FailoverDBClusterResult = struct
  type t = { d_b_cluster : DBCluster.t option }

  let make ?d_b_cluster () = { d_b_cluster }

  let parse xml =
    Some
      { d_b_cluster =
          Aws.Util.option_bind (Aws.Xml.member "DBCluster" xml) DBCluster.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster (fun f ->
               Aws.Query.Pair ("DBCluster", DBCluster.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.d_b_cluster (fun f -> "DBCluster", DBCluster.to_json f) ])

  let of_json j =
    { d_b_cluster = Aws.Util.option_map (Aws.Json.lookup j "DBCluster") DBCluster.of_json
    }
end

module PromoteReadReplicaMessage = struct
  type t =
    { d_b_instance_identifier : String.t
    ; backup_retention_period : Integer.t option
    ; preferred_backup_window : String.t option
    }

  let make ~d_b_instance_identifier ?backup_retention_period ?preferred_backup_window () =
    { d_b_instance_identifier; backup_retention_period; preferred_backup_window }

  let parse xml =
    Some
      { d_b_instance_identifier =
          Aws.Xml.required
            "DBInstanceIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBInstanceIdentifier" xml)
               String.parse)
      ; backup_retention_period =
          Aws.Util.option_bind (Aws.Xml.member "BackupRetentionPeriod" xml) Integer.parse
      ; preferred_backup_window =
          Aws.Util.option_bind (Aws.Xml.member "PreferredBackupWindow" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.preferred_backup_window (fun f ->
               Aws.Query.Pair ("PreferredBackupWindow", String.to_query f))
         ; Aws.Util.option_map v.backup_retention_period (fun f ->
               Aws.Query.Pair ("BackupRetentionPeriod", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DBInstanceIdentifier", String.to_query v.d_b_instance_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.preferred_backup_window (fun f ->
               "PreferredBackupWindow", String.to_json f)
         ; Aws.Util.option_map v.backup_retention_period (fun f ->
               "BackupRetentionPeriod", Integer.to_json f)
         ; Some ("DBInstanceIdentifier", String.to_json v.d_b_instance_identifier)
         ])

  let of_json j =
    { d_b_instance_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBInstanceIdentifier"))
    ; backup_retention_period =
        Aws.Util.option_map (Aws.Json.lookup j "BackupRetentionPeriod") Integer.of_json
    ; preferred_backup_window =
        Aws.Util.option_map (Aws.Json.lookup j "PreferredBackupWindow") String.of_json
    }
end

module DeleteDBInstanceMessage = struct
  type t =
    { d_b_instance_identifier : String.t
    ; skip_final_snapshot : Boolean.t option
    ; final_d_b_snapshot_identifier : String.t option
    ; delete_automated_backups : Boolean.t option
    }

  let make
      ~d_b_instance_identifier
      ?skip_final_snapshot
      ?final_d_b_snapshot_identifier
      ?delete_automated_backups
      () =
    { d_b_instance_identifier
    ; skip_final_snapshot
    ; final_d_b_snapshot_identifier
    ; delete_automated_backups
    }

  let parse xml =
    Some
      { d_b_instance_identifier =
          Aws.Xml.required
            "DBInstanceIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "DBInstanceIdentifier" xml)
               String.parse)
      ; skip_final_snapshot =
          Aws.Util.option_bind (Aws.Xml.member "SkipFinalSnapshot" xml) Boolean.parse
      ; final_d_b_snapshot_identifier =
          Aws.Util.option_bind
            (Aws.Xml.member "FinalDBSnapshotIdentifier" xml)
            String.parse
      ; delete_automated_backups =
          Aws.Util.option_bind (Aws.Xml.member "DeleteAutomatedBackups" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.delete_automated_backups (fun f ->
               Aws.Query.Pair ("DeleteAutomatedBackups", Boolean.to_query f))
         ; Aws.Util.option_map v.final_d_b_snapshot_identifier (fun f ->
               Aws.Query.Pair ("FinalDBSnapshotIdentifier", String.to_query f))
         ; Aws.Util.option_map v.skip_final_snapshot (fun f ->
               Aws.Query.Pair ("SkipFinalSnapshot", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DBInstanceIdentifier", String.to_query v.d_b_instance_identifier))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.delete_automated_backups (fun f ->
               "DeleteAutomatedBackups", Boolean.to_json f)
         ; Aws.Util.option_map v.final_d_b_snapshot_identifier (fun f ->
               "FinalDBSnapshotIdentifier", String.to_json f)
         ; Aws.Util.option_map v.skip_final_snapshot (fun f ->
               "SkipFinalSnapshot", Boolean.to_json f)
         ; Some ("DBInstanceIdentifier", String.to_json v.d_b_instance_identifier)
         ])

  let of_json j =
    { d_b_instance_identifier =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DBInstanceIdentifier"))
    ; skip_final_snapshot =
        Aws.Util.option_map (Aws.Json.lookup j "SkipFinalSnapshot") Boolean.of_json
    ; final_d_b_snapshot_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "FinalDBSnapshotIdentifier") String.of_json
    ; delete_automated_backups =
        Aws.Util.option_map (Aws.Json.lookup j "DeleteAutomatedBackups") Boolean.of_json
    }
end

module DBInstanceAutomatedBackupQuotaExceededFault = struct
  type t = unit

  let make () = ()

  let parse xml = Some ()

  let to_query v = Aws.Query.List (Aws.Util.list_filter_opt [])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [])

  let of_json j = ()
end

module CopyOptionGroupMessage = struct
  type t =
    { source_option_group_identifier : String.t
    ; target_option_group_identifier : String.t
    ; target_option_group_description : String.t
    ; tags : TagList.t
    }

  let make
      ~source_option_group_identifier
      ~target_option_group_identifier
      ~target_option_group_description
      ?(tags = [])
      () =
    { source_option_group_identifier
    ; target_option_group_identifier
    ; target_option_group_description
    ; tags
    }

  let parse xml =
    Some
      { source_option_group_identifier =
          Aws.Xml.required
            "SourceOptionGroupIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "SourceOptionGroupIdentifier" xml)
               String.parse)
      ; target_option_group_identifier =
          Aws.Xml.required
            "TargetOptionGroupIdentifier"
            (Aws.Util.option_bind
               (Aws.Xml.member "TargetOptionGroupIdentifier" xml)
               String.parse)
      ; target_option_group_description =
          Aws.Xml.required
            "TargetOptionGroupDescription"
            (Aws.Util.option_bind
               (Aws.Xml.member "TargetOptionGroupDescription" xml)
               String.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tags" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tags.member", TagList.to_query v.tags))
         ; Some
             (Aws.Query.Pair
                ( "TargetOptionGroupDescription"
                , String.to_query v.target_option_group_description ))
         ; Some
             (Aws.Query.Pair
                ( "TargetOptionGroupIdentifier"
                , String.to_query v.target_option_group_identifier ))
         ; Some
             (Aws.Query.Pair
                ( "SourceOptionGroupIdentifier"
                , String.to_query v.source_option_group_identifier ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tags", TagList.to_json v.tags)
         ; Some
             ( "TargetOptionGroupDescription"
             , String.to_json v.target_option_group_description )
         ; Some
             ( "TargetOptionGroupIdentifier"
             , String.to_json v.target_option_group_identifier )
         ; Some
             ( "SourceOptionGroupIdentifier"
             , String.to_json v.source_option_group_identifier )
         ])

  let of_json j =
    { source_option_group_identifier =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceOptionGroupIdentifier"))
    ; target_option_group_identifier =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TargetOptionGroupIdentifier"))
    ; target_option_group_description =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TargetOptionGroupDescription"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tags"))
    }
end

module CreateGlobalClusterMessage = struct
  type t =
    { global_cluster_identifier : String.t option
    ; source_d_b_cluster_identifier : String.t option
    ; engine : String.t option
    ; engine_version : String.t option
    ; deletion_protection : Boolean.t option
    ; database_name : String.t option
    ; storage_encrypted : Boolean.t option
    }

  let make
      ?global_cluster_identifier
      ?source_d_b_cluster_identifier
      ?engine
      ?engine_version
      ?deletion_protection
      ?database_name
      ?storage_encrypted
      () =
    { global_cluster_identifier
    ; source_d_b_cluster_identifier
    ; engine
    ; engine_version
    ; deletion_protection
    ; database_name
    ; storage_encrypted
    }

  let parse xml =
    Some
      { global_cluster_identifier =
          Aws.Util.option_bind (Aws.Xml.member "GlobalClusterIdentifier" xml) String.parse
      ; source_d_b_cluster_identifier =
          Aws.Util.option_bind
            (Aws.Xml.member "SourceDBClusterIdentifier" xml)
            String.parse
      ; engine = Aws.Util.option_bind (Aws.Xml.member "Engine" xml) String.parse
      ; engine_version =
          Aws.Util.option_bind (Aws.Xml.member "EngineVersion" xml) String.parse
      ; deletion_protection =
          Aws.Util.option_bind (Aws.Xml.member "DeletionProtection" xml) Boolean.parse
      ; database_name =
          Aws.Util.option_bind (Aws.Xml.member "DatabaseName" xml) String.parse
      ; storage_encrypted =
          Aws.Util.option_bind (Aws.Xml.member "StorageEncrypted" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.storage_encrypted (fun f ->
               Aws.Query.Pair ("StorageEncrypted", Boolean.to_query f))
         ; Aws.Util.option_map v.database_name (fun f ->
               Aws.Query.Pair ("DatabaseName", String.to_query f))
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               Aws.Query.Pair ("DeletionProtection", Boolean.to_query f))
         ; Aws.Util.option_map v.engine_version (fun f ->
               Aws.Query.Pair ("EngineVersion", String.to_query f))
         ; Aws.Util.option_map v.engine (fun f ->
               Aws.Query.Pair ("Engine", String.to_query f))
         ; Aws.Util.option_map v.source_d_b_cluster_identifier (fun f ->
               Aws.Query.Pair ("SourceDBClusterIdentifier", String.to_query f))
         ; Aws.Util.option_map v.global_cluster_identifier (fun f ->
               Aws.Query.Pair ("GlobalClusterIdentifier", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.storage_encrypted (fun f ->
               "StorageEncrypted", Boolean.to_json f)
         ; Aws.Util.option_map v.database_name (fun f -> "DatabaseName", String.to_json f)
         ; Aws.Util.option_map v.deletion_protection (fun f ->
               "DeletionProtection", Boolean.to_json f)
         ; Aws.Util.option_map v.engine_version (fun f ->
               "EngineVersion", String.to_json f)
         ; Aws.Util.option_map v.engine (fun f -> "Engine", String.to_json f)
         ; Aws.Util.option_map v.source_d_b_cluster_identifier (fun f ->
               "SourceDBClusterIdentifier", String.to_json f)
         ; Aws.Util.option_map v.global_cluster_identifier (fun f ->
               "GlobalClusterIdentifier", String.to_json f)
         ])

  let of_json j =
    { global_cluster_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "GlobalClusterIdentifier") String.of_json
    ; source_d_b_cluster_identifier =
        Aws.Util.option_map (Aws.Json.lookup j "SourceDBClusterIdentifier") String.of_json
    ; engine = Aws.Util.option_map (Aws.Json.lookup j "Engine") String.of_json
    ; engine_version =
        Aws.Util.option_map (Aws.Json.lookup j "EngineVersion") String.of_json
    ; deletion_protection =
        Aws.Util.option_map (Aws.Json.lookup j "DeletionProtection") Boolean.of_json
    ; database_name =
        Aws.Util.option_map (Aws.Json.lookup j "DatabaseName") String.of_json
    ; storage_encrypted =
        Aws.Util.option_map (Aws.Json.lookup j "StorageEncrypted") Boolean.of_json
    }
end
