open Aws
open Aws.BaseTypes
open CalendarLib
type calendar = Calendar.t
module VolumeType =
  struct
    type t =
      | Standard 
      | Io1 
      | Gp2 
    let str_to_t = [("gp2", Gp2); ("io1", Io1); ("standard", Standard)]
    let t_to_str = [(Gp2, "gp2"); (Io1, "io1"); (Standard, "standard")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module PrivateIpAddressSpecification =
  struct
    type t = {
      private_ip_address: String.t ;
      primary: Boolean.t option }
    let make ~private_ip_address  ?primary  () =
      { private_ip_address; primary }
    let parse xml =
      Some
        {
          private_ip_address =
            (Xml.required "privateIpAddress"
               (Util.option_bind (Xml.member "privateIpAddress" xml)
                  String.parse));
          primary =
            (Util.option_bind (Xml.member "primary" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.primary
              (fun f -> Query.Pair ("Primary", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddress", (String.to_query v.private_ip_address)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.primary
              (fun f -> ("primary", (Boolean.to_json f)));
           Some ("private_ip_address", (String.to_json v.private_ip_address))])
    let of_json j =
      {
        private_ip_address =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "private_ip_address")));
        primary = (Util.option_map (Json.lookup j "primary") Boolean.of_json)
      }
  end
module InstanceNetworkInterfaceAssociation =
  struct
    type t =
      {
      public_ip: String.t option ;
      public_dns_name: String.t option ;
      ip_owner_id: String.t option }
    let make ?public_ip  ?public_dns_name  ?ip_owner_id  () =
      { public_ip; public_dns_name; ip_owner_id }
    let parse xml =
      Some
        {
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse);
          public_dns_name =
            (Util.option_bind (Xml.member "publicDnsName" xml) String.parse);
          ip_owner_id =
            (Util.option_bind (Xml.member "ipOwnerId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ip_owner_id
              (fun f -> Query.Pair ("IpOwnerId", (String.to_query f)));
           Util.option_map v.public_dns_name
             (fun f -> Query.Pair ("PublicDnsName", (String.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("PublicIp", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ip_owner_id
              (fun f -> ("ip_owner_id", (String.to_json f)));
           Util.option_map v.public_dns_name
             (fun f -> ("public_dns_name", (String.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)))])
    let of_json j =
      {
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json);
        public_dns_name =
          (Util.option_map (Json.lookup j "public_dns_name") String.of_json);
        ip_owner_id =
          (Util.option_map (Json.lookup j "ip_owner_id") String.of_json)
      }
  end
module EbsBlockDevice =
  struct
    type t =
      {
      snapshot_id: String.t option ;
      volume_size: Integer.t option ;
      delete_on_termination: Boolean.t option ;
      volume_type: VolumeType.t option ;
      iops: Integer.t option ;
      encrypted: Boolean.t option }
    let make ?snapshot_id  ?volume_size  ?delete_on_termination  ?volume_type
       ?iops  ?encrypted  () =
      {
        snapshot_id;
        volume_size;
        delete_on_termination;
        volume_type;
        iops;
        encrypted
      }
    let parse xml =
      Some
        {
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          volume_size =
            (Util.option_bind (Xml.member "volumeSize" xml) Integer.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          volume_type =
            (Util.option_bind (Xml.member "volumeType" xml) VolumeType.parse);
          iops = (Util.option_bind (Xml.member "iops" xml) Integer.parse);
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.encrypted
              (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.iops
             (fun f -> Query.Pair ("Iops", (Integer.to_query f)));
           Util.option_map v.volume_type
             (fun f -> Query.Pair ("VolumeType", (VolumeType.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.volume_size
             (fun f -> Query.Pair ("VolumeSize", (Integer.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.encrypted
              (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.iops (fun f -> ("iops", (Integer.to_json f)));
           Util.option_map v.volume_type
             (fun f -> ("volume_type", (VolumeType.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.volume_size
             (fun f -> ("volume_size", (Integer.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)))])
    let of_json j =
      {
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        volume_size =
          (Util.option_map (Json.lookup j "volume_size") Integer.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        volume_type =
          (Util.option_map (Json.lookup j "volume_type") VolumeType.of_json);
        iops = (Util.option_map (Json.lookup j "iops") Integer.of_json);
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json)
      }
  end
module PrivateIpAddressSpecificationList =
  struct
    type t = PrivateIpAddressSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PrivateIpAddressSpecification.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list PrivateIpAddressSpecification.to_query v
    let to_json v = `List (List.map PrivateIpAddressSpecification.to_json v)
    let of_json j = Json.to_list PrivateIpAddressSpecification.of_json j
  end
module SecurityGroupIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "SecurityGroupId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module AttachmentStatus =
  struct
    type t =
      | Attaching 
      | Attached 
      | Detaching 
      | Detached 
    let str_to_t =
      [("detached", Detached);
      ("detaching", Detaching);
      ("attached", Attached);
      ("attaching", Attaching)]
    let t_to_str =
      [(Detached, "detached");
      (Detaching, "detaching");
      (Attached, "attached");
      (Attaching, "attaching")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module GroupIdentifier =
  struct
    type t = {
      group_name: String.t option ;
      group_id: String.t option }
    let make ?group_name  ?group_id  () = { group_name; group_id }
    let parse xml =
      Some
        {
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          group_id =
            (Util.option_bind (Xml.member "groupId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_id
              (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_id
              (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)))])
    let of_json j =
      {
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json)
      }
  end
module InstancePrivateIpAddress =
  struct
    type t =
      {
      private_ip_address: String.t option ;
      private_dns_name: String.t option ;
      primary: Boolean.t option ;
      association: InstanceNetworkInterfaceAssociation.t option }
    let make ?private_ip_address  ?private_dns_name  ?primary  ?association 
      () = { private_ip_address; private_dns_name; primary; association }
    let parse xml =
      Some
        {
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          primary =
            (Util.option_bind (Xml.member "primary" xml) Boolean.parse);
          association =
            (Util.option_bind (Xml.member "association" xml)
               InstanceNetworkInterfaceAssociation.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.association
              (fun f ->
                 Query.Pair
                   ("Association",
                     (InstanceNetworkInterfaceAssociation.to_query f)));
           Util.option_map v.primary
             (fun f -> Query.Pair ("Primary", (Boolean.to_query f)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association
              (fun f ->
                 ("association",
                   (InstanceNetworkInterfaceAssociation.to_json f)));
           Util.option_map v.primary
             (fun f -> ("primary", (Boolean.to_json f)));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)))])
    let of_json j =
      {
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        private_dns_name =
          (Util.option_map (Json.lookup j "private_dns_name") String.of_json);
        primary = (Util.option_map (Json.lookup j "primary") Boolean.of_json);
        association =
          (Util.option_map (Json.lookup j "association")
             InstanceNetworkInterfaceAssociation.of_json)
      }
  end
module DiskImageFormat =
  struct
    type t =
      | VMDK 
      | RAW 
      | VHD 
    let str_to_t = [("VHD", VHD); ("RAW", RAW); ("VMDK", VMDK)]
    let t_to_str = [(VHD, "VHD"); (RAW, "RAW"); (VMDK, "VMDK")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module BlockDeviceMapping =
  struct
    type t =
      {
      virtual_name: String.t option ;
      device_name: String.t ;
      ebs: EbsBlockDevice.t option ;
      no_device: String.t option }
    let make ?virtual_name  ~device_name  ?ebs  ?no_device  () =
      { virtual_name; device_name; ebs; no_device }
    let parse xml =
      Some
        {
          virtual_name =
            (Util.option_bind (Xml.member "virtualName" xml) String.parse);
          device_name =
            (Xml.required "deviceName"
               (Util.option_bind (Xml.member "deviceName" xml) String.parse));
          ebs =
            (Util.option_bind (Xml.member "ebs" xml) EbsBlockDevice.parse);
          no_device =
            (Util.option_bind (Xml.member "noDevice" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.no_device
              (fun f -> Query.Pair ("NoDevice", (String.to_query f)));
           Util.option_map v.ebs
             (fun f -> Query.Pair ("Ebs", (EbsBlockDevice.to_query f)));
           Some (Query.Pair ("DeviceName", (String.to_query v.device_name)));
           Util.option_map v.virtual_name
             (fun f -> Query.Pair ("VirtualName", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.no_device
              (fun f -> ("no_device", (String.to_json f)));
           Util.option_map v.ebs
             (fun f -> ("ebs", (EbsBlockDevice.to_json f)));
           Some ("device_name", (String.to_json v.device_name));
           Util.option_map v.virtual_name
             (fun f -> ("virtual_name", (String.to_json f)))])
    let of_json j =
      {
        virtual_name =
          (Util.option_map (Json.lookup j "virtual_name") String.of_json);
        device_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "device_name")));
        ebs = (Util.option_map (Json.lookup j "ebs") EbsBlockDevice.of_json);
        no_device =
          (Util.option_map (Json.lookup j "no_device") String.of_json)
      }
  end
module InstanceNetworkInterfaceSpecification =
  struct
    type t =
      {
      network_interface_id: String.t option ;
      device_index: Integer.t option ;
      subnet_id: String.t option ;
      description: String.t option ;
      private_ip_address: String.t option ;
      groups: SecurityGroupIdStringList.t ;
      delete_on_termination: Boolean.t option ;
      private_ip_addresses: PrivateIpAddressSpecificationList.t ;
      secondary_private_ip_address_count: Integer.t option ;
      associate_public_ip_address: Boolean.t option }
    let make ?network_interface_id  ?device_index  ?subnet_id  ?description 
      ?private_ip_address  ?(groups= [])  ?delete_on_termination 
      ?(private_ip_addresses= [])  ?secondary_private_ip_address_count 
      ?associate_public_ip_address  () =
      {
        network_interface_id;
        device_index;
        subnet_id;
        description;
        private_ip_address;
        groups;
        delete_on_termination;
        private_ip_addresses;
        secondary_private_ip_address_count;
        associate_public_ip_address
      }
    let parse xml =
      Some
        {
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          device_index =
            (Util.option_bind (Xml.member "deviceIndex" xml) Integer.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  SecurityGroupIdStringList.parse));
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          private_ip_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "privateIpAddressesSet" xml)
                  PrivateIpAddressSpecificationList.parse));
          secondary_private_ip_address_count =
            (Util.option_bind
               (Xml.member "secondaryPrivateIpAddressCount" xml)
               Integer.parse);
          associate_public_ip_address =
            (Util.option_bind (Xml.member "associatePublicIpAddress" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.associate_public_ip_address
              (fun f ->
                 Query.Pair
                   ("AssociatePublicIpAddress", (Boolean.to_query f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                Query.Pair
                  ("SecondaryPrivateIpAddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddressesSet",
                  (PrivateIpAddressSpecificationList.to_query
                     v.private_ip_addresses)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (SecurityGroupIdStringList.to_query v.groups)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.device_index
             (fun f -> Query.Pair ("DeviceIndex", (Integer.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.associate_public_ip_address
              (fun f -> ("associate_public_ip_address", (Boolean.to_json f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                ("secondary_private_ip_address_count", (Integer.to_json f)));
           Some
             ("private_ip_addresses",
               (PrivateIpAddressSpecificationList.to_json
                  v.private_ip_addresses));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Some ("groups", (SecurityGroupIdStringList.to_json v.groups));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.device_index
             (fun f -> ("device_index", (Integer.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)))])
    let of_json j =
      {
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        device_index =
          (Util.option_map (Json.lookup j "device_index") Integer.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        groups =
          (SecurityGroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        private_ip_addresses =
          (PrivateIpAddressSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "private_ip_addresses")));
        secondary_private_ip_address_count =
          (Util.option_map
             (Json.lookup j "secondary_private_ip_address_count")
             Integer.of_json);
        associate_public_ip_address =
          (Util.option_map (Json.lookup j "associate_public_ip_address")
             Boolean.of_json)
      }
  end
module EbsInstanceBlockDevice =
  struct
    type t =
      {
      volume_id: String.t option ;
      status: AttachmentStatus.t option ;
      attach_time: DateTime.t option ;
      delete_on_termination: Boolean.t option }
    let make ?volume_id  ?status  ?attach_time  ?delete_on_termination  () =
      { volume_id; status; attach_time; delete_on_termination }
    let parse xml =
      Some
        {
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               AttachmentStatus.parse);
          attach_time =
            (Util.option_bind (Xml.member "attachTime" xml) DateTime.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.delete_on_termination
              (fun f ->
                 Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.attach_time
             (fun f -> Query.Pair ("AttachTime", (DateTime.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (AttachmentStatus.to_query f)));
           Util.option_map v.volume_id
             (fun f -> Query.Pair ("VolumeId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.delete_on_termination
              (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.attach_time
             (fun f -> ("attach_time", (DateTime.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (AttachmentStatus.to_json f)));
           Util.option_map v.volume_id
             (fun f -> ("volume_id", (String.to_json f)))])
    let of_json j =
      {
        volume_id =
          (Util.option_map (Json.lookup j "volume_id") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status") AttachmentStatus.of_json);
        attach_time =
          (Util.option_map (Json.lookup j "attach_time") DateTime.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json)
      }
  end
module GroupIdentifierList =
  struct
    type t = GroupIdentifier.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map GroupIdentifier.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list GroupIdentifier.to_query v
    let to_json v = `List (List.map GroupIdentifier.to_json v)
    let of_json j = Json.to_list GroupIdentifier.of_json j
  end
module InstanceNetworkInterfaceAttachment =
  struct
    type t =
      {
      attachment_id: String.t option ;
      device_index: Integer.t option ;
      status: AttachmentStatus.t option ;
      attach_time: DateTime.t option ;
      delete_on_termination: Boolean.t option }
    let make ?attachment_id  ?device_index  ?status  ?attach_time 
      ?delete_on_termination  () =
      {
        attachment_id;
        device_index;
        status;
        attach_time;
        delete_on_termination
      }
    let parse xml =
      Some
        {
          attachment_id =
            (Util.option_bind (Xml.member "attachmentId" xml) String.parse);
          device_index =
            (Util.option_bind (Xml.member "deviceIndex" xml) Integer.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               AttachmentStatus.parse);
          attach_time =
            (Util.option_bind (Xml.member "attachTime" xml) DateTime.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.delete_on_termination
              (fun f ->
                 Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.attach_time
             (fun f -> Query.Pair ("AttachTime", (DateTime.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (AttachmentStatus.to_query f)));
           Util.option_map v.device_index
             (fun f -> Query.Pair ("DeviceIndex", (Integer.to_query f)));
           Util.option_map v.attachment_id
             (fun f -> Query.Pair ("AttachmentId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.delete_on_termination
              (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.attach_time
             (fun f -> ("attach_time", (DateTime.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (AttachmentStatus.to_json f)));
           Util.option_map v.device_index
             (fun f -> ("device_index", (Integer.to_json f)));
           Util.option_map v.attachment_id
             (fun f -> ("attachment_id", (String.to_json f)))])
    let of_json j =
      {
        attachment_id =
          (Util.option_map (Json.lookup j "attachment_id") String.of_json);
        device_index =
          (Util.option_map (Json.lookup j "device_index") Integer.of_json);
        status =
          (Util.option_map (Json.lookup j "status") AttachmentStatus.of_json);
        attach_time =
          (Util.option_map (Json.lookup j "attach_time") DateTime.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json)
      }
  end
module InstancePrivateIpAddressList =
  struct
    type t = InstancePrivateIpAddress.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstancePrivateIpAddress.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstancePrivateIpAddress.to_query v
    let to_json v = `List (List.map InstancePrivateIpAddress.to_json v)
    let of_json j = Json.to_list InstancePrivateIpAddress.of_json j
  end
module NetworkInterfaceStatus =
  struct
    type t =
      | Available 
      | Attaching 
      | In_use 
      | Detaching 
    let str_to_t =
      [("detaching", Detaching);
      ("in-use", In_use);
      ("attaching", Attaching);
      ("available", Available)]
    let t_to_str =
      [(Detaching, "detaching");
      (In_use, "in-use");
      (Attaching, "attaching");
      (Available, "available")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ProductCodeValues =
  struct
    type t =
      | Devpay 
      | Marketplace 
    let str_to_t = [("marketplace", Marketplace); ("devpay", Devpay)]
    let t_to_str = [(Marketplace, "marketplace"); (Devpay, "devpay")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AttributeValue =
  struct
    type t = {
      value: String.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") String.of_json) }
  end
module InstanceType =
  struct
    type t =
      | T1_micro 
      | M1_small 
      | M1_medium 
      | M1_large 
      | M1_xlarge 
      | M3_medium 
      | M3_large 
      | M3_xlarge 
      | M3_2xlarge 
      | M4_large 
      | M4_xlarge 
      | M4_2xlarge 
      | M4_4xlarge 
      | M4_10xlarge 
      | T2_micro 
      | T2_small 
      | T2_medium 
      | T2_large 
      | M2_xlarge 
      | M2_2xlarge 
      | M2_4xlarge 
      | Cr1_8xlarge 
      | I2_xlarge 
      | I2_2xlarge 
      | I2_4xlarge 
      | I2_8xlarge 
      | Hi1_4xlarge 
      | Hs1_8xlarge 
      | C1_medium 
      | C1_xlarge 
      | C3_large 
      | C3_xlarge 
      | C3_2xlarge 
      | C3_4xlarge 
      | C3_8xlarge 
      | C4_large 
      | C4_xlarge 
      | C4_2xlarge 
      | C4_4xlarge 
      | C4_8xlarge 
      | Cc1_4xlarge 
      | Cc2_8xlarge 
      | G2_2xlarge 
      | Cg1_4xlarge 
      | R3_large 
      | R3_xlarge 
      | R3_2xlarge 
      | R3_4xlarge 
      | R3_8xlarge 
      | D2_xlarge 
      | D2_2xlarge 
      | D2_4xlarge 
      | D2_8xlarge 
    let str_to_t =
      [("d2.8xlarge", D2_8xlarge);
      ("d2.4xlarge", D2_4xlarge);
      ("d2.2xlarge", D2_2xlarge);
      ("d2.xlarge", D2_xlarge);
      ("r3.8xlarge", R3_8xlarge);
      ("r3.4xlarge", R3_4xlarge);
      ("r3.2xlarge", R3_2xlarge);
      ("r3.xlarge", R3_xlarge);
      ("r3.large", R3_large);
      ("cg1.4xlarge", Cg1_4xlarge);
      ("g2.2xlarge", G2_2xlarge);
      ("cc2.8xlarge", Cc2_8xlarge);
      ("cc1.4xlarge", Cc1_4xlarge);
      ("c4.8xlarge", C4_8xlarge);
      ("c4.4xlarge", C4_4xlarge);
      ("c4.2xlarge", C4_2xlarge);
      ("c4.xlarge", C4_xlarge);
      ("c4.large", C4_large);
      ("c3.8xlarge", C3_8xlarge);
      ("c3.4xlarge", C3_4xlarge);
      ("c3.2xlarge", C3_2xlarge);
      ("c3.xlarge", C3_xlarge);
      ("c3.large", C3_large);
      ("c1.xlarge", C1_xlarge);
      ("c1.medium", C1_medium);
      ("hs1.8xlarge", Hs1_8xlarge);
      ("hi1.4xlarge", Hi1_4xlarge);
      ("i2.8xlarge", I2_8xlarge);
      ("i2.4xlarge", I2_4xlarge);
      ("i2.2xlarge", I2_2xlarge);
      ("i2.xlarge", I2_xlarge);
      ("cr1.8xlarge", Cr1_8xlarge);
      ("m2.4xlarge", M2_4xlarge);
      ("m2.2xlarge", M2_2xlarge);
      ("m2.xlarge", M2_xlarge);
      ("t2.large", T2_large);
      ("t2.medium", T2_medium);
      ("t2.small", T2_small);
      ("t2.micro", T2_micro);
      ("m4.10xlarge", M4_10xlarge);
      ("m4.4xlarge", M4_4xlarge);
      ("m4.2xlarge", M4_2xlarge);
      ("m4.xlarge", M4_xlarge);
      ("m4.large", M4_large);
      ("m3.2xlarge", M3_2xlarge);
      ("m3.xlarge", M3_xlarge);
      ("m3.large", M3_large);
      ("m3.medium", M3_medium);
      ("m1.xlarge", M1_xlarge);
      ("m1.large", M1_large);
      ("m1.medium", M1_medium);
      ("m1.small", M1_small);
      ("t1.micro", T1_micro)]
    let t_to_str =
      [(D2_8xlarge, "d2.8xlarge");
      (D2_4xlarge, "d2.4xlarge");
      (D2_2xlarge, "d2.2xlarge");
      (D2_xlarge, "d2.xlarge");
      (R3_8xlarge, "r3.8xlarge");
      (R3_4xlarge, "r3.4xlarge");
      (R3_2xlarge, "r3.2xlarge");
      (R3_xlarge, "r3.xlarge");
      (R3_large, "r3.large");
      (Cg1_4xlarge, "cg1.4xlarge");
      (G2_2xlarge, "g2.2xlarge");
      (Cc2_8xlarge, "cc2.8xlarge");
      (Cc1_4xlarge, "cc1.4xlarge");
      (C4_8xlarge, "c4.8xlarge");
      (C4_4xlarge, "c4.4xlarge");
      (C4_2xlarge, "c4.2xlarge");
      (C4_xlarge, "c4.xlarge");
      (C4_large, "c4.large");
      (C3_8xlarge, "c3.8xlarge");
      (C3_4xlarge, "c3.4xlarge");
      (C3_2xlarge, "c3.2xlarge");
      (C3_xlarge, "c3.xlarge");
      (C3_large, "c3.large");
      (C1_xlarge, "c1.xlarge");
      (C1_medium, "c1.medium");
      (Hs1_8xlarge, "hs1.8xlarge");
      (Hi1_4xlarge, "hi1.4xlarge");
      (I2_8xlarge, "i2.8xlarge");
      (I2_4xlarge, "i2.4xlarge");
      (I2_2xlarge, "i2.2xlarge");
      (I2_xlarge, "i2.xlarge");
      (Cr1_8xlarge, "cr1.8xlarge");
      (M2_4xlarge, "m2.4xlarge");
      (M2_2xlarge, "m2.2xlarge");
      (M2_xlarge, "m2.xlarge");
      (T2_large, "t2.large");
      (T2_medium, "t2.medium");
      (T2_small, "t2.small");
      (T2_micro, "t2.micro");
      (M4_10xlarge, "m4.10xlarge");
      (M4_4xlarge, "m4.4xlarge");
      (M4_2xlarge, "m4.2xlarge");
      (M4_xlarge, "m4.xlarge");
      (M4_large, "m4.large");
      (M3_2xlarge, "m3.2xlarge");
      (M3_xlarge, "m3.xlarge");
      (M3_large, "m3.large");
      (M3_medium, "m3.medium");
      (M1_xlarge, "m1.xlarge");
      (M1_large, "m1.large");
      (M1_medium, "m1.medium");
      (M1_small, "m1.small");
      (T1_micro, "t1.micro")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DiskImageDescription =
  struct
    type t =
      {
      format: DiskImageFormat.t ;
      size: Long.t ;
      import_manifest_url: String.t ;
      checksum: String.t option }
    let make ~format  ~size  ~import_manifest_url  ?checksum  () =
      { format; size; import_manifest_url; checksum }
    let parse xml =
      Some
        {
          format =
            (Xml.required "format"
               (Util.option_bind (Xml.member "format" xml)
                  DiskImageFormat.parse));
          size =
            (Xml.required "size"
               (Util.option_bind (Xml.member "size" xml) Long.parse));
          import_manifest_url =
            (Xml.required "importManifestUrl"
               (Util.option_bind (Xml.member "importManifestUrl" xml)
                  String.parse));
          checksum =
            (Util.option_bind (Xml.member "checksum" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.checksum
              (fun f -> Query.Pair ("Checksum", (String.to_query f)));
           Some
             (Query.Pair
                ("ImportManifestUrl",
                  (String.to_query v.import_manifest_url)));
           Some (Query.Pair ("Size", (Long.to_query v.size)));
           Some (Query.Pair ("Format", (DiskImageFormat.to_query v.format)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.checksum
              (fun f -> ("checksum", (String.to_json f)));
           Some
             ("import_manifest_url", (String.to_json v.import_manifest_url));
           Some ("size", (Long.to_json v.size));
           Some ("format", (DiskImageFormat.to_json v.format))])
    let of_json j =
      {
        format =
          (DiskImageFormat.of_json
             (Util.of_option_exn (Json.lookup j "format")));
        size = (Long.of_json (Util.of_option_exn (Json.lookup j "size")));
        import_manifest_url =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "import_manifest_url")));
        checksum =
          (Util.option_map (Json.lookup j "checksum") String.of_json)
      }
  end
module DiskImageVolumeDescription =
  struct
    type t = {
      size: Long.t option ;
      id: String.t }
    let make ?size  ~id  () = { size; id }
    let parse xml =
      Some
        {
          size = (Util.option_bind (Xml.member "size" xml) Long.parse);
          id =
            (Xml.required "id"
               (Util.option_bind (Xml.member "id" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Id", (String.to_query v.id)));
           Util.option_map v.size
             (fun f -> Query.Pair ("Size", (Long.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("id", (String.to_json v.id));
           Util.option_map v.size (fun f -> ("size", (Long.to_json f)))])
    let of_json j =
      {
        size = (Util.option_map (Json.lookup j "size") Long.of_json);
        id = (String.of_json (Util.of_option_exn (Json.lookup j "id")))
      }
  end
module StatusName =
  struct
    type t =
      | Reachability 
    let str_to_t = [("reachability", Reachability)]
    let t_to_str = [(Reachability, "reachability")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module StatusType =
  struct
    type t =
      | Passed 
      | Failed 
      | Insufficient_data 
      | Initializing 
    let str_to_t =
      [("initializing", Initializing);
      ("insufficient-data", Insufficient_data);
      ("failed", Failed);
      ("passed", Passed)]
    let t_to_str =
      [(Initializing, "initializing");
      (Insufficient_data, "insufficient-data");
      (Failed, "failed");
      (Passed, "passed")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module IpRange =
  struct
    type t = {
      cidr_ip: String.t }
    let make ~cidr_ip  () = { cidr_ip }
    let parse xml =
      Some
        {
          cidr_ip =
            (Xml.required "cidrIp"
               (Util.option_bind (Xml.member "cidrIp" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("CidrIp", (String.to_query v.cidr_ip)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt [Some ("cidr_ip", (String.to_json v.cidr_ip))])
    let of_json j =
      {
        cidr_ip =
          (String.of_json (Util.of_option_exn (Json.lookup j "cidr_ip")))
      }
  end
module PrefixListId =
  struct
    type t = {
      prefix_list_id: String.t option }
    let make ?prefix_list_id  () = { prefix_list_id }
    let parse xml =
      Some
        {
          prefix_list_id =
            (Util.option_bind (Xml.member "prefixListId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.prefix_list_id
              (fun f -> Query.Pair ("PrefixListId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.prefix_list_id
              (fun f -> ("prefix_list_id", (String.to_json f)))])
    let of_json j =
      {
        prefix_list_id =
          (Util.option_map (Json.lookup j "prefix_list_id") String.of_json)
      }
  end
module UserIdGroupPair =
  struct
    type t =
      {
      user_id: String.t option ;
      group_name: String.t option ;
      group_id: String.t option }
    let make ?user_id  ?group_name  ?group_id  () =
      { user_id; group_name; group_id }
    let parse xml =
      Some
        {
          user_id = (Util.option_bind (Xml.member "userId" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          group_id =
            (Util.option_bind (Xml.member "groupId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_id
              (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.user_id
             (fun f -> Query.Pair ("UserId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_id
              (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.user_id
             (fun f -> ("user_id", (String.to_json f)))])
    let of_json j =
      {
        user_id = (Util.option_map (Json.lookup j "user_id") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json)
      }
  end
module BlockDeviceMappingList =
  struct
    type t = BlockDeviceMapping.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map BlockDeviceMapping.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list BlockDeviceMapping.to_query v
    let to_json v = `List (List.map BlockDeviceMapping.to_json v)
    let of_json j = Json.to_list BlockDeviceMapping.of_json j
  end
module IamInstanceProfileSpecification =
  struct
    type t = {
      arn: String.t option ;
      name: String.t option }
    let make ?arn  ?name  () = { arn; name }
    let parse xml =
      Some
        {
          arn = (Util.option_bind (Xml.member "arn" xml) String.parse);
          name = (Util.option_bind (Xml.member "name" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.name
              (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.arn
             (fun f -> Query.Pair ("Arn", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.arn (fun f -> ("arn", (String.to_json f)))])
    let of_json j =
      {
        arn = (Util.option_map (Json.lookup j "arn") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json)
      }
  end
module InstanceNetworkInterfaceSpecificationList =
  struct
    type t = InstanceNetworkInterfaceSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceNetworkInterfaceSpecification.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list InstanceNetworkInterfaceSpecification.to_query v
    let to_json v =
      `List (List.map InstanceNetworkInterfaceSpecification.to_json v)
    let of_json j =
      Json.to_list InstanceNetworkInterfaceSpecification.of_json j
  end
module SpotFleetMonitoring =
  struct
    type t = {
      enabled: Boolean.t option }
    let make ?enabled  () = { enabled }
    let parse xml =
      Some
        {
          enabled =
            (Util.option_bind (Xml.member "enabled" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> ("enabled", (Boolean.to_json f)))])
    let of_json j =
      { enabled = (Util.option_map (Json.lookup j "enabled") Boolean.of_json)
      }
  end
module SpotPlacement =
  struct
    type t =
      {
      availability_zone: String.t option ;
      group_name: String.t option }
    let make ?availability_zone  ?group_name  () =
      { availability_zone; group_name }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_name
              (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_name
              (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json)
      }
  end
module VolumeStatusName =
  struct
    type t =
      | Io_enabled 
      | Io_performance 
    let str_to_t =
      [("io-performance", Io_performance); ("io-enabled", Io_enabled)]
    let t_to_str =
      [(Io_performance, "io-performance"); (Io_enabled, "io-enabled")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceBlockDeviceMapping =
  struct
    type t =
      {
      device_name: String.t option ;
      ebs: EbsInstanceBlockDevice.t option }
    let make ?device_name  ?ebs  () = { device_name; ebs }
    let parse xml =
      Some
        {
          device_name =
            (Util.option_bind (Xml.member "deviceName" xml) String.parse);
          ebs =
            (Util.option_bind (Xml.member "ebs" xml)
               EbsInstanceBlockDevice.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ebs
              (fun f ->
                 Query.Pair ("Ebs", (EbsInstanceBlockDevice.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ebs
              (fun f -> ("ebs", (EbsInstanceBlockDevice.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)))])
    let of_json j =
      {
        device_name =
          (Util.option_map (Json.lookup j "device_name") String.of_json);
        ebs =
          (Util.option_map (Json.lookup j "ebs")
             EbsInstanceBlockDevice.of_json)
      }
  end
module InstanceNetworkInterface =
  struct
    type t =
      {
      network_interface_id: String.t option ;
      subnet_id: String.t option ;
      vpc_id: String.t option ;
      description: String.t option ;
      owner_id: String.t option ;
      status: NetworkInterfaceStatus.t option ;
      mac_address: String.t option ;
      private_ip_address: String.t option ;
      private_dns_name: String.t option ;
      source_dest_check: Boolean.t option ;
      groups: GroupIdentifierList.t ;
      attachment: InstanceNetworkInterfaceAttachment.t option ;
      association: InstanceNetworkInterfaceAssociation.t option ;
      private_ip_addresses: InstancePrivateIpAddressList.t }
    let make ?network_interface_id  ?subnet_id  ?vpc_id  ?description 
      ?owner_id  ?status  ?mac_address  ?private_ip_address 
      ?private_dns_name  ?source_dest_check  ?(groups= [])  ?attachment 
      ?association  ?(private_ip_addresses= [])  () =
      {
        network_interface_id;
        subnet_id;
        vpc_id;
        description;
        owner_id;
        status;
        mac_address;
        private_ip_address;
        private_dns_name;
        source_dest_check;
        groups;
        attachment;
        association;
        private_ip_addresses
      }
    let parse xml =
      Some
        {
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               NetworkInterfaceStatus.parse);
          mac_address =
            (Util.option_bind (Xml.member "macAddress" xml) String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml)
               Boolean.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          attachment =
            (Util.option_bind (Xml.member "attachment" xml)
               InstanceNetworkInterfaceAttachment.parse);
          association =
            (Util.option_bind (Xml.member "association" xml)
               InstanceNetworkInterfaceAssociation.parse);
          private_ip_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "privateIpAddressesSet" xml)
                  InstancePrivateIpAddressList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PrivateIpAddressesSet",
                   (InstancePrivateIpAddressList.to_query
                      v.private_ip_addresses)));
           Util.option_map v.association
             (fun f ->
                Query.Pair
                  ("Association",
                    (InstanceNetworkInterfaceAssociation.to_query f)));
           Util.option_map v.attachment
             (fun f ->
                Query.Pair
                  ("Attachment",
                    (InstanceNetworkInterfaceAttachment.to_query f)));
           Some
             (Query.Pair
                ("GroupSet", (GroupIdentifierList.to_query v.groups)));
           Util.option_map v.source_dest_check
             (fun f -> Query.Pair ("SourceDestCheck", (Boolean.to_query f)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.mac_address
             (fun f -> Query.Pair ("MacAddress", (String.to_query f)));
           Util.option_map v.status
             (fun f ->
                Query.Pair ("Status", (NetworkInterfaceStatus.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("private_ip_addresses",
                (InstancePrivateIpAddressList.to_json v.private_ip_addresses));
           Util.option_map v.association
             (fun f ->
                ("association",
                  (InstanceNetworkInterfaceAssociation.to_json f)));
           Util.option_map v.attachment
             (fun f ->
                ("attachment",
                  (InstanceNetworkInterfaceAttachment.to_json f)));
           Some ("groups", (GroupIdentifierList.to_json v.groups));
           Util.option_map v.source_dest_check
             (fun f -> ("source_dest_check", (Boolean.to_json f)));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.mac_address
             (fun f -> ("mac_address", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (NetworkInterfaceStatus.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)))])
    let of_json j =
      {
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             NetworkInterfaceStatus.of_json);
        mac_address =
          (Util.option_map (Json.lookup j "mac_address") String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        private_dns_name =
          (Util.option_map (Json.lookup j "private_dns_name") String.of_json);
        source_dest_check =
          (Util.option_map (Json.lookup j "source_dest_check")
             Boolean.of_json);
        groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        attachment =
          (Util.option_map (Json.lookup j "attachment")
             InstanceNetworkInterfaceAttachment.of_json);
        association =
          (Util.option_map (Json.lookup j "association")
             InstanceNetworkInterfaceAssociation.of_json);
        private_ip_addresses =
          (InstancePrivateIpAddressList.of_json
             (Util.of_option_exn (Json.lookup j "private_ip_addresses")))
      }
  end
module InstanceStateName =
  struct
    type t =
      | Pending 
      | Running 
      | Shutting_down 
      | Terminated 
      | Stopping 
      | Stopped 
    let str_to_t =
      [("stopped", Stopped);
      ("stopping", Stopping);
      ("terminated", Terminated);
      ("shutting-down", Shutting_down);
      ("running", Running);
      ("pending", Pending)]
    let t_to_str =
      [(Stopped, "stopped");
      (Stopping, "stopping");
      (Terminated, "terminated");
      (Shutting_down, "shutting-down");
      (Running, "running");
      (Pending, "pending")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module MonitoringState =
  struct
    type t =
      | Disabled 
      | Disabling 
      | Enabled 
      | Pending 
    let str_to_t =
      [("pending", Pending);
      ("enabled", Enabled);
      ("disabling", Disabling);
      ("disabled", Disabled)]
    let t_to_str =
      [(Pending, "pending");
      (Enabled, "enabled");
      (Disabling, "disabling");
      (Disabled, "disabled")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module Tenancy =
  struct
    type t =
      | Default 
      | Dedicated 
    let str_to_t = [("dedicated", Dedicated); ("default", Default)]
    let t_to_str = [(Dedicated, "dedicated"); (Default, "default")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ProductCode =
  struct
    type t =
      {
      product_code_id: String.t option ;
      product_code_type: ProductCodeValues.t option }
    let make ?product_code_id  ?product_code_type  () =
      { product_code_id; product_code_type }
    let parse xml =
      Some
        {
          product_code_id =
            (Util.option_bind (Xml.member "productCode" xml) String.parse);
          product_code_type =
            (Util.option_bind (Xml.member "type" xml) ProductCodeValues.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.product_code_type
              (fun f -> Query.Pair ("Type", (ProductCodeValues.to_query f)));
           Util.option_map v.product_code_id
             (fun f -> Query.Pair ("ProductCode", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.product_code_type
              (fun f -> ("product_code_type", (ProductCodeValues.to_json f)));
           Util.option_map v.product_code_id
             (fun f -> ("product_code_id", (String.to_json f)))])
    let of_json j =
      {
        product_code_id =
          (Util.option_map (Json.lookup j "product_code_id") String.of_json);
        product_code_type =
          (Util.option_map (Json.lookup j "product_code_type")
             ProductCodeValues.of_json)
      }
  end
module Tag =
  struct
    type t = {
      key: String.t ;
      value: String.t }
    let make ~key  ~value  () = { key; value }
    let parse xml =
      Some
        {
          key =
            (Xml.required "key"
               (Util.option_bind (Xml.member "key" xml) String.parse));
          value =
            (Xml.required "value"
               (Util.option_bind (Xml.member "value" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Value", (String.to_query v.value)));
           Some (Query.Pair ("Key", (String.to_query v.key)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("value", (String.to_json v.value));
           Some ("key", (String.to_json v.key))])
    let of_json j =
      {
        key = (String.of_json (Util.of_option_exn (Json.lookup j "key")));
        value = (String.of_json (Util.of_option_exn (Json.lookup j "value")))
      }
  end
module NetworkInterfaceAssociation =
  struct
    type t =
      {
      public_ip: String.t option ;
      public_dns_name: String.t option ;
      ip_owner_id: String.t option ;
      allocation_id: String.t option ;
      association_id: String.t option }
    let make ?public_ip  ?public_dns_name  ?ip_owner_id  ?allocation_id 
      ?association_id  () =
      {
        public_ip;
        public_dns_name;
        ip_owner_id;
        allocation_id;
        association_id
      }
    let parse xml =
      Some
        {
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse);
          public_dns_name =
            (Util.option_bind (Xml.member "publicDnsName" xml) String.parse);
          ip_owner_id =
            (Util.option_bind (Xml.member "ipOwnerId" xml) String.parse);
          allocation_id =
            (Util.option_bind (Xml.member "allocationId" xml) String.parse);
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.association_id
              (fun f -> Query.Pair ("AssociationId", (String.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)));
           Util.option_map v.ip_owner_id
             (fun f -> Query.Pair ("IpOwnerId", (String.to_query f)));
           Util.option_map v.public_dns_name
             (fun f -> Query.Pair ("PublicDnsName", (String.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("PublicIp", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_id
              (fun f -> ("association_id", (String.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)));
           Util.option_map v.ip_owner_id
             (fun f -> ("ip_owner_id", (String.to_json f)));
           Util.option_map v.public_dns_name
             (fun f -> ("public_dns_name", (String.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)))])
    let of_json j =
      {
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json);
        public_dns_name =
          (Util.option_map (Json.lookup j "public_dns_name") String.of_json);
        ip_owner_id =
          (Util.option_map (Json.lookup j "ip_owner_id") String.of_json);
        allocation_id =
          (Util.option_map (Json.lookup j "allocation_id") String.of_json);
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json)
      }
  end
module DhcpConfigurationValueList =
  struct
    type t = AttributeValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AttributeValue.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list AttributeValue.to_query v
    let to_json v = `List (List.map AttributeValue.to_json v)
    let of_json j = Json.to_list AttributeValue.of_json j
  end
module ReservedInstancesConfiguration =
  struct
    type t =
      {
      availability_zone: String.t option ;
      platform: String.t option ;
      instance_count: Integer.t option ;
      instance_type: InstanceType.t option }
    let make ?availability_zone  ?platform  ?instance_count  ?instance_type 
      () = { availability_zone; platform; instance_count; instance_type }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml) String.parse);
          instance_count =
            (Util.option_bind (Xml.member "instanceCount" xml) Integer.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_type
              (fun f ->
                 Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_type
              (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        platform =
          (Util.option_map (Json.lookup j "platform") String.of_json);
        instance_count =
          (Util.option_map (Json.lookup j "instance_count") Integer.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json)
      }
  end
module RecurringChargeFrequency =
  struct
    type t =
      | Hourly 
    let str_to_t = [("Hourly", Hourly)]
    let t_to_str = [(Hourly, "Hourly")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ImportInstanceVolumeDetailItem =
  struct
    type t =
      {
      bytes_converted: Long.t ;
      availability_zone: String.t ;
      image: DiskImageDescription.t ;
      volume: DiskImageVolumeDescription.t ;
      status: String.t ;
      status_message: String.t option ;
      description: String.t option }
    let make ~bytes_converted  ~availability_zone  ~image  ~volume  ~status 
      ?status_message  ?description  () =
      {
        bytes_converted;
        availability_zone;
        image;
        volume;
        status;
        status_message;
        description
      }
    let parse xml =
      Some
        {
          bytes_converted =
            (Xml.required "bytesConverted"
               (Util.option_bind (Xml.member "bytesConverted" xml) Long.parse));
          availability_zone =
            (Xml.required "availabilityZone"
               (Util.option_bind (Xml.member "availabilityZone" xml)
                  String.parse));
          image =
            (Xml.required "image"
               (Util.option_bind (Xml.member "image" xml)
                  DiskImageDescription.parse));
          volume =
            (Xml.required "volume"
               (Util.option_bind (Xml.member "volume" xml)
                  DiskImageVolumeDescription.parse));
          status =
            (Xml.required "status"
               (Util.option_bind (Xml.member "status" xml) String.parse));
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Some (Query.Pair ("Status", (String.to_query v.status)));
           Some
             (Query.Pair
                ("Volume", (DiskImageVolumeDescription.to_query v.volume)));
           Some
             (Query.Pair ("Image", (DiskImageDescription.to_query v.image)));
           Some
             (Query.Pair
                ("AvailabilityZone", (String.to_query v.availability_zone)));
           Some
             (Query.Pair
                ("BytesConverted", (Long.to_query v.bytes_converted)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (String.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Some ("status", (String.to_json v.status));
           Some ("volume", (DiskImageVolumeDescription.to_json v.volume));
           Some ("image", (DiskImageDescription.to_json v.image));
           Some ("availability_zone", (String.to_json v.availability_zone));
           Some ("bytes_converted", (Long.to_json v.bytes_converted))])
    let of_json j =
      {
        bytes_converted =
          (Long.of_json
             (Util.of_option_exn (Json.lookup j "bytes_converted")));
        availability_zone =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "availability_zone")));
        image =
          (DiskImageDescription.of_json
             (Util.of_option_exn (Json.lookup j "image")));
        volume =
          (DiskImageVolumeDescription.of_json
             (Util.of_option_exn (Json.lookup j "volume")));
        status =
          (String.of_json (Util.of_option_exn (Json.lookup j "status")));
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json)
      }
  end
module RouteOrigin =
  struct
    type t =
      | CreateRouteTable 
      | CreateRoute 
      | EnableVgwRoutePropagation 
    let str_to_t =
      [("EnableVgwRoutePropagation", EnableVgwRoutePropagation);
      ("CreateRoute", CreateRoute);
      ("CreateRouteTable", CreateRouteTable)]
    let t_to_str =
      [(EnableVgwRoutePropagation, "EnableVgwRoutePropagation");
      (CreateRoute, "CreateRoute");
      (CreateRouteTable, "CreateRouteTable")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module RouteState =
  struct
    type t =
      | Active 
      | Blackhole 
    let str_to_t = [("blackhole", Blackhole); ("active", Active)]
    let t_to_str = [(Blackhole, "blackhole"); (Active, "active")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ListingState =
  struct
    type t =
      | Available 
      | Sold 
      | Cancelled 
      | Pending 
    let str_to_t =
      [("pending", Pending);
      ("cancelled", Cancelled);
      ("sold", Sold);
      ("available", Available)]
    let t_to_str =
      [(Pending, "pending");
      (Cancelled, "cancelled");
      (Sold, "sold");
      (Available, "available")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CurrencyCodeValues =
  struct
    type t =
      | USD 
    let str_to_t = [("USD", USD)]
    let t_to_str = [(USD, "USD")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module EventCode =
  struct
    type t =
      | Instance_reboot 
      | System_reboot 
      | System_maintenance 
      | Instance_retirement 
      | Instance_stop 
    let str_to_t =
      [("instance-stop", Instance_stop);
      ("instance-retirement", Instance_retirement);
      ("system-maintenance", System_maintenance);
      ("system-reboot", System_reboot);
      ("instance-reboot", Instance_reboot)]
    let t_to_str =
      [(Instance_stop, "instance-stop");
      (Instance_retirement, "instance-retirement");
      (System_maintenance, "system-maintenance");
      (System_reboot, "system-reboot");
      (Instance_reboot, "instance-reboot")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceStatusDetails =
  struct
    type t =
      {
      name: StatusName.t option ;
      status: StatusType.t option ;
      impaired_since: DateTime.t option }
    let make ?name  ?status  ?impaired_since  () =
      { name; status; impaired_since }
    let parse xml =
      Some
        {
          name = (Util.option_bind (Xml.member "name" xml) StatusName.parse);
          status =
            (Util.option_bind (Xml.member "status" xml) StatusType.parse);
          impaired_since =
            (Util.option_bind (Xml.member "impairedSince" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.impaired_since
              (fun f -> Query.Pair ("ImpairedSince", (DateTime.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (StatusType.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (StatusName.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.impaired_since
              (fun f -> ("impaired_since", (DateTime.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (StatusType.to_json f)));
           Util.option_map v.name (fun f -> ("name", (StatusName.to_json f)))])
    let of_json j =
      {
        name = (Util.option_map (Json.lookup j "name") StatusName.of_json);
        status =
          (Util.option_map (Json.lookup j "status") StatusType.of_json);
        impaired_since =
          (Util.option_map (Json.lookup j "impaired_since") DateTime.of_json)
      }
  end
module IpRangeList =
  struct
    type t = IpRange.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map IpRange.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list IpRange.to_query v
    let to_json v = `List (List.map IpRange.to_json v)
    let of_json j = Json.to_list IpRange.of_json j
  end
module PrefixListIdList =
  struct
    type t = PrefixListId.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map PrefixListId.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PrefixListId.to_query v
    let to_json v = `List (List.map PrefixListId.to_json v)
    let of_json j = Json.to_list PrefixListId.of_json j
  end
module UserIdGroupPairList =
  struct
    type t = UserIdGroupPair.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map UserIdGroupPair.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list UserIdGroupPair.to_query v
    let to_json v = `List (List.map UserIdGroupPair.to_json v)
    let of_json j = Json.to_list UserIdGroupPair.of_json j
  end
module SpotFleetLaunchSpecification =
  struct
    type t =
      {
      image_id: String.t option ;
      key_name: String.t option ;
      security_groups: GroupIdentifierList.t ;
      user_data: String.t option ;
      addressing_type: String.t option ;
      instance_type: InstanceType.t option ;
      placement: SpotPlacement.t option ;
      kernel_id: String.t option ;
      ramdisk_id: String.t option ;
      block_device_mappings: BlockDeviceMappingList.t ;
      monitoring: SpotFleetMonitoring.t option ;
      subnet_id: String.t option ;
      network_interfaces: InstanceNetworkInterfaceSpecificationList.t ;
      iam_instance_profile: IamInstanceProfileSpecification.t option ;
      ebs_optimized: Boolean.t option ;
      weighted_capacity: Double.t option ;
      spot_price: String.t option }
    let make ?image_id  ?key_name  ?(security_groups= [])  ?user_data 
      ?addressing_type  ?instance_type  ?placement  ?kernel_id  ?ramdisk_id 
      ?(block_device_mappings= [])  ?monitoring  ?subnet_id 
      ?(network_interfaces= [])  ?iam_instance_profile  ?ebs_optimized 
      ?weighted_capacity  ?spot_price  () =
      {
        image_id;
        key_name;
        security_groups;
        user_data;
        addressing_type;
        instance_type;
        placement;
        kernel_id;
        ramdisk_id;
        block_device_mappings;
        monitoring;
        subnet_id;
        network_interfaces;
        iam_instance_profile;
        ebs_optimized;
        weighted_capacity;
        spot_price
      }
    let parse xml =
      Some
        {
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse);
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          user_data =
            (Util.option_bind (Xml.member "userData" xml) String.parse);
          addressing_type =
            (Util.option_bind (Xml.member "addressingType" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          placement =
            (Util.option_bind (Xml.member "placement" xml)
               SpotPlacement.parse);
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdiskId" xml) String.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  BlockDeviceMappingList.parse));
          monitoring =
            (Util.option_bind (Xml.member "monitoring" xml)
               SpotFleetMonitoring.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkInterfaceSet" xml)
                  InstanceNetworkInterfaceSpecificationList.parse));
          iam_instance_profile =
            (Util.option_bind (Xml.member "iamInstanceProfile" xml)
               IamInstanceProfileSpecification.parse);
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml) Boolean.parse);
          weighted_capacity =
            (Util.option_bind (Xml.member "weightedCapacity" xml)
               Double.parse);
          spot_price =
            (Util.option_bind (Xml.member "spotPrice" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_price
              (fun f -> Query.Pair ("SpotPrice", (String.to_query f)));
           Util.option_map v.weighted_capacity
             (fun f -> Query.Pair ("WeightedCapacity", (Double.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile",
                    (IamInstanceProfileSpecification.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceSet",
                  (InstanceNetworkInterfaceSpecificationList.to_query
                     v.network_interfaces)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.monitoring
             (fun f ->
                Query.Pair ("Monitoring", (SpotFleetMonitoring.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingList.to_query v.block_device_mappings)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Util.option_map v.placement
             (fun f -> Query.Pair ("Placement", (SpotPlacement.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.addressing_type
             (fun f -> Query.Pair ("AddressingType", (String.to_query f)));
           Util.option_map v.user_data
             (fun f -> Query.Pair ("UserData", (String.to_query f)));
           Some
             (Query.Pair
                ("GroupSet",
                  (GroupIdentifierList.to_query v.security_groups)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_price
              (fun f -> ("spot_price", (String.to_json f)));
           Util.option_map v.weighted_capacity
             (fun f -> ("weighted_capacity", (Double.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile",
                  (IamInstanceProfileSpecification.to_json f)));
           Some
             ("network_interfaces",
               (InstanceNetworkInterfaceSpecificationList.to_json
                  v.network_interfaces));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.monitoring
             (fun f -> ("monitoring", (SpotFleetMonitoring.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingList.to_json v.block_device_mappings));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Util.option_map v.placement
             (fun f -> ("placement", (SpotPlacement.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.addressing_type
             (fun f -> ("addressing_type", (String.to_json f)));
           Util.option_map v.user_data
             (fun f -> ("user_data", (String.to_json f)));
           Some
             ("security_groups",
               (GroupIdentifierList.to_json v.security_groups));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)))])
    let of_json j =
      {
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        security_groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "security_groups")));
        user_data =
          (Util.option_map (Json.lookup j "user_data") String.of_json);
        addressing_type =
          (Util.option_map (Json.lookup j "addressing_type") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        placement =
          (Util.option_map (Json.lookup j "placement") SpotPlacement.of_json);
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id") String.of_json);
        block_device_mappings =
          (BlockDeviceMappingList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        monitoring =
          (Util.option_map (Json.lookup j "monitoring")
             SpotFleetMonitoring.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        network_interfaces =
          (InstanceNetworkInterfaceSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "network_interfaces")));
        iam_instance_profile =
          (Util.option_map (Json.lookup j "iam_instance_profile")
             IamInstanceProfileSpecification.of_json);
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized") Boolean.of_json);
        weighted_capacity =
          (Util.option_map (Json.lookup j "weighted_capacity") Double.of_json);
        spot_price =
          (Util.option_map (Json.lookup j "spot_price") String.of_json)
      }
  end
module VolumeStatusDetails =
  struct
    type t = {
      name: VolumeStatusName.t option ;
      status: String.t option }
    let make ?name  ?status  () = { name; status }
    let parse xml =
      Some
        {
          name =
            (Util.option_bind (Xml.member "name" xml) VolumeStatusName.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (VolumeStatusName.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (String.to_json f)));
           Util.option_map v.name
             (fun f -> ("name", (VolumeStatusName.to_json f)))])
    let of_json j =
      {
        name =
          (Util.option_map (Json.lookup j "name") VolumeStatusName.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json)
      }
  end
module VolumeAttachmentState =
  struct
    type t =
      | Attaching 
      | Attached 
      | Detaching 
      | Detached 
    let str_to_t =
      [("detached", Detached);
      ("detaching", Detaching);
      ("attached", Attached);
      ("attaching", Attaching)]
    let t_to_str =
      [(Detached, "detached");
      (Detaching, "detaching");
      (Attached, "attached");
      (Attaching, "attaching")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TelemetryStatus =
  struct
    type t =
      | UP 
      | DOWN 
    let str_to_t = [("DOWN", DOWN); ("UP", UP)]
    let t_to_str = [(DOWN, "DOWN"); (UP, "UP")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VpnState =
  struct
    type t =
      | Pending 
      | Available 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("available", Available);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Available, "available");
      (Pending, "pending")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VpnStaticRouteSource =
  struct
    type t =
      | Static 
    let str_to_t = [("Static", Static)]
    let t_to_str = [(Static, "Static")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ArchitectureValues =
  struct
    type t =
      | I386 
      | X86_64 
    let str_to_t = [("x86_64", X86_64); ("i386", I386)]
    let t_to_str = [(X86_64, "x86_64"); (I386, "i386")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DeviceType =
  struct
    type t =
      | Ebs 
      | Instance_store 
    let str_to_t = [("instance-store", Instance_store); ("ebs", Ebs)]
    let t_to_str = [(Instance_store, "instance-store"); (Ebs, "ebs")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module HypervisorType =
  struct
    type t =
      | Ovm 
      | Xen 
    let str_to_t = [("xen", Xen); ("ovm", Ovm)]
    let t_to_str = [(Xen, "xen"); (Ovm, "ovm")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module IamInstanceProfile =
  struct
    type t = {
      arn: String.t option ;
      id: String.t option }
    let make ?arn  ?id  () = { arn; id }
    let parse xml =
      Some
        {
          arn = (Util.option_bind (Xml.member "arn" xml) String.parse);
          id = (Util.option_bind (Xml.member "id" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.id
              (fun f -> Query.Pair ("Id", (String.to_query f)));
           Util.option_map v.arn
             (fun f -> Query.Pair ("Arn", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.id (fun f -> ("id", (String.to_json f)));
           Util.option_map v.arn (fun f -> ("arn", (String.to_json f)))])
    let of_json j =
      {
        arn = (Util.option_map (Json.lookup j "arn") String.of_json);
        id = (Util.option_map (Json.lookup j "id") String.of_json)
      }
  end
module InstanceBlockDeviceMappingList =
  struct
    type t = InstanceBlockDeviceMapping.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceBlockDeviceMapping.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list InstanceBlockDeviceMapping.to_query v
    let to_json v = `List (List.map InstanceBlockDeviceMapping.to_json v)
    let of_json j = Json.to_list InstanceBlockDeviceMapping.of_json j
  end
module InstanceLifecycleType =
  struct
    type t =
      | Spot 
    let str_to_t = [("spot", Spot)]
    let t_to_str = [(Spot, "spot")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceNetworkInterfaceList =
  struct
    type t = InstanceNetworkInterface.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceNetworkInterface.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceNetworkInterface.to_query v
    let to_json v = `List (List.map InstanceNetworkInterface.to_json v)
    let of_json j = Json.to_list InstanceNetworkInterface.of_json j
  end
module InstanceState =
  struct
    type t = {
      code: Integer.t ;
      name: InstanceStateName.t }
    let make ~code  ~name  () = { code; name }
    let parse xml =
      Some
        {
          code =
            (Xml.required "code"
               (Util.option_bind (Xml.member "code" xml) Integer.parse));
          name =
            (Xml.required "name"
               (Util.option_bind (Xml.member "name" xml)
                  InstanceStateName.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Name", (InstanceStateName.to_query v.name)));
           Some (Query.Pair ("Code", (Integer.to_query v.code)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("name", (InstanceStateName.to_json v.name));
           Some ("code", (Integer.to_json v.code))])
    let of_json j =
      {
        code = (Integer.of_json (Util.of_option_exn (Json.lookup j "code")));
        name =
          (InstanceStateName.of_json
             (Util.of_option_exn (Json.lookup j "name")))
      }
  end
module Monitoring =
  struct
    type t = {
      state: MonitoringState.t option }
    let make ?state  () = { state }
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "state" xml) MonitoringState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (MonitoringState.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (MonitoringState.to_json f)))])
    let of_json j =
      {
        state =
          (Util.option_map (Json.lookup j "state") MonitoringState.of_json)
      }
  end
module Placement =
  struct
    type t =
      {
      availability_zone: String.t option ;
      group_name: String.t option ;
      tenancy: Tenancy.t option }
    let make ?availability_zone  ?group_name  ?tenancy  () =
      { availability_zone; group_name; tenancy }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          tenancy =
            (Util.option_bind (Xml.member "tenancy" xml) Tenancy.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.tenancy
              (fun f -> Query.Pair ("Tenancy", (Tenancy.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.tenancy
              (fun f -> ("tenancy", (Tenancy.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        tenancy = (Util.option_map (Json.lookup j "tenancy") Tenancy.of_json)
      }
  end
module PlatformValues =
  struct
    type t =
      | Windows 
    let str_to_t = [("Windows", Windows)]
    let t_to_str = [(Windows, "Windows")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ProductCodeList =
  struct
    type t = ProductCode.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map ProductCode.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ProductCode.to_query v
    let to_json v = `List (List.map ProductCode.to_json v)
    let of_json j = Json.to_list ProductCode.of_json j
  end
module StateReason =
  struct
    type t = {
      code: String.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module TagList =
  struct
    type t = Tag.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Tag.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Tag.to_query v
    let to_json v = `List (List.map Tag.to_json v)
    let of_json j = Json.to_list Tag.of_json j
  end
module VirtualizationType =
  struct
    type t =
      | Hvm 
      | Paravirtual 
    let str_to_t = [("paravirtual", Paravirtual); ("hvm", Hvm)]
    let t_to_str = [(Paravirtual, "paravirtual"); (Hvm, "hvm")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module IcmpTypeCode =
  struct
    type t = {
      type_: Integer.t option ;
      code: Integer.t option }
    let make ?type_  ?code  () = { type_; code }
    let parse xml =
      Some
        {
          type_ = (Util.option_bind (Xml.member "type" xml) Integer.parse);
          code = (Util.option_bind (Xml.member "code" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.code
              (fun f -> Query.Pair ("Code", (Integer.to_query f)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.code (fun f -> ("code", (Integer.to_json f)));
           Util.option_map v.type_ (fun f -> ("type_", (Integer.to_json f)))])
    let of_json j =
      {
        type_ = (Util.option_map (Json.lookup j "type_") Integer.of_json);
        code = (Util.option_map (Json.lookup j "code") Integer.of_json)
      }
  end
module PortRange =
  struct
    type t = {
      from: Integer.t option ;
      to_: Integer.t option }
    let make ?from  ?to_  () = { from; to_ }
    let parse xml =
      Some
        {
          from = (Util.option_bind (Xml.member "from" xml) Integer.parse);
          to_ = (Util.option_bind (Xml.member "to" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.to_
              (fun f -> Query.Pair ("To", (Integer.to_query f)));
           Util.option_map v.from
             (fun f -> Query.Pair ("From", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.to_ (fun f -> ("to_", (Integer.to_json f)));
           Util.option_map v.from (fun f -> ("from", (Integer.to_json f)))])
    let of_json j =
      {
        from = (Util.option_map (Json.lookup j "from") Integer.of_json);
        to_ = (Util.option_map (Json.lookup j "to_") Integer.of_json)
      }
  end
module RuleAction =
  struct
    type t =
      | Allow 
      | Deny 
    let str_to_t = [("deny", Deny); ("allow", Allow)]
    let t_to_str = [(Deny, "deny"); (Allow, "allow")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module UserBucketDetails =
  struct
    type t = {
      s3_bucket: String.t option ;
      s3_key: String.t option }
    let make ?s3_bucket  ?s3_key  () = { s3_bucket; s3_key }
    let parse xml =
      Some
        {
          s3_bucket =
            (Util.option_bind (Xml.member "s3Bucket" xml) String.parse);
          s3_key = (Util.option_bind (Xml.member "s3Key" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3_key
              (fun f -> Query.Pair ("S3Key", (String.to_query f)));
           Util.option_map v.s3_bucket
             (fun f -> Query.Pair ("S3Bucket", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_key
              (fun f -> ("s3_key", (String.to_json f)));
           Util.option_map v.s3_bucket
             (fun f -> ("s3_bucket", (String.to_json f)))])
    let of_json j =
      {
        s3_bucket =
          (Util.option_map (Json.lookup j "s3_bucket") String.of_json);
        s3_key = (Util.option_map (Json.lookup j "s3_key") String.of_json)
      }
  end
module NetworkInterfacePrivateIpAddress =
  struct
    type t =
      {
      private_ip_address: String.t option ;
      private_dns_name: String.t option ;
      primary: Boolean.t option ;
      association: NetworkInterfaceAssociation.t option }
    let make ?private_ip_address  ?private_dns_name  ?primary  ?association 
      () = { private_ip_address; private_dns_name; primary; association }
    let parse xml =
      Some
        {
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          primary =
            (Util.option_bind (Xml.member "primary" xml) Boolean.parse);
          association =
            (Util.option_bind (Xml.member "association" xml)
               NetworkInterfaceAssociation.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.association
              (fun f ->
                 Query.Pair
                   ("Association", (NetworkInterfaceAssociation.to_query f)));
           Util.option_map v.primary
             (fun f -> Query.Pair ("Primary", (Boolean.to_query f)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association
              (fun f ->
                 ("association", (NetworkInterfaceAssociation.to_json f)));
           Util.option_map v.primary
             (fun f -> ("primary", (Boolean.to_json f)));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)))])
    let of_json j =
      {
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        private_dns_name =
          (Util.option_map (Json.lookup j "private_dns_name") String.of_json);
        primary = (Util.option_map (Json.lookup j "primary") Boolean.of_json);
        association =
          (Util.option_map (Json.lookup j "association")
             NetworkInterfaceAssociation.of_json)
      }
  end
module DhcpConfiguration =
  struct
    type t = {
      key: String.t option ;
      values: DhcpConfigurationValueList.t }
    let make ?key  ?(values= [])  () = { key; values }
    let parse xml =
      Some
        {
          key = (Util.option_bind (Xml.member "key" xml) String.parse);
          values =
            (Util.of_option []
               (Util.option_bind (Xml.member "valueSet" xml)
                  DhcpConfigurationValueList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ValueSet", (DhcpConfigurationValueList.to_query v.values)));
           Util.option_map v.key
             (fun f -> Query.Pair ("Key", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("values", (DhcpConfigurationValueList.to_json v.values));
           Util.option_map v.key (fun f -> ("key", (String.to_json f)))])
    let of_json j =
      {
        key = (Util.option_map (Json.lookup j "key") String.of_json);
        values =
          (DhcpConfigurationValueList.of_json
             (Util.of_option_exn (Json.lookup j "values")))
      }
  end
module VpcAttachment =
  struct
    type t = {
      vpc_id: String.t option ;
      state: AttachmentStatus.t option }
    let make ?vpc_id  ?state  () = { vpc_id; state }
    let parse xml =
      Some
        {
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml) AttachmentStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (AttachmentStatus.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (AttachmentStatus.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)))])
    let of_json j =
      {
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state") AttachmentStatus.of_json)
      }
  end
module ReservedInstancesModificationResult =
  struct
    type t =
      {
      reserved_instances_id: String.t option ;
      target_configuration: ReservedInstancesConfiguration.t option }
    let make ?reserved_instances_id  ?target_configuration  () =
      { reserved_instances_id; target_configuration }
    let parse xml =
      Some
        {
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse);
          target_configuration =
            (Util.option_bind (Xml.member "targetConfiguration" xml)
               ReservedInstancesConfiguration.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.target_configuration
              (fun f ->
                 Query.Pair
                   ("TargetConfiguration",
                     (ReservedInstancesConfiguration.to_query f)));
           Util.option_map v.reserved_instances_id
             (fun f ->
                Query.Pair ("ReservedInstancesId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.target_configuration
              (fun f ->
                 ("target_configuration",
                   (ReservedInstancesConfiguration.to_json f)));
           Util.option_map v.reserved_instances_id
             (fun f -> ("reserved_instances_id", (String.to_json f)))])
    let of_json j =
      {
        reserved_instances_id =
          (Util.option_map (Json.lookup j "reserved_instances_id")
             String.of_json);
        target_configuration =
          (Util.option_map (Json.lookup j "target_configuration")
             ReservedInstancesConfiguration.of_json)
      }
  end
module ReservedInstancesId =
  struct
    type t = {
      reserved_instances_id: String.t option }
    let make ?reserved_instances_id  () = { reserved_instances_id }
    let parse xml =
      Some
        {
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f ->
                 Query.Pair ("ReservedInstancesId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f -> ("reserved_instances_id", (String.to_json f)))])
    let of_json j =
      {
        reserved_instances_id =
          (Util.option_map (Json.lookup j "reserved_instances_id")
             String.of_json)
      }
  end
module RecurringCharge =
  struct
    type t =
      {
      frequency: RecurringChargeFrequency.t option ;
      amount: Double.t option }
    let make ?frequency  ?amount  () = { frequency; amount }
    let parse xml =
      Some
        {
          frequency =
            (Util.option_bind (Xml.member "frequency" xml)
               RecurringChargeFrequency.parse);
          amount = (Util.option_bind (Xml.member "amount" xml) Double.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.amount
              (fun f -> Query.Pair ("Amount", (Double.to_query f)));
           Util.option_map v.frequency
             (fun f ->
                Query.Pair
                  ("Frequency", (RecurringChargeFrequency.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.amount
              (fun f -> ("amount", (Double.to_json f)));
           Util.option_map v.frequency
             (fun f -> ("frequency", (RecurringChargeFrequency.to_json f)))])
    let of_json j =
      {
        frequency =
          (Util.option_map (Json.lookup j "frequency")
             RecurringChargeFrequency.of_json);
        amount = (Util.option_map (Json.lookup j "amount") Double.of_json)
      }
  end
module PermissionGroup =
  struct
    type t =
      | All 
    let str_to_t = [("all", All)]
    let t_to_str = [(All, "all")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ImportInstanceVolumeDetailSet =
  struct
    type t = ImportInstanceVolumeDetailItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ImportInstanceVolumeDetailItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ImportInstanceVolumeDetailItem.to_query v
    let to_json v = `List (List.map ImportInstanceVolumeDetailItem.to_json v)
    let of_json j = Json.to_list ImportInstanceVolumeDetailItem.of_json j
  end
module PropagatingVgw =
  struct
    type t = {
      gateway_id: String.t option }
    let make ?gateway_id  () = { gateway_id }
    let parse xml =
      Some
        {
          gateway_id =
            (Util.option_bind (Xml.member "gatewayId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.gateway_id
              (fun f -> Query.Pair ("GatewayId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.gateway_id
              (fun f -> ("gateway_id", (String.to_json f)))])
    let of_json j =
      {
        gateway_id =
          (Util.option_map (Json.lookup j "gateway_id") String.of_json)
      }
  end
module Route =
  struct
    type t =
      {
      destination_cidr_block: String.t option ;
      destination_prefix_list_id: String.t option ;
      gateway_id: String.t option ;
      instance_id: String.t option ;
      instance_owner_id: String.t option ;
      network_interface_id: String.t option ;
      vpc_peering_connection_id: String.t option ;
      state: RouteState.t option ;
      origin: RouteOrigin.t option }
    let make ?destination_cidr_block  ?destination_prefix_list_id 
      ?gateway_id  ?instance_id  ?instance_owner_id  ?network_interface_id 
      ?vpc_peering_connection_id  ?state  ?origin  () =
      {
        destination_cidr_block;
        destination_prefix_list_id;
        gateway_id;
        instance_id;
        instance_owner_id;
        network_interface_id;
        vpc_peering_connection_id;
        state;
        origin
      }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Util.option_bind (Xml.member "destinationCidrBlock" xml)
               String.parse);
          destination_prefix_list_id =
            (Util.option_bind (Xml.member "destinationPrefixListId" xml)
               String.parse);
          gateway_id =
            (Util.option_bind (Xml.member "gatewayId" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          instance_owner_id =
            (Util.option_bind (Xml.member "instanceOwnerId" xml) String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          vpc_peering_connection_id =
            (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml) RouteState.parse);
          origin =
            (Util.option_bind (Xml.member "origin" xml) RouteOrigin.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.origin
              (fun f -> Query.Pair ("Origin", (RouteOrigin.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (RouteState.to_query f)));
           Util.option_map v.vpc_peering_connection_id
             (fun f ->
                Query.Pair ("VpcPeeringConnectionId", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.instance_owner_id
             (fun f -> Query.Pair ("InstanceOwnerId", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.gateway_id
             (fun f -> Query.Pair ("GatewayId", (String.to_query f)));
           Util.option_map v.destination_prefix_list_id
             (fun f ->
                Query.Pair ("DestinationPrefixListId", (String.to_query f)));
           Util.option_map v.destination_cidr_block
             (fun f ->
                Query.Pair ("DestinationCidrBlock", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.origin
              (fun f -> ("origin", (RouteOrigin.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (RouteState.to_json f)));
           Util.option_map v.vpc_peering_connection_id
             (fun f -> ("vpc_peering_connection_id", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.instance_owner_id
             (fun f -> ("instance_owner_id", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.gateway_id
             (fun f -> ("gateway_id", (String.to_json f)));
           Util.option_map v.destination_prefix_list_id
             (fun f -> ("destination_prefix_list_id", (String.to_json f)));
           Util.option_map v.destination_cidr_block
             (fun f -> ("destination_cidr_block", (String.to_json f)))])
    let of_json j =
      {
        destination_cidr_block =
          (Util.option_map (Json.lookup j "destination_cidr_block")
             String.of_json);
        destination_prefix_list_id =
          (Util.option_map (Json.lookup j "destination_prefix_list_id")
             String.of_json);
        gateway_id =
          (Util.option_map (Json.lookup j "gateway_id") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        instance_owner_id =
          (Util.option_map (Json.lookup j "instance_owner_id") String.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        vpc_peering_connection_id =
          (Util.option_map (Json.lookup j "vpc_peering_connection_id")
             String.of_json);
        state = (Util.option_map (Json.lookup j "state") RouteState.of_json);
        origin =
          (Util.option_map (Json.lookup j "origin") RouteOrigin.of_json)
      }
  end
module RouteTableAssociation =
  struct
    type t =
      {
      route_table_association_id: String.t option ;
      route_table_id: String.t option ;
      subnet_id: String.t option ;
      main: Boolean.t option }
    let make ?route_table_association_id  ?route_table_id  ?subnet_id  ?main 
      () = { route_table_association_id; route_table_id; subnet_id; main }
    let parse xml =
      Some
        {
          route_table_association_id =
            (Util.option_bind (Xml.member "routeTableAssociationId" xml)
               String.parse);
          route_table_id =
            (Util.option_bind (Xml.member "routeTableId" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          main = (Util.option_bind (Xml.member "main" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.main
              (fun f -> Query.Pair ("Main", (Boolean.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.route_table_id
             (fun f -> Query.Pair ("RouteTableId", (String.to_query f)));
           Util.option_map v.route_table_association_id
             (fun f ->
                Query.Pair ("RouteTableAssociationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.main (fun f -> ("main", (Boolean.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.route_table_id
             (fun f -> ("route_table_id", (String.to_json f)));
           Util.option_map v.route_table_association_id
             (fun f -> ("route_table_association_id", (String.to_json f)))])
    let of_json j =
      {
        route_table_association_id =
          (Util.option_map (Json.lookup j "route_table_association_id")
             String.of_json);
        route_table_id =
          (Util.option_map (Json.lookup j "route_table_id") String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        main = (Util.option_map (Json.lookup j "main") Boolean.of_json)
      }
  end
module InstanceCount =
  struct
    type t =
      {
      state: ListingState.t option ;
      instance_count: Integer.t option }
    let make ?state  ?instance_count  () = { state; instance_count }
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "state" xml) ListingState.parse);
          instance_count =
            (Util.option_bind (Xml.member "instanceCount" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_count
              (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (ListingState.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_count
              (fun f -> ("instance_count", (Integer.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (ListingState.to_json f)))])
    let of_json j =
      {
        state =
          (Util.option_map (Json.lookup j "state") ListingState.of_json);
        instance_count =
          (Util.option_map (Json.lookup j "instance_count") Integer.of_json)
      }
  end
module PriceSchedule =
  struct
    type t =
      {
      term: Long.t option ;
      price: Double.t option ;
      currency_code: CurrencyCodeValues.t option ;
      active: Boolean.t option }
    let make ?term  ?price  ?currency_code  ?active  () =
      { term; price; currency_code; active }
    let parse xml =
      Some
        {
          term = (Util.option_bind (Xml.member "term" xml) Long.parse);
          price = (Util.option_bind (Xml.member "price" xml) Double.parse);
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          active = (Util.option_bind (Xml.member "active" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.active
              (fun f -> Query.Pair ("Active", (Boolean.to_query f)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)));
           Util.option_map v.price
             (fun f -> Query.Pair ("Price", (Double.to_query f)));
           Util.option_map v.term
             (fun f -> Query.Pair ("Term", (Long.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.active
              (fun f -> ("active", (Boolean.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)));
           Util.option_map v.price (fun f -> ("price", (Double.to_json f)));
           Util.option_map v.term (fun f -> ("term", (Long.to_json f)))])
    let of_json j =
      {
        term = (Util.option_map (Json.lookup j "term") Long.of_json);
        price = (Util.option_map (Json.lookup j "price") Double.of_json);
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json);
        active = (Util.option_map (Json.lookup j "active") Boolean.of_json)
      }
  end
module InstanceStatusEvent =
  struct
    type t =
      {
      code: EventCode.t option ;
      description: String.t option ;
      not_before: DateTime.t option ;
      not_after: DateTime.t option }
    let make ?code  ?description  ?not_before  ?not_after  () =
      { code; description; not_before; not_after }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) EventCode.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          not_before =
            (Util.option_bind (Xml.member "notBefore" xml) DateTime.parse);
          not_after =
            (Util.option_bind (Xml.member "notAfter" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.not_after
              (fun f -> Query.Pair ("NotAfter", (DateTime.to_query f)));
           Util.option_map v.not_before
             (fun f -> Query.Pair ("NotBefore", (DateTime.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (EventCode.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.not_after
              (fun f -> ("not_after", (DateTime.to_json f)));
           Util.option_map v.not_before
             (fun f -> ("not_before", (DateTime.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (EventCode.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") EventCode.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        not_before =
          (Util.option_map (Json.lookup j "not_before") DateTime.of_json);
        not_after =
          (Util.option_map (Json.lookup j "not_after") DateTime.of_json)
      }
  end
module InstanceStatusDetailsList =
  struct
    type t = InstanceStatusDetails.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceStatusDetails.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceStatusDetails.to_query v
    let to_json v = `List (List.map InstanceStatusDetails.to_json v)
    let of_json j = Json.to_list InstanceStatusDetails.of_json j
  end
module SummaryStatus =
  struct
    type t =
      | Ok 
      | Impaired 
      | Insufficient_data 
      | Not_applicable 
      | Initializing 
    let str_to_t =
      [("initializing", Initializing);
      ("not-applicable", Not_applicable);
      ("insufficient-data", Insufficient_data);
      ("impaired", Impaired);
      ("ok", Ok)]
    let t_to_str =
      [(Initializing, "initializing");
      (Not_applicable, "not-applicable");
      (Insufficient_data, "insufficient-data");
      (Impaired, "impaired");
      (Ok, "ok")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module RunInstancesMonitoringEnabled =
  struct
    type t = {
      enabled: Boolean.t }
    let make ~enabled  () = { enabled }
    let parse xml =
      Some
        {
          enabled =
            (Xml.required "enabled"
               (Util.option_bind (Xml.member "enabled" xml) Boolean.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Enabled", (Boolean.to_query v.enabled)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt [Some ("enabled", (Boolean.to_json v.enabled))])
    let of_json j =
      {
        enabled =
          (Boolean.of_json (Util.of_option_exn (Json.lookup j "enabled")))
      }
  end
module ContainerFormat =
  struct
    type t =
      | Ova 
    let str_to_t = [("ova", Ova)]
    let t_to_str = [(Ova, "ova")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ExportEnvironment =
  struct
    type t =
      | Citrix 
      | Vmware 
      | Microsoft 
    let str_to_t =
      [("microsoft", Microsoft); ("vmware", Vmware); ("citrix", Citrix)]
    let t_to_str =
      [(Microsoft, "microsoft"); (Vmware, "vmware"); (Citrix, "citrix")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module IpPermission =
  struct
    type t =
      {
      ip_protocol: String.t ;
      from_port: Integer.t option ;
      to_port: Integer.t option ;
      user_id_group_pairs: UserIdGroupPairList.t ;
      ip_ranges: IpRangeList.t ;
      prefix_list_ids: PrefixListIdList.t }
    let make ~ip_protocol  ?from_port  ?to_port  ?(user_id_group_pairs= []) 
      ?(ip_ranges= [])  ?(prefix_list_ids= [])  () =
      {
        ip_protocol;
        from_port;
        to_port;
        user_id_group_pairs;
        ip_ranges;
        prefix_list_ids
      }
    let parse xml =
      Some
        {
          ip_protocol =
            (Xml.required "ipProtocol"
               (Util.option_bind (Xml.member "ipProtocol" xml) String.parse));
          from_port =
            (Util.option_bind (Xml.member "fromPort" xml) Integer.parse);
          to_port =
            (Util.option_bind (Xml.member "toPort" xml) Integer.parse);
          user_id_group_pairs =
            (Util.of_option []
               (Util.option_bind (Xml.member "groups" xml)
                  UserIdGroupPairList.parse));
          ip_ranges =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipRanges" xml)
                  IpRangeList.parse));
          prefix_list_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "prefixListIds" xml)
                  PrefixListIdList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PrefixListIds",
                   (PrefixListIdList.to_query v.prefix_list_ids)));
           Some (Query.Pair ("IpRanges", (IpRangeList.to_query v.ip_ranges)));
           Some
             (Query.Pair
                ("Groups",
                  (UserIdGroupPairList.to_query v.user_id_group_pairs)));
           Util.option_map v.to_port
             (fun f -> Query.Pair ("ToPort", (Integer.to_query f)));
           Util.option_map v.from_port
             (fun f -> Query.Pair ("FromPort", (Integer.to_query f)));
           Some (Query.Pair ("IpProtocol", (String.to_query v.ip_protocol)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("prefix_list_ids",
                (PrefixListIdList.to_json v.prefix_list_ids));
           Some ("ip_ranges", (IpRangeList.to_json v.ip_ranges));
           Some
             ("user_id_group_pairs",
               (UserIdGroupPairList.to_json v.user_id_group_pairs));
           Util.option_map v.to_port
             (fun f -> ("to_port", (Integer.to_json f)));
           Util.option_map v.from_port
             (fun f -> ("from_port", (Integer.to_json f)));
           Some ("ip_protocol", (String.to_json v.ip_protocol))])
    let of_json j =
      {
        ip_protocol =
          (String.of_json (Util.of_option_exn (Json.lookup j "ip_protocol")));
        from_port =
          (Util.option_map (Json.lookup j "from_port") Integer.of_json);
        to_port = (Util.option_map (Json.lookup j "to_port") Integer.of_json);
        user_id_group_pairs =
          (UserIdGroupPairList.of_json
             (Util.of_option_exn (Json.lookup j "user_id_group_pairs")));
        ip_ranges =
          (IpRangeList.of_json
             (Util.of_option_exn (Json.lookup j "ip_ranges")));
        prefix_list_ids =
          (PrefixListIdList.of_json
             (Util.of_option_exn (Json.lookup j "prefix_list_ids")))
      }
  end
module InternetGatewayAttachment =
  struct
    type t = {
      vpc_id: String.t ;
      state: AttachmentStatus.t }
    let make ~vpc_id  ~state  () = { vpc_id; state }
    let parse xml =
      Some
        {
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse));
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml)
                  AttachmentStatus.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("State", (AttachmentStatus.to_query v.state)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("state", (AttachmentStatus.to_json v.state));
           Some ("vpc_id", (String.to_json v.vpc_id))])
    let of_json j =
      {
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        state =
          (AttachmentStatus.of_json
             (Util.of_option_exn (Json.lookup j "state")))
      }
  end
module LaunchSpecsList =
  struct
    type t = SpotFleetLaunchSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SpotFleetLaunchSpecification.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list SpotFleetLaunchSpecification.to_query v
    let to_json v = `List (List.map SpotFleetLaunchSpecification.to_json v)
    let of_json j = Json.to_list SpotFleetLaunchSpecification.of_json j
  end
module AvailabilityZoneMessage =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module S3Storage =
  struct
    type t =
      {
      bucket: String.t option ;
      prefix: String.t option ;
      a_w_s_access_key_id: String.t option ;
      upload_policy: Blob.t option ;
      upload_policy_signature: String.t option }
    let make ?bucket  ?prefix  ?a_w_s_access_key_id  ?upload_policy 
      ?upload_policy_signature  () =
      {
        bucket;
        prefix;
        a_w_s_access_key_id;
        upload_policy;
        upload_policy_signature
      }
    let parse xml =
      Some
        {
          bucket = (Util.option_bind (Xml.member "bucket" xml) String.parse);
          prefix = (Util.option_bind (Xml.member "prefix" xml) String.parse);
          a_w_s_access_key_id =
            (Util.option_bind (Xml.member "AWSAccessKeyId" xml) String.parse);
          upload_policy =
            (Util.option_bind (Xml.member "uploadPolicy" xml) Blob.parse);
          upload_policy_signature =
            (Util.option_bind (Xml.member "uploadPolicySignature" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.upload_policy_signature
              (fun f ->
                 Query.Pair ("UploadPolicySignature", (String.to_query f)));
           Util.option_map v.upload_policy
             (fun f -> Query.Pair ("UploadPolicy", (Blob.to_query f)));
           Util.option_map v.a_w_s_access_key_id
             (fun f -> Query.Pair ("AWSAccessKeyId", (String.to_query f)));
           Util.option_map v.prefix
             (fun f -> Query.Pair ("Prefix", (String.to_query f)));
           Util.option_map v.bucket
             (fun f -> Query.Pair ("Bucket", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.upload_policy_signature
              (fun f -> ("upload_policy_signature", (String.to_json f)));
           Util.option_map v.upload_policy
             (fun f -> ("upload_policy", (Blob.to_json f)));
           Util.option_map v.a_w_s_access_key_id
             (fun f -> ("a_w_s_access_key_id", (String.to_json f)));
           Util.option_map v.prefix (fun f -> ("prefix", (String.to_json f)));
           Util.option_map v.bucket (fun f -> ("bucket", (String.to_json f)))])
    let of_json j =
      {
        bucket = (Util.option_map (Json.lookup j "bucket") String.of_json);
        prefix = (Util.option_map (Json.lookup j "prefix") String.of_json);
        a_w_s_access_key_id =
          (Util.option_map (Json.lookup j "a_w_s_access_key_id")
             String.of_json);
        upload_policy =
          (Util.option_map (Json.lookup j "upload_policy") Blob.of_json);
        upload_policy_signature =
          (Util.option_map (Json.lookup j "upload_policy_signature")
             String.of_json)
      }
  end
module VolumeStatusAction =
  struct
    type t =
      {
      code: String.t option ;
      description: String.t option ;
      event_type: String.t option ;
      event_id: String.t option }
    let make ?code  ?description  ?event_type  ?event_id  () =
      { code; description; event_type; event_id }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          event_type =
            (Util.option_bind (Xml.member "eventType" xml) String.parse);
          event_id =
            (Util.option_bind (Xml.member "eventId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.event_id
              (fun f -> Query.Pair ("EventId", (String.to_query f)));
           Util.option_map v.event_type
             (fun f -> Query.Pair ("EventType", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.event_id
              (fun f -> ("event_id", (String.to_json f)));
           Util.option_map v.event_type
             (fun f -> ("event_type", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        event_type =
          (Util.option_map (Json.lookup j "event_type") String.of_json);
        event_id =
          (Util.option_map (Json.lookup j "event_id") String.of_json)
      }
  end
module VolumeStatusEvent =
  struct
    type t =
      {
      event_type: String.t option ;
      description: String.t option ;
      not_before: DateTime.t option ;
      not_after: DateTime.t option ;
      event_id: String.t option }
    let make ?event_type  ?description  ?not_before  ?not_after  ?event_id 
      () = { event_type; description; not_before; not_after; event_id }
    let parse xml =
      Some
        {
          event_type =
            (Util.option_bind (Xml.member "eventType" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          not_before =
            (Util.option_bind (Xml.member "notBefore" xml) DateTime.parse);
          not_after =
            (Util.option_bind (Xml.member "notAfter" xml) DateTime.parse);
          event_id =
            (Util.option_bind (Xml.member "eventId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.event_id
              (fun f -> Query.Pair ("EventId", (String.to_query f)));
           Util.option_map v.not_after
             (fun f -> Query.Pair ("NotAfter", (DateTime.to_query f)));
           Util.option_map v.not_before
             (fun f -> Query.Pair ("NotBefore", (DateTime.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.event_type
             (fun f -> Query.Pair ("EventType", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.event_id
              (fun f -> ("event_id", (String.to_json f)));
           Util.option_map v.not_after
             (fun f -> ("not_after", (DateTime.to_json f)));
           Util.option_map v.not_before
             (fun f -> ("not_before", (DateTime.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.event_type
             (fun f -> ("event_type", (String.to_json f)))])
    let of_json j =
      {
        event_type =
          (Util.option_map (Json.lookup j "event_type") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        not_before =
          (Util.option_map (Json.lookup j "not_before") DateTime.of_json);
        not_after =
          (Util.option_map (Json.lookup j "not_after") DateTime.of_json);
        event_id =
          (Util.option_map (Json.lookup j "event_id") String.of_json)
      }
  end
module VolumeStatusDetailsList =
  struct
    type t = VolumeStatusDetails.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VolumeStatusDetails.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VolumeStatusDetails.to_query v
    let to_json v = `List (List.map VolumeStatusDetails.to_json v)
    let of_json j = Json.to_list VolumeStatusDetails.of_json j
  end
module VolumeStatusInfoStatus =
  struct
    type t =
      | Ok 
      | Impaired 
      | Insufficient_data 
    let str_to_t =
      [("insufficient-data", Insufficient_data);
      ("impaired", Impaired);
      ("ok", Ok)]
    let t_to_str =
      [(Insufficient_data, "insufficient-data");
      (Impaired, "impaired");
      (Ok, "ok")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VolumeAttachment =
  struct
    type t =
      {
      volume_id: String.t option ;
      instance_id: String.t option ;
      device: String.t option ;
      state: VolumeAttachmentState.t option ;
      attach_time: DateTime.t option ;
      delete_on_termination: Boolean.t option }
    let make ?volume_id  ?instance_id  ?device  ?state  ?attach_time 
      ?delete_on_termination  () =
      {
        volume_id;
        instance_id;
        device;
        state;
        attach_time;
        delete_on_termination
      }
    let parse xml =
      Some
        {
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          device = (Util.option_bind (Xml.member "device" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "status" xml)
               VolumeAttachmentState.parse);
          attach_time =
            (Util.option_bind (Xml.member "attachTime" xml) DateTime.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.delete_on_termination
              (fun f ->
                 Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.attach_time
             (fun f -> Query.Pair ("AttachTime", (DateTime.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("Status", (VolumeAttachmentState.to_query f)));
           Util.option_map v.device
             (fun f -> Query.Pair ("Device", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.volume_id
             (fun f -> Query.Pair ("VolumeId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.delete_on_termination
              (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.attach_time
             (fun f -> ("attach_time", (DateTime.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (VolumeAttachmentState.to_json f)));
           Util.option_map v.device (fun f -> ("device", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.volume_id
             (fun f -> ("volume_id", (String.to_json f)))])
    let of_json j =
      {
        volume_id =
          (Util.option_map (Json.lookup j "volume_id") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        device = (Util.option_map (Json.lookup j "device") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             VolumeAttachmentState.of_json);
        attach_time =
          (Util.option_map (Json.lookup j "attach_time") DateTime.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json)
      }
  end
module VgwTelemetry =
  struct
    type t =
      {
      outside_ip_address: String.t option ;
      status: TelemetryStatus.t option ;
      last_status_change: DateTime.t option ;
      status_message: String.t option ;
      accepted_route_count: Integer.t option }
    let make ?outside_ip_address  ?status  ?last_status_change 
      ?status_message  ?accepted_route_count  () =
      {
        outside_ip_address;
        status;
        last_status_change;
        status_message;
        accepted_route_count
      }
    let parse xml =
      Some
        {
          outside_ip_address =
            (Util.option_bind (Xml.member "outsideIpAddress" xml)
               String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml) TelemetryStatus.parse);
          last_status_change =
            (Util.option_bind (Xml.member "lastStatusChange" xml)
               DateTime.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          accepted_route_count =
            (Util.option_bind (Xml.member "acceptedRouteCount" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.accepted_route_count
              (fun f ->
                 Query.Pair ("AcceptedRouteCount", (Integer.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.last_status_change
             (fun f -> Query.Pair ("LastStatusChange", (DateTime.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (TelemetryStatus.to_query f)));
           Util.option_map v.outside_ip_address
             (fun f -> Query.Pair ("OutsideIpAddress", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.accepted_route_count
              (fun f -> ("accepted_route_count", (Integer.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.last_status_change
             (fun f -> ("last_status_change", (DateTime.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (TelemetryStatus.to_json f)));
           Util.option_map v.outside_ip_address
             (fun f -> ("outside_ip_address", (String.to_json f)))])
    let of_json j =
      {
        outside_ip_address =
          (Util.option_map (Json.lookup j "outside_ip_address")
             String.of_json);
        status =
          (Util.option_map (Json.lookup j "status") TelemetryStatus.of_json);
        last_status_change =
          (Util.option_map (Json.lookup j "last_status_change")
             DateTime.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        accepted_route_count =
          (Util.option_map (Json.lookup j "accepted_route_count")
             Integer.of_json)
      }
  end
module VpnStaticRoute =
  struct
    type t =
      {
      destination_cidr_block: String.t option ;
      source: VpnStaticRouteSource.t option ;
      state: VpnState.t option }
    let make ?destination_cidr_block  ?source  ?state  () =
      { destination_cidr_block; source; state }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Util.option_bind (Xml.member "destinationCidrBlock" xml)
               String.parse);
          source =
            (Util.option_bind (Xml.member "source" xml)
               VpnStaticRouteSource.parse);
          state = (Util.option_bind (Xml.member "state" xml) VpnState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (VpnState.to_query f)));
           Util.option_map v.source
             (fun f ->
                Query.Pair ("Source", (VpnStaticRouteSource.to_query f)));
           Util.option_map v.destination_cidr_block
             (fun f ->
                Query.Pair ("DestinationCidrBlock", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (VpnState.to_json f)));
           Util.option_map v.source
             (fun f -> ("source", (VpnStaticRouteSource.to_json f)));
           Util.option_map v.destination_cidr_block
             (fun f -> ("destination_cidr_block", (String.to_json f)))])
    let of_json j =
      {
        destination_cidr_block =
          (Util.option_map (Json.lookup j "destination_cidr_block")
             String.of_json);
        source =
          (Util.option_map (Json.lookup j "source")
             VpnStaticRouteSource.of_json);
        state = (Util.option_map (Json.lookup j "state") VpnState.of_json)
      }
  end
module PricingDetail =
  struct
    type t = {
      price: Double.t option ;
      count: Integer.t option }
    let make ?price  ?count  () = { price; count }
    let parse xml =
      Some
        {
          price = (Util.option_bind (Xml.member "price" xml) Double.parse);
          count = (Util.option_bind (Xml.member "count" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.count
              (fun f -> Query.Pair ("Count", (Integer.to_query f)));
           Util.option_map v.price
             (fun f -> Query.Pair ("Price", (Double.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.count (fun f -> ("count", (Integer.to_json f)));
           Util.option_map v.price (fun f -> ("price", (Double.to_json f)))])
    let of_json j =
      {
        price = (Util.option_map (Json.lookup j "price") Double.of_json);
        count = (Util.option_map (Json.lookup j "count") Integer.of_json)
      }
  end
module Instance =
  struct
    type t =
      {
      instance_id: String.t ;
      image_id: String.t ;
      state: InstanceState.t ;
      private_dns_name: String.t option ;
      public_dns_name: String.t option ;
      state_transition_reason: String.t option ;
      key_name: String.t option ;
      ami_launch_index: Integer.t ;
      product_codes: ProductCodeList.t ;
      instance_type: InstanceType.t ;
      launch_time: DateTime.t ;
      placement: Placement.t ;
      kernel_id: String.t option ;
      ramdisk_id: String.t option ;
      platform: PlatformValues.t option ;
      monitoring: Monitoring.t ;
      subnet_id: String.t option ;
      vpc_id: String.t option ;
      private_ip_address: String.t option ;
      public_ip_address: String.t option ;
      state_reason: StateReason.t option ;
      architecture: ArchitectureValues.t ;
      root_device_type: DeviceType.t ;
      root_device_name: String.t option ;
      block_device_mappings: InstanceBlockDeviceMappingList.t ;
      virtualization_type: VirtualizationType.t ;
      instance_lifecycle: InstanceLifecycleType.t option ;
      spot_instance_request_id: String.t option ;
      client_token: String.t option ;
      tags: TagList.t ;
      security_groups: GroupIdentifierList.t ;
      source_dest_check: Boolean.t option ;
      hypervisor: HypervisorType.t ;
      network_interfaces: InstanceNetworkInterfaceList.t ;
      iam_instance_profile: IamInstanceProfile.t option ;
      ebs_optimized: Boolean.t option ;
      sriov_net_support: String.t option }
    let make ~instance_id  ~image_id  ~state  ?private_dns_name 
      ?public_dns_name  ?state_transition_reason  ?key_name 
      ~ami_launch_index  ?(product_codes= [])  ~instance_type  ~launch_time 
      ~placement  ?kernel_id  ?ramdisk_id  ?platform  ~monitoring  ?subnet_id
       ?vpc_id  ?private_ip_address  ?public_ip_address  ?state_reason 
      ~architecture  ~root_device_type  ?root_device_name 
      ?(block_device_mappings= [])  ~virtualization_type  ?instance_lifecycle
       ?spot_instance_request_id  ?client_token  ?(tags= []) 
      ?(security_groups= [])  ?source_dest_check  ~hypervisor 
      ?(network_interfaces= [])  ?iam_instance_profile  ?ebs_optimized 
      ?sriov_net_support  () =
      {
        instance_id;
        image_id;
        state;
        private_dns_name;
        public_dns_name;
        state_transition_reason;
        key_name;
        ami_launch_index;
        product_codes;
        instance_type;
        launch_time;
        placement;
        kernel_id;
        ramdisk_id;
        platform;
        monitoring;
        subnet_id;
        vpc_id;
        private_ip_address;
        public_ip_address;
        state_reason;
        architecture;
        root_device_type;
        root_device_name;
        block_device_mappings;
        virtualization_type;
        instance_lifecycle;
        spot_instance_request_id;
        client_token;
        tags;
        security_groups;
        source_dest_check;
        hypervisor;
        network_interfaces;
        iam_instance_profile;
        ebs_optimized;
        sriov_net_support
      }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          image_id =
            (Xml.required "imageId"
               (Util.option_bind (Xml.member "imageId" xml) String.parse));
          state =
            (Xml.required "instanceState"
               (Util.option_bind (Xml.member "instanceState" xml)
                  InstanceState.parse));
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          public_dns_name =
            (Util.option_bind (Xml.member "dnsName" xml) String.parse);
          state_transition_reason =
            (Util.option_bind (Xml.member "reason" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse);
          ami_launch_index =
            (Xml.required "amiLaunchIndex"
               (Util.option_bind (Xml.member "amiLaunchIndex" xml)
                  Integer.parse));
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse));
          instance_type =
            (Xml.required "instanceType"
               (Util.option_bind (Xml.member "instanceType" xml)
                  InstanceType.parse));
          launch_time =
            (Xml.required "launchTime"
               (Util.option_bind (Xml.member "launchTime" xml) DateTime.parse));
          placement =
            (Xml.required "placement"
               (Util.option_bind (Xml.member "placement" xml) Placement.parse));
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdiskId" xml) String.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml)
               PlatformValues.parse);
          monitoring =
            (Xml.required "monitoring"
               (Util.option_bind (Xml.member "monitoring" xml)
                  Monitoring.parse));
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          public_ip_address =
            (Util.option_bind (Xml.member "ipAddress" xml) String.parse);
          state_reason =
            (Util.option_bind (Xml.member "stateReason" xml)
               StateReason.parse);
          architecture =
            (Xml.required "architecture"
               (Util.option_bind (Xml.member "architecture" xml)
                  ArchitectureValues.parse));
          root_device_type =
            (Xml.required "rootDeviceType"
               (Util.option_bind (Xml.member "rootDeviceType" xml)
                  DeviceType.parse));
          root_device_name =
            (Util.option_bind (Xml.member "rootDeviceName" xml) String.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  InstanceBlockDeviceMappingList.parse));
          virtualization_type =
            (Xml.required "virtualizationType"
               (Util.option_bind (Xml.member "virtualizationType" xml)
                  VirtualizationType.parse));
          instance_lifecycle =
            (Util.option_bind (Xml.member "instanceLifecycle" xml)
               InstanceLifecycleType.parse);
          spot_instance_request_id =
            (Util.option_bind (Xml.member "spotInstanceRequestId" xml)
               String.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml)
               Boolean.parse);
          hypervisor =
            (Xml.required "hypervisor"
               (Util.option_bind (Xml.member "hypervisor" xml)
                  HypervisorType.parse));
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkInterfaceSet" xml)
                  InstanceNetworkInterfaceList.parse));
          iam_instance_profile =
            (Util.option_bind (Xml.member "iamInstanceProfile" xml)
               IamInstanceProfile.parse);
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml) Boolean.parse);
          sriov_net_support =
            (Util.option_bind (Xml.member "sriovNetSupport" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.sriov_net_support
              (fun f -> Query.Pair ("SriovNetSupport", (String.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile", (IamInstanceProfile.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceSet",
                  (InstanceNetworkInterfaceList.to_query v.network_interfaces)));
           Some
             (Query.Pair
                ("Hypervisor", (HypervisorType.to_query v.hypervisor)));
           Util.option_map v.source_dest_check
             (fun f -> Query.Pair ("SourceDestCheck", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("GroupSet",
                  (GroupIdentifierList.to_query v.security_groups)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.spot_instance_request_id
             (fun f ->
                Query.Pair ("SpotInstanceRequestId", (String.to_query f)));
           Util.option_map v.instance_lifecycle
             (fun f ->
                Query.Pair
                  ("InstanceLifecycle", (InstanceLifecycleType.to_query f)));
           Some
             (Query.Pair
                ("VirtualizationType",
                  (VirtualizationType.to_query v.virtualization_type)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (InstanceBlockDeviceMappingList.to_query
                     v.block_device_mappings)));
           Util.option_map v.root_device_name
             (fun f -> Query.Pair ("RootDeviceName", (String.to_query f)));
           Some
             (Query.Pair
                ("RootDeviceType", (DeviceType.to_query v.root_device_type)));
           Some
             (Query.Pair
                ("Architecture",
                  (ArchitectureValues.to_query v.architecture)));
           Util.option_map v.state_reason
             (fun f -> Query.Pair ("StateReason", (StateReason.to_query f)));
           Util.option_map v.public_ip_address
             (fun f -> Query.Pair ("IpAddress", (String.to_query f)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Some
             (Query.Pair ("Monitoring", (Monitoring.to_query v.monitoring)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (PlatformValues.to_query f)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Some (Query.Pair ("Placement", (Placement.to_query v.placement)));
           Some
             (Query.Pair ("LaunchTime", (DateTime.to_query v.launch_time)));
           Some
             (Query.Pair
                ("InstanceType", (InstanceType.to_query v.instance_type)));
           Some
             (Query.Pair
                ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Some
             (Query.Pair
                ("AmiLaunchIndex", (Integer.to_query v.ami_launch_index)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.state_transition_reason
             (fun f -> Query.Pair ("Reason", (String.to_query f)));
           Util.option_map v.public_dns_name
             (fun f -> Query.Pair ("DnsName", (String.to_query f)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Some
             (Query.Pair ("InstanceState", (InstanceState.to_query v.state)));
           Some (Query.Pair ("ImageId", (String.to_query v.image_id)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.sriov_net_support
              (fun f -> ("sriov_net_support", (String.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile", (IamInstanceProfile.to_json f)));
           Some
             ("network_interfaces",
               (InstanceNetworkInterfaceList.to_json v.network_interfaces));
           Some ("hypervisor", (HypervisorType.to_json v.hypervisor));
           Util.option_map v.source_dest_check
             (fun f -> ("source_dest_check", (Boolean.to_json f)));
           Some
             ("security_groups",
               (GroupIdentifierList.to_json v.security_groups));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.spot_instance_request_id
             (fun f -> ("spot_instance_request_id", (String.to_json f)));
           Util.option_map v.instance_lifecycle
             (fun f ->
                ("instance_lifecycle", (InstanceLifecycleType.to_json f)));
           Some
             ("virtualization_type",
               (VirtualizationType.to_json v.virtualization_type));
           Some
             ("block_device_mappings",
               (InstanceBlockDeviceMappingList.to_json
                  v.block_device_mappings));
           Util.option_map v.root_device_name
             (fun f -> ("root_device_name", (String.to_json f)));
           Some ("root_device_type", (DeviceType.to_json v.root_device_type));
           Some ("architecture", (ArchitectureValues.to_json v.architecture));
           Util.option_map v.state_reason
             (fun f -> ("state_reason", (StateReason.to_json f)));
           Util.option_map v.public_ip_address
             (fun f -> ("public_ip_address", (String.to_json f)));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Some ("monitoring", (Monitoring.to_json v.monitoring));
           Util.option_map v.platform
             (fun f -> ("platform", (PlatformValues.to_json f)));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Some ("placement", (Placement.to_json v.placement));
           Some ("launch_time", (DateTime.to_json v.launch_time));
           Some ("instance_type", (InstanceType.to_json v.instance_type));
           Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Some ("ami_launch_index", (Integer.to_json v.ami_launch_index));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.state_transition_reason
             (fun f -> ("state_transition_reason", (String.to_json f)));
           Util.option_map v.public_dns_name
             (fun f -> ("public_dns_name", (String.to_json f)));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Some ("state", (InstanceState.to_json v.state));
           Some ("image_id", (String.to_json v.image_id));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        image_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "image_id")));
        state =
          (InstanceState.of_json (Util.of_option_exn (Json.lookup j "state")));
        private_dns_name =
          (Util.option_map (Json.lookup j "private_dns_name") String.of_json);
        public_dns_name =
          (Util.option_map (Json.lookup j "public_dns_name") String.of_json);
        state_transition_reason =
          (Util.option_map (Json.lookup j "state_transition_reason")
             String.of_json);
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        ami_launch_index =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "ami_launch_index")));
        product_codes =
          (ProductCodeList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")));
        instance_type =
          (InstanceType.of_json
             (Util.of_option_exn (Json.lookup j "instance_type")));
        launch_time =
          (DateTime.of_json
             (Util.of_option_exn (Json.lookup j "launch_time")));
        placement =
          (Placement.of_json (Util.of_option_exn (Json.lookup j "placement")));
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id") String.of_json);
        platform =
          (Util.option_map (Json.lookup j "platform") PlatformValues.of_json);
        monitoring =
          (Monitoring.of_json
             (Util.of_option_exn (Json.lookup j "monitoring")));
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        public_ip_address =
          (Util.option_map (Json.lookup j "public_ip_address") String.of_json);
        state_reason =
          (Util.option_map (Json.lookup j "state_reason") StateReason.of_json);
        architecture =
          (ArchitectureValues.of_json
             (Util.of_option_exn (Json.lookup j "architecture")));
        root_device_type =
          (DeviceType.of_json
             (Util.of_option_exn (Json.lookup j "root_device_type")));
        root_device_name =
          (Util.option_map (Json.lookup j "root_device_name") String.of_json);
        block_device_mappings =
          (InstanceBlockDeviceMappingList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        virtualization_type =
          (VirtualizationType.of_json
             (Util.of_option_exn (Json.lookup j "virtualization_type")));
        instance_lifecycle =
          (Util.option_map (Json.lookup j "instance_lifecycle")
             InstanceLifecycleType.of_json);
        spot_instance_request_id =
          (Util.option_map (Json.lookup j "spot_instance_request_id")
             String.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        security_groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "security_groups")));
        source_dest_check =
          (Util.option_map (Json.lookup j "source_dest_check")
             Boolean.of_json);
        hypervisor =
          (HypervisorType.of_json
             (Util.of_option_exn (Json.lookup j "hypervisor")));
        network_interfaces =
          (InstanceNetworkInterfaceList.of_json
             (Util.of_option_exn (Json.lookup j "network_interfaces")));
        iam_instance_profile =
          (Util.option_map (Json.lookup j "iam_instance_profile")
             IamInstanceProfile.of_json);
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized") Boolean.of_json);
        sriov_net_support =
          (Util.option_map (Json.lookup j "sriov_net_support") String.of_json)
      }
  end
module VpcPeeringConnectionStateReasonCode =
  struct
    type t =
      | Initiating_request 
      | Pending_acceptance 
      | Active 
      | Deleted 
      | Rejected 
      | Failed 
      | Expired 
      | Provisioning 
      | Deleting 
    let str_to_t =
      [("deleting", Deleting);
      ("provisioning", Provisioning);
      ("expired", Expired);
      ("failed", Failed);
      ("rejected", Rejected);
      ("deleted", Deleted);
      ("active", Active);
      ("pending-acceptance", Pending_acceptance);
      ("initiating-request", Initiating_request)]
    let t_to_str =
      [(Deleting, "deleting");
      (Provisioning, "provisioning");
      (Expired, "expired");
      (Failed, "failed");
      (Rejected, "rejected");
      (Deleted, "deleted");
      (Active, "active");
      (Pending_acceptance, "pending-acceptance");
      (Initiating_request, "initiating-request")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module NetworkAclAssociation =
  struct
    type t =
      {
      network_acl_association_id: String.t option ;
      network_acl_id: String.t option ;
      subnet_id: String.t option }
    let make ?network_acl_association_id  ?network_acl_id  ?subnet_id  () =
      { network_acl_association_id; network_acl_id; subnet_id }
    let parse xml =
      Some
        {
          network_acl_association_id =
            (Util.option_bind (Xml.member "networkAclAssociationId" xml)
               String.parse);
          network_acl_id =
            (Util.option_bind (Xml.member "networkAclId" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.network_acl_id
             (fun f -> Query.Pair ("NetworkAclId", (String.to_query f)));
           Util.option_map v.network_acl_association_id
             (fun f ->
                Query.Pair ("NetworkAclAssociationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.network_acl_id
             (fun f -> ("network_acl_id", (String.to_json f)));
           Util.option_map v.network_acl_association_id
             (fun f -> ("network_acl_association_id", (String.to_json f)))])
    let of_json j =
      {
        network_acl_association_id =
          (Util.option_map (Json.lookup j "network_acl_association_id")
             String.of_json);
        network_acl_id =
          (Util.option_map (Json.lookup j "network_acl_id") String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json)
      }
  end
module NetworkAclEntry =
  struct
    type t =
      {
      rule_number: Integer.t option ;
      protocol: String.t option ;
      rule_action: RuleAction.t option ;
      egress: Boolean.t option ;
      cidr_block: String.t option ;
      icmp_type_code: IcmpTypeCode.t option ;
      port_range: PortRange.t option }
    let make ?rule_number  ?protocol  ?rule_action  ?egress  ?cidr_block 
      ?icmp_type_code  ?port_range  () =
      {
        rule_number;
        protocol;
        rule_action;
        egress;
        cidr_block;
        icmp_type_code;
        port_range
      }
    let parse xml =
      Some
        {
          rule_number =
            (Util.option_bind (Xml.member "ruleNumber" xml) Integer.parse);
          protocol =
            (Util.option_bind (Xml.member "protocol" xml) String.parse);
          rule_action =
            (Util.option_bind (Xml.member "ruleAction" xml) RuleAction.parse);
          egress = (Util.option_bind (Xml.member "egress" xml) Boolean.parse);
          cidr_block =
            (Util.option_bind (Xml.member "cidrBlock" xml) String.parse);
          icmp_type_code =
            (Util.option_bind (Xml.member "icmpTypeCode" xml)
               IcmpTypeCode.parse);
          port_range =
            (Util.option_bind (Xml.member "portRange" xml) PortRange.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.port_range
              (fun f -> Query.Pair ("PortRange", (PortRange.to_query f)));
           Util.option_map v.icmp_type_code
             (fun f -> Query.Pair ("IcmpTypeCode", (IcmpTypeCode.to_query f)));
           Util.option_map v.cidr_block
             (fun f -> Query.Pair ("CidrBlock", (String.to_query f)));
           Util.option_map v.egress
             (fun f -> Query.Pair ("Egress", (Boolean.to_query f)));
           Util.option_map v.rule_action
             (fun f -> Query.Pair ("RuleAction", (RuleAction.to_query f)));
           Util.option_map v.protocol
             (fun f -> Query.Pair ("Protocol", (String.to_query f)));
           Util.option_map v.rule_number
             (fun f -> Query.Pair ("RuleNumber", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.port_range
              (fun f -> ("port_range", (PortRange.to_json f)));
           Util.option_map v.icmp_type_code
             (fun f -> ("icmp_type_code", (IcmpTypeCode.to_json f)));
           Util.option_map v.cidr_block
             (fun f -> ("cidr_block", (String.to_json f)));
           Util.option_map v.egress
             (fun f -> ("egress", (Boolean.to_json f)));
           Util.option_map v.rule_action
             (fun f -> ("rule_action", (RuleAction.to_json f)));
           Util.option_map v.protocol
             (fun f -> ("protocol", (String.to_json f)));
           Util.option_map v.rule_number
             (fun f -> ("rule_number", (Integer.to_json f)))])
    let of_json j =
      {
        rule_number =
          (Util.option_map (Json.lookup j "rule_number") Integer.of_json);
        protocol =
          (Util.option_map (Json.lookup j "protocol") String.of_json);
        rule_action =
          (Util.option_map (Json.lookup j "rule_action") RuleAction.of_json);
        egress = (Util.option_map (Json.lookup j "egress") Boolean.of_json);
        cidr_block =
          (Util.option_map (Json.lookup j "cidr_block") String.of_json);
        icmp_type_code =
          (Util.option_map (Json.lookup j "icmp_type_code")
             IcmpTypeCode.of_json);
        port_range =
          (Util.option_map (Json.lookup j "port_range") PortRange.of_json)
      }
  end
module SnapshotDetail =
  struct
    type t =
      {
      disk_image_size: Double.t option ;
      description: String.t option ;
      format: String.t option ;
      url: String.t option ;
      user_bucket: UserBucketDetails.t option ;
      device_name: String.t option ;
      snapshot_id: String.t option ;
      progress: String.t option ;
      status_message: String.t option ;
      status: String.t option }
    let make ?disk_image_size  ?description  ?format  ?url  ?user_bucket 
      ?device_name  ?snapshot_id  ?progress  ?status_message  ?status  () =
      {
        disk_image_size;
        description;
        format;
        url;
        user_bucket;
        device_name;
        snapshot_id;
        progress;
        status_message;
        status
      }
    let parse xml =
      Some
        {
          disk_image_size =
            (Util.option_bind (Xml.member "diskImageSize" xml) Double.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          format = (Util.option_bind (Xml.member "format" xml) String.parse);
          url = (Util.option_bind (Xml.member "url" xml) String.parse);
          user_bucket =
            (Util.option_bind (Xml.member "userBucket" xml)
               UserBucketDetails.parse);
          device_name =
            (Util.option_bind (Xml.member "deviceName" xml) String.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (String.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)));
           Util.option_map v.user_bucket
             (fun f ->
                Query.Pair ("UserBucket", (UserBucketDetails.to_query f)));
           Util.option_map v.url
             (fun f -> Query.Pair ("Url", (String.to_query f)));
           Util.option_map v.format
             (fun f -> Query.Pair ("Format", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.disk_image_size
             (fun f -> Query.Pair ("DiskImageSize", (Double.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (String.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.progress
             (fun f -> ("progress", (String.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)));
           Util.option_map v.user_bucket
             (fun f -> ("user_bucket", (UserBucketDetails.to_json f)));
           Util.option_map v.url (fun f -> ("url", (String.to_json f)));
           Util.option_map v.format (fun f -> ("format", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.disk_image_size
             (fun f -> ("disk_image_size", (Double.to_json f)))])
    let of_json j =
      {
        disk_image_size =
          (Util.option_map (Json.lookup j "disk_image_size") Double.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        format = (Util.option_map (Json.lookup j "format") String.of_json);
        url = (Util.option_map (Json.lookup j "url") String.of_json);
        user_bucket =
          (Util.option_map (Json.lookup j "user_bucket")
             UserBucketDetails.of_json);
        device_name =
          (Util.option_map (Json.lookup j "device_name") String.of_json);
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        progress =
          (Util.option_map (Json.lookup j "progress") String.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json)
      }
  end
module CancelBatchErrorCode =
  struct
    type t =
      | FleetRequestIdDoesNotExist 
      | FleetRequestIdMalformed 
      | FleetRequestNotInCancellableState 
      | UnexpectedError 
    let str_to_t =
      [("unexpectedError", UnexpectedError);
      ("fleetRequestNotInCancellableState",
        FleetRequestNotInCancellableState);
      ("fleetRequestIdMalformed", FleetRequestIdMalformed);
      ("fleetRequestIdDoesNotExist", FleetRequestIdDoesNotExist)]
    let t_to_str =
      [(UnexpectedError, "unexpectedError");
      (FleetRequestNotInCancellableState,
        "fleetRequestNotInCancellableState");
      (FleetRequestIdMalformed, "fleetRequestIdMalformed");
      (FleetRequestIdDoesNotExist, "fleetRequestIdDoesNotExist")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AccountAttributeValue =
  struct
    type t = {
      attribute_value: String.t option }
    let make ?attribute_value  () = { attribute_value }
    let parse xml =
      Some
        {
          attribute_value =
            (Util.option_bind (Xml.member "attributeValue" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.attribute_value
              (fun f -> Query.Pair ("AttributeValue", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.attribute_value
              (fun f -> ("attribute_value", (String.to_json f)))])
    let of_json j =
      {
        attribute_value =
          (Util.option_map (Json.lookup j "attribute_value") String.of_json)
      }
  end
module NetworkInterfaceAttachment =
  struct
    type t =
      {
      attachment_id: String.t option ;
      instance_id: String.t option ;
      instance_owner_id: String.t option ;
      device_index: Integer.t option ;
      status: AttachmentStatus.t option ;
      attach_time: DateTime.t option ;
      delete_on_termination: Boolean.t option }
    let make ?attachment_id  ?instance_id  ?instance_owner_id  ?device_index 
      ?status  ?attach_time  ?delete_on_termination  () =
      {
        attachment_id;
        instance_id;
        instance_owner_id;
        device_index;
        status;
        attach_time;
        delete_on_termination
      }
    let parse xml =
      Some
        {
          attachment_id =
            (Util.option_bind (Xml.member "attachmentId" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          instance_owner_id =
            (Util.option_bind (Xml.member "instanceOwnerId" xml) String.parse);
          device_index =
            (Util.option_bind (Xml.member "deviceIndex" xml) Integer.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               AttachmentStatus.parse);
          attach_time =
            (Util.option_bind (Xml.member "attachTime" xml) DateTime.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.delete_on_termination
              (fun f ->
                 Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.attach_time
             (fun f -> Query.Pair ("AttachTime", (DateTime.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (AttachmentStatus.to_query f)));
           Util.option_map v.device_index
             (fun f -> Query.Pair ("DeviceIndex", (Integer.to_query f)));
           Util.option_map v.instance_owner_id
             (fun f -> Query.Pair ("InstanceOwnerId", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.attachment_id
             (fun f -> Query.Pair ("AttachmentId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.delete_on_termination
              (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.attach_time
             (fun f -> ("attach_time", (DateTime.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (AttachmentStatus.to_json f)));
           Util.option_map v.device_index
             (fun f -> ("device_index", (Integer.to_json f)));
           Util.option_map v.instance_owner_id
             (fun f -> ("instance_owner_id", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.attachment_id
             (fun f -> ("attachment_id", (String.to_json f)))])
    let of_json j =
      {
        attachment_id =
          (Util.option_map (Json.lookup j "attachment_id") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        instance_owner_id =
          (Util.option_map (Json.lookup j "instance_owner_id") String.of_json);
        device_index =
          (Util.option_map (Json.lookup j "device_index") Integer.of_json);
        status =
          (Util.option_map (Json.lookup j "status") AttachmentStatus.of_json);
        attach_time =
          (Util.option_map (Json.lookup j "attach_time") DateTime.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json)
      }
  end
module NetworkInterfacePrivateIpAddressList =
  struct
    type t = NetworkInterfacePrivateIpAddress.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map NetworkInterfacePrivateIpAddress.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list NetworkInterfacePrivateIpAddress.to_query v
    let to_json v =
      `List (List.map NetworkInterfacePrivateIpAddress.to_json v)
    let of_json j = Json.to_list NetworkInterfacePrivateIpAddress.of_json j
  end
module ResourceType =
  struct
    type t =
      | Customer_gateway 
      | Dhcp_options 
      | Image 
      | Instance 
      | Internet_gateway 
      | Network_acl 
      | Network_interface 
      | Reserved_instances 
      | Route_table 
      | Snapshot 
      | Spot_instances_request 
      | Subnet 
      | Security_group 
      | Volume 
      | Vpc 
      | Vpn_connection 
      | Vpn_gateway 
    let str_to_t =
      [("vpn-gateway", Vpn_gateway);
      ("vpn-connection", Vpn_connection);
      ("vpc", Vpc);
      ("volume", Volume);
      ("security-group", Security_group);
      ("subnet", Subnet);
      ("spot-instances-request", Spot_instances_request);
      ("snapshot", Snapshot);
      ("route-table", Route_table);
      ("reserved-instances", Reserved_instances);
      ("network-interface", Network_interface);
      ("network-acl", Network_acl);
      ("internet-gateway", Internet_gateway);
      ("instance", Instance);
      ("image", Image);
      ("dhcp-options", Dhcp_options);
      ("customer-gateway", Customer_gateway)]
    let t_to_str =
      [(Vpn_gateway, "vpn-gateway");
      (Vpn_connection, "vpn-connection");
      (Vpc, "vpc");
      (Volume, "volume");
      (Security_group, "security-group");
      (Subnet, "subnet");
      (Spot_instances_request, "spot-instances-request");
      (Snapshot, "snapshot");
      (Route_table, "route-table");
      (Reserved_instances, "reserved-instances");
      (Network_interface, "network-interface");
      (Network_acl, "network-acl");
      (Internet_gateway, "internet-gateway");
      (Instance, "instance");
      (Image, "image");
      (Dhcp_options, "dhcp-options");
      (Customer_gateway, "customer-gateway")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DhcpConfigurationList =
  struct
    type t = DhcpConfiguration.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DhcpConfiguration.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list DhcpConfiguration.to_query v
    let to_json v = `List (List.map DhcpConfiguration.to_json v)
    let of_json j = Json.to_list DhcpConfiguration.of_json j
  end
module GatewayType =
  struct
    type t =
      | Ipsec_1 
    let str_to_t = [("ipsec.1", Ipsec_1)]
    let t_to_str = [(Ipsec_1, "ipsec.1")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VpcAttachmentList =
  struct
    type t = VpcAttachment.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map VpcAttachment.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VpcAttachment.to_query v
    let to_json v = `List (List.map VpcAttachment.to_json v)
    let of_json j = Json.to_list VpcAttachment.of_json j
  end
module ReservedInstancesModificationResultList =
  struct
    type t = ReservedInstancesModificationResult.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReservedInstancesModificationResult.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ReservedInstancesModificationResult.to_query v
    let to_json v =
      `List (List.map ReservedInstancesModificationResult.to_json v)
    let of_json j =
      Json.to_list ReservedInstancesModificationResult.of_json j
  end
module ReservedIntancesIds =
  struct
    type t = ReservedInstancesId.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReservedInstancesId.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ReservedInstancesId.to_query v
    let to_json v = `List (List.map ReservedInstancesId.to_json v)
    let of_json j = Json.to_list ReservedInstancesId.of_json j
  end
module OfferingTypeValues =
  struct
    type t =
      | Heavy_Utilization 
      | Medium_Utilization 
      | Light_Utilization 
      | No_Upfront 
      | Partial_Upfront 
      | All_Upfront 
    let str_to_t =
      [("All Upfront", All_Upfront);
      ("Partial Upfront", Partial_Upfront);
      ("No Upfront", No_Upfront);
      ("Light Utilization", Light_Utilization);
      ("Medium Utilization", Medium_Utilization);
      ("Heavy Utilization", Heavy_Utilization)]
    let t_to_str =
      [(All_Upfront, "All Upfront");
      (Partial_Upfront, "Partial Upfront");
      (No_Upfront, "No Upfront");
      (Light_Utilization, "Light Utilization");
      (Medium_Utilization, "Medium Utilization");
      (Heavy_Utilization, "Heavy Utilization")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module RIProductDescription =
  struct
    type t =
      | Linux_UNIX 
      | Linux_UNIX__Amazon_VPC_ 
      | Windows 
      | Windows__Amazon_VPC_ 
    let str_to_t =
      [("Windows (Amazon VPC)", Windows__Amazon_VPC_);
      ("Windows", Windows);
      ("Linux/UNIX (Amazon VPC)", Linux_UNIX__Amazon_VPC_);
      ("Linux/UNIX", Linux_UNIX)]
    let t_to_str =
      [(Windows__Amazon_VPC_, "Windows (Amazon VPC)");
      (Windows, "Windows");
      (Linux_UNIX__Amazon_VPC_, "Linux/UNIX (Amazon VPC)");
      (Linux_UNIX, "Linux/UNIX")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module RecurringChargesList =
  struct
    type t = RecurringCharge.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map RecurringCharge.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list RecurringCharge.to_query v
    let to_json v = `List (List.map RecurringCharge.to_json v)
    let of_json j = Json.to_list RecurringCharge.of_json j
  end
module ReservedInstanceState =
  struct
    type t =
      | Payment_pending 
      | Active 
      | Payment_failed 
      | Retired 
    let str_to_t =
      [("retired", Retired);
      ("payment-failed", Payment_failed);
      ("active", Active);
      ("payment-pending", Payment_pending)]
    let t_to_str =
      [(Retired, "retired");
      (Payment_failed, "payment-failed");
      (Active, "active");
      (Payment_pending, "payment-pending")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ValueStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module PlacementGroupState =
  struct
    type t =
      | Pending 
      | Available 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("available", Available);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Available, "available");
      (Pending, "pending")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module PlacementStrategy =
  struct
    type t =
      | Cluster 
    let str_to_t = [("cluster", Cluster)]
    let t_to_str = [(Cluster, "cluster")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CancelSpotInstanceRequestState =
  struct
    type t =
      | Active 
      | Open 
      | Closed 
      | Cancelled 
      | Completed 
    let str_to_t =
      [("completed", Completed);
      ("cancelled", Cancelled);
      ("closed", Closed);
      ("open", Open);
      ("active", Active)]
    let t_to_str =
      [(Completed, "completed");
      (Cancelled, "cancelled");
      (Closed, "closed");
      (Open, "open");
      (Active, "active")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module LaunchPermission =
  struct
    type t = {
      user_id: String.t option ;
      group: PermissionGroup.t option }
    let make ?user_id  ?group  () = { user_id; group }
    let parse xml =
      Some
        {
          user_id = (Util.option_bind (Xml.member "userId" xml) String.parse);
          group =
            (Util.option_bind (Xml.member "group" xml) PermissionGroup.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group
              (fun f -> Query.Pair ("Group", (PermissionGroup.to_query f)));
           Util.option_map v.user_id
             (fun f -> Query.Pair ("UserId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group
              (fun f -> ("group", (PermissionGroup.to_json f)));
           Util.option_map v.user_id
             (fun f -> ("user_id", (String.to_json f)))])
    let of_json j =
      {
        user_id = (Util.option_map (Json.lookup j "user_id") String.of_json);
        group =
          (Util.option_map (Json.lookup j "group") PermissionGroup.of_json)
      }
  end
module ConversionTaskState =
  struct
    type t =
      | Active 
      | Cancelling 
      | Cancelled 
      | Completed 
    let str_to_t =
      [("completed", Completed);
      ("cancelled", Cancelled);
      ("cancelling", Cancelling);
      ("active", Active)]
    let t_to_str =
      [(Completed, "completed");
      (Cancelled, "cancelled");
      (Cancelling, "cancelling");
      (Active, "active")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ImportInstanceTaskDetails =
  struct
    type t =
      {
      volumes: ImportInstanceVolumeDetailSet.t ;
      instance_id: String.t option ;
      platform: PlatformValues.t option ;
      description: String.t option }
    let make ~volumes  ?instance_id  ?platform  ?description  () =
      { volumes; instance_id; platform; description }
    let parse xml =
      Some
        {
          volumes =
            (Xml.required "volumes"
               (Util.option_bind (Xml.member "volumes" xml)
                  ImportInstanceVolumeDetailSet.parse));
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml)
               PlatformValues.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (PlatformValues.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Some
             (Query.Pair
                ("Volumes",
                  (ImportInstanceVolumeDetailSet.to_query v.volumes)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (String.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (PlatformValues.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Some
             ("volumes", (ImportInstanceVolumeDetailSet.to_json v.volumes))])
    let of_json j =
      {
        volumes =
          (ImportInstanceVolumeDetailSet.of_json
             (Util.of_option_exn (Json.lookup j "volumes")));
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        platform =
          (Util.option_map (Json.lookup j "platform") PlatformValues.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json)
      }
  end
module ImportVolumeTaskDetails =
  struct
    type t =
      {
      bytes_converted: Long.t ;
      availability_zone: String.t ;
      description: String.t option ;
      image: DiskImageDescription.t ;
      volume: DiskImageVolumeDescription.t }
    let make ~bytes_converted  ~availability_zone  ?description  ~image 
      ~volume  () =
      { bytes_converted; availability_zone; description; image; volume }
    let parse xml =
      Some
        {
          bytes_converted =
            (Xml.required "bytesConverted"
               (Util.option_bind (Xml.member "bytesConverted" xml) Long.parse));
          availability_zone =
            (Xml.required "availabilityZone"
               (Util.option_bind (Xml.member "availabilityZone" xml)
                  String.parse));
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          image =
            (Xml.required "image"
               (Util.option_bind (Xml.member "image" xml)
                  DiskImageDescription.parse));
          volume =
            (Xml.required "volume"
               (Util.option_bind (Xml.member "volume" xml)
                  DiskImageVolumeDescription.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Volume", (DiskImageVolumeDescription.to_query v.volume)));
           Some
             (Query.Pair ("Image", (DiskImageDescription.to_query v.image)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some
             (Query.Pair
                ("AvailabilityZone", (String.to_query v.availability_zone)));
           Some
             (Query.Pair
                ("BytesConverted", (Long.to_query v.bytes_converted)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("volume", (DiskImageVolumeDescription.to_json v.volume));
           Some ("image", (DiskImageDescription.to_json v.image));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some ("availability_zone", (String.to_json v.availability_zone));
           Some ("bytes_converted", (Long.to_json v.bytes_converted))])
    let of_json j =
      {
        bytes_converted =
          (Long.of_json
             (Util.of_option_exn (Json.lookup j "bytes_converted")));
        availability_zone =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "availability_zone")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        image =
          (DiskImageDescription.of_json
             (Util.of_option_exn (Json.lookup j "image")));
        volume =
          (DiskImageVolumeDescription.of_json
             (Util.of_option_exn (Json.lookup j "volume")))
      }
  end
module EventInformation =
  struct
    type t =
      {
      instance_id: String.t option ;
      event_sub_type: String.t option ;
      event_description: String.t option }
    let make ?instance_id  ?event_sub_type  ?event_description  () =
      { instance_id; event_sub_type; event_description }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          event_sub_type =
            (Util.option_bind (Xml.member "eventSubType" xml) String.parse);
          event_description =
            (Util.option_bind (Xml.member "eventDescription" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.event_description
              (fun f -> Query.Pair ("EventDescription", (String.to_query f)));
           Util.option_map v.event_sub_type
             (fun f -> Query.Pair ("EventSubType", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.event_description
              (fun f -> ("event_description", (String.to_json f)));
           Util.option_map v.event_sub_type
             (fun f -> ("event_sub_type", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        event_sub_type =
          (Util.option_map (Json.lookup j "event_sub_type") String.of_json);
        event_description =
          (Util.option_map (Json.lookup j "event_description") String.of_json)
      }
  end
module EventType =
  struct
    type t =
      | InstanceChange 
      | FleetRequestChange 
      | Error 
    let str_to_t =
      [("error", Error);
      ("fleetRequestChange", FleetRequestChange);
      ("instanceChange", InstanceChange)]
    let t_to_str =
      [(Error, "error");
      (FleetRequestChange, "fleetRequestChange");
      (InstanceChange, "instanceChange")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module UnsuccessfulItemError =
  struct
    type t = {
      code: String.t ;
      message: String.t }
    let make ~code  ~message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Xml.required "code"
               (Util.option_bind (Xml.member "code" xml) String.parse));
          message =
            (Xml.required "message"
               (Util.option_bind (Xml.member "message" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Message", (String.to_query v.message)));
           Some (Query.Pair ("Code", (String.to_query v.code)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("message", (String.to_json v.message));
           Some ("code", (String.to_json v.code))])
    let of_json j =
      {
        code = (String.of_json (Util.of_option_exn (Json.lookup j "code")));
        message =
          (String.of_json (Util.of_option_exn (Json.lookup j "message")))
      }
  end
module PropagatingVgwList =
  struct
    type t = PropagatingVgw.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PropagatingVgw.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PropagatingVgw.to_query v
    let to_json v = `List (List.map PropagatingVgw.to_json v)
    let of_json j = Json.to_list PropagatingVgw.of_json j
  end
module RouteList =
  struct
    type t = Route.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Route.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Route.to_query v
    let to_json v = `List (List.map Route.to_json v)
    let of_json j = Json.to_list Route.of_json j
  end
module RouteTableAssociationList =
  struct
    type t = RouteTableAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map RouteTableAssociation.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list RouteTableAssociation.to_query v
    let to_json v = `List (List.map RouteTableAssociation.to_json v)
    let of_json j = Json.to_list RouteTableAssociation.of_json j
  end
module InstanceCountList =
  struct
    type t = InstanceCount.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map InstanceCount.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceCount.to_query v
    let to_json v = `List (List.map InstanceCount.to_json v)
    let of_json j = Json.to_list InstanceCount.of_json j
  end
module ListingStatus =
  struct
    type t =
      | Active 
      | Pending 
      | Cancelled 
      | Closed 
    let str_to_t =
      [("closed", Closed);
      ("cancelled", Cancelled);
      ("pending", Pending);
      ("active", Active)]
    let t_to_str =
      [(Closed, "closed");
      (Cancelled, "cancelled");
      (Pending, "pending");
      (Active, "active")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module PriceScheduleList =
  struct
    type t = PriceSchedule.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map PriceSchedule.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PriceSchedule.to_query v
    let to_json v = `List (List.map PriceSchedule.to_json v)
    let of_json j = Json.to_list PriceSchedule.of_json j
  end
module MoveStatus =
  struct
    type t =
      | MovingToVpc 
      | RestoringToClassic 
    let str_to_t =
      [("restoringToClassic", RestoringToClassic);
      ("movingToVpc", MovingToVpc)]
    let t_to_str =
      [(RestoringToClassic, "restoringToClassic");
      (MovingToVpc, "movingToVpc")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceStatusEventList =
  struct
    type t = InstanceStatusEvent.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceStatusEvent.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceStatusEvent.to_query v
    let to_json v = `List (List.map InstanceStatusEvent.to_json v)
    let of_json j = Json.to_list InstanceStatusEvent.of_json j
  end
module InstanceStatusSummary =
  struct
    type t = {
      status: SummaryStatus.t ;
      details: InstanceStatusDetailsList.t }
    let make ~status  ?(details= [])  () = { status; details }
    let parse xml =
      Some
        {
          status =
            (Xml.required "status"
               (Util.option_bind (Xml.member "status" xml)
                  SummaryStatus.parse));
          details =
            (Util.of_option []
               (Util.option_bind (Xml.member "details" xml)
                  InstanceStatusDetailsList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Details", (InstanceStatusDetailsList.to_query v.details)));
           Some (Query.Pair ("Status", (SummaryStatus.to_query v.status)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("details", (InstanceStatusDetailsList.to_json v.details));
           Some ("status", (SummaryStatus.to_json v.status))])
    let of_json j =
      {
        status =
          (SummaryStatus.of_json
             (Util.of_option_exn (Json.lookup j "status")));
        details =
          (InstanceStatusDetailsList.of_json
             (Util.of_option_exn (Json.lookup j "details")))
      }
  end
module ImageState =
  struct
    type t =
      | Pending 
      | Available 
      | Invalid 
      | Deregistered 
      | Transient 
      | Failed 
      | Error 
    let str_to_t =
      [("error", Error);
      ("failed", Failed);
      ("transient", Transient);
      ("deregistered", Deregistered);
      ("invalid", Invalid);
      ("available", Available);
      ("pending", Pending)]
    let t_to_str =
      [(Error, "error");
      (Failed, "failed");
      (Transient, "transient");
      (Deregistered, "deregistered");
      (Invalid, "invalid");
      (Available, "available");
      (Pending, "pending")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ImageTypeValues =
  struct
    type t =
      | Machine 
      | Kernel 
      | Ramdisk 
    let str_to_t =
      [("ramdisk", Ramdisk); ("kernel", Kernel); ("machine", Machine)]
    let t_to_str =
      [(Ramdisk, "ramdisk"); (Kernel, "kernel"); (Machine, "machine")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SnapshotTaskDetail =
  struct
    type t =
      {
      disk_image_size: Double.t option ;
      description: String.t option ;
      format: String.t option ;
      url: String.t option ;
      user_bucket: UserBucketDetails.t option ;
      snapshot_id: String.t option ;
      progress: String.t option ;
      status_message: String.t option ;
      status: String.t option }
    let make ?disk_image_size  ?description  ?format  ?url  ?user_bucket 
      ?snapshot_id  ?progress  ?status_message  ?status  () =
      {
        disk_image_size;
        description;
        format;
        url;
        user_bucket;
        snapshot_id;
        progress;
        status_message;
        status
      }
    let parse xml =
      Some
        {
          disk_image_size =
            (Util.option_bind (Xml.member "diskImageSize" xml) Double.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          format = (Util.option_bind (Xml.member "format" xml) String.parse);
          url = (Util.option_bind (Xml.member "url" xml) String.parse);
          user_bucket =
            (Util.option_bind (Xml.member "userBucket" xml)
               UserBucketDetails.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (String.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.user_bucket
             (fun f ->
                Query.Pair ("UserBucket", (UserBucketDetails.to_query f)));
           Util.option_map v.url
             (fun f -> Query.Pair ("Url", (String.to_query f)));
           Util.option_map v.format
             (fun f -> Query.Pair ("Format", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.disk_image_size
             (fun f -> Query.Pair ("DiskImageSize", (Double.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (String.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.progress
             (fun f -> ("progress", (String.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.user_bucket
             (fun f -> ("user_bucket", (UserBucketDetails.to_json f)));
           Util.option_map v.url (fun f -> ("url", (String.to_json f)));
           Util.option_map v.format (fun f -> ("format", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.disk_image_size
             (fun f -> ("disk_image_size", (Double.to_json f)))])
    let of_json j =
      {
        disk_image_size =
          (Util.option_map (Json.lookup j "disk_image_size") Double.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        format = (Util.option_map (Json.lookup j "format") String.of_json);
        url = (Util.option_map (Json.lookup j "url") String.of_json);
        user_bucket =
          (Util.option_map (Json.lookup j "user_bucket")
             UserBucketDetails.of_json);
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        progress =
          (Util.option_map (Json.lookup j "progress") String.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json)
      }
  end
module LaunchSpecification =
  struct
    type t =
      {
      image_id: String.t option ;
      key_name: String.t option ;
      security_groups: GroupIdentifierList.t ;
      user_data: String.t option ;
      addressing_type: String.t option ;
      instance_type: InstanceType.t option ;
      placement: SpotPlacement.t option ;
      kernel_id: String.t option ;
      ramdisk_id: String.t option ;
      block_device_mappings: BlockDeviceMappingList.t ;
      subnet_id: String.t option ;
      network_interfaces: InstanceNetworkInterfaceSpecificationList.t ;
      iam_instance_profile: IamInstanceProfileSpecification.t option ;
      ebs_optimized: Boolean.t option ;
      monitoring: RunInstancesMonitoringEnabled.t option }
    let make ?image_id  ?key_name  ?(security_groups= [])  ?user_data 
      ?addressing_type  ?instance_type  ?placement  ?kernel_id  ?ramdisk_id 
      ?(block_device_mappings= [])  ?subnet_id  ?(network_interfaces= []) 
      ?iam_instance_profile  ?ebs_optimized  ?monitoring  () =
      {
        image_id;
        key_name;
        security_groups;
        user_data;
        addressing_type;
        instance_type;
        placement;
        kernel_id;
        ramdisk_id;
        block_device_mappings;
        subnet_id;
        network_interfaces;
        iam_instance_profile;
        ebs_optimized;
        monitoring
      }
    let parse xml =
      Some
        {
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse);
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          user_data =
            (Util.option_bind (Xml.member "userData" xml) String.parse);
          addressing_type =
            (Util.option_bind (Xml.member "addressingType" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          placement =
            (Util.option_bind (Xml.member "placement" xml)
               SpotPlacement.parse);
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdiskId" xml) String.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  BlockDeviceMappingList.parse));
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkInterfaceSet" xml)
                  InstanceNetworkInterfaceSpecificationList.parse));
          iam_instance_profile =
            (Util.option_bind (Xml.member "iamInstanceProfile" xml)
               IamInstanceProfileSpecification.parse);
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml) Boolean.parse);
          monitoring =
            (Util.option_bind (Xml.member "monitoring" xml)
               RunInstancesMonitoringEnabled.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.monitoring
              (fun f ->
                 Query.Pair
                   ("Monitoring", (RunInstancesMonitoringEnabled.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile",
                    (IamInstanceProfileSpecification.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceSet",
                  (InstanceNetworkInterfaceSpecificationList.to_query
                     v.network_interfaces)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingList.to_query v.block_device_mappings)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Util.option_map v.placement
             (fun f -> Query.Pair ("Placement", (SpotPlacement.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.addressing_type
             (fun f -> Query.Pair ("AddressingType", (String.to_query f)));
           Util.option_map v.user_data
             (fun f -> Query.Pair ("UserData", (String.to_query f)));
           Some
             (Query.Pair
                ("GroupSet",
                  (GroupIdentifierList.to_query v.security_groups)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.monitoring
              (fun f ->
                 ("monitoring", (RunInstancesMonitoringEnabled.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile",
                  (IamInstanceProfileSpecification.to_json f)));
           Some
             ("network_interfaces",
               (InstanceNetworkInterfaceSpecificationList.to_json
                  v.network_interfaces));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingList.to_json v.block_device_mappings));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Util.option_map v.placement
             (fun f -> ("placement", (SpotPlacement.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.addressing_type
             (fun f -> ("addressing_type", (String.to_json f)));
           Util.option_map v.user_data
             (fun f -> ("user_data", (String.to_json f)));
           Some
             ("security_groups",
               (GroupIdentifierList.to_json v.security_groups));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)))])
    let of_json j =
      {
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        security_groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "security_groups")));
        user_data =
          (Util.option_map (Json.lookup j "user_data") String.of_json);
        addressing_type =
          (Util.option_map (Json.lookup j "addressing_type") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        placement =
          (Util.option_map (Json.lookup j "placement") SpotPlacement.of_json);
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id") String.of_json);
        block_device_mappings =
          (BlockDeviceMappingList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        network_interfaces =
          (InstanceNetworkInterfaceSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "network_interfaces")));
        iam_instance_profile =
          (Util.option_map (Json.lookup j "iam_instance_profile")
             IamInstanceProfileSpecification.of_json);
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized") Boolean.of_json);
        monitoring =
          (Util.option_map (Json.lookup j "monitoring")
             RunInstancesMonitoringEnabled.of_json)
      }
  end
module SpotInstanceState =
  struct
    type t =
      | Open 
      | Active 
      | Closed 
      | Cancelled 
      | Failed 
    let str_to_t =
      [("failed", Failed);
      ("cancelled", Cancelled);
      ("closed", Closed);
      ("active", Active);
      ("open", Open)]
    let t_to_str =
      [(Failed, "failed");
      (Cancelled, "cancelled");
      (Closed, "closed");
      (Active, "active");
      (Open, "open")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SpotInstanceStateFault =
  struct
    type t = {
      code: String.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module SpotInstanceStatus =
  struct
    type t =
      {
      code: String.t option ;
      update_time: DateTime.t option ;
      message: String.t option }
    let make ?code  ?update_time  ?message  () =
      { code; update_time; message }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          update_time =
            (Util.option_bind (Xml.member "updateTime" xml) DateTime.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.update_time
             (fun f -> Query.Pair ("UpdateTime", (DateTime.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.update_time
             (fun f -> ("update_time", (DateTime.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") String.of_json);
        update_time =
          (Util.option_map (Json.lookup j "update_time") DateTime.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module SpotInstanceType =
  struct
    type t =
      | One_time 
      | Persistent 
    let str_to_t = [("persistent", Persistent); ("one-time", One_time)]
    let t_to_str = [(Persistent, "persistent"); (One_time, "one-time")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ExportTaskState =
  struct
    type t =
      | Active 
      | Cancelling 
      | Cancelled 
      | Completed 
    let str_to_t =
      [("completed", Completed);
      ("cancelled", Cancelled);
      ("cancelling", Cancelling);
      ("active", Active)]
    let t_to_str =
      [(Completed, "completed");
      (Cancelled, "cancelled");
      (Cancelling, "cancelling");
      (Active, "active")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ExportToS3Task =
  struct
    type t =
      {
      disk_image_format: DiskImageFormat.t option ;
      container_format: ContainerFormat.t option ;
      s3_bucket: String.t option ;
      s3_key: String.t option }
    let make ?disk_image_format  ?container_format  ?s3_bucket  ?s3_key  () =
      { disk_image_format; container_format; s3_bucket; s3_key }
    let parse xml =
      Some
        {
          disk_image_format =
            (Util.option_bind (Xml.member "diskImageFormat" xml)
               DiskImageFormat.parse);
          container_format =
            (Util.option_bind (Xml.member "containerFormat" xml)
               ContainerFormat.parse);
          s3_bucket =
            (Util.option_bind (Xml.member "s3Bucket" xml) String.parse);
          s3_key = (Util.option_bind (Xml.member "s3Key" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3_key
              (fun f -> Query.Pair ("S3Key", (String.to_query f)));
           Util.option_map v.s3_bucket
             (fun f -> Query.Pair ("S3Bucket", (String.to_query f)));
           Util.option_map v.container_format
             (fun f ->
                Query.Pair ("ContainerFormat", (ContainerFormat.to_query f)));
           Util.option_map v.disk_image_format
             (fun f ->
                Query.Pair ("DiskImageFormat", (DiskImageFormat.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_key
              (fun f -> ("s3_key", (String.to_json f)));
           Util.option_map v.s3_bucket
             (fun f -> ("s3_bucket", (String.to_json f)));
           Util.option_map v.container_format
             (fun f -> ("container_format", (ContainerFormat.to_json f)));
           Util.option_map v.disk_image_format
             (fun f -> ("disk_image_format", (DiskImageFormat.to_json f)))])
    let of_json j =
      {
        disk_image_format =
          (Util.option_map (Json.lookup j "disk_image_format")
             DiskImageFormat.of_json);
        container_format =
          (Util.option_map (Json.lookup j "container_format")
             ContainerFormat.of_json);
        s3_bucket =
          (Util.option_map (Json.lookup j "s3_bucket") String.of_json);
        s3_key = (Util.option_map (Json.lookup j "s3_key") String.of_json)
      }
  end
module InstanceExportDetails =
  struct
    type t =
      {
      instance_id: String.t option ;
      target_environment: ExportEnvironment.t option }
    let make ?instance_id  ?target_environment  () =
      { instance_id; target_environment }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          target_environment =
            (Util.option_bind (Xml.member "targetEnvironment" xml)
               ExportEnvironment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.target_environment
              (fun f ->
                 Query.Pair
                   ("TargetEnvironment", (ExportEnvironment.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.target_environment
              (fun f -> ("target_environment", (ExportEnvironment.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        target_environment =
          (Util.option_map (Json.lookup j "target_environment")
             ExportEnvironment.of_json)
      }
  end
module IpPermissionList =
  struct
    type t = IpPermission.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map IpPermission.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list IpPermission.to_query v
    let to_json v = `List (List.map IpPermission.to_json v)
    let of_json j = Json.to_list IpPermission.of_json j
  end
module EbsInstanceBlockDeviceSpecification =
  struct
    type t =
      {
      volume_id: String.t option ;
      delete_on_termination: Boolean.t option }
    let make ?volume_id  ?delete_on_termination  () =
      { volume_id; delete_on_termination }
    let parse xml =
      Some
        {
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.delete_on_termination
              (fun f ->
                 Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.volume_id
             (fun f -> Query.Pair ("VolumeId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.delete_on_termination
              (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.volume_id
             (fun f -> ("volume_id", (String.to_json f)))])
    let of_json j =
      {
        volume_id =
          (Util.option_map (Json.lookup j "volume_id") String.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json)
      }
  end
module InternetGatewayAttachmentList =
  struct
    type t = InternetGatewayAttachment.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InternetGatewayAttachment.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InternetGatewayAttachment.to_query v
    let to_json v = `List (List.map InternetGatewayAttachment.to_json v)
    let of_json j = Json.to_list InternetGatewayAttachment.of_json j
  end
module BatchState =
  struct
    type t =
      | Submitted 
      | Active 
      | Cancelled 
      | Failed 
      | Cancelled_running 
      | Cancelled_terminating 
    let str_to_t =
      [("cancelled_terminating", Cancelled_terminating);
      ("cancelled_running", Cancelled_running);
      ("failed", Failed);
      ("cancelled", Cancelled);
      ("active", Active);
      ("submitted", Submitted)]
    let t_to_str =
      [(Cancelled_terminating, "cancelled_terminating");
      (Cancelled_running, "cancelled_running");
      (Failed, "failed");
      (Cancelled, "cancelled");
      (Active, "active");
      (Submitted, "submitted")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SpotFleetRequestConfigData =
  struct
    type t =
      {
      client_token: String.t option ;
      spot_price: String.t ;
      target_capacity: Integer.t ;
      valid_from: DateTime.t option ;
      valid_until: DateTime.t option ;
      terminate_instances_with_expiration: Boolean.t option ;
      iam_fleet_role: String.t ;
      launch_specifications: LaunchSpecsList.t }
    let make ?client_token  ~spot_price  ~target_capacity  ?valid_from 
      ?valid_until  ?terminate_instances_with_expiration  ~iam_fleet_role 
      ~launch_specifications  () =
      {
        client_token;
        spot_price;
        target_capacity;
        valid_from;
        valid_until;
        terminate_instances_with_expiration;
        iam_fleet_role;
        launch_specifications
      }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          spot_price =
            (Xml.required "spotPrice"
               (Util.option_bind (Xml.member "spotPrice" xml) String.parse));
          target_capacity =
            (Xml.required "targetCapacity"
               (Util.option_bind (Xml.member "targetCapacity" xml)
                  Integer.parse));
          valid_from =
            (Util.option_bind (Xml.member "validFrom" xml) DateTime.parse);
          valid_until =
            (Util.option_bind (Xml.member "validUntil" xml) DateTime.parse);
          terminate_instances_with_expiration =
            (Util.option_bind
               (Xml.member "terminateInstancesWithExpiration" xml)
               Boolean.parse);
          iam_fleet_role =
            (Xml.required "iamFleetRole"
               (Util.option_bind (Xml.member "iamFleetRole" xml) String.parse));
          launch_specifications =
            (Xml.required "launchSpecifications"
               (Util.option_bind (Xml.member "launchSpecifications" xml)
                  LaunchSpecsList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("LaunchSpecifications",
                   (LaunchSpecsList.to_query v.launch_specifications)));
           Some
             (Query.Pair ("IamFleetRole", (String.to_query v.iam_fleet_role)));
           Util.option_map v.terminate_instances_with_expiration
             (fun f ->
                Query.Pair
                  ("TerminateInstancesWithExpiration", (Boolean.to_query f)));
           Util.option_map v.valid_until
             (fun f -> Query.Pair ("ValidUntil", (DateTime.to_query f)));
           Util.option_map v.valid_from
             (fun f -> Query.Pair ("ValidFrom", (DateTime.to_query f)));
           Some
             (Query.Pair
                ("TargetCapacity", (Integer.to_query v.target_capacity)));
           Some (Query.Pair ("SpotPrice", (String.to_query v.spot_price)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("launch_specifications",
                (LaunchSpecsList.to_json v.launch_specifications));
           Some ("iam_fleet_role", (String.to_json v.iam_fleet_role));
           Util.option_map v.terminate_instances_with_expiration
             (fun f ->
                ("terminate_instances_with_expiration", (Boolean.to_json f)));
           Util.option_map v.valid_until
             (fun f -> ("valid_until", (DateTime.to_json f)));
           Util.option_map v.valid_from
             (fun f -> ("valid_from", (DateTime.to_json f)));
           Some ("target_capacity", (Integer.to_json v.target_capacity));
           Some ("spot_price", (String.to_json v.spot_price));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        spot_price =
          (String.of_json (Util.of_option_exn (Json.lookup j "spot_price")));
        target_capacity =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "target_capacity")));
        valid_from =
          (Util.option_map (Json.lookup j "valid_from") DateTime.of_json);
        valid_until =
          (Util.option_map (Json.lookup j "valid_until") DateTime.of_json);
        terminate_instances_with_expiration =
          (Util.option_map
             (Json.lookup j "terminate_instances_with_expiration")
             Boolean.of_json);
        iam_fleet_role =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "iam_fleet_role")));
        launch_specifications =
          (LaunchSpecsList.of_json
             (Util.of_option_exn (Json.lookup j "launch_specifications")))
      }
  end
module AvailabilityZoneMessageList =
  struct
    type t = AvailabilityZoneMessage.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AvailabilityZoneMessage.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list AvailabilityZoneMessage.to_query v
    let to_json v = `List (List.map AvailabilityZoneMessage.to_json v)
    let of_json j = Json.to_list AvailabilityZoneMessage.of_json j
  end
module AvailabilityZoneState =
  struct
    type t =
      | Available 
    let str_to_t = [("available", Available)]
    let t_to_str = [(Available, "available")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TrafficType =
  struct
    type t =
      | ACCEPT 
      | REJECT 
      | ALL 
    let str_to_t = [("ALL", ALL); ("REJECT", REJECT); ("ACCEPT", ACCEPT)]
    let t_to_str = [(ALL, "ALL"); (REJECT, "REJECT"); (ACCEPT, "ACCEPT")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module BundleTaskError =
  struct
    type t = {
      code: String.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module BundleTaskState =
  struct
    type t =
      | Pending 
      | Waiting_for_shutdown 
      | Bundling 
      | Storing 
      | Cancelling 
      | Complete 
      | Failed 
    let str_to_t =
      [("failed", Failed);
      ("complete", Complete);
      ("cancelling", Cancelling);
      ("storing", Storing);
      ("bundling", Bundling);
      ("waiting-for-shutdown", Waiting_for_shutdown);
      ("pending", Pending)]
    let t_to_str =
      [(Failed, "failed");
      (Complete, "complete");
      (Cancelling, "cancelling");
      (Storing, "storing");
      (Bundling, "bundling");
      (Waiting_for_shutdown, "waiting-for-shutdown");
      (Pending, "pending")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module Storage =
  struct
    type t = {
      s3: S3Storage.t option }
    let make ?s3  () = { s3 }
    let parse xml =
      Some { s3 = (Util.option_bind (Xml.member "S3" xml) S3Storage.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3
              (fun f -> Query.Pair ("S3", (S3Storage.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3 (fun f -> ("s3", (S3Storage.to_json f)))])
    let of_json j =
      { s3 = (Util.option_map (Json.lookup j "s3") S3Storage.of_json) }
  end
module VolumeStatusActionsList =
  struct
    type t = VolumeStatusAction.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VolumeStatusAction.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VolumeStatusAction.to_query v
    let to_json v = `List (List.map VolumeStatusAction.to_json v)
    let of_json j = Json.to_list VolumeStatusAction.of_json j
  end
module VolumeStatusEventsList =
  struct
    type t = VolumeStatusEvent.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VolumeStatusEvent.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VolumeStatusEvent.to_query v
    let to_json v = `List (List.map VolumeStatusEvent.to_json v)
    let of_json j = Json.to_list VolumeStatusEvent.of_json j
  end
module VolumeStatusInfo =
  struct
    type t =
      {
      status: VolumeStatusInfoStatus.t option ;
      details: VolumeStatusDetailsList.t }
    let make ?status  ?(details= [])  () = { status; details }
    let parse xml =
      Some
        {
          status =
            (Util.option_bind (Xml.member "status" xml)
               VolumeStatusInfoStatus.parse);
          details =
            (Util.of_option []
               (Util.option_bind (Xml.member "details" xml)
                  VolumeStatusDetailsList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Details", (VolumeStatusDetailsList.to_query v.details)));
           Util.option_map v.status
             (fun f ->
                Query.Pair ("Status", (VolumeStatusInfoStatus.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("details", (VolumeStatusDetailsList.to_json v.details));
           Util.option_map v.status
             (fun f -> ("status", (VolumeStatusInfoStatus.to_json f)))])
    let of_json j =
      {
        status =
          (Util.option_map (Json.lookup j "status")
             VolumeStatusInfoStatus.of_json);
        details =
          (VolumeStatusDetailsList.of_json
             (Util.of_option_exn (Json.lookup j "details")))
      }
  end
module CreateVolumePermission =
  struct
    type t = {
      user_id: String.t option ;
      group: PermissionGroup.t option }
    let make ?user_id  ?group  () = { user_id; group }
    let parse xml =
      Some
        {
          user_id = (Util.option_bind (Xml.member "userId" xml) String.parse);
          group =
            (Util.option_bind (Xml.member "group" xml) PermissionGroup.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group
              (fun f -> Query.Pair ("Group", (PermissionGroup.to_query f)));
           Util.option_map v.user_id
             (fun f -> Query.Pair ("UserId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group
              (fun f -> ("group", (PermissionGroup.to_json f)));
           Util.option_map v.user_id
             (fun f -> ("user_id", (String.to_json f)))])
    let of_json j =
      {
        user_id = (Util.option_map (Json.lookup j "user_id") String.of_json);
        group =
          (Util.option_map (Json.lookup j "group") PermissionGroup.of_json)
      }
  end
module VolumeAttachmentList =
  struct
    type t = VolumeAttachment.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VolumeAttachment.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VolumeAttachment.to_query v
    let to_json v = `List (List.map VolumeAttachment.to_json v)
    let of_json j = Json.to_list VolumeAttachment.of_json j
  end
module VolumeState =
  struct
    type t =
      | Creating 
      | Available 
      | In_use 
      | Deleting 
      | Deleted 
      | Error 
    let str_to_t =
      [("error", Error);
      ("deleted", Deleted);
      ("deleting", Deleting);
      ("in-use", In_use);
      ("available", Available);
      ("creating", Creating)]
    let t_to_str =
      [(Error, "error");
      (Deleted, "deleted");
      (Deleting, "deleting");
      (In_use, "in-use");
      (Available, "available");
      (Creating, "creating")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DomainType =
  struct
    type t =
      | Vpc 
      | Standard 
    let str_to_t = [("standard", Standard); ("vpc", Vpc)]
    let t_to_str = [(Standard, "standard"); (Vpc, "vpc")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VgwTelemetryList =
  struct
    type t = VgwTelemetry.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map VgwTelemetry.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VgwTelemetry.to_query v
    let to_json v = `List (List.map VgwTelemetry.to_json v)
    let of_json j = Json.to_list VgwTelemetry.of_json j
  end
module VpnConnectionOptions =
  struct
    type t = {
      static_routes_only: Boolean.t option }
    let make ?static_routes_only  () = { static_routes_only }
    let parse xml =
      Some
        {
          static_routes_only =
            (Util.option_bind (Xml.member "staticRoutesOnly" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.static_routes_only
              (fun f -> Query.Pair ("StaticRoutesOnly", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.static_routes_only
              (fun f -> ("static_routes_only", (Boolean.to_json f)))])
    let of_json j =
      {
        static_routes_only =
          (Util.option_map (Json.lookup j "static_routes_only")
             Boolean.of_json)
      }
  end
module VpnStaticRouteList =
  struct
    type t = VpnStaticRoute.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VpnStaticRoute.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VpnStaticRoute.to_query v
    let to_json v = `List (List.map VpnStaticRoute.to_json v)
    let of_json j = Json.to_list VpnStaticRoute.of_json j
  end
module PricingDetailsList =
  struct
    type t = PricingDetail.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map PricingDetail.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PricingDetail.to_query v
    let to_json v = `List (List.map PricingDetail.to_json v)
    let of_json j = Json.to_list PricingDetail.of_json j
  end
module InstanceList =
  struct
    type t = Instance.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Instance.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Instance.to_query v
    let to_json v = `List (List.map Instance.to_json v)
    let of_json j = Json.to_list Instance.of_json j
  end
module VpcPeeringConnectionStateReason =
  struct
    type t =
      {
      code: VpcPeeringConnectionStateReasonCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               VpcPeeringConnectionStateReasonCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair
                  ("Code", (VpcPeeringConnectionStateReasonCode.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f ->
                ("code", (VpcPeeringConnectionStateReasonCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             VpcPeeringConnectionStateReasonCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module VpcPeeringConnectionVpcInfo =
  struct
    type t =
      {
      cidr_block: String.t option ;
      owner_id: String.t option ;
      vpc_id: String.t option }
    let make ?cidr_block  ?owner_id  ?vpc_id  () =
      { cidr_block; owner_id; vpc_id }
    let parse xml =
      Some
        {
          cidr_block =
            (Util.option_bind (Xml.member "cidrBlock" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.cidr_block
             (fun f -> Query.Pair ("CidrBlock", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.cidr_block
             (fun f -> ("cidr_block", (String.to_json f)))])
    let of_json j =
      {
        cidr_block =
          (Util.option_map (Json.lookup j "cidr_block") String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json)
      }
  end
module VpcState =
  struct
    type t =
      | Pending 
      | Available 
    let str_to_t = [("available", Available); ("pending", Pending)]
    let t_to_str = [(Available, "available"); (Pending, "pending")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module NetworkAclAssociationList =
  struct
    type t = NetworkAclAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map NetworkAclAssociation.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list NetworkAclAssociation.to_query v
    let to_json v = `List (List.map NetworkAclAssociation.to_json v)
    let of_json j = Json.to_list NetworkAclAssociation.of_json j
  end
module NetworkAclEntryList =
  struct
    type t = NetworkAclEntry.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map NetworkAclEntry.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list NetworkAclEntry.to_query v
    let to_json v = `List (List.map NetworkAclEntry.to_json v)
    let of_json j = Json.to_list NetworkAclEntry.of_json j
  end
module SubnetState =
  struct
    type t =
      | Pending 
      | Available 
    let str_to_t = [("available", Available); ("pending", Pending)]
    let t_to_str = [(Available, "available"); (Pending, "pending")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SnapshotDetailList =
  struct
    type t = SnapshotDetail.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SnapshotDetail.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list SnapshotDetail.to_query v
    let to_json v = `List (List.map SnapshotDetail.to_json v)
    let of_json j = Json.to_list SnapshotDetail.of_json j
  end
module CancelSpotFleetRequestsError =
  struct
    type t = {
      code: CancelBatchErrorCode.t ;
      message: String.t }
    let make ~code  ~message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Xml.required "code"
               (Util.option_bind (Xml.member "code" xml)
                  CancelBatchErrorCode.parse));
          message =
            (Xml.required "message"
               (Util.option_bind (Xml.member "message" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Message", (String.to_query v.message)));
           Some (Query.Pair ("Code", (CancelBatchErrorCode.to_query v.code)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("message", (String.to_json v.message));
           Some ("code", (CancelBatchErrorCode.to_json v.code))])
    let of_json j =
      {
        code =
          (CancelBatchErrorCode.of_json
             (Util.of_option_exn (Json.lookup j "code")));
        message =
          (String.of_json (Util.of_option_exn (Json.lookup j "message")))
      }
  end
module AccountAttributeValueList =
  struct
    type t = AccountAttributeValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AccountAttributeValue.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list AccountAttributeValue.to_query v
    let to_json v = `List (List.map AccountAttributeValue.to_json v)
    let of_json j = Json.to_list AccountAttributeValue.of_json j
  end
module DiskImageDetail =
  struct
    type t =
      {
      format: DiskImageFormat.t ;
      bytes: Long.t ;
      import_manifest_url: String.t }
    let make ~format  ~bytes  ~import_manifest_url  () =
      { format; bytes; import_manifest_url }
    let parse xml =
      Some
        {
          format =
            (Xml.required "format"
               (Util.option_bind (Xml.member "format" xml)
                  DiskImageFormat.parse));
          bytes =
            (Xml.required "bytes"
               (Util.option_bind (Xml.member "bytes" xml) Long.parse));
          import_manifest_url =
            (Xml.required "importManifestUrl"
               (Util.option_bind (Xml.member "importManifestUrl" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ImportManifestUrl",
                   (String.to_query v.import_manifest_url)));
           Some (Query.Pair ("Bytes", (Long.to_query v.bytes)));
           Some (Query.Pair ("Format", (DiskImageFormat.to_query v.format)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("import_manifest_url", (String.to_json v.import_manifest_url));
           Some ("bytes", (Long.to_json v.bytes));
           Some ("format", (DiskImageFormat.to_json v.format))])
    let of_json j =
      {
        format =
          (DiskImageFormat.of_json
             (Util.of_option_exn (Json.lookup j "format")));
        bytes = (Long.of_json (Util.of_option_exn (Json.lookup j "bytes")));
        import_manifest_url =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "import_manifest_url")))
      }
  end
module VolumeDetail =
  struct
    type t = {
      size: Long.t }
    let make ~size  () = { size }
    let parse xml =
      Some
        {
          size =
            (Xml.required "size"
               (Util.option_bind (Xml.member "size" xml) Long.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Size", (Long.to_query v.size)))])
    let to_json v =
      `Assoc (Util.list_filter_opt [Some ("size", (Long.to_json v.size))])
    let of_json j =
      { size = (Long.of_json (Util.of_option_exn (Json.lookup j "size"))) }
  end
module State =
  struct
    type t =
      | Pending 
      | Available 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("Deleted", Deleted);
      ("Deleting", Deleting);
      ("Available", Available);
      ("Pending", Pending)]
    let t_to_str =
      [(Deleted, "Deleted");
      (Deleting, "Deleting");
      (Available, "Available");
      (Pending, "Pending")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module UserBucket =
  struct
    type t = {
      s3_bucket: String.t option ;
      s3_key: String.t option }
    let make ?s3_bucket  ?s3_key  () = { s3_bucket; s3_key }
    let parse xml =
      Some
        {
          s3_bucket =
            (Util.option_bind (Xml.member "S3Bucket" xml) String.parse);
          s3_key = (Util.option_bind (Xml.member "S3Key" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3_key
              (fun f -> Query.Pair ("S3Key", (String.to_query f)));
           Util.option_map v.s3_bucket
             (fun f -> Query.Pair ("S3Bucket", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_key
              (fun f -> ("s3_key", (String.to_json f)));
           Util.option_map v.s3_bucket
             (fun f -> ("s3_bucket", (String.to_json f)))])
    let of_json j =
      {
        s3_bucket =
          (Util.option_map (Json.lookup j "s3_bucket") String.of_json);
        s3_key = (Util.option_map (Json.lookup j "s3_key") String.of_json)
      }
  end
module SnapshotState =
  struct
    type t =
      | Pending 
      | Completed 
      | Error 
    let str_to_t =
      [("error", Error); ("completed", Completed); ("pending", Pending)]
    let t_to_str =
      [(Error, "error"); (Completed, "completed"); (Pending, "pending")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module NetworkInterface =
  struct
    type t =
      {
      network_interface_id: String.t option ;
      subnet_id: String.t option ;
      vpc_id: String.t option ;
      availability_zone: String.t option ;
      description: String.t option ;
      owner_id: String.t option ;
      requester_id: String.t option ;
      requester_managed: Boolean.t option ;
      status: NetworkInterfaceStatus.t option ;
      mac_address: String.t option ;
      private_ip_address: String.t option ;
      private_dns_name: String.t option ;
      source_dest_check: Boolean.t option ;
      groups: GroupIdentifierList.t ;
      attachment: NetworkInterfaceAttachment.t option ;
      association: NetworkInterfaceAssociation.t option ;
      tag_set: TagList.t ;
      private_ip_addresses: NetworkInterfacePrivateIpAddressList.t }
    let make ?network_interface_id  ?subnet_id  ?vpc_id  ?availability_zone 
      ?description  ?owner_id  ?requester_id  ?requester_managed  ?status 
      ?mac_address  ?private_ip_address  ?private_dns_name 
      ?source_dest_check  ?(groups= [])  ?attachment  ?association 
      ?(tag_set= [])  ?(private_ip_addresses= [])  () =
      {
        network_interface_id;
        subnet_id;
        vpc_id;
        availability_zone;
        description;
        owner_id;
        requester_id;
        requester_managed;
        status;
        mac_address;
        private_ip_address;
        private_dns_name;
        source_dest_check;
        groups;
        attachment;
        association;
        tag_set;
        private_ip_addresses
      }
    let parse xml =
      Some
        {
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          requester_id =
            (Util.option_bind (Xml.member "requesterId" xml) String.parse);
          requester_managed =
            (Util.option_bind (Xml.member "requesterManaged" xml)
               Boolean.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               NetworkInterfaceStatus.parse);
          mac_address =
            (Util.option_bind (Xml.member "macAddress" xml) String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml)
               Boolean.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          attachment =
            (Util.option_bind (Xml.member "attachment" xml)
               NetworkInterfaceAttachment.parse);
          association =
            (Util.option_bind (Xml.member "association" xml)
               NetworkInterfaceAssociation.parse);
          tag_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          private_ip_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "privateIpAddressesSet" xml)
                  NetworkInterfacePrivateIpAddressList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PrivateIpAddressesSet",
                   (NetworkInterfacePrivateIpAddressList.to_query
                      v.private_ip_addresses)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tag_set)));
           Util.option_map v.association
             (fun f ->
                Query.Pair
                  ("Association", (NetworkInterfaceAssociation.to_query f)));
           Util.option_map v.attachment
             (fun f ->
                Query.Pair
                  ("Attachment", (NetworkInterfaceAttachment.to_query f)));
           Some
             (Query.Pair
                ("GroupSet", (GroupIdentifierList.to_query v.groups)));
           Util.option_map v.source_dest_check
             (fun f -> Query.Pair ("SourceDestCheck", (Boolean.to_query f)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.mac_address
             (fun f -> Query.Pair ("MacAddress", (String.to_query f)));
           Util.option_map v.status
             (fun f ->
                Query.Pair ("Status", (NetworkInterfaceStatus.to_query f)));
           Util.option_map v.requester_managed
             (fun f -> Query.Pair ("RequesterManaged", (Boolean.to_query f)));
           Util.option_map v.requester_id
             (fun f -> Query.Pair ("RequesterId", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("private_ip_addresses",
                (NetworkInterfacePrivateIpAddressList.to_json
                   v.private_ip_addresses));
           Some ("tag_set", (TagList.to_json v.tag_set));
           Util.option_map v.association
             (fun f ->
                ("association", (NetworkInterfaceAssociation.to_json f)));
           Util.option_map v.attachment
             (fun f -> ("attachment", (NetworkInterfaceAttachment.to_json f)));
           Some ("groups", (GroupIdentifierList.to_json v.groups));
           Util.option_map v.source_dest_check
             (fun f -> ("source_dest_check", (Boolean.to_json f)));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.mac_address
             (fun f -> ("mac_address", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (NetworkInterfaceStatus.to_json f)));
           Util.option_map v.requester_managed
             (fun f -> ("requester_managed", (Boolean.to_json f)));
           Util.option_map v.requester_id
             (fun f -> ("requester_id", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)))])
    let of_json j =
      {
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        requester_id =
          (Util.option_map (Json.lookup j "requester_id") String.of_json);
        requester_managed =
          (Util.option_map (Json.lookup j "requester_managed")
             Boolean.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             NetworkInterfaceStatus.of_json);
        mac_address =
          (Util.option_map (Json.lookup j "mac_address") String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        private_dns_name =
          (Util.option_map (Json.lookup j "private_dns_name") String.of_json);
        source_dest_check =
          (Util.option_map (Json.lookup j "source_dest_check")
             Boolean.of_json);
        groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        attachment =
          (Util.option_map (Json.lookup j "attachment")
             NetworkInterfaceAttachment.of_json);
        association =
          (Util.option_map (Json.lookup j "association")
             NetworkInterfaceAssociation.of_json);
        tag_set =
          (TagList.of_json (Util.of_option_exn (Json.lookup j "tag_set")));
        private_ip_addresses =
          (NetworkInterfacePrivateIpAddressList.of_json
             (Util.of_option_exn (Json.lookup j "private_ip_addresses")))
      }
  end
module TagDescription =
  struct
    type t =
      {
      resource_id: String.t ;
      resource_type: ResourceType.t ;
      key: String.t ;
      value: String.t }
    let make ~resource_id  ~resource_type  ~key  ~value  () =
      { resource_id; resource_type; key; value }
    let parse xml =
      Some
        {
          resource_id =
            (Xml.required "resourceId"
               (Util.option_bind (Xml.member "resourceId" xml) String.parse));
          resource_type =
            (Xml.required "resourceType"
               (Util.option_bind (Xml.member "resourceType" xml)
                  ResourceType.parse));
          key =
            (Xml.required "key"
               (Util.option_bind (Xml.member "key" xml) String.parse));
          value =
            (Xml.required "value"
               (Util.option_bind (Xml.member "value" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Value", (String.to_query v.value)));
           Some (Query.Pair ("Key", (String.to_query v.key)));
           Some
             (Query.Pair
                ("ResourceType", (ResourceType.to_query v.resource_type)));
           Some (Query.Pair ("ResourceId", (String.to_query v.resource_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("value", (String.to_json v.value));
           Some ("key", (String.to_json v.key));
           Some ("resource_type", (ResourceType.to_json v.resource_type));
           Some ("resource_id", (String.to_json v.resource_id))])
    let of_json j =
      {
        resource_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "resource_id")));
        resource_type =
          (ResourceType.of_json
             (Util.of_option_exn (Json.lookup j "resource_type")));
        key = (String.of_json (Util.of_option_exn (Json.lookup j "key")));
        value = (String.of_json (Util.of_option_exn (Json.lookup j "value")))
      }
  end
module DhcpOptions =
  struct
    type t =
      {
      dhcp_options_id: String.t option ;
      dhcp_configurations: DhcpConfigurationList.t ;
      tags: TagList.t }
    let make ?dhcp_options_id  ?(dhcp_configurations= [])  ?(tags= [])  () =
      { dhcp_options_id; dhcp_configurations; tags }
    let parse xml =
      Some
        {
          dhcp_options_id =
            (Util.option_bind (Xml.member "dhcpOptionsId" xml) String.parse);
          dhcp_configurations =
            (Util.of_option []
               (Util.option_bind (Xml.member "dhcpConfigurationSet" xml)
                  DhcpConfigurationList.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("DhcpConfigurationSet",
                  (DhcpConfigurationList.to_query v.dhcp_configurations)));
           Util.option_map v.dhcp_options_id
             (fun f -> Query.Pair ("DhcpOptionsId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Some
             ("dhcp_configurations",
               (DhcpConfigurationList.to_json v.dhcp_configurations));
           Util.option_map v.dhcp_options_id
             (fun f -> ("dhcp_options_id", (String.to_json f)))])
    let of_json j =
      {
        dhcp_options_id =
          (Util.option_map (Json.lookup j "dhcp_options_id") String.of_json);
        dhcp_configurations =
          (DhcpConfigurationList.of_json
             (Util.of_option_exn (Json.lookup j "dhcp_configurations")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module VpnGateway =
  struct
    type t =
      {
      vpn_gateway_id: String.t option ;
      state: VpnState.t option ;
      type_: GatewayType.t option ;
      availability_zone: String.t option ;
      vpc_attachments: VpcAttachmentList.t ;
      tags: TagList.t }
    let make ?vpn_gateway_id  ?state  ?type_  ?availability_zone 
      ?(vpc_attachments= [])  ?(tags= [])  () =
      {
        vpn_gateway_id;
        state;
        type_;
        availability_zone;
        vpc_attachments;
        tags
      }
    let parse xml =
      Some
        {
          vpn_gateway_id =
            (Util.option_bind (Xml.member "vpnGatewayId" xml) String.parse);
          state = (Util.option_bind (Xml.member "state" xml) VpnState.parse);
          type_ =
            (Util.option_bind (Xml.member "type" xml) GatewayType.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          vpc_attachments =
            (Util.of_option []
               (Util.option_bind (Xml.member "attachments" xml)
                  VpcAttachmentList.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("Attachments",
                  (VpcAttachmentList.to_query v.vpc_attachments)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (GatewayType.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (VpnState.to_query f)));
           Util.option_map v.vpn_gateway_id
             (fun f -> Query.Pair ("VpnGatewayId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Some
             ("vpc_attachments",
               (VpcAttachmentList.to_json v.vpc_attachments));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (GatewayType.to_json f)));
           Util.option_map v.state (fun f -> ("state", (VpnState.to_json f)));
           Util.option_map v.vpn_gateway_id
             (fun f -> ("vpn_gateway_id", (String.to_json f)))])
    let of_json j =
      {
        vpn_gateway_id =
          (Util.option_map (Json.lookup j "vpn_gateway_id") String.of_json);
        state = (Util.option_map (Json.lookup j "state") VpnState.of_json);
        type_ = (Util.option_map (Json.lookup j "type_") GatewayType.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        vpc_attachments =
          (VpcAttachmentList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_attachments")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module ReservedInstancesModification =
  struct
    type t =
      {
      reserved_instances_modification_id: String.t option ;
      reserved_instances_ids: ReservedIntancesIds.t ;
      modification_results: ReservedInstancesModificationResultList.t ;
      create_date: DateTime.t option ;
      update_date: DateTime.t option ;
      effective_date: DateTime.t option ;
      status: String.t option ;
      status_message: String.t option ;
      client_token: String.t option }
    let make ?reserved_instances_modification_id  ?(reserved_instances_ids=
      [])  ?(modification_results= [])  ?create_date  ?update_date 
      ?effective_date  ?status  ?status_message  ?client_token  () =
      {
        reserved_instances_modification_id;
        reserved_instances_ids;
        modification_results;
        create_date;
        update_date;
        effective_date;
        status;
        status_message;
        client_token
      }
    let parse xml =
      Some
        {
          reserved_instances_modification_id =
            (Util.option_bind
               (Xml.member "reservedInstancesModificationId" xml)
               String.parse);
          reserved_instances_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "reservedInstancesSet" xml)
                  ReservedIntancesIds.parse));
          modification_results =
            (Util.of_option []
               (Util.option_bind (Xml.member "modificationResultSet" xml)
                  ReservedInstancesModificationResultList.parse));
          create_date =
            (Util.option_bind (Xml.member "createDate" xml) DateTime.parse);
          update_date =
            (Util.option_bind (Xml.member "updateDate" xml) DateTime.parse);
          effective_date =
            (Util.option_bind (Xml.member "effectiveDate" xml) DateTime.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.effective_date
             (fun f -> Query.Pair ("EffectiveDate", (DateTime.to_query f)));
           Util.option_map v.update_date
             (fun f -> Query.Pair ("UpdateDate", (DateTime.to_query f)));
           Util.option_map v.create_date
             (fun f -> Query.Pair ("CreateDate", (DateTime.to_query f)));
           Some
             (Query.Pair
                ("ModificationResultSet",
                  (ReservedInstancesModificationResultList.to_query
                     v.modification_results)));
           Some
             (Query.Pair
                ("ReservedInstancesSet",
                  (ReservedIntancesIds.to_query v.reserved_instances_ids)));
           Util.option_map v.reserved_instances_modification_id
             (fun f ->
                Query.Pair
                  ("ReservedInstancesModificationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Util.option_map v.effective_date
             (fun f -> ("effective_date", (DateTime.to_json f)));
           Util.option_map v.update_date
             (fun f -> ("update_date", (DateTime.to_json f)));
           Util.option_map v.create_date
             (fun f -> ("create_date", (DateTime.to_json f)));
           Some
             ("modification_results",
               (ReservedInstancesModificationResultList.to_json
                  v.modification_results));
           Some
             ("reserved_instances_ids",
               (ReservedIntancesIds.to_json v.reserved_instances_ids));
           Util.option_map v.reserved_instances_modification_id
             (fun f ->
                ("reserved_instances_modification_id", (String.to_json f)))])
    let of_json j =
      {
        reserved_instances_modification_id =
          (Util.option_map
             (Json.lookup j "reserved_instances_modification_id")
             String.of_json);
        reserved_instances_ids =
          (ReservedIntancesIds.of_json
             (Util.of_option_exn (Json.lookup j "reserved_instances_ids")));
        modification_results =
          (ReservedInstancesModificationResultList.of_json
             (Util.of_option_exn (Json.lookup j "modification_results")));
        create_date =
          (Util.option_map (Json.lookup j "create_date") DateTime.of_json);
        update_date =
          (Util.option_map (Json.lookup j "update_date") DateTime.of_json);
        effective_date =
          (Util.option_map (Json.lookup j "effective_date") DateTime.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module ReservedInstances =
  struct
    type t =
      {
      reserved_instances_id: String.t option ;
      instance_type: InstanceType.t option ;
      availability_zone: String.t option ;
      start: DateTime.t option ;
      end_: DateTime.t option ;
      duration: Long.t option ;
      usage_price: Float.t option ;
      fixed_price: Float.t option ;
      instance_count: Integer.t option ;
      product_description: RIProductDescription.t option ;
      state: ReservedInstanceState.t option ;
      tags: TagList.t ;
      instance_tenancy: Tenancy.t option ;
      currency_code: CurrencyCodeValues.t option ;
      offering_type: OfferingTypeValues.t option ;
      recurring_charges: RecurringChargesList.t }
    let make ?reserved_instances_id  ?instance_type  ?availability_zone 
      ?start  ?end_  ?duration  ?usage_price  ?fixed_price  ?instance_count 
      ?product_description  ?state  ?(tags= [])  ?instance_tenancy 
      ?currency_code  ?offering_type  ?(recurring_charges= [])  () =
      {
        reserved_instances_id;
        instance_type;
        availability_zone;
        start;
        end_;
        duration;
        usage_price;
        fixed_price;
        instance_count;
        product_description;
        state;
        tags;
        instance_tenancy;
        currency_code;
        offering_type;
        recurring_charges
      }
    let parse xml =
      Some
        {
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          start = (Util.option_bind (Xml.member "start" xml) DateTime.parse);
          end_ = (Util.option_bind (Xml.member "end" xml) DateTime.parse);
          duration =
            (Util.option_bind (Xml.member "duration" xml) Long.parse);
          usage_price =
            (Util.option_bind (Xml.member "usagePrice" xml) Float.parse);
          fixed_price =
            (Util.option_bind (Xml.member "fixedPrice" xml) Float.parse);
          instance_count =
            (Util.option_bind (Xml.member "instanceCount" xml) Integer.parse);
          product_description =
            (Util.option_bind (Xml.member "productDescription" xml)
               RIProductDescription.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               ReservedInstanceState.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          instance_tenancy =
            (Util.option_bind (Xml.member "instanceTenancy" xml)
               Tenancy.parse);
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          offering_type =
            (Util.option_bind (Xml.member "offeringType" xml)
               OfferingTypeValues.parse);
          recurring_charges =
            (Util.of_option []
               (Util.option_bind (Xml.member "recurringCharges" xml)
                  RecurringChargesList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("RecurringCharges",
                   (RecurringChargesList.to_query v.recurring_charges)));
           Util.option_map v.offering_type
             (fun f ->
                Query.Pair ("OfferingType", (OfferingTypeValues.to_query f)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)));
           Util.option_map v.instance_tenancy
             (fun f -> Query.Pair ("InstanceTenancy", (Tenancy.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("State", (ReservedInstanceState.to_query f)));
           Util.option_map v.product_description
             (fun f ->
                Query.Pair
                  ("ProductDescription", (RIProductDescription.to_query f)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)));
           Util.option_map v.fixed_price
             (fun f -> Query.Pair ("FixedPrice", (Float.to_query f)));
           Util.option_map v.usage_price
             (fun f -> Query.Pair ("UsagePrice", (Float.to_query f)));
           Util.option_map v.duration
             (fun f -> Query.Pair ("Duration", (Long.to_query f)));
           Util.option_map v.end_
             (fun f -> Query.Pair ("End", (DateTime.to_query f)));
           Util.option_map v.start
             (fun f -> Query.Pair ("Start", (DateTime.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.reserved_instances_id
             (fun f ->
                Query.Pair ("ReservedInstancesId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("recurring_charges",
                (RecurringChargesList.to_json v.recurring_charges));
           Util.option_map v.offering_type
             (fun f -> ("offering_type", (OfferingTypeValues.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)));
           Util.option_map v.instance_tenancy
             (fun f -> ("instance_tenancy", (Tenancy.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.state
             (fun f -> ("state", (ReservedInstanceState.to_json f)));
           Util.option_map v.product_description
             (fun f ->
                ("product_description", (RIProductDescription.to_json f)));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)));
           Util.option_map v.fixed_price
             (fun f -> ("fixed_price", (Float.to_json f)));
           Util.option_map v.usage_price
             (fun f -> ("usage_price", (Float.to_json f)));
           Util.option_map v.duration
             (fun f -> ("duration", (Long.to_json f)));
           Util.option_map v.end_ (fun f -> ("end_", (DateTime.to_json f)));
           Util.option_map v.start (fun f -> ("start", (DateTime.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.reserved_instances_id
             (fun f -> ("reserved_instances_id", (String.to_json f)))])
    let of_json j =
      {
        reserved_instances_id =
          (Util.option_map (Json.lookup j "reserved_instances_id")
             String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        start = (Util.option_map (Json.lookup j "start") DateTime.of_json);
        end_ = (Util.option_map (Json.lookup j "end_") DateTime.of_json);
        duration = (Util.option_map (Json.lookup j "duration") Long.of_json);
        usage_price =
          (Util.option_map (Json.lookup j "usage_price") Float.of_json);
        fixed_price =
          (Util.option_map (Json.lookup j "fixed_price") Float.of_json);
        instance_count =
          (Util.option_map (Json.lookup j "instance_count") Integer.of_json);
        product_description =
          (Util.option_map (Json.lookup j "product_description")
             RIProductDescription.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             ReservedInstanceState.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        instance_tenancy =
          (Util.option_map (Json.lookup j "instance_tenancy") Tenancy.of_json);
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json);
        offering_type =
          (Util.option_map (Json.lookup j "offering_type")
             OfferingTypeValues.of_json);
        recurring_charges =
          (RecurringChargesList.of_json
             (Util.of_option_exn (Json.lookup j "recurring_charges")))
      }
  end
module Filter =
  struct
    type t = {
      name: String.t ;
      values: ValueStringList.t }
    let make ~name  ?(values= [])  () = { name; values }
    let parse xml =
      Some
        {
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          values =
            (Util.of_option []
               (Util.option_bind (Xml.member "Value" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Value", (ValueStringList.to_query v.values)));
           Some (Query.Pair ("Name", (String.to_query v.name)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("values", (ValueStringList.to_json v.values));
           Some ("name", (String.to_json v.name))])
    let of_json j =
      {
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        values =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "values")))
      }
  end
module PlacementGroup =
  struct
    type t =
      {
      group_name: String.t option ;
      strategy: PlacementStrategy.t option ;
      state: PlacementGroupState.t option }
    let make ?group_name  ?strategy  ?state  () =
      { group_name; strategy; state }
    let parse xml =
      Some
        {
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          strategy =
            (Util.option_bind (Xml.member "strategy" xml)
               PlacementStrategy.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               PlacementGroupState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair ("State", (PlacementGroupState.to_query f)));
           Util.option_map v.strategy
             (fun f ->
                Query.Pair ("Strategy", (PlacementStrategy.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (PlacementGroupState.to_json f)));
           Util.option_map v.strategy
             (fun f -> ("strategy", (PlacementStrategy.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)))])
    let of_json j =
      {
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        strategy =
          (Util.option_map (Json.lookup j "strategy")
             PlacementStrategy.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             PlacementGroupState.of_json)
      }
  end
module KeyPairInfo =
  struct
    type t = {
      key_name: String.t option ;
      key_fingerprint: String.t option }
    let make ?key_name  ?key_fingerprint  () = { key_name; key_fingerprint }
    let parse xml =
      Some
        {
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse);
          key_fingerprint =
            (Util.option_bind (Xml.member "keyFingerprint" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.key_fingerprint
              (fun f -> Query.Pair ("KeyFingerprint", (String.to_query f)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.key_fingerprint
              (fun f -> ("key_fingerprint", (String.to_json f)));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)))])
    let of_json j =
      {
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        key_fingerprint =
          (Util.option_map (Json.lookup j "key_fingerprint") String.of_json)
      }
  end
module CancelledSpotInstanceRequest =
  struct
    type t =
      {
      spot_instance_request_id: String.t option ;
      state: CancelSpotInstanceRequestState.t option }
    let make ?spot_instance_request_id  ?state  () =
      { spot_instance_request_id; state }
    let parse xml =
      Some
        {
          spot_instance_request_id =
            (Util.option_bind (Xml.member "spotInstanceRequestId" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               CancelSpotInstanceRequestState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair
                   ("State", (CancelSpotInstanceRequestState.to_query f)));
           Util.option_map v.spot_instance_request_id
             (fun f ->
                Query.Pair ("SpotInstanceRequestId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (CancelSpotInstanceRequestState.to_json f)));
           Util.option_map v.spot_instance_request_id
             (fun f -> ("spot_instance_request_id", (String.to_json f)))])
    let of_json j =
      {
        spot_instance_request_id =
          (Util.option_map (Json.lookup j "spot_instance_request_id")
             String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             CancelSpotInstanceRequestState.of_json)
      }
  end
module DatafeedSubscriptionState =
  struct
    type t =
      | Active 
      | Inactive 
    let str_to_t = [("Inactive", Inactive); ("Active", Active)]
    let t_to_str = [(Inactive, "Inactive"); (Active, "Active")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module LaunchPermissionList =
  struct
    type t = LaunchPermission.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchPermission.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list LaunchPermission.to_query v
    let to_json v = `List (List.map LaunchPermission.to_json v)
    let of_json j = Json.to_list LaunchPermission.of_json j
  end
module ConversionTask =
  struct
    type t =
      {
      conversion_task_id: String.t ;
      expiration_time: String.t option ;
      import_instance: ImportInstanceTaskDetails.t option ;
      import_volume: ImportVolumeTaskDetails.t option ;
      state: ConversionTaskState.t ;
      status_message: String.t option ;
      tags: TagList.t }
    let make ~conversion_task_id  ?expiration_time  ?import_instance 
      ?import_volume  ~state  ?status_message  ?(tags= [])  () =
      {
        conversion_task_id;
        expiration_time;
        import_instance;
        import_volume;
        state;
        status_message;
        tags
      }
    let parse xml =
      Some
        {
          conversion_task_id =
            (Xml.required "conversionTaskId"
               (Util.option_bind (Xml.member "conversionTaskId" xml)
                  String.parse));
          expiration_time =
            (Util.option_bind (Xml.member "expirationTime" xml) String.parse);
          import_instance =
            (Util.option_bind (Xml.member "importInstance" xml)
               ImportInstanceTaskDetails.parse);
          import_volume =
            (Util.option_bind (Xml.member "importVolume" xml)
               ImportVolumeTaskDetails.parse);
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml)
                  ConversionTaskState.parse));
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Some
             (Query.Pair ("State", (ConversionTaskState.to_query v.state)));
           Util.option_map v.import_volume
             (fun f ->
                Query.Pair
                  ("ImportVolume", (ImportVolumeTaskDetails.to_query f)));
           Util.option_map v.import_instance
             (fun f ->
                Query.Pair
                  ("ImportInstance", (ImportInstanceTaskDetails.to_query f)));
           Util.option_map v.expiration_time
             (fun f -> Query.Pair ("ExpirationTime", (String.to_query f)));
           Some
             (Query.Pair
                ("ConversionTaskId", (String.to_query v.conversion_task_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Some ("state", (ConversionTaskState.to_json v.state));
           Util.option_map v.import_volume
             (fun f -> ("import_volume", (ImportVolumeTaskDetails.to_json f)));
           Util.option_map v.import_instance
             (fun f ->
                ("import_instance", (ImportInstanceTaskDetails.to_json f)));
           Util.option_map v.expiration_time
             (fun f -> ("expiration_time", (String.to_json f)));
           Some ("conversion_task_id", (String.to_json v.conversion_task_id))])
    let of_json j =
      {
        conversion_task_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "conversion_task_id")));
        expiration_time =
          (Util.option_map (Json.lookup j "expiration_time") String.of_json);
        import_instance =
          (Util.option_map (Json.lookup j "import_instance")
             ImportInstanceTaskDetails.of_json);
        import_volume =
          (Util.option_map (Json.lookup j "import_volume")
             ImportVolumeTaskDetails.of_json);
        state =
          (ConversionTaskState.of_json
             (Util.of_option_exn (Json.lookup j "state")));
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module HistoryRecord =
  struct
    type t =
      {
      timestamp: DateTime.t ;
      event_type: EventType.t ;
      event_information: EventInformation.t }
    let make ~timestamp  ~event_type  ~event_information  () =
      { timestamp; event_type; event_information }
    let parse xml =
      Some
        {
          timestamp =
            (Xml.required "timestamp"
               (Util.option_bind (Xml.member "timestamp" xml) DateTime.parse));
          event_type =
            (Xml.required "eventType"
               (Util.option_bind (Xml.member "eventType" xml) EventType.parse));
          event_information =
            (Xml.required "eventInformation"
               (Util.option_bind (Xml.member "eventInformation" xml)
                  EventInformation.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("EventInformation",
                   (EventInformation.to_query v.event_information)));
           Some (Query.Pair ("EventType", (EventType.to_query v.event_type)));
           Some (Query.Pair ("Timestamp", (DateTime.to_query v.timestamp)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("event_information",
                (EventInformation.to_json v.event_information));
           Some ("event_type", (EventType.to_json v.event_type));
           Some ("timestamp", (DateTime.to_json v.timestamp))])
    let of_json j =
      {
        timestamp =
          (DateTime.of_json (Util.of_option_exn (Json.lookup j "timestamp")));
        event_type =
          (EventType.of_json
             (Util.of_option_exn (Json.lookup j "event_type")));
        event_information =
          (EventInformation.of_json
             (Util.of_option_exn (Json.lookup j "event_information")))
      }
  end
module UnsuccessfulItem =
  struct
    type t = {
      resource_id: String.t option ;
      error: UnsuccessfulItemError.t }
    let make ?resource_id  ~error  () = { resource_id; error }
    let parse xml =
      Some
        {
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          error =
            (Xml.required "error"
               (Util.option_bind (Xml.member "error" xml)
                  UnsuccessfulItemError.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("Error", (UnsuccessfulItemError.to_query v.error)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("error", (UnsuccessfulItemError.to_json v.error));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)))])
    let of_json j =
      {
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        error =
          (UnsuccessfulItemError.of_json
             (Util.of_option_exn (Json.lookup j "error")))
      }
  end
module RouteTable =
  struct
    type t =
      {
      route_table_id: String.t option ;
      vpc_id: String.t option ;
      routes: RouteList.t ;
      associations: RouteTableAssociationList.t ;
      tags: TagList.t ;
      propagating_vgws: PropagatingVgwList.t }
    let make ?route_table_id  ?vpc_id  ?(routes= [])  ?(associations= []) 
      ?(tags= [])  ?(propagating_vgws= [])  () =
      { route_table_id; vpc_id; routes; associations; tags; propagating_vgws
      }
    let parse xml =
      Some
        {
          route_table_id =
            (Util.option_bind (Xml.member "routeTableId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          routes =
            (Util.of_option []
               (Util.option_bind (Xml.member "routeSet" xml) RouteList.parse));
          associations =
            (Util.of_option []
               (Util.option_bind (Xml.member "associationSet" xml)
                  RouteTableAssociationList.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          propagating_vgws =
            (Util.of_option []
               (Util.option_bind (Xml.member "propagatingVgwSet" xml)
                  PropagatingVgwList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PropagatingVgwSet",
                   (PropagatingVgwList.to_query v.propagating_vgws)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("AssociationSet",
                  (RouteTableAssociationList.to_query v.associations)));
           Some (Query.Pair ("RouteSet", (RouteList.to_query v.routes)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.route_table_id
             (fun f -> Query.Pair ("RouteTableId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("propagating_vgws",
                (PropagatingVgwList.to_json v.propagating_vgws));
           Some ("tags", (TagList.to_json v.tags));
           Some
             ("associations",
               (RouteTableAssociationList.to_json v.associations));
           Some ("routes", (RouteList.to_json v.routes));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.route_table_id
             (fun f -> ("route_table_id", (String.to_json f)))])
    let of_json j =
      {
        route_table_id =
          (Util.option_map (Json.lookup j "route_table_id") String.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        routes =
          (RouteList.of_json (Util.of_option_exn (Json.lookup j "routes")));
        associations =
          (RouteTableAssociationList.of_json
             (Util.of_option_exn (Json.lookup j "associations")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        propagating_vgws =
          (PropagatingVgwList.of_json
             (Util.of_option_exn (Json.lookup j "propagating_vgws")))
      }
  end
module ReservedInstancesListing =
  struct
    type t =
      {
      reserved_instances_listing_id: String.t option ;
      reserved_instances_id: String.t option ;
      create_date: DateTime.t option ;
      update_date: DateTime.t option ;
      status: ListingStatus.t option ;
      status_message: String.t option ;
      instance_counts: InstanceCountList.t ;
      price_schedules: PriceScheduleList.t ;
      tags: TagList.t ;
      client_token: String.t option }
    let make ?reserved_instances_listing_id  ?reserved_instances_id 
      ?create_date  ?update_date  ?status  ?status_message 
      ?(instance_counts= [])  ?(price_schedules= [])  ?(tags= []) 
      ?client_token  () =
      {
        reserved_instances_listing_id;
        reserved_instances_id;
        create_date;
        update_date;
        status;
        status_message;
        instance_counts;
        price_schedules;
        tags;
        client_token
      }
    let parse xml =
      Some
        {
          reserved_instances_listing_id =
            (Util.option_bind (Xml.member "reservedInstancesListingId" xml)
               String.parse);
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse);
          create_date =
            (Util.option_bind (Xml.member "createDate" xml) DateTime.parse);
          update_date =
            (Util.option_bind (Xml.member "updateDate" xml) DateTime.parse);
          status =
            (Util.option_bind (Xml.member "status" xml) ListingStatus.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          instance_counts =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceCounts" xml)
                  InstanceCountList.parse));
          price_schedules =
            (Util.of_option []
               (Util.option_bind (Xml.member "priceSchedules" xml)
                  PriceScheduleList.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("PriceSchedules",
                  (PriceScheduleList.to_query v.price_schedules)));
           Some
             (Query.Pair
                ("InstanceCounts",
                  (InstanceCountList.to_query v.instance_counts)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (ListingStatus.to_query f)));
           Util.option_map v.update_date
             (fun f -> Query.Pair ("UpdateDate", (DateTime.to_query f)));
           Util.option_map v.create_date
             (fun f -> Query.Pair ("CreateDate", (DateTime.to_query f)));
           Util.option_map v.reserved_instances_id
             (fun f ->
                Query.Pair ("ReservedInstancesId", (String.to_query f)));
           Util.option_map v.reserved_instances_listing_id
             (fun f ->
                Query.Pair
                  ("ReservedInstancesListingId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Some
             ("price_schedules",
               (PriceScheduleList.to_json v.price_schedules));
           Some
             ("instance_counts",
               (InstanceCountList.to_json v.instance_counts));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (ListingStatus.to_json f)));
           Util.option_map v.update_date
             (fun f -> ("update_date", (DateTime.to_json f)));
           Util.option_map v.create_date
             (fun f -> ("create_date", (DateTime.to_json f)));
           Util.option_map v.reserved_instances_id
             (fun f -> ("reserved_instances_id", (String.to_json f)));
           Util.option_map v.reserved_instances_listing_id
             (fun f -> ("reserved_instances_listing_id", (String.to_json f)))])
    let of_json j =
      {
        reserved_instances_listing_id =
          (Util.option_map (Json.lookup j "reserved_instances_listing_id")
             String.of_json);
        reserved_instances_id =
          (Util.option_map (Json.lookup j "reserved_instances_id")
             String.of_json);
        create_date =
          (Util.option_map (Json.lookup j "create_date") DateTime.of_json);
        update_date =
          (Util.option_map (Json.lookup j "update_date") DateTime.of_json);
        status =
          (Util.option_map (Json.lookup j "status") ListingStatus.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        instance_counts =
          (InstanceCountList.of_json
             (Util.of_option_exn (Json.lookup j "instance_counts")));
        price_schedules =
          (PriceScheduleList.of_json
             (Util.of_option_exn (Json.lookup j "price_schedules")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module InstanceStateChange =
  struct
    type t =
      {
      instance_id: String.t option ;
      current_state: InstanceState.t option ;
      previous_state: InstanceState.t option }
    let make ?instance_id  ?current_state  ?previous_state  () =
      { instance_id; current_state; previous_state }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          current_state =
            (Util.option_bind (Xml.member "currentState" xml)
               InstanceState.parse);
          previous_state =
            (Util.option_bind (Xml.member "previousState" xml)
               InstanceState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.previous_state
              (fun f ->
                 Query.Pair ("PreviousState", (InstanceState.to_query f)));
           Util.option_map v.current_state
             (fun f ->
                Query.Pair ("CurrentState", (InstanceState.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.previous_state
              (fun f -> ("previous_state", (InstanceState.to_json f)));
           Util.option_map v.current_state
             (fun f -> ("current_state", (InstanceState.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        current_state =
          (Util.option_map (Json.lookup j "current_state")
             InstanceState.of_json);
        previous_state =
          (Util.option_map (Json.lookup j "previous_state")
             InstanceState.of_json)
      }
  end
module MovingAddressStatus =
  struct
    type t = {
      public_ip: String.t option ;
      move_status: MoveStatus.t option }
    let make ?public_ip  ?move_status  () = { public_ip; move_status }
    let parse xml =
      Some
        {
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse);
          move_status =
            (Util.option_bind (Xml.member "moveStatus" xml) MoveStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.move_status
              (fun f -> Query.Pair ("MoveStatus", (MoveStatus.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("PublicIp", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.move_status
              (fun f -> ("move_status", (MoveStatus.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)))])
    let of_json j =
      {
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json);
        move_status =
          (Util.option_map (Json.lookup j "move_status") MoveStatus.of_json)
      }
  end
module InstanceStatus =
  struct
    type t =
      {
      instance_id: String.t option ;
      availability_zone: String.t option ;
      events: InstanceStatusEventList.t ;
      instance_state: InstanceState.t option ;
      system_status: InstanceStatusSummary.t option ;
      instance_status: InstanceStatusSummary.t option }
    let make ?instance_id  ?availability_zone  ?(events= [])  ?instance_state
       ?system_status  ?instance_status  () =
      {
        instance_id;
        availability_zone;
        events;
        instance_state;
        system_status;
        instance_status
      }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          events =
            (Util.of_option []
               (Util.option_bind (Xml.member "eventsSet" xml)
                  InstanceStatusEventList.parse));
          instance_state =
            (Util.option_bind (Xml.member "instanceState" xml)
               InstanceState.parse);
          system_status =
            (Util.option_bind (Xml.member "systemStatus" xml)
               InstanceStatusSummary.parse);
          instance_status =
            (Util.option_bind (Xml.member "instanceStatus" xml)
               InstanceStatusSummary.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_status
              (fun f ->
                 Query.Pair
                   ("InstanceStatus", (InstanceStatusSummary.to_query f)));
           Util.option_map v.system_status
             (fun f ->
                Query.Pair
                  ("SystemStatus", (InstanceStatusSummary.to_query f)));
           Util.option_map v.instance_state
             (fun f ->
                Query.Pair ("InstanceState", (InstanceState.to_query f)));
           Some
             (Query.Pair
                ("EventsSet", (InstanceStatusEventList.to_query v.events)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_status
              (fun f ->
                 ("instance_status", (InstanceStatusSummary.to_json f)));
           Util.option_map v.system_status
             (fun f -> ("system_status", (InstanceStatusSummary.to_json f)));
           Util.option_map v.instance_state
             (fun f -> ("instance_state", (InstanceState.to_json f)));
           Some ("events", (InstanceStatusEventList.to_json v.events));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        events =
          (InstanceStatusEventList.of_json
             (Util.of_option_exn (Json.lookup j "events")));
        instance_state =
          (Util.option_map (Json.lookup j "instance_state")
             InstanceState.of_json);
        system_status =
          (Util.option_map (Json.lookup j "system_status")
             InstanceStatusSummary.of_json);
        instance_status =
          (Util.option_map (Json.lookup j "instance_status")
             InstanceStatusSummary.of_json)
      }
  end
module Image =
  struct
    type t =
      {
      image_id: String.t ;
      image_location: String.t ;
      state: ImageState.t ;
      owner_id: String.t ;
      creation_date: String.t option ;
      public: Boolean.t ;
      product_codes: ProductCodeList.t ;
      architecture: ArchitectureValues.t ;
      image_type: ImageTypeValues.t ;
      kernel_id: String.t option ;
      ramdisk_id: String.t option ;
      platform: PlatformValues.t option ;
      sriov_net_support: String.t option ;
      state_reason: StateReason.t option ;
      image_owner_alias: String.t option ;
      name: String.t option ;
      description: String.t option ;
      root_device_type: DeviceType.t ;
      root_device_name: String.t option ;
      block_device_mappings: BlockDeviceMappingList.t ;
      virtualization_type: VirtualizationType.t ;
      tags: TagList.t ;
      hypervisor: HypervisorType.t }
    let make ~image_id  ~image_location  ~state  ~owner_id  ?creation_date 
      ~public  ?(product_codes= [])  ~architecture  ~image_type  ?kernel_id 
      ?ramdisk_id  ?platform  ?sriov_net_support  ?state_reason 
      ?image_owner_alias  ?name  ?description  ~root_device_type 
      ?root_device_name  ?(block_device_mappings= [])  ~virtualization_type 
      ?(tags= [])  ~hypervisor  () =
      {
        image_id;
        image_location;
        state;
        owner_id;
        creation_date;
        public;
        product_codes;
        architecture;
        image_type;
        kernel_id;
        ramdisk_id;
        platform;
        sriov_net_support;
        state_reason;
        image_owner_alias;
        name;
        description;
        root_device_type;
        root_device_name;
        block_device_mappings;
        virtualization_type;
        tags;
        hypervisor
      }
    let parse xml =
      Some
        {
          image_id =
            (Xml.required "imageId"
               (Util.option_bind (Xml.member "imageId" xml) String.parse));
          image_location =
            (Xml.required "imageLocation"
               (Util.option_bind (Xml.member "imageLocation" xml)
                  String.parse));
          state =
            (Xml.required "imageState"
               (Util.option_bind (Xml.member "imageState" xml)
                  ImageState.parse));
          owner_id =
            (Xml.required "imageOwnerId"
               (Util.option_bind (Xml.member "imageOwnerId" xml) String.parse));
          creation_date =
            (Util.option_bind (Xml.member "creationDate" xml) String.parse);
          public =
            (Xml.required "isPublic"
               (Util.option_bind (Xml.member "isPublic" xml) Boolean.parse));
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse));
          architecture =
            (Xml.required "architecture"
               (Util.option_bind (Xml.member "architecture" xml)
                  ArchitectureValues.parse));
          image_type =
            (Xml.required "imageType"
               (Util.option_bind (Xml.member "imageType" xml)
                  ImageTypeValues.parse));
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdiskId" xml) String.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml)
               PlatformValues.parse);
          sriov_net_support =
            (Util.option_bind (Xml.member "sriovNetSupport" xml) String.parse);
          state_reason =
            (Util.option_bind (Xml.member "stateReason" xml)
               StateReason.parse);
          image_owner_alias =
            (Util.option_bind (Xml.member "imageOwnerAlias" xml) String.parse);
          name = (Util.option_bind (Xml.member "name" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          root_device_type =
            (Xml.required "rootDeviceType"
               (Util.option_bind (Xml.member "rootDeviceType" xml)
                  DeviceType.parse));
          root_device_name =
            (Util.option_bind (Xml.member "rootDeviceName" xml) String.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  BlockDeviceMappingList.parse));
          virtualization_type =
            (Xml.required "virtualizationType"
               (Util.option_bind (Xml.member "virtualizationType" xml)
                  VirtualizationType.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          hypervisor =
            (Xml.required "hypervisor"
               (Util.option_bind (Xml.member "hypervisor" xml)
                  HypervisorType.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Hypervisor", (HypervisorType.to_query v.hypervisor)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("VirtualizationType",
                  (VirtualizationType.to_query v.virtualization_type)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingList.to_query v.block_device_mappings)));
           Util.option_map v.root_device_name
             (fun f -> Query.Pair ("RootDeviceName", (String.to_query f)));
           Some
             (Query.Pair
                ("RootDeviceType", (DeviceType.to_query v.root_device_type)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.image_owner_alias
             (fun f -> Query.Pair ("ImageOwnerAlias", (String.to_query f)));
           Util.option_map v.state_reason
             (fun f -> Query.Pair ("StateReason", (StateReason.to_query f)));
           Util.option_map v.sriov_net_support
             (fun f -> Query.Pair ("SriovNetSupport", (String.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (PlatformValues.to_query f)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Some
             (Query.Pair
                ("ImageType", (ImageTypeValues.to_query v.image_type)));
           Some
             (Query.Pair
                ("Architecture",
                  (ArchitectureValues.to_query v.architecture)));
           Some
             (Query.Pair
                ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Some (Query.Pair ("IsPublic", (Boolean.to_query v.public)));
           Util.option_map v.creation_date
             (fun f -> Query.Pair ("CreationDate", (String.to_query f)));
           Some (Query.Pair ("ImageOwnerId", (String.to_query v.owner_id)));
           Some (Query.Pair ("ImageState", (ImageState.to_query v.state)));
           Some
             (Query.Pair
                ("ImageLocation", (String.to_query v.image_location)));
           Some (Query.Pair ("ImageId", (String.to_query v.image_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("hypervisor", (HypervisorType.to_json v.hypervisor));
           Some ("tags", (TagList.to_json v.tags));
           Some
             ("virtualization_type",
               (VirtualizationType.to_json v.virtualization_type));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingList.to_json v.block_device_mappings));
           Util.option_map v.root_device_name
             (fun f -> ("root_device_name", (String.to_json f)));
           Some ("root_device_type", (DeviceType.to_json v.root_device_type));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.image_owner_alias
             (fun f -> ("image_owner_alias", (String.to_json f)));
           Util.option_map v.state_reason
             (fun f -> ("state_reason", (StateReason.to_json f)));
           Util.option_map v.sriov_net_support
             (fun f -> ("sriov_net_support", (String.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (PlatformValues.to_json f)));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Some ("image_type", (ImageTypeValues.to_json v.image_type));
           Some ("architecture", (ArchitectureValues.to_json v.architecture));
           Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Some ("public", (Boolean.to_json v.public));
           Util.option_map v.creation_date
             (fun f -> ("creation_date", (String.to_json f)));
           Some ("owner_id", (String.to_json v.owner_id));
           Some ("state", (ImageState.to_json v.state));
           Some ("image_location", (String.to_json v.image_location));
           Some ("image_id", (String.to_json v.image_id))])
    let of_json j =
      {
        image_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "image_id")));
        image_location =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "image_location")));
        state =
          (ImageState.of_json (Util.of_option_exn (Json.lookup j "state")));
        owner_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "owner_id")));
        creation_date =
          (Util.option_map (Json.lookup j "creation_date") String.of_json);
        public =
          (Boolean.of_json (Util.of_option_exn (Json.lookup j "public")));
        product_codes =
          (ProductCodeList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")));
        architecture =
          (ArchitectureValues.of_json
             (Util.of_option_exn (Json.lookup j "architecture")));
        image_type =
          (ImageTypeValues.of_json
             (Util.of_option_exn (Json.lookup j "image_type")));
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id") String.of_json);
        platform =
          (Util.option_map (Json.lookup j "platform") PlatformValues.of_json);
        sriov_net_support =
          (Util.option_map (Json.lookup j "sriov_net_support") String.of_json);
        state_reason =
          (Util.option_map (Json.lookup j "state_reason") StateReason.of_json);
        image_owner_alias =
          (Util.option_map (Json.lookup j "image_owner_alias") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        root_device_type =
          (DeviceType.of_json
             (Util.of_option_exn (Json.lookup j "root_device_type")));
        root_device_name =
          (Util.option_map (Json.lookup j "root_device_name") String.of_json);
        block_device_mappings =
          (BlockDeviceMappingList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        virtualization_type =
          (VirtualizationType.of_json
             (Util.of_option_exn (Json.lookup j "virtualization_type")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        hypervisor =
          (HypervisorType.of_json
             (Util.of_option_exn (Json.lookup j "hypervisor")))
      }
  end
module PriceScheduleSpecification =
  struct
    type t =
      {
      term: Long.t option ;
      price: Double.t option ;
      currency_code: CurrencyCodeValues.t option }
    let make ?term  ?price  ?currency_code  () =
      { term; price; currency_code }
    let parse xml =
      Some
        {
          term = (Util.option_bind (Xml.member "term" xml) Long.parse);
          price = (Util.option_bind (Xml.member "price" xml) Double.parse);
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.currency_code
              (fun f ->
                 Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)));
           Util.option_map v.price
             (fun f -> Query.Pair ("Price", (Double.to_query f)));
           Util.option_map v.term
             (fun f -> Query.Pair ("Term", (Long.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.currency_code
              (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)));
           Util.option_map v.price (fun f -> ("price", (Double.to_json f)));
           Util.option_map v.term (fun f -> ("term", (Long.to_json f)))])
    let of_json j =
      {
        term = (Util.option_map (Json.lookup j "term") Long.of_json);
        price = (Util.option_map (Json.lookup j "price") Double.of_json);
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json)
      }
  end
module ImportSnapshotTask =
  struct
    type t =
      {
      import_task_id: String.t option ;
      snapshot_task_detail: SnapshotTaskDetail.t option ;
      description: String.t option }
    let make ?import_task_id  ?snapshot_task_detail  ?description  () =
      { import_task_id; snapshot_task_detail; description }
    let parse xml =
      Some
        {
          import_task_id =
            (Util.option_bind (Xml.member "importTaskId" xml) String.parse);
          snapshot_task_detail =
            (Util.option_bind (Xml.member "snapshotTaskDetail" xml)
               SnapshotTaskDetail.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.snapshot_task_detail
             (fun f ->
                Query.Pair
                  ("SnapshotTaskDetail", (SnapshotTaskDetail.to_query f)));
           Util.option_map v.import_task_id
             (fun f -> Query.Pair ("ImportTaskId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (String.to_json f)));
           Util.option_map v.snapshot_task_detail
             (fun f ->
                ("snapshot_task_detail", (SnapshotTaskDetail.to_json f)));
           Util.option_map v.import_task_id
             (fun f -> ("import_task_id", (String.to_json f)))])
    let of_json j =
      {
        import_task_id =
          (Util.option_map (Json.lookup j "import_task_id") String.of_json);
        snapshot_task_detail =
          (Util.option_map (Json.lookup j "snapshot_task_detail")
             SnapshotTaskDetail.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json)
      }
  end
module SpotInstanceRequest =
  struct
    type t =
      {
      spot_instance_request_id: String.t option ;
      spot_price: String.t option ;
      type_: SpotInstanceType.t option ;
      state: SpotInstanceState.t option ;
      fault: SpotInstanceStateFault.t option ;
      status: SpotInstanceStatus.t option ;
      valid_from: DateTime.t option ;
      valid_until: DateTime.t option ;
      launch_group: String.t option ;
      availability_zone_group: String.t option ;
      launch_specification: LaunchSpecification.t option ;
      instance_id: String.t option ;
      create_time: DateTime.t option ;
      product_description: RIProductDescription.t option ;
      tags: TagList.t ;
      launched_availability_zone: String.t option }
    let make ?spot_instance_request_id  ?spot_price  ?type_  ?state  ?fault 
      ?status  ?valid_from  ?valid_until  ?launch_group 
      ?availability_zone_group  ?launch_specification  ?instance_id 
      ?create_time  ?product_description  ?(tags= []) 
      ?launched_availability_zone  () =
      {
        spot_instance_request_id;
        spot_price;
        type_;
        state;
        fault;
        status;
        valid_from;
        valid_until;
        launch_group;
        availability_zone_group;
        launch_specification;
        instance_id;
        create_time;
        product_description;
        tags;
        launched_availability_zone
      }
    let parse xml =
      Some
        {
          spot_instance_request_id =
            (Util.option_bind (Xml.member "spotInstanceRequestId" xml)
               String.parse);
          spot_price =
            (Util.option_bind (Xml.member "spotPrice" xml) String.parse);
          type_ =
            (Util.option_bind (Xml.member "type" xml) SpotInstanceType.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               SpotInstanceState.parse);
          fault =
            (Util.option_bind (Xml.member "fault" xml)
               SpotInstanceStateFault.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               SpotInstanceStatus.parse);
          valid_from =
            (Util.option_bind (Xml.member "validFrom" xml) DateTime.parse);
          valid_until =
            (Util.option_bind (Xml.member "validUntil" xml) DateTime.parse);
          launch_group =
            (Util.option_bind (Xml.member "launchGroup" xml) String.parse);
          availability_zone_group =
            (Util.option_bind (Xml.member "availabilityZoneGroup" xml)
               String.parse);
          launch_specification =
            (Util.option_bind (Xml.member "launchSpecification" xml)
               LaunchSpecification.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          create_time =
            (Util.option_bind (Xml.member "createTime" xml) DateTime.parse);
          product_description =
            (Util.option_bind (Xml.member "productDescription" xml)
               RIProductDescription.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          launched_availability_zone =
            (Util.option_bind (Xml.member "launchedAvailabilityZone" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.launched_availability_zone
              (fun f ->
                 Query.Pair ("LaunchedAvailabilityZone", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.product_description
             (fun f ->
                Query.Pair
                  ("ProductDescription", (RIProductDescription.to_query f)));
           Util.option_map v.create_time
             (fun f -> Query.Pair ("CreateTime", (DateTime.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.launch_specification
             (fun f ->
                Query.Pair
                  ("LaunchSpecification", (LaunchSpecification.to_query f)));
           Util.option_map v.availability_zone_group
             (fun f ->
                Query.Pair ("AvailabilityZoneGroup", (String.to_query f)));
           Util.option_map v.launch_group
             (fun f -> Query.Pair ("LaunchGroup", (String.to_query f)));
           Util.option_map v.valid_until
             (fun f -> Query.Pair ("ValidUntil", (DateTime.to_query f)));
           Util.option_map v.valid_from
             (fun f -> Query.Pair ("ValidFrom", (DateTime.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (SpotInstanceStatus.to_query f)));
           Util.option_map v.fault
             (fun f ->
                Query.Pair ("Fault", (SpotInstanceStateFault.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (SpotInstanceState.to_query f)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (SpotInstanceType.to_query f)));
           Util.option_map v.spot_price
             (fun f -> Query.Pair ("SpotPrice", (String.to_query f)));
           Util.option_map v.spot_instance_request_id
             (fun f ->
                Query.Pair ("SpotInstanceRequestId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.launched_availability_zone
              (fun f -> ("launched_availability_zone", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.product_description
             (fun f ->
                ("product_description", (RIProductDescription.to_json f)));
           Util.option_map v.create_time
             (fun f -> ("create_time", (DateTime.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.launch_specification
             (fun f ->
                ("launch_specification", (LaunchSpecification.to_json f)));
           Util.option_map v.availability_zone_group
             (fun f -> ("availability_zone_group", (String.to_json f)));
           Util.option_map v.launch_group
             (fun f -> ("launch_group", (String.to_json f)));
           Util.option_map v.valid_until
             (fun f -> ("valid_until", (DateTime.to_json f)));
           Util.option_map v.valid_from
             (fun f -> ("valid_from", (DateTime.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (SpotInstanceStatus.to_json f)));
           Util.option_map v.fault
             (fun f -> ("fault", (SpotInstanceStateFault.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (SpotInstanceState.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (SpotInstanceType.to_json f)));
           Util.option_map v.spot_price
             (fun f -> ("spot_price", (String.to_json f)));
           Util.option_map v.spot_instance_request_id
             (fun f -> ("spot_instance_request_id", (String.to_json f)))])
    let of_json j =
      {
        spot_instance_request_id =
          (Util.option_map (Json.lookup j "spot_instance_request_id")
             String.of_json);
        spot_price =
          (Util.option_map (Json.lookup j "spot_price") String.of_json);
        type_ =
          (Util.option_map (Json.lookup j "type_") SpotInstanceType.of_json);
        state =
          (Util.option_map (Json.lookup j "state") SpotInstanceState.of_json);
        fault =
          (Util.option_map (Json.lookup j "fault")
             SpotInstanceStateFault.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             SpotInstanceStatus.of_json);
        valid_from =
          (Util.option_map (Json.lookup j "valid_from") DateTime.of_json);
        valid_until =
          (Util.option_map (Json.lookup j "valid_until") DateTime.of_json);
        launch_group =
          (Util.option_map (Json.lookup j "launch_group") String.of_json);
        availability_zone_group =
          (Util.option_map (Json.lookup j "availability_zone_group")
             String.of_json);
        launch_specification =
          (Util.option_map (Json.lookup j "launch_specification")
             LaunchSpecification.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        create_time =
          (Util.option_map (Json.lookup j "create_time") DateTime.of_json);
        product_description =
          (Util.option_map (Json.lookup j "product_description")
             RIProductDescription.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        launched_availability_zone =
          (Util.option_map (Json.lookup j "launched_availability_zone")
             String.of_json)
      }
  end
module ExportTask =
  struct
    type t =
      {
      export_task_id: String.t ;
      description: String.t ;
      state: ExportTaskState.t ;
      status_message: String.t ;
      instance_export_details: InstanceExportDetails.t ;
      export_to_s3_task: ExportToS3Task.t }
    let make ~export_task_id  ~description  ~state  ~status_message 
      ~instance_export_details  ~export_to_s3_task  () =
      {
        export_task_id;
        description;
        state;
        status_message;
        instance_export_details;
        export_to_s3_task
      }
    let parse xml =
      Some
        {
          export_task_id =
            (Xml.required "exportTaskId"
               (Util.option_bind (Xml.member "exportTaskId" xml) String.parse));
          description =
            (Xml.required "description"
               (Util.option_bind (Xml.member "description" xml) String.parse));
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml)
                  ExportTaskState.parse));
          status_message =
            (Xml.required "statusMessage"
               (Util.option_bind (Xml.member "statusMessage" xml)
                  String.parse));
          instance_export_details =
            (Xml.required "instanceExport"
               (Util.option_bind (Xml.member "instanceExport" xml)
                  InstanceExportDetails.parse));
          export_to_s3_task =
            (Xml.required "exportToS3"
               (Util.option_bind (Xml.member "exportToS3" xml)
                  ExportToS3Task.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ExportToS3",
                   (ExportToS3Task.to_query v.export_to_s3_task)));
           Some
             (Query.Pair
                ("InstanceExport",
                  (InstanceExportDetails.to_query v.instance_export_details)));
           Some
             (Query.Pair
                ("StatusMessage", (String.to_query v.status_message)));
           Some (Query.Pair ("State", (ExportTaskState.to_query v.state)));
           Some (Query.Pair ("Description", (String.to_query v.description)));
           Some
             (Query.Pair ("ExportTaskId", (String.to_query v.export_task_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("export_to_s3_task",
                (ExportToS3Task.to_json v.export_to_s3_task));
           Some
             ("instance_export_details",
               (InstanceExportDetails.to_json v.instance_export_details));
           Some ("status_message", (String.to_json v.status_message));
           Some ("state", (ExportTaskState.to_json v.state));
           Some ("description", (String.to_json v.description));
           Some ("export_task_id", (String.to_json v.export_task_id))])
    let of_json j =
      {
        export_task_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "export_task_id")));
        description =
          (String.of_json (Util.of_option_exn (Json.lookup j "description")));
        state =
          (ExportTaskState.of_json
             (Util.of_option_exn (Json.lookup j "state")));
        status_message =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "status_message")));
        instance_export_details =
          (InstanceExportDetails.of_json
             (Util.of_option_exn (Json.lookup j "instance_export_details")));
        export_to_s3_task =
          (ExportToS3Task.of_json
             (Util.of_option_exn (Json.lookup j "export_to_s3_task")))
      }
  end
module PrefixList =
  struct
    type t =
      {
      prefix_list_id: String.t option ;
      prefix_list_name: String.t option ;
      cidrs: ValueStringList.t }
    let make ?prefix_list_id  ?prefix_list_name  ?(cidrs= [])  () =
      { prefix_list_id; prefix_list_name; cidrs }
    let parse xml =
      Some
        {
          prefix_list_id =
            (Util.option_bind (Xml.member "prefixListId" xml) String.parse);
          prefix_list_name =
            (Util.option_bind (Xml.member "prefixListName" xml) String.parse);
          cidrs =
            (Util.of_option []
               (Util.option_bind (Xml.member "cidrSet" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("CidrSet", (ValueStringList.to_query v.cidrs)));
           Util.option_map v.prefix_list_name
             (fun f -> Query.Pair ("PrefixListName", (String.to_query f)));
           Util.option_map v.prefix_list_id
             (fun f -> Query.Pair ("PrefixListId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("cidrs", (ValueStringList.to_json v.cidrs));
           Util.option_map v.prefix_list_name
             (fun f -> ("prefix_list_name", (String.to_json f)));
           Util.option_map v.prefix_list_id
             (fun f -> ("prefix_list_id", (String.to_json f)))])
    let of_json j =
      {
        prefix_list_id =
          (Util.option_map (Json.lookup j "prefix_list_id") String.of_json);
        prefix_list_name =
          (Util.option_map (Json.lookup j "prefix_list_name") String.of_json);
        cidrs =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "cidrs")))
      }
  end
module InstanceMonitoring =
  struct
    type t = {
      instance_id: String.t option ;
      monitoring: Monitoring.t option }
    let make ?instance_id  ?monitoring  () = { instance_id; monitoring }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          monitoring =
            (Util.option_bind (Xml.member "monitoring" xml) Monitoring.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.monitoring
              (fun f -> Query.Pair ("Monitoring", (Monitoring.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.monitoring
              (fun f -> ("monitoring", (Monitoring.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        monitoring =
          (Util.option_map (Json.lookup j "monitoring") Monitoring.of_json)
      }
  end
module SecurityGroup =
  struct
    type t =
      {
      owner_id: String.t ;
      group_name: String.t ;
      group_id: String.t ;
      description: String.t ;
      ip_permissions: IpPermissionList.t ;
      ip_permissions_egress: IpPermissionList.t ;
      vpc_id: String.t option ;
      tags: TagList.t }
    let make ~owner_id  ~group_name  ~group_id  ~description 
      ?(ip_permissions= [])  ?(ip_permissions_egress= [])  ?vpc_id  ?(tags=
      [])  () =
      {
        owner_id;
        group_name;
        group_id;
        description;
        ip_permissions;
        ip_permissions_egress;
        vpc_id;
        tags
      }
    let parse xml =
      Some
        {
          owner_id =
            (Xml.required "ownerId"
               (Util.option_bind (Xml.member "ownerId" xml) String.parse));
          group_name =
            (Xml.required "groupName"
               (Util.option_bind (Xml.member "groupName" xml) String.parse));
          group_id =
            (Xml.required "groupId"
               (Util.option_bind (Xml.member "groupId" xml) String.parse));
          description =
            (Xml.required "groupDescription"
               (Util.option_bind (Xml.member "groupDescription" xml)
                  String.parse));
          ip_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipPermissions" xml)
                  IpPermissionList.parse));
          ip_permissions_egress =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipPermissionsEgress" xml)
                  IpPermissionList.parse));
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some
             (Query.Pair
                ("IpPermissionsEgress",
                  (IpPermissionList.to_query v.ip_permissions_egress)));
           Some
             (Query.Pair
                ("IpPermissions",
                  (IpPermissionList.to_query v.ip_permissions)));
           Some
             (Query.Pair
                ("GroupDescription", (String.to_query v.description)));
           Some (Query.Pair ("GroupId", (String.to_query v.group_id)));
           Some (Query.Pair ("GroupName", (String.to_query v.group_name)));
           Some (Query.Pair ("OwnerId", (String.to_query v.owner_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Some
             ("ip_permissions_egress",
               (IpPermissionList.to_json v.ip_permissions_egress));
           Some
             ("ip_permissions", (IpPermissionList.to_json v.ip_permissions));
           Some ("description", (String.to_json v.description));
           Some ("group_id", (String.to_json v.group_id));
           Some ("group_name", (String.to_json v.group_name));
           Some ("owner_id", (String.to_json v.owner_id))])
    let of_json j =
      {
        owner_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "owner_id")));
        group_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "group_name")));
        group_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "group_id")));
        description =
          (String.of_json (Util.of_option_exn (Json.lookup j "description")));
        ip_permissions =
          (IpPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "ip_permissions")));
        ip_permissions_egress =
          (IpPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "ip_permissions_egress")));
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module ActiveInstance =
  struct
    type t =
      {
      instance_type: String.t option ;
      instance_id: String.t option ;
      spot_instance_request_id: String.t option }
    let make ?instance_type  ?instance_id  ?spot_instance_request_id  () =
      { instance_type; instance_id; spot_instance_request_id }
    let parse xml =
      Some
        {
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          spot_instance_request_id =
            (Util.option_bind (Xml.member "spotInstanceRequestId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_instance_request_id
              (fun f ->
                 Query.Pair ("SpotInstanceRequestId", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_instance_request_id
              (fun f -> ("spot_instance_request_id", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)))])
    let of_json j =
      {
        instance_type =
          (Util.option_map (Json.lookup j "instance_type") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        spot_instance_request_id =
          (Util.option_map (Json.lookup j "spot_instance_request_id")
             String.of_json)
      }
  end
module InstanceBlockDeviceMappingSpecification =
  struct
    type t =
      {
      device_name: String.t option ;
      ebs: EbsInstanceBlockDeviceSpecification.t option ;
      virtual_name: String.t option ;
      no_device: String.t option }
    let make ?device_name  ?ebs  ?virtual_name  ?no_device  () =
      { device_name; ebs; virtual_name; no_device }
    let parse xml =
      Some
        {
          device_name =
            (Util.option_bind (Xml.member "deviceName" xml) String.parse);
          ebs =
            (Util.option_bind (Xml.member "ebs" xml)
               EbsInstanceBlockDeviceSpecification.parse);
          virtual_name =
            (Util.option_bind (Xml.member "virtualName" xml) String.parse);
          no_device =
            (Util.option_bind (Xml.member "noDevice" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.no_device
              (fun f -> Query.Pair ("NoDevice", (String.to_query f)));
           Util.option_map v.virtual_name
             (fun f -> Query.Pair ("VirtualName", (String.to_query f)));
           Util.option_map v.ebs
             (fun f ->
                Query.Pair
                  ("Ebs", (EbsInstanceBlockDeviceSpecification.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.no_device
              (fun f -> ("no_device", (String.to_json f)));
           Util.option_map v.virtual_name
             (fun f -> ("virtual_name", (String.to_json f)));
           Util.option_map v.ebs
             (fun f ->
                ("ebs", (EbsInstanceBlockDeviceSpecification.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)))])
    let of_json j =
      {
        device_name =
          (Util.option_map (Json.lookup j "device_name") String.of_json);
        ebs =
          (Util.option_map (Json.lookup j "ebs")
             EbsInstanceBlockDeviceSpecification.of_json);
        virtual_name =
          (Util.option_map (Json.lookup j "virtual_name") String.of_json);
        no_device =
          (Util.option_map (Json.lookup j "no_device") String.of_json)
      }
  end
module InternetGateway =
  struct
    type t =
      {
      internet_gateway_id: String.t ;
      attachments: InternetGatewayAttachmentList.t ;
      tags: TagList.t }
    let make ~internet_gateway_id  ?(attachments= [])  ?(tags= [])  () =
      { internet_gateway_id; attachments; tags }
    let parse xml =
      Some
        {
          internet_gateway_id =
            (Xml.required "internetGatewayId"
               (Util.option_bind (Xml.member "internetGatewayId" xml)
                  String.parse));
          attachments =
            (Util.of_option []
               (Util.option_bind (Xml.member "attachmentSet" xml)
                  InternetGatewayAttachmentList.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("AttachmentSet",
                  (InternetGatewayAttachmentList.to_query v.attachments)));
           Some
             (Query.Pair
                ("InternetGatewayId",
                  (String.to_query v.internet_gateway_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Some
             ("attachments",
               (InternetGatewayAttachmentList.to_json v.attachments));
           Some
             ("internet_gateway_id", (String.to_json v.internet_gateway_id))])
    let of_json j =
      {
        internet_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "internet_gateway_id")));
        attachments =
          (InternetGatewayAttachmentList.of_json
             (Util.of_option_exn (Json.lookup j "attachments")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module AccountAttributeName =
  struct
    type t =
      | Supported_platforms 
      | Default_vpc 
    let str_to_t =
      [("default-vpc", Default_vpc);
      ("supported-platforms", Supported_platforms)]
    let t_to_str =
      [(Default_vpc, "default-vpc");
      (Supported_platforms, "supported-platforms")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SpotFleetRequestConfig =
  struct
    type t =
      {
      spot_fleet_request_id: String.t ;
      spot_fleet_request_state: BatchState.t ;
      spot_fleet_request_config: SpotFleetRequestConfigData.t }
    let make ~spot_fleet_request_id  ~spot_fleet_request_state 
      ~spot_fleet_request_config  () =
      {
        spot_fleet_request_id;
        spot_fleet_request_state;
        spot_fleet_request_config
      }
    let parse xml =
      Some
        {
          spot_fleet_request_id =
            (Xml.required "spotFleetRequestId"
               (Util.option_bind (Xml.member "spotFleetRequestId" xml)
                  String.parse));
          spot_fleet_request_state =
            (Xml.required "spotFleetRequestState"
               (Util.option_bind (Xml.member "spotFleetRequestState" xml)
                  BatchState.parse));
          spot_fleet_request_config =
            (Xml.required "spotFleetRequestConfig"
               (Util.option_bind (Xml.member "spotFleetRequestConfig" xml)
                  SpotFleetRequestConfigData.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotFleetRequestConfig",
                   (SpotFleetRequestConfigData.to_query
                      v.spot_fleet_request_config)));
           Some
             (Query.Pair
                ("SpotFleetRequestState",
                  (BatchState.to_query v.spot_fleet_request_state)));
           Some
             (Query.Pair
                ("SpotFleetRequestId",
                  (String.to_query v.spot_fleet_request_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("spot_fleet_request_config",
                (SpotFleetRequestConfigData.to_json
                   v.spot_fleet_request_config));
           Some
             ("spot_fleet_request_state",
               (BatchState.to_json v.spot_fleet_request_state));
           Some
             ("spot_fleet_request_id",
               (String.to_json v.spot_fleet_request_id))])
    let of_json j =
      {
        spot_fleet_request_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_id")));
        spot_fleet_request_state =
          (BatchState.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_state")));
        spot_fleet_request_config =
          (SpotFleetRequestConfigData.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_config")))
      }
  end
module AvailabilityZone =
  struct
    type t =
      {
      zone_name: String.t option ;
      state: AvailabilityZoneState.t option ;
      region_name: String.t option ;
      messages: AvailabilityZoneMessageList.t }
    let make ?zone_name  ?state  ?region_name  ?(messages= [])  () =
      { zone_name; state; region_name; messages }
    let parse xml =
      Some
        {
          zone_name =
            (Util.option_bind (Xml.member "zoneName" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "zoneState" xml)
               AvailabilityZoneState.parse);
          region_name =
            (Util.option_bind (Xml.member "regionName" xml) String.parse);
          messages =
            (Util.of_option []
               (Util.option_bind (Xml.member "messageSet" xml)
                  AvailabilityZoneMessageList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("MessageSet",
                   (AvailabilityZoneMessageList.to_query v.messages)));
           Util.option_map v.region_name
             (fun f -> Query.Pair ("RegionName", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("ZoneState", (AvailabilityZoneState.to_query f)));
           Util.option_map v.zone_name
             (fun f -> Query.Pair ("ZoneName", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("messages", (AvailabilityZoneMessageList.to_json v.messages));
           Util.option_map v.region_name
             (fun f -> ("region_name", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (AvailabilityZoneState.to_json f)));
           Util.option_map v.zone_name
             (fun f -> ("zone_name", (String.to_json f)))])
    let of_json j =
      {
        zone_name =
          (Util.option_map (Json.lookup j "zone_name") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             AvailabilityZoneState.of_json);
        region_name =
          (Util.option_map (Json.lookup j "region_name") String.of_json);
        messages =
          (AvailabilityZoneMessageList.of_json
             (Util.of_option_exn (Json.lookup j "messages")))
      }
  end
module CustomerGateway =
  struct
    type t =
      {
      customer_gateway_id: String.t ;
      state: String.t ;
      type_: String.t ;
      ip_address: String.t ;
      bgp_asn: String.t ;
      tags: TagList.t }
    let make ~customer_gateway_id  ~state  ~type_  ~ip_address  ~bgp_asn 
      ?(tags= [])  () =
      { customer_gateway_id; state; type_; ip_address; bgp_asn; tags }
    let parse xml =
      Some
        {
          customer_gateway_id =
            (Xml.required "customerGatewayId"
               (Util.option_bind (Xml.member "customerGatewayId" xml)
                  String.parse));
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml) String.parse));
          type_ =
            (Xml.required "type"
               (Util.option_bind (Xml.member "type" xml) String.parse));
          ip_address =
            (Xml.required "ipAddress"
               (Util.option_bind (Xml.member "ipAddress" xml) String.parse));
          bgp_asn =
            (Xml.required "bgpAsn"
               (Util.option_bind (Xml.member "bgpAsn" xml) String.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some (Query.Pair ("BgpAsn", (String.to_query v.bgp_asn)));
           Some (Query.Pair ("IpAddress", (String.to_query v.ip_address)));
           Some (Query.Pair ("Type", (String.to_query v.type_)));
           Some (Query.Pair ("State", (String.to_query v.state)));
           Some
             (Query.Pair
                ("CustomerGatewayId",
                  (String.to_query v.customer_gateway_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Some ("bgp_asn", (String.to_json v.bgp_asn));
           Some ("ip_address", (String.to_json v.ip_address));
           Some ("type_", (String.to_json v.type_));
           Some ("state", (String.to_json v.state));
           Some
             ("customer_gateway_id", (String.to_json v.customer_gateway_id))])
    let of_json j =
      {
        customer_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "customer_gateway_id")));
        state = (String.of_json (Util.of_option_exn (Json.lookup j "state")));
        type_ = (String.of_json (Util.of_option_exn (Json.lookup j "type_")));
        ip_address =
          (String.of_json (Util.of_option_exn (Json.lookup j "ip_address")));
        bgp_asn =
          (String.of_json (Util.of_option_exn (Json.lookup j "bgp_asn")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module FlowLog =
  struct
    type t =
      {
      creation_time: DateTime.t option ;
      flow_log_id: String.t option ;
      flow_log_status: String.t option ;
      resource_id: String.t option ;
      traffic_type: TrafficType.t option ;
      log_group_name: String.t option ;
      deliver_logs_status: String.t option ;
      deliver_logs_error_message: String.t option ;
      deliver_logs_permission_arn: String.t option }
    let make ?creation_time  ?flow_log_id  ?flow_log_status  ?resource_id 
      ?traffic_type  ?log_group_name  ?deliver_logs_status 
      ?deliver_logs_error_message  ?deliver_logs_permission_arn  () =
      {
        creation_time;
        flow_log_id;
        flow_log_status;
        resource_id;
        traffic_type;
        log_group_name;
        deliver_logs_status;
        deliver_logs_error_message;
        deliver_logs_permission_arn
      }
    let parse xml =
      Some
        {
          creation_time =
            (Util.option_bind (Xml.member "creationTime" xml) DateTime.parse);
          flow_log_id =
            (Util.option_bind (Xml.member "flowLogId" xml) String.parse);
          flow_log_status =
            (Util.option_bind (Xml.member "flowLogStatus" xml) String.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          traffic_type =
            (Util.option_bind (Xml.member "trafficType" xml)
               TrafficType.parse);
          log_group_name =
            (Util.option_bind (Xml.member "logGroupName" xml) String.parse);
          deliver_logs_status =
            (Util.option_bind (Xml.member "deliverLogsStatus" xml)
               String.parse);
          deliver_logs_error_message =
            (Util.option_bind (Xml.member "deliverLogsErrorMessage" xml)
               String.parse);
          deliver_logs_permission_arn =
            (Util.option_bind (Xml.member "deliverLogsPermissionArn" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.deliver_logs_permission_arn
              (fun f ->
                 Query.Pair ("DeliverLogsPermissionArn", (String.to_query f)));
           Util.option_map v.deliver_logs_error_message
             (fun f ->
                Query.Pair ("DeliverLogsErrorMessage", (String.to_query f)));
           Util.option_map v.deliver_logs_status
             (fun f -> Query.Pair ("DeliverLogsStatus", (String.to_query f)));
           Util.option_map v.log_group_name
             (fun f -> Query.Pair ("LogGroupName", (String.to_query f)));
           Util.option_map v.traffic_type
             (fun f -> Query.Pair ("TrafficType", (TrafficType.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.flow_log_status
             (fun f -> Query.Pair ("FlowLogStatus", (String.to_query f)));
           Util.option_map v.flow_log_id
             (fun f -> Query.Pair ("FlowLogId", (String.to_query f)));
           Util.option_map v.creation_time
             (fun f -> Query.Pair ("CreationTime", (DateTime.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.deliver_logs_permission_arn
              (fun f -> ("deliver_logs_permission_arn", (String.to_json f)));
           Util.option_map v.deliver_logs_error_message
             (fun f -> ("deliver_logs_error_message", (String.to_json f)));
           Util.option_map v.deliver_logs_status
             (fun f -> ("deliver_logs_status", (String.to_json f)));
           Util.option_map v.log_group_name
             (fun f -> ("log_group_name", (String.to_json f)));
           Util.option_map v.traffic_type
             (fun f -> ("traffic_type", (TrafficType.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.flow_log_status
             (fun f -> ("flow_log_status", (String.to_json f)));
           Util.option_map v.flow_log_id
             (fun f -> ("flow_log_id", (String.to_json f)));
           Util.option_map v.creation_time
             (fun f -> ("creation_time", (DateTime.to_json f)))])
    let of_json j =
      {
        creation_time =
          (Util.option_map (Json.lookup j "creation_time") DateTime.of_json);
        flow_log_id =
          (Util.option_map (Json.lookup j "flow_log_id") String.of_json);
        flow_log_status =
          (Util.option_map (Json.lookup j "flow_log_status") String.of_json);
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        traffic_type =
          (Util.option_map (Json.lookup j "traffic_type") TrafficType.of_json);
        log_group_name =
          (Util.option_map (Json.lookup j "log_group_name") String.of_json);
        deliver_logs_status =
          (Util.option_map (Json.lookup j "deliver_logs_status")
             String.of_json);
        deliver_logs_error_message =
          (Util.option_map (Json.lookup j "deliver_logs_error_message")
             String.of_json);
        deliver_logs_permission_arn =
          (Util.option_map (Json.lookup j "deliver_logs_permission_arn")
             String.of_json)
      }
  end
module BundleTask =
  struct
    type t =
      {
      instance_id: String.t ;
      bundle_id: String.t ;
      state: BundleTaskState.t ;
      start_time: DateTime.t ;
      update_time: DateTime.t ;
      storage: Storage.t ;
      progress: String.t ;
      bundle_task_error: BundleTaskError.t option }
    let make ~instance_id  ~bundle_id  ~state  ~start_time  ~update_time 
      ~storage  ~progress  ?bundle_task_error  () =
      {
        instance_id;
        bundle_id;
        state;
        start_time;
        update_time;
        storage;
        progress;
        bundle_task_error
      }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          bundle_id =
            (Xml.required "bundleId"
               (Util.option_bind (Xml.member "bundleId" xml) String.parse));
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml)
                  BundleTaskState.parse));
          start_time =
            (Xml.required "startTime"
               (Util.option_bind (Xml.member "startTime" xml) DateTime.parse));
          update_time =
            (Xml.required "updateTime"
               (Util.option_bind (Xml.member "updateTime" xml) DateTime.parse));
          storage =
            (Xml.required "storage"
               (Util.option_bind (Xml.member "storage" xml) Storage.parse));
          progress =
            (Xml.required "progress"
               (Util.option_bind (Xml.member "progress" xml) String.parse));
          bundle_task_error =
            (Util.option_bind (Xml.member "error" xml) BundleTaskError.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.bundle_task_error
              (fun f -> Query.Pair ("Error", (BundleTaskError.to_query f)));
           Some (Query.Pair ("Progress", (String.to_query v.progress)));
           Some (Query.Pair ("Storage", (Storage.to_query v.storage)));
           Some
             (Query.Pair ("UpdateTime", (DateTime.to_query v.update_time)));
           Some (Query.Pair ("StartTime", (DateTime.to_query v.start_time)));
           Some (Query.Pair ("State", (BundleTaskState.to_query v.state)));
           Some (Query.Pair ("BundleId", (String.to_query v.bundle_id)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.bundle_task_error
              (fun f -> ("bundle_task_error", (BundleTaskError.to_json f)));
           Some ("progress", (String.to_json v.progress));
           Some ("storage", (Storage.to_json v.storage));
           Some ("update_time", (DateTime.to_json v.update_time));
           Some ("start_time", (DateTime.to_json v.start_time));
           Some ("state", (BundleTaskState.to_json v.state));
           Some ("bundle_id", (String.to_json v.bundle_id));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        bundle_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "bundle_id")));
        state =
          (BundleTaskState.of_json
             (Util.of_option_exn (Json.lookup j "state")));
        start_time =
          (DateTime.of_json (Util.of_option_exn (Json.lookup j "start_time")));
        update_time =
          (DateTime.of_json
             (Util.of_option_exn (Json.lookup j "update_time")));
        storage =
          (Storage.of_json (Util.of_option_exn (Json.lookup j "storage")));
        progress =
          (String.of_json (Util.of_option_exn (Json.lookup j "progress")));
        bundle_task_error =
          (Util.option_map (Json.lookup j "bundle_task_error")
             BundleTaskError.of_json)
      }
  end
module VolumeStatusItem =
  struct
    type t =
      {
      volume_id: String.t option ;
      availability_zone: String.t option ;
      volume_status: VolumeStatusInfo.t option ;
      events: VolumeStatusEventsList.t ;
      actions: VolumeStatusActionsList.t }
    let make ?volume_id  ?availability_zone  ?volume_status  ?(events= []) 
      ?(actions= [])  () =
      { volume_id; availability_zone; volume_status; events; actions }
    let parse xml =
      Some
        {
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          volume_status =
            (Util.option_bind (Xml.member "volumeStatus" xml)
               VolumeStatusInfo.parse);
          events =
            (Util.of_option []
               (Util.option_bind (Xml.member "eventsSet" xml)
                  VolumeStatusEventsList.parse));
          actions =
            (Util.of_option []
               (Util.option_bind (Xml.member "actionsSet" xml)
                  VolumeStatusActionsList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ActionsSet", (VolumeStatusActionsList.to_query v.actions)));
           Some
             (Query.Pair
                ("EventsSet", (VolumeStatusEventsList.to_query v.events)));
           Util.option_map v.volume_status
             (fun f ->
                Query.Pair ("VolumeStatus", (VolumeStatusInfo.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.volume_id
             (fun f -> Query.Pair ("VolumeId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("actions", (VolumeStatusActionsList.to_json v.actions));
           Some ("events", (VolumeStatusEventsList.to_json v.events));
           Util.option_map v.volume_status
             (fun f -> ("volume_status", (VolumeStatusInfo.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.volume_id
             (fun f -> ("volume_id", (String.to_json f)))])
    let of_json j =
      {
        volume_id =
          (Util.option_map (Json.lookup j "volume_id") String.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        volume_status =
          (Util.option_map (Json.lookup j "volume_status")
             VolumeStatusInfo.of_json);
        events =
          (VolumeStatusEventsList.of_json
             (Util.of_option_exn (Json.lookup j "events")));
        actions =
          (VolumeStatusActionsList.of_json
             (Util.of_option_exn (Json.lookup j "actions")))
      }
  end
module CreateVolumePermissionList =
  struct
    type t = CreateVolumePermission.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CreateVolumePermission.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list CreateVolumePermission.to_query v
    let to_json v = `List (List.map CreateVolumePermission.to_json v)
    let of_json j = Json.to_list CreateVolumePermission.of_json j
  end
module Volume =
  struct
    type t =
      {
      volume_id: String.t ;
      size: Integer.t ;
      snapshot_id: String.t ;
      availability_zone: String.t ;
      state: VolumeState.t ;
      create_time: DateTime.t ;
      attachments: VolumeAttachmentList.t ;
      tags: TagList.t ;
      volume_type: VolumeType.t ;
      iops: Integer.t option ;
      encrypted: Boolean.t ;
      kms_key_id: String.t option }
    let make ~volume_id  ~size  ~snapshot_id  ~availability_zone  ~state 
      ~create_time  ?(attachments= [])  ?(tags= [])  ~volume_type  ?iops 
      ~encrypted  ?kms_key_id  () =
      {
        volume_id;
        size;
        snapshot_id;
        availability_zone;
        state;
        create_time;
        attachments;
        tags;
        volume_type;
        iops;
        encrypted;
        kms_key_id
      }
    let parse xml =
      Some
        {
          volume_id =
            (Xml.required "volumeId"
               (Util.option_bind (Xml.member "volumeId" xml) String.parse));
          size =
            (Xml.required "size"
               (Util.option_bind (Xml.member "size" xml) Integer.parse));
          snapshot_id =
            (Xml.required "snapshotId"
               (Util.option_bind (Xml.member "snapshotId" xml) String.parse));
          availability_zone =
            (Xml.required "availabilityZone"
               (Util.option_bind (Xml.member "availabilityZone" xml)
                  String.parse));
          state =
            (Xml.required "status"
               (Util.option_bind (Xml.member "status" xml) VolumeState.parse));
          create_time =
            (Xml.required "createTime"
               (Util.option_bind (Xml.member "createTime" xml) DateTime.parse));
          attachments =
            (Util.of_option []
               (Util.option_bind (Xml.member "attachmentSet" xml)
                  VolumeAttachmentList.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          volume_type =
            (Xml.required "volumeType"
               (Util.option_bind (Xml.member "volumeType" xml)
                  VolumeType.parse));
          iops = (Util.option_bind (Xml.member "iops" xml) Integer.parse);
          encrypted =
            (Xml.required "encrypted"
               (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse));
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Some (Query.Pair ("Encrypted", (Boolean.to_query v.encrypted)));
           Util.option_map v.iops
             (fun f -> Query.Pair ("Iops", (Integer.to_query f)));
           Some
             (Query.Pair ("VolumeType", (VolumeType.to_query v.volume_type)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("AttachmentSet",
                  (VolumeAttachmentList.to_query v.attachments)));
           Some
             (Query.Pair ("CreateTime", (DateTime.to_query v.create_time)));
           Some (Query.Pair ("Status", (VolumeState.to_query v.state)));
           Some
             (Query.Pair
                ("AvailabilityZone", (String.to_query v.availability_zone)));
           Some (Query.Pair ("SnapshotId", (String.to_query v.snapshot_id)));
           Some (Query.Pair ("Size", (Integer.to_query v.size)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> ("kms_key_id", (String.to_json f)));
           Some ("encrypted", (Boolean.to_json v.encrypted));
           Util.option_map v.iops (fun f -> ("iops", (Integer.to_json f)));
           Some ("volume_type", (VolumeType.to_json v.volume_type));
           Some ("tags", (TagList.to_json v.tags));
           Some ("attachments", (VolumeAttachmentList.to_json v.attachments));
           Some ("create_time", (DateTime.to_json v.create_time));
           Some ("state", (VolumeState.to_json v.state));
           Some ("availability_zone", (String.to_json v.availability_zone));
           Some ("snapshot_id", (String.to_json v.snapshot_id));
           Some ("size", (Integer.to_json v.size));
           Some ("volume_id", (String.to_json v.volume_id))])
    let of_json j =
      {
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")));
        size = (Integer.of_json (Util.of_option_exn (Json.lookup j "size")));
        snapshot_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "snapshot_id")));
        availability_zone =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "availability_zone")));
        state =
          (VolumeState.of_json (Util.of_option_exn (Json.lookup j "state")));
        create_time =
          (DateTime.of_json
             (Util.of_option_exn (Json.lookup j "create_time")));
        attachments =
          (VolumeAttachmentList.of_json
             (Util.of_option_exn (Json.lookup j "attachments")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        volume_type =
          (VolumeType.of_json
             (Util.of_option_exn (Json.lookup j "volume_type")));
        iops = (Util.option_map (Json.lookup j "iops") Integer.of_json);
        encrypted =
          (Boolean.of_json (Util.of_option_exn (Json.lookup j "encrypted")));
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json)
      }
  end
module Region =
  struct
    type t = {
      region_name: String.t option ;
      endpoint: String.t option }
    let make ?region_name  ?endpoint  () = { region_name; endpoint }
    let parse xml =
      Some
        {
          region_name =
            (Util.option_bind (Xml.member "regionName" xml) String.parse);
          endpoint =
            (Util.option_bind (Xml.member "regionEndpoint" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.endpoint
              (fun f -> Query.Pair ("RegionEndpoint", (String.to_query f)));
           Util.option_map v.region_name
             (fun f -> Query.Pair ("RegionName", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.endpoint
              (fun f -> ("endpoint", (String.to_json f)));
           Util.option_map v.region_name
             (fun f -> ("region_name", (String.to_json f)))])
    let of_json j =
      {
        region_name =
          (Util.option_map (Json.lookup j "region_name") String.of_json);
        endpoint =
          (Util.option_map (Json.lookup j "endpoint") String.of_json)
      }
  end
module Address =
  struct
    type t =
      {
      instance_id: String.t option ;
      public_ip: String.t option ;
      allocation_id: String.t option ;
      association_id: String.t option ;
      domain: DomainType.t option ;
      network_interface_id: String.t option ;
      network_interface_owner_id: String.t option ;
      private_ip_address: String.t option }
    let make ?instance_id  ?public_ip  ?allocation_id  ?association_id 
      ?domain  ?network_interface_id  ?network_interface_owner_id 
      ?private_ip_address  () =
      {
        instance_id;
        public_ip;
        allocation_id;
        association_id;
        domain;
        network_interface_id;
        network_interface_owner_id;
        private_ip_address
      }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse);
          allocation_id =
            (Util.option_bind (Xml.member "allocationId" xml) String.parse);
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          domain =
            (Util.option_bind (Xml.member "domain" xml) DomainType.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          network_interface_owner_id =
            (Util.option_bind (Xml.member "networkInterfaceOwnerId" xml)
               String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.network_interface_owner_id
             (fun f ->
                Query.Pair ("NetworkInterfaceOwnerId", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.domain
             (fun f -> Query.Pair ("Domain", (DomainType.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.network_interface_owner_id
             (fun f -> ("network_interface_owner_id", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.domain
             (fun f -> ("domain", (DomainType.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json);
        allocation_id =
          (Util.option_map (Json.lookup j "allocation_id") String.of_json);
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        domain =
          (Util.option_map (Json.lookup j "domain") DomainType.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        network_interface_owner_id =
          (Util.option_map (Json.lookup j "network_interface_owner_id")
             String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json)
      }
  end
module VpnConnection =
  struct
    type t =
      {
      vpn_connection_id: String.t ;
      state: VpnState.t ;
      customer_gateway_configuration: String.t option ;
      type_: GatewayType.t ;
      customer_gateway_id: String.t ;
      vpn_gateway_id: String.t option ;
      tags: TagList.t ;
      vgw_telemetry: VgwTelemetryList.t ;
      options: VpnConnectionOptions.t option ;
      routes: VpnStaticRouteList.t }
    let make ~vpn_connection_id  ~state  ?customer_gateway_configuration 
      ~type_  ~customer_gateway_id  ?vpn_gateway_id  ?(tags= []) 
      ?(vgw_telemetry= [])  ?options  ?(routes= [])  () =
      {
        vpn_connection_id;
        state;
        customer_gateway_configuration;
        type_;
        customer_gateway_id;
        vpn_gateway_id;
        tags;
        vgw_telemetry;
        options;
        routes
      }
    let parse xml =
      Some
        {
          vpn_connection_id =
            (Xml.required "vpnConnectionId"
               (Util.option_bind (Xml.member "vpnConnectionId" xml)
                  String.parse));
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml) VpnState.parse));
          customer_gateway_configuration =
            (Util.option_bind (Xml.member "customerGatewayConfiguration" xml)
               String.parse);
          type_ =
            (Xml.required "type"
               (Util.option_bind (Xml.member "type" xml) GatewayType.parse));
          customer_gateway_id =
            (Xml.required "customerGatewayId"
               (Util.option_bind (Xml.member "customerGatewayId" xml)
                  String.parse));
          vpn_gateway_id =
            (Util.option_bind (Xml.member "vpnGatewayId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vgw_telemetry =
            (Util.of_option []
               (Util.option_bind (Xml.member "vgwTelemetry" xml)
                  VgwTelemetryList.parse));
          options =
            (Util.option_bind (Xml.member "options" xml)
               VpnConnectionOptions.parse);
          routes =
            (Util.of_option []
               (Util.option_bind (Xml.member "routes" xml)
                  VpnStaticRouteList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("Routes", (VpnStaticRouteList.to_query v.routes)));
           Util.option_map v.options
             (fun f ->
                Query.Pair ("Options", (VpnConnectionOptions.to_query f)));
           Some
             (Query.Pair
                ("VgwTelemetry", (VgwTelemetryList.to_query v.vgw_telemetry)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.vpn_gateway_id
             (fun f -> Query.Pair ("VpnGatewayId", (String.to_query f)));
           Some
             (Query.Pair
                ("CustomerGatewayId",
                  (String.to_query v.customer_gateway_id)));
           Some (Query.Pair ("Type", (GatewayType.to_query v.type_)));
           Util.option_map v.customer_gateway_configuration
             (fun f ->
                Query.Pair
                  ("CustomerGatewayConfiguration", (String.to_query f)));
           Some (Query.Pair ("State", (VpnState.to_query v.state)));
           Some
             (Query.Pair
                ("VpnConnectionId", (String.to_query v.vpn_connection_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("routes", (VpnStaticRouteList.to_json v.routes));
           Util.option_map v.options
             (fun f -> ("options", (VpnConnectionOptions.to_json f)));
           Some ("vgw_telemetry", (VgwTelemetryList.to_json v.vgw_telemetry));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.vpn_gateway_id
             (fun f -> ("vpn_gateway_id", (String.to_json f)));
           Some
             ("customer_gateway_id", (String.to_json v.customer_gateway_id));
           Some ("type_", (GatewayType.to_json v.type_));
           Util.option_map v.customer_gateway_configuration
             (fun f -> ("customer_gateway_configuration", (String.to_json f)));
           Some ("state", (VpnState.to_json v.state));
           Some ("vpn_connection_id", (String.to_json v.vpn_connection_id))])
    let of_json j =
      {
        vpn_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_connection_id")));
        state =
          (VpnState.of_json (Util.of_option_exn (Json.lookup j "state")));
        customer_gateway_configuration =
          (Util.option_map (Json.lookup j "customer_gateway_configuration")
             String.of_json);
        type_ =
          (GatewayType.of_json (Util.of_option_exn (Json.lookup j "type_")));
        customer_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "customer_gateway_id")));
        vpn_gateway_id =
          (Util.option_map (Json.lookup j "vpn_gateway_id") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        vgw_telemetry =
          (VgwTelemetryList.of_json
             (Util.of_option_exn (Json.lookup j "vgw_telemetry")));
        options =
          (Util.option_map (Json.lookup j "options")
             VpnConnectionOptions.of_json);
        routes =
          (VpnStaticRouteList.of_json
             (Util.of_option_exn (Json.lookup j "routes")))
      }
  end
module ReservedInstancesOffering =
  struct
    type t =
      {
      reserved_instances_offering_id: String.t option ;
      instance_type: InstanceType.t option ;
      availability_zone: String.t option ;
      duration: Long.t option ;
      usage_price: Float.t option ;
      fixed_price: Float.t option ;
      product_description: RIProductDescription.t option ;
      instance_tenancy: Tenancy.t option ;
      currency_code: CurrencyCodeValues.t option ;
      offering_type: OfferingTypeValues.t option ;
      recurring_charges: RecurringChargesList.t ;
      marketplace: Boolean.t option ;
      pricing_details: PricingDetailsList.t }
    let make ?reserved_instances_offering_id  ?instance_type 
      ?availability_zone  ?duration  ?usage_price  ?fixed_price 
      ?product_description  ?instance_tenancy  ?currency_code  ?offering_type
       ?(recurring_charges= [])  ?marketplace  ?(pricing_details= [])  () =
      {
        reserved_instances_offering_id;
        instance_type;
        availability_zone;
        duration;
        usage_price;
        fixed_price;
        product_description;
        instance_tenancy;
        currency_code;
        offering_type;
        recurring_charges;
        marketplace;
        pricing_details
      }
    let parse xml =
      Some
        {
          reserved_instances_offering_id =
            (Util.option_bind (Xml.member "reservedInstancesOfferingId" xml)
               String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          duration =
            (Util.option_bind (Xml.member "duration" xml) Long.parse);
          usage_price =
            (Util.option_bind (Xml.member "usagePrice" xml) Float.parse);
          fixed_price =
            (Util.option_bind (Xml.member "fixedPrice" xml) Float.parse);
          product_description =
            (Util.option_bind (Xml.member "productDescription" xml)
               RIProductDescription.parse);
          instance_tenancy =
            (Util.option_bind (Xml.member "instanceTenancy" xml)
               Tenancy.parse);
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          offering_type =
            (Util.option_bind (Xml.member "offeringType" xml)
               OfferingTypeValues.parse);
          recurring_charges =
            (Util.of_option []
               (Util.option_bind (Xml.member "recurringCharges" xml)
                  RecurringChargesList.parse));
          marketplace =
            (Util.option_bind (Xml.member "marketplace" xml) Boolean.parse);
          pricing_details =
            (Util.of_option []
               (Util.option_bind (Xml.member "pricingDetailsSet" xml)
                  PricingDetailsList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PricingDetailsSet",
                   (PricingDetailsList.to_query v.pricing_details)));
           Util.option_map v.marketplace
             (fun f -> Query.Pair ("Marketplace", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("RecurringCharges",
                  (RecurringChargesList.to_query v.recurring_charges)));
           Util.option_map v.offering_type
             (fun f ->
                Query.Pair ("OfferingType", (OfferingTypeValues.to_query f)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)));
           Util.option_map v.instance_tenancy
             (fun f -> Query.Pair ("InstanceTenancy", (Tenancy.to_query f)));
           Util.option_map v.product_description
             (fun f ->
                Query.Pair
                  ("ProductDescription", (RIProductDescription.to_query f)));
           Util.option_map v.fixed_price
             (fun f -> Query.Pair ("FixedPrice", (Float.to_query f)));
           Util.option_map v.usage_price
             (fun f -> Query.Pair ("UsagePrice", (Float.to_query f)));
           Util.option_map v.duration
             (fun f -> Query.Pair ("Duration", (Long.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.reserved_instances_offering_id
             (fun f ->
                Query.Pair
                  ("ReservedInstancesOfferingId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("pricing_details",
                (PricingDetailsList.to_json v.pricing_details));
           Util.option_map v.marketplace
             (fun f -> ("marketplace", (Boolean.to_json f)));
           Some
             ("recurring_charges",
               (RecurringChargesList.to_json v.recurring_charges));
           Util.option_map v.offering_type
             (fun f -> ("offering_type", (OfferingTypeValues.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)));
           Util.option_map v.instance_tenancy
             (fun f -> ("instance_tenancy", (Tenancy.to_json f)));
           Util.option_map v.product_description
             (fun f ->
                ("product_description", (RIProductDescription.to_json f)));
           Util.option_map v.fixed_price
             (fun f -> ("fixed_price", (Float.to_json f)));
           Util.option_map v.usage_price
             (fun f -> ("usage_price", (Float.to_json f)));
           Util.option_map v.duration
             (fun f -> ("duration", (Long.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.reserved_instances_offering_id
             (fun f -> ("reserved_instances_offering_id", (String.to_json f)))])
    let of_json j =
      {
        reserved_instances_offering_id =
          (Util.option_map (Json.lookup j "reserved_instances_offering_id")
             String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        duration = (Util.option_map (Json.lookup j "duration") Long.of_json);
        usage_price =
          (Util.option_map (Json.lookup j "usage_price") Float.of_json);
        fixed_price =
          (Util.option_map (Json.lookup j "fixed_price") Float.of_json);
        product_description =
          (Util.option_map (Json.lookup j "product_description")
             RIProductDescription.of_json);
        instance_tenancy =
          (Util.option_map (Json.lookup j "instance_tenancy") Tenancy.of_json);
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json);
        offering_type =
          (Util.option_map (Json.lookup j "offering_type")
             OfferingTypeValues.of_json);
        recurring_charges =
          (RecurringChargesList.of_json
             (Util.of_option_exn (Json.lookup j "recurring_charges")));
        marketplace =
          (Util.option_map (Json.lookup j "marketplace") Boolean.of_json);
        pricing_details =
          (PricingDetailsList.of_json
             (Util.of_option_exn (Json.lookup j "pricing_details")))
      }
  end
module Reservation =
  struct
    type t =
      {
      reservation_id: String.t ;
      owner_id: String.t ;
      requester_id: String.t option ;
      groups: GroupIdentifierList.t ;
      instances: InstanceList.t }
    let make ~reservation_id  ~owner_id  ?requester_id  ?(groups= []) 
      ?(instances= [])  () =
      { reservation_id; owner_id; requester_id; groups; instances }
    let parse xml =
      Some
        {
          reservation_id =
            (Xml.required "reservationId"
               (Util.option_bind (Xml.member "reservationId" xml)
                  String.parse));
          owner_id =
            (Xml.required "ownerId"
               (Util.option_bind (Xml.member "ownerId" xml) String.parse));
          requester_id =
            (Util.option_bind (Xml.member "requesterId" xml) String.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  InstanceList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstancesSet", (InstanceList.to_query v.instances)));
           Some
             (Query.Pair
                ("GroupSet", (GroupIdentifierList.to_query v.groups)));
           Util.option_map v.requester_id
             (fun f -> Query.Pair ("RequesterId", (String.to_query f)));
           Some (Query.Pair ("OwnerId", (String.to_query v.owner_id)));
           Some
             (Query.Pair
                ("ReservationId", (String.to_query v.reservation_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("instances", (InstanceList.to_json v.instances));
           Some ("groups", (GroupIdentifierList.to_json v.groups));
           Util.option_map v.requester_id
             (fun f -> ("requester_id", (String.to_json f)));
           Some ("owner_id", (String.to_json v.owner_id));
           Some ("reservation_id", (String.to_json v.reservation_id))])
    let of_json j =
      {
        reservation_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "reservation_id")));
        owner_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "owner_id")));
        requester_id =
          (Util.option_map (Json.lookup j "requester_id") String.of_json);
        groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        instances =
          (InstanceList.of_json
             (Util.of_option_exn (Json.lookup j "instances")))
      }
  end
module VpcPeeringConnection =
  struct
    type t =
      {
      accepter_vpc_info: VpcPeeringConnectionVpcInfo.t option ;
      expiration_time: DateTime.t option ;
      requester_vpc_info: VpcPeeringConnectionVpcInfo.t option ;
      status: VpcPeeringConnectionStateReason.t option ;
      tags: TagList.t ;
      vpc_peering_connection_id: String.t option }
    let make ?accepter_vpc_info  ?expiration_time  ?requester_vpc_info 
      ?status  ?(tags= [])  ?vpc_peering_connection_id  () =
      {
        accepter_vpc_info;
        expiration_time;
        requester_vpc_info;
        status;
        tags;
        vpc_peering_connection_id
      }
    let parse xml =
      Some
        {
          accepter_vpc_info =
            (Util.option_bind (Xml.member "accepterVpcInfo" xml)
               VpcPeeringConnectionVpcInfo.parse);
          expiration_time =
            (Util.option_bind (Xml.member "expirationTime" xml)
               DateTime.parse);
          requester_vpc_info =
            (Util.option_bind (Xml.member "requesterVpcInfo" xml)
               VpcPeeringConnectionVpcInfo.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               VpcPeeringConnectionStateReason.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vpc_peering_connection_id =
            (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Query.Pair ("VpcPeeringConnectionId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.status
             (fun f ->
                Query.Pair
                  ("Status", (VpcPeeringConnectionStateReason.to_query f)));
           Util.option_map v.requester_vpc_info
             (fun f ->
                Query.Pair
                  ("RequesterVpcInfo",
                    (VpcPeeringConnectionVpcInfo.to_query f)));
           Util.option_map v.expiration_time
             (fun f -> Query.Pair ("ExpirationTime", (DateTime.to_query f)));
           Util.option_map v.accepter_vpc_info
             (fun f ->
                Query.Pair
                  ("AccepterVpcInfo",
                    (VpcPeeringConnectionVpcInfo.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f -> ("vpc_peering_connection_id", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.status
             (fun f ->
                ("status", (VpcPeeringConnectionStateReason.to_json f)));
           Util.option_map v.requester_vpc_info
             (fun f ->
                ("requester_vpc_info",
                  (VpcPeeringConnectionVpcInfo.to_json f)));
           Util.option_map v.expiration_time
             (fun f -> ("expiration_time", (DateTime.to_json f)));
           Util.option_map v.accepter_vpc_info
             (fun f ->
                ("accepter_vpc_info",
                  (VpcPeeringConnectionVpcInfo.to_json f)))])
    let of_json j =
      {
        accepter_vpc_info =
          (Util.option_map (Json.lookup j "accepter_vpc_info")
             VpcPeeringConnectionVpcInfo.of_json);
        expiration_time =
          (Util.option_map (Json.lookup j "expiration_time") DateTime.of_json);
        requester_vpc_info =
          (Util.option_map (Json.lookup j "requester_vpc_info")
             VpcPeeringConnectionVpcInfo.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             VpcPeeringConnectionStateReason.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        vpc_peering_connection_id =
          (Util.option_map (Json.lookup j "vpc_peering_connection_id")
             String.of_json)
      }
  end
module Vpc =
  struct
    type t =
      {
      vpc_id: String.t ;
      state: VpcState.t ;
      cidr_block: String.t ;
      dhcp_options_id: String.t ;
      tags: TagList.t ;
      instance_tenancy: Tenancy.t ;
      is_default: Boolean.t }
    let make ~vpc_id  ~state  ~cidr_block  ~dhcp_options_id  ?(tags= []) 
      ~instance_tenancy  ~is_default  () =
      {
        vpc_id;
        state;
        cidr_block;
        dhcp_options_id;
        tags;
        instance_tenancy;
        is_default
      }
    let parse xml =
      Some
        {
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse));
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml) VpcState.parse));
          cidr_block =
            (Xml.required "cidrBlock"
               (Util.option_bind (Xml.member "cidrBlock" xml) String.parse));
          dhcp_options_id =
            (Xml.required "dhcpOptionsId"
               (Util.option_bind (Xml.member "dhcpOptionsId" xml)
                  String.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          instance_tenancy =
            (Xml.required "instanceTenancy"
               (Util.option_bind (Xml.member "instanceTenancy" xml)
                  Tenancy.parse));
          is_default =
            (Xml.required "isDefault"
               (Util.option_bind (Xml.member "isDefault" xml) Boolean.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("IsDefault", (Boolean.to_query v.is_default)));
           Some
             (Query.Pair
                ("InstanceTenancy", (Tenancy.to_query v.instance_tenancy)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("DhcpOptionsId", (String.to_query v.dhcp_options_id)));
           Some (Query.Pair ("CidrBlock", (String.to_query v.cidr_block)));
           Some (Query.Pair ("State", (VpcState.to_query v.state)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("is_default", (Boolean.to_json v.is_default));
           Some ("instance_tenancy", (Tenancy.to_json v.instance_tenancy));
           Some ("tags", (TagList.to_json v.tags));
           Some ("dhcp_options_id", (String.to_json v.dhcp_options_id));
           Some ("cidr_block", (String.to_json v.cidr_block));
           Some ("state", (VpcState.to_json v.state));
           Some ("vpc_id", (String.to_json v.vpc_id))])
    let of_json j =
      {
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        state =
          (VpcState.of_json (Util.of_option_exn (Json.lookup j "state")));
        cidr_block =
          (String.of_json (Util.of_option_exn (Json.lookup j "cidr_block")));
        dhcp_options_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "dhcp_options_id")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        instance_tenancy =
          (Tenancy.of_json
             (Util.of_option_exn (Json.lookup j "instance_tenancy")));
        is_default =
          (Boolean.of_json (Util.of_option_exn (Json.lookup j "is_default")))
      }
  end
module NetworkAcl =
  struct
    type t =
      {
      network_acl_id: String.t option ;
      vpc_id: String.t option ;
      is_default: Boolean.t option ;
      entries: NetworkAclEntryList.t ;
      associations: NetworkAclAssociationList.t ;
      tags: TagList.t }
    let make ?network_acl_id  ?vpc_id  ?is_default  ?(entries= []) 
      ?(associations= [])  ?(tags= [])  () =
      { network_acl_id; vpc_id; is_default; entries; associations; tags }
    let parse xml =
      Some
        {
          network_acl_id =
            (Util.option_bind (Xml.member "networkAclId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          is_default =
            (Util.option_bind (Xml.member "default" xml) Boolean.parse);
          entries =
            (Util.of_option []
               (Util.option_bind (Xml.member "entrySet" xml)
                  NetworkAclEntryList.parse));
          associations =
            (Util.of_option []
               (Util.option_bind (Xml.member "associationSet" xml)
                  NetworkAclAssociationList.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("AssociationSet",
                  (NetworkAclAssociationList.to_query v.associations)));
           Some
             (Query.Pair
                ("EntrySet", (NetworkAclEntryList.to_query v.entries)));
           Util.option_map v.is_default
             (fun f -> Query.Pair ("Default", (Boolean.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.network_acl_id
             (fun f -> Query.Pair ("NetworkAclId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Some
             ("associations",
               (NetworkAclAssociationList.to_json v.associations));
           Some ("entries", (NetworkAclEntryList.to_json v.entries));
           Util.option_map v.is_default
             (fun f -> ("is_default", (Boolean.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.network_acl_id
             (fun f -> ("network_acl_id", (String.to_json f)))])
    let of_json j =
      {
        network_acl_id =
          (Util.option_map (Json.lookup j "network_acl_id") String.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        is_default =
          (Util.option_map (Json.lookup j "is_default") Boolean.of_json);
        entries =
          (NetworkAclEntryList.of_json
             (Util.of_option_exn (Json.lookup j "entries")));
        associations =
          (NetworkAclAssociationList.of_json
             (Util.of_option_exn (Json.lookup j "associations")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module Subnet =
  struct
    type t =
      {
      subnet_id: String.t ;
      state: SubnetState.t ;
      vpc_id: String.t ;
      cidr_block: String.t ;
      available_ip_address_count: Integer.t ;
      availability_zone: String.t ;
      default_for_az: Boolean.t ;
      map_public_ip_on_launch: Boolean.t ;
      tags: TagList.t }
    let make ~subnet_id  ~state  ~vpc_id  ~cidr_block 
      ~available_ip_address_count  ~availability_zone  ~default_for_az 
      ~map_public_ip_on_launch  ?(tags= [])  () =
      {
        subnet_id;
        state;
        vpc_id;
        cidr_block;
        available_ip_address_count;
        availability_zone;
        default_for_az;
        map_public_ip_on_launch;
        tags
      }
    let parse xml =
      Some
        {
          subnet_id =
            (Xml.required "subnetId"
               (Util.option_bind (Xml.member "subnetId" xml) String.parse));
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml) SubnetState.parse));
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse));
          cidr_block =
            (Xml.required "cidrBlock"
               (Util.option_bind (Xml.member "cidrBlock" xml) String.parse));
          available_ip_address_count =
            (Xml.required "availableIpAddressCount"
               (Util.option_bind (Xml.member "availableIpAddressCount" xml)
                  Integer.parse));
          availability_zone =
            (Xml.required "availabilityZone"
               (Util.option_bind (Xml.member "availabilityZone" xml)
                  String.parse));
          default_for_az =
            (Xml.required "defaultForAz"
               (Util.option_bind (Xml.member "defaultForAz" xml)
                  Boolean.parse));
          map_public_ip_on_launch =
            (Xml.required "mapPublicIpOnLaunch"
               (Util.option_bind (Xml.member "mapPublicIpOnLaunch" xml)
                  Boolean.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("MapPublicIpOnLaunch",
                  (Boolean.to_query v.map_public_ip_on_launch)));
           Some
             (Query.Pair
                ("DefaultForAz", (Boolean.to_query v.default_for_az)));
           Some
             (Query.Pair
                ("AvailabilityZone", (String.to_query v.availability_zone)));
           Some
             (Query.Pair
                ("AvailableIpAddressCount",
                  (Integer.to_query v.available_ip_address_count)));
           Some (Query.Pair ("CidrBlock", (String.to_query v.cidr_block)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some (Query.Pair ("State", (SubnetState.to_query v.state)));
           Some (Query.Pair ("SubnetId", (String.to_query v.subnet_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Some
             ("map_public_ip_on_launch",
               (Boolean.to_json v.map_public_ip_on_launch));
           Some ("default_for_az", (Boolean.to_json v.default_for_az));
           Some ("availability_zone", (String.to_json v.availability_zone));
           Some
             ("available_ip_address_count",
               (Integer.to_json v.available_ip_address_count));
           Some ("cidr_block", (String.to_json v.cidr_block));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Some ("state", (SubnetState.to_json v.state));
           Some ("subnet_id", (String.to_json v.subnet_id))])
    let of_json j =
      {
        subnet_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "subnet_id")));
        state =
          (SubnetState.of_json (Util.of_option_exn (Json.lookup j "state")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        cidr_block =
          (String.of_json (Util.of_option_exn (Json.lookup j "cidr_block")));
        available_ip_address_count =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "available_ip_address_count")));
        availability_zone =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "availability_zone")));
        default_for_az =
          (Boolean.of_json
             (Util.of_option_exn (Json.lookup j "default_for_az")));
        map_public_ip_on_launch =
          (Boolean.of_json
             (Util.of_option_exn (Json.lookup j "map_public_ip_on_launch")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module VpcClassicLink =
  struct
    type t =
      {
      vpc_id: String.t option ;
      classic_link_enabled: Boolean.t option ;
      tags: TagList.t }
    let make ?vpc_id  ?classic_link_enabled  ?(tags= [])  () =
      { vpc_id; classic_link_enabled; tags }
    let parse xml =
      Some
        {
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          classic_link_enabled =
            (Util.option_bind (Xml.member "classicLinkEnabled" xml)
               Boolean.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.classic_link_enabled
             (fun f ->
                Query.Pair ("ClassicLinkEnabled", (Boolean.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.classic_link_enabled
             (fun f -> ("classic_link_enabled", (Boolean.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)))])
    let of_json j =
      {
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        classic_link_enabled =
          (Util.option_map (Json.lookup j "classic_link_enabled")
             Boolean.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module ImportImageTask =
  struct
    type t =
      {
      import_task_id: String.t option ;
      architecture: String.t option ;
      license_type: String.t option ;
      platform: String.t option ;
      hypervisor: String.t option ;
      description: String.t option ;
      snapshot_details: SnapshotDetailList.t ;
      image_id: String.t option ;
      progress: String.t option ;
      status_message: String.t option ;
      status: String.t option }
    let make ?import_task_id  ?architecture  ?license_type  ?platform 
      ?hypervisor  ?description  ?(snapshot_details= [])  ?image_id 
      ?progress  ?status_message  ?status  () =
      {
        import_task_id;
        architecture;
        license_type;
        platform;
        hypervisor;
        description;
        snapshot_details;
        image_id;
        progress;
        status_message;
        status
      }
    let parse xml =
      Some
        {
          import_task_id =
            (Util.option_bind (Xml.member "importTaskId" xml) String.parse);
          architecture =
            (Util.option_bind (Xml.member "architecture" xml) String.parse);
          license_type =
            (Util.option_bind (Xml.member "licenseType" xml) String.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml) String.parse);
          hypervisor =
            (Util.option_bind (Xml.member "hypervisor" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          snapshot_details =
            (Util.of_option []
               (Util.option_bind (Xml.member "snapshotDetailSet" xml)
                  SnapshotDetailList.parse));
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (String.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Some
             (Query.Pair
                ("SnapshotDetailSet",
                  (SnapshotDetailList.to_query v.snapshot_details)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.hypervisor
             (fun f -> Query.Pair ("Hypervisor", (String.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (String.to_query f)));
           Util.option_map v.license_type
             (fun f -> Query.Pair ("LicenseType", (String.to_query f)));
           Util.option_map v.architecture
             (fun f -> Query.Pair ("Architecture", (String.to_query f)));
           Util.option_map v.import_task_id
             (fun f -> Query.Pair ("ImportTaskId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (String.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.progress
             (fun f -> ("progress", (String.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Some
             ("snapshot_details",
               (SnapshotDetailList.to_json v.snapshot_details));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.hypervisor
             (fun f -> ("hypervisor", (String.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (String.to_json f)));
           Util.option_map v.license_type
             (fun f -> ("license_type", (String.to_json f)));
           Util.option_map v.architecture
             (fun f -> ("architecture", (String.to_json f)));
           Util.option_map v.import_task_id
             (fun f -> ("import_task_id", (String.to_json f)))])
    let of_json j =
      {
        import_task_id =
          (Util.option_map (Json.lookup j "import_task_id") String.of_json);
        architecture =
          (Util.option_map (Json.lookup j "architecture") String.of_json);
        license_type =
          (Util.option_map (Json.lookup j "license_type") String.of_json);
        platform =
          (Util.option_map (Json.lookup j "platform") String.of_json);
        hypervisor =
          (Util.option_map (Json.lookup j "hypervisor") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        snapshot_details =
          (SnapshotDetailList.of_json
             (Util.of_option_exn (Json.lookup j "snapshot_details")));
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        progress =
          (Util.option_map (Json.lookup j "progress") String.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json)
      }
  end
module CancelSpotFleetRequestsErrorItem =
  struct
    type t =
      {
      spot_fleet_request_id: String.t ;
      error: CancelSpotFleetRequestsError.t }
    let make ~spot_fleet_request_id  ~error  () =
      { spot_fleet_request_id; error }
    let parse xml =
      Some
        {
          spot_fleet_request_id =
            (Xml.required "spotFleetRequestId"
               (Util.option_bind (Xml.member "spotFleetRequestId" xml)
                  String.parse));
          error =
            (Xml.required "error"
               (Util.option_bind (Xml.member "error" xml)
                  CancelSpotFleetRequestsError.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Error", (CancelSpotFleetRequestsError.to_query v.error)));
           Some
             (Query.Pair
                ("SpotFleetRequestId",
                  (String.to_query v.spot_fleet_request_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("error", (CancelSpotFleetRequestsError.to_json v.error));
           Some
             ("spot_fleet_request_id",
               (String.to_json v.spot_fleet_request_id))])
    let of_json j =
      {
        spot_fleet_request_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_id")));
        error =
          (CancelSpotFleetRequestsError.of_json
             (Util.of_option_exn (Json.lookup j "error")))
      }
  end
module CancelSpotFleetRequestsSuccessItem =
  struct
    type t =
      {
      spot_fleet_request_id: String.t ;
      current_spot_fleet_request_state: BatchState.t ;
      previous_spot_fleet_request_state: BatchState.t }
    let make ~spot_fleet_request_id  ~current_spot_fleet_request_state 
      ~previous_spot_fleet_request_state  () =
      {
        spot_fleet_request_id;
        current_spot_fleet_request_state;
        previous_spot_fleet_request_state
      }
    let parse xml =
      Some
        {
          spot_fleet_request_id =
            (Xml.required "spotFleetRequestId"
               (Util.option_bind (Xml.member "spotFleetRequestId" xml)
                  String.parse));
          current_spot_fleet_request_state =
            (Xml.required "currentSpotFleetRequestState"
               (Util.option_bind
                  (Xml.member "currentSpotFleetRequestState" xml)
                  BatchState.parse));
          previous_spot_fleet_request_state =
            (Xml.required "previousSpotFleetRequestState"
               (Util.option_bind
                  (Xml.member "previousSpotFleetRequestState" xml)
                  BatchState.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PreviousSpotFleetRequestState",
                   (BatchState.to_query v.previous_spot_fleet_request_state)));
           Some
             (Query.Pair
                ("CurrentSpotFleetRequestState",
                  (BatchState.to_query v.current_spot_fleet_request_state)));
           Some
             (Query.Pair
                ("SpotFleetRequestId",
                  (String.to_query v.spot_fleet_request_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("previous_spot_fleet_request_state",
                (BatchState.to_json v.previous_spot_fleet_request_state));
           Some
             ("current_spot_fleet_request_state",
               (BatchState.to_json v.current_spot_fleet_request_state));
           Some
             ("spot_fleet_request_id",
               (String.to_json v.spot_fleet_request_id))])
    let of_json j =
      {
        spot_fleet_request_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_id")));
        current_spot_fleet_request_state =
          (BatchState.of_json
             (Util.of_option_exn
                (Json.lookup j "current_spot_fleet_request_state")));
        previous_spot_fleet_request_state =
          (BatchState.of_json
             (Util.of_option_exn
                (Json.lookup j "previous_spot_fleet_request_state")))
      }
  end
module AccountAttribute =
  struct
    type t =
      {
      attribute_name: String.t option ;
      attribute_values: AccountAttributeValueList.t }
    let make ?attribute_name  ?(attribute_values= [])  () =
      { attribute_name; attribute_values }
    let parse xml =
      Some
        {
          attribute_name =
            (Util.option_bind (Xml.member "attributeName" xml) String.parse);
          attribute_values =
            (Util.of_option []
               (Util.option_bind (Xml.member "attributeValueSet" xml)
                  AccountAttributeValueList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AttributeValueSet",
                   (AccountAttributeValueList.to_query v.attribute_values)));
           Util.option_map v.attribute_name
             (fun f -> Query.Pair ("AttributeName", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("attribute_values",
                (AccountAttributeValueList.to_json v.attribute_values));
           Util.option_map v.attribute_name
             (fun f -> ("attribute_name", (String.to_json f)))])
    let of_json j =
      {
        attribute_name =
          (Util.option_map (Json.lookup j "attribute_name") String.of_json);
        attribute_values =
          (AccountAttributeValueList.of_json
             (Util.of_option_exn (Json.lookup j "attribute_values")))
      }
  end
module SpotPrice =
  struct
    type t =
      {
      instance_type: InstanceType.t option ;
      product_description: RIProductDescription.t option ;
      spot_price: String.t option ;
      timestamp: DateTime.t option ;
      availability_zone: String.t option }
    let make ?instance_type  ?product_description  ?spot_price  ?timestamp 
      ?availability_zone  () =
      {
        instance_type;
        product_description;
        spot_price;
        timestamp;
        availability_zone
      }
    let parse xml =
      Some
        {
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          product_description =
            (Util.option_bind (Xml.member "productDescription" xml)
               RIProductDescription.parse);
          spot_price =
            (Util.option_bind (Xml.member "spotPrice" xml) String.parse);
          timestamp =
            (Util.option_bind (Xml.member "timestamp" xml) DateTime.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.availability_zone
              (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.timestamp
             (fun f -> Query.Pair ("Timestamp", (DateTime.to_query f)));
           Util.option_map v.spot_price
             (fun f -> Query.Pair ("SpotPrice", (String.to_query f)));
           Util.option_map v.product_description
             (fun f ->
                Query.Pair
                  ("ProductDescription", (RIProductDescription.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.availability_zone
              (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.timestamp
             (fun f -> ("timestamp", (DateTime.to_json f)));
           Util.option_map v.spot_price
             (fun f -> ("spot_price", (String.to_json f)));
           Util.option_map v.product_description
             (fun f ->
                ("product_description", (RIProductDescription.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)))])
    let of_json j =
      {
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        product_description =
          (Util.option_map (Json.lookup j "product_description")
             RIProductDescription.of_json);
        spot_price =
          (Util.option_map (Json.lookup j "spot_price") String.of_json);
        timestamp =
          (Util.option_map (Json.lookup j "timestamp") DateTime.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json)
      }
  end
module ReportInstanceReasonCodes =
  struct
    type t =
      | Instance_stuck_in_state 
      | Unresponsive 
      | Not_accepting_credentials 
      | Password_not_available 
      | Performance_network 
      | Performance_instance_store 
      | Performance_ebs_volume 
      | Performance_other 
      | Other 
    let str_to_t =
      [("other", Other);
      ("performance-other", Performance_other);
      ("performance-ebs-volume", Performance_ebs_volume);
      ("performance-instance-store", Performance_instance_store);
      ("performance-network", Performance_network);
      ("password-not-available", Password_not_available);
      ("not-accepting-credentials", Not_accepting_credentials);
      ("unresponsive", Unresponsive);
      ("instance-stuck-in-state", Instance_stuck_in_state)]
    let t_to_str =
      [(Other, "other");
      (Performance_other, "performance-other");
      (Performance_ebs_volume, "performance-ebs-volume");
      (Performance_instance_store, "performance-instance-store");
      (Performance_network, "performance-network");
      (Password_not_available, "password-not-available");
      (Not_accepting_credentials, "not-accepting-credentials");
      (Unresponsive, "unresponsive");
      (Instance_stuck_in_state, "instance-stuck-in-state")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DiskImage =
  struct
    type t =
      {
      image: DiskImageDetail.t option ;
      description: String.t option ;
      volume: VolumeDetail.t option }
    let make ?image  ?description  ?volume  () =
      { image; description; volume }
    let parse xml =
      Some
        {
          image =
            (Util.option_bind (Xml.member "Image" xml) DiskImageDetail.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          volume =
            (Util.option_bind (Xml.member "Volume" xml) VolumeDetail.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume
              (fun f -> Query.Pair ("Volume", (VolumeDetail.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.image
             (fun f -> Query.Pair ("Image", (DiskImageDetail.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume
              (fun f -> ("volume", (VolumeDetail.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.image
             (fun f -> ("image", (DiskImageDetail.to_json f)))])
    let of_json j =
      {
        image =
          (Util.option_map (Json.lookup j "image") DiskImageDetail.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        volume =
          (Util.option_map (Json.lookup j "volume") VolumeDetail.of_json)
      }
  end
module SecurityGroupStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "SecurityGroup" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ShutdownBehavior =
  struct
    type t =
      | Stop 
      | Terminate 
    let str_to_t = [("terminate", Terminate); ("stop", Stop)]
    let t_to_str = [(Terminate, "terminate"); (Stop, "stop")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module UserData =
  struct
    type t = {
      data: String.t option }
    let make ?data  () = { data }
    let parse xml =
      Some { data = (Util.option_bind (Xml.member "data" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.data
              (fun f -> Query.Pair ("Data", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.data (fun f -> ("data", (String.to_json f)))])
    let of_json j =
      { data = (Util.option_map (Json.lookup j "data") String.of_json) }
  end
module VpcEndpoint =
  struct
    type t =
      {
      vpc_endpoint_id: String.t option ;
      vpc_id: String.t option ;
      service_name: String.t option ;
      state: State.t option ;
      policy_document: String.t option ;
      route_table_ids: ValueStringList.t ;
      creation_timestamp: DateTime.t option }
    let make ?vpc_endpoint_id  ?vpc_id  ?service_name  ?state 
      ?policy_document  ?(route_table_ids= [])  ?creation_timestamp  () =
      {
        vpc_endpoint_id;
        vpc_id;
        service_name;
        state;
        policy_document;
        route_table_ids;
        creation_timestamp
      }
    let parse xml =
      Some
        {
          vpc_endpoint_id =
            (Util.option_bind (Xml.member "vpcEndpointId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          service_name =
            (Util.option_bind (Xml.member "serviceName" xml) String.parse);
          state = (Util.option_bind (Xml.member "state" xml) State.parse);
          policy_document =
            (Util.option_bind (Xml.member "policyDocument" xml) String.parse);
          route_table_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "routeTableIdSet" xml)
                  ValueStringList.parse));
          creation_timestamp =
            (Util.option_bind (Xml.member "creationTimestamp" xml)
               DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.creation_timestamp
              (fun f ->
                 Query.Pair ("CreationTimestamp", (DateTime.to_query f)));
           Some
             (Query.Pair
                ("RouteTableIdSet",
                  (ValueStringList.to_query v.route_table_ids)));
           Util.option_map v.policy_document
             (fun f -> Query.Pair ("PolicyDocument", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (State.to_query f)));
           Util.option_map v.service_name
             (fun f -> Query.Pair ("ServiceName", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> Query.Pair ("VpcEndpointId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.creation_timestamp
              (fun f -> ("creation_timestamp", (DateTime.to_json f)));
           Some
             ("route_table_ids", (ValueStringList.to_json v.route_table_ids));
           Util.option_map v.policy_document
             (fun f -> ("policy_document", (String.to_json f)));
           Util.option_map v.state (fun f -> ("state", (State.to_json f)));
           Util.option_map v.service_name
             (fun f -> ("service_name", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> ("vpc_endpoint_id", (String.to_json f)))])
    let of_json j =
      {
        vpc_endpoint_id =
          (Util.option_map (Json.lookup j "vpc_endpoint_id") String.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        service_name =
          (Util.option_map (Json.lookup j "service_name") String.of_json);
        state = (Util.option_map (Json.lookup j "state") State.of_json);
        policy_document =
          (Util.option_map (Json.lookup j "policy_document") String.of_json);
        route_table_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "route_table_ids")));
        creation_timestamp =
          (Util.option_map (Json.lookup j "creation_timestamp")
             DateTime.of_json)
      }
  end
module ImageDiskContainer =
  struct
    type t =
      {
      description: String.t option ;
      format: String.t option ;
      url: String.t option ;
      user_bucket: UserBucket.t option ;
      device_name: String.t option ;
      snapshot_id: String.t option }
    let make ?description  ?format  ?url  ?user_bucket  ?device_name 
      ?snapshot_id  () =
      { description; format; url; user_bucket; device_name; snapshot_id }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          format = (Util.option_bind (Xml.member "Format" xml) String.parse);
          url = (Util.option_bind (Xml.member "Url" xml) String.parse);
          user_bucket =
            (Util.option_bind (Xml.member "UserBucket" xml) UserBucket.parse);
          device_name =
            (Util.option_bind (Xml.member "DeviceName" xml) String.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "SnapshotId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.snapshot_id
              (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)));
           Util.option_map v.user_bucket
             (fun f -> Query.Pair ("UserBucket", (UserBucket.to_query f)));
           Util.option_map v.url
             (fun f -> Query.Pair ("Url", (String.to_query f)));
           Util.option_map v.format
             (fun f -> Query.Pair ("Format", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.snapshot_id
              (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)));
           Util.option_map v.user_bucket
             (fun f -> ("user_bucket", (UserBucket.to_json f)));
           Util.option_map v.url (fun f -> ("url", (String.to_json f)));
           Util.option_map v.format (fun f -> ("format", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        format = (Util.option_map (Json.lookup j "format") String.of_json);
        url = (Util.option_map (Json.lookup j "url") String.of_json);
        user_bucket =
          (Util.option_map (Json.lookup j "user_bucket") UserBucket.of_json);
        device_name =
          (Util.option_map (Json.lookup j "device_name") String.of_json);
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json)
      }
  end
module ClassicLinkInstance =
  struct
    type t =
      {
      instance_id: String.t option ;
      vpc_id: String.t option ;
      groups: GroupIdentifierList.t ;
      tags: TagList.t }
    let make ?instance_id  ?vpc_id  ?(groups= [])  ?(tags= [])  () =
      { instance_id; vpc_id; groups; tags }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("GroupSet", (GroupIdentifierList.to_query v.groups)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Some ("groups", (GroupIdentifierList.to_json v.groups));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module Snapshot =
  struct
    type t =
      {
      snapshot_id: String.t ;
      volume_id: String.t ;
      state: SnapshotState.t ;
      start_time: DateTime.t ;
      progress: String.t ;
      owner_id: String.t ;
      description: String.t ;
      volume_size: Integer.t ;
      owner_alias: String.t option ;
      tags: TagList.t ;
      encrypted: Boolean.t ;
      kms_key_id: String.t option }
    let make ~snapshot_id  ~volume_id  ~state  ~start_time  ~progress 
      ~owner_id  ~description  ~volume_size  ?owner_alias  ?(tags= []) 
      ~encrypted  ?kms_key_id  () =
      {
        snapshot_id;
        volume_id;
        state;
        start_time;
        progress;
        owner_id;
        description;
        volume_size;
        owner_alias;
        tags;
        encrypted;
        kms_key_id
      }
    let parse xml =
      Some
        {
          snapshot_id =
            (Xml.required "snapshotId"
               (Util.option_bind (Xml.member "snapshotId" xml) String.parse));
          volume_id =
            (Xml.required "volumeId"
               (Util.option_bind (Xml.member "volumeId" xml) String.parse));
          state =
            (Xml.required "status"
               (Util.option_bind (Xml.member "status" xml)
                  SnapshotState.parse));
          start_time =
            (Xml.required "startTime"
               (Util.option_bind (Xml.member "startTime" xml) DateTime.parse));
          progress =
            (Xml.required "progress"
               (Util.option_bind (Xml.member "progress" xml) String.parse));
          owner_id =
            (Xml.required "ownerId"
               (Util.option_bind (Xml.member "ownerId" xml) String.parse));
          description =
            (Xml.required "description"
               (Util.option_bind (Xml.member "description" xml) String.parse));
          volume_size =
            (Xml.required "volumeSize"
               (Util.option_bind (Xml.member "volumeSize" xml) Integer.parse));
          owner_alias =
            (Util.option_bind (Xml.member "ownerAlias" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          encrypted =
            (Xml.required "encrypted"
               (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse));
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Some (Query.Pair ("Encrypted", (Boolean.to_query v.encrypted)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.owner_alias
             (fun f -> Query.Pair ("OwnerAlias", (String.to_query f)));
           Some (Query.Pair ("VolumeSize", (Integer.to_query v.volume_size)));
           Some (Query.Pair ("Description", (String.to_query v.description)));
           Some (Query.Pair ("OwnerId", (String.to_query v.owner_id)));
           Some (Query.Pair ("Progress", (String.to_query v.progress)));
           Some (Query.Pair ("StartTime", (DateTime.to_query v.start_time)));
           Some (Query.Pair ("Status", (SnapshotState.to_query v.state)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Some (Query.Pair ("SnapshotId", (String.to_query v.snapshot_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> ("kms_key_id", (String.to_json f)));
           Some ("encrypted", (Boolean.to_json v.encrypted));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.owner_alias
             (fun f -> ("owner_alias", (String.to_json f)));
           Some ("volume_size", (Integer.to_json v.volume_size));
           Some ("description", (String.to_json v.description));
           Some ("owner_id", (String.to_json v.owner_id));
           Some ("progress", (String.to_json v.progress));
           Some ("start_time", (DateTime.to_json v.start_time));
           Some ("state", (SnapshotState.to_json v.state));
           Some ("volume_id", (String.to_json v.volume_id));
           Some ("snapshot_id", (String.to_json v.snapshot_id))])
    let of_json j =
      {
        snapshot_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "snapshot_id")));
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")));
        state =
          (SnapshotState.of_json (Util.of_option_exn (Json.lookup j "state")));
        start_time =
          (DateTime.of_json (Util.of_option_exn (Json.lookup j "start_time")));
        progress =
          (String.of_json (Util.of_option_exn (Json.lookup j "progress")));
        owner_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "owner_id")));
        description =
          (String.of_json (Util.of_option_exn (Json.lookup j "description")));
        volume_size =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "volume_size")));
        owner_alias =
          (Util.option_map (Json.lookup j "owner_alias") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        encrypted =
          (Boolean.of_json (Util.of_option_exn (Json.lookup j "encrypted")));
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json)
      }
  end
module NewDhcpConfiguration =
  struct
    type t = {
      key: String.t option ;
      values: ValueStringList.t }
    let make ?key  ?(values= [])  () = { key; values }
    let parse xml =
      Some
        {
          key = (Util.option_bind (Xml.member "key" xml) String.parse);
          values =
            (Util.of_option []
               (Util.option_bind (Xml.member "Value" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Value", (ValueStringList.to_query v.values)));
           Util.option_map v.key
             (fun f -> Query.Pair ("Key", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("values", (ValueStringList.to_json v.values));
           Util.option_map v.key (fun f -> ("key", (String.to_json f)))])
    let of_json j =
      {
        key = (Util.option_map (Json.lookup j "key") String.of_json);
        values =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "values")))
      }
  end
module VpcAttributeName =
  struct
    type t =
      | EnableDnsSupport 
      | EnableDnsHostnames 
    let str_to_t =
      [("enableDnsHostnames", EnableDnsHostnames);
      ("enableDnsSupport", EnableDnsSupport)]
    let t_to_str =
      [(EnableDnsHostnames, "enableDnsHostnames");
      (EnableDnsSupport, "enableDnsSupport")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module BlockDeviceMappingRequestList =
  struct
    type t = BlockDeviceMapping.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map BlockDeviceMapping.parse
           (Xml.members "BlockDeviceMapping" xml))
    let to_query v = Query.to_query_list BlockDeviceMapping.to_query v
    let to_json v = `List (List.map BlockDeviceMapping.to_json v)
    let of_json j = Json.to_list BlockDeviceMapping.of_json j
  end
module NetworkInterfaceList =
  struct
    type t = NetworkInterface.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map NetworkInterface.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list NetworkInterface.to_query v
    let to_json v = `List (List.map NetworkInterface.to_json v)
    let of_json j = Json.to_list NetworkInterface.of_json j
  end
module TagDescriptionList =
  struct
    type t = TagDescription.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TagDescription.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TagDescription.to_query v
    let to_json v = `List (List.map TagDescription.to_json v)
    let of_json j = Json.to_list TagDescription.of_json j
  end
module DhcpOptionsList =
  struct
    type t = DhcpOptions.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map DhcpOptions.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list DhcpOptions.to_query v
    let to_json v = `List (List.map DhcpOptions.to_json v)
    let of_json j = Json.to_list DhcpOptions.of_json j
  end
module VpnGatewayList =
  struct
    type t = VpnGateway.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map VpnGateway.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VpnGateway.to_query v
    let to_json v = `List (List.map VpnGateway.to_json v)
    let of_json j = Json.to_list VpnGateway.of_json j
  end
module AttributeBooleanValue =
  struct
    type t = {
      value: Boolean.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) Boolean.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (Boolean.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") Boolean.of_json) }
  end
module ReservedInstancesModificationList =
  struct
    type t = ReservedInstancesModification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReservedInstancesModification.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ReservedInstancesModification.to_query v
    let to_json v = `List (List.map ReservedInstancesModification.to_json v)
    let of_json j = Json.to_list ReservedInstancesModification.of_json j
  end
module ReservedInstancesList =
  struct
    type t = ReservedInstances.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReservedInstances.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ReservedInstances.to_query v
    let to_json v = `List (List.map ReservedInstances.to_json v)
    let of_json j = Json.to_list ReservedInstances.of_json j
  end
module FilterList =
  struct
    type t = Filter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Filter.parse (Xml.members "Filter" xml))
    let to_query v = Query.to_query_list Filter.to_query v
    let to_json v = `List (List.map Filter.to_json v)
    let of_json j = Json.to_list Filter.of_json j
  end
module PlacementGroupList =
  struct
    type t = PlacementGroup.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PlacementGroup.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PlacementGroup.to_query v
    let to_json v = `List (List.map PlacementGroup.to_json v)
    let of_json j = Json.to_list PlacementGroup.of_json j
  end
module KeyPairList =
  struct
    type t = KeyPairInfo.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map KeyPairInfo.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list KeyPairInfo.to_query v
    let to_json v = `List (List.map KeyPairInfo.to_json v)
    let of_json j = Json.to_list KeyPairInfo.of_json j
  end
module CancelledSpotInstanceRequestList =
  struct
    type t = CancelledSpotInstanceRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CancelledSpotInstanceRequest.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list CancelledSpotInstanceRequest.to_query v
    let to_json v = `List (List.map CancelledSpotInstanceRequest.to_json v)
    let of_json j = Json.to_list CancelledSpotInstanceRequest.of_json j
  end
module SpotDatafeedSubscription =
  struct
    type t =
      {
      owner_id: String.t option ;
      bucket: String.t option ;
      prefix: String.t option ;
      state: DatafeedSubscriptionState.t option ;
      fault: SpotInstanceStateFault.t option }
    let make ?owner_id  ?bucket  ?prefix  ?state  ?fault  () =
      { owner_id; bucket; prefix; state; fault }
    let parse xml =
      Some
        {
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          bucket = (Util.option_bind (Xml.member "bucket" xml) String.parse);
          prefix = (Util.option_bind (Xml.member "prefix" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               DatafeedSubscriptionState.parse);
          fault =
            (Util.option_bind (Xml.member "fault" xml)
               SpotInstanceStateFault.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.fault
              (fun f ->
                 Query.Pair ("Fault", (SpotInstanceStateFault.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("State", (DatafeedSubscriptionState.to_query f)));
           Util.option_map v.prefix
             (fun f -> Query.Pair ("Prefix", (String.to_query f)));
           Util.option_map v.bucket
             (fun f -> Query.Pair ("Bucket", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.fault
              (fun f -> ("fault", (SpotInstanceStateFault.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (DatafeedSubscriptionState.to_json f)));
           Util.option_map v.prefix (fun f -> ("prefix", (String.to_json f)));
           Util.option_map v.bucket (fun f -> ("bucket", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)))])
    let of_json j =
      {
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        bucket = (Util.option_map (Json.lookup j "bucket") String.of_json);
        prefix = (Util.option_map (Json.lookup j "prefix") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             DatafeedSubscriptionState.of_json);
        fault =
          (Util.option_map (Json.lookup j "fault")
             SpotInstanceStateFault.of_json)
      }
  end
module LaunchPermissionModifications =
  struct
    type t = {
      add: LaunchPermissionList.t ;
      remove: LaunchPermissionList.t }
    let make ?(add= [])  ?(remove= [])  () = { add; remove }
    let parse xml =
      Some
        {
          add =
            (Util.of_option []
               (Util.option_bind (Xml.member "Add" xml)
                  LaunchPermissionList.parse));
          remove =
            (Util.of_option []
               (Util.option_bind (Xml.member "Remove" xml)
                  LaunchPermissionList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Remove", (LaunchPermissionList.to_query v.remove)));
           Some (Query.Pair ("Add", (LaunchPermissionList.to_query v.add)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("remove", (LaunchPermissionList.to_json v.remove));
           Some ("add", (LaunchPermissionList.to_json v.add))])
    let of_json j =
      {
        add =
          (LaunchPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "add")));
        remove =
          (LaunchPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "remove")))
      }
  end
module OperationType =
  struct
    type t =
      | Add 
      | Remove 
    let str_to_t = [("remove", Remove); ("add", Add)]
    let t_to_str = [(Remove, "remove"); (Add, "add")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ProductCodeStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "ProductCode" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module UserGroupStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "UserGroup" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module UserIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "UserId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module InstanceAttributeName =
  struct
    type t =
      | InstanceType 
      | Kernel 
      | Ramdisk 
      | UserData 
      | DisableApiTermination 
      | InstanceInitiatedShutdownBehavior 
      | RootDeviceName 
      | BlockDeviceMapping 
      | ProductCodes 
      | SourceDestCheck 
      | GroupSet 
      | EbsOptimized 
      | SriovNetSupport 
    let str_to_t =
      [("sriovNetSupport", SriovNetSupport);
      ("ebsOptimized", EbsOptimized);
      ("groupSet", GroupSet);
      ("sourceDestCheck", SourceDestCheck);
      ("productCodes", ProductCodes);
      ("blockDeviceMapping", BlockDeviceMapping);
      ("rootDeviceName", RootDeviceName);
      ("instanceInitiatedShutdownBehavior",
        InstanceInitiatedShutdownBehavior);
      ("disableApiTermination", DisableApiTermination);
      ("userData", UserData);
      ("ramdisk", Ramdisk);
      ("kernel", Kernel);
      ("instanceType", InstanceType)]
    let t_to_str =
      [(SriovNetSupport, "sriovNetSupport");
      (EbsOptimized, "ebsOptimized");
      (GroupSet, "groupSet");
      (SourceDestCheck, "sourceDestCheck");
      (ProductCodes, "productCodes");
      (BlockDeviceMapping, "blockDeviceMapping");
      (RootDeviceName, "rootDeviceName");
      (InstanceInitiatedShutdownBehavior,
        "instanceInitiatedShutdownBehavior");
      (DisableApiTermination, "disableApiTermination");
      (UserData, "userData");
      (Ramdisk, "ramdisk");
      (Kernel, "kernel");
      (InstanceType, "instanceType")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module BundleIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "BundleId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module DescribeConversionTaskList =
  struct
    type t = ConversionTask.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ConversionTask.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ConversionTask.to_query v
    let to_json v = `List (List.map ConversionTask.to_json v)
    let of_json j = Json.to_list ConversionTask.of_json j
  end
module ExportToS3TaskSpecification =
  struct
    type t =
      {
      disk_image_format: DiskImageFormat.t option ;
      container_format: ContainerFormat.t option ;
      s3_bucket: String.t option ;
      s3_prefix: String.t option }
    let make ?disk_image_format  ?container_format  ?s3_bucket  ?s3_prefix 
      () = { disk_image_format; container_format; s3_bucket; s3_prefix }
    let parse xml =
      Some
        {
          disk_image_format =
            (Util.option_bind (Xml.member "diskImageFormat" xml)
               DiskImageFormat.parse);
          container_format =
            (Util.option_bind (Xml.member "containerFormat" xml)
               ContainerFormat.parse);
          s3_bucket =
            (Util.option_bind (Xml.member "s3Bucket" xml) String.parse);
          s3_prefix =
            (Util.option_bind (Xml.member "s3Prefix" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3_prefix
              (fun f -> Query.Pair ("S3Prefix", (String.to_query f)));
           Util.option_map v.s3_bucket
             (fun f -> Query.Pair ("S3Bucket", (String.to_query f)));
           Util.option_map v.container_format
             (fun f ->
                Query.Pair ("ContainerFormat", (ContainerFormat.to_query f)));
           Util.option_map v.disk_image_format
             (fun f ->
                Query.Pair ("DiskImageFormat", (DiskImageFormat.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_prefix
              (fun f -> ("s3_prefix", (String.to_json f)));
           Util.option_map v.s3_bucket
             (fun f -> ("s3_bucket", (String.to_json f)));
           Util.option_map v.container_format
             (fun f -> ("container_format", (ContainerFormat.to_json f)));
           Util.option_map v.disk_image_format
             (fun f -> ("disk_image_format", (DiskImageFormat.to_json f)))])
    let of_json j =
      {
        disk_image_format =
          (Util.option_map (Json.lookup j "disk_image_format")
             DiskImageFormat.of_json);
        container_format =
          (Util.option_map (Json.lookup j "container_format")
             ContainerFormat.of_json);
        s3_bucket =
          (Util.option_map (Json.lookup j "s3_bucket") String.of_json);
        s3_prefix =
          (Util.option_map (Json.lookup j "s3_prefix") String.of_json)
      }
  end
module HistoryRecords =
  struct
    type t = HistoryRecord.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map HistoryRecord.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list HistoryRecord.to_query v
    let to_json v = `List (List.map HistoryRecord.to_json v)
    let of_json j = Json.to_list HistoryRecord.of_json j
  end
module OwnerStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "Owner" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module RestorableByStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module SnapshotIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "SnapshotId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ReservedInstancesConfigurationList =
  struct
    type t = ReservedInstancesConfiguration.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReservedInstancesConfiguration.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ReservedInstancesConfiguration.to_query v
    let to_json v = `List (List.map ReservedInstancesConfiguration.to_json v)
    let of_json j = Json.to_list ReservedInstancesConfiguration.of_json j
  end
module ReservedInstancesIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ReservedInstancesId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module GroupIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "groupId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module GroupNameStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "GroupName" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module RequestSpotLaunchSpecification =
  struct
    type t =
      {
      image_id: String.t option ;
      key_name: String.t option ;
      security_groups: ValueStringList.t ;
      user_data: String.t option ;
      addressing_type: String.t option ;
      instance_type: InstanceType.t option ;
      placement: SpotPlacement.t option ;
      kernel_id: String.t option ;
      ramdisk_id: String.t option ;
      block_device_mappings: BlockDeviceMappingList.t ;
      subnet_id: String.t option ;
      network_interfaces: InstanceNetworkInterfaceSpecificationList.t ;
      iam_instance_profile: IamInstanceProfileSpecification.t option ;
      ebs_optimized: Boolean.t option ;
      monitoring: RunInstancesMonitoringEnabled.t option ;
      security_group_ids: ValueStringList.t }
    let make ?image_id  ?key_name  ?(security_groups= [])  ?user_data 
      ?addressing_type  ?instance_type  ?placement  ?kernel_id  ?ramdisk_id 
      ?(block_device_mappings= [])  ?subnet_id  ?(network_interfaces= []) 
      ?iam_instance_profile  ?ebs_optimized  ?monitoring 
      ?(security_group_ids= [])  () =
      {
        image_id;
        key_name;
        security_groups;
        user_data;
        addressing_type;
        instance_type;
        placement;
        kernel_id;
        ramdisk_id;
        block_device_mappings;
        subnet_id;
        network_interfaces;
        iam_instance_profile;
        ebs_optimized;
        monitoring;
        security_group_ids
      }
    let parse xml =
      Some
        {
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse);
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroup" xml)
                  ValueStringList.parse));
          user_data =
            (Util.option_bind (Xml.member "userData" xml) String.parse);
          addressing_type =
            (Util.option_bind (Xml.member "addressingType" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          placement =
            (Util.option_bind (Xml.member "placement" xml)
               SpotPlacement.parse);
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdiskId" xml) String.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  BlockDeviceMappingList.parse));
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "NetworkInterface" xml)
                  InstanceNetworkInterfaceSpecificationList.parse));
          iam_instance_profile =
            (Util.option_bind (Xml.member "iamInstanceProfile" xml)
               IamInstanceProfileSpecification.parse);
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml) Boolean.parse);
          monitoring =
            (Util.option_bind (Xml.member "monitoring" xml)
               RunInstancesMonitoringEnabled.parse);
          security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SecurityGroupId",
                   (ValueStringList.to_query v.security_group_ids)));
           Util.option_map v.monitoring
             (fun f ->
                Query.Pair
                  ("Monitoring", (RunInstancesMonitoringEnabled.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile",
                    (IamInstanceProfileSpecification.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterface",
                  (InstanceNetworkInterfaceSpecificationList.to_query
                     v.network_interfaces)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingList.to_query v.block_device_mappings)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Util.option_map v.placement
             (fun f -> Query.Pair ("Placement", (SpotPlacement.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.addressing_type
             (fun f -> Query.Pair ("AddressingType", (String.to_query f)));
           Util.option_map v.user_data
             (fun f -> Query.Pair ("UserData", (String.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroup",
                  (ValueStringList.to_query v.security_groups)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("security_group_ids",
                (ValueStringList.to_json v.security_group_ids));
           Util.option_map v.monitoring
             (fun f ->
                ("monitoring", (RunInstancesMonitoringEnabled.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile",
                  (IamInstanceProfileSpecification.to_json f)));
           Some
             ("network_interfaces",
               (InstanceNetworkInterfaceSpecificationList.to_json
                  v.network_interfaces));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingList.to_json v.block_device_mappings));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Util.option_map v.placement
             (fun f -> ("placement", (SpotPlacement.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.addressing_type
             (fun f -> ("addressing_type", (String.to_json f)));
           Util.option_map v.user_data
             (fun f -> ("user_data", (String.to_json f)));
           Some
             ("security_groups", (ValueStringList.to_json v.security_groups));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)))])
    let of_json j =
      {
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        security_groups =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "security_groups")));
        user_data =
          (Util.option_map (Json.lookup j "user_data") String.of_json);
        addressing_type =
          (Util.option_map (Json.lookup j "addressing_type") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        placement =
          (Util.option_map (Json.lookup j "placement") SpotPlacement.of_json);
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id") String.of_json);
        block_device_mappings =
          (BlockDeviceMappingList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        network_interfaces =
          (InstanceNetworkInterfaceSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "network_interfaces")));
        iam_instance_profile =
          (Util.option_map (Json.lookup j "iam_instance_profile")
             IamInstanceProfileSpecification.of_json);
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized") Boolean.of_json);
        monitoring =
          (Util.option_map (Json.lookup j "monitoring")
             RunInstancesMonitoringEnabled.of_json);
        security_group_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "security_group_ids")))
      }
  end
module PrivateIpAddressStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "PrivateIpAddress" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module UnsuccessfulItemSet =
  struct
    type t = UnsuccessfulItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map UnsuccessfulItem.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list UnsuccessfulItem.to_query v
    let to_json v = `List (List.map UnsuccessfulItem.to_json v)
    let of_json j = Json.to_list UnsuccessfulItem.of_json j
  end
module Status =
  struct
    type t =
      | MoveInProgress 
      | InVpc 
      | InClassic 
    let str_to_t =
      [("InClassic", InClassic);
      ("InVpc", InVpc);
      ("MoveInProgress", MoveInProgress)]
    let t_to_str =
      [(InClassic, "InClassic");
      (InVpc, "InVpc");
      (MoveInProgress, "MoveInProgress")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module RouteTableList =
  struct
    type t = RouteTable.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map RouteTable.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list RouteTable.to_query v
    let to_json v = `List (List.map RouteTable.to_json v)
    let of_json j = Json.to_list RouteTable.of_json j
  end
module InstanceIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "InstanceId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ImportTaskIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ImportTaskId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ReservedInstancesListingList =
  struct
    type t = ReservedInstancesListing.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReservedInstancesListing.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ReservedInstancesListing.to_query v
    let to_json v = `List (List.map ReservedInstancesListing.to_json v)
    let of_json j = Json.to_list ReservedInstancesListing.of_json j
  end
module InstanceStateChangeList =
  struct
    type t = InstanceStateChange.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceStateChange.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceStateChange.to_query v
    let to_json v = `List (List.map InstanceStateChange.to_json v)
    let of_json j = Json.to_list InstanceStateChange.of_json j
  end
module ExecutableByStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ExecutableBy" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ImageIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "ImageId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module MovingAddressStatusSet =
  struct
    type t = MovingAddressStatus.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map MovingAddressStatus.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list MovingAddressStatus.to_query v
    let to_json v = `List (List.map MovingAddressStatus.to_json v)
    let of_json j = Json.to_list MovingAddressStatus.of_json j
  end
module ExportTaskIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ExportTaskId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ReservedInstancesOfferingIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module InstanceStatusList =
  struct
    type t = InstanceStatus.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceStatus.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceStatus.to_query v
    let to_json v = `List (List.map InstanceStatus.to_json v)
    let of_json j = Json.to_list InstanceStatus.of_json j
  end
module NetworkInterfaceAttachmentChanges =
  struct
    type t =
      {
      attachment_id: String.t option ;
      delete_on_termination: Boolean.t option }
    let make ?attachment_id  ?delete_on_termination  () =
      { attachment_id; delete_on_termination }
    let parse xml =
      Some
        {
          attachment_id =
            (Util.option_bind (Xml.member "attachmentId" xml) String.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.delete_on_termination
              (fun f ->
                 Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.attachment_id
             (fun f -> Query.Pair ("AttachmentId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.delete_on_termination
              (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.attachment_id
             (fun f -> ("attachment_id", (String.to_json f)))])
    let of_json j =
      {
        attachment_id =
          (Util.option_map (Json.lookup j "attachment_id") String.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json)
      }
  end
module ImageList =
  struct
    type t = Image.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Image.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Image.to_query v
    let to_json v = `List (List.map Image.to_json v)
    let of_json j = Json.to_list Image.of_json j
  end
module PriceScheduleSpecificationList =
  struct
    type t = PriceScheduleSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PriceScheduleSpecification.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list PriceScheduleSpecification.to_query v
    let to_json v = `List (List.map PriceScheduleSpecification.to_json v)
    let of_json j = Json.to_list PriceScheduleSpecification.of_json j
  end
module ImportSnapshotTaskList =
  struct
    type t = ImportSnapshotTask.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ImportSnapshotTask.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ImportSnapshotTask.to_query v
    let to_json v = `List (List.map ImportSnapshotTask.to_json v)
    let of_json j = Json.to_list ImportSnapshotTask.of_json j
  end
module SpotInstanceRequestIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "SpotInstanceRequestId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module KeyNameStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "KeyName" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module SpotInstanceRequestList =
  struct
    type t = SpotInstanceRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SpotInstanceRequest.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list SpotInstanceRequest.to_query v
    let to_json v = `List (List.map SpotInstanceRequest.to_json v)
    let of_json j = Json.to_list SpotInstanceRequest.of_json j
  end
module InstanceTypeList =
  struct
    type t = InstanceType.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceType.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list InstanceType.to_query v
    let to_json v = `List (List.map InstanceType.to_json v)
    let of_json j = Json.to_list InstanceType.of_json j
  end
module ProductDescriptionList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module CustomerGatewayIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "CustomerGatewayId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ExportTaskList =
  struct
    type t = ExportTask.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map ExportTask.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ExportTask.to_query v
    let to_json v = `List (List.map ExportTask.to_json v)
    let of_json j = Json.to_list ExportTask.of_json j
  end
module PrefixListSet =
  struct
    type t = PrefixList.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map PrefixList.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PrefixList.to_query v
    let to_json v = `List (List.map PrefixList.to_json v)
    let of_json j = Json.to_list PrefixList.of_json j
  end
module InstanceMonitoringList =
  struct
    type t = InstanceMonitoring.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceMonitoring.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceMonitoring.to_query v
    let to_json v = `List (List.map InstanceMonitoring.to_json v)
    let of_json j = Json.to_list InstanceMonitoring.of_json j
  end
module SecurityGroupList =
  struct
    type t = SecurityGroup.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map SecurityGroup.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list SecurityGroup.to_query v
    let to_json v = `List (List.map SecurityGroup.to_json v)
    let of_json j = Json.to_list SecurityGroup.of_json j
  end
module VpnConnectionIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "VpnConnectionId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ActiveInstanceSet =
  struct
    type t = ActiveInstance.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ActiveInstance.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ActiveInstance.to_query v
    let to_json v = `List (List.map ActiveInstance.to_json v)
    let of_json j = Json.to_list ActiveInstance.of_json j
  end
module SnapshotAttributeName =
  struct
    type t =
      | ProductCodes 
      | CreateVolumePermission 
    let str_to_t =
      [("createVolumePermission", CreateVolumePermission);
      ("productCodes", ProductCodes)]
    let t_to_str =
      [(CreateVolumePermission, "createVolumePermission");
      (ProductCodes, "productCodes")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module BlobAttributeValue =
  struct
    type t = {
      value: Blob.t option }
    let make ?value  () = { value }
    let parse xml =
      Some { value = (Util.option_bind (Xml.member "value" xml) Blob.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (Blob.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (Blob.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") Blob.of_json) }
  end
module InstanceBlockDeviceMappingSpecificationList =
  struct
    type t = InstanceBlockDeviceMappingSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceBlockDeviceMappingSpecification.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list InstanceBlockDeviceMappingSpecification.to_query v
    let to_json v =
      `List (List.map InstanceBlockDeviceMappingSpecification.to_json v)
    let of_json j =
      Json.to_list InstanceBlockDeviceMappingSpecification.of_json j
  end
module InternetGatewayList =
  struct
    type t = InternetGateway.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InternetGateway.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InternetGateway.to_query v
    let to_json v = `List (List.map InternetGateway.to_json v)
    let of_json j = Json.to_list InternetGateway.of_json j
  end
module NetworkInterfaceIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module AccountAttributeNameStringList =
  struct
    type t = AccountAttributeName.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AccountAttributeName.parse
           (Xml.members "attributeName" xml))
    let to_query v = Query.to_query_list AccountAttributeName.to_query v
    let to_json v = `List (List.map AccountAttributeName.to_json v)
    let of_json j = Json.to_list AccountAttributeName.of_json j
  end
module ConversionIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ZoneNameStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "ZoneName" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module VpnGatewayIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "VpnGatewayId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ReservedInstancesModificationIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse
           (Xml.members "ReservedInstancesModificationId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module SpotFleetRequestConfigSet =
  struct
    type t = SpotFleetRequestConfig.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SpotFleetRequestConfig.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list SpotFleetRequestConfig.to_query v
    let to_json v = `List (List.map SpotFleetRequestConfig.to_json v)
    let of_json j = Json.to_list SpotFleetRequestConfig.of_json j
  end
module VolumeAttributeName =
  struct
    type t =
      | AutoEnableIO 
      | ProductCodes 
    let str_to_t =
      [("productCodes", ProductCodes); ("autoEnableIO", AutoEnableIO)]
    let t_to_str =
      [(ProductCodes, "productCodes"); (AutoEnableIO, "autoEnableIO")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module PlacementGroupStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module AvailabilityZoneList =
  struct
    type t = AvailabilityZone.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AvailabilityZone.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list AvailabilityZone.to_query v
    let to_json v = `List (List.map AvailabilityZone.to_json v)
    let of_json j = Json.to_list AvailabilityZone.of_json j
  end
module CustomerGatewayList =
  struct
    type t = CustomerGateway.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CustomerGateway.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list CustomerGateway.to_query v
    let to_json v = `List (List.map CustomerGateway.to_json v)
    let of_json j = Json.to_list CustomerGateway.of_json j
  end
module FlowLogSet =
  struct
    type t = FlowLog.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map FlowLog.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list FlowLog.to_query v
    let to_json v = `List (List.map FlowLog.to_json v)
    let of_json j = Json.to_list FlowLog.of_json j
  end
module BundleTaskList =
  struct
    type t = BundleTask.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map BundleTask.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list BundleTask.to_query v
    let to_json v = `List (List.map BundleTask.to_json v)
    let of_json j = Json.to_list BundleTask.of_json j
  end
module VolumeStatusList =
  struct
    type t = VolumeStatusItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VolumeStatusItem.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VolumeStatusItem.to_query v
    let to_json v = `List (List.map VolumeStatusItem.to_json v)
    let of_json j = Json.to_list VolumeStatusItem.of_json j
  end
module SubnetIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "SubnetId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module CreateVolumePermissionModifications =
  struct
    type t =
      {
      add: CreateVolumePermissionList.t ;
      remove: CreateVolumePermissionList.t }
    let make ?(add= [])  ?(remove= [])  () = { add; remove }
    let parse xml =
      Some
        {
          add =
            (Util.of_option []
               (Util.option_bind (Xml.member "Add" xml)
                  CreateVolumePermissionList.parse));
          remove =
            (Util.of_option []
               (Util.option_bind (Xml.member "Remove" xml)
                  CreateVolumePermissionList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Remove", (CreateVolumePermissionList.to_query v.remove)));
           Some
             (Query.Pair ("Add", (CreateVolumePermissionList.to_query v.add)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("remove", (CreateVolumePermissionList.to_json v.remove));
           Some ("add", (CreateVolumePermissionList.to_json v.add))])
    let of_json j =
      {
        add =
          (CreateVolumePermissionList.of_json
             (Util.of_option_exn (Json.lookup j "add")));
        remove =
          (CreateVolumePermissionList.of_json
             (Util.of_option_exn (Json.lookup j "remove")))
      }
  end
module VolumeList =
  struct
    type t = Volume.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Volume.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Volume.to_query v
    let to_json v = `List (List.map Volume.to_json v)
    let of_json j = Json.to_list Volume.of_json j
  end
module VpcClassicLinkIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "VpcId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module RegionList =
  struct
    type t = Region.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Region.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Region.to_query v
    let to_json v = `List (List.map Region.to_json v)
    let of_json j = Json.to_list Region.of_json j
  end
module VpnConnectionOptionsSpecification =
  struct
    type t = {
      static_routes_only: Boolean.t option }
    let make ?static_routes_only  () = { static_routes_only }
    let parse xml =
      Some
        {
          static_routes_only =
            (Util.option_bind (Xml.member "staticRoutesOnly" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.static_routes_only
              (fun f -> Query.Pair ("StaticRoutesOnly", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.static_routes_only
              (fun f -> ("static_routes_only", (Boolean.to_json f)))])
    let of_json j =
      {
        static_routes_only =
          (Util.option_map (Json.lookup j "static_routes_only")
             Boolean.of_json)
      }
  end
module ResourceIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module AllocationIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "AllocationId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module PublicIpStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "PublicIp" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module AddressList =
  struct
    type t = Address.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Address.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Address.to_query v
    let to_json v = `List (List.map Address.to_json v)
    let of_json j = Json.to_list Address.of_json j
  end
module ClientData =
  struct
    type t =
      {
      upload_start: DateTime.t option ;
      upload_end: DateTime.t option ;
      upload_size: Double.t option ;
      comment: String.t option }
    let make ?upload_start  ?upload_end  ?upload_size  ?comment  () =
      { upload_start; upload_end; upload_size; comment }
    let parse xml =
      Some
        {
          upload_start =
            (Util.option_bind (Xml.member "UploadStart" xml) DateTime.parse);
          upload_end =
            (Util.option_bind (Xml.member "UploadEnd" xml) DateTime.parse);
          upload_size =
            (Util.option_bind (Xml.member "UploadSize" xml) Double.parse);
          comment =
            (Util.option_bind (Xml.member "Comment" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.comment
              (fun f -> Query.Pair ("Comment", (String.to_query f)));
           Util.option_map v.upload_size
             (fun f -> Query.Pair ("UploadSize", (Double.to_query f)));
           Util.option_map v.upload_end
             (fun f -> Query.Pair ("UploadEnd", (DateTime.to_query f)));
           Util.option_map v.upload_start
             (fun f -> Query.Pair ("UploadStart", (DateTime.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.comment
              (fun f -> ("comment", (String.to_json f)));
           Util.option_map v.upload_size
             (fun f -> ("upload_size", (Double.to_json f)));
           Util.option_map v.upload_end
             (fun f -> ("upload_end", (DateTime.to_json f)));
           Util.option_map v.upload_start
             (fun f -> ("upload_start", (DateTime.to_json f)))])
    let of_json j =
      {
        upload_start =
          (Util.option_map (Json.lookup j "upload_start") DateTime.of_json);
        upload_end =
          (Util.option_map (Json.lookup j "upload_end") DateTime.of_json);
        upload_size =
          (Util.option_map (Json.lookup j "upload_size") Double.of_json);
        comment = (Util.option_map (Json.lookup j "comment") String.of_json)
      }
  end
module SnapshotDiskContainer =
  struct
    type t =
      {
      description: String.t option ;
      format: String.t option ;
      url: String.t option ;
      user_bucket: UserBucket.t option }
    let make ?description  ?format  ?url  ?user_bucket  () =
      { description; format; url; user_bucket }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          format = (Util.option_bind (Xml.member "Format" xml) String.parse);
          url = (Util.option_bind (Xml.member "Url" xml) String.parse);
          user_bucket =
            (Util.option_bind (Xml.member "UserBucket" xml) UserBucket.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f -> Query.Pair ("UserBucket", (UserBucket.to_query f)));
           Util.option_map v.url
             (fun f -> Query.Pair ("Url", (String.to_query f)));
           Util.option_map v.format
             (fun f -> Query.Pair ("Format", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f -> ("user_bucket", (UserBucket.to_json f)));
           Util.option_map v.url (fun f -> ("url", (String.to_json f)));
           Util.option_map v.format (fun f -> ("format", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        format = (Util.option_map (Json.lookup j "format") String.of_json);
        url = (Util.option_map (Json.lookup j "url") String.of_json);
        user_bucket =
          (Util.option_map (Json.lookup j "user_bucket") UserBucket.of_json)
      }
  end
module VpnConnectionList =
  struct
    type t = VpnConnection.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map VpnConnection.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VpnConnection.to_query v
    let to_json v = `List (List.map VpnConnection.to_json v)
    let of_json j = Json.to_list VpnConnection.of_json j
  end
module ReservedInstancesOfferingList =
  struct
    type t = ReservedInstancesOffering.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReservedInstancesOffering.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ReservedInstancesOffering.to_query v
    let to_json v = `List (List.map ReservedInstancesOffering.to_json v)
    let of_json j = Json.to_list ReservedInstancesOffering.of_json j
  end
module ReservationList =
  struct
    type t = Reservation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Reservation.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Reservation.to_query v
    let to_json v = `List (List.map Reservation.to_json v)
    let of_json j = Json.to_list Reservation.of_json j
  end
module VolumeIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "VolumeId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module RegionNameStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "RegionName" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module VpcPeeringConnectionList =
  struct
    type t = VpcPeeringConnection.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VpcPeeringConnection.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VpcPeeringConnection.to_query v
    let to_json v = `List (List.map VpcPeeringConnection.to_json v)
    let of_json j = Json.to_list VpcPeeringConnection.of_json j
  end
module VpcList =
  struct
    type t = Vpc.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Vpc.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Vpc.to_query v
    let to_json v = `List (List.map Vpc.to_json v)
    let of_json j = Json.to_list Vpc.of_json j
  end
module NetworkAclList =
  struct
    type t = NetworkAcl.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map NetworkAcl.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list NetworkAcl.to_query v
    let to_json v = `List (List.map NetworkAcl.to_json v)
    let of_json j = Json.to_list NetworkAcl.of_json j
  end
module SubnetList =
  struct
    type t = Subnet.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Subnet.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Subnet.to_query v
    let to_json v = `List (List.map Subnet.to_json v)
    let of_json j = Json.to_list Subnet.of_json j
  end
module VpcClassicLinkList =
  struct
    type t = VpcClassicLink.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VpcClassicLink.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VpcClassicLink.to_query v
    let to_json v = `List (List.map VpcClassicLink.to_json v)
    let of_json j = Json.to_list VpcClassicLink.of_json j
  end
module ImportImageTaskList =
  struct
    type t = ImportImageTask.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ImportImageTask.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ImportImageTask.to_query v
    let to_json v = `List (List.map ImportImageTask.to_json v)
    let of_json j = Json.to_list ImportImageTask.of_json j
  end
module FlowLogsResourceType =
  struct
    type t =
      | VPC 
      | Subnet 
      | NetworkInterface 
    let str_to_t =
      [("NetworkInterface", NetworkInterface);
      ("Subnet", Subnet);
      ("VPC", VPC)]
    let t_to_str =
      [(NetworkInterface, "NetworkInterface");
      (Subnet, "Subnet");
      (VPC, "VPC")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CancelSpotFleetRequestsErrorSet =
  struct
    type t = CancelSpotFleetRequestsErrorItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CancelSpotFleetRequestsErrorItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list CancelSpotFleetRequestsErrorItem.to_query v
    let to_json v =
      `List (List.map CancelSpotFleetRequestsErrorItem.to_json v)
    let of_json j = Json.to_list CancelSpotFleetRequestsErrorItem.of_json j
  end
module CancelSpotFleetRequestsSuccessSet =
  struct
    type t = CancelSpotFleetRequestsSuccessItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CancelSpotFleetRequestsSuccessItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list CancelSpotFleetRequestsSuccessItem.to_query v
    let to_json v =
      `List (List.map CancelSpotFleetRequestsSuccessItem.to_json v)
    let of_json j = Json.to_list CancelSpotFleetRequestsSuccessItem.of_json j
  end
module AccountAttributeList =
  struct
    type t = AccountAttribute.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AccountAttribute.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list AccountAttribute.to_query v
    let to_json v = `List (List.map AccountAttribute.to_json v)
    let of_json j = Json.to_list AccountAttribute.of_json j
  end
module DhcpOptionsIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "DhcpOptionsId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module SpotPriceHistoryList =
  struct
    type t = SpotPrice.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map SpotPrice.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list SpotPrice.to_query v
    let to_json v = `List (List.map SpotPrice.to_json v)
    let of_json j = Json.to_list SpotPrice.of_json j
  end
module ReasonCodesList =
  struct
    type t = ReportInstanceReasonCodes.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReportInstanceReasonCodes.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ReportInstanceReasonCodes.to_query v
    let to_json v = `List (List.map ReportInstanceReasonCodes.to_json v)
    let of_json j = Json.to_list ReportInstanceReasonCodes.of_json j
  end
module ReportStatusType =
  struct
    type t =
      | Ok 
      | Impaired 
    let str_to_t = [("impaired", Impaired); ("ok", Ok)]
    let t_to_str = [(Impaired, "impaired"); (Ok, "ok")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VpcIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "VpcId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module DiskImageList =
  struct
    type t = DiskImage.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map DiskImage.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list DiskImage.to_query v
    let to_json v = `List (List.map DiskImage.to_json v)
    let of_json j = Json.to_list DiskImage.of_json j
  end
module ImportInstanceLaunchSpecification =
  struct
    type t =
      {
      architecture: ArchitectureValues.t option ;
      group_names: SecurityGroupStringList.t ;
      group_ids: SecurityGroupIdStringList.t ;
      additional_info: String.t option ;
      user_data: UserData.t option ;
      instance_type: InstanceType.t option ;
      placement: Placement.t option ;
      monitoring: Boolean.t option ;
      subnet_id: String.t option ;
      instance_initiated_shutdown_behavior: ShutdownBehavior.t option ;
      private_ip_address: String.t option }
    let make ?architecture  ?(group_names= [])  ?(group_ids= []) 
      ?additional_info  ?user_data  ?instance_type  ?placement  ?monitoring 
      ?subnet_id  ?instance_initiated_shutdown_behavior  ?private_ip_address 
      () =
      {
        architecture;
        group_names;
        group_ids;
        additional_info;
        user_data;
        instance_type;
        placement;
        monitoring;
        subnet_id;
        instance_initiated_shutdown_behavior;
        private_ip_address
      }
    let parse xml =
      Some
        {
          architecture =
            (Util.option_bind (Xml.member "architecture" xml)
               ArchitectureValues.parse);
          group_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "GroupName" xml)
                  SecurityGroupStringList.parse));
          group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "GroupId" xml)
                  SecurityGroupIdStringList.parse));
          additional_info =
            (Util.option_bind (Xml.member "additionalInfo" xml) String.parse);
          user_data =
            (Util.option_bind (Xml.member "userData" xml) UserData.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          placement =
            (Util.option_bind (Xml.member "placement" xml) Placement.parse);
          monitoring =
            (Util.option_bind (Xml.member "monitoring" xml) Boolean.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          instance_initiated_shutdown_behavior =
            (Util.option_bind
               (Xml.member "instanceInitiatedShutdownBehavior" xml)
               ShutdownBehavior.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInitiatedShutdownBehavior",
                    (ShutdownBehavior.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.monitoring
             (fun f -> Query.Pair ("Monitoring", (Boolean.to_query f)));
           Util.option_map v.placement
             (fun f -> Query.Pair ("Placement", (Placement.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.user_data
             (fun f -> Query.Pair ("UserData", (UserData.to_query f)));
           Util.option_map v.additional_info
             (fun f -> Query.Pair ("AdditionalInfo", (String.to_query f)));
           Some
             (Query.Pair
                ("GroupId", (SecurityGroupIdStringList.to_query v.group_ids)));
           Some
             (Query.Pair
                ("GroupName",
                  (SecurityGroupStringList.to_query v.group_names)));
           Util.option_map v.architecture
             (fun f ->
                Query.Pair ("Architecture", (ArchitectureValues.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                ("instance_initiated_shutdown_behavior",
                  (ShutdownBehavior.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.monitoring
             (fun f -> ("monitoring", (Boolean.to_json f)));
           Util.option_map v.placement
             (fun f -> ("placement", (Placement.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.user_data
             (fun f -> ("user_data", (UserData.to_json f)));
           Util.option_map v.additional_info
             (fun f -> ("additional_info", (String.to_json f)));
           Some
             ("group_ids", (SecurityGroupIdStringList.to_json v.group_ids));
           Some
             ("group_names", (SecurityGroupStringList.to_json v.group_names));
           Util.option_map v.architecture
             (fun f -> ("architecture", (ArchitectureValues.to_json f)))])
    let of_json j =
      {
        architecture =
          (Util.option_map (Json.lookup j "architecture")
             ArchitectureValues.of_json);
        group_names =
          (SecurityGroupStringList.of_json
             (Util.of_option_exn (Json.lookup j "group_names")));
        group_ids =
          (SecurityGroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "group_ids")));
        additional_info =
          (Util.option_map (Json.lookup j "additional_info") String.of_json);
        user_data =
          (Util.option_map (Json.lookup j "user_data") UserData.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        placement =
          (Util.option_map (Json.lookup j "placement") Placement.of_json);
        monitoring =
          (Util.option_map (Json.lookup j "monitoring") Boolean.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        instance_initiated_shutdown_behavior =
          (Util.option_map
             (Json.lookup j "instance_initiated_shutdown_behavior")
             ShutdownBehavior.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json)
      }
  end
module VpcEndpointSet =
  struct
    type t = VpcEndpoint.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map VpcEndpoint.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VpcEndpoint.to_query v
    let to_json v = `List (List.map VpcEndpoint.to_json v)
    let of_json j = Json.to_list VpcEndpoint.of_json j
  end
module ImageDiskContainerList =
  struct
    type t = ImageDiskContainer.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ImageDiskContainer.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ImageDiskContainer.to_query v
    let to_json v = `List (List.map ImageDiskContainer.to_json v)
    let of_json j = Json.to_list ImageDiskContainer.of_json j
  end
module ClassicLinkInstanceList =
  struct
    type t = ClassicLinkInstance.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ClassicLinkInstance.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ClassicLinkInstance.to_query v
    let to_json v = `List (List.map ClassicLinkInstance.to_json v)
    let of_json j = Json.to_list ClassicLinkInstance.of_json j
  end
module ImageAttributeName =
  struct
    type t =
      | Description 
      | Kernel 
      | Ramdisk 
      | LaunchPermission 
      | ProductCodes 
      | BlockDeviceMapping 
      | SriovNetSupport 
    let str_to_t =
      [("sriovNetSupport", SriovNetSupport);
      ("blockDeviceMapping", BlockDeviceMapping);
      ("productCodes", ProductCodes);
      ("launchPermission", LaunchPermission);
      ("ramdisk", Ramdisk);
      ("kernel", Kernel);
      ("description", Description)]
    let t_to_str =
      [(SriovNetSupport, "sriovNetSupport");
      (BlockDeviceMapping, "blockDeviceMapping");
      (ProductCodes, "productCodes");
      (LaunchPermission, "launchPermission");
      (Ramdisk, "ramdisk");
      (Kernel, "kernel");
      (Description, "description")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SnapshotList =
  struct
    type t = Snapshot.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Snapshot.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Snapshot.to_query v
    let to_json v = `List (List.map Snapshot.to_json v)
    let of_json j = Json.to_list Snapshot.of_json j
  end
module NetworkInterfaceAttribute =
  struct
    type t =
      | Description 
      | GroupSet 
      | SourceDestCheck 
      | Attachment 
    let str_to_t =
      [("attachment", Attachment);
      ("sourceDestCheck", SourceDestCheck);
      ("groupSet", GroupSet);
      ("description", Description)]
    let t_to_str =
      [(Attachment, "attachment");
      (SourceDestCheck, "sourceDestCheck");
      (GroupSet, "groupSet");
      (Description, "description")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ReservedInstanceLimitPrice =
  struct
    type t =
      {
      amount: Double.t option ;
      currency_code: CurrencyCodeValues.t option }
    let make ?amount  ?currency_code  () = { amount; currency_code }
    let parse xml =
      Some
        {
          amount = (Util.option_bind (Xml.member "amount" xml) Double.parse);
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.currency_code
              (fun f ->
                 Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)));
           Util.option_map v.amount
             (fun f -> Query.Pair ("Amount", (Double.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.currency_code
              (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)));
           Util.option_map v.amount (fun f -> ("amount", (Double.to_json f)))])
    let of_json j =
      {
        amount = (Util.option_map (Json.lookup j "amount") Double.of_json);
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json)
      }
  end
module ResetImageAttributeName =
  struct
    type t =
      | LaunchPermission 
    let str_to_t = [("launchPermission", LaunchPermission)]
    let t_to_str = [(LaunchPermission, "launchPermission")]
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module NewDhcpConfigurationList =
  struct
    type t = NewDhcpConfiguration.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map NewDhcpConfiguration.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list NewDhcpConfiguration.to_query v
    let to_json v = `List (List.map NewDhcpConfiguration.to_json v)
    let of_json j = Json.to_list NewDhcpConfiguration.of_json j
  end
module DescribeVpcAttributeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_id: String.t ;
      attribute: VpcAttributeName.t option }
    let make ?dry_run  ~vpc_id  ?attribute  () =
      { dry_run; vpc_id; attribute }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          attribute =
            (Util.option_bind (Xml.member "Attribute" xml)
               VpcAttributeName.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.attribute
              (fun f ->
                 Query.Pair ("Attribute", (VpcAttributeName.to_query f)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.attribute
              (fun f -> ("attribute", (VpcAttributeName.to_json f)));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        attribute =
          (Util.option_map (Json.lookup j "attribute")
             VpcAttributeName.of_json)
      }
  end
module DeleteNetworkAclRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      network_acl_id: String.t }
    let make ?dry_run  ~network_acl_id  () = { dry_run; network_acl_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_acl_id =
            (Xml.required "networkAclId"
               (Util.option_bind (Xml.member "networkAclId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("NetworkAclId", (String.to_query v.network_acl_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("network_acl_id", (String.to_json v.network_acl_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_acl_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_acl_id")))
      }
  end
module CreateImageRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_id: String.t ;
      name: String.t ;
      description: String.t option ;
      no_reboot: Boolean.t option ;
      block_device_mappings: BlockDeviceMappingRequestList.t }
    let make ?dry_run  ~instance_id  ~name  ?description  ?no_reboot 
      ?(block_device_mappings= [])  () =
      {
        dry_run;
        instance_id;
        name;
        description;
        no_reboot;
        block_device_mappings
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          name =
            (Xml.required "name"
               (Util.option_bind (Xml.member "name" xml) String.parse));
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          no_reboot =
            (Util.option_bind (Xml.member "noReboot" xml) Boolean.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  BlockDeviceMappingRequestList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("BlockDeviceMapping",
                   (BlockDeviceMappingRequestList.to_query
                      v.block_device_mappings)));
           Util.option_map v.no_reboot
             (fun f -> Query.Pair ("NoReboot", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some (Query.Pair ("Name", (String.to_query v.name)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("block_device_mappings",
                (BlockDeviceMappingRequestList.to_json
                   v.block_device_mappings));
           Util.option_map v.no_reboot
             (fun f -> ("no_reboot", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some ("name", (String.to_json v.name));
           Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        no_reboot =
          (Util.option_map (Json.lookup j "no_reboot") Boolean.of_json);
        block_device_mappings =
          (BlockDeviceMappingRequestList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")))
      }
  end
module DescribeNetworkInterfacesResult =
  struct
    type t = {
      network_interfaces: NetworkInterfaceList.t }
    let make ?(network_interfaces= [])  () = { network_interfaces }
    let parse xml =
      Some
        {
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkInterfaceSet" xml)
                  NetworkInterfaceList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("NetworkInterfaceSet",
                   (NetworkInterfaceList.to_query v.network_interfaces)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("network_interfaces",
                (NetworkInterfaceList.to_json v.network_interfaces))])
    let of_json j =
      {
        network_interfaces =
          (NetworkInterfaceList.of_json
             (Util.of_option_exn (Json.lookup j "network_interfaces")))
      }
  end
module CreateVpcRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      cidr_block: String.t ;
      instance_tenancy: Tenancy.t option }
    let make ?dry_run  ~cidr_block  ?instance_tenancy  () =
      { dry_run; cidr_block; instance_tenancy }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          cidr_block =
            (Xml.required "CidrBlock"
               (Util.option_bind (Xml.member "CidrBlock" xml) String.parse));
          instance_tenancy =
            (Util.option_bind (Xml.member "instanceTenancy" xml)
               Tenancy.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_tenancy
              (fun f -> Query.Pair ("InstanceTenancy", (Tenancy.to_query f)));
           Some (Query.Pair ("CidrBlock", (String.to_query v.cidr_block)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_tenancy
              (fun f -> ("instance_tenancy", (Tenancy.to_json f)));
           Some ("cidr_block", (String.to_json v.cidr_block));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        cidr_block =
          (String.of_json (Util.of_option_exn (Json.lookup j "cidr_block")));
        instance_tenancy =
          (Util.option_map (Json.lookup j "instance_tenancy") Tenancy.of_json)
      }
  end
module DescribeTagsResult =
  struct
    type t = {
      tags: TagDescriptionList.t ;
      next_token: String.t option }
    let make ?(tags= [])  ?next_token  () = { tags; next_token }
    let parse xml =
      Some
        {
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml)
                  TagDescriptionList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagDescriptionList.to_query v.tags)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("tags", (TagDescriptionList.to_json v.tags))])
    let of_json j =
      {
        tags =
          (TagDescriptionList.of_json
             (Util.of_option_exn (Json.lookup j "tags")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeDhcpOptionsResult =
  struct
    type t = {
      dhcp_options: DhcpOptionsList.t }
    let make ?(dhcp_options= [])  () = { dhcp_options }
    let parse xml =
      Some
        {
          dhcp_options =
            (Util.of_option []
               (Util.option_bind (Xml.member "dhcpOptionsSet" xml)
                  DhcpOptionsList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("DhcpOptionsSet",
                   (DhcpOptionsList.to_query v.dhcp_options)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("dhcp_options", (DhcpOptionsList.to_json v.dhcp_options))])
    let of_json j =
      {
        dhcp_options =
          (DhcpOptionsList.of_json
             (Util.of_option_exn (Json.lookup j "dhcp_options")))
      }
  end
module DescribeVpnGatewaysResult =
  struct
    type t = {
      vpn_gateways: VpnGatewayList.t }
    let make ?(vpn_gateways= [])  () = { vpn_gateways }
    let parse xml =
      Some
        {
          vpn_gateways =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpnGatewaySet" xml)
                  VpnGatewayList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpnGatewaySet", (VpnGatewayList.to_query v.vpn_gateways)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpn_gateways", (VpnGatewayList.to_json v.vpn_gateways))])
    let of_json j =
      {
        vpn_gateways =
          (VpnGatewayList.of_json
             (Util.of_option_exn (Json.lookup j "vpn_gateways")))
      }
  end
module CreateImageResult =
  struct
    type t = {
      image_id: String.t option }
    let make ?image_id  () = { image_id }
    let parse xml =
      Some
        {
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.image_id
              (fun f -> Query.Pair ("ImageId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.image_id
              (fun f -> ("image_id", (String.to_json f)))])
    let of_json j =
      {
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json)
      }
  end
module CreateNetworkAclRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      vpc_id: String.t }
    let make ?dry_run  ~vpc_id  () = { dry_run; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module AuthorizeSecurityGroupEgressRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      group_id: String.t ;
      source_security_group_name: String.t option ;
      source_security_group_owner_id: String.t option ;
      ip_protocol: String.t option ;
      from_port: Integer.t option ;
      to_port: Integer.t option ;
      cidr_ip: String.t option ;
      ip_permissions: IpPermissionList.t }
    let make ?dry_run  ~group_id  ?source_security_group_name 
      ?source_security_group_owner_id  ?ip_protocol  ?from_port  ?to_port 
      ?cidr_ip  ?(ip_permissions= [])  () =
      {
        dry_run;
        group_id;
        source_security_group_name;
        source_security_group_owner_id;
        ip_protocol;
        from_port;
        to_port;
        cidr_ip;
        ip_permissions
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          group_id =
            (Xml.required "groupId"
               (Util.option_bind (Xml.member "groupId" xml) String.parse));
          source_security_group_name =
            (Util.option_bind (Xml.member "sourceSecurityGroupName" xml)
               String.parse);
          source_security_group_owner_id =
            (Util.option_bind (Xml.member "sourceSecurityGroupOwnerId" xml)
               String.parse);
          ip_protocol =
            (Util.option_bind (Xml.member "ipProtocol" xml) String.parse);
          from_port =
            (Util.option_bind (Xml.member "fromPort" xml) Integer.parse);
          to_port =
            (Util.option_bind (Xml.member "toPort" xml) Integer.parse);
          cidr_ip = (Util.option_bind (Xml.member "cidrIp" xml) String.parse);
          ip_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipPermissions" xml)
                  IpPermissionList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("IpPermissions",
                   (IpPermissionList.to_query v.ip_permissions)));
           Util.option_map v.cidr_ip
             (fun f -> Query.Pair ("CidrIp", (String.to_query f)));
           Util.option_map v.to_port
             (fun f -> Query.Pair ("ToPort", (Integer.to_query f)));
           Util.option_map v.from_port
             (fun f -> Query.Pair ("FromPort", (Integer.to_query f)));
           Util.option_map v.ip_protocol
             (fun f -> Query.Pair ("IpProtocol", (String.to_query f)));
           Util.option_map v.source_security_group_owner_id
             (fun f ->
                Query.Pair
                  ("SourceSecurityGroupOwnerId", (String.to_query f)));
           Util.option_map v.source_security_group_name
             (fun f ->
                Query.Pair ("SourceSecurityGroupName", (String.to_query f)));
           Some (Query.Pair ("GroupId", (String.to_query v.group_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("ip_permissions", (IpPermissionList.to_json v.ip_permissions));
           Util.option_map v.cidr_ip
             (fun f -> ("cidr_ip", (String.to_json f)));
           Util.option_map v.to_port
             (fun f -> ("to_port", (Integer.to_json f)));
           Util.option_map v.from_port
             (fun f -> ("from_port", (Integer.to_json f)));
           Util.option_map v.ip_protocol
             (fun f -> ("ip_protocol", (String.to_json f)));
           Util.option_map v.source_security_group_owner_id
             (fun f -> ("source_security_group_owner_id", (String.to_json f)));
           Util.option_map v.source_security_group_name
             (fun f -> ("source_security_group_name", (String.to_json f)));
           Some ("group_id", (String.to_json v.group_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "group_id")));
        source_security_group_name =
          (Util.option_map (Json.lookup j "source_security_group_name")
             String.of_json);
        source_security_group_owner_id =
          (Util.option_map (Json.lookup j "source_security_group_owner_id")
             String.of_json);
        ip_protocol =
          (Util.option_map (Json.lookup j "ip_protocol") String.of_json);
        from_port =
          (Util.option_map (Json.lookup j "from_port") Integer.of_json);
        to_port = (Util.option_map (Json.lookup j "to_port") Integer.of_json);
        cidr_ip = (Util.option_map (Json.lookup j "cidr_ip") String.of_json);
        ip_permissions =
          (IpPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "ip_permissions")))
      }
  end
module CopyImageRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      source_region: String.t ;
      source_image_id: String.t ;
      name: String.t ;
      description: String.t option ;
      client_token: String.t option }
    let make ?dry_run  ~source_region  ~source_image_id  ~name  ?description 
      ?client_token  () =
      {
        dry_run;
        source_region;
        source_image_id;
        name;
        description;
        client_token
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          source_region =
            (Xml.required "SourceRegion"
               (Util.option_bind (Xml.member "SourceRegion" xml) String.parse));
          source_image_id =
            (Xml.required "SourceImageId"
               (Util.option_bind (Xml.member "SourceImageId" xml)
                  String.parse));
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some (Query.Pair ("Name", (String.to_query v.name)));
           Some
             (Query.Pair
                ("SourceImageId", (String.to_query v.source_image_id)));
           Some
             (Query.Pair ("SourceRegion", (String.to_query v.source_region)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some ("name", (String.to_json v.name));
           Some ("source_image_id", (String.to_json v.source_image_id));
           Some ("source_region", (String.to_json v.source_region));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        source_region =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "source_region")));
        source_image_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "source_image_id")));
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module DescribeNetworkInterfaceAttributeResult =
  struct
    type t =
      {
      network_interface_id: String.t option ;
      description: AttributeValue.t option ;
      source_dest_check: AttributeBooleanValue.t option ;
      groups: GroupIdentifierList.t ;
      attachment: NetworkInterfaceAttachment.t option }
    let make ?network_interface_id  ?description  ?source_dest_check 
      ?(groups= [])  ?attachment  () =
      {
        network_interface_id;
        description;
        source_dest_check;
        groups;
        attachment
      }
    let parse xml =
      Some
        {
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml)
               AttributeValue.parse);
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml)
               AttributeBooleanValue.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          attachment =
            (Util.option_bind (Xml.member "attachment" xml)
               NetworkInterfaceAttachment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.attachment
              (fun f ->
                 Query.Pair
                   ("Attachment", (NetworkInterfaceAttachment.to_query f)));
           Some
             (Query.Pair
                ("GroupSet", (GroupIdentifierList.to_query v.groups)));
           Util.option_map v.source_dest_check
             (fun f ->
                Query.Pair
                  ("SourceDestCheck", (AttributeBooleanValue.to_query f)));
           Util.option_map v.description
             (fun f ->
                Query.Pair ("Description", (AttributeValue.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.attachment
              (fun f ->
                 ("attachment", (NetworkInterfaceAttachment.to_json f)));
           Some ("groups", (GroupIdentifierList.to_json v.groups));
           Util.option_map v.source_dest_check
             (fun f ->
                ("source_dest_check", (AttributeBooleanValue.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (AttributeValue.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)))])
    let of_json j =
      {
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        description =
          (Util.option_map (Json.lookup j "description")
             AttributeValue.of_json);
        source_dest_check =
          (Util.option_map (Json.lookup j "source_dest_check")
             AttributeBooleanValue.of_json);
        groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        attachment =
          (Util.option_map (Json.lookup j "attachment")
             NetworkInterfaceAttachment.of_json)
      }
  end
module DescribeReservedInstancesModificationsResult =
  struct
    type t =
      {
      reserved_instances_modifications: ReservedInstancesModificationList.t ;
      next_token: String.t option }
    let make ?(reserved_instances_modifications= [])  ?next_token  () =
      { reserved_instances_modifications; next_token }
    let parse xml =
      Some
        {
          reserved_instances_modifications =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "reservedInstancesModificationsSet" xml)
                  ReservedInstancesModificationList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ReservedInstancesModificationsSet",
                  (ReservedInstancesModificationList.to_query
                     v.reserved_instances_modifications)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("reserved_instances_modifications",
               (ReservedInstancesModificationList.to_json
                  v.reserved_instances_modifications))])
    let of_json j =
      {
        reserved_instances_modifications =
          (ReservedInstancesModificationList.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_modifications")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeReservedInstancesResult =
  struct
    type t = {
      reserved_instances: ReservedInstancesList.t }
    let make ?(reserved_instances= [])  () = { reserved_instances }
    let parse xml =
      Some
        {
          reserved_instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "reservedInstancesSet" xml)
                  ReservedInstancesList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesSet",
                   (ReservedInstancesList.to_query v.reserved_instances)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances",
                (ReservedInstancesList.to_json v.reserved_instances))])
    let of_json j =
      {
        reserved_instances =
          (ReservedInstancesList.of_json
             (Util.of_option_exn (Json.lookup j "reserved_instances")))
      }
  end
module CreateNetworkAclEntryRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      network_acl_id: String.t ;
      rule_number: Integer.t ;
      protocol: String.t ;
      rule_action: RuleAction.t ;
      egress: Boolean.t ;
      cidr_block: String.t ;
      icmp_type_code: IcmpTypeCode.t option ;
      port_range: PortRange.t option }
    let make ?dry_run  ~network_acl_id  ~rule_number  ~protocol  ~rule_action
       ~egress  ~cidr_block  ?icmp_type_code  ?port_range  () =
      {
        dry_run;
        network_acl_id;
        rule_number;
        protocol;
        rule_action;
        egress;
        cidr_block;
        icmp_type_code;
        port_range
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_acl_id =
            (Xml.required "networkAclId"
               (Util.option_bind (Xml.member "networkAclId" xml) String.parse));
          rule_number =
            (Xml.required "ruleNumber"
               (Util.option_bind (Xml.member "ruleNumber" xml) Integer.parse));
          protocol =
            (Xml.required "protocol"
               (Util.option_bind (Xml.member "protocol" xml) String.parse));
          rule_action =
            (Xml.required "ruleAction"
               (Util.option_bind (Xml.member "ruleAction" xml)
                  RuleAction.parse));
          egress =
            (Xml.required "egress"
               (Util.option_bind (Xml.member "egress" xml) Boolean.parse));
          cidr_block =
            (Xml.required "cidrBlock"
               (Util.option_bind (Xml.member "cidrBlock" xml) String.parse));
          icmp_type_code =
            (Util.option_bind (Xml.member "Icmp" xml) IcmpTypeCode.parse);
          port_range =
            (Util.option_bind (Xml.member "portRange" xml) PortRange.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.port_range
              (fun f -> Query.Pair ("PortRange", (PortRange.to_query f)));
           Util.option_map v.icmp_type_code
             (fun f -> Query.Pair ("Icmp", (IcmpTypeCode.to_query f)));
           Some (Query.Pair ("CidrBlock", (String.to_query v.cidr_block)));
           Some (Query.Pair ("Egress", (Boolean.to_query v.egress)));
           Some
             (Query.Pair ("RuleAction", (RuleAction.to_query v.rule_action)));
           Some (Query.Pair ("Protocol", (String.to_query v.protocol)));
           Some (Query.Pair ("RuleNumber", (Integer.to_query v.rule_number)));
           Some
             (Query.Pair ("NetworkAclId", (String.to_query v.network_acl_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.port_range
              (fun f -> ("port_range", (PortRange.to_json f)));
           Util.option_map v.icmp_type_code
             (fun f -> ("icmp_type_code", (IcmpTypeCode.to_json f)));
           Some ("cidr_block", (String.to_json v.cidr_block));
           Some ("egress", (Boolean.to_json v.egress));
           Some ("rule_action", (RuleAction.to_json v.rule_action));
           Some ("protocol", (String.to_json v.protocol));
           Some ("rule_number", (Integer.to_json v.rule_number));
           Some ("network_acl_id", (String.to_json v.network_acl_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_acl_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_acl_id")));
        rule_number =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "rule_number")));
        protocol =
          (String.of_json (Util.of_option_exn (Json.lookup j "protocol")));
        rule_action =
          (RuleAction.of_json
             (Util.of_option_exn (Json.lookup j "rule_action")));
        egress =
          (Boolean.of_json (Util.of_option_exn (Json.lookup j "egress")));
        cidr_block =
          (String.of_json (Util.of_option_exn (Json.lookup j "cidr_block")));
        icmp_type_code =
          (Util.option_map (Json.lookup j "icmp_type_code")
             IcmpTypeCode.of_json);
        port_range =
          (Util.option_map (Json.lookup j "port_range") PortRange.of_json)
      }
  end
module DescribeTagsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(filters= [])  ?max_results  ?next_token  () =
      { dry_run; filters; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribePlacementGroupsResult =
  struct
    type t = {
      placement_groups: PlacementGroupList.t }
    let make ?(placement_groups= [])  () = { placement_groups }
    let parse xml =
      Some
        {
          placement_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "placementGroupSet" xml)
                  PlacementGroupList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PlacementGroupSet",
                   (PlacementGroupList.to_query v.placement_groups)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("placement_groups",
                (PlacementGroupList.to_json v.placement_groups))])
    let of_json j =
      {
        placement_groups =
          (PlacementGroupList.of_json
             (Util.of_option_exn (Json.lookup j "placement_groups")))
      }
  end
module CreateSubnetRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_id: String.t ;
      cidr_block: String.t ;
      availability_zone: String.t option }
    let make ?dry_run  ~vpc_id  ~cidr_block  ?availability_zone  () =
      { dry_run; vpc_id; cidr_block; availability_zone }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          cidr_block =
            (Xml.required "CidrBlock"
               (Util.option_bind (Xml.member "CidrBlock" xml) String.parse));
          availability_zone =
            (Util.option_bind (Xml.member "AvailabilityZone" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.availability_zone
              (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Some (Query.Pair ("CidrBlock", (String.to_query v.cidr_block)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.availability_zone
              (fun f -> ("availability_zone", (String.to_json f)));
           Some ("cidr_block", (String.to_json v.cidr_block));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        cidr_block =
          (String.of_json (Util.of_option_exn (Json.lookup j "cidr_block")));
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json)
      }
  end
module DeletePlacementGroupRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      group_name: String.t }
    let make ?dry_run  ~group_name  () = { dry_run; group_name }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          group_name =
            (Xml.required "groupName"
               (Util.option_bind (Xml.member "groupName" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("GroupName", (String.to_query v.group_name)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("group_name", (String.to_json v.group_name));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "group_name")))
      }
  end
module DescribeKeyPairsResult =
  struct
    type t = {
      key_pairs: KeyPairList.t }
    let make ?(key_pairs= [])  () = { key_pairs }
    let parse xml =
      Some
        {
          key_pairs =
            (Util.of_option []
               (Util.option_bind (Xml.member "keySet" xml) KeyPairList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("KeySet", (KeyPairList.to_query v.key_pairs)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("key_pairs", (KeyPairList.to_json v.key_pairs))])
    let of_json j =
      {
        key_pairs =
          (KeyPairList.of_json
             (Util.of_option_exn (Json.lookup j "key_pairs")))
      }
  end
module CancelSpotInstanceRequestsResult =
  struct
    type t =
      {
      cancelled_spot_instance_requests: CancelledSpotInstanceRequestList.t }
    let make ?(cancelled_spot_instance_requests= [])  () =
      { cancelled_spot_instance_requests }
    let parse xml =
      Some
        {
          cancelled_spot_instance_requests =
            (Util.of_option []
               (Util.option_bind (Xml.member "spotInstanceRequestSet" xml)
                  CancelledSpotInstanceRequestList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotInstanceRequestSet",
                   (CancelledSpotInstanceRequestList.to_query
                      v.cancelled_spot_instance_requests)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("cancelled_spot_instance_requests",
                (CancelledSpotInstanceRequestList.to_json
                   v.cancelled_spot_instance_requests))])
    let of_json j =
      {
        cancelled_spot_instance_requests =
          (CancelledSpotInstanceRequestList.of_json
             (Util.of_option_exn
                (Json.lookup j "cancelled_spot_instance_requests")))
      }
  end
module CreateSpotDatafeedSubscriptionResult =
  struct
    type t = {
      spot_datafeed_subscription: SpotDatafeedSubscription.t option }
    let make ?spot_datafeed_subscription  () = { spot_datafeed_subscription }
    let parse xml =
      Some
        {
          spot_datafeed_subscription =
            (Util.option_bind (Xml.member "spotDatafeedSubscription" xml)
               SpotDatafeedSubscription.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_datafeed_subscription
              (fun f ->
                 Query.Pair
                   ("SpotDatafeedSubscription",
                     (SpotDatafeedSubscription.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_datafeed_subscription
              (fun f ->
                 ("spot_datafeed_subscription",
                   (SpotDatafeedSubscription.to_json f)))])
    let of_json j =
      {
        spot_datafeed_subscription =
          (Util.option_map (Json.lookup j "spot_datafeed_subscription")
             SpotDatafeedSubscription.of_json)
      }
  end
module ModifyImageAttributeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      image_id: String.t ;
      attribute: String.t option ;
      operation_type: OperationType.t option ;
      user_ids: UserIdStringList.t ;
      user_groups: UserGroupStringList.t ;
      product_codes: ProductCodeStringList.t ;
      value: String.t option ;
      launch_permission: LaunchPermissionModifications.t option ;
      description: AttributeValue.t option }
    let make ?dry_run  ~image_id  ?attribute  ?operation_type  ?(user_ids=
      [])  ?(user_groups= [])  ?(product_codes= [])  ?value 
      ?launch_permission  ?description  () =
      {
        dry_run;
        image_id;
        attribute;
        operation_type;
        user_ids;
        user_groups;
        product_codes;
        value;
        launch_permission;
        description
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          image_id =
            (Xml.required "ImageId"
               (Util.option_bind (Xml.member "ImageId" xml) String.parse));
          attribute =
            (Util.option_bind (Xml.member "Attribute" xml) String.parse);
          operation_type =
            (Util.option_bind (Xml.member "OperationType" xml)
               OperationType.parse);
          user_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "UserId" xml)
                  UserIdStringList.parse));
          user_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "UserGroup" xml)
                  UserGroupStringList.parse));
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "ProductCode" xml)
                  ProductCodeStringList.parse));
          value = (Util.option_bind (Xml.member "Value" xml) String.parse);
          launch_permission =
            (Util.option_bind (Xml.member "LaunchPermission" xml)
               LaunchPermissionModifications.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml)
               AttributeValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f ->
                 Query.Pair ("Description", (AttributeValue.to_query f)));
           Util.option_map v.launch_permission
             (fun f ->
                Query.Pair
                  ("LaunchPermission",
                    (LaunchPermissionModifications.to_query f)));
           Util.option_map v.value
             (fun f -> Query.Pair ("Value", (String.to_query f)));
           Some
             (Query.Pair
                ("ProductCode",
                  (ProductCodeStringList.to_query v.product_codes)));
           Some
             (Query.Pair
                ("UserGroup", (UserGroupStringList.to_query v.user_groups)));
           Some
             (Query.Pair ("UserId", (UserIdStringList.to_query v.user_ids)));
           Util.option_map v.operation_type
             (fun f ->
                Query.Pair ("OperationType", (OperationType.to_query f)));
           Util.option_map v.attribute
             (fun f -> Query.Pair ("Attribute", (String.to_query f)));
           Some (Query.Pair ("ImageId", (String.to_query v.image_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (AttributeValue.to_json f)));
           Util.option_map v.launch_permission
             (fun f ->
                ("launch_permission",
                  (LaunchPermissionModifications.to_json f)));
           Util.option_map v.value (fun f -> ("value", (String.to_json f)));
           Some
             ("product_codes",
               (ProductCodeStringList.to_json v.product_codes));
           Some ("user_groups", (UserGroupStringList.to_json v.user_groups));
           Some ("user_ids", (UserIdStringList.to_json v.user_ids));
           Util.option_map v.operation_type
             (fun f -> ("operation_type", (OperationType.to_json f)));
           Util.option_map v.attribute
             (fun f -> ("attribute", (String.to_json f)));
           Some ("image_id", (String.to_json v.image_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        image_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "image_id")));
        attribute =
          (Util.option_map (Json.lookup j "attribute") String.of_json);
        operation_type =
          (Util.option_map (Json.lookup j "operation_type")
             OperationType.of_json);
        user_ids =
          (UserIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "user_ids")));
        user_groups =
          (UserGroupStringList.of_json
             (Util.of_option_exn (Json.lookup j "user_groups")));
        product_codes =
          (ProductCodeStringList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")));
        value = (Util.option_map (Json.lookup j "value") String.of_json);
        launch_permission =
          (Util.option_map (Json.lookup j "launch_permission")
             LaunchPermissionModifications.of_json);
        description =
          (Util.option_map (Json.lookup j "description")
             AttributeValue.of_json)
      }
  end
module DescribeInstanceAttributeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_id: String.t ;
      attribute: InstanceAttributeName.t }
    let make ?dry_run  ~instance_id  ~attribute  () =
      { dry_run; instance_id; attribute }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          attribute =
            (Xml.required "attribute"
               (Util.option_bind (Xml.member "attribute" xml)
                  InstanceAttributeName.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Attribute", (InstanceAttributeName.to_query v.attribute)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("attribute", (InstanceAttributeName.to_json v.attribute));
           Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        attribute =
          (InstanceAttributeName.of_json
             (Util.of_option_exn (Json.lookup j "attribute")))
      }
  end
module DescribeBundleTasksRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      bundle_ids: BundleIdStringList.t ;
      filters: FilterList.t }
    let make ?dry_run  ?(bundle_ids= [])  ?(filters= [])  () =
      { dry_run; bundle_ids; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          bundle_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "BundleId" xml)
                  BundleIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("BundleId", (BundleIdStringList.to_query v.bundle_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some ("bundle_ids", (BundleIdStringList.to_json v.bundle_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        bundle_ids =
          (BundleIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "bundle_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module DescribeConversionTasksResult =
  struct
    type t = {
      conversion_tasks: DescribeConversionTaskList.t }
    let make ?(conversion_tasks= [])  () = { conversion_tasks }
    let parse xml =
      Some
        {
          conversion_tasks =
            (Util.of_option []
               (Util.option_bind (Xml.member "conversionTasks" xml)
                  DescribeConversionTaskList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ConversionTasks",
                   (DescribeConversionTaskList.to_query v.conversion_tasks)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("conversion_tasks",
                (DescribeConversionTaskList.to_json v.conversion_tasks))])
    let of_json j =
      {
        conversion_tasks =
          (DescribeConversionTaskList.of_json
             (Util.of_option_exn (Json.lookup j "conversion_tasks")))
      }
  end
module CreateInstanceExportTaskRequest =
  struct
    type t =
      {
      description: String.t option ;
      instance_id: String.t ;
      target_environment: ExportEnvironment.t option ;
      export_to_s3_task: ExportToS3TaskSpecification.t option }
    let make ?description  ~instance_id  ?target_environment 
      ?export_to_s3_task  () =
      { description; instance_id; target_environment; export_to_s3_task }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          target_environment =
            (Util.option_bind (Xml.member "targetEnvironment" xml)
               ExportEnvironment.parse);
          export_to_s3_task =
            (Util.option_bind (Xml.member "exportToS3" xml)
               ExportToS3TaskSpecification.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.export_to_s3_task
              (fun f ->
                 Query.Pair
                   ("ExportToS3", (ExportToS3TaskSpecification.to_query f)));
           Util.option_map v.target_environment
             (fun f ->
                Query.Pair
                  ("TargetEnvironment", (ExportEnvironment.to_query f)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.export_to_s3_task
              (fun f ->
                 ("export_to_s3_task",
                   (ExportToS3TaskSpecification.to_json f)));
           Util.option_map v.target_environment
             (fun f -> ("target_environment", (ExportEnvironment.to_json f)));
           Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        target_environment =
          (Util.option_map (Json.lookup j "target_environment")
             ExportEnvironment.of_json);
        export_to_s3_task =
          (Util.option_map (Json.lookup j "export_to_s3_task")
             ExportToS3TaskSpecification.of_json)
      }
  end
module ResetNetworkInterfaceAttributeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      network_interface_id: String.t ;
      source_dest_check: String.t option }
    let make ?dry_run  ~network_interface_id  ?source_dest_check  () =
      { dry_run; network_interface_id; source_dest_check }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_interface_id =
            (Xml.required "networkInterfaceId"
               (Util.option_bind (Xml.member "networkInterfaceId" xml)
                  String.parse));
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.source_dest_check
              (fun f -> Query.Pair ("SourceDestCheck", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceId",
                  (String.to_query v.network_interface_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.source_dest_check
              (fun f -> ("source_dest_check", (String.to_json f)));
           Some
             ("network_interface_id",
               (String.to_json v.network_interface_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")));
        source_dest_check =
          (Util.option_map (Json.lookup j "source_dest_check") String.of_json)
      }
  end
module CreateSecurityGroupResult =
  struct
    type t = {
      group_id: String.t }
    let make ~group_id  () = { group_id }
    let parse xml =
      Some
        {
          group_id =
            (Xml.required "groupId"
               (Util.option_bind (Xml.member "groupId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("GroupId", (String.to_query v.group_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("group_id", (String.to_json v.group_id))])
    let of_json j =
      {
        group_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "group_id")))
      }
  end
module DescribeSpotFleetRequestHistoryResponse =
  struct
    type t =
      {
      spot_fleet_request_id: String.t ;
      start_time: DateTime.t ;
      last_evaluated_time: DateTime.t ;
      history_records: HistoryRecords.t ;
      next_token: String.t option }
    let make ~spot_fleet_request_id  ~start_time  ~last_evaluated_time 
      ~history_records  ?next_token  () =
      {
        spot_fleet_request_id;
        start_time;
        last_evaluated_time;
        history_records;
        next_token
      }
    let parse xml =
      Some
        {
          spot_fleet_request_id =
            (Xml.required "spotFleetRequestId"
               (Util.option_bind (Xml.member "spotFleetRequestId" xml)
                  String.parse));
          start_time =
            (Xml.required "startTime"
               (Util.option_bind (Xml.member "startTime" xml) DateTime.parse));
          last_evaluated_time =
            (Xml.required "lastEvaluatedTime"
               (Util.option_bind (Xml.member "lastEvaluatedTime" xml)
                  DateTime.parse));
          history_records =
            (Xml.required "historyRecordSet"
               (Util.option_bind (Xml.member "historyRecordSet" xml)
                  HistoryRecords.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("HistoryRecordSet",
                  (HistoryRecords.to_query v.history_records)));
           Some
             (Query.Pair
                ("LastEvaluatedTime",
                  (DateTime.to_query v.last_evaluated_time)));
           Some (Query.Pair ("StartTime", (DateTime.to_query v.start_time)));
           Some
             (Query.Pair
                ("SpotFleetRequestId",
                  (String.to_query v.spot_fleet_request_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("history_records", (HistoryRecords.to_json v.history_records));
           Some
             ("last_evaluated_time",
               (DateTime.to_json v.last_evaluated_time));
           Some ("start_time", (DateTime.to_json v.start_time));
           Some
             ("spot_fleet_request_id",
               (String.to_json v.spot_fleet_request_id))])
    let of_json j =
      {
        spot_fleet_request_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_id")));
        start_time =
          (DateTime.of_json (Util.of_option_exn (Json.lookup j "start_time")));
        last_evaluated_time =
          (DateTime.of_json
             (Util.of_option_exn (Json.lookup j "last_evaluated_time")));
        history_records =
          (HistoryRecords.of_json
             (Util.of_option_exn (Json.lookup j "history_records")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CancelReservedInstancesListingRequest =
  struct
    type t = {
      reserved_instances_listing_id: String.t }
    let make ~reserved_instances_listing_id  () =
      { reserved_instances_listing_id }
    let parse xml =
      Some
        {
          reserved_instances_listing_id =
            (Xml.required "reservedInstancesListingId"
               (Util.option_bind
                  (Xml.member "reservedInstancesListingId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesListingId",
                   (String.to_query v.reserved_instances_listing_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances_listing_id",
                (String.to_json v.reserved_instances_listing_id))])
    let of_json j =
      {
        reserved_instances_listing_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_listing_id")))
      }
  end
module DescribeSnapshotsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      snapshot_ids: SnapshotIdStringList.t ;
      owner_ids: OwnerStringList.t ;
      restorable_by_user_ids: RestorableByStringList.t ;
      filters: FilterList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?dry_run  ?(snapshot_ids= [])  ?(owner_ids= []) 
      ?(restorable_by_user_ids= [])  ?(filters= [])  ?next_token 
      ?max_results  () =
      {
        dry_run;
        snapshot_ids;
        owner_ids;
        restorable_by_user_ids;
        filters;
        next_token;
        max_results
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          snapshot_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SnapshotId" xml)
                  SnapshotIdStringList.parse));
          owner_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "Owner" xml)
                  OwnerStringList.parse));
          restorable_by_user_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "RestorableBy" xml)
                  RestorableByStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("RestorableBy",
                  (RestorableByStringList.to_query v.restorable_by_user_ids)));
           Some
             (Query.Pair ("Owner", (OwnerStringList.to_query v.owner_ids)));
           Some
             (Query.Pair
                ("SnapshotId",
                  (SnapshotIdStringList.to_query v.snapshot_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("restorable_by_user_ids",
               (RestorableByStringList.to_json v.restorable_by_user_ids));
           Some ("owner_ids", (OwnerStringList.to_json v.owner_ids));
           Some
             ("snapshot_ids", (SnapshotIdStringList.to_json v.snapshot_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        snapshot_ids =
          (SnapshotIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "snapshot_ids")));
        owner_ids =
          (OwnerStringList.of_json
             (Util.of_option_exn (Json.lookup j "owner_ids")));
        restorable_by_user_ids =
          (RestorableByStringList.of_json
             (Util.of_option_exn (Json.lookup j "restorable_by_user_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module ModifyReservedInstancesRequest =
  struct
    type t =
      {
      client_token: String.t option ;
      reserved_instances_ids: ReservedInstancesIdStringList.t ;
      target_configurations: ReservedInstancesConfigurationList.t }
    let make ?client_token  ~reserved_instances_ids  ~target_configurations 
      () = { client_token; reserved_instances_ids; target_configurations }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          reserved_instances_ids =
            (Xml.required "ReservedInstancesId"
               (Util.option_bind (Xml.member "ReservedInstancesId" xml)
                  ReservedInstancesIdStringList.parse));
          target_configurations =
            (Xml.required "ReservedInstancesConfigurationSetItemType"
               (Util.option_bind
                  (Xml.member "ReservedInstancesConfigurationSetItemType" xml)
                  ReservedInstancesConfigurationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesConfigurationSetItemType",
                   (ReservedInstancesConfigurationList.to_query
                      v.target_configurations)));
           Some
             (Query.Pair
                ("ReservedInstancesId",
                  (ReservedInstancesIdStringList.to_query
                     v.reserved_instances_ids)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("target_configurations",
                (ReservedInstancesConfigurationList.to_json
                   v.target_configurations));
           Some
             ("reserved_instances_ids",
               (ReservedInstancesIdStringList.to_json
                  v.reserved_instances_ids));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        reserved_instances_ids =
          (ReservedInstancesIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "reserved_instances_ids")));
        target_configurations =
          (ReservedInstancesConfigurationList.of_json
             (Util.of_option_exn (Json.lookup j "target_configurations")))
      }
  end
module AssociateRouteTableRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      subnet_id: String.t ;
      route_table_id: String.t }
    let make ?dry_run  ~subnet_id  ~route_table_id  () =
      { dry_run; subnet_id; route_table_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          subnet_id =
            (Xml.required "subnetId"
               (Util.option_bind (Xml.member "subnetId" xml) String.parse));
          route_table_id =
            (Xml.required "routeTableId"
               (Util.option_bind (Xml.member "routeTableId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("RouteTableId", (String.to_query v.route_table_id)));
           Some (Query.Pair ("SubnetId", (String.to_query v.subnet_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("route_table_id", (String.to_json v.route_table_id));
           Some ("subnet_id", (String.to_json v.subnet_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        subnet_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "subnet_id")));
        route_table_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "route_table_id")))
      }
  end
module AssociateAddressResult =
  struct
    type t = {
      association_id: String.t option }
    let make ?association_id  () = { association_id }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.association_id
              (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_id
              (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json)
      }
  end
module CreateCustomerGatewayRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      type_: GatewayType.t ;
      public_ip: String.t ;
      bgp_asn: Integer.t }
    let make ?dry_run  ~type_  ~public_ip  ~bgp_asn  () =
      { dry_run; type_; public_ip; bgp_asn }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          type_ =
            (Xml.required "Type"
               (Util.option_bind (Xml.member "Type" xml) GatewayType.parse));
          public_ip =
            (Xml.required "IpAddress"
               (Util.option_bind (Xml.member "IpAddress" xml) String.parse));
          bgp_asn =
            (Xml.required "BgpAsn"
               (Util.option_bind (Xml.member "BgpAsn" xml) Integer.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("BgpAsn", (Integer.to_query v.bgp_asn)));
           Some (Query.Pair ("IpAddress", (String.to_query v.public_ip)));
           Some (Query.Pair ("Type", (GatewayType.to_query v.type_)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("bgp_asn", (Integer.to_json v.bgp_asn));
           Some ("public_ip", (String.to_json v.public_ip));
           Some ("type_", (GatewayType.to_json v.type_));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        type_ =
          (GatewayType.of_json (Util.of_option_exn (Json.lookup j "type_")));
        public_ip =
          (String.of_json (Util.of_option_exn (Json.lookup j "public_ip")));
        bgp_asn =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "bgp_asn")))
      }
  end
module DescribeSecurityGroupsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      group_names: GroupNameStringList.t ;
      group_ids: GroupIdStringList.t ;
      filters: FilterList.t }
    let make ?dry_run  ?(group_names= [])  ?(group_ids= [])  ?(filters= []) 
      () = { dry_run; group_names; group_ids; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          group_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "GroupName" xml)
                  GroupNameStringList.parse));
          group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "GroupId" xml)
                  GroupIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("GroupId", (GroupIdStringList.to_query v.group_ids)));
           Some
             (Query.Pair
                ("GroupName", (GroupNameStringList.to_query v.group_names)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some ("group_ids", (GroupIdStringList.to_json v.group_ids));
           Some ("group_names", (GroupNameStringList.to_json v.group_names));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_names =
          (GroupNameStringList.of_json
             (Util.of_option_exn (Json.lookup j "group_names")));
        group_ids =
          (GroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "group_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module ReplaceNetworkAclEntryRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      network_acl_id: String.t ;
      rule_number: Integer.t ;
      protocol: String.t ;
      rule_action: RuleAction.t ;
      egress: Boolean.t ;
      cidr_block: String.t ;
      icmp_type_code: IcmpTypeCode.t option ;
      port_range: PortRange.t option }
    let make ?dry_run  ~network_acl_id  ~rule_number  ~protocol  ~rule_action
       ~egress  ~cidr_block  ?icmp_type_code  ?port_range  () =
      {
        dry_run;
        network_acl_id;
        rule_number;
        protocol;
        rule_action;
        egress;
        cidr_block;
        icmp_type_code;
        port_range
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_acl_id =
            (Xml.required "networkAclId"
               (Util.option_bind (Xml.member "networkAclId" xml) String.parse));
          rule_number =
            (Xml.required "ruleNumber"
               (Util.option_bind (Xml.member "ruleNumber" xml) Integer.parse));
          protocol =
            (Xml.required "protocol"
               (Util.option_bind (Xml.member "protocol" xml) String.parse));
          rule_action =
            (Xml.required "ruleAction"
               (Util.option_bind (Xml.member "ruleAction" xml)
                  RuleAction.parse));
          egress =
            (Xml.required "egress"
               (Util.option_bind (Xml.member "egress" xml) Boolean.parse));
          cidr_block =
            (Xml.required "cidrBlock"
               (Util.option_bind (Xml.member "cidrBlock" xml) String.parse));
          icmp_type_code =
            (Util.option_bind (Xml.member "Icmp" xml) IcmpTypeCode.parse);
          port_range =
            (Util.option_bind (Xml.member "portRange" xml) PortRange.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.port_range
              (fun f -> Query.Pair ("PortRange", (PortRange.to_query f)));
           Util.option_map v.icmp_type_code
             (fun f -> Query.Pair ("Icmp", (IcmpTypeCode.to_query f)));
           Some (Query.Pair ("CidrBlock", (String.to_query v.cidr_block)));
           Some (Query.Pair ("Egress", (Boolean.to_query v.egress)));
           Some
             (Query.Pair ("RuleAction", (RuleAction.to_query v.rule_action)));
           Some (Query.Pair ("Protocol", (String.to_query v.protocol)));
           Some (Query.Pair ("RuleNumber", (Integer.to_query v.rule_number)));
           Some
             (Query.Pair ("NetworkAclId", (String.to_query v.network_acl_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.port_range
              (fun f -> ("port_range", (PortRange.to_json f)));
           Util.option_map v.icmp_type_code
             (fun f -> ("icmp_type_code", (IcmpTypeCode.to_json f)));
           Some ("cidr_block", (String.to_json v.cidr_block));
           Some ("egress", (Boolean.to_json v.egress));
           Some ("rule_action", (RuleAction.to_json v.rule_action));
           Some ("protocol", (String.to_json v.protocol));
           Some ("rule_number", (Integer.to_json v.rule_number));
           Some ("network_acl_id", (String.to_json v.network_acl_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_acl_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_acl_id")));
        rule_number =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "rule_number")));
        protocol =
          (String.of_json (Util.of_option_exn (Json.lookup j "protocol")));
        rule_action =
          (RuleAction.of_json
             (Util.of_option_exn (Json.lookup j "rule_action")));
        egress =
          (Boolean.of_json (Util.of_option_exn (Json.lookup j "egress")));
        cidr_block =
          (String.of_json (Util.of_option_exn (Json.lookup j "cidr_block")));
        icmp_type_code =
          (Util.option_map (Json.lookup j "icmp_type_code")
             IcmpTypeCode.of_json);
        port_range =
          (Util.option_map (Json.lookup j "port_range") PortRange.of_json)
      }
  end
module DescribeFlowLogsRequest =
  struct
    type t =
      {
      flow_log_ids: ValueStringList.t ;
      filter: FilterList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(flow_log_ids= [])  ?(filter= [])  ?next_token  ?max_results 
      () = { flow_log_ids; filter; next_token; max_results }
    let parse xml =
      Some
        {
          flow_log_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "FlowLogId" xml)
                  ValueStringList.parse));
          filter =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filter)));
           Some
             (Query.Pair
                ("FlowLogId", (ValueStringList.to_query v.flow_log_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("filter", (FilterList.to_json v.filter));
           Some ("flow_log_ids", (ValueStringList.to_json v.flow_log_ids))])
    let of_json j =
      {
        flow_log_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "flow_log_ids")));
        filter =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filter")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module RequestSpotInstancesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      spot_price: String.t ;
      client_token: String.t option ;
      instance_count: Integer.t option ;
      type_: SpotInstanceType.t option ;
      valid_from: DateTime.t option ;
      valid_until: DateTime.t option ;
      launch_group: String.t option ;
      availability_zone_group: String.t option ;
      launch_specification: RequestSpotLaunchSpecification.t option }
    let make ?dry_run  ~spot_price  ?client_token  ?instance_count  ?type_ 
      ?valid_from  ?valid_until  ?launch_group  ?availability_zone_group 
      ?launch_specification  () =
      {
        dry_run;
        spot_price;
        client_token;
        instance_count;
        type_;
        valid_from;
        valid_until;
        launch_group;
        availability_zone_group;
        launch_specification
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          spot_price =
            (Xml.required "spotPrice"
               (Util.option_bind (Xml.member "spotPrice" xml) String.parse));
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          instance_count =
            (Util.option_bind (Xml.member "instanceCount" xml) Integer.parse);
          type_ =
            (Util.option_bind (Xml.member "type" xml) SpotInstanceType.parse);
          valid_from =
            (Util.option_bind (Xml.member "validFrom" xml) DateTime.parse);
          valid_until =
            (Util.option_bind (Xml.member "validUntil" xml) DateTime.parse);
          launch_group =
            (Util.option_bind (Xml.member "launchGroup" xml) String.parse);
          availability_zone_group =
            (Util.option_bind (Xml.member "availabilityZoneGroup" xml)
               String.parse);
          launch_specification =
            (Util.option_bind (Xml.member "LaunchSpecification" xml)
               RequestSpotLaunchSpecification.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.launch_specification
              (fun f ->
                 Query.Pair
                   ("LaunchSpecification",
                     (RequestSpotLaunchSpecification.to_query f)));
           Util.option_map v.availability_zone_group
             (fun f ->
                Query.Pair ("AvailabilityZoneGroup", (String.to_query f)));
           Util.option_map v.launch_group
             (fun f -> Query.Pair ("LaunchGroup", (String.to_query f)));
           Util.option_map v.valid_until
             (fun f -> Query.Pair ("ValidUntil", (DateTime.to_query f)));
           Util.option_map v.valid_from
             (fun f -> Query.Pair ("ValidFrom", (DateTime.to_query f)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (SpotInstanceType.to_query f)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some (Query.Pair ("SpotPrice", (String.to_query v.spot_price)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.launch_specification
              (fun f ->
                 ("launch_specification",
                   (RequestSpotLaunchSpecification.to_json f)));
           Util.option_map v.availability_zone_group
             (fun f -> ("availability_zone_group", (String.to_json f)));
           Util.option_map v.launch_group
             (fun f -> ("launch_group", (String.to_json f)));
           Util.option_map v.valid_until
             (fun f -> ("valid_until", (DateTime.to_json f)));
           Util.option_map v.valid_from
             (fun f -> ("valid_from", (DateTime.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (SpotInstanceType.to_json f)));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Some ("spot_price", (String.to_json v.spot_price));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        spot_price =
          (String.of_json (Util.of_option_exn (Json.lookup j "spot_price")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        instance_count =
          (Util.option_map (Json.lookup j "instance_count") Integer.of_json);
        type_ =
          (Util.option_map (Json.lookup j "type_") SpotInstanceType.of_json);
        valid_from =
          (Util.option_map (Json.lookup j "valid_from") DateTime.of_json);
        valid_until =
          (Util.option_map (Json.lookup j "valid_until") DateTime.of_json);
        launch_group =
          (Util.option_map (Json.lookup j "launch_group") String.of_json);
        availability_zone_group =
          (Util.option_map (Json.lookup j "availability_zone_group")
             String.of_json);
        launch_specification =
          (Util.option_map (Json.lookup j "launch_specification")
             RequestSpotLaunchSpecification.of_json)
      }
  end
module AssignPrivateIpAddressesRequest =
  struct
    type t =
      {
      network_interface_id: String.t ;
      private_ip_addresses: PrivateIpAddressStringList.t ;
      secondary_private_ip_address_count: Integer.t option ;
      allow_reassignment: Boolean.t option }
    let make ~network_interface_id  ?(private_ip_addresses= []) 
      ?secondary_private_ip_address_count  ?allow_reassignment  () =
      {
        network_interface_id;
        private_ip_addresses;
        secondary_private_ip_address_count;
        allow_reassignment
      }
    let parse xml =
      Some
        {
          network_interface_id =
            (Xml.required "networkInterfaceId"
               (Util.option_bind (Xml.member "networkInterfaceId" xml)
                  String.parse));
          private_ip_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "privateIpAddress" xml)
                  PrivateIpAddressStringList.parse));
          secondary_private_ip_address_count =
            (Util.option_bind
               (Xml.member "secondaryPrivateIpAddressCount" xml)
               Integer.parse);
          allow_reassignment =
            (Util.option_bind (Xml.member "allowReassignment" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.allow_reassignment
              (fun f ->
                 Query.Pair ("AllowReassignment", (Boolean.to_query f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                Query.Pair
                  ("SecondaryPrivateIpAddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddress",
                  (PrivateIpAddressStringList.to_query v.private_ip_addresses)));
           Some
             (Query.Pair
                ("NetworkInterfaceId",
                  (String.to_query v.network_interface_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.allow_reassignment
              (fun f -> ("allow_reassignment", (Boolean.to_json f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                ("secondary_private_ip_address_count", (Integer.to_json f)));
           Some
             ("private_ip_addresses",
               (PrivateIpAddressStringList.to_json v.private_ip_addresses));
           Some
             ("network_interface_id",
               (String.to_json v.network_interface_id))])
    let of_json j =
      {
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")));
        private_ip_addresses =
          (PrivateIpAddressStringList.of_json
             (Util.of_option_exn (Json.lookup j "private_ip_addresses")));
        secondary_private_ip_address_count =
          (Util.option_map
             (Json.lookup j "secondary_private_ip_address_count")
             Integer.of_json);
        allow_reassignment =
          (Util.option_map (Json.lookup j "allow_reassignment")
             Boolean.of_json)
      }
  end
module CreateFlowLogsResult =
  struct
    type t =
      {
      flow_log_ids: ValueStringList.t ;
      client_token: String.t option ;
      unsuccessful: UnsuccessfulItemSet.t }
    let make ?(flow_log_ids= [])  ?client_token  ?(unsuccessful= [])  () =
      { flow_log_ids; client_token; unsuccessful }
    let parse xml =
      Some
        {
          flow_log_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "flowLogIdSet" xml)
                  ValueStringList.parse));
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemSet.to_query v.unsuccessful)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some
             (Query.Pair
                ("FlowLogIdSet", (ValueStringList.to_query v.flow_log_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemSet.to_json v.unsuccessful));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Some ("flow_log_ids", (ValueStringList.to_json v.flow_log_ids))])
    let of_json j =
      {
        flow_log_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "flow_log_ids")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        unsuccessful =
          (UnsuccessfulItemSet.of_json
             (Util.of_option_exn (Json.lookup j "unsuccessful")))
      }
  end
module CreateNetworkInterfaceResult =
  struct
    type t = {
      network_interface: NetworkInterface.t option }
    let make ?network_interface  () = { network_interface }
    let parse xml =
      Some
        {
          network_interface =
            (Util.option_bind (Xml.member "networkInterface" xml)
               NetworkInterface.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.network_interface
              (fun f ->
                 Query.Pair
                   ("NetworkInterface", (NetworkInterface.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.network_interface
              (fun f -> ("network_interface", (NetworkInterface.to_json f)))])
    let of_json j =
      {
        network_interface =
          (Util.option_map (Json.lookup j "network_interface")
             NetworkInterface.of_json)
      }
  end
module RestoreAddressToClassicResult =
  struct
    type t = {
      status: Status.t option ;
      public_ip: String.t option }
    let make ?status  ?public_ip  () = { status; public_ip }
    let parse xml =
      Some
        {
          status = (Util.option_bind (Xml.member "status" xml) Status.parse);
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.public_ip
              (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (Status.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.public_ip
              (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (Status.to_json f)))])
    let of_json j =
      {
        status = (Util.option_map (Json.lookup j "status") Status.of_json);
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json)
      }
  end
module DescribeRouteTablesResult =
  struct
    type t = {
      route_tables: RouteTableList.t }
    let make ?(route_tables= [])  () = { route_tables }
    let parse xml =
      Some
        {
          route_tables =
            (Util.of_option []
               (Util.option_bind (Xml.member "routeTableSet" xml)
                  RouteTableList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("RouteTableSet", (RouteTableList.to_query v.route_tables)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("route_tables", (RouteTableList.to_json v.route_tables))])
    let of_json j =
      {
        route_tables =
          (RouteTableList.of_json
             (Util.of_option_exn (Json.lookup j "route_tables")))
      }
  end
module DescribeSpotDatafeedSubscriptionRequest =
  struct
    type t = {
      dry_run: Boolean.t option }
    let make ?dry_run  () = { dry_run }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      { dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeSnapshotAttributeResult =
  struct
    type t =
      {
      snapshot_id: String.t option ;
      create_volume_permissions: CreateVolumePermissionList.t ;
      product_codes: ProductCodeList.t }
    let make ?snapshot_id  ?(create_volume_permissions= [])  ?(product_codes=
      [])  () = { snapshot_id; create_volume_permissions; product_codes }
    let parse xml =
      Some
        {
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          create_volume_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "createVolumePermission" xml)
                  CreateVolumePermissionList.parse));
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Some
             (Query.Pair
                ("CreateVolumePermission",
                  (CreateVolumePermissionList.to_query
                     v.create_volume_permissions)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Some
             ("create_volume_permissions",
               (CreateVolumePermissionList.to_json
                  v.create_volume_permissions));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)))])
    let of_json j =
      {
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        create_volume_permissions =
          (CreateVolumePermissionList.of_json
             (Util.of_option_exn (Json.lookup j "create_volume_permissions")));
        product_codes =
          (ProductCodeList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")))
      }
  end
module DeleteVpnGatewayRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      vpn_gateway_id: String.t }
    let make ?dry_run  ~vpn_gateway_id  () = { dry_run; vpn_gateway_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpn_gateway_id =
            (Xml.required "VpnGatewayId"
               (Util.option_bind (Xml.member "VpnGatewayId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpnGatewayId", (String.to_query v.vpn_gateway_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpn_gateway_id", (String.to_json v.vpn_gateway_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpn_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_gateway_id")))
      }
  end
module UnassignPrivateIpAddressesRequest =
  struct
    type t =
      {
      network_interface_id: String.t ;
      private_ip_addresses: PrivateIpAddressStringList.t }
    let make ~network_interface_id  ~private_ip_addresses  () =
      { network_interface_id; private_ip_addresses }
    let parse xml =
      Some
        {
          network_interface_id =
            (Xml.required "networkInterfaceId"
               (Util.option_bind (Xml.member "networkInterfaceId" xml)
                  String.parse));
          private_ip_addresses =
            (Xml.required "privateIpAddress"
               (Util.option_bind (Xml.member "privateIpAddress" xml)
                  PrivateIpAddressStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PrivateIpAddress",
                   (PrivateIpAddressStringList.to_query
                      v.private_ip_addresses)));
           Some
             (Query.Pair
                ("NetworkInterfaceId",
                  (String.to_query v.network_interface_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("private_ip_addresses",
                (PrivateIpAddressStringList.to_json v.private_ip_addresses));
           Some
             ("network_interface_id",
               (String.to_json v.network_interface_id))])
    let of_json j =
      {
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")));
        private_ip_addresses =
          (PrivateIpAddressStringList.of_json
             (Util.of_option_exn (Json.lookup j "private_ip_addresses")))
      }
  end
module EnableVpcClassicLinkResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module PurchaseReservedInstancesOfferingResult =
  struct
    type t = {
      reserved_instances_id: String.t option }
    let make ?reserved_instances_id  () = { reserved_instances_id }
    let parse xml =
      Some
        {
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f ->
                 Query.Pair ("ReservedInstancesId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f -> ("reserved_instances_id", (String.to_json f)))])
    let of_json j =
      {
        reserved_instances_id =
          (Util.option_map (Json.lookup j "reserved_instances_id")
             String.of_json)
      }
  end
module ModifyVpcAttributeRequest =
  struct
    type t =
      {
      vpc_id: String.t ;
      enable_dns_support: AttributeBooleanValue.t option ;
      enable_dns_hostnames: AttributeBooleanValue.t option }
    let make ~vpc_id  ?enable_dns_support  ?enable_dns_hostnames  () =
      { vpc_id; enable_dns_support; enable_dns_hostnames }
    let parse xml =
      Some
        {
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse));
          enable_dns_support =
            (Util.option_bind (Xml.member "EnableDnsSupport" xml)
               AttributeBooleanValue.parse);
          enable_dns_hostnames =
            (Util.option_bind (Xml.member "EnableDnsHostnames" xml)
               AttributeBooleanValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enable_dns_hostnames
              (fun f ->
                 Query.Pair
                   ("EnableDnsHostnames", (AttributeBooleanValue.to_query f)));
           Util.option_map v.enable_dns_support
             (fun f ->
                Query.Pair
                  ("EnableDnsSupport", (AttributeBooleanValue.to_query f)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enable_dns_hostnames
              (fun f ->
                 ("enable_dns_hostnames", (AttributeBooleanValue.to_json f)));
           Util.option_map v.enable_dns_support
             (fun f ->
                ("enable_dns_support", (AttributeBooleanValue.to_json f)));
           Some ("vpc_id", (String.to_json v.vpc_id))])
    let of_json j =
      {
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        enable_dns_support =
          (Util.option_map (Json.lookup j "enable_dns_support")
             AttributeBooleanValue.of_json);
        enable_dns_hostnames =
          (Util.option_map (Json.lookup j "enable_dns_hostnames")
             AttributeBooleanValue.of_json)
      }
  end
module RejectVpcPeeringConnectionResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module ReplaceNetworkAclAssociationResult =
  struct
    type t = {
      new_association_id: String.t option }
    let make ?new_association_id  () = { new_association_id }
    let parse xml =
      Some
        {
          new_association_id =
            (Util.option_bind (Xml.member "newAssociationId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.new_association_id
              (fun f -> Query.Pair ("NewAssociationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.new_association_id
              (fun f -> ("new_association_id", (String.to_json f)))])
    let of_json j =
      {
        new_association_id =
          (Util.option_map (Json.lookup j "new_association_id")
             String.of_json)
      }
  end
module ModifyVpcEndpointResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module AttachClassicLinkVpcResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module DeleteSpotDatafeedSubscriptionRequest =
  struct
    type t = {
      dry_run: Boolean.t option }
    let make ?dry_run  () = { dry_run }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      { dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module TerminateInstancesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_ids: InstanceIdStringList.t }
    let make ?dry_run  ~instance_ids  () = { dry_run; instance_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_ids =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstanceId",
                   (InstanceIdStringList.to_query v.instance_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instance_ids", (InstanceIdStringList.to_json v.instance_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")))
      }
  end
module CreateRouteResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module DeleteRouteTableRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      route_table_id: String.t }
    let make ?dry_run  ~route_table_id  () = { dry_run; route_table_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          route_table_id =
            (Xml.required "routeTableId"
               (Util.option_bind (Xml.member "routeTableId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("RouteTableId", (String.to_query v.route_table_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("route_table_id", (String.to_json v.route_table_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        route_table_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "route_table_id")))
      }
  end
module CancelSpotFleetRequestsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      spot_fleet_request_ids: ValueStringList.t ;
      terminate_instances: Boolean.t }
    let make ?dry_run  ~spot_fleet_request_ids  ~terminate_instances  () =
      { dry_run; spot_fleet_request_ids; terminate_instances }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          spot_fleet_request_ids =
            (Xml.required "spotFleetRequestId"
               (Util.option_bind (Xml.member "spotFleetRequestId" xml)
                  ValueStringList.parse));
          terminate_instances =
            (Xml.required "terminateInstances"
               (Util.option_bind (Xml.member "terminateInstances" xml)
                  Boolean.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TerminateInstances",
                   (Boolean.to_query v.terminate_instances)));
           Some
             (Query.Pair
                ("SpotFleetRequestId",
                  (ValueStringList.to_query v.spot_fleet_request_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("terminate_instances",
                (Boolean.to_json v.terminate_instances));
           Some
             ("spot_fleet_request_ids",
               (ValueStringList.to_json v.spot_fleet_request_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        spot_fleet_request_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_ids")));
        terminate_instances =
          (Boolean.of_json
             (Util.of_option_exn (Json.lookup j "terminate_instances")))
      }
  end
module DeleteVpcEndpointsResult =
  struct
    type t = {
      unsuccessful: UnsuccessfulItemSet.t }
    let make ?(unsuccessful= [])  () = { unsuccessful }
    let parse xml =
      Some
        {
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemSet.to_query v.unsuccessful)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemSet.to_json v.unsuccessful))])
    let of_json j =
      {
        unsuccessful =
          (UnsuccessfulItemSet.of_json
             (Util.of_option_exn (Json.lookup j "unsuccessful")))
      }
  end
module CancelBundleTaskRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      bundle_id: String.t }
    let make ?dry_run  ~bundle_id  () = { dry_run; bundle_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          bundle_id =
            (Xml.required "BundleId"
               (Util.option_bind (Xml.member "BundleId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("BundleId", (String.to_query v.bundle_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("bundle_id", (String.to_json v.bundle_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        bundle_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "bundle_id")))
      }
  end
module CopyImageResult =
  struct
    type t = {
      image_id: String.t option }
    let make ?image_id  () = { image_id }
    let parse xml =
      Some
        {
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.image_id
              (fun f -> Query.Pair ("ImageId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.image_id
              (fun f -> ("image_id", (String.to_json f)))])
    let of_json j =
      {
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json)
      }
  end
module CreateInstanceExportTaskResult =
  struct
    type t = {
      export_task: ExportTask.t option }
    let make ?export_task  () = { export_task }
    let parse xml =
      Some
        {
          export_task =
            (Util.option_bind (Xml.member "exportTask" xml) ExportTask.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.export_task
              (fun f -> Query.Pair ("ExportTask", (ExportTask.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.export_task
              (fun f -> ("export_task", (ExportTask.to_json f)))])
    let of_json j =
      {
        export_task =
          (Util.option_map (Json.lookup j "export_task") ExportTask.of_json)
      }
  end
module CreateVpcEndpointRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_id: String.t ;
      service_name: String.t ;
      policy_document: String.t option ;
      route_table_ids: ValueStringList.t ;
      client_token: String.t option }
    let make ?dry_run  ~vpc_id  ~service_name  ?policy_document 
      ?(route_table_ids= [])  ?client_token  () =
      {
        dry_run;
        vpc_id;
        service_name;
        policy_document;
        route_table_ids;
        client_token
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          service_name =
            (Xml.required "ServiceName"
               (Util.option_bind (Xml.member "ServiceName" xml) String.parse));
          policy_document =
            (Util.option_bind (Xml.member "PolicyDocument" xml) String.parse);
          route_table_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "RouteTableId" xml)
                  ValueStringList.parse));
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some
             (Query.Pair
                ("RouteTableId",
                  (ValueStringList.to_query v.route_table_ids)));
           Util.option_map v.policy_document
             (fun f -> Query.Pair ("PolicyDocument", (String.to_query f)));
           Some
             (Query.Pair ("ServiceName", (String.to_query v.service_name)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Some
             ("route_table_ids", (ValueStringList.to_json v.route_table_ids));
           Util.option_map v.policy_document
             (fun f -> ("policy_document", (String.to_json f)));
           Some ("service_name", (String.to_json v.service_name));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        service_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "service_name")));
        policy_document =
          (Util.option_map (Json.lookup j "policy_document") String.of_json);
        route_table_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "route_table_ids")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module DeleteDhcpOptionsRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      dhcp_options_id: String.t }
    let make ?dry_run  ~dhcp_options_id  () = { dry_run; dhcp_options_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          dhcp_options_id =
            (Xml.required "DhcpOptionsId"
               (Util.option_bind (Xml.member "DhcpOptionsId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("DhcpOptionsId", (String.to_query v.dhcp_options_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("dhcp_options_id", (String.to_json v.dhcp_options_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        dhcp_options_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "dhcp_options_id")))
      }
  end
module DescribeImportSnapshotTasksRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      import_task_ids: ImportTaskIdList.t ;
      next_token: String.t option ;
      max_results: Integer.t option ;
      filters: FilterList.t }
    let make ?dry_run  ?(import_task_ids= [])  ?next_token  ?max_results 
      ?(filters= [])  () =
      { dry_run; import_task_ids; next_token; max_results; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          import_task_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "ImportTaskId" xml)
                  ImportTaskIdList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filters", (FilterList.to_query v.filters)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ImportTaskId",
                  (ImportTaskIdList.to_query v.import_task_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("import_task_ids",
               (ImportTaskIdList.to_json v.import_task_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        import_task_ids =
          (ImportTaskIdList.of_json
             (Util.of_option_exn (Json.lookup j "import_task_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module RequestSpotFleetRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      spot_fleet_request_config: SpotFleetRequestConfigData.t }
    let make ?dry_run  ~spot_fleet_request_config  () =
      { dry_run; spot_fleet_request_config }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          spot_fleet_request_config =
            (Xml.required "spotFleetRequestConfig"
               (Util.option_bind (Xml.member "spotFleetRequestConfig" xml)
                  SpotFleetRequestConfigData.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotFleetRequestConfig",
                   (SpotFleetRequestConfigData.to_query
                      v.spot_fleet_request_config)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("spot_fleet_request_config",
                (SpotFleetRequestConfigData.to_json
                   v.spot_fleet_request_config));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        spot_fleet_request_config =
          (SpotFleetRequestConfigData.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_config")))
      }
  end
module DescribeReservedInstancesListingsResult =
  struct
    type t = {
      reserved_instances_listings: ReservedInstancesListingList.t }
    let make ?(reserved_instances_listings= [])  () =
      { reserved_instances_listings }
    let parse xml =
      Some
        {
          reserved_instances_listings =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "reservedInstancesListingsSet" xml)
                  ReservedInstancesListingList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesListingsSet",
                   (ReservedInstancesListingList.to_query
                      v.reserved_instances_listings)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances_listings",
                (ReservedInstancesListingList.to_json
                   v.reserved_instances_listings))])
    let of_json j =
      {
        reserved_instances_listings =
          (ReservedInstancesListingList.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_listings")))
      }
  end
module DeleteSecurityGroupRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      group_name: String.t option ;
      group_id: String.t option }
    let make ?dry_run  ?group_name  ?group_id  () =
      { dry_run; group_name; group_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          group_name =
            (Util.option_bind (Xml.member "GroupName" xml) String.parse);
          group_id =
            (Util.option_bind (Xml.member "GroupId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_id
              (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_id
              (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json)
      }
  end
module DeleteVpcEndpointsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_endpoint_ids: ValueStringList.t }
    let make ?dry_run  ~vpc_endpoint_ids  () = { dry_run; vpc_endpoint_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          vpc_endpoint_ids =
            (Xml.required "VpcEndpointId"
               (Util.option_bind (Xml.member "VpcEndpointId" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpcEndpointId",
                   (ValueStringList.to_query v.vpc_endpoint_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("vpc_endpoint_ids",
                (ValueStringList.to_json v.vpc_endpoint_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_endpoint_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_endpoint_ids")))
      }
  end
module RunInstancesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      image_id: String.t ;
      min_count: Integer.t ;
      max_count: Integer.t ;
      key_name: String.t option ;
      security_groups: SecurityGroupStringList.t ;
      security_group_ids: SecurityGroupIdStringList.t ;
      user_data: String.t option ;
      instance_type: InstanceType.t option ;
      placement: Placement.t option ;
      kernel_id: String.t option ;
      ramdisk_id: String.t option ;
      block_device_mappings: BlockDeviceMappingRequestList.t ;
      monitoring: RunInstancesMonitoringEnabled.t option ;
      subnet_id: String.t option ;
      disable_api_termination: Boolean.t option ;
      instance_initiated_shutdown_behavior: ShutdownBehavior.t option ;
      private_ip_address: String.t option ;
      client_token: String.t option ;
      additional_info: String.t option ;
      network_interfaces: InstanceNetworkInterfaceSpecificationList.t ;
      iam_instance_profile: IamInstanceProfileSpecification.t option ;
      ebs_optimized: Boolean.t option }
    let make ?dry_run  ~image_id  ~min_count  ~max_count  ?key_name 
      ?(security_groups= [])  ?(security_group_ids= [])  ?user_data 
      ?instance_type  ?placement  ?kernel_id  ?ramdisk_id 
      ?(block_device_mappings= [])  ?monitoring  ?subnet_id 
      ?disable_api_termination  ?instance_initiated_shutdown_behavior 
      ?private_ip_address  ?client_token  ?additional_info 
      ?(network_interfaces= [])  ?iam_instance_profile  ?ebs_optimized  () =
      {
        dry_run;
        image_id;
        min_count;
        max_count;
        key_name;
        security_groups;
        security_group_ids;
        user_data;
        instance_type;
        placement;
        kernel_id;
        ramdisk_id;
        block_device_mappings;
        monitoring;
        subnet_id;
        disable_api_termination;
        instance_initiated_shutdown_behavior;
        private_ip_address;
        client_token;
        additional_info;
        network_interfaces;
        iam_instance_profile;
        ebs_optimized
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          image_id =
            (Xml.required "ImageId"
               (Util.option_bind (Xml.member "ImageId" xml) String.parse));
          min_count =
            (Xml.required "MinCount"
               (Util.option_bind (Xml.member "MinCount" xml) Integer.parse));
          max_count =
            (Xml.required "MaxCount"
               (Util.option_bind (Xml.member "MaxCount" xml) Integer.parse));
          key_name =
            (Util.option_bind (Xml.member "KeyName" xml) String.parse);
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroup" xml)
                  SecurityGroupStringList.parse));
          security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  SecurityGroupIdStringList.parse));
          user_data =
            (Util.option_bind (Xml.member "UserData" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "InstanceType" xml)
               InstanceType.parse);
          placement =
            (Util.option_bind (Xml.member "Placement" xml) Placement.parse);
          kernel_id =
            (Util.option_bind (Xml.member "KernelId" xml) String.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "RamdiskId" xml) String.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "BlockDeviceMapping" xml)
                  BlockDeviceMappingRequestList.parse));
          monitoring =
            (Util.option_bind (Xml.member "Monitoring" xml)
               RunInstancesMonitoringEnabled.parse);
          subnet_id =
            (Util.option_bind (Xml.member "SubnetId" xml) String.parse);
          disable_api_termination =
            (Util.option_bind (Xml.member "disableApiTermination" xml)
               Boolean.parse);
          instance_initiated_shutdown_behavior =
            (Util.option_bind
               (Xml.member "instanceInitiatedShutdownBehavior" xml)
               ShutdownBehavior.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          additional_info =
            (Util.option_bind (Xml.member "additionalInfo" xml) String.parse);
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkInterface" xml)
                  InstanceNetworkInterfaceSpecificationList.parse));
          iam_instance_profile =
            (Util.option_bind (Xml.member "iamInstanceProfile" xml)
               IamInstanceProfileSpecification.parse);
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ebs_optimized
              (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile",
                    (IamInstanceProfileSpecification.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterface",
                  (InstanceNetworkInterfaceSpecificationList.to_query
                     v.network_interfaces)));
           Util.option_map v.additional_info
             (fun f -> Query.Pair ("AdditionalInfo", (String.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInitiatedShutdownBehavior",
                    (ShutdownBehavior.to_query f)));
           Util.option_map v.disable_api_termination
             (fun f ->
                Query.Pair ("DisableApiTermination", (Boolean.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.monitoring
             (fun f ->
                Query.Pair
                  ("Monitoring", (RunInstancesMonitoringEnabled.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingRequestList.to_query
                     v.block_device_mappings)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Util.option_map v.placement
             (fun f -> Query.Pair ("Placement", (Placement.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.user_data
             (fun f -> Query.Pair ("UserData", (String.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (SecurityGroupIdStringList.to_query v.security_group_ids)));
           Some
             (Query.Pair
                ("SecurityGroup",
                  (SecurityGroupStringList.to_query v.security_groups)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Some (Query.Pair ("MaxCount", (Integer.to_query v.max_count)));
           Some (Query.Pair ("MinCount", (Integer.to_query v.min_count)));
           Some (Query.Pair ("ImageId", (String.to_query v.image_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ebs_optimized
              (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile",
                  (IamInstanceProfileSpecification.to_json f)));
           Some
             ("network_interfaces",
               (InstanceNetworkInterfaceSpecificationList.to_json
                  v.network_interfaces));
           Util.option_map v.additional_info
             (fun f -> ("additional_info", (String.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                ("instance_initiated_shutdown_behavior",
                  (ShutdownBehavior.to_json f)));
           Util.option_map v.disable_api_termination
             (fun f -> ("disable_api_termination", (Boolean.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.monitoring
             (fun f ->
                ("monitoring", (RunInstancesMonitoringEnabled.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingRequestList.to_json v.block_device_mappings));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Util.option_map v.placement
             (fun f -> ("placement", (Placement.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.user_data
             (fun f -> ("user_data", (String.to_json f)));
           Some
             ("security_group_ids",
               (SecurityGroupIdStringList.to_json v.security_group_ids));
           Some
             ("security_groups",
               (SecurityGroupStringList.to_json v.security_groups));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Some ("max_count", (Integer.to_json v.max_count));
           Some ("min_count", (Integer.to_json v.min_count));
           Some ("image_id", (String.to_json v.image_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        image_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "image_id")));
        min_count =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "min_count")));
        max_count =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "max_count")));
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        security_groups =
          (SecurityGroupStringList.of_json
             (Util.of_option_exn (Json.lookup j "security_groups")));
        security_group_ids =
          (SecurityGroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "security_group_ids")));
        user_data =
          (Util.option_map (Json.lookup j "user_data") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        placement =
          (Util.option_map (Json.lookup j "placement") Placement.of_json);
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id") String.of_json);
        block_device_mappings =
          (BlockDeviceMappingRequestList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        monitoring =
          (Util.option_map (Json.lookup j "monitoring")
             RunInstancesMonitoringEnabled.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        disable_api_termination =
          (Util.option_map (Json.lookup j "disable_api_termination")
             Boolean.of_json);
        instance_initiated_shutdown_behavior =
          (Util.option_map
             (Json.lookup j "instance_initiated_shutdown_behavior")
             ShutdownBehavior.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        additional_info =
          (Util.option_map (Json.lookup j "additional_info") String.of_json);
        network_interfaces =
          (InstanceNetworkInterfaceSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "network_interfaces")));
        iam_instance_profile =
          (Util.option_map (Json.lookup j "iam_instance_profile")
             IamInstanceProfileSpecification.of_json);
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized") Boolean.of_json)
      }
  end
module StartInstancesResult =
  struct
    type t = {
      starting_instances: InstanceStateChangeList.t }
    let make ?(starting_instances= [])  () = { starting_instances }
    let parse xml =
      Some
        {
          starting_instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  InstanceStateChangeList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstancesSet",
                   (InstanceStateChangeList.to_query v.starting_instances)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("starting_instances",
                (InstanceStateChangeList.to_json v.starting_instances))])
    let of_json j =
      {
        starting_instances =
          (InstanceStateChangeList.of_json
             (Util.of_option_exn (Json.lookup j "starting_instances")))
      }
  end
module DisableVpcClassicLinkRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      vpc_id: String.t }
    let make ?dry_run  ~vpc_id  () = { dry_run; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module DeleteNetworkAclEntryRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      network_acl_id: String.t ;
      rule_number: Integer.t ;
      egress: Boolean.t }
    let make ?dry_run  ~network_acl_id  ~rule_number  ~egress  () =
      { dry_run; network_acl_id; rule_number; egress }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_acl_id =
            (Xml.required "networkAclId"
               (Util.option_bind (Xml.member "networkAclId" xml) String.parse));
          rule_number =
            (Xml.required "ruleNumber"
               (Util.option_bind (Xml.member "ruleNumber" xml) Integer.parse));
          egress =
            (Xml.required "egress"
               (Util.option_bind (Xml.member "egress" xml) Boolean.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Egress", (Boolean.to_query v.egress)));
           Some (Query.Pair ("RuleNumber", (Integer.to_query v.rule_number)));
           Some
             (Query.Pair ("NetworkAclId", (String.to_query v.network_acl_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("egress", (Boolean.to_json v.egress));
           Some ("rule_number", (Integer.to_json v.rule_number));
           Some ("network_acl_id", (String.to_json v.network_acl_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_acl_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_acl_id")));
        rule_number =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "rule_number")));
        egress =
          (Boolean.of_json (Util.of_option_exn (Json.lookup j "egress")))
      }
  end
module AllocateAddressResult =
  struct
    type t =
      {
      public_ip: String.t option ;
      domain: DomainType.t option ;
      allocation_id: String.t option }
    let make ?public_ip  ?domain  ?allocation_id  () =
      { public_ip; domain; allocation_id }
    let parse xml =
      Some
        {
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse);
          domain =
            (Util.option_bind (Xml.member "domain" xml) DomainType.parse);
          allocation_id =
            (Util.option_bind (Xml.member "allocationId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.allocation_id
              (fun f -> Query.Pair ("AllocationId", (String.to_query f)));
           Util.option_map v.domain
             (fun f -> Query.Pair ("Domain", (DomainType.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("PublicIp", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.allocation_id
              (fun f -> ("allocation_id", (String.to_json f)));
           Util.option_map v.domain
             (fun f -> ("domain", (DomainType.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)))])
    let of_json j =
      {
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json);
        domain =
          (Util.option_map (Json.lookup j "domain") DomainType.of_json);
        allocation_id =
          (Util.option_map (Json.lookup j "allocation_id") String.of_json)
      }
  end
module DescribeImagesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      image_ids: ImageIdStringList.t ;
      owners: OwnerStringList.t ;
      executable_users: ExecutableByStringList.t ;
      filters: FilterList.t }
    let make ?dry_run  ?(image_ids= [])  ?(owners= [])  ?(executable_users=
      [])  ?(filters= [])  () =
      { dry_run; image_ids; owners; executable_users; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          image_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "ImageId" xml)
                  ImageIdStringList.parse));
          owners =
            (Util.of_option []
               (Util.option_bind (Xml.member "Owner" xml)
                  OwnerStringList.parse));
          executable_users =
            (Util.of_option []
               (Util.option_bind (Xml.member "ExecutableBy" xml)
                  ExecutableByStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("ExecutableBy",
                  (ExecutableByStringList.to_query v.executable_users)));
           Some (Query.Pair ("Owner", (OwnerStringList.to_query v.owners)));
           Some
             (Query.Pair
                ("ImageId", (ImageIdStringList.to_query v.image_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some
             ("executable_users",
               (ExecutableByStringList.to_json v.executable_users));
           Some ("owners", (OwnerStringList.to_json v.owners));
           Some ("image_ids", (ImageIdStringList.to_json v.image_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        image_ids =
          (ImageIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "image_ids")));
        owners =
          (OwnerStringList.of_json
             (Util.of_option_exn (Json.lookup j "owners")));
        executable_users =
          (ExecutableByStringList.of_json
             (Util.of_option_exn (Json.lookup j "executable_users")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module ReplaceNetworkAclAssociationRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      association_id: String.t ;
      network_acl_id: String.t }
    let make ?dry_run  ~association_id  ~network_acl_id  () =
      { dry_run; association_id; network_acl_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          association_id =
            (Xml.required "associationId"
               (Util.option_bind (Xml.member "associationId" xml)
                  String.parse));
          network_acl_id =
            (Xml.required "networkAclId"
               (Util.option_bind (Xml.member "networkAclId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("NetworkAclId", (String.to_query v.network_acl_id)));
           Some
             (Query.Pair
                ("AssociationId", (String.to_query v.association_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("network_acl_id", (String.to_json v.network_acl_id));
           Some ("association_id", (String.to_json v.association_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        association_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "association_id")));
        network_acl_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_acl_id")))
      }
  end
module DescribeVpcEndpointsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_endpoint_ids: ValueStringList.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(vpc_endpoint_ids= [])  ?(filters= [])  ?max_results 
      ?next_token  () =
      { dry_run; vpc_endpoint_ids; filters; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          vpc_endpoint_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VpcEndpointId" xml)
                  ValueStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("VpcEndpointId",
                  (ValueStringList.to_query v.vpc_endpoint_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("vpc_endpoint_ids",
               (ValueStringList.to_json v.vpc_endpoint_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_endpoint_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_endpoint_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeVpcPeeringConnectionsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_peering_connection_ids: ValueStringList.t ;
      filters: FilterList.t }
    let make ?dry_run  ?(vpc_peering_connection_ids= [])  ?(filters= [])  ()
      = { dry_run; vpc_peering_connection_ids; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_peering_connection_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VpcPeeringConnectionId" xml)
                  ValueStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("VpcPeeringConnectionId",
                  (ValueStringList.to_query v.vpc_peering_connection_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some
             ("vpc_peering_connection_ids",
               (ValueStringList.to_json v.vpc_peering_connection_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_peering_connection_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_peering_connection_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module TerminateInstancesResult =
  struct
    type t = {
      terminating_instances: InstanceStateChangeList.t }
    let make ?(terminating_instances= [])  () = { terminating_instances }
    let parse xml =
      Some
        {
          terminating_instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  InstanceStateChangeList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstancesSet",
                   (InstanceStateChangeList.to_query v.terminating_instances)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("terminating_instances",
                (InstanceStateChangeList.to_json v.terminating_instances))])
    let of_json j =
      {
        terminating_instances =
          (InstanceStateChangeList.of_json
             (Util.of_option_exn (Json.lookup j "terminating_instances")))
      }
  end
module DescribeMovingAddressesResult =
  struct
    type t =
      {
      moving_address_statuses: MovingAddressStatusSet.t ;
      next_token: String.t option }
    let make ?(moving_address_statuses= [])  ?next_token  () =
      { moving_address_statuses; next_token }
    let parse xml =
      Some
        {
          moving_address_statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "movingAddressStatusSet" xml)
                  MovingAddressStatusSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("MovingAddressStatusSet",
                  (MovingAddressStatusSet.to_query v.moving_address_statuses)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("moving_address_statuses",
               (MovingAddressStatusSet.to_json v.moving_address_statuses))])
    let of_json j =
      {
        moving_address_statuses =
          (MovingAddressStatusSet.of_json
             (Util.of_option_exn (Json.lookup j "moving_address_statuses")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeExportTasksRequest =
  struct
    type t = {
      export_task_ids: ExportTaskIdStringList.t }
    let make ?(export_task_ids= [])  () = { export_task_ids }
    let parse xml =
      Some
        {
          export_task_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "exportTaskId" xml)
                  ExportTaskIdStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ExportTaskId",
                   (ExportTaskIdStringList.to_query v.export_task_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("export_task_ids",
                (ExportTaskIdStringList.to_json v.export_task_ids))])
    let of_json j =
      {
        export_task_ids =
          (ExportTaskIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "export_task_ids")))
      }
  end
module DescribeReservedInstancesOfferingsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      reserved_instances_offering_ids:
        ReservedInstancesOfferingIdStringList.t ;
      instance_type: InstanceType.t option ;
      availability_zone: String.t option ;
      product_description: RIProductDescription.t option ;
      filters: FilterList.t ;
      instance_tenancy: Tenancy.t option ;
      offering_type: OfferingTypeValues.t option ;
      next_token: String.t option ;
      max_results: Integer.t option ;
      include_marketplace: Boolean.t option ;
      min_duration: Long.t option ;
      max_duration: Long.t option ;
      max_instance_count: Integer.t option }
    let make ?dry_run  ?(reserved_instances_offering_ids= [])  ?instance_type
       ?availability_zone  ?product_description  ?(filters= []) 
      ?instance_tenancy  ?offering_type  ?next_token  ?max_results 
      ?include_marketplace  ?min_duration  ?max_duration  ?max_instance_count
       () =
      {
        dry_run;
        reserved_instances_offering_ids;
        instance_type;
        availability_zone;
        product_description;
        filters;
        instance_tenancy;
        offering_type;
        next_token;
        max_results;
        include_marketplace;
        min_duration;
        max_duration;
        max_instance_count
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          reserved_instances_offering_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "ReservedInstancesOfferingId" xml)
                  ReservedInstancesOfferingIdStringList.parse));
          instance_type =
            (Util.option_bind (Xml.member "InstanceType" xml)
               InstanceType.parse);
          availability_zone =
            (Util.option_bind (Xml.member "AvailabilityZone" xml)
               String.parse);
          product_description =
            (Util.option_bind (Xml.member "ProductDescription" xml)
               RIProductDescription.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          instance_tenancy =
            (Util.option_bind (Xml.member "instanceTenancy" xml)
               Tenancy.parse);
          offering_type =
            (Util.option_bind (Xml.member "offeringType" xml)
               OfferingTypeValues.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          include_marketplace =
            (Util.option_bind (Xml.member "IncludeMarketplace" xml)
               Boolean.parse);
          min_duration =
            (Util.option_bind (Xml.member "MinDuration" xml) Long.parse);
          max_duration =
            (Util.option_bind (Xml.member "MaxDuration" xml) Long.parse);
          max_instance_count =
            (Util.option_bind (Xml.member "MaxInstanceCount" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_instance_count
              (fun f -> Query.Pair ("MaxInstanceCount", (Integer.to_query f)));
           Util.option_map v.max_duration
             (fun f -> Query.Pair ("MaxDuration", (Long.to_query f)));
           Util.option_map v.min_duration
             (fun f -> Query.Pair ("MinDuration", (Long.to_query f)));
           Util.option_map v.include_marketplace
             (fun f ->
                Query.Pair ("IncludeMarketplace", (Boolean.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.offering_type
             (fun f ->
                Query.Pair ("OfferingType", (OfferingTypeValues.to_query f)));
           Util.option_map v.instance_tenancy
             (fun f -> Query.Pair ("InstanceTenancy", (Tenancy.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.product_description
             (fun f ->
                Query.Pair
                  ("ProductDescription", (RIProductDescription.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Some
             (Query.Pair
                ("ReservedInstancesOfferingId",
                  (ReservedInstancesOfferingIdStringList.to_query
                     v.reserved_instances_offering_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_instance_count
              (fun f -> ("max_instance_count", (Integer.to_json f)));
           Util.option_map v.max_duration
             (fun f -> ("max_duration", (Long.to_json f)));
           Util.option_map v.min_duration
             (fun f -> ("min_duration", (Long.to_json f)));
           Util.option_map v.include_marketplace
             (fun f -> ("include_marketplace", (Boolean.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.offering_type
             (fun f -> ("offering_type", (OfferingTypeValues.to_json f)));
           Util.option_map v.instance_tenancy
             (fun f -> ("instance_tenancy", (Tenancy.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.product_description
             (fun f ->
                ("product_description", (RIProductDescription.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Some
             ("reserved_instances_offering_ids",
               (ReservedInstancesOfferingIdStringList.to_json
                  v.reserved_instances_offering_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        reserved_instances_offering_ids =
          (ReservedInstancesOfferingIdStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_offering_ids")));
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        product_description =
          (Util.option_map (Json.lookup j "product_description")
             RIProductDescription.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        instance_tenancy =
          (Util.option_map (Json.lookup j "instance_tenancy") Tenancy.of_json);
        offering_type =
          (Util.option_map (Json.lookup j "offering_type")
             OfferingTypeValues.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        include_marketplace =
          (Util.option_map (Json.lookup j "include_marketplace")
             Boolean.of_json);
        min_duration =
          (Util.option_map (Json.lookup j "min_duration") Long.of_json);
        max_duration =
          (Util.option_map (Json.lookup j "max_duration") Long.of_json);
        max_instance_count =
          (Util.option_map (Json.lookup j "max_instance_count")
             Integer.of_json)
      }
  end
module CreateVpcPeeringConnectionResult =
  struct
    type t = {
      vpc_peering_connection: VpcPeeringConnection.t option }
    let make ?vpc_peering_connection  () = { vpc_peering_connection }
    let parse xml =
      Some
        {
          vpc_peering_connection =
            (Util.option_bind (Xml.member "vpcPeeringConnection" xml)
               VpcPeeringConnection.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection
              (fun f ->
                 Query.Pair
                   ("VpcPeeringConnection",
                     (VpcPeeringConnection.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection
              (fun f ->
                 ("vpc_peering_connection", (VpcPeeringConnection.to_json f)))])
    let of_json j =
      {
        vpc_peering_connection =
          (Util.option_map (Json.lookup j "vpc_peering_connection")
             VpcPeeringConnection.of_json)
      }
  end
module DescribeInstanceStatusResult =
  struct
    type t =
      {
      instance_statuses: InstanceStatusList.t ;
      next_token: String.t option }
    let make ?(instance_statuses= [])  ?next_token  () =
      { instance_statuses; next_token }
    let parse xml =
      Some
        {
          instance_statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceStatusSet" xml)
                  InstanceStatusList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("InstanceStatusSet",
                  (InstanceStatusList.to_query v.instance_statuses)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("instance_statuses",
               (InstanceStatusList.to_json v.instance_statuses))])
    let of_json j =
      {
        instance_statuses =
          (InstanceStatusList.of_json
             (Util.of_option_exn (Json.lookup j "instance_statuses")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateReservedInstancesListingResult =
  struct
    type t = {
      reserved_instances_listings: ReservedInstancesListingList.t }
    let make ?(reserved_instances_listings= [])  () =
      { reserved_instances_listings }
    let parse xml =
      Some
        {
          reserved_instances_listings =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "reservedInstancesListingsSet" xml)
                  ReservedInstancesListingList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesListingsSet",
                   (ReservedInstancesListingList.to_query
                      v.reserved_instances_listings)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances_listings",
                (ReservedInstancesListingList.to_json
                   v.reserved_instances_listings))])
    let of_json j =
      {
        reserved_instances_listings =
          (ReservedInstancesListingList.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_listings")))
      }
  end
module DeleteInternetGatewayRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      internet_gateway_id: String.t }
    let make ?dry_run  ~internet_gateway_id  () =
      { dry_run; internet_gateway_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          internet_gateway_id =
            (Xml.required "internetGatewayId"
               (Util.option_bind (Xml.member "internetGatewayId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InternetGatewayId",
                   (String.to_query v.internet_gateway_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("internet_gateway_id", (String.to_json v.internet_gateway_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        internet_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "internet_gateway_id")))
      }
  end
module DescribeNetworkAclsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      network_acl_ids: ValueStringList.t ;
      filters: FilterList.t }
    let make ?dry_run  ?(network_acl_ids= [])  ?(filters= [])  () =
      { dry_run; network_acl_ids; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_acl_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "NetworkAclId" xml)
                  ValueStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("NetworkAclId",
                  (ValueStringList.to_query v.network_acl_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some
             ("network_acl_ids", (ValueStringList.to_json v.network_acl_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_acl_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "network_acl_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module CreateVpnConnectionRouteRequest =
  struct
    type t = {
      vpn_connection_id: String.t ;
      destination_cidr_block: String.t }
    let make ~vpn_connection_id  ~destination_cidr_block  () =
      { vpn_connection_id; destination_cidr_block }
    let parse xml =
      Some
        {
          vpn_connection_id =
            (Xml.required "VpnConnectionId"
               (Util.option_bind (Xml.member "VpnConnectionId" xml)
                  String.parse));
          destination_cidr_block =
            (Xml.required "DestinationCidrBlock"
               (Util.option_bind (Xml.member "DestinationCidrBlock" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("DestinationCidrBlock",
                   (String.to_query v.destination_cidr_block)));
           Some
             (Query.Pair
                ("VpnConnectionId", (String.to_query v.vpn_connection_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("destination_cidr_block",
                (String.to_json v.destination_cidr_block));
           Some ("vpn_connection_id", (String.to_json v.vpn_connection_id))])
    let of_json j =
      {
        vpn_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_connection_id")));
        destination_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "destination_cidr_block")))
      }
  end
module ConfirmProductInstanceRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      product_code: String.t ;
      instance_id: String.t }
    let make ?dry_run  ~product_code  ~instance_id  () =
      { dry_run; product_code; instance_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          product_code =
            (Xml.required "ProductCode"
               (Util.option_bind (Xml.member "ProductCode" xml) String.parse));
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Some
             (Query.Pair ("ProductCode", (String.to_query v.product_code)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("instance_id", (String.to_json v.instance_id));
           Some ("product_code", (String.to_json v.product_code));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        product_code =
          (String.of_json (Util.of_option_exn (Json.lookup j "product_code")));
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")))
      }
  end
module ModifyNetworkInterfaceAttributeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      network_interface_id: String.t ;
      description: AttributeValue.t option ;
      source_dest_check: AttributeBooleanValue.t option ;
      groups: SecurityGroupIdStringList.t ;
      attachment: NetworkInterfaceAttachmentChanges.t option }
    let make ?dry_run  ~network_interface_id  ?description 
      ?source_dest_check  ?(groups= [])  ?attachment  () =
      {
        dry_run;
        network_interface_id;
        description;
        source_dest_check;
        groups;
        attachment
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_interface_id =
            (Xml.required "networkInterfaceId"
               (Util.option_bind (Xml.member "networkInterfaceId" xml)
                  String.parse));
          description =
            (Util.option_bind (Xml.member "description" xml)
               AttributeValue.parse);
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml)
               AttributeBooleanValue.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  SecurityGroupIdStringList.parse));
          attachment =
            (Util.option_bind (Xml.member "attachment" xml)
               NetworkInterfaceAttachmentChanges.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.attachment
              (fun f ->
                 Query.Pair
                   ("Attachment",
                     (NetworkInterfaceAttachmentChanges.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (SecurityGroupIdStringList.to_query v.groups)));
           Util.option_map v.source_dest_check
             (fun f ->
                Query.Pair
                  ("SourceDestCheck", (AttributeBooleanValue.to_query f)));
           Util.option_map v.description
             (fun f ->
                Query.Pair ("Description", (AttributeValue.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceId",
                  (String.to_query v.network_interface_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.attachment
              (fun f ->
                 ("attachment",
                   (NetworkInterfaceAttachmentChanges.to_json f)));
           Some ("groups", (SecurityGroupIdStringList.to_json v.groups));
           Util.option_map v.source_dest_check
             (fun f ->
                ("source_dest_check", (AttributeBooleanValue.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (AttributeValue.to_json f)));
           Some
             ("network_interface_id",
               (String.to_json v.network_interface_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")));
        description =
          (Util.option_map (Json.lookup j "description")
             AttributeValue.of_json);
        source_dest_check =
          (Util.option_map (Json.lookup j "source_dest_check")
             AttributeBooleanValue.of_json);
        groups =
          (SecurityGroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        attachment =
          (Util.option_map (Json.lookup j "attachment")
             NetworkInterfaceAttachmentChanges.of_json)
      }
  end
module CreateVolumeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      size: Integer.t option ;
      snapshot_id: String.t option ;
      availability_zone: String.t ;
      volume_type: VolumeType.t option ;
      iops: Integer.t option ;
      encrypted: Boolean.t option ;
      kms_key_id: String.t option }
    let make ?dry_run  ?size  ?snapshot_id  ~availability_zone  ?volume_type 
      ?iops  ?encrypted  ?kms_key_id  () =
      {
        dry_run;
        size;
        snapshot_id;
        availability_zone;
        volume_type;
        iops;
        encrypted;
        kms_key_id
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          size = (Util.option_bind (Xml.member "Size" xml) Integer.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "SnapshotId" xml) String.parse);
          availability_zone =
            (Xml.required "AvailabilityZone"
               (Util.option_bind (Xml.member "AvailabilityZone" xml)
                  String.parse));
          volume_type =
            (Util.option_bind (Xml.member "VolumeType" xml) VolumeType.parse);
          iops = (Util.option_bind (Xml.member "Iops" xml) Integer.parse);
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "KmsKeyId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.iops
             (fun f -> Query.Pair ("Iops", (Integer.to_query f)));
           Util.option_map v.volume_type
             (fun f -> Query.Pair ("VolumeType", (VolumeType.to_query f)));
           Some
             (Query.Pair
                ("AvailabilityZone", (String.to_query v.availability_zone)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.size
             (fun f -> Query.Pair ("Size", (Integer.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.iops (fun f -> ("iops", (Integer.to_json f)));
           Util.option_map v.volume_type
             (fun f -> ("volume_type", (VolumeType.to_json f)));
           Some ("availability_zone", (String.to_json v.availability_zone));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.size (fun f -> ("size", (Integer.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        size = (Util.option_map (Json.lookup j "size") Integer.of_json);
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        availability_zone =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "availability_zone")));
        volume_type =
          (Util.option_map (Json.lookup j "volume_type") VolumeType.of_json);
        iops = (Util.option_map (Json.lookup j "iops") Integer.of_json);
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json)
      }
  end
module DescribeImagesResult =
  struct
    type t = {
      images: ImageList.t }
    let make ?(images= [])  () = { images }
    let parse xml =
      Some
        {
          images =
            (Util.of_option []
               (Util.option_bind (Xml.member "imagesSet" xml) ImageList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("ImagesSet", (ImageList.to_query v.images)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt [Some ("images", (ImageList.to_json v.images))])
    let of_json j =
      {
        images =
          (ImageList.of_json (Util.of_option_exn (Json.lookup j "images")))
      }
  end
module EnableVpcClassicLinkRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      vpc_id: String.t }
    let make ?dry_run  ~vpc_id  () = { dry_run; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module CreateReservedInstancesListingRequest =
  struct
    type t =
      {
      reserved_instances_id: String.t ;
      instance_count: Integer.t ;
      price_schedules: PriceScheduleSpecificationList.t ;
      client_token: String.t }
    let make ~reserved_instances_id  ~instance_count  ~price_schedules 
      ~client_token  () =
      { reserved_instances_id; instance_count; price_schedules; client_token
      }
    let parse xml =
      Some
        {
          reserved_instances_id =
            (Xml.required "reservedInstancesId"
               (Util.option_bind (Xml.member "reservedInstancesId" xml)
                  String.parse));
          instance_count =
            (Xml.required "instanceCount"
               (Util.option_bind (Xml.member "instanceCount" xml)
                  Integer.parse));
          price_schedules =
            (Xml.required "priceSchedules"
               (Util.option_bind (Xml.member "priceSchedules" xml)
                  PriceScheduleSpecificationList.parse));
          client_token =
            (Xml.required "clientToken"
               (Util.option_bind (Xml.member "clientToken" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("ClientToken", (String.to_query v.client_token)));
           Some
             (Query.Pair
                ("PriceSchedules",
                  (PriceScheduleSpecificationList.to_query v.price_schedules)));
           Some
             (Query.Pair
                ("InstanceCount", (Integer.to_query v.instance_count)));
           Some
             (Query.Pair
                ("ReservedInstancesId",
                  (String.to_query v.reserved_instances_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("client_token", (String.to_json v.client_token));
           Some
             ("price_schedules",
               (PriceScheduleSpecificationList.to_json v.price_schedules));
           Some ("instance_count", (Integer.to_json v.instance_count));
           Some
             ("reserved_instances_id",
               (String.to_json v.reserved_instances_id))])
    let of_json j =
      {
        reserved_instances_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "reserved_instances_id")));
        instance_count =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "instance_count")));
        price_schedules =
          (PriceScheduleSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "price_schedules")));
        client_token =
          (String.of_json (Util.of_option_exn (Json.lookup j "client_token")))
      }
  end
module DescribeImportSnapshotTasksResult =
  struct
    type t =
      {
      import_snapshot_tasks: ImportSnapshotTaskList.t ;
      next_token: String.t option }
    let make ?(import_snapshot_tasks= [])  ?next_token  () =
      { import_snapshot_tasks; next_token }
    let parse xml =
      Some
        {
          import_snapshot_tasks =
            (Util.of_option []
               (Util.option_bind (Xml.member "importSnapshotTaskSet" xml)
                  ImportSnapshotTaskList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ImportSnapshotTaskSet",
                  (ImportSnapshotTaskList.to_query v.import_snapshot_tasks)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("import_snapshot_tasks",
               (ImportSnapshotTaskList.to_json v.import_snapshot_tasks))])
    let of_json j =
      {
        import_snapshot_tasks =
          (ImportSnapshotTaskList.of_json
             (Util.of_option_exn (Json.lookup j "import_snapshot_tasks")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DisassociateRouteTableRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      association_id: String.t }
    let make ?dry_run  ~association_id  () = { dry_run; association_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          association_id =
            (Xml.required "associationId"
               (Util.option_bind (Xml.member "associationId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AssociationId", (String.to_query v.association_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("association_id", (String.to_json v.association_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        association_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "association_id")))
      }
  end
module DeleteVpnConnectionRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      vpn_connection_id: String.t }
    let make ?dry_run  ~vpn_connection_id  () =
      { dry_run; vpn_connection_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpn_connection_id =
            (Xml.required "VpnConnectionId"
               (Util.option_bind (Xml.member "VpnConnectionId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpnConnectionId", (String.to_query v.vpn_connection_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpn_connection_id", (String.to_json v.vpn_connection_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpn_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_connection_id")))
      }
  end
module CancelSpotInstanceRequestsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      spot_instance_request_ids: SpotInstanceRequestIdList.t }
    let make ?dry_run  ~spot_instance_request_ids  () =
      { dry_run; spot_instance_request_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          spot_instance_request_ids =
            (Xml.required "SpotInstanceRequestId"
               (Util.option_bind (Xml.member "SpotInstanceRequestId" xml)
                  SpotInstanceRequestIdList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotInstanceRequestId",
                   (SpotInstanceRequestIdList.to_query
                      v.spot_instance_request_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("spot_instance_request_ids",
                (SpotInstanceRequestIdList.to_json
                   v.spot_instance_request_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        spot_instance_request_ids =
          (SpotInstanceRequestIdList.of_json
             (Util.of_option_exn (Json.lookup j "spot_instance_request_ids")))
      }
  end
module DescribeKeyPairsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      key_names: KeyNameStringList.t ;
      filters: FilterList.t }
    let make ?dry_run  ?(key_names= [])  ?(filters= [])  () =
      { dry_run; key_names; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          key_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "KeyName" xml)
                  KeyNameStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("KeyName", (KeyNameStringList.to_query v.key_names)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some ("key_names", (KeyNameStringList.to_json v.key_names));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        key_names =
          (KeyNameStringList.of_json
             (Util.of_option_exn (Json.lookup j "key_names")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module RequestSpotInstancesResult =
  struct
    type t = {
      spot_instance_requests: SpotInstanceRequestList.t }
    let make ?(spot_instance_requests= [])  () = { spot_instance_requests }
    let parse xml =
      Some
        {
          spot_instance_requests =
            (Util.of_option []
               (Util.option_bind (Xml.member "spotInstanceRequestSet" xml)
                  SpotInstanceRequestList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotInstanceRequestSet",
                   (SpotInstanceRequestList.to_query v.spot_instance_requests)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("spot_instance_requests",
                (SpotInstanceRequestList.to_json v.spot_instance_requests))])
    let of_json j =
      {
        spot_instance_requests =
          (SpotInstanceRequestList.of_json
             (Util.of_option_exn (Json.lookup j "spot_instance_requests")))
      }
  end
module DescribeReservedInstancesListingsRequest =
  struct
    type t =
      {
      reserved_instances_id: String.t option ;
      reserved_instances_listing_id: String.t option ;
      filters: FilterList.t }
    let make ?reserved_instances_id  ?reserved_instances_listing_id 
      ?(filters= [])  () =
      { reserved_instances_id; reserved_instances_listing_id; filters }
    let parse xml =
      Some
        {
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse);
          reserved_instances_listing_id =
            (Util.option_bind (Xml.member "reservedInstancesListingId" xml)
               String.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "filters" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filters", (FilterList.to_query v.filters)));
           Util.option_map v.reserved_instances_listing_id
             (fun f ->
                Query.Pair
                  ("ReservedInstancesListingId", (String.to_query f)));
           Util.option_map v.reserved_instances_id
             (fun f ->
                Query.Pair ("ReservedInstancesId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.reserved_instances_listing_id
             (fun f -> ("reserved_instances_listing_id", (String.to_json f)));
           Util.option_map v.reserved_instances_id
             (fun f -> ("reserved_instances_id", (String.to_json f)))])
    let of_json j =
      {
        reserved_instances_id =
          (Util.option_map (Json.lookup j "reserved_instances_id")
             String.of_json);
        reserved_instances_listing_id =
          (Util.option_map (Json.lookup j "reserved_instances_listing_id")
             String.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module DescribeSpotPriceHistoryRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      start_time: DateTime.t option ;
      end_time: DateTime.t option ;
      instance_types: InstanceTypeList.t ;
      product_descriptions: ProductDescriptionList.t ;
      filters: FilterList.t ;
      availability_zone: String.t option ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?start_time  ?end_time  ?(instance_types= []) 
      ?(product_descriptions= [])  ?(filters= [])  ?availability_zone 
      ?max_results  ?next_token  () =
      {
        dry_run;
        start_time;
        end_time;
        instance_types;
        product_descriptions;
        filters;
        availability_zone;
        max_results;
        next_token
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          start_time =
            (Util.option_bind (Xml.member "startTime" xml) DateTime.parse);
          end_time =
            (Util.option_bind (Xml.member "endTime" xml) DateTime.parse);
          instance_types =
            (Util.of_option []
               (Util.option_bind (Xml.member "InstanceType" xml)
                  InstanceTypeList.parse));
          product_descriptions =
            (Util.of_option []
               (Util.option_bind (Xml.member "ProductDescription" xml)
                  ProductDescriptionList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("ProductDescription",
                  (ProductDescriptionList.to_query v.product_descriptions)));
           Some
             (Query.Pair
                ("InstanceType",
                  (InstanceTypeList.to_query v.instance_types)));
           Util.option_map v.end_time
             (fun f -> Query.Pair ("EndTime", (DateTime.to_query f)));
           Util.option_map v.start_time
             (fun f -> Query.Pair ("StartTime", (DateTime.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("product_descriptions",
               (ProductDescriptionList.to_json v.product_descriptions));
           Some
             ("instance_types", (InstanceTypeList.to_json v.instance_types));
           Util.option_map v.end_time
             (fun f -> ("end_time", (DateTime.to_json f)));
           Util.option_map v.start_time
             (fun f -> ("start_time", (DateTime.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        start_time =
          (Util.option_map (Json.lookup j "start_time") DateTime.of_json);
        end_time =
          (Util.option_map (Json.lookup j "end_time") DateTime.of_json);
        instance_types =
          (InstanceTypeList.of_json
             (Util.of_option_exn (Json.lookup j "instance_types")));
        product_descriptions =
          (ProductDescriptionList.of_json
             (Util.of_option_exn (Json.lookup j "product_descriptions")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module MoveAddressToVpcResult =
  struct
    type t = {
      allocation_id: String.t option ;
      status: Status.t option }
    let make ?allocation_id  ?status  () = { allocation_id; status }
    let parse xml =
      Some
        {
          allocation_id =
            (Util.option_bind (Xml.member "allocationId" xml) String.parse);
          status = (Util.option_bind (Xml.member "status" xml) Status.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (Status.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (Status.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)))])
    let of_json j =
      {
        allocation_id =
          (Util.option_map (Json.lookup j "allocation_id") String.of_json);
        status = (Util.option_map (Json.lookup j "status") Status.of_json)
      }
  end
module CancelImportTaskResult =
  struct
    type t =
      {
      import_task_id: String.t option ;
      state: String.t option ;
      previous_state: String.t option }
    let make ?import_task_id  ?state  ?previous_state  () =
      { import_task_id; state; previous_state }
    let parse xml =
      Some
        {
          import_task_id =
            (Util.option_bind (Xml.member "importTaskId" xml) String.parse);
          state = (Util.option_bind (Xml.member "state" xml) String.parse);
          previous_state =
            (Util.option_bind (Xml.member "previousState" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.previous_state
              (fun f -> Query.Pair ("PreviousState", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (String.to_query f)));
           Util.option_map v.import_task_id
             (fun f -> Query.Pair ("ImportTaskId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.previous_state
              (fun f -> ("previous_state", (String.to_json f)));
           Util.option_map v.state (fun f -> ("state", (String.to_json f)));
           Util.option_map v.import_task_id
             (fun f -> ("import_task_id", (String.to_json f)))])
    let of_json j =
      {
        import_task_id =
          (Util.option_map (Json.lookup j "import_task_id") String.of_json);
        state = (Util.option_map (Json.lookup j "state") String.of_json);
        previous_state =
          (Util.option_map (Json.lookup j "previous_state") String.of_json)
      }
  end
module DeleteRouteRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      route_table_id: String.t ;
      destination_cidr_block: String.t }
    let make ?dry_run  ~route_table_id  ~destination_cidr_block  () =
      { dry_run; route_table_id; destination_cidr_block }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          route_table_id =
            (Xml.required "routeTableId"
               (Util.option_bind (Xml.member "routeTableId" xml) String.parse));
          destination_cidr_block =
            (Xml.required "destinationCidrBlock"
               (Util.option_bind (Xml.member "destinationCidrBlock" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("DestinationCidrBlock",
                   (String.to_query v.destination_cidr_block)));
           Some
             (Query.Pair ("RouteTableId", (String.to_query v.route_table_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("destination_cidr_block",
                (String.to_json v.destination_cidr_block));
           Some ("route_table_id", (String.to_json v.route_table_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        route_table_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "route_table_id")));
        destination_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "destination_cidr_block")))
      }
  end
module ResetInstanceAttributeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_id: String.t ;
      attribute: InstanceAttributeName.t }
    let make ?dry_run  ~instance_id  ~attribute  () =
      { dry_run; instance_id; attribute }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          attribute =
            (Xml.required "attribute"
               (Util.option_bind (Xml.member "attribute" xml)
                  InstanceAttributeName.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Attribute", (InstanceAttributeName.to_query v.attribute)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("attribute", (InstanceAttributeName.to_json v.attribute));
           Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        attribute =
          (InstanceAttributeName.of_json
             (Util.of_option_exn (Json.lookup j "attribute")))
      }
  end
module CopySnapshotResult =
  struct
    type t = {
      snapshot_id: String.t option }
    let make ?snapshot_id  () = { snapshot_id }
    let parse xml =
      Some
        {
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.snapshot_id
              (fun f -> Query.Pair ("SnapshotId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.snapshot_id
              (fun f -> ("snapshot_id", (String.to_json f)))])
    let of_json j =
      {
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json)
      }
  end
module CreateVpnGatewayResult =
  struct
    type t = {
      vpn_gateway: VpnGateway.t option }
    let make ?vpn_gateway  () = { vpn_gateway }
    let parse xml =
      Some
        {
          vpn_gateway =
            (Util.option_bind (Xml.member "vpnGateway" xml) VpnGateway.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpn_gateway
              (fun f -> Query.Pair ("VpnGateway", (VpnGateway.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpn_gateway
              (fun f -> ("vpn_gateway", (VpnGateway.to_json f)))])
    let of_json j =
      {
        vpn_gateway =
          (Util.option_map (Json.lookup j "vpn_gateway") VpnGateway.of_json)
      }
  end
module DeleteVpcRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      vpc_id: String.t }
    let make ?dry_run  ~vpc_id  () = { dry_run; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module CancelExportTaskRequest =
  struct
    type t = {
      export_task_id: String.t }
    let make ~export_task_id  () = { export_task_id }
    let parse xml =
      Some
        {
          export_task_id =
            (Xml.required "exportTaskId"
               (Util.option_bind (Xml.member "exportTaskId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ExportTaskId", (String.to_query v.export_task_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("export_task_id", (String.to_json v.export_task_id))])
    let of_json j =
      {
        export_task_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "export_task_id")))
      }
  end
module DescribeCustomerGatewaysRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      customer_gateway_ids: CustomerGatewayIdStringList.t ;
      filters: FilterList.t }
    let make ?dry_run  ?(customer_gateway_ids= [])  ?(filters= [])  () =
      { dry_run; customer_gateway_ids; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          customer_gateway_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "CustomerGatewayId" xml)
                  CustomerGatewayIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("CustomerGatewayId",
                  (CustomerGatewayIdStringList.to_query
                     v.customer_gateway_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some
             ("customer_gateway_ids",
               (CustomerGatewayIdStringList.to_json v.customer_gateway_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        customer_gateway_ids =
          (CustomerGatewayIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "customer_gateway_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module DescribeExportTasksResult =
  struct
    type t = {
      export_tasks: ExportTaskList.t }
    let make ?(export_tasks= [])  () = { export_tasks }
    let parse xml =
      Some
        {
          export_tasks =
            (Util.of_option []
               (Util.option_bind (Xml.member "exportTaskSet" xml)
                  ExportTaskList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ExportTaskSet", (ExportTaskList.to_query v.export_tasks)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("export_tasks", (ExportTaskList.to_json v.export_tasks))])
    let of_json j =
      {
        export_tasks =
          (ExportTaskList.of_json
             (Util.of_option_exn (Json.lookup j "export_tasks")))
      }
  end
module DescribePrefixListsResult =
  struct
    type t = {
      prefix_lists: PrefixListSet.t ;
      next_token: String.t option }
    let make ?(prefix_lists= [])  ?next_token  () =
      { prefix_lists; next_token }
    let parse xml =
      Some
        {
          prefix_lists =
            (Util.of_option []
               (Util.option_bind (Xml.member "prefixListSet" xml)
                  PrefixListSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("PrefixListSet", (PrefixListSet.to_query v.prefix_lists)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("prefix_lists", (PrefixListSet.to_json v.prefix_lists))])
    let of_json j =
      {
        prefix_lists =
          (PrefixListSet.of_json
             (Util.of_option_exn (Json.lookup j "prefix_lists")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module UnmonitorInstancesResult =
  struct
    type t = {
      instance_monitorings: InstanceMonitoringList.t }
    let make ?(instance_monitorings= [])  () = { instance_monitorings }
    let parse xml =
      Some
        {
          instance_monitorings =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  InstanceMonitoringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstancesSet",
                   (InstanceMonitoringList.to_query v.instance_monitorings)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instance_monitorings",
                (InstanceMonitoringList.to_json v.instance_monitorings))])
    let of_json j =
      {
        instance_monitorings =
          (InstanceMonitoringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_monitorings")))
      }
  end
module DescribeSecurityGroupsResult =
  struct
    type t = {
      security_groups: SecurityGroupList.t }
    let make ?(security_groups= [])  () = { security_groups }
    let parse xml =
      Some
        {
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "securityGroupInfo" xml)
                  SecurityGroupList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SecurityGroupInfo",
                   (SecurityGroupList.to_query v.security_groups)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("security_groups",
                (SecurityGroupList.to_json v.security_groups))])
    let of_json j =
      {
        security_groups =
          (SecurityGroupList.of_json
             (Util.of_option_exn (Json.lookup j "security_groups")))
      }
  end
module DeleteSubnetRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      subnet_id: String.t }
    let make ?dry_run  ~subnet_id  () = { dry_run; subnet_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          subnet_id =
            (Xml.required "SubnetId"
               (Util.option_bind (Xml.member "SubnetId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("SubnetId", (String.to_query v.subnet_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("subnet_id", (String.to_json v.subnet_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        subnet_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "subnet_id")))
      }
  end
module DescribeVpcEndpointServicesResult =
  struct
    type t = {
      service_names: ValueStringList.t ;
      next_token: String.t option }
    let make ?(service_names= [])  ?next_token  () =
      { service_names; next_token }
    let parse xml =
      Some
        {
          service_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "serviceNameSet" xml)
                  ValueStringList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ServiceNameSet",
                  (ValueStringList.to_query v.service_names)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("service_names", (ValueStringList.to_json v.service_names))])
    let of_json j =
      {
        service_names =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "service_names")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeVpnConnectionsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpn_connection_ids: VpnConnectionIdStringList.t ;
      filters: FilterList.t }
    let make ?dry_run  ?(vpn_connection_ids= [])  ?(filters= [])  () =
      { dry_run; vpn_connection_ids; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpn_connection_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VpnConnectionId" xml)
                  VpnConnectionIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("VpnConnectionId",
                  (VpnConnectionIdStringList.to_query v.vpn_connection_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some
             ("vpn_connection_ids",
               (VpnConnectionIdStringList.to_json v.vpn_connection_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpn_connection_ids =
          (VpnConnectionIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "vpn_connection_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module GetConsoleOutputResult =
  struct
    type t =
      {
      instance_id: String.t option ;
      timestamp: DateTime.t option ;
      output: String.t option }
    let make ?instance_id  ?timestamp  ?output  () =
      { instance_id; timestamp; output }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          timestamp =
            (Util.option_bind (Xml.member "timestamp" xml) DateTime.parse);
          output = (Util.option_bind (Xml.member "output" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.output
              (fun f -> Query.Pair ("Output", (String.to_query f)));
           Util.option_map v.timestamp
             (fun f -> Query.Pair ("Timestamp", (DateTime.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.output
              (fun f -> ("output", (String.to_json f)));
           Util.option_map v.timestamp
             (fun f -> ("timestamp", (DateTime.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        timestamp =
          (Util.option_map (Json.lookup j "timestamp") DateTime.of_json);
        output = (Util.option_map (Json.lookup j "output") String.of_json)
      }
  end
module DescribeSpotFleetInstancesResponse =
  struct
    type t =
      {
      spot_fleet_request_id: String.t ;
      active_instances: ActiveInstanceSet.t ;
      next_token: String.t option }
    let make ~spot_fleet_request_id  ~active_instances  ?next_token  () =
      { spot_fleet_request_id; active_instances; next_token }
    let parse xml =
      Some
        {
          spot_fleet_request_id =
            (Xml.required "spotFleetRequestId"
               (Util.option_bind (Xml.member "spotFleetRequestId" xml)
                  String.parse));
          active_instances =
            (Xml.required "activeInstanceSet"
               (Util.option_bind (Xml.member "activeInstanceSet" xml)
                  ActiveInstanceSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ActiveInstanceSet",
                  (ActiveInstanceSet.to_query v.active_instances)));
           Some
             (Query.Pair
                ("SpotFleetRequestId",
                  (String.to_query v.spot_fleet_request_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("active_instances",
               (ActiveInstanceSet.to_json v.active_instances));
           Some
             ("spot_fleet_request_id",
               (String.to_json v.spot_fleet_request_id))])
    let of_json j =
      {
        spot_fleet_request_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_id")));
        active_instances =
          (ActiveInstanceSet.of_json
             (Util.of_option_exn (Json.lookup j "active_instances")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeSnapshotAttributeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      snapshot_id: String.t ;
      attribute: SnapshotAttributeName.t }
    let make ?dry_run  ~snapshot_id  ~attribute  () =
      { dry_run; snapshot_id; attribute }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          snapshot_id =
            (Xml.required "SnapshotId"
               (Util.option_bind (Xml.member "SnapshotId" xml) String.parse));
          attribute =
            (Xml.required "Attribute"
               (Util.option_bind (Xml.member "Attribute" xml)
                  SnapshotAttributeName.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Attribute", (SnapshotAttributeName.to_query v.attribute)));
           Some (Query.Pair ("SnapshotId", (String.to_query v.snapshot_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("attribute", (SnapshotAttributeName.to_json v.attribute));
           Some ("snapshot_id", (String.to_json v.snapshot_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        snapshot_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "snapshot_id")));
        attribute =
          (SnapshotAttributeName.of_json
             (Util.of_option_exn (Json.lookup j "attribute")))
      }
  end
module DeleteVpnConnectionRouteRequest =
  struct
    type t = {
      vpn_connection_id: String.t ;
      destination_cidr_block: String.t }
    let make ~vpn_connection_id  ~destination_cidr_block  () =
      { vpn_connection_id; destination_cidr_block }
    let parse xml =
      Some
        {
          vpn_connection_id =
            (Xml.required "VpnConnectionId"
               (Util.option_bind (Xml.member "VpnConnectionId" xml)
                  String.parse));
          destination_cidr_block =
            (Xml.required "DestinationCidrBlock"
               (Util.option_bind (Xml.member "DestinationCidrBlock" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("DestinationCidrBlock",
                   (String.to_query v.destination_cidr_block)));
           Some
             (Query.Pair
                ("VpnConnectionId", (String.to_query v.vpn_connection_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("destination_cidr_block",
                (String.to_json v.destination_cidr_block));
           Some ("vpn_connection_id", (String.to_json v.vpn_connection_id))])
    let of_json j =
      {
        vpn_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_connection_id")));
        destination_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "destination_cidr_block")))
      }
  end
module CreateSpotDatafeedSubscriptionRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      bucket: String.t ;
      prefix: String.t option }
    let make ?dry_run  ~bucket  ?prefix  () = { dry_run; bucket; prefix }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          bucket =
            (Xml.required "bucket"
               (Util.option_bind (Xml.member "bucket" xml) String.parse));
          prefix = (Util.option_bind (Xml.member "prefix" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.prefix
              (fun f -> Query.Pair ("Prefix", (String.to_query f)));
           Some (Query.Pair ("Bucket", (String.to_query v.bucket)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.prefix
              (fun f -> ("prefix", (String.to_json f)));
           Some ("bucket", (String.to_json v.bucket));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        bucket =
          (String.of_json (Util.of_option_exn (Json.lookup j "bucket")));
        prefix = (Util.option_map (Json.lookup j "prefix") String.of_json)
      }
  end
module DetachClassicLinkVpcRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_id: String.t ;
      vpc_id: String.t }
    let make ?dry_run  ~instance_id  ~vpc_id  () =
      { dry_run; instance_id; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module AttachClassicLinkVpcRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_id: String.t ;
      vpc_id: String.t ;
      groups: GroupIdStringList.t }
    let make ?dry_run  ~instance_id  ~vpc_id  ~groups  () =
      { dry_run; instance_id; vpc_id; groups }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse));
          groups =
            (Xml.required "SecurityGroupId"
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  GroupIdStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SecurityGroupId", (GroupIdStringList.to_query v.groups)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("groups", (GroupIdStringList.to_json v.groups));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        groups =
          (GroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "groups")))
      }
  end
module ModifyInstanceAttributeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_id: String.t ;
      attribute: InstanceAttributeName.t option ;
      value: String.t option ;
      block_device_mappings: InstanceBlockDeviceMappingSpecificationList.t ;
      source_dest_check: AttributeBooleanValue.t option ;
      disable_api_termination: AttributeBooleanValue.t option ;
      instance_type: AttributeValue.t option ;
      kernel: AttributeValue.t option ;
      ramdisk: AttributeValue.t option ;
      user_data: BlobAttributeValue.t option ;
      instance_initiated_shutdown_behavior: AttributeValue.t option ;
      groups: GroupIdStringList.t ;
      ebs_optimized: AttributeBooleanValue.t option ;
      sriov_net_support: AttributeValue.t option }
    let make ?dry_run  ~instance_id  ?attribute  ?value 
      ?(block_device_mappings= [])  ?source_dest_check 
      ?disable_api_termination  ?instance_type  ?kernel  ?ramdisk  ?user_data
       ?instance_initiated_shutdown_behavior  ?(groups= [])  ?ebs_optimized 
      ?sriov_net_support  () =
      {
        dry_run;
        instance_id;
        attribute;
        value;
        block_device_mappings;
        source_dest_check;
        disable_api_termination;
        instance_type;
        kernel;
        ramdisk;
        user_data;
        instance_initiated_shutdown_behavior;
        groups;
        ebs_optimized;
        sriov_net_support
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          attribute =
            (Util.option_bind (Xml.member "attribute" xml)
               InstanceAttributeName.parse);
          value = (Util.option_bind (Xml.member "value" xml) String.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  InstanceBlockDeviceMappingSpecificationList.parse));
          source_dest_check =
            (Util.option_bind (Xml.member "SourceDestCheck" xml)
               AttributeBooleanValue.parse);
          disable_api_termination =
            (Util.option_bind (Xml.member "disableApiTermination" xml)
               AttributeBooleanValue.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               AttributeValue.parse);
          kernel =
            (Util.option_bind (Xml.member "kernel" xml) AttributeValue.parse);
          ramdisk =
            (Util.option_bind (Xml.member "ramdisk" xml) AttributeValue.parse);
          user_data =
            (Util.option_bind (Xml.member "userData" xml)
               BlobAttributeValue.parse);
          instance_initiated_shutdown_behavior =
            (Util.option_bind
               (Xml.member "instanceInitiatedShutdownBehavior" xml)
               AttributeValue.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "GroupId" xml)
                  GroupIdStringList.parse));
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml)
               AttributeBooleanValue.parse);
          sriov_net_support =
            (Util.option_bind (Xml.member "sriovNetSupport" xml)
               AttributeValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.sriov_net_support
              (fun f ->
                 Query.Pair ("SriovNetSupport", (AttributeValue.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f ->
                Query.Pair
                  ("EbsOptimized", (AttributeBooleanValue.to_query f)));
           Some
             (Query.Pair ("GroupId", (GroupIdStringList.to_query v.groups)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInitiatedShutdownBehavior",
                    (AttributeValue.to_query f)));
           Util.option_map v.user_data
             (fun f ->
                Query.Pair ("UserData", (BlobAttributeValue.to_query f)));
           Util.option_map v.ramdisk
             (fun f -> Query.Pair ("Ramdisk", (AttributeValue.to_query f)));
           Util.option_map v.kernel
             (fun f -> Query.Pair ("Kernel", (AttributeValue.to_query f)));
           Util.option_map v.instance_type
             (fun f ->
                Query.Pair ("InstanceType", (AttributeValue.to_query f)));
           Util.option_map v.disable_api_termination
             (fun f ->
                Query.Pair
                  ("DisableApiTermination",
                    (AttributeBooleanValue.to_query f)));
           Util.option_map v.source_dest_check
             (fun f ->
                Query.Pair
                  ("SourceDestCheck", (AttributeBooleanValue.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (InstanceBlockDeviceMappingSpecificationList.to_query
                     v.block_device_mappings)));
           Util.option_map v.value
             (fun f -> Query.Pair ("Value", (String.to_query f)));
           Util.option_map v.attribute
             (fun f ->
                Query.Pair ("Attribute", (InstanceAttributeName.to_query f)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.sriov_net_support
              (fun f -> ("sriov_net_support", (AttributeValue.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (AttributeBooleanValue.to_json f)));
           Some ("groups", (GroupIdStringList.to_json v.groups));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                ("instance_initiated_shutdown_behavior",
                  (AttributeValue.to_json f)));
           Util.option_map v.user_data
             (fun f -> ("user_data", (BlobAttributeValue.to_json f)));
           Util.option_map v.ramdisk
             (fun f -> ("ramdisk", (AttributeValue.to_json f)));
           Util.option_map v.kernel
             (fun f -> ("kernel", (AttributeValue.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (AttributeValue.to_json f)));
           Util.option_map v.disable_api_termination
             (fun f ->
                ("disable_api_termination",
                  (AttributeBooleanValue.to_json f)));
           Util.option_map v.source_dest_check
             (fun f ->
                ("source_dest_check", (AttributeBooleanValue.to_json f)));
           Some
             ("block_device_mappings",
               (InstanceBlockDeviceMappingSpecificationList.to_json
                  v.block_device_mappings));
           Util.option_map v.value (fun f -> ("value", (String.to_json f)));
           Util.option_map v.attribute
             (fun f -> ("attribute", (InstanceAttributeName.to_json f)));
           Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        attribute =
          (Util.option_map (Json.lookup j "attribute")
             InstanceAttributeName.of_json);
        value = (Util.option_map (Json.lookup j "value") String.of_json);
        block_device_mappings =
          (InstanceBlockDeviceMappingSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        source_dest_check =
          (Util.option_map (Json.lookup j "source_dest_check")
             AttributeBooleanValue.of_json);
        disable_api_termination =
          (Util.option_map (Json.lookup j "disable_api_termination")
             AttributeBooleanValue.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             AttributeValue.of_json);
        kernel =
          (Util.option_map (Json.lookup j "kernel") AttributeValue.of_json);
        ramdisk =
          (Util.option_map (Json.lookup j "ramdisk") AttributeValue.of_json);
        user_data =
          (Util.option_map (Json.lookup j "user_data")
             BlobAttributeValue.of_json);
        instance_initiated_shutdown_behavior =
          (Util.option_map
             (Json.lookup j "instance_initiated_shutdown_behavior")
             AttributeValue.of_json);
        groups =
          (GroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized")
             AttributeBooleanValue.of_json);
        sriov_net_support =
          (Util.option_map (Json.lookup j "sriov_net_support")
             AttributeValue.of_json)
      }
  end
module DeleteFlowLogsRequest =
  struct
    type t = {
      flow_log_ids: ValueStringList.t }
    let make ~flow_log_ids  () = { flow_log_ids }
    let parse xml =
      Some
        {
          flow_log_ids =
            (Xml.required "FlowLogId"
               (Util.option_bind (Xml.member "FlowLogId" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("FlowLogId", (ValueStringList.to_query v.flow_log_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("flow_log_ids", (ValueStringList.to_json v.flow_log_ids))])
    let of_json j =
      {
        flow_log_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "flow_log_ids")))
      }
  end
module EnableVgwRoutePropagationRequest =
  struct
    type t = {
      route_table_id: String.t ;
      gateway_id: String.t }
    let make ~route_table_id  ~gateway_id  () =
      { route_table_id; gateway_id }
    let parse xml =
      Some
        {
          route_table_id =
            (Xml.required "RouteTableId"
               (Util.option_bind (Xml.member "RouteTableId" xml) String.parse));
          gateway_id =
            (Xml.required "GatewayId"
               (Util.option_bind (Xml.member "GatewayId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("GatewayId", (String.to_query v.gateway_id)));
           Some
             (Query.Pair ("RouteTableId", (String.to_query v.route_table_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("gateway_id", (String.to_json v.gateway_id));
           Some ("route_table_id", (String.to_json v.route_table_id))])
    let of_json j =
      {
        route_table_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "route_table_id")));
        gateway_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "gateway_id")))
      }
  end
module DescribeInternetGatewaysResult =
  struct
    type t = {
      internet_gateways: InternetGatewayList.t }
    let make ?(internet_gateways= [])  () = { internet_gateways }
    let parse xml =
      Some
        {
          internet_gateways =
            (Util.of_option []
               (Util.option_bind (Xml.member "internetGatewaySet" xml)
                  InternetGatewayList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InternetGatewaySet",
                   (InternetGatewayList.to_query v.internet_gateways)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("internet_gateways",
                (InternetGatewayList.to_json v.internet_gateways))])
    let of_json j =
      {
        internet_gateways =
          (InternetGatewayList.of_json
             (Util.of_option_exn (Json.lookup j "internet_gateways")))
      }
  end
module DescribeNetworkInterfacesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      network_interface_ids: NetworkInterfaceIdList.t ;
      filters: FilterList.t }
    let make ?dry_run  ?(network_interface_ids= [])  ?(filters= [])  () =
      { dry_run; network_interface_ids; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_interface_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "NetworkInterfaceId" xml)
                  NetworkInterfaceIdList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("NetworkInterfaceId",
                  (NetworkInterfaceIdList.to_query v.network_interface_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some
             ("network_interface_ids",
               (NetworkInterfaceIdList.to_json v.network_interface_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_interface_ids =
          (NetworkInterfaceIdList.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module DescribeAccountAttributesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      attribute_names: AccountAttributeNameStringList.t }
    let make ?dry_run  ?(attribute_names= [])  () =
      { dry_run; attribute_names }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          attribute_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "attributeName" xml)
                  AccountAttributeNameStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AttributeName",
                   (AccountAttributeNameStringList.to_query v.attribute_names)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("attribute_names",
                (AccountAttributeNameStringList.to_json v.attribute_names));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        attribute_names =
          (AccountAttributeNameStringList.of_json
             (Util.of_option_exn (Json.lookup j "attribute_names")))
      }
  end
module DescribeConversionTasksRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      conversion_task_ids: ConversionIdStringList.t }
    let make ?dry_run  ?(filters= [])  ?(conversion_task_ids= [])  () =
      { dry_run; filters; conversion_task_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "filter" xml) FilterList.parse));
          conversion_task_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "conversionTaskId" xml)
                  ConversionIdStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ConversionTaskId",
                   (ConversionIdStringList.to_query v.conversion_task_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("conversion_task_ids",
                (ConversionIdStringList.to_json v.conversion_task_ids));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        conversion_task_ids =
          (ConversionIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "conversion_task_ids")))
      }
  end
module ModifyVpcEndpointRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_endpoint_id: String.t ;
      reset_policy: Boolean.t option ;
      policy_document: String.t option ;
      add_route_table_ids: ValueStringList.t ;
      remove_route_table_ids: ValueStringList.t }
    let make ?dry_run  ~vpc_endpoint_id  ?reset_policy  ?policy_document 
      ?(add_route_table_ids= [])  ?(remove_route_table_ids= [])  () =
      {
        dry_run;
        vpc_endpoint_id;
        reset_policy;
        policy_document;
        add_route_table_ids;
        remove_route_table_ids
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          vpc_endpoint_id =
            (Xml.required "VpcEndpointId"
               (Util.option_bind (Xml.member "VpcEndpointId" xml)
                  String.parse));
          reset_policy =
            (Util.option_bind (Xml.member "ResetPolicy" xml) Boolean.parse);
          policy_document =
            (Util.option_bind (Xml.member "PolicyDocument" xml) String.parse);
          add_route_table_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "AddRouteTableId" xml)
                  ValueStringList.parse));
          remove_route_table_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "RemoveRouteTableId" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("RemoveRouteTableId",
                   (ValueStringList.to_query v.remove_route_table_ids)));
           Some
             (Query.Pair
                ("AddRouteTableId",
                  (ValueStringList.to_query v.add_route_table_ids)));
           Util.option_map v.policy_document
             (fun f -> Query.Pair ("PolicyDocument", (String.to_query f)));
           Util.option_map v.reset_policy
             (fun f -> Query.Pair ("ResetPolicy", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("VpcEndpointId", (String.to_query v.vpc_endpoint_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("remove_route_table_ids",
                (ValueStringList.to_json v.remove_route_table_ids));
           Some
             ("add_route_table_ids",
               (ValueStringList.to_json v.add_route_table_ids));
           Util.option_map v.policy_document
             (fun f -> ("policy_document", (String.to_json f)));
           Util.option_map v.reset_policy
             (fun f -> ("reset_policy", (Boolean.to_json f)));
           Some ("vpc_endpoint_id", (String.to_json v.vpc_endpoint_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpc_endpoint_id")));
        reset_policy =
          (Util.option_map (Json.lookup j "reset_policy") Boolean.of_json);
        policy_document =
          (Util.option_map (Json.lookup j "policy_document") String.of_json);
        add_route_table_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "add_route_table_ids")));
        remove_route_table_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "remove_route_table_ids")))
      }
  end
module ModifyVolumeAttributeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      volume_id: String.t ;
      auto_enable_i_o: AttributeBooleanValue.t option }
    let make ?dry_run  ~volume_id  ?auto_enable_i_o  () =
      { dry_run; volume_id; auto_enable_i_o }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          volume_id =
            (Xml.required "VolumeId"
               (Util.option_bind (Xml.member "VolumeId" xml) String.parse));
          auto_enable_i_o =
            (Util.option_bind (Xml.member "AutoEnableIO" xml)
               AttributeBooleanValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.auto_enable_i_o
              (fun f ->
                 Query.Pair
                   ("AutoEnableIO", (AttributeBooleanValue.to_query f)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.auto_enable_i_o
              (fun f ->
                 ("auto_enable_i_o", (AttributeBooleanValue.to_json f)));
           Some ("volume_id", (String.to_json v.volume_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")));
        auto_enable_i_o =
          (Util.option_map (Json.lookup j "auto_enable_i_o")
             AttributeBooleanValue.of_json)
      }
  end
module AttachVpnGatewayRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpn_gateway_id: String.t ;
      vpc_id: String.t }
    let make ?dry_run  ~vpn_gateway_id  ~vpc_id  () =
      { dry_run; vpn_gateway_id; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpn_gateway_id =
            (Xml.required "VpnGatewayId"
               (Util.option_bind (Xml.member "VpnGatewayId" xml) String.parse));
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some
             (Query.Pair ("VpnGatewayId", (String.to_query v.vpn_gateway_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Some ("vpn_gateway_id", (String.to_json v.vpn_gateway_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpn_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_gateway_id")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module AcceptVpcPeeringConnectionRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_peering_connection_id: String.t option }
    let make ?dry_run  ?vpc_peering_connection_id  () =
      { dry_run; vpc_peering_connection_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_peering_connection_id =
            (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Query.Pair ("VpcPeeringConnectionId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f -> ("vpc_peering_connection_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_peering_connection_id =
          (Util.option_map (Json.lookup j "vpc_peering_connection_id")
             String.of_json)
      }
  end
module ResetSnapshotAttributeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      snapshot_id: String.t ;
      attribute: SnapshotAttributeName.t }
    let make ?dry_run  ~snapshot_id  ~attribute  () =
      { dry_run; snapshot_id; attribute }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          snapshot_id =
            (Xml.required "SnapshotId"
               (Util.option_bind (Xml.member "SnapshotId" xml) String.parse));
          attribute =
            (Xml.required "Attribute"
               (Util.option_bind (Xml.member "Attribute" xml)
                  SnapshotAttributeName.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Attribute", (SnapshotAttributeName.to_query v.attribute)));
           Some (Query.Pair ("SnapshotId", (String.to_query v.snapshot_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("attribute", (SnapshotAttributeName.to_json v.attribute));
           Some ("snapshot_id", (String.to_json v.snapshot_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        snapshot_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "snapshot_id")));
        attribute =
          (SnapshotAttributeName.of_json
             (Util.of_option_exn (Json.lookup j "attribute")))
      }
  end
module DescribeAvailabilityZonesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      zone_names: ZoneNameStringList.t ;
      filters: FilterList.t }
    let make ?dry_run  ?(zone_names= [])  ?(filters= [])  () =
      { dry_run; zone_names; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          zone_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "ZoneName" xml)
                  ZoneNameStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("ZoneName", (ZoneNameStringList.to_query v.zone_names)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some ("zone_names", (ZoneNameStringList.to_json v.zone_names));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        zone_names =
          (ZoneNameStringList.of_json
             (Util.of_option_exn (Json.lookup j "zone_names")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module StopInstancesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_ids: InstanceIdStringList.t ;
      force: Boolean.t option }
    let make ?dry_run  ~instance_ids  ?force  () =
      { dry_run; instance_ids; force }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_ids =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse));
          force = (Util.option_bind (Xml.member "force" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.force
              (fun f -> Query.Pair ("Force", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("InstanceId",
                  (InstanceIdStringList.to_query v.instance_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.force (fun f -> ("force", (Boolean.to_json f)));
           Some
             ("instance_ids", (InstanceIdStringList.to_json v.instance_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        force = (Util.option_map (Json.lookup j "force") Boolean.of_json)
      }
  end
module DescribeImportImageTasksRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      import_task_ids: ImportTaskIdList.t ;
      next_token: String.t option ;
      max_results: Integer.t option ;
      filters: FilterList.t }
    let make ?dry_run  ?(import_task_ids= [])  ?next_token  ?max_results 
      ?(filters= [])  () =
      { dry_run; import_task_ids; next_token; max_results; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          import_task_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "ImportTaskId" xml)
                  ImportTaskIdList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filters", (FilterList.to_query v.filters)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ImportTaskId",
                  (ImportTaskIdList.to_query v.import_task_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("import_task_ids",
               (ImportTaskIdList.to_json v.import_task_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        import_task_ids =
          (ImportTaskIdList.of_json
             (Util.of_option_exn (Json.lookup j "import_task_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module DescribeInstancesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_ids: InstanceIdStringList.t ;
      filters: FilterList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?dry_run  ?(instance_ids= [])  ?(filters= [])  ?next_token 
      ?max_results  () =
      { dry_run; instance_ids; filters; next_token; max_results }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("InstanceId",
                  (InstanceIdStringList.to_query v.instance_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("instance_ids", (InstanceIdStringList.to_json v.instance_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module DescribeVpnGatewaysRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpn_gateway_ids: VpnGatewayIdStringList.t ;
      filters: FilterList.t }
    let make ?dry_run  ?(vpn_gateway_ids= [])  ?(filters= [])  () =
      { dry_run; vpn_gateway_ids; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpn_gateway_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VpnGatewayId" xml)
                  VpnGatewayIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("VpnGatewayId",
                  (VpnGatewayIdStringList.to_query v.vpn_gateway_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some
             ("vpn_gateway_ids",
               (VpnGatewayIdStringList.to_json v.vpn_gateway_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpn_gateway_ids =
          (VpnGatewayIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "vpn_gateway_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module UnmonitorInstancesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_ids: InstanceIdStringList.t }
    let make ?dry_run  ~instance_ids  () = { dry_run; instance_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_ids =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstanceId",
                   (InstanceIdStringList.to_query v.instance_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instance_ids", (InstanceIdStringList.to_json v.instance_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")))
      }
  end
module ImportKeyPairRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      key_name: String.t ;
      public_key_material: Blob.t }
    let make ?dry_run  ~key_name  ~public_key_material  () =
      { dry_run; key_name; public_key_material }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          key_name =
            (Xml.required "keyName"
               (Util.option_bind (Xml.member "keyName" xml) String.parse));
          public_key_material =
            (Xml.required "publicKeyMaterial"
               (Util.option_bind (Xml.member "publicKeyMaterial" xml)
                  Blob.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PublicKeyMaterial", (Blob.to_query v.public_key_material)));
           Some (Query.Pair ("KeyName", (String.to_query v.key_name)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("public_key_material", (Blob.to_json v.public_key_material));
           Some ("key_name", (String.to_json v.key_name));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        key_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "key_name")));
        public_key_material =
          (Blob.of_json
             (Util.of_option_exn (Json.lookup j "public_key_material")))
      }
  end
module DescribeSpotFleetRequestsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      spot_fleet_request_ids: ValueStringList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?dry_run  ?(spot_fleet_request_ids= [])  ?next_token 
      ?max_results  () =
      { dry_run; spot_fleet_request_ids; next_token; max_results }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          spot_fleet_request_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "spotFleetRequestId" xml)
                  ValueStringList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("SpotFleetRequestId",
                  (ValueStringList.to_query v.spot_fleet_request_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("spot_fleet_request_ids",
               (ValueStringList.to_json v.spot_fleet_request_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        spot_fleet_request_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module DescribeSpotDatafeedSubscriptionResult =
  struct
    type t = {
      spot_datafeed_subscription: SpotDatafeedSubscription.t option }
    let make ?spot_datafeed_subscription  () = { spot_datafeed_subscription }
    let parse xml =
      Some
        {
          spot_datafeed_subscription =
            (Util.option_bind (Xml.member "spotDatafeedSubscription" xml)
               SpotDatafeedSubscription.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_datafeed_subscription
              (fun f ->
                 Query.Pair
                   ("SpotDatafeedSubscription",
                     (SpotDatafeedSubscription.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_datafeed_subscription
              (fun f ->
                 ("spot_datafeed_subscription",
                   (SpotDatafeedSubscription.to_json f)))])
    let of_json j =
      {
        spot_datafeed_subscription =
          (Util.option_map (Json.lookup j "spot_datafeed_subscription")
             SpotDatafeedSubscription.of_json)
      }
  end
module RevokeSecurityGroupEgressRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      group_id: String.t ;
      source_security_group_name: String.t option ;
      source_security_group_owner_id: String.t option ;
      ip_protocol: String.t option ;
      from_port: Integer.t option ;
      to_port: Integer.t option ;
      cidr_ip: String.t option ;
      ip_permissions: IpPermissionList.t }
    let make ?dry_run  ~group_id  ?source_security_group_name 
      ?source_security_group_owner_id  ?ip_protocol  ?from_port  ?to_port 
      ?cidr_ip  ?(ip_permissions= [])  () =
      {
        dry_run;
        group_id;
        source_security_group_name;
        source_security_group_owner_id;
        ip_protocol;
        from_port;
        to_port;
        cidr_ip;
        ip_permissions
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          group_id =
            (Xml.required "groupId"
               (Util.option_bind (Xml.member "groupId" xml) String.parse));
          source_security_group_name =
            (Util.option_bind (Xml.member "sourceSecurityGroupName" xml)
               String.parse);
          source_security_group_owner_id =
            (Util.option_bind (Xml.member "sourceSecurityGroupOwnerId" xml)
               String.parse);
          ip_protocol =
            (Util.option_bind (Xml.member "ipProtocol" xml) String.parse);
          from_port =
            (Util.option_bind (Xml.member "fromPort" xml) Integer.parse);
          to_port =
            (Util.option_bind (Xml.member "toPort" xml) Integer.parse);
          cidr_ip = (Util.option_bind (Xml.member "cidrIp" xml) String.parse);
          ip_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipPermissions" xml)
                  IpPermissionList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("IpPermissions",
                   (IpPermissionList.to_query v.ip_permissions)));
           Util.option_map v.cidr_ip
             (fun f -> Query.Pair ("CidrIp", (String.to_query f)));
           Util.option_map v.to_port
             (fun f -> Query.Pair ("ToPort", (Integer.to_query f)));
           Util.option_map v.from_port
             (fun f -> Query.Pair ("FromPort", (Integer.to_query f)));
           Util.option_map v.ip_protocol
             (fun f -> Query.Pair ("IpProtocol", (String.to_query f)));
           Util.option_map v.source_security_group_owner_id
             (fun f ->
                Query.Pair
                  ("SourceSecurityGroupOwnerId", (String.to_query f)));
           Util.option_map v.source_security_group_name
             (fun f ->
                Query.Pair ("SourceSecurityGroupName", (String.to_query f)));
           Some (Query.Pair ("GroupId", (String.to_query v.group_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("ip_permissions", (IpPermissionList.to_json v.ip_permissions));
           Util.option_map v.cidr_ip
             (fun f -> ("cidr_ip", (String.to_json f)));
           Util.option_map v.to_port
             (fun f -> ("to_port", (Integer.to_json f)));
           Util.option_map v.from_port
             (fun f -> ("from_port", (Integer.to_json f)));
           Util.option_map v.ip_protocol
             (fun f -> ("ip_protocol", (String.to_json f)));
           Util.option_map v.source_security_group_owner_id
             (fun f -> ("source_security_group_owner_id", (String.to_json f)));
           Util.option_map v.source_security_group_name
             (fun f -> ("source_security_group_name", (String.to_json f)));
           Some ("group_id", (String.to_json v.group_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "group_id")));
        source_security_group_name =
          (Util.option_map (Json.lookup j "source_security_group_name")
             String.of_json);
        source_security_group_owner_id =
          (Util.option_map (Json.lookup j "source_security_group_owner_id")
             String.of_json);
        ip_protocol =
          (Util.option_map (Json.lookup j "ip_protocol") String.of_json);
        from_port =
          (Util.option_map (Json.lookup j "from_port") Integer.of_json);
        to_port = (Util.option_map (Json.lookup j "to_port") Integer.of_json);
        cidr_ip = (Util.option_map (Json.lookup j "cidr_ip") String.of_json);
        ip_permissions =
          (IpPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "ip_permissions")))
      }
  end
module DescribeInternetGatewaysRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      internet_gateway_ids: ValueStringList.t ;
      filters: FilterList.t }
    let make ?dry_run  ?(internet_gateway_ids= [])  ?(filters= [])  () =
      { dry_run; internet_gateway_ids; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          internet_gateway_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "internetGatewayId" xml)
                  ValueStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("InternetGatewayId",
                  (ValueStringList.to_query v.internet_gateway_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some
             ("internet_gateway_ids",
               (ValueStringList.to_json v.internet_gateway_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        internet_gateway_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "internet_gateway_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module DeleteVpcPeeringConnectionResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module DescribeReservedInstancesModificationsRequest =
  struct
    type t =
      {
      reserved_instances_modification_ids:
        ReservedInstancesModificationIdStringList.t ;
      next_token: String.t option ;
      filters: FilterList.t }
    let make ?(reserved_instances_modification_ids= [])  ?next_token 
      ?(filters= [])  () =
      { reserved_instances_modification_ids; next_token; filters }
    let parse xml =
      Some
        {
          reserved_instances_modification_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "ReservedInstancesModificationId" xml)
                  ReservedInstancesModificationIdStringList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ReservedInstancesModificationId",
                  (ReservedInstancesModificationIdStringList.to_query
                     v.reserved_instances_modification_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("reserved_instances_modification_ids",
               (ReservedInstancesModificationIdStringList.to_json
                  v.reserved_instances_modification_ids))])
    let of_json j =
      {
        reserved_instances_modification_ids =
          (ReservedInstancesModificationIdStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_modification_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module DescribeSpotFleetRequestsResponse =
  struct
    type t =
      {
      spot_fleet_request_configs: SpotFleetRequestConfigSet.t ;
      next_token: String.t option }
    let make ~spot_fleet_request_configs  ?next_token  () =
      { spot_fleet_request_configs; next_token }
    let parse xml =
      Some
        {
          spot_fleet_request_configs =
            (Xml.required "spotFleetRequestConfigSet"
               (Util.option_bind (Xml.member "spotFleetRequestConfigSet" xml)
                  SpotFleetRequestConfigSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("SpotFleetRequestConfigSet",
                  (SpotFleetRequestConfigSet.to_query
                     v.spot_fleet_request_configs)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("spot_fleet_request_configs",
               (SpotFleetRequestConfigSet.to_json
                  v.spot_fleet_request_configs))])
    let of_json j =
      {
        spot_fleet_request_configs =
          (SpotFleetRequestConfigSet.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_configs")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ImportVolumeResult =
  struct
    type t = {
      conversion_task: ConversionTask.t option }
    let make ?conversion_task  () = { conversion_task }
    let parse xml =
      Some
        {
          conversion_task =
            (Util.option_bind (Xml.member "conversionTask" xml)
               ConversionTask.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.conversion_task
              (fun f ->
                 Query.Pair ("ConversionTask", (ConversionTask.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.conversion_task
              (fun f -> ("conversion_task", (ConversionTask.to_json f)))])
    let of_json j =
      {
        conversion_task =
          (Util.option_map (Json.lookup j "conversion_task")
             ConversionTask.of_json)
      }
  end
module DescribeVolumeAttributeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      volume_id: String.t ;
      attribute: VolumeAttributeName.t option }
    let make ?dry_run  ~volume_id  ?attribute  () =
      { dry_run; volume_id; attribute }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          volume_id =
            (Xml.required "VolumeId"
               (Util.option_bind (Xml.member "VolumeId" xml) String.parse));
          attribute =
            (Util.option_bind (Xml.member "Attribute" xml)
               VolumeAttributeName.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.attribute
              (fun f ->
                 Query.Pair ("Attribute", (VolumeAttributeName.to_query f)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.attribute
              (fun f -> ("attribute", (VolumeAttributeName.to_json f)));
           Some ("volume_id", (String.to_json v.volume_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")));
        attribute =
          (Util.option_map (Json.lookup j "attribute")
             VolumeAttributeName.of_json)
      }
  end
module CreateNetworkAclResult =
  struct
    type t = {
      network_acl: NetworkAcl.t option }
    let make ?network_acl  () = { network_acl }
    let parse xml =
      Some
        {
          network_acl =
            (Util.option_bind (Xml.member "networkAcl" xml) NetworkAcl.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.network_acl
              (fun f -> Query.Pair ("NetworkAcl", (NetworkAcl.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.network_acl
              (fun f -> ("network_acl", (NetworkAcl.to_json f)))])
    let of_json j =
      {
        network_acl =
          (Util.option_map (Json.lookup j "network_acl") NetworkAcl.of_json)
      }
  end
module CreateRouteTableResult =
  struct
    type t = {
      route_table: RouteTable.t option }
    let make ?route_table  () = { route_table }
    let parse xml =
      Some
        {
          route_table =
            (Util.option_bind (Xml.member "routeTable" xml) RouteTable.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.route_table
              (fun f -> Query.Pair ("RouteTable", (RouteTable.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.route_table
              (fun f -> ("route_table", (RouteTable.to_json f)))])
    let of_json j =
      {
        route_table =
          (Util.option_map (Json.lookup j "route_table") RouteTable.of_json)
      }
  end
module DescribeSpotInstanceRequestsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      spot_instance_request_ids: SpotInstanceRequestIdList.t ;
      filters: FilterList.t }
    let make ?dry_run  ?(spot_instance_request_ids= [])  ?(filters= [])  () =
      { dry_run; spot_instance_request_ids; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          spot_instance_request_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SpotInstanceRequestId" xml)
                  SpotInstanceRequestIdList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("SpotInstanceRequestId",
                  (SpotInstanceRequestIdList.to_query
                     v.spot_instance_request_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some
             ("spot_instance_request_ids",
               (SpotInstanceRequestIdList.to_json v.spot_instance_request_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        spot_instance_request_ids =
          (SpotInstanceRequestIdList.of_json
             (Util.of_option_exn (Json.lookup j "spot_instance_request_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module DeleteNetworkInterfaceRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      network_interface_id: String.t }
    let make ?dry_run  ~network_interface_id  () =
      { dry_run; network_interface_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_interface_id =
            (Xml.required "networkInterfaceId"
               (Util.option_bind (Xml.member "networkInterfaceId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("NetworkInterfaceId",
                   (String.to_query v.network_interface_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("network_interface_id",
                (String.to_json v.network_interface_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")))
      }
  end
module DescribePlacementGroupsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      group_names: PlacementGroupStringList.t ;
      filters: FilterList.t }
    let make ?dry_run  ?(group_names= [])  ?(filters= [])  () =
      { dry_run; group_names; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          group_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupName" xml)
                  PlacementGroupStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("GroupName",
                  (PlacementGroupStringList.to_query v.group_names)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some
             ("group_names",
               (PlacementGroupStringList.to_json v.group_names));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_names =
          (PlacementGroupStringList.of_json
             (Util.of_option_exn (Json.lookup j "group_names")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module DescribeAvailabilityZonesResult =
  struct
    type t = {
      availability_zones: AvailabilityZoneList.t }
    let make ?(availability_zones= [])  () = { availability_zones }
    let parse xml =
      Some
        {
          availability_zones =
            (Util.of_option []
               (Util.option_bind (Xml.member "availabilityZoneInfo" xml)
                  AvailabilityZoneList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AvailabilityZoneInfo",
                   (AvailabilityZoneList.to_query v.availability_zones)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("availability_zones",
                (AvailabilityZoneList.to_json v.availability_zones))])
    let of_json j =
      {
        availability_zones =
          (AvailabilityZoneList.of_json
             (Util.of_option_exn (Json.lookup j "availability_zones")))
      }
  end
module StartInstancesRequest =
  struct
    type t =
      {
      instance_ids: InstanceIdStringList.t ;
      additional_info: String.t option ;
      dry_run: Boolean.t option }
    let make ~instance_ids  ?additional_info  ?dry_run  () =
      { instance_ids; additional_info; dry_run }
    let parse xml =
      Some
        {
          instance_ids =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse));
          additional_info =
            (Util.option_bind (Xml.member "additionalInfo" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.additional_info
             (fun f -> Query.Pair ("AdditionalInfo", (String.to_query f)));
           Some
             (Query.Pair
                ("InstanceId",
                  (InstanceIdStringList.to_query v.instance_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.additional_info
             (fun f -> ("additional_info", (String.to_json f)));
           Some
             ("instance_ids", (InstanceIdStringList.to_json v.instance_ids))])
    let of_json j =
      {
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        additional_info =
          (Util.option_map (Json.lookup j "additional_info") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ImportImageResult =
  struct
    type t =
      {
      import_task_id: String.t option ;
      architecture: String.t option ;
      license_type: String.t option ;
      platform: String.t option ;
      hypervisor: String.t option ;
      description: String.t option ;
      snapshot_details: SnapshotDetailList.t ;
      image_id: String.t option ;
      progress: String.t option ;
      status_message: String.t option ;
      status: String.t option }
    let make ?import_task_id  ?architecture  ?license_type  ?platform 
      ?hypervisor  ?description  ?(snapshot_details= [])  ?image_id 
      ?progress  ?status_message  ?status  () =
      {
        import_task_id;
        architecture;
        license_type;
        platform;
        hypervisor;
        description;
        snapshot_details;
        image_id;
        progress;
        status_message;
        status
      }
    let parse xml =
      Some
        {
          import_task_id =
            (Util.option_bind (Xml.member "importTaskId" xml) String.parse);
          architecture =
            (Util.option_bind (Xml.member "architecture" xml) String.parse);
          license_type =
            (Util.option_bind (Xml.member "licenseType" xml) String.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml) String.parse);
          hypervisor =
            (Util.option_bind (Xml.member "hypervisor" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          snapshot_details =
            (Util.of_option []
               (Util.option_bind (Xml.member "snapshotDetailSet" xml)
                  SnapshotDetailList.parse));
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (String.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Some
             (Query.Pair
                ("SnapshotDetailSet",
                  (SnapshotDetailList.to_query v.snapshot_details)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.hypervisor
             (fun f -> Query.Pair ("Hypervisor", (String.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (String.to_query f)));
           Util.option_map v.license_type
             (fun f -> Query.Pair ("LicenseType", (String.to_query f)));
           Util.option_map v.architecture
             (fun f -> Query.Pair ("Architecture", (String.to_query f)));
           Util.option_map v.import_task_id
             (fun f -> Query.Pair ("ImportTaskId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (String.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.progress
             (fun f -> ("progress", (String.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Some
             ("snapshot_details",
               (SnapshotDetailList.to_json v.snapshot_details));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.hypervisor
             (fun f -> ("hypervisor", (String.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (String.to_json f)));
           Util.option_map v.license_type
             (fun f -> ("license_type", (String.to_json f)));
           Util.option_map v.architecture
             (fun f -> ("architecture", (String.to_json f)));
           Util.option_map v.import_task_id
             (fun f -> ("import_task_id", (String.to_json f)))])
    let of_json j =
      {
        import_task_id =
          (Util.option_map (Json.lookup j "import_task_id") String.of_json);
        architecture =
          (Util.option_map (Json.lookup j "architecture") String.of_json);
        license_type =
          (Util.option_map (Json.lookup j "license_type") String.of_json);
        platform =
          (Util.option_map (Json.lookup j "platform") String.of_json);
        hypervisor =
          (Util.option_map (Json.lookup j "hypervisor") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        snapshot_details =
          (SnapshotDetailList.of_json
             (Util.of_option_exn (Json.lookup j "snapshot_details")));
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        progress =
          (Util.option_map (Json.lookup j "progress") String.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json)
      }
  end
module DescribeCustomerGatewaysResult =
  struct
    type t = {
      customer_gateways: CustomerGatewayList.t }
    let make ?(customer_gateways= [])  () = { customer_gateways }
    let parse xml =
      Some
        {
          customer_gateways =
            (Util.of_option []
               (Util.option_bind (Xml.member "customerGatewaySet" xml)
                  CustomerGatewayList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("CustomerGatewaySet",
                   (CustomerGatewayList.to_query v.customer_gateways)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("customer_gateways",
                (CustomerGatewayList.to_json v.customer_gateways))])
    let of_json j =
      {
        customer_gateways =
          (CustomerGatewayList.of_json
             (Util.of_option_exn (Json.lookup j "customer_gateways")))
      }
  end
module DescribeVpcEndpointServicesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?max_results  ?next_token  () =
      { dry_run; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeSpotFleetRequestHistoryRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      spot_fleet_request_id: String.t ;
      event_type: EventType.t option ;
      start_time: DateTime.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?dry_run  ~spot_fleet_request_id  ?event_type  ~start_time 
      ?next_token  ?max_results  () =
      {
        dry_run;
        spot_fleet_request_id;
        event_type;
        start_time;
        next_token;
        max_results
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          spot_fleet_request_id =
            (Xml.required "spotFleetRequestId"
               (Util.option_bind (Xml.member "spotFleetRequestId" xml)
                  String.parse));
          event_type =
            (Util.option_bind (Xml.member "eventType" xml) EventType.parse);
          start_time =
            (Xml.required "startTime"
               (Util.option_bind (Xml.member "startTime" xml) DateTime.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("StartTime", (DateTime.to_query v.start_time)));
           Util.option_map v.event_type
             (fun f -> Query.Pair ("EventType", (EventType.to_query f)));
           Some
             (Query.Pair
                ("SpotFleetRequestId",
                  (String.to_query v.spot_fleet_request_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("start_time", (DateTime.to_json v.start_time));
           Util.option_map v.event_type
             (fun f -> ("event_type", (EventType.to_json f)));
           Some
             ("spot_fleet_request_id",
               (String.to_json v.spot_fleet_request_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        spot_fleet_request_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_id")));
        event_type =
          (Util.option_map (Json.lookup j "event_type") EventType.of_json);
        start_time =
          (DateTime.of_json (Util.of_option_exn (Json.lookup j "start_time")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module DeleteVolumeRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      volume_id: String.t }
    let make ?dry_run  ~volume_id  () = { dry_run; volume_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          volume_id =
            (Xml.required "VolumeId"
               (Util.option_bind (Xml.member "VolumeId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("volume_id", (String.to_json v.volume_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")))
      }
  end
module DescribeFlowLogsResult =
  struct
    type t = {
      flow_logs: FlowLogSet.t ;
      next_token: String.t option }
    let make ?(flow_logs= [])  ?next_token  () = { flow_logs; next_token }
    let parse xml =
      Some
        {
          flow_logs =
            (Util.of_option []
               (Util.option_bind (Xml.member "flowLogSet" xml)
                  FlowLogSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair ("FlowLogSet", (FlowLogSet.to_query v.flow_logs)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("flow_logs", (FlowLogSet.to_json v.flow_logs))])
    let of_json j =
      {
        flow_logs =
          (FlowLogSet.of_json
             (Util.of_option_exn (Json.lookup j "flow_logs")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeBundleTasksResult =
  struct
    type t = {
      bundle_tasks: BundleTaskList.t }
    let make ?(bundle_tasks= [])  () = { bundle_tasks }
    let parse xml =
      Some
        {
          bundle_tasks =
            (Util.of_option []
               (Util.option_bind (Xml.member "bundleInstanceTasksSet" xml)
                  BundleTaskList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("BundleInstanceTasksSet",
                   (BundleTaskList.to_query v.bundle_tasks)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("bundle_tasks", (BundleTaskList.to_json v.bundle_tasks))])
    let of_json j =
      {
        bundle_tasks =
          (BundleTaskList.of_json
             (Util.of_option_exn (Json.lookup j "bundle_tasks")))
      }
  end
module DescribeVolumeStatusResult =
  struct
    type t =
      {
      volume_statuses: VolumeStatusList.t ;
      next_token: String.t option }
    let make ?(volume_statuses= [])  ?next_token  () =
      { volume_statuses; next_token }
    let parse xml =
      Some
        {
          volume_statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "volumeStatusSet" xml)
                  VolumeStatusList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("VolumeStatusSet",
                  (VolumeStatusList.to_query v.volume_statuses)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("volume_statuses",
               (VolumeStatusList.to_json v.volume_statuses))])
    let of_json j =
      {
        volume_statuses =
          (VolumeStatusList.of_json
             (Util.of_option_exn (Json.lookup j "volume_statuses")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeSubnetsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      subnet_ids: SubnetIdStringList.t ;
      filters: FilterList.t }
    let make ?dry_run  ?(subnet_ids= [])  ?(filters= [])  () =
      { dry_run; subnet_ids; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          subnet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SubnetId" xml)
                  SubnetIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("SubnetId", (SubnetIdStringList.to_query v.subnet_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some ("subnet_ids", (SubnetIdStringList.to_json v.subnet_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        subnet_ids =
          (SubnetIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "subnet_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module ImportKeyPairResult =
  struct
    type t = {
      key_name: String.t option ;
      key_fingerprint: String.t option }
    let make ?key_name  ?key_fingerprint  () = { key_name; key_fingerprint }
    let parse xml =
      Some
        {
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse);
          key_fingerprint =
            (Util.option_bind (Xml.member "keyFingerprint" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.key_fingerprint
              (fun f -> Query.Pair ("KeyFingerprint", (String.to_query f)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.key_fingerprint
              (fun f -> ("key_fingerprint", (String.to_json f)));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)))])
    let of_json j =
      {
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        key_fingerprint =
          (Util.option_map (Json.lookup j "key_fingerprint") String.of_json)
      }
  end
module CreateKeyPairRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      key_name: String.t }
    let make ?dry_run  ~key_name  () = { dry_run; key_name }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          key_name =
            (Xml.required "KeyName"
               (Util.option_bind (Xml.member "KeyName" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("KeyName", (String.to_query v.key_name)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("key_name", (String.to_json v.key_name));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        key_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "key_name")))
      }
  end
module DisassociateAddressRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      public_ip: String.t option ;
      association_id: String.t option }
    let make ?dry_run  ?public_ip  ?association_id  () =
      { dry_run; public_ip; association_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          public_ip =
            (Util.option_bind (Xml.member "PublicIp" xml) String.parse);
          association_id =
            (Util.option_bind (Xml.member "AssociationId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.association_id
              (fun f -> Query.Pair ("AssociationId", (String.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_id
              (fun f -> ("association_id", (String.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json);
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json)
      }
  end
module DisableVpcClassicLinkResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module ReplaceRouteRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      route_table_id: String.t ;
      destination_cidr_block: String.t ;
      gateway_id: String.t option ;
      instance_id: String.t option ;
      network_interface_id: String.t option ;
      vpc_peering_connection_id: String.t option }
    let make ?dry_run  ~route_table_id  ~destination_cidr_block  ?gateway_id 
      ?instance_id  ?network_interface_id  ?vpc_peering_connection_id  () =
      {
        dry_run;
        route_table_id;
        destination_cidr_block;
        gateway_id;
        instance_id;
        network_interface_id;
        vpc_peering_connection_id
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          route_table_id =
            (Xml.required "routeTableId"
               (Util.option_bind (Xml.member "routeTableId" xml) String.parse));
          destination_cidr_block =
            (Xml.required "destinationCidrBlock"
               (Util.option_bind (Xml.member "destinationCidrBlock" xml)
                  String.parse));
          gateway_id =
            (Util.option_bind (Xml.member "gatewayId" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          vpc_peering_connection_id =
            (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Query.Pair ("VpcPeeringConnectionId", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.gateway_id
             (fun f -> Query.Pair ("GatewayId", (String.to_query f)));
           Some
             (Query.Pair
                ("DestinationCidrBlock",
                  (String.to_query v.destination_cidr_block)));
           Some
             (Query.Pair ("RouteTableId", (String.to_query v.route_table_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f -> ("vpc_peering_connection_id", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.gateway_id
             (fun f -> ("gateway_id", (String.to_json f)));
           Some
             ("destination_cidr_block",
               (String.to_json v.destination_cidr_block));
           Some ("route_table_id", (String.to_json v.route_table_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        route_table_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "route_table_id")));
        destination_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "destination_cidr_block")));
        gateway_id =
          (Util.option_map (Json.lookup j "gateway_id") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        vpc_peering_connection_id =
          (Util.option_map (Json.lookup j "vpc_peering_connection_id")
             String.of_json)
      }
  end
module DeleteFlowLogsResult =
  struct
    type t = {
      unsuccessful: UnsuccessfulItemSet.t }
    let make ?(unsuccessful= [])  () = { unsuccessful }
    let parse xml =
      Some
        {
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemSet.to_query v.unsuccessful)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemSet.to_json v.unsuccessful))])
    let of_json j =
      {
        unsuccessful =
          (UnsuccessfulItemSet.of_json
             (Util.of_option_exn (Json.lookup j "unsuccessful")))
      }
  end
module GetConsoleOutputRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      instance_id: String.t }
    let make ?dry_run  ~instance_id  () = { dry_run; instance_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")))
      }
  end
module AttachVpnGatewayResult =
  struct
    type t = {
      vpc_attachment: VpcAttachment.t option }
    let make ?vpc_attachment  () = { vpc_attachment }
    let parse xml =
      Some
        {
          vpc_attachment =
            (Util.option_bind (Xml.member "attachment" xml)
               VpcAttachment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_attachment
              (fun f -> Query.Pair ("Attachment", (VpcAttachment.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_attachment
              (fun f -> ("vpc_attachment", (VpcAttachment.to_json f)))])
    let of_json j =
      {
        vpc_attachment =
          (Util.option_map (Json.lookup j "vpc_attachment")
             VpcAttachment.of_json)
      }
  end
module ImageAttribute =
  struct
    type t =
      {
      image_id: String.t option ;
      launch_permissions: LaunchPermissionList.t ;
      product_codes: ProductCodeList.t ;
      kernel_id: AttributeValue.t option ;
      ramdisk_id: AttributeValue.t option ;
      description: AttributeValue.t option ;
      sriov_net_support: AttributeValue.t option ;
      block_device_mappings: BlockDeviceMappingList.t }
    let make ?image_id  ?(launch_permissions= [])  ?(product_codes= []) 
      ?kernel_id  ?ramdisk_id  ?description  ?sriov_net_support 
      ?(block_device_mappings= [])  () =
      {
        image_id;
        launch_permissions;
        product_codes;
        kernel_id;
        ramdisk_id;
        description;
        sriov_net_support;
        block_device_mappings
      }
    let parse xml =
      Some
        {
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          launch_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "launchPermission" xml)
                  LaunchPermissionList.parse));
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse));
          kernel_id =
            (Util.option_bind (Xml.member "kernel" xml) AttributeValue.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdisk" xml) AttributeValue.parse);
          description =
            (Util.option_bind (Xml.member "description" xml)
               AttributeValue.parse);
          sriov_net_support =
            (Util.option_bind (Xml.member "sriovNetSupport" xml)
               AttributeValue.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  BlockDeviceMappingList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("BlockDeviceMapping",
                   (BlockDeviceMappingList.to_query v.block_device_mappings)));
           Util.option_map v.sriov_net_support
             (fun f ->
                Query.Pair ("SriovNetSupport", (AttributeValue.to_query f)));
           Util.option_map v.description
             (fun f ->
                Query.Pair ("Description", (AttributeValue.to_query f)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("Ramdisk", (AttributeValue.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("Kernel", (AttributeValue.to_query f)));
           Some
             (Query.Pair
                ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Some
             (Query.Pair
                ("LaunchPermission",
                  (LaunchPermissionList.to_query v.launch_permissions)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("block_device_mappings",
                (BlockDeviceMappingList.to_json v.block_device_mappings));
           Util.option_map v.sriov_net_support
             (fun f -> ("sriov_net_support", (AttributeValue.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (AttributeValue.to_json f)));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (AttributeValue.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (AttributeValue.to_json f)));
           Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Some
             ("launch_permissions",
               (LaunchPermissionList.to_json v.launch_permissions));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)))])
    let of_json j =
      {
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        launch_permissions =
          (LaunchPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "launch_permissions")));
        product_codes =
          (ProductCodeList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")));
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") AttributeValue.of_json);
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id")
             AttributeValue.of_json);
        description =
          (Util.option_map (Json.lookup j "description")
             AttributeValue.of_json);
        sriov_net_support =
          (Util.option_map (Json.lookup j "sriov_net_support")
             AttributeValue.of_json);
        block_device_mappings =
          (BlockDeviceMappingList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")))
      }
  end
module DetachClassicLinkVpcResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module CreateVpnConnectionResult =
  struct
    type t = {
      vpn_connection: VpnConnection.t option }
    let make ?vpn_connection  () = { vpn_connection }
    let parse xml =
      Some
        {
          vpn_connection =
            (Util.option_bind (Xml.member "vpnConnection" xml)
               VpnConnection.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f ->
                 Query.Pair ("VpnConnection", (VpnConnection.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f -> ("vpn_connection", (VpnConnection.to_json f)))])
    let of_json j =
      {
        vpn_connection =
          (Util.option_map (Json.lookup j "vpn_connection")
             VpnConnection.of_json)
      }
  end
module DeleteSnapshotRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      snapshot_id: String.t }
    let make ?dry_run  ~snapshot_id  () = { dry_run; snapshot_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          snapshot_id =
            (Xml.required "SnapshotId"
               (Util.option_bind (Xml.member "SnapshotId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("SnapshotId", (String.to_query v.snapshot_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("snapshot_id", (String.to_json v.snapshot_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        snapshot_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "snapshot_id")))
      }
  end
module KeyPair =
  struct
    type t =
      {
      key_name: String.t ;
      key_fingerprint: String.t ;
      key_material: String.t }
    let make ~key_name  ~key_fingerprint  ~key_material  () =
      { key_name; key_fingerprint; key_material }
    let parse xml =
      Some
        {
          key_name =
            (Xml.required "keyName"
               (Util.option_bind (Xml.member "keyName" xml) String.parse));
          key_fingerprint =
            (Xml.required "keyFingerprint"
               (Util.option_bind (Xml.member "keyFingerprint" xml)
                  String.parse));
          key_material =
            (Xml.required "keyMaterial"
               (Util.option_bind (Xml.member "keyMaterial" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("KeyMaterial", (String.to_query v.key_material)));
           Some
             (Query.Pair
                ("KeyFingerprint", (String.to_query v.key_fingerprint)));
           Some (Query.Pair ("KeyName", (String.to_query v.key_name)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("key_material", (String.to_json v.key_material));
           Some ("key_fingerprint", (String.to_json v.key_fingerprint));
           Some ("key_name", (String.to_json v.key_name))])
    let of_json j =
      {
        key_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "key_name")));
        key_fingerprint =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "key_fingerprint")));
        key_material =
          (String.of_json (Util.of_option_exn (Json.lookup j "key_material")))
      }
  end
module RestoreAddressToClassicRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      public_ip: String.t }
    let make ?dry_run  ~public_ip  () = { dry_run; public_ip }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          public_ip =
            (Xml.required "publicIp"
               (Util.option_bind (Xml.member "publicIp" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("PublicIp", (String.to_query v.public_ip)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("public_ip", (String.to_json v.public_ip));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        public_ip =
          (String.of_json (Util.of_option_exn (Json.lookup j "public_ip")))
      }
  end
module DeleteVpcPeeringConnectionRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_peering_connection_id: String.t }
    let make ?dry_run  ~vpc_peering_connection_id  () =
      { dry_run; vpc_peering_connection_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_peering_connection_id =
            (Xml.required "vpcPeeringConnectionId"
               (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpcPeeringConnectionId",
                   (String.to_query v.vpc_peering_connection_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("vpc_peering_connection_id",
                (String.to_json v.vpc_peering_connection_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_peering_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpc_peering_connection_id")))
      }
  end
module CreateCustomerGatewayResult =
  struct
    type t = {
      customer_gateway: CustomerGateway.t option }
    let make ?customer_gateway  () = { customer_gateway }
    let parse xml =
      Some
        {
          customer_gateway =
            (Util.option_bind (Xml.member "customerGateway" xml)
               CustomerGateway.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.customer_gateway
              (fun f ->
                 Query.Pair ("CustomerGateway", (CustomerGateway.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.customer_gateway
              (fun f -> ("customer_gateway", (CustomerGateway.to_json f)))])
    let of_json j =
      {
        customer_gateway =
          (Util.option_map (Json.lookup j "customer_gateway")
             CustomerGateway.of_json)
      }
  end
module ModifyReservedInstancesResult =
  struct
    type t = {
      reserved_instances_modification_id: String.t option }
    let make ?reserved_instances_modification_id  () =
      { reserved_instances_modification_id }
    let parse xml =
      Some
        {
          reserved_instances_modification_id =
            (Util.option_bind
               (Xml.member "reservedInstancesModificationId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_modification_id
              (fun f ->
                 Query.Pair
                   ("ReservedInstancesModificationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_modification_id
              (fun f ->
                 ("reserved_instances_modification_id", (String.to_json f)))])
    let of_json j =
      {
        reserved_instances_modification_id =
          (Util.option_map
             (Json.lookup j "reserved_instances_modification_id")
             String.of_json)
      }
  end
module DescribeSpotInstanceRequestsResult =
  struct
    type t = {
      spot_instance_requests: SpotInstanceRequestList.t }
    let make ?(spot_instance_requests= [])  () = { spot_instance_requests }
    let parse xml =
      Some
        {
          spot_instance_requests =
            (Util.of_option []
               (Util.option_bind (Xml.member "spotInstanceRequestSet" xml)
                  SpotInstanceRequestList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotInstanceRequestSet",
                   (SpotInstanceRequestList.to_query v.spot_instance_requests)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("spot_instance_requests",
                (SpotInstanceRequestList.to_json v.spot_instance_requests))])
    let of_json j =
      {
        spot_instance_requests =
          (SpotInstanceRequestList.of_json
             (Util.of_option_exn (Json.lookup j "spot_instance_requests")))
      }
  end
module ModifySnapshotAttributeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      snapshot_id: String.t ;
      attribute: SnapshotAttributeName.t option ;
      operation_type: OperationType.t option ;
      user_ids: UserIdStringList.t ;
      group_names: GroupNameStringList.t ;
      create_volume_permission: CreateVolumePermissionModifications.t option }
    let make ?dry_run  ~snapshot_id  ?attribute  ?operation_type  ?(user_ids=
      [])  ?(group_names= [])  ?create_volume_permission  () =
      {
        dry_run;
        snapshot_id;
        attribute;
        operation_type;
        user_ids;
        group_names;
        create_volume_permission
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          snapshot_id =
            (Xml.required "SnapshotId"
               (Util.option_bind (Xml.member "SnapshotId" xml) String.parse));
          attribute =
            (Util.option_bind (Xml.member "Attribute" xml)
               SnapshotAttributeName.parse);
          operation_type =
            (Util.option_bind (Xml.member "OperationType" xml)
               OperationType.parse);
          user_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "UserId" xml)
                  UserIdStringList.parse));
          group_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "UserGroup" xml)
                  GroupNameStringList.parse));
          create_volume_permission =
            (Util.option_bind (Xml.member "CreateVolumePermission" xml)
               CreateVolumePermissionModifications.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.create_volume_permission
              (fun f ->
                 Query.Pair
                   ("CreateVolumePermission",
                     (CreateVolumePermissionModifications.to_query f)));
           Some
             (Query.Pair
                ("UserGroup", (GroupNameStringList.to_query v.group_names)));
           Some
             (Query.Pair ("UserId", (UserIdStringList.to_query v.user_ids)));
           Util.option_map v.operation_type
             (fun f ->
                Query.Pair ("OperationType", (OperationType.to_query f)));
           Util.option_map v.attribute
             (fun f ->
                Query.Pair ("Attribute", (SnapshotAttributeName.to_query f)));
           Some (Query.Pair ("SnapshotId", (String.to_query v.snapshot_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.create_volume_permission
              (fun f ->
                 ("create_volume_permission",
                   (CreateVolumePermissionModifications.to_json f)));
           Some ("group_names", (GroupNameStringList.to_json v.group_names));
           Some ("user_ids", (UserIdStringList.to_json v.user_ids));
           Util.option_map v.operation_type
             (fun f -> ("operation_type", (OperationType.to_json f)));
           Util.option_map v.attribute
             (fun f -> ("attribute", (SnapshotAttributeName.to_json f)));
           Some ("snapshot_id", (String.to_json v.snapshot_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        snapshot_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "snapshot_id")));
        attribute =
          (Util.option_map (Json.lookup j "attribute")
             SnapshotAttributeName.of_json);
        operation_type =
          (Util.option_map (Json.lookup j "operation_type")
             OperationType.of_json);
        user_ids =
          (UserIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "user_ids")));
        group_names =
          (GroupNameStringList.of_json
             (Util.of_option_exn (Json.lookup j "group_names")));
        create_volume_permission =
          (Util.option_map (Json.lookup j "create_volume_permission")
             CreateVolumePermissionModifications.of_json)
      }
  end
module ReleaseAddressRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      public_ip: String.t option ;
      allocation_id: String.t option }
    let make ?dry_run  ?public_ip  ?allocation_id  () =
      { dry_run; public_ip; allocation_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          public_ip =
            (Util.option_bind (Xml.member "PublicIp" xml) String.parse);
          allocation_id =
            (Util.option_bind (Xml.member "AllocationId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.allocation_id
              (fun f -> Query.Pair ("AllocationId", (String.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.allocation_id
              (fun f -> ("allocation_id", (String.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json);
        allocation_id =
          (Util.option_map (Json.lookup j "allocation_id") String.of_json)
      }
  end
module ImportSnapshotResult =
  struct
    type t =
      {
      import_task_id: String.t option ;
      snapshot_task_detail: SnapshotTaskDetail.t option ;
      description: String.t option }
    let make ?import_task_id  ?snapshot_task_detail  ?description  () =
      { import_task_id; snapshot_task_detail; description }
    let parse xml =
      Some
        {
          import_task_id =
            (Util.option_bind (Xml.member "importTaskId" xml) String.parse);
          snapshot_task_detail =
            (Util.option_bind (Xml.member "snapshotTaskDetail" xml)
               SnapshotTaskDetail.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.snapshot_task_detail
             (fun f ->
                Query.Pair
                  ("SnapshotTaskDetail", (SnapshotTaskDetail.to_query f)));
           Util.option_map v.import_task_id
             (fun f -> Query.Pair ("ImportTaskId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (String.to_json f)));
           Util.option_map v.snapshot_task_detail
             (fun f ->
                ("snapshot_task_detail", (SnapshotTaskDetail.to_json f)));
           Util.option_map v.import_task_id
             (fun f -> ("import_task_id", (String.to_json f)))])
    let of_json j =
      {
        import_task_id =
          (Util.option_map (Json.lookup j "import_task_id") String.of_json);
        snapshot_task_detail =
          (Util.option_map (Json.lookup j "snapshot_task_detail")
             SnapshotTaskDetail.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json)
      }
  end
module DescribeVolumesResult =
  struct
    type t = {
      volumes: VolumeList.t ;
      next_token: String.t option }
    let make ?(volumes= [])  ?next_token  () = { volumes; next_token }
    let parse xml =
      Some
        {
          volumes =
            (Util.of_option []
               (Util.option_bind (Xml.member "volumeSet" xml)
                  VolumeList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("VolumeSet", (VolumeList.to_query v.volumes)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("volumes", (VolumeList.to_json v.volumes))])
    let of_json j =
      {
        volumes =
          (VolumeList.of_json (Util.of_option_exn (Json.lookup j "volumes")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module AcceptVpcPeeringConnectionResult =
  struct
    type t = {
      vpc_peering_connection: VpcPeeringConnection.t option }
    let make ?vpc_peering_connection  () = { vpc_peering_connection }
    let parse xml =
      Some
        {
          vpc_peering_connection =
            (Util.option_bind (Xml.member "vpcPeeringConnection" xml)
               VpcPeeringConnection.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection
              (fun f ->
                 Query.Pair
                   ("VpcPeeringConnection",
                     (VpcPeeringConnection.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection
              (fun f ->
                 ("vpc_peering_connection", (VpcPeeringConnection.to_json f)))])
    let of_json j =
      {
        vpc_peering_connection =
          (Util.option_map (Json.lookup j "vpc_peering_connection")
             VpcPeeringConnection.of_json)
      }
  end
module AttachNetworkInterfaceResult =
  struct
    type t = {
      attachment_id: String.t option }
    let make ?attachment_id  () = { attachment_id }
    let parse xml =
      Some
        {
          attachment_id =
            (Util.option_bind (Xml.member "attachmentId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.attachment_id
              (fun f -> Query.Pair ("AttachmentId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.attachment_id
              (fun f -> ("attachment_id", (String.to_json f)))])
    let of_json j =
      {
        attachment_id =
          (Util.option_map (Json.lookup j "attachment_id") String.of_json)
      }
  end
module DescribeReservedInstancesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      reserved_instances_ids: ReservedInstancesIdStringList.t ;
      filters: FilterList.t ;
      offering_type: OfferingTypeValues.t option }
    let make ?dry_run  ?(reserved_instances_ids= [])  ?(filters= []) 
      ?offering_type  () =
      { dry_run; reserved_instances_ids; filters; offering_type }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          reserved_instances_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "ReservedInstancesId" xml)
                  ReservedInstancesIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          offering_type =
            (Util.option_bind (Xml.member "offeringType" xml)
               OfferingTypeValues.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.offering_type
              (fun f ->
                 Query.Pair ("OfferingType", (OfferingTypeValues.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("ReservedInstancesId",
                  (ReservedInstancesIdStringList.to_query
                     v.reserved_instances_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.offering_type
              (fun f -> ("offering_type", (OfferingTypeValues.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("reserved_instances_ids",
               (ReservedInstancesIdStringList.to_json
                  v.reserved_instances_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        reserved_instances_ids =
          (ReservedInstancesIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "reserved_instances_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        offering_type =
          (Util.option_map (Json.lookup j "offering_type")
             OfferingTypeValues.of_json)
      }
  end
module DescribeVpcClassicLinkRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_ids: VpcClassicLinkIdList.t ;
      filters: FilterList.t }
    let make ?dry_run  ?(vpc_ids= [])  ?(filters= [])  () =
      { dry_run; vpc_ids; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VpcId" xml)
                  VpcClassicLinkIdList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair ("VpcId", (VpcClassicLinkIdList.to_query v.vpc_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some ("vpc_ids", (VpcClassicLinkIdList.to_json v.vpc_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_ids =
          (VpcClassicLinkIdList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module DescribeRegionsResult =
  struct
    type t = {
      regions: RegionList.t }
    let make ?(regions= [])  () = { regions }
    let parse xml =
      Some
        {
          regions =
            (Util.of_option []
               (Util.option_bind (Xml.member "regionInfo" xml)
                  RegionList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("RegionInfo", (RegionList.to_query v.regions)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("regions", (RegionList.to_json v.regions))])
    let of_json j =
      {
        regions =
          (RegionList.of_json (Util.of_option_exn (Json.lookup j "regions")))
      }
  end
module CreateVpnConnectionRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      type_: String.t ;
      customer_gateway_id: String.t ;
      vpn_gateway_id: String.t ;
      options: VpnConnectionOptionsSpecification.t option }
    let make ?dry_run  ~type_  ~customer_gateway_id  ~vpn_gateway_id 
      ?options  () =
      { dry_run; type_; customer_gateway_id; vpn_gateway_id; options }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          type_ =
            (Xml.required "Type"
               (Util.option_bind (Xml.member "Type" xml) String.parse));
          customer_gateway_id =
            (Xml.required "CustomerGatewayId"
               (Util.option_bind (Xml.member "CustomerGatewayId" xml)
                  String.parse));
          vpn_gateway_id =
            (Xml.required "VpnGatewayId"
               (Util.option_bind (Xml.member "VpnGatewayId" xml) String.parse));
          options =
            (Util.option_bind (Xml.member "options" xml)
               VpnConnectionOptionsSpecification.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.options
              (fun f ->
                 Query.Pair
                   ("Options",
                     (VpnConnectionOptionsSpecification.to_query f)));
           Some
             (Query.Pair ("VpnGatewayId", (String.to_query v.vpn_gateway_id)));
           Some
             (Query.Pair
                ("CustomerGatewayId",
                  (String.to_query v.customer_gateway_id)));
           Some (Query.Pair ("Type", (String.to_query v.type_)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.options
              (fun f ->
                 ("options", (VpnConnectionOptionsSpecification.to_json f)));
           Some ("vpn_gateway_id", (String.to_json v.vpn_gateway_id));
           Some
             ("customer_gateway_id", (String.to_json v.customer_gateway_id));
           Some ("type_", (String.to_json v.type_));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        type_ = (String.of_json (Util.of_option_exn (Json.lookup j "type_")));
        customer_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "customer_gateway_id")));
        vpn_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_gateway_id")));
        options =
          (Util.option_map (Json.lookup j "options")
             VpnConnectionOptionsSpecification.of_json)
      }
  end
module CreateVpnGatewayRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      type_: GatewayType.t ;
      availability_zone: String.t option }
    let make ?dry_run  ~type_  ?availability_zone  () =
      { dry_run; type_; availability_zone }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          type_ =
            (Xml.required "Type"
               (Util.option_bind (Xml.member "Type" xml) GatewayType.parse));
          availability_zone =
            (Util.option_bind (Xml.member "AvailabilityZone" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.availability_zone
              (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Some (Query.Pair ("Type", (GatewayType.to_query v.type_)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.availability_zone
              (fun f -> ("availability_zone", (String.to_json f)));
           Some ("type_", (GatewayType.to_json v.type_));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        type_ =
          (GatewayType.of_json (Util.of_option_exn (Json.lookup j "type_")));
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json)
      }
  end
module RegisterImageResult =
  struct
    type t = {
      image_id: String.t option }
    let make ?image_id  () = { image_id }
    let parse xml =
      Some
        {
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.image_id
              (fun f -> Query.Pair ("ImageId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.image_id
              (fun f -> ("image_id", (String.to_json f)))])
    let of_json j =
      {
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json)
      }
  end
module AttachVolumeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      volume_id: String.t ;
      instance_id: String.t ;
      device: String.t }
    let make ?dry_run  ~volume_id  ~instance_id  ~device  () =
      { dry_run; volume_id; instance_id; device }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          volume_id =
            (Xml.required "VolumeId"
               (Util.option_bind (Xml.member "VolumeId" xml) String.parse));
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          device =
            (Xml.required "Device"
               (Util.option_bind (Xml.member "Device" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Device", (String.to_query v.device)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("device", (String.to_json v.device));
           Some ("instance_id", (String.to_json v.instance_id));
           Some ("volume_id", (String.to_json v.volume_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")));
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        device =
          (String.of_json (Util.of_option_exn (Json.lookup j "device")))
      }
  end
module CancelReservedInstancesListingResult =
  struct
    type t = {
      reserved_instances_listings: ReservedInstancesListingList.t }
    let make ?(reserved_instances_listings= [])  () =
      { reserved_instances_listings }
    let parse xml =
      Some
        {
          reserved_instances_listings =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "reservedInstancesListingsSet" xml)
                  ReservedInstancesListingList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesListingsSet",
                   (ReservedInstancesListingList.to_query
                      v.reserved_instances_listings)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances_listings",
                (ReservedInstancesListingList.to_json
                   v.reserved_instances_listings))])
    let of_json j =
      {
        reserved_instances_listings =
          (ReservedInstancesListingList.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_listings")))
      }
  end
module CreateTagsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      resources: ResourceIdList.t ;
      tags: TagList.t }
    let make ?dry_run  ~resources  ~tags  () = { dry_run; resources; tags }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          resources =
            (Xml.required "ResourceId"
               (Util.option_bind (Xml.member "ResourceId" xml)
                  ResourceIdList.parse));
          tags =
            (Xml.required "Tag"
               (Util.option_bind (Xml.member "Tag" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Tag", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("ResourceId", (ResourceIdList.to_query v.resources)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Some ("resources", (ResourceIdList.to_json v.resources));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        resources =
          (ResourceIdList.of_json
             (Util.of_option_exn (Json.lookup j "resources")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module CreateDhcpOptionsResult =
  struct
    type t = {
      dhcp_options: DhcpOptions.t option }
    let make ?dhcp_options  () = { dhcp_options }
    let parse xml =
      Some
        {
          dhcp_options =
            (Util.option_bind (Xml.member "dhcpOptions" xml)
               DhcpOptions.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dhcp_options
              (fun f -> Query.Pair ("DhcpOptions", (DhcpOptions.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dhcp_options
              (fun f -> ("dhcp_options", (DhcpOptions.to_json f)))])
    let of_json j =
      {
        dhcp_options =
          (Util.option_map (Json.lookup j "dhcp_options") DhcpOptions.of_json)
      }
  end
module CreatePlacementGroupRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      group_name: String.t ;
      strategy: PlacementStrategy.t }
    let make ?dry_run  ~group_name  ~strategy  () =
      { dry_run; group_name; strategy }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          group_name =
            (Xml.required "groupName"
               (Util.option_bind (Xml.member "groupName" xml) String.parse));
          strategy =
            (Xml.required "strategy"
               (Util.option_bind (Xml.member "strategy" xml)
                  PlacementStrategy.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Strategy", (PlacementStrategy.to_query v.strategy)));
           Some (Query.Pair ("GroupName", (String.to_query v.group_name)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("strategy", (PlacementStrategy.to_json v.strategy));
           Some ("group_name", (String.to_json v.group_name));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "group_name")));
        strategy =
          (PlacementStrategy.of_json
             (Util.of_option_exn (Json.lookup j "strategy")))
      }
  end
module ConfirmProductInstanceResult =
  struct
    type t = {
      owner_id: String.t option ;
      return: Boolean.t option }
    let make ?owner_id  ?return  () = { owner_id; return }
    let parse xml =
      Some
        {
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)))])
    let of_json j =
      {
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        return = (Util.option_map (Json.lookup j "return") Boolean.of_json)
      }
  end
module AssociateAddressRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_id: String.t option ;
      public_ip: String.t option ;
      allocation_id: String.t option ;
      network_interface_id: String.t option ;
      private_ip_address: String.t option ;
      allow_reassociation: Boolean.t option }
    let make ?dry_run  ?instance_id  ?public_ip  ?allocation_id 
      ?network_interface_id  ?private_ip_address  ?allow_reassociation  () =
      {
        dry_run;
        instance_id;
        public_ip;
        allocation_id;
        network_interface_id;
        private_ip_address;
        allow_reassociation
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          public_ip =
            (Util.option_bind (Xml.member "PublicIp" xml) String.parse);
          allocation_id =
            (Util.option_bind (Xml.member "AllocationId" xml) String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          allow_reassociation =
            (Util.option_bind (Xml.member "allowReassociation" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.allow_reassociation
              (fun f ->
                 Query.Pair ("AllowReassociation", (Boolean.to_query f)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.allow_reassociation
              (fun f -> ("allow_reassociation", (Boolean.to_json f)));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json);
        allocation_id =
          (Util.option_map (Json.lookup j "allocation_id") String.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        allow_reassociation =
          (Util.option_map (Json.lookup j "allow_reassociation")
             Boolean.of_json)
      }
  end
module CreateRouteRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      route_table_id: String.t ;
      destination_cidr_block: String.t ;
      gateway_id: String.t option ;
      instance_id: String.t option ;
      network_interface_id: String.t option ;
      vpc_peering_connection_id: String.t option }
    let make ?dry_run  ~route_table_id  ~destination_cidr_block  ?gateway_id 
      ?instance_id  ?network_interface_id  ?vpc_peering_connection_id  () =
      {
        dry_run;
        route_table_id;
        destination_cidr_block;
        gateway_id;
        instance_id;
        network_interface_id;
        vpc_peering_connection_id
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          route_table_id =
            (Xml.required "routeTableId"
               (Util.option_bind (Xml.member "routeTableId" xml) String.parse));
          destination_cidr_block =
            (Xml.required "destinationCidrBlock"
               (Util.option_bind (Xml.member "destinationCidrBlock" xml)
                  String.parse));
          gateway_id =
            (Util.option_bind (Xml.member "gatewayId" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          vpc_peering_connection_id =
            (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Query.Pair ("VpcPeeringConnectionId", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.gateway_id
             (fun f -> Query.Pair ("GatewayId", (String.to_query f)));
           Some
             (Query.Pair
                ("DestinationCidrBlock",
                  (String.to_query v.destination_cidr_block)));
           Some
             (Query.Pair ("RouteTableId", (String.to_query v.route_table_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f -> ("vpc_peering_connection_id", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.gateway_id
             (fun f -> ("gateway_id", (String.to_json f)));
           Some
             ("destination_cidr_block",
               (String.to_json v.destination_cidr_block));
           Some ("route_table_id", (String.to_json v.route_table_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        route_table_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "route_table_id")));
        destination_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "destination_cidr_block")));
        gateway_id =
          (Util.option_map (Json.lookup j "gateway_id") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        vpc_peering_connection_id =
          (Util.option_map (Json.lookup j "vpc_peering_connection_id")
             String.of_json)
      }
  end
module RejectVpcPeeringConnectionRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_peering_connection_id: String.t }
    let make ?dry_run  ~vpc_peering_connection_id  () =
      { dry_run; vpc_peering_connection_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_peering_connection_id =
            (Xml.required "vpcPeeringConnectionId"
               (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpcPeeringConnectionId",
                   (String.to_query v.vpc_peering_connection_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("vpc_peering_connection_id",
                (String.to_json v.vpc_peering_connection_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_peering_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpc_peering_connection_id")))
      }
  end
module AllocateAddressRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      domain: DomainType.t option }
    let make ?dry_run  ?domain  () = { dry_run; domain }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          domain =
            (Util.option_bind (Xml.member "Domain" xml) DomainType.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.domain
              (fun f -> Query.Pair ("Domain", (DomainType.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.domain
              (fun f -> ("domain", (DomainType.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        domain =
          (Util.option_map (Json.lookup j "domain") DomainType.of_json)
      }
  end
module DescribeAddressesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      public_ips: PublicIpStringList.t ;
      filters: FilterList.t ;
      allocation_ids: AllocationIdList.t }
    let make ?dry_run  ?(public_ips= [])  ?(filters= [])  ?(allocation_ids=
      [])  () = { dry_run; public_ips; filters; allocation_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          public_ips =
            (Util.of_option []
               (Util.option_bind (Xml.member "PublicIp" xml)
                  PublicIpStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          allocation_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "AllocationId" xml)
                  AllocationIdList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AllocationId",
                   (AllocationIdList.to_query v.allocation_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("PublicIp", (PublicIpStringList.to_query v.public_ips)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("allocation_ids", (AllocationIdList.to_json v.allocation_ids));
           Some ("filters", (FilterList.to_json v.filters));
           Some ("public_ips", (PublicIpStringList.to_json v.public_ips));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        public_ips =
          (PublicIpStringList.of_json
             (Util.of_option_exn (Json.lookup j "public_ips")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        allocation_ids =
          (AllocationIdList.of_json
             (Util.of_option_exn (Json.lookup j "allocation_ids")))
      }
  end
module BundleInstanceResult =
  struct
    type t = {
      bundle_task: BundleTask.t option }
    let make ?bundle_task  () = { bundle_task }
    let parse xml =
      Some
        {
          bundle_task =
            (Util.option_bind (Xml.member "bundleInstanceTask" xml)
               BundleTask.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.bundle_task
              (fun f ->
                 Query.Pair ("BundleInstanceTask", (BundleTask.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.bundle_task
              (fun f -> ("bundle_task", (BundleTask.to_json f)))])
    let of_json j =
      {
        bundle_task =
          (Util.option_map (Json.lookup j "bundle_task") BundleTask.of_json)
      }
  end
module CreateRouteTableRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      vpc_id: String.t }
    let make ?dry_run  ~vpc_id  () = { dry_run; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module DetachVolumeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      volume_id: String.t ;
      instance_id: String.t option ;
      device: String.t option ;
      force: Boolean.t option }
    let make ?dry_run  ~volume_id  ?instance_id  ?device  ?force  () =
      { dry_run; volume_id; instance_id; device; force }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          volume_id =
            (Xml.required "VolumeId"
               (Util.option_bind (Xml.member "VolumeId" xml) String.parse));
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          device = (Util.option_bind (Xml.member "Device" xml) String.parse);
          force = (Util.option_bind (Xml.member "Force" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.force
              (fun f -> Query.Pair ("Force", (Boolean.to_query f)));
           Util.option_map v.device
             (fun f -> Query.Pair ("Device", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.force (fun f -> ("force", (Boolean.to_json f)));
           Util.option_map v.device (fun f -> ("device", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Some ("volume_id", (String.to_json v.volume_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")));
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        device = (Util.option_map (Json.lookup j "device") String.of_json);
        force = (Util.option_map (Json.lookup j "force") Boolean.of_json)
      }
  end
module InstanceAttribute =
  struct
    type t =
      {
      instance_id: String.t option ;
      instance_type: AttributeValue.t option ;
      kernel_id: AttributeValue.t option ;
      ramdisk_id: AttributeValue.t option ;
      user_data: AttributeValue.t option ;
      disable_api_termination: AttributeBooleanValue.t option ;
      instance_initiated_shutdown_behavior: AttributeValue.t option ;
      root_device_name: AttributeValue.t option ;
      block_device_mappings: InstanceBlockDeviceMappingList.t ;
      product_codes: ProductCodeList.t ;
      ebs_optimized: AttributeBooleanValue.t option ;
      sriov_net_support: AttributeValue.t option ;
      source_dest_check: AttributeBooleanValue.t option ;
      groups: GroupIdentifierList.t }
    let make ?instance_id  ?instance_type  ?kernel_id  ?ramdisk_id 
      ?user_data  ?disable_api_termination 
      ?instance_initiated_shutdown_behavior  ?root_device_name 
      ?(block_device_mappings= [])  ?(product_codes= [])  ?ebs_optimized 
      ?sriov_net_support  ?source_dest_check  ?(groups= [])  () =
      {
        instance_id;
        instance_type;
        kernel_id;
        ramdisk_id;
        user_data;
        disable_api_termination;
        instance_initiated_shutdown_behavior;
        root_device_name;
        block_device_mappings;
        product_codes;
        ebs_optimized;
        sriov_net_support;
        source_dest_check;
        groups
      }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               AttributeValue.parse);
          kernel_id =
            (Util.option_bind (Xml.member "kernel" xml) AttributeValue.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdisk" xml) AttributeValue.parse);
          user_data =
            (Util.option_bind (Xml.member "userData" xml)
               AttributeValue.parse);
          disable_api_termination =
            (Util.option_bind (Xml.member "disableApiTermination" xml)
               AttributeBooleanValue.parse);
          instance_initiated_shutdown_behavior =
            (Util.option_bind
               (Xml.member "instanceInitiatedShutdownBehavior" xml)
               AttributeValue.parse);
          root_device_name =
            (Util.option_bind (Xml.member "rootDeviceName" xml)
               AttributeValue.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  InstanceBlockDeviceMappingList.parse));
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse));
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml)
               AttributeBooleanValue.parse);
          sriov_net_support =
            (Util.option_bind (Xml.member "sriovNetSupport" xml)
               AttributeValue.parse);
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml)
               AttributeBooleanValue.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("GroupSet", (GroupIdentifierList.to_query v.groups)));
           Util.option_map v.source_dest_check
             (fun f ->
                Query.Pair
                  ("SourceDestCheck", (AttributeBooleanValue.to_query f)));
           Util.option_map v.sriov_net_support
             (fun f ->
                Query.Pair ("SriovNetSupport", (AttributeValue.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f ->
                Query.Pair
                  ("EbsOptimized", (AttributeBooleanValue.to_query f)));
           Some
             (Query.Pair
                ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (InstanceBlockDeviceMappingList.to_query
                     v.block_device_mappings)));
           Util.option_map v.root_device_name
             (fun f ->
                Query.Pair ("RootDeviceName", (AttributeValue.to_query f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInitiatedShutdownBehavior",
                    (AttributeValue.to_query f)));
           Util.option_map v.disable_api_termination
             (fun f ->
                Query.Pair
                  ("DisableApiTermination",
                    (AttributeBooleanValue.to_query f)));
           Util.option_map v.user_data
             (fun f -> Query.Pair ("UserData", (AttributeValue.to_query f)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("Ramdisk", (AttributeValue.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("Kernel", (AttributeValue.to_query f)));
           Util.option_map v.instance_type
             (fun f ->
                Query.Pair ("InstanceType", (AttributeValue.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("groups", (GroupIdentifierList.to_json v.groups));
           Util.option_map v.source_dest_check
             (fun f ->
                ("source_dest_check", (AttributeBooleanValue.to_json f)));
           Util.option_map v.sriov_net_support
             (fun f -> ("sriov_net_support", (AttributeValue.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (AttributeBooleanValue.to_json f)));
           Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Some
             ("block_device_mappings",
               (InstanceBlockDeviceMappingList.to_json
                  v.block_device_mappings));
           Util.option_map v.root_device_name
             (fun f -> ("root_device_name", (AttributeValue.to_json f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                ("instance_initiated_shutdown_behavior",
                  (AttributeValue.to_json f)));
           Util.option_map v.disable_api_termination
             (fun f ->
                ("disable_api_termination",
                  (AttributeBooleanValue.to_json f)));
           Util.option_map v.user_data
             (fun f -> ("user_data", (AttributeValue.to_json f)));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (AttributeValue.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (AttributeValue.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (AttributeValue.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             AttributeValue.of_json);
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") AttributeValue.of_json);
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id")
             AttributeValue.of_json);
        user_data =
          (Util.option_map (Json.lookup j "user_data") AttributeValue.of_json);
        disable_api_termination =
          (Util.option_map (Json.lookup j "disable_api_termination")
             AttributeBooleanValue.of_json);
        instance_initiated_shutdown_behavior =
          (Util.option_map
             (Json.lookup j "instance_initiated_shutdown_behavior")
             AttributeValue.of_json);
        root_device_name =
          (Util.option_map (Json.lookup j "root_device_name")
             AttributeValue.of_json);
        block_device_mappings =
          (InstanceBlockDeviceMappingList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        product_codes =
          (ProductCodeList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")));
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized")
             AttributeBooleanValue.of_json);
        sriov_net_support =
          (Util.option_map (Json.lookup j "sriov_net_support")
             AttributeValue.of_json);
        source_dest_check =
          (Util.option_map (Json.lookup j "source_dest_check")
             AttributeBooleanValue.of_json);
        groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "groups")))
      }
  end
module DescribeAddressesResult =
  struct
    type t = {
      addresses: AddressList.t }
    let make ?(addresses= [])  () = { addresses }
    let parse xml =
      Some
        {
          addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "addressesSet" xml)
                  AddressList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AddressesSet", (AddressList.to_query v.addresses)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("addresses", (AddressList.to_json v.addresses))])
    let of_json j =
      {
        addresses =
          (AddressList.of_json
             (Util.of_option_exn (Json.lookup j "addresses")))
      }
  end
module DescribeRouteTablesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      route_table_ids: ValueStringList.t ;
      filters: FilterList.t }
    let make ?dry_run  ?(route_table_ids= [])  ?(filters= [])  () =
      { dry_run; route_table_ids; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          route_table_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "RouteTableId" xml)
                  ValueStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("RouteTableId",
                  (ValueStringList.to_query v.route_table_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some
             ("route_table_ids", (ValueStringList.to_json v.route_table_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        route_table_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "route_table_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module ImportSnapshotRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      description: String.t option ;
      disk_container: SnapshotDiskContainer.t option ;
      client_data: ClientData.t option ;
      client_token: String.t option ;
      role_name: String.t option }
    let make ?dry_run  ?description  ?disk_container  ?client_data 
      ?client_token  ?role_name  () =
      {
        dry_run;
        description;
        disk_container;
        client_data;
        client_token;
        role_name
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          disk_container =
            (Util.option_bind (Xml.member "DiskContainer" xml)
               SnapshotDiskContainer.parse);
          client_data =
            (Util.option_bind (Xml.member "ClientData" xml) ClientData.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          role_name =
            (Util.option_bind (Xml.member "RoleName" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.role_name
              (fun f -> Query.Pair ("RoleName", (String.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.client_data
             (fun f -> Query.Pair ("ClientData", (ClientData.to_query f)));
           Util.option_map v.disk_container
             (fun f ->
                Query.Pair
                  ("DiskContainer", (SnapshotDiskContainer.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.role_name
              (fun f -> ("role_name", (String.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.client_data
             (fun f -> ("client_data", (ClientData.to_json f)));
           Util.option_map v.disk_container
             (fun f -> ("disk_container", (SnapshotDiskContainer.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        disk_container =
          (Util.option_map (Json.lookup j "disk_container")
             SnapshotDiskContainer.of_json);
        client_data =
          (Util.option_map (Json.lookup j "client_data") ClientData.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        role_name =
          (Util.option_map (Json.lookup j "role_name") String.of_json)
      }
  end
module CreateSubnetResult =
  struct
    type t = {
      subnet: Subnet.t option }
    let make ?subnet  () = { subnet }
    let parse xml =
      Some
        { subnet = (Util.option_bind (Xml.member "subnet" xml) Subnet.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet
              (fun f -> Query.Pair ("Subnet", (Subnet.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet
              (fun f -> ("subnet", (Subnet.to_json f)))])
    let of_json j =
      { subnet = (Util.option_map (Json.lookup j "subnet") Subnet.of_json) }
  end
module StopInstancesResult =
  struct
    type t = {
      stopping_instances: InstanceStateChangeList.t }
    let make ?(stopping_instances= [])  () = { stopping_instances }
    let parse xml =
      Some
        {
          stopping_instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  InstanceStateChangeList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstancesSet",
                   (InstanceStateChangeList.to_query v.stopping_instances)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("stopping_instances",
                (InstanceStateChangeList.to_json v.stopping_instances))])
    let of_json j =
      {
        stopping_instances =
          (InstanceStateChangeList.of_json
             (Util.of_option_exn (Json.lookup j "stopping_instances")))
      }
  end
module RequestSpotFleetResponse =
  struct
    type t = {
      spot_fleet_request_id: String.t }
    let make ~spot_fleet_request_id  () = { spot_fleet_request_id }
    let parse xml =
      Some
        {
          spot_fleet_request_id =
            (Xml.required "spotFleetRequestId"
               (Util.option_bind (Xml.member "spotFleetRequestId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotFleetRequestId",
                   (String.to_query v.spot_fleet_request_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("spot_fleet_request_id",
                (String.to_json v.spot_fleet_request_id))])
    let of_json j =
      {
        spot_fleet_request_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_id")))
      }
  end
module DescribeVpnConnectionsResult =
  struct
    type t = {
      vpn_connections: VpnConnectionList.t }
    let make ?(vpn_connections= [])  () = { vpn_connections }
    let parse xml =
      Some
        {
          vpn_connections =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpnConnectionSet" xml)
                  VpnConnectionList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpnConnectionSet",
                   (VpnConnectionList.to_query v.vpn_connections)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("vpn_connections",
                (VpnConnectionList.to_json v.vpn_connections))])
    let of_json j =
      {
        vpn_connections =
          (VpnConnectionList.of_json
             (Util.of_option_exn (Json.lookup j "vpn_connections")))
      }
  end
module DescribeReservedInstancesOfferingsResult =
  struct
    type t =
      {
      reserved_instances_offerings: ReservedInstancesOfferingList.t ;
      next_token: String.t option }
    let make ?(reserved_instances_offerings= [])  ?next_token  () =
      { reserved_instances_offerings; next_token }
    let parse xml =
      Some
        {
          reserved_instances_offerings =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "reservedInstancesOfferingsSet" xml)
                  ReservedInstancesOfferingList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ReservedInstancesOfferingsSet",
                  (ReservedInstancesOfferingList.to_query
                     v.reserved_instances_offerings)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("reserved_instances_offerings",
               (ReservedInstancesOfferingList.to_json
                  v.reserved_instances_offerings))])
    let of_json j =
      {
        reserved_instances_offerings =
          (ReservedInstancesOfferingList.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_offerings")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module AssociateDhcpOptionsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      dhcp_options_id: String.t ;
      vpc_id: String.t }
    let make ?dry_run  ~dhcp_options_id  ~vpc_id  () =
      { dry_run; dhcp_options_id; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          dhcp_options_id =
            (Xml.required "DhcpOptionsId"
               (Util.option_bind (Xml.member "DhcpOptionsId" xml)
                  String.parse));
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some
             (Query.Pair
                ("DhcpOptionsId", (String.to_query v.dhcp_options_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Some ("dhcp_options_id", (String.to_json v.dhcp_options_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        dhcp_options_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "dhcp_options_id")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module DeleteKeyPairRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      key_name: String.t }
    let make ?dry_run  ~key_name  () = { dry_run; key_name }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          key_name =
            (Xml.required "KeyName"
               (Util.option_bind (Xml.member "KeyName" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("KeyName", (String.to_query v.key_name)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("key_name", (String.to_json v.key_name));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        key_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "key_name")))
      }
  end
module DescribeInstancesResult =
  struct
    type t = {
      reservations: ReservationList.t ;
      next_token: String.t option }
    let make ?(reservations= [])  ?next_token  () =
      { reservations; next_token }
    let parse xml =
      Some
        {
          reservations =
            (Util.of_option []
               (Util.option_bind (Xml.member "reservationSet" xml)
                  ReservationList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ReservationSet", (ReservationList.to_query v.reservations)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("reservations", (ReservationList.to_json v.reservations))])
    let of_json j =
      {
        reservations =
          (ReservationList.of_json
             (Util.of_option_exn (Json.lookup j "reservations")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module GetPasswordDataResult =
  struct
    type t =
      {
      instance_id: String.t ;
      timestamp: DateTime.t ;
      password_data: String.t }
    let make ~instance_id  ~timestamp  ~password_data  () =
      { instance_id; timestamp; password_data }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          timestamp =
            (Xml.required "timestamp"
               (Util.option_bind (Xml.member "timestamp" xml) DateTime.parse));
          password_data =
            (Xml.required "passwordData"
               (Util.option_bind (Xml.member "passwordData" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("PasswordData", (String.to_query v.password_data)));
           Some (Query.Pair ("Timestamp", (DateTime.to_query v.timestamp)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("password_data", (String.to_json v.password_data));
           Some ("timestamp", (DateTime.to_json v.timestamp));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        timestamp =
          (DateTime.of_json (Util.of_option_exn (Json.lookup j "timestamp")));
        password_data =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "password_data")))
      }
  end
module CreateVpcResult =
  struct
    type t = {
      vpc: Vpc.t option }
    let make ?vpc  () = { vpc }
    let parse xml =
      Some { vpc = (Util.option_bind (Xml.member "vpc" xml) Vpc.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc
              (fun f -> Query.Pair ("Vpc", (Vpc.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc (fun f -> ("vpc", (Vpc.to_json f)))])
    let of_json j =
      { vpc = (Util.option_map (Json.lookup j "vpc") Vpc.of_json) }
  end
module DescribeVolumesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      volume_ids: VolumeIdStringList.t ;
      filters: FilterList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?dry_run  ?(volume_ids= [])  ?(filters= [])  ?next_token 
      ?max_results  () =
      { dry_run; volume_ids; filters; next_token; max_results }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          volume_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VolumeId" xml)
                  VolumeIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("VolumeId", (VolumeIdStringList.to_query v.volume_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some ("volume_ids", (VolumeIdStringList.to_json v.volume_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        volume_ids =
          (VolumeIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "volume_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module MonitorInstancesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_ids: InstanceIdStringList.t }
    let make ?dry_run  ~instance_ids  () = { dry_run; instance_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_ids =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstanceId",
                   (InstanceIdStringList.to_query v.instance_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instance_ids", (InstanceIdStringList.to_json v.instance_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")))
      }
  end
module DescribeRegionsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      region_names: RegionNameStringList.t ;
      filters: FilterList.t }
    let make ?dry_run  ?(region_names= [])  ?(filters= [])  () =
      { dry_run; region_names; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          region_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "RegionName" xml)
                  RegionNameStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("RegionName",
                  (RegionNameStringList.to_query v.region_names)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some
             ("region_names", (RegionNameStringList.to_json v.region_names));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        region_names =
          (RegionNameStringList.of_json
             (Util.of_option_exn (Json.lookup j "region_names")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module ModifySubnetAttributeRequest =
  struct
    type t =
      {
      subnet_id: String.t ;
      map_public_ip_on_launch: AttributeBooleanValue.t option }
    let make ~subnet_id  ?map_public_ip_on_launch  () =
      { subnet_id; map_public_ip_on_launch }
    let parse xml =
      Some
        {
          subnet_id =
            (Xml.required "subnetId"
               (Util.option_bind (Xml.member "subnetId" xml) String.parse));
          map_public_ip_on_launch =
            (Util.option_bind (Xml.member "MapPublicIpOnLaunch" xml)
               AttributeBooleanValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.map_public_ip_on_launch
              (fun f ->
                 Query.Pair
                   ("MapPublicIpOnLaunch",
                     (AttributeBooleanValue.to_query f)));
           Some (Query.Pair ("SubnetId", (String.to_query v.subnet_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.map_public_ip_on_launch
              (fun f ->
                 ("map_public_ip_on_launch",
                   (AttributeBooleanValue.to_json f)));
           Some ("subnet_id", (String.to_json v.subnet_id))])
    let of_json j =
      {
        subnet_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "subnet_id")));
        map_public_ip_on_launch =
          (Util.option_map (Json.lookup j "map_public_ip_on_launch")
             AttributeBooleanValue.of_json)
      }
  end
module ImportInstanceResult =
  struct
    type t = {
      conversion_task: ConversionTask.t option }
    let make ?conversion_task  () = { conversion_task }
    let parse xml =
      Some
        {
          conversion_task =
            (Util.option_bind (Xml.member "conversionTask" xml)
               ConversionTask.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.conversion_task
              (fun f ->
                 Query.Pair ("ConversionTask", (ConversionTask.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.conversion_task
              (fun f -> ("conversion_task", (ConversionTask.to_json f)))])
    let of_json j =
      {
        conversion_task =
          (Util.option_map (Json.lookup j "conversion_task")
             ConversionTask.of_json)
      }
  end
module RegisterImageRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      image_location: String.t option ;
      name: String.t ;
      description: String.t option ;
      architecture: ArchitectureValues.t option ;
      kernel_id: String.t option ;
      ramdisk_id: String.t option ;
      root_device_name: String.t option ;
      block_device_mappings: BlockDeviceMappingRequestList.t ;
      virtualization_type: String.t option ;
      sriov_net_support: String.t option }
    let make ?dry_run  ?image_location  ~name  ?description  ?architecture 
      ?kernel_id  ?ramdisk_id  ?root_device_name  ?(block_device_mappings=
      [])  ?virtualization_type  ?sriov_net_support  () =
      {
        dry_run;
        image_location;
        name;
        description;
        architecture;
        kernel_id;
        ramdisk_id;
        root_device_name;
        block_device_mappings;
        virtualization_type;
        sriov_net_support
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          image_location =
            (Util.option_bind (Xml.member "ImageLocation" xml) String.parse);
          name =
            (Xml.required "name"
               (Util.option_bind (Xml.member "name" xml) String.parse));
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          architecture =
            (Util.option_bind (Xml.member "architecture" xml)
               ArchitectureValues.parse);
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdiskId" xml) String.parse);
          root_device_name =
            (Util.option_bind (Xml.member "rootDeviceName" xml) String.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "BlockDeviceMapping" xml)
                  BlockDeviceMappingRequestList.parse));
          virtualization_type =
            (Util.option_bind (Xml.member "virtualizationType" xml)
               String.parse);
          sriov_net_support =
            (Util.option_bind (Xml.member "sriovNetSupport" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.sriov_net_support
              (fun f -> Query.Pair ("SriovNetSupport", (String.to_query f)));
           Util.option_map v.virtualization_type
             (fun f -> Query.Pair ("VirtualizationType", (String.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingRequestList.to_query
                     v.block_device_mappings)));
           Util.option_map v.root_device_name
             (fun f -> Query.Pair ("RootDeviceName", (String.to_query f)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Util.option_map v.architecture
             (fun f ->
                Query.Pair ("Architecture", (ArchitectureValues.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some (Query.Pair ("Name", (String.to_query v.name)));
           Util.option_map v.image_location
             (fun f -> Query.Pair ("ImageLocation", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.sriov_net_support
              (fun f -> ("sriov_net_support", (String.to_json f)));
           Util.option_map v.virtualization_type
             (fun f -> ("virtualization_type", (String.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingRequestList.to_json v.block_device_mappings));
           Util.option_map v.root_device_name
             (fun f -> ("root_device_name", (String.to_json f)));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Util.option_map v.architecture
             (fun f -> ("architecture", (ArchitectureValues.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some ("name", (String.to_json v.name));
           Util.option_map v.image_location
             (fun f -> ("image_location", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        image_location =
          (Util.option_map (Json.lookup j "image_location") String.of_json);
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        architecture =
          (Util.option_map (Json.lookup j "architecture")
             ArchitectureValues.of_json);
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id") String.of_json);
        root_device_name =
          (Util.option_map (Json.lookup j "root_device_name") String.of_json);
        block_device_mappings =
          (BlockDeviceMappingRequestList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        virtualization_type =
          (Util.option_map (Json.lookup j "virtualization_type")
             String.of_json);
        sriov_net_support =
          (Util.option_map (Json.lookup j "sriov_net_support") String.of_json)
      }
  end
module CreateSecurityGroupRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      group_name: String.t ;
      description: String.t ;
      vpc_id: String.t option }
    let make ?dry_run  ~group_name  ~description  ?vpc_id  () =
      { dry_run; group_name; description; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          group_name =
            (Xml.required "GroupName"
               (Util.option_bind (Xml.member "GroupName" xml) String.parse));
          description =
            (Xml.required "GroupDescription"
               (Util.option_bind (Xml.member "GroupDescription" xml)
                  String.parse));
          vpc_id = (Util.option_bind (Xml.member "VpcId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some
             (Query.Pair
                ("GroupDescription", (String.to_query v.description)));
           Some (Query.Pair ("GroupName", (String.to_query v.group_name)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Some ("description", (String.to_json v.description));
           Some ("group_name", (String.to_json v.group_name));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "group_name")));
        description =
          (String.of_json (Util.of_option_exn (Json.lookup j "description")));
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json)
      }
  end
module DescribeVpcPeeringConnectionsResult =
  struct
    type t = {
      vpc_peering_connections: VpcPeeringConnectionList.t }
    let make ?(vpc_peering_connections= [])  () = { vpc_peering_connections }
    let parse xml =
      Some
        {
          vpc_peering_connections =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpcPeeringConnectionSet" xml)
                  VpcPeeringConnectionList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpcPeeringConnectionSet",
                   (VpcPeeringConnectionList.to_query
                      v.vpc_peering_connections)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("vpc_peering_connections",
                (VpcPeeringConnectionList.to_json v.vpc_peering_connections))])
    let of_json j =
      {
        vpc_peering_connections =
          (VpcPeeringConnectionList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_peering_connections")))
      }
  end
module DescribeVolumeAttributeResult =
  struct
    type t =
      {
      volume_id: String.t option ;
      auto_enable_i_o: AttributeBooleanValue.t option ;
      product_codes: ProductCodeList.t }
    let make ?volume_id  ?auto_enable_i_o  ?(product_codes= [])  () =
      { volume_id; auto_enable_i_o; product_codes }
    let parse xml =
      Some
        {
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse);
          auto_enable_i_o =
            (Util.option_bind (Xml.member "autoEnableIO" xml)
               AttributeBooleanValue.parse);
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Util.option_map v.auto_enable_i_o
             (fun f ->
                Query.Pair
                  ("AutoEnableIO", (AttributeBooleanValue.to_query f)));
           Util.option_map v.volume_id
             (fun f -> Query.Pair ("VolumeId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Util.option_map v.auto_enable_i_o
             (fun f -> ("auto_enable_i_o", (AttributeBooleanValue.to_json f)));
           Util.option_map v.volume_id
             (fun f -> ("volume_id", (String.to_json f)))])
    let of_json j =
      {
        volume_id =
          (Util.option_map (Json.lookup j "volume_id") String.of_json);
        auto_enable_i_o =
          (Util.option_map (Json.lookup j "auto_enable_i_o")
             AttributeBooleanValue.of_json);
        product_codes =
          (ProductCodeList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")))
      }
  end
module DescribeVpcsResult =
  struct
    type t = {
      vpcs: VpcList.t }
    let make ?(vpcs= [])  () = { vpcs }
    let parse xml =
      Some
        {
          vpcs =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpcSet" xml) VpcList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcSet", (VpcList.to_query v.vpcs)))])
    let to_json v =
      `Assoc (Util.list_filter_opt [Some ("vpcs", (VpcList.to_json v.vpcs))])
    let of_json j =
      { vpcs = (VpcList.of_json (Util.of_option_exn (Json.lookup j "vpcs")))
      }
  end
module DescribePrefixListsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      prefix_list_ids: ValueStringList.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(prefix_list_ids= [])  ?(filters= [])  ?max_results 
      ?next_token  () =
      { dry_run; prefix_list_ids; filters; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          prefix_list_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "PrefixListId" xml)
                  ValueStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("PrefixListId",
                  (ValueStringList.to_query v.prefix_list_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("prefix_list_ids", (ValueStringList.to_json v.prefix_list_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        prefix_list_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "prefix_list_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeNetworkAclsResult =
  struct
    type t = {
      network_acls: NetworkAclList.t }
    let make ?(network_acls= [])  () = { network_acls }
    let parse xml =
      Some
        {
          network_acls =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkAclSet" xml)
                  NetworkAclList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("NetworkAclSet", (NetworkAclList.to_query v.network_acls)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("network_acls", (NetworkAclList.to_json v.network_acls))])
    let of_json j =
      {
        network_acls =
          (NetworkAclList.of_json
             (Util.of_option_exn (Json.lookup j "network_acls")))
      }
  end
module DescribeSubnetsResult =
  struct
    type t = {
      subnets: SubnetList.t }
    let make ?(subnets= [])  () = { subnets }
    let parse xml =
      Some
        {
          subnets =
            (Util.of_option []
               (Util.option_bind (Xml.member "subnetSet" xml)
                  SubnetList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("SubnetSet", (SubnetList.to_query v.subnets)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("subnets", (SubnetList.to_json v.subnets))])
    let of_json j =
      {
        subnets =
          (SubnetList.of_json (Util.of_option_exn (Json.lookup j "subnets")))
      }
  end
module CancelBundleTaskResult =
  struct
    type t = {
      bundle_task: BundleTask.t option }
    let make ?bundle_task  () = { bundle_task }
    let parse xml =
      Some
        {
          bundle_task =
            (Util.option_bind (Xml.member "bundleInstanceTask" xml)
               BundleTask.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.bundle_task
              (fun f ->
                 Query.Pair ("BundleInstanceTask", (BundleTask.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.bundle_task
              (fun f -> ("bundle_task", (BundleTask.to_json f)))])
    let of_json j =
      {
        bundle_task =
          (Util.option_map (Json.lookup j "bundle_task") BundleTask.of_json)
      }
  end
module DetachInternetGatewayRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      internet_gateway_id: String.t ;
      vpc_id: String.t }
    let make ?dry_run  ~internet_gateway_id  ~vpc_id  () =
      { dry_run; internet_gateway_id; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          internet_gateway_id =
            (Xml.required "internetGatewayId"
               (Util.option_bind (Xml.member "internetGatewayId" xml)
                  String.parse));
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some
             (Query.Pair
                ("InternetGatewayId",
                  (String.to_query v.internet_gateway_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Some
             ("internet_gateway_id", (String.to_json v.internet_gateway_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        internet_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "internet_gateway_id")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module CancelConversionRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      conversion_task_id: String.t ;
      reason_message: String.t option }
    let make ?dry_run  ~conversion_task_id  ?reason_message  () =
      { dry_run; conversion_task_id; reason_message }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          conversion_task_id =
            (Xml.required "conversionTaskId"
               (Util.option_bind (Xml.member "conversionTaskId" xml)
                  String.parse));
          reason_message =
            (Util.option_bind (Xml.member "reasonMessage" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reason_message
              (fun f -> Query.Pair ("ReasonMessage", (String.to_query f)));
           Some
             (Query.Pair
                ("ConversionTaskId", (String.to_query v.conversion_task_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reason_message
              (fun f -> ("reason_message", (String.to_json f)));
           Some ("conversion_task_id", (String.to_json v.conversion_task_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        conversion_task_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "conversion_task_id")));
        reason_message =
          (Util.option_map (Json.lookup j "reason_message") String.of_json)
      }
  end
module AttachInternetGatewayRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      internet_gateway_id: String.t ;
      vpc_id: String.t }
    let make ?dry_run  ~internet_gateway_id  ~vpc_id  () =
      { dry_run; internet_gateway_id; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          internet_gateway_id =
            (Xml.required "internetGatewayId"
               (Util.option_bind (Xml.member "internetGatewayId" xml)
                  String.parse));
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some
             (Query.Pair
                ("InternetGatewayId",
                  (String.to_query v.internet_gateway_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Some
             ("internet_gateway_id", (String.to_json v.internet_gateway_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        internet_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "internet_gateway_id")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module DescribeVpcClassicLinkResult =
  struct
    type t = {
      vpcs: VpcClassicLinkList.t }
    let make ?(vpcs= [])  () = { vpcs }
    let parse xml =
      Some
        {
          vpcs =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpcSet" xml)
                  VpcClassicLinkList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("VpcSet", (VpcClassicLinkList.to_query v.vpcs)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpcs", (VpcClassicLinkList.to_json v.vpcs))])
    let of_json j =
      {
        vpcs =
          (VpcClassicLinkList.of_json
             (Util.of_option_exn (Json.lookup j "vpcs")))
      }
  end
module DescribeImportImageTasksResult =
  struct
    type t =
      {
      import_image_tasks: ImportImageTaskList.t ;
      next_token: String.t option }
    let make ?(import_image_tasks= [])  ?next_token  () =
      { import_image_tasks; next_token }
    let parse xml =
      Some
        {
          import_image_tasks =
            (Util.of_option []
               (Util.option_bind (Xml.member "importImageTaskSet" xml)
                  ImportImageTaskList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ImportImageTaskSet",
                  (ImportImageTaskList.to_query v.import_image_tasks)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("import_image_tasks",
               (ImportImageTaskList.to_json v.import_image_tasks))])
    let of_json j =
      {
        import_image_tasks =
          (ImportImageTaskList.of_json
             (Util.of_option_exn (Json.lookup j "import_image_tasks")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateFlowLogsRequest =
  struct
    type t =
      {
      resource_ids: ValueStringList.t ;
      resource_type: FlowLogsResourceType.t ;
      traffic_type: TrafficType.t ;
      log_group_name: String.t ;
      deliver_logs_permission_arn: String.t ;
      client_token: String.t option }
    let make ~resource_ids  ~resource_type  ~traffic_type  ~log_group_name 
      ~deliver_logs_permission_arn  ?client_token  () =
      {
        resource_ids;
        resource_type;
        traffic_type;
        log_group_name;
        deliver_logs_permission_arn;
        client_token
      }
    let parse xml =
      Some
        {
          resource_ids =
            (Xml.required "ResourceId"
               (Util.option_bind (Xml.member "ResourceId" xml)
                  ValueStringList.parse));
          resource_type =
            (Xml.required "ResourceType"
               (Util.option_bind (Xml.member "ResourceType" xml)
                  FlowLogsResourceType.parse));
          traffic_type =
            (Xml.required "TrafficType"
               (Util.option_bind (Xml.member "TrafficType" xml)
                  TrafficType.parse));
          log_group_name =
            (Xml.required "LogGroupName"
               (Util.option_bind (Xml.member "LogGroupName" xml) String.parse));
          deliver_logs_permission_arn =
            (Xml.required "DeliverLogsPermissionArn"
               (Util.option_bind (Xml.member "DeliverLogsPermissionArn" xml)
                  String.parse));
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some
             (Query.Pair
                ("DeliverLogsPermissionArn",
                  (String.to_query v.deliver_logs_permission_arn)));
           Some
             (Query.Pair ("LogGroupName", (String.to_query v.log_group_name)));
           Some
             (Query.Pair
                ("TrafficType", (TrafficType.to_query v.traffic_type)));
           Some
             (Query.Pair
                ("ResourceType",
                  (FlowLogsResourceType.to_query v.resource_type)));
           Some
             (Query.Pair
                ("ResourceId", (ValueStringList.to_query v.resource_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Some
             ("deliver_logs_permission_arn",
               (String.to_json v.deliver_logs_permission_arn));
           Some ("log_group_name", (String.to_json v.log_group_name));
           Some ("traffic_type", (TrafficType.to_json v.traffic_type));
           Some
             ("resource_type",
               (FlowLogsResourceType.to_json v.resource_type));
           Some ("resource_ids", (ValueStringList.to_json v.resource_ids))])
    let of_json j =
      {
        resource_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "resource_ids")));
        resource_type =
          (FlowLogsResourceType.of_json
             (Util.of_option_exn (Json.lookup j "resource_type")));
        traffic_type =
          (TrafficType.of_json
             (Util.of_option_exn (Json.lookup j "traffic_type")));
        log_group_name =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "log_group_name")));
        deliver_logs_permission_arn =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "deliver_logs_permission_arn")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module CancelSpotFleetRequestsResponse =
  struct
    type t =
      {
      unsuccessful_fleet_requests: CancelSpotFleetRequestsErrorSet.t ;
      successful_fleet_requests: CancelSpotFleetRequestsSuccessSet.t }
    let make ?(unsuccessful_fleet_requests= [])  ?(successful_fleet_requests=
      [])  () = { unsuccessful_fleet_requests; successful_fleet_requests }
    let parse xml =
      Some
        {
          unsuccessful_fleet_requests =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "unsuccessfulFleetRequestSet" xml)
                  CancelSpotFleetRequestsErrorSet.parse));
          successful_fleet_requests =
            (Util.of_option []
               (Util.option_bind (Xml.member "successfulFleetRequestSet" xml)
                  CancelSpotFleetRequestsSuccessSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SuccessfulFleetRequestSet",
                   (CancelSpotFleetRequestsSuccessSet.to_query
                      v.successful_fleet_requests)));
           Some
             (Query.Pair
                ("UnsuccessfulFleetRequestSet",
                  (CancelSpotFleetRequestsErrorSet.to_query
                     v.unsuccessful_fleet_requests)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("successful_fleet_requests",
                (CancelSpotFleetRequestsSuccessSet.to_json
                   v.successful_fleet_requests));
           Some
             ("unsuccessful_fleet_requests",
               (CancelSpotFleetRequestsErrorSet.to_json
                  v.unsuccessful_fleet_requests))])
    let of_json j =
      {
        unsuccessful_fleet_requests =
          (CancelSpotFleetRequestsErrorSet.of_json
             (Util.of_option_exn
                (Json.lookup j "unsuccessful_fleet_requests")));
        successful_fleet_requests =
          (CancelSpotFleetRequestsSuccessSet.of_json
             (Util.of_option_exn (Json.lookup j "successful_fleet_requests")))
      }
  end
module CreateSnapshotRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      volume_id: String.t ;
      description: String.t option }
    let make ?dry_run  ~volume_id  ?description  () =
      { dry_run; volume_id; description }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          volume_id =
            (Xml.required "VolumeId"
               (Util.option_bind (Xml.member "VolumeId" xml) String.parse));
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (String.to_json f)));
           Some ("volume_id", (String.to_json v.volume_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json)
      }
  end
module DescribeAccountAttributesResult =
  struct
    type t = {
      account_attributes: AccountAttributeList.t }
    let make ?(account_attributes= [])  () = { account_attributes }
    let parse xml =
      Some
        {
          account_attributes =
            (Util.of_option []
               (Util.option_bind (Xml.member "accountAttributeSet" xml)
                  AccountAttributeList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AccountAttributeSet",
                   (AccountAttributeList.to_query v.account_attributes)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("account_attributes",
                (AccountAttributeList.to_json v.account_attributes))])
    let of_json j =
      {
        account_attributes =
          (AccountAttributeList.of_json
             (Util.of_option_exn (Json.lookup j "account_attributes")))
      }
  end
module ReplaceRouteTableAssociationResult =
  struct
    type t = {
      new_association_id: String.t option }
    let make ?new_association_id  () = { new_association_id }
    let parse xml =
      Some
        {
          new_association_id =
            (Util.option_bind (Xml.member "newAssociationId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.new_association_id
              (fun f -> Query.Pair ("NewAssociationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.new_association_id
              (fun f -> ("new_association_id", (String.to_json f)))])
    let of_json j =
      {
        new_association_id =
          (Util.option_map (Json.lookup j "new_association_id")
             String.of_json)
      }
  end
module DescribeVolumeStatusRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      volume_ids: VolumeIdStringList.t ;
      filters: FilterList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?dry_run  ?(volume_ids= [])  ?(filters= [])  ?next_token 
      ?max_results  () =
      { dry_run; volume_ids; filters; next_token; max_results }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          volume_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VolumeId" xml)
                  VolumeIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("VolumeId", (VolumeIdStringList.to_query v.volume_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some ("volume_ids", (VolumeIdStringList.to_json v.volume_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        volume_ids =
          (VolumeIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "volume_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module DescribeDhcpOptionsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      dhcp_options_ids: DhcpOptionsIdStringList.t ;
      filters: FilterList.t }
    let make ?dry_run  ?(dhcp_options_ids= [])  ?(filters= [])  () =
      { dry_run; dhcp_options_ids; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          dhcp_options_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "DhcpOptionsId" xml)
                  DhcpOptionsIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("DhcpOptionsId",
                  (DhcpOptionsIdStringList.to_query v.dhcp_options_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some
             ("dhcp_options_ids",
               (DhcpOptionsIdStringList.to_json v.dhcp_options_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        dhcp_options_ids =
          (DhcpOptionsIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "dhcp_options_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module DescribeSpotPriceHistoryResult =
  struct
    type t =
      {
      spot_price_history: SpotPriceHistoryList.t ;
      next_token: String.t option }
    let make ?(spot_price_history= [])  ?next_token  () =
      { spot_price_history; next_token }
    let parse xml =
      Some
        {
          spot_price_history =
            (Util.of_option []
               (Util.option_bind (Xml.member "spotPriceHistorySet" xml)
                  SpotPriceHistoryList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("SpotPriceHistorySet",
                  (SpotPriceHistoryList.to_query v.spot_price_history)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("spot_price_history",
               (SpotPriceHistoryList.to_json v.spot_price_history))])
    let of_json j =
      {
        spot_price_history =
          (SpotPriceHistoryList.of_json
             (Util.of_option_exn (Json.lookup j "spot_price_history")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeleteTagsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      resources: ResourceIdList.t ;
      tags: TagList.t }
    let make ?dry_run  ~resources  ?(tags= [])  () =
      { dry_run; resources; tags }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          resources =
            (Xml.required "resourceId"
               (Util.option_bind (Xml.member "resourceId" xml)
                  ResourceIdList.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tag" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Tag", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("ResourceId", (ResourceIdList.to_query v.resources)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Some ("resources", (ResourceIdList.to_json v.resources));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        resources =
          (ResourceIdList.of_json
             (Util.of_option_exn (Json.lookup j "resources")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module ReportInstanceStatusRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instances: InstanceIdStringList.t ;
      status: ReportStatusType.t ;
      start_time: DateTime.t option ;
      end_time: DateTime.t option ;
      reason_codes: ReasonCodesList.t ;
      description: String.t option }
    let make ?dry_run  ~instances  ~status  ?start_time  ?end_time 
      ~reason_codes  ?description  () =
      {
        dry_run;
        instances;
        status;
        start_time;
        end_time;
        reason_codes;
        description
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instances =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml)
                  InstanceIdStringList.parse));
          status =
            (Xml.required "status"
               (Util.option_bind (Xml.member "status" xml)
                  ReportStatusType.parse));
          start_time =
            (Util.option_bind (Xml.member "startTime" xml) DateTime.parse);
          end_time =
            (Util.option_bind (Xml.member "endTime" xml) DateTime.parse);
          reason_codes =
            (Xml.required "reasonCode"
               (Util.option_bind (Xml.member "reasonCode" xml)
                  ReasonCodesList.parse));
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some
             (Query.Pair
                ("ReasonCode", (ReasonCodesList.to_query v.reason_codes)));
           Util.option_map v.end_time
             (fun f -> Query.Pair ("EndTime", (DateTime.to_query f)));
           Util.option_map v.start_time
             (fun f -> Query.Pair ("StartTime", (DateTime.to_query f)));
           Some (Query.Pair ("Status", (ReportStatusType.to_query v.status)));
           Some
             (Query.Pair
                ("InstanceId", (InstanceIdStringList.to_query v.instances)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (String.to_json f)));
           Some ("reason_codes", (ReasonCodesList.to_json v.reason_codes));
           Util.option_map v.end_time
             (fun f -> ("end_time", (DateTime.to_json f)));
           Util.option_map v.start_time
             (fun f -> ("start_time", (DateTime.to_json f)));
           Some ("status", (ReportStatusType.to_json v.status));
           Some ("instances", (InstanceIdStringList.to_json v.instances));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instances =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instances")));
        status =
          (ReportStatusType.of_json
             (Util.of_option_exn (Json.lookup j "status")));
        start_time =
          (Util.option_map (Json.lookup j "start_time") DateTime.of_json);
        end_time =
          (Util.option_map (Json.lookup j "end_time") DateTime.of_json);
        reason_codes =
          (ReasonCodesList.of_json
             (Util.of_option_exn (Json.lookup j "reason_codes")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json)
      }
  end
module AssociateRouteTableResult =
  struct
    type t = {
      association_id: String.t option }
    let make ?association_id  () = { association_id }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.association_id
              (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_id
              (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json)
      }
  end
module CreateVpcPeeringConnectionRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_id: String.t option ;
      peer_vpc_id: String.t option ;
      peer_owner_id: String.t option }
    let make ?dry_run  ?vpc_id  ?peer_vpc_id  ?peer_owner_id  () =
      { dry_run; vpc_id; peer_vpc_id; peer_owner_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          peer_vpc_id =
            (Util.option_bind (Xml.member "peerVpcId" xml) String.parse);
          peer_owner_id =
            (Util.option_bind (Xml.member "peerOwnerId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.peer_owner_id
              (fun f -> Query.Pair ("PeerOwnerId", (String.to_query f)));
           Util.option_map v.peer_vpc_id
             (fun f -> Query.Pair ("PeerVpcId", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.peer_owner_id
              (fun f -> ("peer_owner_id", (String.to_json f)));
           Util.option_map v.peer_vpc_id
             (fun f -> ("peer_vpc_id", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        peer_vpc_id =
          (Util.option_map (Json.lookup j "peer_vpc_id") String.of_json);
        peer_owner_id =
          (Util.option_map (Json.lookup j "peer_owner_id") String.of_json)
      }
  end
module DescribeVpcsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_ids: VpcIdStringList.t ;
      filters: FilterList.t }
    let make ?dry_run  ?(vpc_ids= [])  ?(filters= [])  () =
      { dry_run; vpc_ids; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VpcId" xml)
                  VpcIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some (Query.Pair ("VpcId", (VpcIdStringList.to_query v.vpc_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some ("vpc_ids", (VpcIdStringList.to_json v.vpc_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_ids =
          (VpcIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module DetachNetworkInterfaceRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      attachment_id: String.t ;
      force: Boolean.t option }
    let make ?dry_run  ~attachment_id  ?force  () =
      { dry_run; attachment_id; force }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          attachment_id =
            (Xml.required "attachmentId"
               (Util.option_bind (Xml.member "attachmentId" xml) String.parse));
          force = (Util.option_bind (Xml.member "force" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.force
              (fun f -> Query.Pair ("Force", (Boolean.to_query f)));
           Some
             (Query.Pair ("AttachmentId", (String.to_query v.attachment_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.force (fun f -> ("force", (Boolean.to_json f)));
           Some ("attachment_id", (String.to_json v.attachment_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        attachment_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "attachment_id")));
        force = (Util.option_map (Json.lookup j "force") Boolean.of_json)
      }
  end
module CreateNetworkInterfaceRequest =
  struct
    type t =
      {
      subnet_id: String.t ;
      description: String.t option ;
      private_ip_address: String.t option ;
      groups: SecurityGroupIdStringList.t ;
      private_ip_addresses: PrivateIpAddressSpecificationList.t ;
      secondary_private_ip_address_count: Integer.t option ;
      dry_run: Boolean.t option }
    let make ~subnet_id  ?description  ?private_ip_address  ?(groups= []) 
      ?(private_ip_addresses= [])  ?secondary_private_ip_address_count 
      ?dry_run  () =
      {
        subnet_id;
        description;
        private_ip_address;
        groups;
        private_ip_addresses;
        secondary_private_ip_address_count;
        dry_run
      }
    let parse xml =
      Some
        {
          subnet_id =
            (Xml.required "subnetId"
               (Util.option_bind (Xml.member "subnetId" xml) String.parse));
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  SecurityGroupIdStringList.parse));
          private_ip_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "privateIpAddresses" xml)
                  PrivateIpAddressSpecificationList.parse));
          secondary_private_ip_address_count =
            (Util.option_bind
               (Xml.member "secondaryPrivateIpAddressCount" xml)
               Integer.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                Query.Pair
                  ("SecondaryPrivateIpAddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddresses",
                  (PrivateIpAddressSpecificationList.to_query
                     v.private_ip_addresses)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (SecurityGroupIdStringList.to_query v.groups)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some (Query.Pair ("SubnetId", (String.to_query v.subnet_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                ("secondary_private_ip_address_count", (Integer.to_json f)));
           Some
             ("private_ip_addresses",
               (PrivateIpAddressSpecificationList.to_json
                  v.private_ip_addresses));
           Some ("groups", (SecurityGroupIdStringList.to_json v.groups));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some ("subnet_id", (String.to_json v.subnet_id))])
    let of_json j =
      {
        subnet_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "subnet_id")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        groups =
          (SecurityGroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        private_ip_addresses =
          (PrivateIpAddressSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "private_ip_addresses")));
        secondary_private_ip_address_count =
          (Util.option_map
             (Json.lookup j "secondary_private_ip_address_count")
             Integer.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module GetPasswordDataRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      instance_id: String.t }
    let make ?dry_run  ~instance_id  () = { dry_run; instance_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")))
      }
  end
module DeregisterImageRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      image_id: String.t }
    let make ?dry_run  ~image_id  () = { dry_run; image_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          image_id =
            (Xml.required "ImageId"
               (Util.option_bind (Xml.member "ImageId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("ImageId", (String.to_query v.image_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("image_id", (String.to_json v.image_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        image_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "image_id")))
      }
  end
module BundleInstanceRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_id: String.t ;
      storage: Storage.t }
    let make ?dry_run  ~instance_id  ~storage  () =
      { dry_run; instance_id; storage }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          storage =
            (Xml.required "Storage"
               (Util.option_bind (Xml.member "Storage" xml) Storage.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Storage", (Storage.to_query v.storage)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("storage", (Storage.to_json v.storage));
           Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        storage =
          (Storage.of_json (Util.of_option_exn (Json.lookup j "storage")))
      }
  end
module RebootInstancesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_ids: InstanceIdStringList.t }
    let make ?dry_run  ~instance_ids  () = { dry_run; instance_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_ids =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstanceId",
                   (InstanceIdStringList.to_query v.instance_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instance_ids", (InstanceIdStringList.to_json v.instance_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")))
      }
  end
module ReplaceRouteTableAssociationRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      association_id: String.t ;
      route_table_id: String.t }
    let make ?dry_run  ~association_id  ~route_table_id  () =
      { dry_run; association_id; route_table_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          association_id =
            (Xml.required "associationId"
               (Util.option_bind (Xml.member "associationId" xml)
                  String.parse));
          route_table_id =
            (Xml.required "routeTableId"
               (Util.option_bind (Xml.member "routeTableId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("RouteTableId", (String.to_query v.route_table_id)));
           Some
             (Query.Pair
                ("AssociationId", (String.to_query v.association_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("route_table_id", (String.to_json v.route_table_id));
           Some ("association_id", (String.to_json v.association_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        association_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "association_id")));
        route_table_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "route_table_id")))
      }
  end
module DescribeClassicLinkInstancesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_ids: InstanceIdStringList.t ;
      filters: FilterList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?dry_run  ?(instance_ids= [])  ?(filters= [])  ?next_token 
      ?max_results  () =
      { dry_run; instance_ids; filters; next_token; max_results }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("InstanceId",
                  (InstanceIdStringList.to_query v.instance_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("instance_ids", (InstanceIdStringList.to_json v.instance_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module CreateInternetGatewayResult =
  struct
    type t = {
      internet_gateway: InternetGateway.t option }
    let make ?internet_gateway  () = { internet_gateway }
    let parse xml =
      Some
        {
          internet_gateway =
            (Util.option_bind (Xml.member "internetGateway" xml)
               InternetGateway.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.internet_gateway
              (fun f ->
                 Query.Pair ("InternetGateway", (InternetGateway.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.internet_gateway
              (fun f -> ("internet_gateway", (InternetGateway.to_json f)))])
    let of_json j =
      {
        internet_gateway =
          (Util.option_map (Json.lookup j "internet_gateway")
             InternetGateway.of_json)
      }
  end
module ImportInstanceRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      description: String.t option ;
      launch_specification: ImportInstanceLaunchSpecification.t option ;
      disk_images: DiskImageList.t ;
      platform: PlatformValues.t }
    let make ?dry_run  ?description  ?launch_specification  ?(disk_images=
      [])  ~platform  () =
      { dry_run; description; launch_specification; disk_images; platform }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          launch_specification =
            (Util.option_bind (Xml.member "launchSpecification" xml)
               ImportInstanceLaunchSpecification.parse);
          disk_images =
            (Util.of_option []
               (Util.option_bind (Xml.member "diskImage" xml)
                  DiskImageList.parse));
          platform =
            (Xml.required "platform"
               (Util.option_bind (Xml.member "platform" xml)
                  PlatformValues.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("Platform", (PlatformValues.to_query v.platform)));
           Some
             (Query.Pair
                ("DiskImage", (DiskImageList.to_query v.disk_images)));
           Util.option_map v.launch_specification
             (fun f ->
                Query.Pair
                  ("LaunchSpecification",
                    (ImportInstanceLaunchSpecification.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("platform", (PlatformValues.to_json v.platform));
           Some ("disk_images", (DiskImageList.to_json v.disk_images));
           Util.option_map v.launch_specification
             (fun f ->
                ("launch_specification",
                  (ImportInstanceLaunchSpecification.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        launch_specification =
          (Util.option_map (Json.lookup j "launch_specification")
             ImportInstanceLaunchSpecification.of_json);
        disk_images =
          (DiskImageList.of_json
             (Util.of_option_exn (Json.lookup j "disk_images")));
        platform =
          (PlatformValues.of_json
             (Util.of_option_exn (Json.lookup j "platform")))
      }
  end
module ImportVolumeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      availability_zone: String.t ;
      image: DiskImageDetail.t ;
      description: String.t option ;
      volume: VolumeDetail.t }
    let make ?dry_run  ~availability_zone  ~image  ?description  ~volume  ()
      = { dry_run; availability_zone; image; description; volume }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          availability_zone =
            (Xml.required "availabilityZone"
               (Util.option_bind (Xml.member "availabilityZone" xml)
                  String.parse));
          image =
            (Xml.required "image"
               (Util.option_bind (Xml.member "image" xml)
                  DiskImageDetail.parse));
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          volume =
            (Xml.required "volume"
               (Util.option_bind (Xml.member "volume" xml) VolumeDetail.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Volume", (VolumeDetail.to_query v.volume)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some (Query.Pair ("Image", (DiskImageDetail.to_query v.image)));
           Some
             (Query.Pair
                ("AvailabilityZone", (String.to_query v.availability_zone)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("volume", (VolumeDetail.to_json v.volume));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some ("image", (DiskImageDetail.to_json v.image));
           Some ("availability_zone", (String.to_json v.availability_zone));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        availability_zone =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "availability_zone")));
        image =
          (DiskImageDetail.of_json
             (Util.of_option_exn (Json.lookup j "image")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        volume =
          (VolumeDetail.of_json (Util.of_option_exn (Json.lookup j "volume")))
      }
  end
module DescribeInstanceStatusRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_ids: InstanceIdStringList.t ;
      filters: FilterList.t ;
      next_token: String.t option ;
      max_results: Integer.t option ;
      include_all_instances: Boolean.t option }
    let make ?dry_run  ?(instance_ids= [])  ?(filters= [])  ?next_token 
      ?max_results  ?include_all_instances  () =
      {
        dry_run;
        instance_ids;
        filters;
        next_token;
        max_results;
        include_all_instances
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          include_all_instances =
            (Util.option_bind (Xml.member "includeAllInstances" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.include_all_instances
              (fun f ->
                 Query.Pair ("IncludeAllInstances", (Boolean.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("InstanceId",
                  (InstanceIdStringList.to_query v.instance_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.include_all_instances
              (fun f -> ("include_all_instances", (Boolean.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("instance_ids", (InstanceIdStringList.to_json v.instance_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        include_all_instances =
          (Util.option_map (Json.lookup j "include_all_instances")
             Boolean.of_json)
      }
  end
module CancelImportTaskRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      import_task_id: String.t option ;
      cancel_reason: String.t option }
    let make ?dry_run  ?import_task_id  ?cancel_reason  () =
      { dry_run; import_task_id; cancel_reason }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          import_task_id =
            (Util.option_bind (Xml.member "ImportTaskId" xml) String.parse);
          cancel_reason =
            (Util.option_bind (Xml.member "CancelReason" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cancel_reason
              (fun f -> Query.Pair ("CancelReason", (String.to_query f)));
           Util.option_map v.import_task_id
             (fun f -> Query.Pair ("ImportTaskId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cancel_reason
              (fun f -> ("cancel_reason", (String.to_json f)));
           Util.option_map v.import_task_id
             (fun f -> ("import_task_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        import_task_id =
          (Util.option_map (Json.lookup j "import_task_id") String.of_json);
        cancel_reason =
          (Util.option_map (Json.lookup j "cancel_reason") String.of_json)
      }
  end
module DescribeVpcEndpointsResult =
  struct
    type t = {
      vpc_endpoints: VpcEndpointSet.t ;
      next_token: String.t option }
    let make ?(vpc_endpoints= [])  ?next_token  () =
      { vpc_endpoints; next_token }
    let parse xml =
      Some
        {
          vpc_endpoints =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpcEndpointSet" xml)
                  VpcEndpointSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("VpcEndpointSet", (VpcEndpointSet.to_query v.vpc_endpoints)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("vpc_endpoints", (VpcEndpointSet.to_json v.vpc_endpoints))])
    let of_json j =
      {
        vpc_endpoints =
          (VpcEndpointSet.of_json
             (Util.of_option_exn (Json.lookup j "vpc_endpoints")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ImportImageRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      description: String.t option ;
      disk_containers: ImageDiskContainerList.t ;
      license_type: String.t option ;
      hypervisor: String.t option ;
      architecture: String.t option ;
      platform: String.t option ;
      client_data: ClientData.t option ;
      client_token: String.t option ;
      role_name: String.t option }
    let make ?dry_run  ?description  ?(disk_containers= [])  ?license_type 
      ?hypervisor  ?architecture  ?platform  ?client_data  ?client_token 
      ?role_name  () =
      {
        dry_run;
        description;
        disk_containers;
        license_type;
        hypervisor;
        architecture;
        platform;
        client_data;
        client_token;
        role_name
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          disk_containers =
            (Util.of_option []
               (Util.option_bind (Xml.member "DiskContainer" xml)
                  ImageDiskContainerList.parse));
          license_type =
            (Util.option_bind (Xml.member "LicenseType" xml) String.parse);
          hypervisor =
            (Util.option_bind (Xml.member "Hypervisor" xml) String.parse);
          architecture =
            (Util.option_bind (Xml.member "Architecture" xml) String.parse);
          platform =
            (Util.option_bind (Xml.member "Platform" xml) String.parse);
          client_data =
            (Util.option_bind (Xml.member "ClientData" xml) ClientData.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          role_name =
            (Util.option_bind (Xml.member "RoleName" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.role_name
              (fun f -> Query.Pair ("RoleName", (String.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.client_data
             (fun f -> Query.Pair ("ClientData", (ClientData.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (String.to_query f)));
           Util.option_map v.architecture
             (fun f -> Query.Pair ("Architecture", (String.to_query f)));
           Util.option_map v.hypervisor
             (fun f -> Query.Pair ("Hypervisor", (String.to_query f)));
           Util.option_map v.license_type
             (fun f -> Query.Pair ("LicenseType", (String.to_query f)));
           Some
             (Query.Pair
                ("DiskContainer",
                  (ImageDiskContainerList.to_query v.disk_containers)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.role_name
              (fun f -> ("role_name", (String.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.client_data
             (fun f -> ("client_data", (ClientData.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (String.to_json f)));
           Util.option_map v.architecture
             (fun f -> ("architecture", (String.to_json f)));
           Util.option_map v.hypervisor
             (fun f -> ("hypervisor", (String.to_json f)));
           Util.option_map v.license_type
             (fun f -> ("license_type", (String.to_json f)));
           Some
             ("disk_containers",
               (ImageDiskContainerList.to_json v.disk_containers));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        disk_containers =
          (ImageDiskContainerList.of_json
             (Util.of_option_exn (Json.lookup j "disk_containers")));
        license_type =
          (Util.option_map (Json.lookup j "license_type") String.of_json);
        hypervisor =
          (Util.option_map (Json.lookup j "hypervisor") String.of_json);
        architecture =
          (Util.option_map (Json.lookup j "architecture") String.of_json);
        platform =
          (Util.option_map (Json.lookup j "platform") String.of_json);
        client_data =
          (Util.option_map (Json.lookup j "client_data") ClientData.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        role_name =
          (Util.option_map (Json.lookup j "role_name") String.of_json)
      }
  end
module DescribeClassicLinkInstancesResult =
  struct
    type t =
      {
      instances: ClassicLinkInstanceList.t ;
      next_token: String.t option }
    let make ?(instances= [])  ?next_token  () = { instances; next_token }
    let parse xml =
      Some
        {
          instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  ClassicLinkInstanceList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("InstancesSet",
                  (ClassicLinkInstanceList.to_query v.instances)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("instances", (ClassicLinkInstanceList.to_json v.instances))])
    let of_json j =
      {
        instances =
          (ClassicLinkInstanceList.of_json
             (Util.of_option_exn (Json.lookup j "instances")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeSpotFleetInstancesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      spot_fleet_request_id: String.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?dry_run  ~spot_fleet_request_id  ?next_token  ?max_results  ()
      = { dry_run; spot_fleet_request_id; next_token; max_results }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          spot_fleet_request_id =
            (Xml.required "spotFleetRequestId"
               (Util.option_bind (Xml.member "spotFleetRequestId" xml)
                  String.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("SpotFleetRequestId",
                  (String.to_query v.spot_fleet_request_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("spot_fleet_request_id",
               (String.to_json v.spot_fleet_request_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        spot_fleet_request_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_id")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module DetachVpnGatewayRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpn_gateway_id: String.t ;
      vpc_id: String.t }
    let make ?dry_run  ~vpn_gateway_id  ~vpc_id  () =
      { dry_run; vpn_gateway_id; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpn_gateway_id =
            (Xml.required "VpnGatewayId"
               (Util.option_bind (Xml.member "VpnGatewayId" xml) String.parse));
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some
             (Query.Pair ("VpnGatewayId", (String.to_query v.vpn_gateway_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Some ("vpn_gateway_id", (String.to_json v.vpn_gateway_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpn_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_gateway_id")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module MonitorInstancesResult =
  struct
    type t = {
      instance_monitorings: InstanceMonitoringList.t }
    let make ?(instance_monitorings= [])  () = { instance_monitorings }
    let parse xml =
      Some
        {
          instance_monitorings =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  InstanceMonitoringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstancesSet",
                   (InstanceMonitoringList.to_query v.instance_monitorings)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instance_monitorings",
                (InstanceMonitoringList.to_json v.instance_monitorings))])
    let of_json j =
      {
        instance_monitorings =
          (InstanceMonitoringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_monitorings")))
      }
  end
module AuthorizeSecurityGroupIngressRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      group_name: String.t option ;
      group_id: String.t option ;
      source_security_group_name: String.t option ;
      source_security_group_owner_id: String.t option ;
      ip_protocol: String.t option ;
      from_port: Integer.t option ;
      to_port: Integer.t option ;
      cidr_ip: String.t option ;
      ip_permissions: IpPermissionList.t }
    let make ?dry_run  ?group_name  ?group_id  ?source_security_group_name 
      ?source_security_group_owner_id  ?ip_protocol  ?from_port  ?to_port 
      ?cidr_ip  ?(ip_permissions= [])  () =
      {
        dry_run;
        group_name;
        group_id;
        source_security_group_name;
        source_security_group_owner_id;
        ip_protocol;
        from_port;
        to_port;
        cidr_ip;
        ip_permissions
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          group_name =
            (Util.option_bind (Xml.member "GroupName" xml) String.parse);
          group_id =
            (Util.option_bind (Xml.member "GroupId" xml) String.parse);
          source_security_group_name =
            (Util.option_bind (Xml.member "SourceSecurityGroupName" xml)
               String.parse);
          source_security_group_owner_id =
            (Util.option_bind (Xml.member "SourceSecurityGroupOwnerId" xml)
               String.parse);
          ip_protocol =
            (Util.option_bind (Xml.member "IpProtocol" xml) String.parse);
          from_port =
            (Util.option_bind (Xml.member "FromPort" xml) Integer.parse);
          to_port =
            (Util.option_bind (Xml.member "ToPort" xml) Integer.parse);
          cidr_ip = (Util.option_bind (Xml.member "CidrIp" xml) String.parse);
          ip_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "IpPermissions" xml)
                  IpPermissionList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("IpPermissions",
                   (IpPermissionList.to_query v.ip_permissions)));
           Util.option_map v.cidr_ip
             (fun f -> Query.Pair ("CidrIp", (String.to_query f)));
           Util.option_map v.to_port
             (fun f -> Query.Pair ("ToPort", (Integer.to_query f)));
           Util.option_map v.from_port
             (fun f -> Query.Pair ("FromPort", (Integer.to_query f)));
           Util.option_map v.ip_protocol
             (fun f -> Query.Pair ("IpProtocol", (String.to_query f)));
           Util.option_map v.source_security_group_owner_id
             (fun f ->
                Query.Pair
                  ("SourceSecurityGroupOwnerId", (String.to_query f)));
           Util.option_map v.source_security_group_name
             (fun f ->
                Query.Pair ("SourceSecurityGroupName", (String.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("ip_permissions", (IpPermissionList.to_json v.ip_permissions));
           Util.option_map v.cidr_ip
             (fun f -> ("cidr_ip", (String.to_json f)));
           Util.option_map v.to_port
             (fun f -> ("to_port", (Integer.to_json f)));
           Util.option_map v.from_port
             (fun f -> ("from_port", (Integer.to_json f)));
           Util.option_map v.ip_protocol
             (fun f -> ("ip_protocol", (String.to_json f)));
           Util.option_map v.source_security_group_owner_id
             (fun f -> ("source_security_group_owner_id", (String.to_json f)));
           Util.option_map v.source_security_group_name
             (fun f -> ("source_security_group_name", (String.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json);
        source_security_group_name =
          (Util.option_map (Json.lookup j "source_security_group_name")
             String.of_json);
        source_security_group_owner_id =
          (Util.option_map (Json.lookup j "source_security_group_owner_id")
             String.of_json);
        ip_protocol =
          (Util.option_map (Json.lookup j "ip_protocol") String.of_json);
        from_port =
          (Util.option_map (Json.lookup j "from_port") Integer.of_json);
        to_port = (Util.option_map (Json.lookup j "to_port") Integer.of_json);
        cidr_ip = (Util.option_map (Json.lookup j "cidr_ip") String.of_json);
        ip_permissions =
          (IpPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "ip_permissions")))
      }
  end
module CreateInternetGatewayRequest =
  struct
    type t = {
      dry_run: Boolean.t option }
    let make ?dry_run  () = { dry_run }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      { dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeImageAttributeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      image_id: String.t ;
      attribute: ImageAttributeName.t }
    let make ?dry_run  ~image_id  ~attribute  () =
      { dry_run; image_id; attribute }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          image_id =
            (Xml.required "ImageId"
               (Util.option_bind (Xml.member "ImageId" xml) String.parse));
          attribute =
            (Xml.required "Attribute"
               (Util.option_bind (Xml.member "Attribute" xml)
                  ImageAttributeName.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Attribute", (ImageAttributeName.to_query v.attribute)));
           Some (Query.Pair ("ImageId", (String.to_query v.image_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("attribute", (ImageAttributeName.to_json v.attribute));
           Some ("image_id", (String.to_json v.image_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        image_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "image_id")));
        attribute =
          (ImageAttributeName.of_json
             (Util.of_option_exn (Json.lookup j "attribute")))
      }
  end
module DeleteCustomerGatewayRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      customer_gateway_id: String.t }
    let make ?dry_run  ~customer_gateway_id  () =
      { dry_run; customer_gateway_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          customer_gateway_id =
            (Xml.required "CustomerGatewayId"
               (Util.option_bind (Xml.member "CustomerGatewayId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("CustomerGatewayId",
                   (String.to_query v.customer_gateway_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("customer_gateway_id", (String.to_json v.customer_gateway_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        customer_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "customer_gateway_id")))
      }
  end
module DescribeSnapshotsResult =
  struct
    type t = {
      snapshots: SnapshotList.t ;
      next_token: String.t option }
    let make ?(snapshots= [])  ?next_token  () = { snapshots; next_token }
    let parse xml =
      Some
        {
          snapshots =
            (Util.of_option []
               (Util.option_bind (Xml.member "snapshotSet" xml)
                  SnapshotList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair ("SnapshotSet", (SnapshotList.to_query v.snapshots)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("snapshots", (SnapshotList.to_json v.snapshots))])
    let of_json j =
      {
        snapshots =
          (SnapshotList.of_json
             (Util.of_option_exn (Json.lookup j "snapshots")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module EnableVolumeIORequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      volume_id: String.t }
    let make ?dry_run  ~volume_id  () = { dry_run; volume_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          volume_id =
            (Xml.required "volumeId"
               (Util.option_bind (Xml.member "volumeId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("volume_id", (String.to_json v.volume_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")))
      }
  end
module RevokeSecurityGroupIngressRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      group_name: String.t option ;
      group_id: String.t option ;
      source_security_group_name: String.t option ;
      source_security_group_owner_id: String.t option ;
      ip_protocol: String.t option ;
      from_port: Integer.t option ;
      to_port: Integer.t option ;
      cidr_ip: String.t option ;
      ip_permissions: IpPermissionList.t }
    let make ?dry_run  ?group_name  ?group_id  ?source_security_group_name 
      ?source_security_group_owner_id  ?ip_protocol  ?from_port  ?to_port 
      ?cidr_ip  ?(ip_permissions= [])  () =
      {
        dry_run;
        group_name;
        group_id;
        source_security_group_name;
        source_security_group_owner_id;
        ip_protocol;
        from_port;
        to_port;
        cidr_ip;
        ip_permissions
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          group_name =
            (Util.option_bind (Xml.member "GroupName" xml) String.parse);
          group_id =
            (Util.option_bind (Xml.member "GroupId" xml) String.parse);
          source_security_group_name =
            (Util.option_bind (Xml.member "SourceSecurityGroupName" xml)
               String.parse);
          source_security_group_owner_id =
            (Util.option_bind (Xml.member "SourceSecurityGroupOwnerId" xml)
               String.parse);
          ip_protocol =
            (Util.option_bind (Xml.member "IpProtocol" xml) String.parse);
          from_port =
            (Util.option_bind (Xml.member "FromPort" xml) Integer.parse);
          to_port =
            (Util.option_bind (Xml.member "ToPort" xml) Integer.parse);
          cidr_ip = (Util.option_bind (Xml.member "CidrIp" xml) String.parse);
          ip_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "IpPermissions" xml)
                  IpPermissionList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("IpPermissions",
                   (IpPermissionList.to_query v.ip_permissions)));
           Util.option_map v.cidr_ip
             (fun f -> Query.Pair ("CidrIp", (String.to_query f)));
           Util.option_map v.to_port
             (fun f -> Query.Pair ("ToPort", (Integer.to_query f)));
           Util.option_map v.from_port
             (fun f -> Query.Pair ("FromPort", (Integer.to_query f)));
           Util.option_map v.ip_protocol
             (fun f -> Query.Pair ("IpProtocol", (String.to_query f)));
           Util.option_map v.source_security_group_owner_id
             (fun f ->
                Query.Pair
                  ("SourceSecurityGroupOwnerId", (String.to_query f)));
           Util.option_map v.source_security_group_name
             (fun f ->
                Query.Pair ("SourceSecurityGroupName", (String.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("ip_permissions", (IpPermissionList.to_json v.ip_permissions));
           Util.option_map v.cidr_ip
             (fun f -> ("cidr_ip", (String.to_json f)));
           Util.option_map v.to_port
             (fun f -> ("to_port", (Integer.to_json f)));
           Util.option_map v.from_port
             (fun f -> ("from_port", (Integer.to_json f)));
           Util.option_map v.ip_protocol
             (fun f -> ("ip_protocol", (String.to_json f)));
           Util.option_map v.source_security_group_owner_id
             (fun f -> ("source_security_group_owner_id", (String.to_json f)));
           Util.option_map v.source_security_group_name
             (fun f -> ("source_security_group_name", (String.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json);
        source_security_group_name =
          (Util.option_map (Json.lookup j "source_security_group_name")
             String.of_json);
        source_security_group_owner_id =
          (Util.option_map (Json.lookup j "source_security_group_owner_id")
             String.of_json);
        ip_protocol =
          (Util.option_map (Json.lookup j "ip_protocol") String.of_json);
        from_port =
          (Util.option_map (Json.lookup j "from_port") Integer.of_json);
        to_port = (Util.option_map (Json.lookup j "to_port") Integer.of_json);
        cidr_ip = (Util.option_map (Json.lookup j "cidr_ip") String.of_json);
        ip_permissions =
          (IpPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "ip_permissions")))
      }
  end
module DisableVgwRoutePropagationRequest =
  struct
    type t = {
      route_table_id: String.t ;
      gateway_id: String.t }
    let make ~route_table_id  ~gateway_id  () =
      { route_table_id; gateway_id }
    let parse xml =
      Some
        {
          route_table_id =
            (Xml.required "RouteTableId"
               (Util.option_bind (Xml.member "RouteTableId" xml) String.parse));
          gateway_id =
            (Xml.required "GatewayId"
               (Util.option_bind (Xml.member "GatewayId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("GatewayId", (String.to_query v.gateway_id)));
           Some
             (Query.Pair ("RouteTableId", (String.to_query v.route_table_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("gateway_id", (String.to_json v.gateway_id));
           Some ("route_table_id", (String.to_json v.route_table_id))])
    let of_json j =
      {
        route_table_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "route_table_id")));
        gateway_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "gateway_id")))
      }
  end
module DescribeVpcAttributeResult =
  struct
    type t =
      {
      vpc_id: String.t option ;
      enable_dns_support: AttributeBooleanValue.t option ;
      enable_dns_hostnames: AttributeBooleanValue.t option }
    let make ?vpc_id  ?enable_dns_support  ?enable_dns_hostnames  () =
      { vpc_id; enable_dns_support; enable_dns_hostnames }
    let parse xml =
      Some
        {
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          enable_dns_support =
            (Util.option_bind (Xml.member "enableDnsSupport" xml)
               AttributeBooleanValue.parse);
          enable_dns_hostnames =
            (Util.option_bind (Xml.member "enableDnsHostnames" xml)
               AttributeBooleanValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enable_dns_hostnames
              (fun f ->
                 Query.Pair
                   ("EnableDnsHostnames", (AttributeBooleanValue.to_query f)));
           Util.option_map v.enable_dns_support
             (fun f ->
                Query.Pair
                  ("EnableDnsSupport", (AttributeBooleanValue.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enable_dns_hostnames
              (fun f ->
                 ("enable_dns_hostnames", (AttributeBooleanValue.to_json f)));
           Util.option_map v.enable_dns_support
             (fun f ->
                ("enable_dns_support", (AttributeBooleanValue.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)))])
    let of_json j =
      {
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        enable_dns_support =
          (Util.option_map (Json.lookup j "enable_dns_support")
             AttributeBooleanValue.of_json);
        enable_dns_hostnames =
          (Util.option_map (Json.lookup j "enable_dns_hostnames")
             AttributeBooleanValue.of_json)
      }
  end
module DescribeNetworkInterfaceAttributeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      network_interface_id: String.t ;
      attribute: NetworkInterfaceAttribute.t option }
    let make ?dry_run  ~network_interface_id  ?attribute  () =
      { dry_run; network_interface_id; attribute }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_interface_id =
            (Xml.required "networkInterfaceId"
               (Util.option_bind (Xml.member "networkInterfaceId" xml)
                  String.parse));
          attribute =
            (Util.option_bind (Xml.member "attribute" xml)
               NetworkInterfaceAttribute.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.attribute
              (fun f ->
                 Query.Pair
                   ("Attribute", (NetworkInterfaceAttribute.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceId",
                  (String.to_query v.network_interface_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.attribute
              (fun f -> ("attribute", (NetworkInterfaceAttribute.to_json f)));
           Some
             ("network_interface_id",
               (String.to_json v.network_interface_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")));
        attribute =
          (Util.option_map (Json.lookup j "attribute")
             NetworkInterfaceAttribute.of_json)
      }
  end
module PurchaseReservedInstancesOfferingRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      reserved_instances_offering_id: String.t ;
      instance_count: Integer.t ;
      limit_price: ReservedInstanceLimitPrice.t option }
    let make ?dry_run  ~reserved_instances_offering_id  ~instance_count 
      ?limit_price  () =
      { dry_run; reserved_instances_offering_id; instance_count; limit_price
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          reserved_instances_offering_id =
            (Xml.required "ReservedInstancesOfferingId"
               (Util.option_bind
                  (Xml.member "ReservedInstancesOfferingId" xml) String.parse));
          instance_count =
            (Xml.required "InstanceCount"
               (Util.option_bind (Xml.member "InstanceCount" xml)
                  Integer.parse));
          limit_price =
            (Util.option_bind (Xml.member "limitPrice" xml)
               ReservedInstanceLimitPrice.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.limit_price
              (fun f ->
                 Query.Pair
                   ("LimitPrice", (ReservedInstanceLimitPrice.to_query f)));
           Some
             (Query.Pair
                ("InstanceCount", (Integer.to_query v.instance_count)));
           Some
             (Query.Pair
                ("ReservedInstancesOfferingId",
                  (String.to_query v.reserved_instances_offering_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.limit_price
              (fun f ->
                 ("limit_price", (ReservedInstanceLimitPrice.to_json f)));
           Some ("instance_count", (Integer.to_json v.instance_count));
           Some
             ("reserved_instances_offering_id",
               (String.to_json v.reserved_instances_offering_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        reserved_instances_offering_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_offering_id")));
        instance_count =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "instance_count")));
        limit_price =
          (Util.option_map (Json.lookup j "limit_price")
             ReservedInstanceLimitPrice.of_json)
      }
  end
module CreateVpcEndpointResult =
  struct
    type t =
      {
      vpc_endpoint: VpcEndpoint.t option ;
      client_token: String.t option }
    let make ?vpc_endpoint  ?client_token  () =
      { vpc_endpoint; client_token }
    let parse xml =
      Some
        {
          vpc_endpoint =
            (Util.option_bind (Xml.member "vpcEndpoint" xml)
               VpcEndpoint.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.vpc_endpoint
             (fun f -> Query.Pair ("VpcEndpoint", (VpcEndpoint.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.vpc_endpoint
             (fun f -> ("vpc_endpoint", (VpcEndpoint.to_json f)))])
    let of_json j =
      {
        vpc_endpoint =
          (Util.option_map (Json.lookup j "vpc_endpoint") VpcEndpoint.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module DescribeMovingAddressesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      public_ips: ValueStringList.t ;
      next_token: String.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option }
    let make ?dry_run  ?(public_ips= [])  ?next_token  ?(filters= []) 
      ?max_results  () =
      { dry_run; public_ips; next_token; filters; max_results }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          public_ips =
            (Util.of_option []
               (Util.option_bind (Xml.member "publicIp" xml)
                  ValueStringList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("PublicIp", (ValueStringList.to_query v.public_ips)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("public_ips", (ValueStringList.to_json v.public_ips));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        public_ips =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "public_ips")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module MoveAddressToVpcRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      public_ip: String.t }
    let make ?dry_run  ~public_ip  () = { dry_run; public_ip }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          public_ip =
            (Xml.required "publicIp"
               (Util.option_bind (Xml.member "publicIp" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("PublicIp", (String.to_query v.public_ip)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("public_ip", (String.to_json v.public_ip));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        public_ip =
          (String.of_json (Util.of_option_exn (Json.lookup j "public_ip")))
      }
  end
module ResetImageAttributeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      image_id: String.t ;
      attribute: ResetImageAttributeName.t }
    let make ?dry_run  ~image_id  ~attribute  () =
      { dry_run; image_id; attribute }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          image_id =
            (Xml.required "ImageId"
               (Util.option_bind (Xml.member "ImageId" xml) String.parse));
          attribute =
            (Xml.required "Attribute"
               (Util.option_bind (Xml.member "Attribute" xml)
                  ResetImageAttributeName.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Attribute",
                   (ResetImageAttributeName.to_query v.attribute)));
           Some (Query.Pair ("ImageId", (String.to_query v.image_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("attribute", (ResetImageAttributeName.to_json v.attribute));
           Some ("image_id", (String.to_json v.image_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        image_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "image_id")));
        attribute =
          (ResetImageAttributeName.of_json
             (Util.of_option_exn (Json.lookup j "attribute")))
      }
  end
module CopySnapshotRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      source_region: String.t ;
      source_snapshot_id: String.t ;
      description: String.t option ;
      destination_region: String.t option ;
      presigned_url: String.t option ;
      encrypted: Boolean.t option ;
      kms_key_id: String.t option }
    let make ?dry_run  ~source_region  ~source_snapshot_id  ?description 
      ?destination_region  ?presigned_url  ?encrypted  ?kms_key_id  () =
      {
        dry_run;
        source_region;
        source_snapshot_id;
        description;
        destination_region;
        presigned_url;
        encrypted;
        kms_key_id
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          source_region =
            (Xml.required "SourceRegion"
               (Util.option_bind (Xml.member "SourceRegion" xml) String.parse));
          source_snapshot_id =
            (Xml.required "SourceSnapshotId"
               (Util.option_bind (Xml.member "SourceSnapshotId" xml)
                  String.parse));
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          destination_region =
            (Util.option_bind (Xml.member "destinationRegion" xml)
               String.parse);
          presigned_url =
            (Util.option_bind (Xml.member "presignedUrl" xml) String.parse);
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.presigned_url
             (fun f -> Query.Pair ("PresignedUrl", (String.to_query f)));
           Util.option_map v.destination_region
             (fun f -> Query.Pair ("DestinationRegion", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some
             (Query.Pair
                ("SourceSnapshotId", (String.to_query v.source_snapshot_id)));
           Some
             (Query.Pair ("SourceRegion", (String.to_query v.source_region)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.presigned_url
             (fun f -> ("presigned_url", (String.to_json f)));
           Util.option_map v.destination_region
             (fun f -> ("destination_region", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some ("source_snapshot_id", (String.to_json v.source_snapshot_id));
           Some ("source_region", (String.to_json v.source_region));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        source_region =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "source_region")));
        source_snapshot_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "source_snapshot_id")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        destination_region =
          (Util.option_map (Json.lookup j "destination_region")
             String.of_json);
        presigned_url =
          (Util.option_map (Json.lookup j "presigned_url") String.of_json);
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json)
      }
  end
module CreateDhcpOptionsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      dhcp_configurations: NewDhcpConfigurationList.t }
    let make ?dry_run  ~dhcp_configurations  () =
      { dry_run; dhcp_configurations }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          dhcp_configurations =
            (Xml.required "dhcpConfiguration"
               (Util.option_bind (Xml.member "dhcpConfiguration" xml)
                  NewDhcpConfigurationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("DhcpConfiguration",
                   (NewDhcpConfigurationList.to_query v.dhcp_configurations)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("dhcp_configurations",
                (NewDhcpConfigurationList.to_json v.dhcp_configurations));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        dhcp_configurations =
          (NewDhcpConfigurationList.of_json
             (Util.of_option_exn (Json.lookup j "dhcp_configurations")))
      }
  end
module AttachNetworkInterfaceRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      network_interface_id: String.t ;
      instance_id: String.t ;
      device_index: Integer.t }
    let make ?dry_run  ~network_interface_id  ~instance_id  ~device_index  ()
      = { dry_run; network_interface_id; instance_id; device_index }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_interface_id =
            (Xml.required "networkInterfaceId"
               (Util.option_bind (Xml.member "networkInterfaceId" xml)
                  String.parse));
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          device_index =
            (Xml.required "deviceIndex"
               (Util.option_bind (Xml.member "deviceIndex" xml) Integer.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("DeviceIndex", (Integer.to_query v.device_index)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Some
             (Query.Pair
                ("NetworkInterfaceId",
                  (String.to_query v.network_interface_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("device_index", (Integer.to_json v.device_index));
           Some ("instance_id", (String.to_json v.instance_id));
           Some
             ("network_interface_id",
               (String.to_json v.network_interface_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")));
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        device_index =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "device_index")))
      }
  end