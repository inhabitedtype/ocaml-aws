open Aws.BaseTypes

type calendar = CalendarLib.Calendar.t

module UserIdGroupPair = struct
  type t =
    { description : String.t option
    ; group_id : String.t option
    ; group_name : String.t option
    ; peering_status : String.t option
    ; user_id : String.t option
    ; vpc_id : String.t option
    ; vpc_peering_connection_id : String.t option
    }

  let make
      ?description
      ?group_id
      ?group_name
      ?peering_status
      ?user_id
      ?vpc_id
      ?vpc_peering_connection_id
      () =
    { description
    ; group_id
    ; group_name
    ; peering_status
    ; user_id
    ; vpc_id
    ; vpc_peering_connection_id
    }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; group_id = Aws.Util.option_bind (Aws.Xml.member "groupId" xml) String.parse
      ; group_name = Aws.Util.option_bind (Aws.Xml.member "groupName" xml) String.parse
      ; peering_status =
          Aws.Util.option_bind (Aws.Xml.member "peeringStatus" xml) String.parse
      ; user_id = Aws.Util.option_bind (Aws.Xml.member "userId" xml) String.parse
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse
      ; vpc_peering_connection_id =
          Aws.Util.option_bind (Aws.Xml.member "vpcPeeringConnectionId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_peering_connection_id (fun f ->
               Aws.Query.Pair ("VpcPeeringConnectionId", String.to_query f))
         ; Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Aws.Util.option_map v.user_id (fun f ->
               Aws.Query.Pair ("UserId", String.to_query f))
         ; Aws.Util.option_map v.peering_status (fun f ->
               Aws.Query.Pair ("PeeringStatus", String.to_query f))
         ; Aws.Util.option_map v.group_name (fun f ->
               Aws.Query.Pair ("GroupName", String.to_query f))
         ; Aws.Util.option_map v.group_id (fun f ->
               Aws.Query.Pair ("GroupId", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_peering_connection_id (fun f ->
               "vpcPeeringConnectionId", String.to_json f)
         ; Aws.Util.option_map v.vpc_id (fun f -> "vpcId", String.to_json f)
         ; Aws.Util.option_map v.user_id (fun f -> "userId", String.to_json f)
         ; Aws.Util.option_map v.peering_status (fun f ->
               "peeringStatus", String.to_json f)
         ; Aws.Util.option_map v.group_name (fun f -> "groupName", String.to_json f)
         ; Aws.Util.option_map v.group_id (fun f -> "groupId", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; group_id = Aws.Util.option_map (Aws.Json.lookup j "groupId") String.of_json
    ; group_name = Aws.Util.option_map (Aws.Json.lookup j "groupName") String.of_json
    ; peering_status =
        Aws.Util.option_map (Aws.Json.lookup j "peeringStatus") String.of_json
    ; user_id = Aws.Util.option_map (Aws.Json.lookup j "userId") String.of_json
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "vpcId") String.of_json
    ; vpc_peering_connection_id =
        Aws.Util.option_map (Aws.Json.lookup j "vpcPeeringConnectionId") String.of_json
    }
end

module UserIdGroupPairList = struct
  type t = UserIdGroupPair.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map UserIdGroupPair.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list UserIdGroupPair.to_query v

  let to_json v = `List (List.map UserIdGroupPair.to_json v)

  let of_json j = Aws.Json.to_list UserIdGroupPair.of_json j
end

module PrefixListId = struct
  type t =
    { description : String.t option
    ; prefix_list_id : String.t option
    }

  let make ?description ?prefix_list_id () = { description; prefix_list_id }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; prefix_list_id =
          Aws.Util.option_bind (Aws.Xml.member "prefixListId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.prefix_list_id (fun f ->
               Aws.Query.Pair ("PrefixListId", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.prefix_list_id (fun f ->
               "prefixListId", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; prefix_list_id =
        Aws.Util.option_map (Aws.Json.lookup j "prefixListId") String.of_json
    }
end

module PrefixListIdList = struct
  type t = PrefixListId.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map PrefixListId.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list PrefixListId.to_query v

  let to_json v = `List (List.map PrefixListId.to_json v)

  let of_json j = Aws.Json.to_list PrefixListId.of_json j
end

module Ipv6Range = struct
  type t =
    { cidr_ipv6 : String.t option
    ; description : String.t option
    }

  let make ?cidr_ipv6 ?description () = { cidr_ipv6; description }

  let parse xml =
    Some
      { cidr_ipv6 = Aws.Util.option_bind (Aws.Xml.member "cidrIpv6" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.cidr_ipv6 (fun f ->
               Aws.Query.Pair ("CidrIpv6", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Aws.Util.option_map v.cidr_ipv6 (fun f -> "cidrIpv6", String.to_json f)
         ])

  let of_json j =
    { cidr_ipv6 = Aws.Util.option_map (Aws.Json.lookup j "cidrIpv6") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    }
end

module Ipv6RangeList = struct
  type t = Ipv6Range.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Ipv6Range.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Ipv6Range.to_query v

  let to_json v = `List (List.map Ipv6Range.to_json v)

  let of_json j = Aws.Json.to_list Ipv6Range.of_json j
end

module IpRange = struct
  type t =
    { cidr_ip : String.t
    ; description : String.t option
    }

  let make ~cidr_ip ?description () = { cidr_ip; description }

  let parse xml =
    Some
      { cidr_ip =
          Aws.Xml.required
            "cidrIp"
            (Aws.Util.option_bind (Aws.Xml.member "cidrIp" xml) String.parse)
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Some (Aws.Query.Pair ("CidrIp", String.to_query v.cidr_ip))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Some ("cidrIp", String.to_json v.cidr_ip)
         ])

  let of_json j =
    { cidr_ip = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "cidrIp"))
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    }
end

module IpRangeList = struct
  type t = IpRange.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map IpRange.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list IpRange.to_query v

  let to_json v = `List (List.map IpRange.to_json v)

  let of_json j = Aws.Json.to_list IpRange.of_json j
end

module IpPermission = struct
  type t =
    { from_port : Integer.t option
    ; ip_protocol : String.t
    ; ip_ranges : IpRangeList.t
    ; ipv6_ranges : Ipv6RangeList.t
    ; prefix_list_ids : PrefixListIdList.t
    ; to_port : Integer.t option
    ; user_id_group_pairs : UserIdGroupPairList.t
    }

  let make
      ?from_port
      ~ip_protocol
      ?(ip_ranges = [])
      ?(ipv6_ranges = [])
      ?(prefix_list_ids = [])
      ?to_port
      ?(user_id_group_pairs = [])
      () =
    { from_port
    ; ip_protocol
    ; ip_ranges
    ; ipv6_ranges
    ; prefix_list_ids
    ; to_port
    ; user_id_group_pairs
    }

  let parse xml =
    Some
      { from_port = Aws.Util.option_bind (Aws.Xml.member "fromPort" xml) Integer.parse
      ; ip_protocol =
          Aws.Xml.required
            "ipProtocol"
            (Aws.Util.option_bind (Aws.Xml.member "ipProtocol" xml) String.parse)
      ; ip_ranges =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "ipRanges" xml) IpRangeList.parse)
      ; ipv6_ranges =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "ipv6Ranges" xml) Ipv6RangeList.parse)
      ; prefix_list_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "prefixListIds" xml)
               PrefixListIdList.parse)
      ; to_port = Aws.Util.option_bind (Aws.Xml.member "toPort" xml) Integer.parse
      ; user_id_group_pairs =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "groups" xml) UserIdGroupPairList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("Groups", UserIdGroupPairList.to_query v.user_id_group_pairs))
         ; Aws.Util.option_map v.to_port (fun f ->
               Aws.Query.Pair ("ToPort", Integer.to_query f))
         ; Some
             (Aws.Query.Pair ("PrefixListIds", PrefixListIdList.to_query v.prefix_list_ids))
         ; Some (Aws.Query.Pair ("Ipv6Ranges", Ipv6RangeList.to_query v.ipv6_ranges))
         ; Some (Aws.Query.Pair ("IpRanges", IpRangeList.to_query v.ip_ranges))
         ; Some (Aws.Query.Pair ("IpProtocol", String.to_query v.ip_protocol))
         ; Aws.Util.option_map v.from_port (fun f ->
               Aws.Query.Pair ("FromPort", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("groups", UserIdGroupPairList.to_json v.user_id_group_pairs)
         ; Aws.Util.option_map v.to_port (fun f -> "toPort", Integer.to_json f)
         ; Some ("prefixListIds", PrefixListIdList.to_json v.prefix_list_ids)
         ; Some ("ipv6Ranges", Ipv6RangeList.to_json v.ipv6_ranges)
         ; Some ("ipRanges", IpRangeList.to_json v.ip_ranges)
         ; Some ("ipProtocol", String.to_json v.ip_protocol)
         ; Aws.Util.option_map v.from_port (fun f -> "fromPort", Integer.to_json f)
         ])

  let of_json j =
    { from_port = Aws.Util.option_map (Aws.Json.lookup j "fromPort") Integer.of_json
    ; ip_protocol =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ipProtocol"))
    ; ip_ranges =
        IpRangeList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ipRanges"))
    ; ipv6_ranges =
        Ipv6RangeList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ipv6Ranges"))
    ; prefix_list_ids =
        PrefixListIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "prefixListIds"))
    ; to_port = Aws.Util.option_map (Aws.Json.lookup j "toPort") Integer.of_json
    ; user_id_group_pairs =
        UserIdGroupPairList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "groups"))
    }
end

module IpPermissionList = struct
  type t = IpPermission.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map IpPermission.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list IpPermission.to_query v

  let to_json v = `List (List.map IpPermission.to_json v)

  let of_json j = Aws.Json.to_list IpPermission.of_json j
end

module UpdateSecurityGroupRuleDescriptionsIngressRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; group_id : String.t option
    ; group_name : String.t option
    ; ip_permissions : IpPermissionList.t
    }

  let make ?dry_run ?group_id ?group_name ~ip_permissions () =
    { dry_run; group_id; group_name; ip_permissions }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; group_id = Aws.Util.option_bind (Aws.Xml.member "GroupId" xml) String.parse
      ; group_name = Aws.Util.option_bind (Aws.Xml.member "GroupName" xml) String.parse
      ; ip_permissions =
          Aws.Xml.required
            "IpPermissions"
            (Aws.Util.option_bind
               (Aws.Xml.member "IpPermissions" xml)
               IpPermissionList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("IpPermissions", IpPermissionList.to_query v.ip_permissions))
         ; Aws.Util.option_map v.group_name (fun f ->
               Aws.Query.Pair ("GroupName", String.to_query f))
         ; Aws.Util.option_map v.group_id (fun f ->
               Aws.Query.Pair ("GroupId", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("IpPermissions", IpPermissionList.to_json v.ip_permissions)
         ; Aws.Util.option_map v.group_name (fun f -> "GroupName", String.to_json f)
         ; Aws.Util.option_map v.group_id (fun f -> "GroupId", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; group_id = Aws.Util.option_map (Aws.Json.lookup j "GroupId") String.of_json
    ; group_name = Aws.Util.option_map (Aws.Json.lookup j "GroupName") String.of_json
    ; ip_permissions =
        IpPermissionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "IpPermissions"))
    }
end

module TransitGatewayAttachmentState = struct
  type t =
    | Initiating
    | InitiatingRequest
    | PendingAcceptance
    | RollingBack
    | Pending
    | Available
    | Modifying
    | Deleting
    | Deleted
    | Failed
    | Rejected
    | Rejecting
    | Failing

  let str_to_t =
    [ "failing", Failing
    ; "rejecting", Rejecting
    ; "rejected", Rejected
    ; "failed", Failed
    ; "deleted", Deleted
    ; "deleting", Deleting
    ; "modifying", Modifying
    ; "available", Available
    ; "pending", Pending
    ; "rollingBack", RollingBack
    ; "pendingAcceptance", PendingAcceptance
    ; "initiatingRequest", InitiatingRequest
    ; "initiating", Initiating
    ]

  let t_to_str =
    [ Failing, "failing"
    ; Rejecting, "rejecting"
    ; Rejected, "rejected"
    ; Failed, "failed"
    ; Deleted, "deleted"
    ; Deleting, "deleting"
    ; Modifying, "modifying"
    ; Available, "available"
    ; Pending, "pending"
    ; RollingBack, "rollingBack"
    ; PendingAcceptance, "pendingAcceptance"
    ; InitiatingRequest, "initiatingRequest"
    ; Initiating, "initiating"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DeleteNetworkInterfacePermissionRequest = struct
  type t =
    { network_interface_permission_id : String.t
    ; force : Boolean.t option
    ; dry_run : Boolean.t option
    }

  let make ~network_interface_permission_id ?force ?dry_run () =
    { network_interface_permission_id; force; dry_run }

  let parse xml =
    Some
      { network_interface_permission_id =
          Aws.Xml.required
            "NetworkInterfacePermissionId"
            (Aws.Util.option_bind
               (Aws.Xml.member "NetworkInterfacePermissionId" xml)
               String.parse)
      ; force = Aws.Util.option_bind (Aws.Xml.member "Force" xml) Boolean.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.force (fun f ->
               Aws.Query.Pair ("Force", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "NetworkInterfacePermissionId"
                , String.to_query v.network_interface_permission_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.force (fun f -> "Force", Boolean.to_json f)
         ; Some
             ( "NetworkInterfacePermissionId"
             , String.to_json v.network_interface_permission_id )
         ])

  let of_json j =
    { network_interface_permission_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "NetworkInterfacePermissionId"))
    ; force = Aws.Util.option_map (Aws.Json.lookup j "Force") Boolean.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module AttachNetworkInterfaceRequest = struct
  type t =
    { device_index : Integer.t
    ; dry_run : Boolean.t option
    ; instance_id : String.t
    ; network_interface_id : String.t
    ; network_card_index : Integer.t option
    }

  let make
      ~device_index
      ?dry_run
      ~instance_id
      ~network_interface_id
      ?network_card_index
      () =
    { device_index; dry_run; instance_id; network_interface_id; network_card_index }

  let parse xml =
    Some
      { device_index =
          Aws.Xml.required
            "deviceIndex"
            (Aws.Util.option_bind (Aws.Xml.member "deviceIndex" xml) Integer.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; instance_id =
          Aws.Xml.required
            "instanceId"
            (Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse)
      ; network_interface_id =
          Aws.Xml.required
            "networkInterfaceId"
            (Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse)
      ; network_card_index =
          Aws.Util.option_bind (Aws.Xml.member "NetworkCardIndex" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.network_card_index (fun f ->
               Aws.Query.Pair ("NetworkCardIndex", Integer.to_query f))
         ; Some
             (Aws.Query.Pair ("NetworkInterfaceId", String.to_query v.network_interface_id))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("DeviceIndex", Integer.to_query v.device_index))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.network_card_index (fun f ->
               "NetworkCardIndex", Integer.to_json f)
         ; Some ("networkInterfaceId", String.to_json v.network_interface_id)
         ; Some ("instanceId", String.to_json v.instance_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("deviceIndex", Integer.to_json v.device_index)
         ])

  let of_json j =
    { device_index =
        Integer.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "deviceIndex"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceId"))
    ; network_interface_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "networkInterfaceId"))
    ; network_card_index =
        Aws.Util.option_map (Aws.Json.lookup j "NetworkCardIndex") Integer.of_json
    }
end

module RouteState = struct
  type t =
    | Active
    | Blackhole

  let str_to_t = [ "blackhole", Blackhole; "active", Active ]

  let t_to_str = [ Blackhole, "blackhole"; Active, "active" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module RouteOrigin = struct
  type t =
    | CreateRouteTable
    | CreateRoute
    | EnableVgwRoutePropagation

  let str_to_t =
    [ "EnableVgwRoutePropagation", EnableVgwRoutePropagation
    ; "CreateRoute", CreateRoute
    ; "CreateRouteTable", CreateRouteTable
    ]

  let t_to_str =
    [ EnableVgwRoutePropagation, "EnableVgwRoutePropagation"
    ; CreateRoute, "CreateRoute"
    ; CreateRouteTable, "CreateRouteTable"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module Route = struct
  type t =
    { destination_cidr_block : String.t option
    ; destination_ipv6_cidr_block : String.t option
    ; destination_prefix_list_id : String.t option
    ; egress_only_internet_gateway_id : String.t option
    ; gateway_id : String.t option
    ; instance_id : String.t option
    ; instance_owner_id : String.t option
    ; nat_gateway_id : String.t option
    ; transit_gateway_id : String.t option
    ; local_gateway_id : String.t option
    ; carrier_gateway_id : String.t option
    ; network_interface_id : String.t option
    ; origin : RouteOrigin.t option
    ; state : RouteState.t option
    ; vpc_peering_connection_id : String.t option
    }

  let make
      ?destination_cidr_block
      ?destination_ipv6_cidr_block
      ?destination_prefix_list_id
      ?egress_only_internet_gateway_id
      ?gateway_id
      ?instance_id
      ?instance_owner_id
      ?nat_gateway_id
      ?transit_gateway_id
      ?local_gateway_id
      ?carrier_gateway_id
      ?network_interface_id
      ?origin
      ?state
      ?vpc_peering_connection_id
      () =
    { destination_cidr_block
    ; destination_ipv6_cidr_block
    ; destination_prefix_list_id
    ; egress_only_internet_gateway_id
    ; gateway_id
    ; instance_id
    ; instance_owner_id
    ; nat_gateway_id
    ; transit_gateway_id
    ; local_gateway_id
    ; carrier_gateway_id
    ; network_interface_id
    ; origin
    ; state
    ; vpc_peering_connection_id
    }

  let parse xml =
    Some
      { destination_cidr_block =
          Aws.Util.option_bind (Aws.Xml.member "destinationCidrBlock" xml) String.parse
      ; destination_ipv6_cidr_block =
          Aws.Util.option_bind
            (Aws.Xml.member "destinationIpv6CidrBlock" xml)
            String.parse
      ; destination_prefix_list_id =
          Aws.Util.option_bind (Aws.Xml.member "destinationPrefixListId" xml) String.parse
      ; egress_only_internet_gateway_id =
          Aws.Util.option_bind
            (Aws.Xml.member "egressOnlyInternetGatewayId" xml)
            String.parse
      ; gateway_id = Aws.Util.option_bind (Aws.Xml.member "gatewayId" xml) String.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      ; instance_owner_id =
          Aws.Util.option_bind (Aws.Xml.member "instanceOwnerId" xml) String.parse
      ; nat_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "natGatewayId" xml) String.parse
      ; transit_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "transitGatewayId" xml) String.parse
      ; local_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "localGatewayId" xml) String.parse
      ; carrier_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "carrierGatewayId" xml) String.parse
      ; network_interface_id =
          Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse
      ; origin = Aws.Util.option_bind (Aws.Xml.member "origin" xml) RouteOrigin.parse
      ; state = Aws.Util.option_bind (Aws.Xml.member "state" xml) RouteState.parse
      ; vpc_peering_connection_id =
          Aws.Util.option_bind (Aws.Xml.member "vpcPeeringConnectionId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_peering_connection_id (fun f ->
               Aws.Query.Pair ("VpcPeeringConnectionId", String.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", RouteState.to_query f))
         ; Aws.Util.option_map v.origin (fun f ->
               Aws.Query.Pair ("Origin", RouteOrigin.to_query f))
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               Aws.Query.Pair ("NetworkInterfaceId", String.to_query f))
         ; Aws.Util.option_map v.carrier_gateway_id (fun f ->
               Aws.Query.Pair ("CarrierGatewayId", String.to_query f))
         ; Aws.Util.option_map v.local_gateway_id (fun f ->
               Aws.Query.Pair ("LocalGatewayId", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_id (fun f ->
               Aws.Query.Pair ("TransitGatewayId", String.to_query f))
         ; Aws.Util.option_map v.nat_gateway_id (fun f ->
               Aws.Query.Pair ("NatGatewayId", String.to_query f))
         ; Aws.Util.option_map v.instance_owner_id (fun f ->
               Aws.Query.Pair ("InstanceOwnerId", String.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.gateway_id (fun f ->
               Aws.Query.Pair ("GatewayId", String.to_query f))
         ; Aws.Util.option_map v.egress_only_internet_gateway_id (fun f ->
               Aws.Query.Pair ("EgressOnlyInternetGatewayId", String.to_query f))
         ; Aws.Util.option_map v.destination_prefix_list_id (fun f ->
               Aws.Query.Pair ("DestinationPrefixListId", String.to_query f))
         ; Aws.Util.option_map v.destination_ipv6_cidr_block (fun f ->
               Aws.Query.Pair ("DestinationIpv6CidrBlock", String.to_query f))
         ; Aws.Util.option_map v.destination_cidr_block (fun f ->
               Aws.Query.Pair ("DestinationCidrBlock", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_peering_connection_id (fun f ->
               "vpcPeeringConnectionId", String.to_json f)
         ; Aws.Util.option_map v.state (fun f -> "state", RouteState.to_json f)
         ; Aws.Util.option_map v.origin (fun f -> "origin", RouteOrigin.to_json f)
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               "networkInterfaceId", String.to_json f)
         ; Aws.Util.option_map v.carrier_gateway_id (fun f ->
               "carrierGatewayId", String.to_json f)
         ; Aws.Util.option_map v.local_gateway_id (fun f ->
               "localGatewayId", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_id (fun f ->
               "transitGatewayId", String.to_json f)
         ; Aws.Util.option_map v.nat_gateway_id (fun f ->
               "natGatewayId", String.to_json f)
         ; Aws.Util.option_map v.instance_owner_id (fun f ->
               "instanceOwnerId", String.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ; Aws.Util.option_map v.gateway_id (fun f -> "gatewayId", String.to_json f)
         ; Aws.Util.option_map v.egress_only_internet_gateway_id (fun f ->
               "egressOnlyInternetGatewayId", String.to_json f)
         ; Aws.Util.option_map v.destination_prefix_list_id (fun f ->
               "destinationPrefixListId", String.to_json f)
         ; Aws.Util.option_map v.destination_ipv6_cidr_block (fun f ->
               "destinationIpv6CidrBlock", String.to_json f)
         ; Aws.Util.option_map v.destination_cidr_block (fun f ->
               "destinationCidrBlock", String.to_json f)
         ])

  let of_json j =
    { destination_cidr_block =
        Aws.Util.option_map (Aws.Json.lookup j "destinationCidrBlock") String.of_json
    ; destination_ipv6_cidr_block =
        Aws.Util.option_map (Aws.Json.lookup j "destinationIpv6CidrBlock") String.of_json
    ; destination_prefix_list_id =
        Aws.Util.option_map (Aws.Json.lookup j "destinationPrefixListId") String.of_json
    ; egress_only_internet_gateway_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "egressOnlyInternetGatewayId")
          String.of_json
    ; gateway_id = Aws.Util.option_map (Aws.Json.lookup j "gatewayId") String.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    ; instance_owner_id =
        Aws.Util.option_map (Aws.Json.lookup j "instanceOwnerId") String.of_json
    ; nat_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "natGatewayId") String.of_json
    ; transit_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "transitGatewayId") String.of_json
    ; local_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "localGatewayId") String.of_json
    ; carrier_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "carrierGatewayId") String.of_json
    ; network_interface_id =
        Aws.Util.option_map (Aws.Json.lookup j "networkInterfaceId") String.of_json
    ; origin = Aws.Util.option_map (Aws.Json.lookup j "origin") RouteOrigin.of_json
    ; state = Aws.Util.option_map (Aws.Json.lookup j "state") RouteState.of_json
    ; vpc_peering_connection_id =
        Aws.Util.option_map (Aws.Json.lookup j "vpcPeeringConnectionId") String.of_json
    }
end

module RouteList = struct
  type t = Route.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map Route.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Route.to_query v

  let to_json v = `List (List.map Route.to_json v)

  let of_json j = Aws.Json.to_list Route.of_json j
end

module Tag = struct
  type t =
    { key : String.t
    ; value : String.t
    }

  let make ~key ~value () = { key; value }

  let parse xml =
    Some
      { key =
          Aws.Xml.required
            "key"
            (Aws.Util.option_bind (Aws.Xml.member "key" xml) String.parse)
      ; value =
          Aws.Xml.required
            "value"
            (Aws.Util.option_bind (Aws.Xml.member "value" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Value", String.to_query v.value))
         ; Some (Aws.Query.Pair ("Key", String.to_query v.key))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("value", String.to_json v.value); Some ("key", String.to_json v.key) ])

  let of_json j =
    { key = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "key"))
    ; value = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "value"))
    }
end

module TagList = struct
  type t = Tag.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map Tag.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Tag.to_query v

  let to_json v = `List (List.map Tag.to_json v)

  let of_json j = Aws.Json.to_list Tag.of_json j
end

module UserBucketDetails = struct
  type t =
    { s3_bucket : String.t option
    ; s3_key : String.t option
    }

  let make ?s3_bucket ?s3_key () = { s3_bucket; s3_key }

  let parse xml =
    Some
      { s3_bucket = Aws.Util.option_bind (Aws.Xml.member "s3Bucket" xml) String.parse
      ; s3_key = Aws.Util.option_bind (Aws.Xml.member "s3Key" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.s3_key (fun f ->
               Aws.Query.Pair ("S3Key", String.to_query f))
         ; Aws.Util.option_map v.s3_bucket (fun f ->
               Aws.Query.Pair ("S3Bucket", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.s3_key (fun f -> "s3Key", String.to_json f)
         ; Aws.Util.option_map v.s3_bucket (fun f -> "s3Bucket", String.to_json f)
         ])

  let of_json j =
    { s3_bucket = Aws.Util.option_map (Aws.Json.lookup j "s3Bucket") String.of_json
    ; s3_key = Aws.Util.option_map (Aws.Json.lookup j "s3Key") String.of_json
    }
end

module SnapshotDetail = struct
  type t =
    { description : String.t option
    ; device_name : String.t option
    ; disk_image_size : Double.t option
    ; format : String.t option
    ; progress : String.t option
    ; snapshot_id : String.t option
    ; status : String.t option
    ; status_message : String.t option
    ; url : String.t option
    ; user_bucket : UserBucketDetails.t option
    }

  let make
      ?description
      ?device_name
      ?disk_image_size
      ?format
      ?progress
      ?snapshot_id
      ?status
      ?status_message
      ?url
      ?user_bucket
      () =
    { description
    ; device_name
    ; disk_image_size
    ; format
    ; progress
    ; snapshot_id
    ; status
    ; status_message
    ; url
    ; user_bucket
    }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; device_name = Aws.Util.option_bind (Aws.Xml.member "deviceName" xml) String.parse
      ; disk_image_size =
          Aws.Util.option_bind (Aws.Xml.member "diskImageSize" xml) Double.parse
      ; format = Aws.Util.option_bind (Aws.Xml.member "format" xml) String.parse
      ; progress = Aws.Util.option_bind (Aws.Xml.member "progress" xml) String.parse
      ; snapshot_id = Aws.Util.option_bind (Aws.Xml.member "snapshotId" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "status" xml) String.parse
      ; status_message =
          Aws.Util.option_bind (Aws.Xml.member "statusMessage" xml) String.parse
      ; url = Aws.Util.option_bind (Aws.Xml.member "url" xml) String.parse
      ; user_bucket =
          Aws.Util.option_bind (Aws.Xml.member "userBucket" xml) UserBucketDetails.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.user_bucket (fun f ->
               Aws.Query.Pair ("UserBucket", UserBucketDetails.to_query f))
         ; Aws.Util.option_map v.url (fun f -> Aws.Query.Pair ("Url", String.to_query f))
         ; Aws.Util.option_map v.status_message (fun f ->
               Aws.Query.Pair ("StatusMessage", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.snapshot_id (fun f ->
               Aws.Query.Pair ("SnapshotId", String.to_query f))
         ; Aws.Util.option_map v.progress (fun f ->
               Aws.Query.Pair ("Progress", String.to_query f))
         ; Aws.Util.option_map v.format (fun f ->
               Aws.Query.Pair ("Format", String.to_query f))
         ; Aws.Util.option_map v.disk_image_size (fun f ->
               Aws.Query.Pair ("DiskImageSize", Double.to_query f))
         ; Aws.Util.option_map v.device_name (fun f ->
               Aws.Query.Pair ("DeviceName", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.user_bucket (fun f ->
               "userBucket", UserBucketDetails.to_json f)
         ; Aws.Util.option_map v.url (fun f -> "url", String.to_json f)
         ; Aws.Util.option_map v.status_message (fun f ->
               "statusMessage", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "status", String.to_json f)
         ; Aws.Util.option_map v.snapshot_id (fun f -> "snapshotId", String.to_json f)
         ; Aws.Util.option_map v.progress (fun f -> "progress", String.to_json f)
         ; Aws.Util.option_map v.format (fun f -> "format", String.to_json f)
         ; Aws.Util.option_map v.disk_image_size (fun f ->
               "diskImageSize", Double.to_json f)
         ; Aws.Util.option_map v.device_name (fun f -> "deviceName", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; device_name = Aws.Util.option_map (Aws.Json.lookup j "deviceName") String.of_json
    ; disk_image_size =
        Aws.Util.option_map (Aws.Json.lookup j "diskImageSize") Double.of_json
    ; format = Aws.Util.option_map (Aws.Json.lookup j "format") String.of_json
    ; progress = Aws.Util.option_map (Aws.Json.lookup j "progress") String.of_json
    ; snapshot_id = Aws.Util.option_map (Aws.Json.lookup j "snapshotId") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "status") String.of_json
    ; status_message =
        Aws.Util.option_map (Aws.Json.lookup j "statusMessage") String.of_json
    ; url = Aws.Util.option_map (Aws.Json.lookup j "url") String.of_json
    ; user_bucket =
        Aws.Util.option_map (Aws.Json.lookup j "userBucket") UserBucketDetails.of_json
    }
end

module SnapshotDetailList = struct
  type t = SnapshotDetail.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map SnapshotDetail.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list SnapshotDetail.to_query v

  let to_json v = `List (List.map SnapshotDetail.to_json v)

  let of_json j = Aws.Json.to_list SnapshotDetail.of_json j
end

module ImportImageLicenseConfigurationResponse = struct
  type t = { license_configuration_arn : String.t option }

  let make ?license_configuration_arn () = { license_configuration_arn }

  let parse xml =
    Some
      { license_configuration_arn =
          Aws.Util.option_bind (Aws.Xml.member "licenseConfigurationArn" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.license_configuration_arn (fun f ->
               Aws.Query.Pair ("LicenseConfigurationArn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.license_configuration_arn (fun f ->
               "licenseConfigurationArn", String.to_json f)
         ])

  let of_json j =
    { license_configuration_arn =
        Aws.Util.option_map (Aws.Json.lookup j "licenseConfigurationArn") String.of_json
    }
end

module ImportImageLicenseSpecificationListResponse = struct
  type t = ImportImageLicenseConfigurationResponse.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         ImportImageLicenseConfigurationResponse.parse
         (Aws.Xml.members "item" xml))

  let to_query v =
    Aws.Query.to_query_list ImportImageLicenseConfigurationResponse.to_query v

  let to_json v = `List (List.map ImportImageLicenseConfigurationResponse.to_json v)

  let of_json j = Aws.Json.to_list ImportImageLicenseConfigurationResponse.of_json j
end

module ImportImageTask = struct
  type t =
    { architecture : String.t option
    ; description : String.t option
    ; encrypted : Boolean.t option
    ; hypervisor : String.t option
    ; image_id : String.t option
    ; import_task_id : String.t option
    ; kms_key_id : String.t option
    ; license_type : String.t option
    ; platform : String.t option
    ; progress : String.t option
    ; snapshot_details : SnapshotDetailList.t
    ; status : String.t option
    ; status_message : String.t option
    ; tags : TagList.t
    ; license_specifications : ImportImageLicenseSpecificationListResponse.t
    }

  let make
      ?architecture
      ?description
      ?encrypted
      ?hypervisor
      ?image_id
      ?import_task_id
      ?kms_key_id
      ?license_type
      ?platform
      ?progress
      ?(snapshot_details = [])
      ?status
      ?status_message
      ?(tags = [])
      ?(license_specifications = [])
      () =
    { architecture
    ; description
    ; encrypted
    ; hypervisor
    ; image_id
    ; import_task_id
    ; kms_key_id
    ; license_type
    ; platform
    ; progress
    ; snapshot_details
    ; status
    ; status_message
    ; tags
    ; license_specifications
    }

  let parse xml =
    Some
      { architecture =
          Aws.Util.option_bind (Aws.Xml.member "architecture" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; encrypted = Aws.Util.option_bind (Aws.Xml.member "encrypted" xml) Boolean.parse
      ; hypervisor = Aws.Util.option_bind (Aws.Xml.member "hypervisor" xml) String.parse
      ; image_id = Aws.Util.option_bind (Aws.Xml.member "imageId" xml) String.parse
      ; import_task_id =
          Aws.Util.option_bind (Aws.Xml.member "importTaskId" xml) String.parse
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "kmsKeyId" xml) String.parse
      ; license_type =
          Aws.Util.option_bind (Aws.Xml.member "licenseType" xml) String.parse
      ; platform = Aws.Util.option_bind (Aws.Xml.member "platform" xml) String.parse
      ; progress = Aws.Util.option_bind (Aws.Xml.member "progress" xml) String.parse
      ; snapshot_details =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "snapshotDetailSet" xml)
               SnapshotDetailList.parse)
      ; status = Aws.Util.option_bind (Aws.Xml.member "status" xml) String.parse
      ; status_message =
          Aws.Util.option_bind (Aws.Xml.member "statusMessage" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      ; license_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "licenseSpecifications" xml)
               ImportImageLicenseSpecificationListResponse.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "LicenseSpecifications"
                , ImportImageLicenseSpecificationListResponse.to_query
                    v.license_specifications ))
         ; Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.status_message (fun f ->
               Aws.Query.Pair ("StatusMessage", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("SnapshotDetailSet", SnapshotDetailList.to_query v.snapshot_details))
         ; Aws.Util.option_map v.progress (fun f ->
               Aws.Query.Pair ("Progress", String.to_query f))
         ; Aws.Util.option_map v.platform (fun f ->
               Aws.Query.Pair ("Platform", String.to_query f))
         ; Aws.Util.option_map v.license_type (fun f ->
               Aws.Query.Pair ("LicenseType", String.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Aws.Util.option_map v.import_task_id (fun f ->
               Aws.Query.Pair ("ImportTaskId", String.to_query f))
         ; Aws.Util.option_map v.image_id (fun f ->
               Aws.Query.Pair ("ImageId", String.to_query f))
         ; Aws.Util.option_map v.hypervisor (fun f ->
               Aws.Query.Pair ("Hypervisor", String.to_query f))
         ; Aws.Util.option_map v.encrypted (fun f ->
               Aws.Query.Pair ("Encrypted", Boolean.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.architecture (fun f ->
               Aws.Query.Pair ("Architecture", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "licenseSpecifications"
             , ImportImageLicenseSpecificationListResponse.to_json
                 v.license_specifications )
         ; Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.status_message (fun f ->
               "statusMessage", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "status", String.to_json f)
         ; Some ("snapshotDetailSet", SnapshotDetailList.to_json v.snapshot_details)
         ; Aws.Util.option_map v.progress (fun f -> "progress", String.to_json f)
         ; Aws.Util.option_map v.platform (fun f -> "platform", String.to_json f)
         ; Aws.Util.option_map v.license_type (fun f -> "licenseType", String.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "kmsKeyId", String.to_json f)
         ; Aws.Util.option_map v.import_task_id (fun f ->
               "importTaskId", String.to_json f)
         ; Aws.Util.option_map v.image_id (fun f -> "imageId", String.to_json f)
         ; Aws.Util.option_map v.hypervisor (fun f -> "hypervisor", String.to_json f)
         ; Aws.Util.option_map v.encrypted (fun f -> "encrypted", Boolean.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Aws.Util.option_map v.architecture (fun f -> "architecture", String.to_json f)
         ])

  let of_json j =
    { architecture = Aws.Util.option_map (Aws.Json.lookup j "architecture") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; encrypted = Aws.Util.option_map (Aws.Json.lookup j "encrypted") Boolean.of_json
    ; hypervisor = Aws.Util.option_map (Aws.Json.lookup j "hypervisor") String.of_json
    ; image_id = Aws.Util.option_map (Aws.Json.lookup j "imageId") String.of_json
    ; import_task_id =
        Aws.Util.option_map (Aws.Json.lookup j "importTaskId") String.of_json
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "kmsKeyId") String.of_json
    ; license_type = Aws.Util.option_map (Aws.Json.lookup j "licenseType") String.of_json
    ; platform = Aws.Util.option_map (Aws.Json.lookup j "platform") String.of_json
    ; progress = Aws.Util.option_map (Aws.Json.lookup j "progress") String.of_json
    ; snapshot_details =
        SnapshotDetailList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "snapshotDetailSet"))
    ; status = Aws.Util.option_map (Aws.Json.lookup j "status") String.of_json
    ; status_message =
        Aws.Util.option_map (Aws.Json.lookup j "statusMessage") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    ; license_specifications =
        ImportImageLicenseSpecificationListResponse.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "licenseSpecifications"))
    }
end

module ExportTransitGatewayRoutesResult = struct
  type t = { s3_location : String.t option }

  let make ?s3_location () = { s3_location }

  let parse xml =
    Some
      { s3_location = Aws.Util.option_bind (Aws.Xml.member "s3Location" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.s3_location (fun f ->
               Aws.Query.Pair ("S3Location", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.s3_location (fun f -> "s3Location", String.to_json f) ])

  let of_json j =
    { s3_location = Aws.Util.option_map (Aws.Json.lookup j "s3Location") String.of_json }
end

module DisableFastSnapshotRestoreStateError = struct
  type t =
    { code : String.t option
    ; message : String.t option
    }

  let make ?code ?message () = { code; message }

  let parse xml =
    Some
      { code = Aws.Util.option_bind (Aws.Xml.member "code" xml) String.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair ("Code", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f)
         ; Aws.Util.option_map v.code (fun f -> "code", String.to_json f)
         ])

  let of_json j =
    { code = Aws.Util.option_map (Aws.Json.lookup j "code") String.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json
    }
end

module DisableFastSnapshotRestoreStateErrorItem = struct
  type t =
    { availability_zone : String.t option
    ; error : DisableFastSnapshotRestoreStateError.t option
    }

  let make ?availability_zone ?error () = { availability_zone; error }

  let parse xml =
    Some
      { availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; error =
          Aws.Util.option_bind
            (Aws.Xml.member "error" xml)
            DisableFastSnapshotRestoreStateError.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.error (fun f ->
               Aws.Query.Pair ("Error", DisableFastSnapshotRestoreStateError.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.error (fun f ->
               "error", DisableFastSnapshotRestoreStateError.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ])

  let of_json j =
    { availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; error =
        Aws.Util.option_map
          (Aws.Json.lookup j "error")
          DisableFastSnapshotRestoreStateError.of_json
    }
end

module DisableFastSnapshotRestoreStateErrorSet = struct
  type t = DisableFastSnapshotRestoreStateErrorItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         DisableFastSnapshotRestoreStateErrorItem.parse
         (Aws.Xml.members "item" xml))

  let to_query v =
    Aws.Query.to_query_list DisableFastSnapshotRestoreStateErrorItem.to_query v

  let to_json v = `List (List.map DisableFastSnapshotRestoreStateErrorItem.to_json v)

  let of_json j = Aws.Json.to_list DisableFastSnapshotRestoreStateErrorItem.of_json j
end

module LaunchTemplate = struct
  type t =
    { launch_template_id : String.t option
    ; launch_template_name : String.t option
    ; create_time : DateTime.t option
    ; created_by : String.t option
    ; default_version_number : Long.t option
    ; latest_version_number : Long.t option
    ; tags : TagList.t
    }

  let make
      ?launch_template_id
      ?launch_template_name
      ?create_time
      ?created_by
      ?default_version_number
      ?latest_version_number
      ?(tags = [])
      () =
    { launch_template_id
    ; launch_template_name
    ; create_time
    ; created_by
    ; default_version_number
    ; latest_version_number
    ; tags
    }

  let parse xml =
    Some
      { launch_template_id =
          Aws.Util.option_bind (Aws.Xml.member "launchTemplateId" xml) String.parse
      ; launch_template_name =
          Aws.Util.option_bind (Aws.Xml.member "launchTemplateName" xml) String.parse
      ; create_time =
          Aws.Util.option_bind (Aws.Xml.member "createTime" xml) DateTime.parse
      ; created_by = Aws.Util.option_bind (Aws.Xml.member "createdBy" xml) String.parse
      ; default_version_number =
          Aws.Util.option_bind (Aws.Xml.member "defaultVersionNumber" xml) Long.parse
      ; latest_version_number =
          Aws.Util.option_bind (Aws.Xml.member "latestVersionNumber" xml) Long.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.latest_version_number (fun f ->
               Aws.Query.Pair ("LatestVersionNumber", Long.to_query f))
         ; Aws.Util.option_map v.default_version_number (fun f ->
               Aws.Query.Pair ("DefaultVersionNumber", Long.to_query f))
         ; Aws.Util.option_map v.created_by (fun f ->
               Aws.Query.Pair ("CreatedBy", String.to_query f))
         ; Aws.Util.option_map v.create_time (fun f ->
               Aws.Query.Pair ("CreateTime", DateTime.to_query f))
         ; Aws.Util.option_map v.launch_template_name (fun f ->
               Aws.Query.Pair ("LaunchTemplateName", String.to_query f))
         ; Aws.Util.option_map v.launch_template_id (fun f ->
               Aws.Query.Pair ("LaunchTemplateId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.latest_version_number (fun f ->
               "latestVersionNumber", Long.to_json f)
         ; Aws.Util.option_map v.default_version_number (fun f ->
               "defaultVersionNumber", Long.to_json f)
         ; Aws.Util.option_map v.created_by (fun f -> "createdBy", String.to_json f)
         ; Aws.Util.option_map v.create_time (fun f -> "createTime", DateTime.to_json f)
         ; Aws.Util.option_map v.launch_template_name (fun f ->
               "launchTemplateName", String.to_json f)
         ; Aws.Util.option_map v.launch_template_id (fun f ->
               "launchTemplateId", String.to_json f)
         ])

  let of_json j =
    { launch_template_id =
        Aws.Util.option_map (Aws.Json.lookup j "launchTemplateId") String.of_json
    ; launch_template_name =
        Aws.Util.option_map (Aws.Json.lookup j "launchTemplateName") String.of_json
    ; create_time = Aws.Util.option_map (Aws.Json.lookup j "createTime") DateTime.of_json
    ; created_by = Aws.Util.option_map (Aws.Json.lookup j "createdBy") String.of_json
    ; default_version_number =
        Aws.Util.option_map (Aws.Json.lookup j "defaultVersionNumber") Long.of_json
    ; latest_version_number =
        Aws.Util.option_map (Aws.Json.lookup j "latestVersionNumber") Long.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module PublicIpv4PoolRange = struct
  type t =
    { first_address : String.t option
    ; last_address : String.t option
    ; address_count : Integer.t option
    ; available_address_count : Integer.t option
    }

  let make ?first_address ?last_address ?address_count ?available_address_count () =
    { first_address; last_address; address_count; available_address_count }

  let parse xml =
    Some
      { first_address =
          Aws.Util.option_bind (Aws.Xml.member "firstAddress" xml) String.parse
      ; last_address =
          Aws.Util.option_bind (Aws.Xml.member "lastAddress" xml) String.parse
      ; address_count =
          Aws.Util.option_bind (Aws.Xml.member "addressCount" xml) Integer.parse
      ; available_address_count =
          Aws.Util.option_bind (Aws.Xml.member "availableAddressCount" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.available_address_count (fun f ->
               Aws.Query.Pair ("AvailableAddressCount", Integer.to_query f))
         ; Aws.Util.option_map v.address_count (fun f ->
               Aws.Query.Pair ("AddressCount", Integer.to_query f))
         ; Aws.Util.option_map v.last_address (fun f ->
               Aws.Query.Pair ("LastAddress", String.to_query f))
         ; Aws.Util.option_map v.first_address (fun f ->
               Aws.Query.Pair ("FirstAddress", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.available_address_count (fun f ->
               "availableAddressCount", Integer.to_json f)
         ; Aws.Util.option_map v.address_count (fun f ->
               "addressCount", Integer.to_json f)
         ; Aws.Util.option_map v.last_address (fun f -> "lastAddress", String.to_json f)
         ; Aws.Util.option_map v.first_address (fun f -> "firstAddress", String.to_json f)
         ])

  let of_json j =
    { first_address =
        Aws.Util.option_map (Aws.Json.lookup j "firstAddress") String.of_json
    ; last_address = Aws.Util.option_map (Aws.Json.lookup j "lastAddress") String.of_json
    ; address_count =
        Aws.Util.option_map (Aws.Json.lookup j "addressCount") Integer.of_json
    ; available_address_count =
        Aws.Util.option_map (Aws.Json.lookup j "availableAddressCount") Integer.of_json
    }
end

module ModifyVpcTenancyResult = struct
  type t = { return_value : Boolean.t option }

  let make ?return_value () = { return_value }

  let parse xml =
    Some
      { return_value = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return_value (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return_value (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return_value = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module UserIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "UserId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module UserGroupStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "UserGroup" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module ProductCodeStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "ProductCode" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module OperationType = struct
  type t =
    | Add
    | Remove

  let str_to_t = [ "remove", Remove; "add", Add ]

  let t_to_str = [ Remove, "remove"; Add, "add" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module PermissionGroup = struct
  type t = All

  let str_to_t = [ "all", All ]

  let t_to_str = [ All, "all" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module LoadPermissionRequest = struct
  type t =
    { group : PermissionGroup.t option
    ; user_id : String.t option
    }

  let make ?group ?user_id () = { group; user_id }

  let parse xml =
    Some
      { group = Aws.Util.option_bind (Aws.Xml.member "Group" xml) PermissionGroup.parse
      ; user_id = Aws.Util.option_bind (Aws.Xml.member "UserId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.user_id (fun f ->
               Aws.Query.Pair ("UserId", String.to_query f))
         ; Aws.Util.option_map v.group (fun f ->
               Aws.Query.Pair ("Group", PermissionGroup.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.user_id (fun f -> "UserId", String.to_json f)
         ; Aws.Util.option_map v.group (fun f -> "Group", PermissionGroup.to_json f)
         ])

  let of_json j =
    { group = Aws.Util.option_map (Aws.Json.lookup j "Group") PermissionGroup.of_json
    ; user_id = Aws.Util.option_map (Aws.Json.lookup j "UserId") String.of_json
    }
end

module LoadPermissionListRequest = struct
  type t = LoadPermissionRequest.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map LoadPermissionRequest.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list LoadPermissionRequest.to_query v

  let to_json v = `List (List.map LoadPermissionRequest.to_json v)

  let of_json j = Aws.Json.to_list LoadPermissionRequest.of_json j
end

module LoadPermissionModifications = struct
  type t =
    { add : LoadPermissionListRequest.t
    ; remove : LoadPermissionListRequest.t
    }

  let make ?(add = []) ?(remove = []) () = { add; remove }

  let parse xml =
    Some
      { add =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Add" xml)
               LoadPermissionListRequest.parse)
      ; remove =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Remove" xml)
               LoadPermissionListRequest.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Remove", LoadPermissionListRequest.to_query v.remove))
         ; Some (Aws.Query.Pair ("Add", LoadPermissionListRequest.to_query v.add))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Remove", LoadPermissionListRequest.to_json v.remove)
         ; Some ("Add", LoadPermissionListRequest.to_json v.add)
         ])

  let of_json j =
    { add =
        LoadPermissionListRequest.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Add"))
    ; remove =
        LoadPermissionListRequest.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Remove"))
    }
end

module FpgaImageAttributeName = struct
  type t =
    | Description
    | Name
    | LoadPermission
    | ProductCodes

  let str_to_t =
    [ "productCodes", ProductCodes
    ; "loadPermission", LoadPermission
    ; "name", Name
    ; "description", Description
    ]

  let t_to_str =
    [ ProductCodes, "productCodes"
    ; LoadPermission, "loadPermission"
    ; Name, "name"
    ; Description, "description"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ModifyFpgaImageAttributeRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; fpga_image_id : String.t
    ; attribute : FpgaImageAttributeName.t option
    ; operation_type : OperationType.t option
    ; user_ids : UserIdStringList.t
    ; user_groups : UserGroupStringList.t
    ; product_codes : ProductCodeStringList.t
    ; load_permission : LoadPermissionModifications.t option
    ; description : String.t option
    ; name : String.t option
    }

  let make
      ?dry_run
      ~fpga_image_id
      ?attribute
      ?operation_type
      ?(user_ids = [])
      ?(user_groups = [])
      ?(product_codes = [])
      ?load_permission
      ?description
      ?name
      () =
    { dry_run
    ; fpga_image_id
    ; attribute
    ; operation_type
    ; user_ids
    ; user_groups
    ; product_codes
    ; load_permission
    ; description
    ; name
    }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; fpga_image_id =
          Aws.Xml.required
            "FpgaImageId"
            (Aws.Util.option_bind (Aws.Xml.member "FpgaImageId" xml) String.parse)
      ; attribute =
          Aws.Util.option_bind
            (Aws.Xml.member "Attribute" xml)
            FpgaImageAttributeName.parse
      ; operation_type =
          Aws.Util.option_bind (Aws.Xml.member "OperationType" xml) OperationType.parse
      ; user_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "UserId" xml) UserIdStringList.parse)
      ; user_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "UserGroup" xml)
               UserGroupStringList.parse)
      ; product_codes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ProductCode" xml)
               ProductCodeStringList.parse)
      ; load_permission =
          Aws.Util.option_bind
            (Aws.Xml.member "LoadPermission" xml)
            LoadPermissionModifications.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.load_permission (fun f ->
               Aws.Query.Pair ("LoadPermission", LoadPermissionModifications.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ProductCode", ProductCodeStringList.to_query v.product_codes))
         ; Some (Aws.Query.Pair ("UserGroup", UserGroupStringList.to_query v.user_groups))
         ; Some (Aws.Query.Pair ("UserId", UserIdStringList.to_query v.user_ids))
         ; Aws.Util.option_map v.operation_type (fun f ->
               Aws.Query.Pair ("OperationType", OperationType.to_query f))
         ; Aws.Util.option_map v.attribute (fun f ->
               Aws.Query.Pair ("Attribute", FpgaImageAttributeName.to_query f))
         ; Some (Aws.Query.Pair ("FpgaImageId", String.to_query v.fpga_image_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.load_permission (fun f ->
               "LoadPermission", LoadPermissionModifications.to_json f)
         ; Some ("ProductCode", ProductCodeStringList.to_json v.product_codes)
         ; Some ("UserGroup", UserGroupStringList.to_json v.user_groups)
         ; Some ("UserId", UserIdStringList.to_json v.user_ids)
         ; Aws.Util.option_map v.operation_type (fun f ->
               "OperationType", OperationType.to_json f)
         ; Aws.Util.option_map v.attribute (fun f ->
               "Attribute", FpgaImageAttributeName.to_json f)
         ; Some ("FpgaImageId", String.to_json v.fpga_image_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; fpga_image_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "FpgaImageId"))
    ; attribute =
        Aws.Util.option_map (Aws.Json.lookup j "Attribute") FpgaImageAttributeName.of_json
    ; operation_type =
        Aws.Util.option_map (Aws.Json.lookup j "OperationType") OperationType.of_json
    ; user_ids =
        UserIdStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "UserId"))
    ; user_groups =
        UserGroupStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "UserGroup"))
    ; product_codes =
        ProductCodeStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ProductCode"))
    ; load_permission =
        Aws.Util.option_map
          (Aws.Json.lookup j "LoadPermission")
          LoadPermissionModifications.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    }
end

module ValueStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module ShutdownBehavior = struct
  type t =
    | Stop
    | Terminate

  let str_to_t = [ "terminate", Terminate; "stop", Stop ]

  let t_to_str = [ Terminate, "terminate"; Stop, "stop" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module LaunchTemplatesMonitoring = struct
  type t = { enabled : Boolean.t option }

  let make ?enabled () = { enabled }

  let parse xml =
    Some { enabled = Aws.Util.option_bind (Aws.Xml.member "enabled" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enabled (fun f ->
               Aws.Query.Pair ("Enabled", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enabled (fun f -> "enabled", Boolean.to_json f) ])

  let of_json j =
    { enabled = Aws.Util.option_map (Aws.Json.lookup j "enabled") Boolean.of_json }
end

module ResourceType = struct
  type t =
    | Client_vpn_endpoint
    | Customer_gateway
    | Dedicated_host
    | Dhcp_options
    | Egress_only_internet_gateway
    | Elastic_ip
    | Elastic_gpu
    | Export_image_task
    | Export_instance_task
    | Fleet
    | Fpga_image
    | Host_reservation
    | Image
    | Import_image_task
    | Import_snapshot_task
    | Instance
    | Internet_gateway
    | Key_pair
    | Launch_template
    | Local_gateway_route_table_vpc_association
    | Natgateway
    | Network_acl
    | Network_interface
    | Placement_group
    | Reserved_instances
    | Route_table
    | Security_group
    | Snapshot
    | Spot_fleet_request
    | Spot_instances_request
    | Subnet
    | Traffic_mirror_filter
    | Traffic_mirror_session
    | Traffic_mirror_target
    | Transit_gateway
    | Transit_gateway_attachment
    | Transit_gateway_multicast_domain
    | Transit_gateway_route_table
    | Volume
    | Vpc
    | Vpc_peering_connection
    | Vpn_connection
    | Vpn_gateway
    | Vpc_flow_log

  let str_to_t =
    [ "vpc-flow-log", Vpc_flow_log
    ; "vpn-gateway", Vpn_gateway
    ; "vpn-connection", Vpn_connection
    ; "vpc-peering-connection", Vpc_peering_connection
    ; "vpc", Vpc
    ; "volume", Volume
    ; "transit-gateway-route-table", Transit_gateway_route_table
    ; "transit-gateway-multicast-domain", Transit_gateway_multicast_domain
    ; "transit-gateway-attachment", Transit_gateway_attachment
    ; "transit-gateway", Transit_gateway
    ; "traffic-mirror-target", Traffic_mirror_target
    ; "traffic-mirror-session", Traffic_mirror_session
    ; "traffic-mirror-filter", Traffic_mirror_filter
    ; "subnet", Subnet
    ; "spot-instances-request", Spot_instances_request
    ; "spot-fleet-request", Spot_fleet_request
    ; "snapshot", Snapshot
    ; "security-group", Security_group
    ; "route-table", Route_table
    ; "reserved-instances", Reserved_instances
    ; "placement-group", Placement_group
    ; "network-interface", Network_interface
    ; "network-acl", Network_acl
    ; "natgateway", Natgateway
    ; ( "local-gateway-route-table-vpc-association"
      , Local_gateway_route_table_vpc_association )
    ; "launch-template", Launch_template
    ; "key-pair", Key_pair
    ; "internet-gateway", Internet_gateway
    ; "instance", Instance
    ; "import-snapshot-task", Import_snapshot_task
    ; "import-image-task", Import_image_task
    ; "image", Image
    ; "host-reservation", Host_reservation
    ; "fpga-image", Fpga_image
    ; "fleet", Fleet
    ; "export-instance-task", Export_instance_task
    ; "export-image-task", Export_image_task
    ; "elastic-gpu", Elastic_gpu
    ; "elastic-ip", Elastic_ip
    ; "egress-only-internet-gateway", Egress_only_internet_gateway
    ; "dhcp-options", Dhcp_options
    ; "dedicated-host", Dedicated_host
    ; "customer-gateway", Customer_gateway
    ; "client-vpn-endpoint", Client_vpn_endpoint
    ]

  let t_to_str =
    [ Vpc_flow_log, "vpc-flow-log"
    ; Vpn_gateway, "vpn-gateway"
    ; Vpn_connection, "vpn-connection"
    ; Vpc_peering_connection, "vpc-peering-connection"
    ; Vpc, "vpc"
    ; Volume, "volume"
    ; Transit_gateway_route_table, "transit-gateway-route-table"
    ; Transit_gateway_multicast_domain, "transit-gateway-multicast-domain"
    ; Transit_gateway_attachment, "transit-gateway-attachment"
    ; Transit_gateway, "transit-gateway"
    ; Traffic_mirror_target, "traffic-mirror-target"
    ; Traffic_mirror_session, "traffic-mirror-session"
    ; Traffic_mirror_filter, "traffic-mirror-filter"
    ; Subnet, "subnet"
    ; Spot_instances_request, "spot-instances-request"
    ; Spot_fleet_request, "spot-fleet-request"
    ; Snapshot, "snapshot"
    ; Security_group, "security-group"
    ; Route_table, "route-table"
    ; Reserved_instances, "reserved-instances"
    ; Placement_group, "placement-group"
    ; Network_interface, "network-interface"
    ; Network_acl, "network-acl"
    ; Natgateway, "natgateway"
    ; ( Local_gateway_route_table_vpc_association
      , "local-gateway-route-table-vpc-association" )
    ; Launch_template, "launch-template"
    ; Key_pair, "key-pair"
    ; Internet_gateway, "internet-gateway"
    ; Instance, "instance"
    ; Import_snapshot_task, "import-snapshot-task"
    ; Import_image_task, "import-image-task"
    ; Image, "image"
    ; Host_reservation, "host-reservation"
    ; Fpga_image, "fpga-image"
    ; Fleet, "fleet"
    ; Export_instance_task, "export-instance-task"
    ; Export_image_task, "export-image-task"
    ; Elastic_gpu, "elastic-gpu"
    ; Elastic_ip, "elastic-ip"
    ; Egress_only_internet_gateway, "egress-only-internet-gateway"
    ; Dhcp_options, "dhcp-options"
    ; Dedicated_host, "dedicated-host"
    ; Customer_gateway, "customer-gateway"
    ; Client_vpn_endpoint, "client-vpn-endpoint"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module LaunchTemplateTagSpecification = struct
  type t =
    { resource_type : ResourceType.t option
    ; tags : TagList.t
    }

  let make ?resource_type ?(tags = []) () = { resource_type; tags }

  let parse xml =
    Some
      { resource_type =
          Aws.Util.option_bind (Aws.Xml.member "resourceType" xml) ResourceType.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.resource_type (fun f ->
               Aws.Query.Pair ("ResourceType", ResourceType.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.resource_type (fun f ->
               "resourceType", ResourceType.to_json f)
         ])

  let of_json j =
    { resource_type =
        Aws.Util.option_map (Aws.Json.lookup j "resourceType") ResourceType.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module LaunchTemplateTagSpecificationList = struct
  type t = LaunchTemplateTagSpecification.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map LaunchTemplateTagSpecification.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list LaunchTemplateTagSpecification.to_query v

  let to_json v = `List (List.map LaunchTemplateTagSpecification.to_json v)

  let of_json j = Aws.Json.to_list LaunchTemplateTagSpecification.of_json j
end

module Tenancy = struct
  type t =
    | Default
    | Dedicated
    | Host

  let str_to_t = [ "host", Host; "dedicated", Dedicated; "default", Default ]

  let t_to_str = [ Host, "host"; Dedicated, "dedicated"; Default, "default" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module LaunchTemplatePlacement = struct
  type t =
    { availability_zone : String.t option
    ; affinity : String.t option
    ; group_name : String.t option
    ; host_id : String.t option
    ; tenancy : Tenancy.t option
    ; spread_domain : String.t option
    ; host_resource_group_arn : String.t option
    ; partition_number : Integer.t option
    }

  let make
      ?availability_zone
      ?affinity
      ?group_name
      ?host_id
      ?tenancy
      ?spread_domain
      ?host_resource_group_arn
      ?partition_number
      () =
    { availability_zone
    ; affinity
    ; group_name
    ; host_id
    ; tenancy
    ; spread_domain
    ; host_resource_group_arn
    ; partition_number
    }

  let parse xml =
    Some
      { availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; affinity = Aws.Util.option_bind (Aws.Xml.member "affinity" xml) String.parse
      ; group_name = Aws.Util.option_bind (Aws.Xml.member "groupName" xml) String.parse
      ; host_id = Aws.Util.option_bind (Aws.Xml.member "hostId" xml) String.parse
      ; tenancy = Aws.Util.option_bind (Aws.Xml.member "tenancy" xml) Tenancy.parse
      ; spread_domain =
          Aws.Util.option_bind (Aws.Xml.member "spreadDomain" xml) String.parse
      ; host_resource_group_arn =
          Aws.Util.option_bind (Aws.Xml.member "hostResourceGroupArn" xml) String.parse
      ; partition_number =
          Aws.Util.option_bind (Aws.Xml.member "partitionNumber" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.partition_number (fun f ->
               Aws.Query.Pair ("PartitionNumber", Integer.to_query f))
         ; Aws.Util.option_map v.host_resource_group_arn (fun f ->
               Aws.Query.Pair ("HostResourceGroupArn", String.to_query f))
         ; Aws.Util.option_map v.spread_domain (fun f ->
               Aws.Query.Pair ("SpreadDomain", String.to_query f))
         ; Aws.Util.option_map v.tenancy (fun f ->
               Aws.Query.Pair ("Tenancy", Tenancy.to_query f))
         ; Aws.Util.option_map v.host_id (fun f ->
               Aws.Query.Pair ("HostId", String.to_query f))
         ; Aws.Util.option_map v.group_name (fun f ->
               Aws.Query.Pair ("GroupName", String.to_query f))
         ; Aws.Util.option_map v.affinity (fun f ->
               Aws.Query.Pair ("Affinity", String.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.partition_number (fun f ->
               "partitionNumber", Integer.to_json f)
         ; Aws.Util.option_map v.host_resource_group_arn (fun f ->
               "hostResourceGroupArn", String.to_json f)
         ; Aws.Util.option_map v.spread_domain (fun f -> "spreadDomain", String.to_json f)
         ; Aws.Util.option_map v.tenancy (fun f -> "tenancy", Tenancy.to_json f)
         ; Aws.Util.option_map v.host_id (fun f -> "hostId", String.to_json f)
         ; Aws.Util.option_map v.group_name (fun f -> "groupName", String.to_json f)
         ; Aws.Util.option_map v.affinity (fun f -> "affinity", String.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ])

  let of_json j =
    { availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; affinity = Aws.Util.option_map (Aws.Json.lookup j "affinity") String.of_json
    ; group_name = Aws.Util.option_map (Aws.Json.lookup j "groupName") String.of_json
    ; host_id = Aws.Util.option_map (Aws.Json.lookup j "hostId") String.of_json
    ; tenancy = Aws.Util.option_map (Aws.Json.lookup j "tenancy") Tenancy.of_json
    ; spread_domain =
        Aws.Util.option_map (Aws.Json.lookup j "spreadDomain") String.of_json
    ; host_resource_group_arn =
        Aws.Util.option_map (Aws.Json.lookup j "hostResourceGroupArn") String.of_json
    ; partition_number =
        Aws.Util.option_map (Aws.Json.lookup j "partitionNumber") Integer.of_json
    }
end

module LaunchTemplateLicenseConfiguration = struct
  type t = { license_configuration_arn : String.t option }

  let make ?license_configuration_arn () = { license_configuration_arn }

  let parse xml =
    Some
      { license_configuration_arn =
          Aws.Util.option_bind (Aws.Xml.member "licenseConfigurationArn" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.license_configuration_arn (fun f ->
               Aws.Query.Pair ("LicenseConfigurationArn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.license_configuration_arn (fun f ->
               "licenseConfigurationArn", String.to_json f)
         ])

  let of_json j =
    { license_configuration_arn =
        Aws.Util.option_map (Aws.Json.lookup j "licenseConfigurationArn") String.of_json
    }
end

module LaunchTemplateLicenseList = struct
  type t = LaunchTemplateLicenseConfiguration.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map LaunchTemplateLicenseConfiguration.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list LaunchTemplateLicenseConfiguration.to_query v

  let to_json v = `List (List.map LaunchTemplateLicenseConfiguration.to_json v)

  let of_json j = Aws.Json.to_list LaunchTemplateLicenseConfiguration.of_json j
end

module PrivateIpAddressSpecification = struct
  type t =
    { primary : Boolean.t option
    ; private_ip_address : String.t option
    }

  let make ?primary ?private_ip_address () = { primary; private_ip_address }

  let parse xml =
    Some
      { primary = Aws.Util.option_bind (Aws.Xml.member "primary" xml) Boolean.parse
      ; private_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "privateIpAddress" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.private_ip_address (fun f ->
               Aws.Query.Pair ("PrivateIpAddress", String.to_query f))
         ; Aws.Util.option_map v.primary (fun f ->
               Aws.Query.Pair ("Primary", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.private_ip_address (fun f ->
               "privateIpAddress", String.to_json f)
         ; Aws.Util.option_map v.primary (fun f -> "primary", Boolean.to_json f)
         ])

  let of_json j =
    { primary = Aws.Util.option_map (Aws.Json.lookup j "primary") Boolean.of_json
    ; private_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "privateIpAddress") String.of_json
    }
end

module PrivateIpAddressSpecificationList = struct
  type t = PrivateIpAddressSpecification.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map PrivateIpAddressSpecification.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list PrivateIpAddressSpecification.to_query v

  let to_json v = `List (List.map PrivateIpAddressSpecification.to_json v)

  let of_json j = Aws.Json.to_list PrivateIpAddressSpecification.of_json j
end

module InstanceIpv6Address = struct
  type t = { ipv6_address : String.t option }

  let make ?ipv6_address () = { ipv6_address }

  let parse xml =
    Some
      { ipv6_address =
          Aws.Util.option_bind (Aws.Xml.member "ipv6Address" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ipv6_address (fun f ->
               Aws.Query.Pair ("Ipv6Address", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ipv6_address (fun f -> "ipv6Address", String.to_json f) ])

  let of_json j =
    { ipv6_address = Aws.Util.option_map (Aws.Json.lookup j "ipv6Address") String.of_json
    }
end

module InstanceIpv6AddressList = struct
  type t = InstanceIpv6Address.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map InstanceIpv6Address.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list InstanceIpv6Address.to_query v

  let to_json v = `List (List.map InstanceIpv6Address.to_json v)

  let of_json j = Aws.Json.to_list InstanceIpv6Address.of_json j
end

module GroupIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "groupId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module LaunchTemplateInstanceNetworkInterfaceSpecification = struct
  type t =
    { associate_carrier_ip_address : Boolean.t option
    ; associate_public_ip_address : Boolean.t option
    ; delete_on_termination : Boolean.t option
    ; description : String.t option
    ; device_index : Integer.t option
    ; groups : GroupIdStringList.t
    ; interface_type : String.t option
    ; ipv6_address_count : Integer.t option
    ; ipv6_addresses : InstanceIpv6AddressList.t
    ; network_interface_id : String.t option
    ; private_ip_address : String.t option
    ; private_ip_addresses : PrivateIpAddressSpecificationList.t
    ; secondary_private_ip_address_count : Integer.t option
    ; subnet_id : String.t option
    ; network_card_index : Integer.t option
    }

  let make
      ?associate_carrier_ip_address
      ?associate_public_ip_address
      ?delete_on_termination
      ?description
      ?device_index
      ?(groups = [])
      ?interface_type
      ?ipv6_address_count
      ?(ipv6_addresses = [])
      ?network_interface_id
      ?private_ip_address
      ?(private_ip_addresses = [])
      ?secondary_private_ip_address_count
      ?subnet_id
      ?network_card_index
      () =
    { associate_carrier_ip_address
    ; associate_public_ip_address
    ; delete_on_termination
    ; description
    ; device_index
    ; groups
    ; interface_type
    ; ipv6_address_count
    ; ipv6_addresses
    ; network_interface_id
    ; private_ip_address
    ; private_ip_addresses
    ; secondary_private_ip_address_count
    ; subnet_id
    ; network_card_index
    }

  let parse xml =
    Some
      { associate_carrier_ip_address =
          Aws.Util.option_bind
            (Aws.Xml.member "associateCarrierIpAddress" xml)
            Boolean.parse
      ; associate_public_ip_address =
          Aws.Util.option_bind
            (Aws.Xml.member "associatePublicIpAddress" xml)
            Boolean.parse
      ; delete_on_termination =
          Aws.Util.option_bind (Aws.Xml.member "deleteOnTermination" xml) Boolean.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; device_index =
          Aws.Util.option_bind (Aws.Xml.member "deviceIndex" xml) Integer.parse
      ; groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "groupSet" xml) GroupIdStringList.parse)
      ; interface_type =
          Aws.Util.option_bind (Aws.Xml.member "interfaceType" xml) String.parse
      ; ipv6_address_count =
          Aws.Util.option_bind (Aws.Xml.member "ipv6AddressCount" xml) Integer.parse
      ; ipv6_addresses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ipv6AddressesSet" xml)
               InstanceIpv6AddressList.parse)
      ; network_interface_id =
          Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse
      ; private_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "privateIpAddress" xml) String.parse
      ; private_ip_addresses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "privateIpAddressesSet" xml)
               PrivateIpAddressSpecificationList.parse)
      ; secondary_private_ip_address_count =
          Aws.Util.option_bind
            (Aws.Xml.member "secondaryPrivateIpAddressCount" xml)
            Integer.parse
      ; subnet_id = Aws.Util.option_bind (Aws.Xml.member "subnetId" xml) String.parse
      ; network_card_index =
          Aws.Util.option_bind (Aws.Xml.member "networkCardIndex" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.network_card_index (fun f ->
               Aws.Query.Pair ("NetworkCardIndex", Integer.to_query f))
         ; Aws.Util.option_map v.subnet_id (fun f ->
               Aws.Query.Pair ("SubnetId", String.to_query f))
         ; Aws.Util.option_map v.secondary_private_ip_address_count (fun f ->
               Aws.Query.Pair ("SecondaryPrivateIpAddressCount", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "PrivateIpAddressesSet"
                , PrivateIpAddressSpecificationList.to_query v.private_ip_addresses ))
         ; Aws.Util.option_map v.private_ip_address (fun f ->
               Aws.Query.Pair ("PrivateIpAddress", String.to_query f))
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               Aws.Query.Pair ("NetworkInterfaceId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Ipv6AddressesSet", InstanceIpv6AddressList.to_query v.ipv6_addresses))
         ; Aws.Util.option_map v.ipv6_address_count (fun f ->
               Aws.Query.Pair ("Ipv6AddressCount", Integer.to_query f))
         ; Aws.Util.option_map v.interface_type (fun f ->
               Aws.Query.Pair ("InterfaceType", String.to_query f))
         ; Some (Aws.Query.Pair ("GroupSet", GroupIdStringList.to_query v.groups))
         ; Aws.Util.option_map v.device_index (fun f ->
               Aws.Query.Pair ("DeviceIndex", Integer.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.delete_on_termination (fun f ->
               Aws.Query.Pair ("DeleteOnTermination", Boolean.to_query f))
         ; Aws.Util.option_map v.associate_public_ip_address (fun f ->
               Aws.Query.Pair ("AssociatePublicIpAddress", Boolean.to_query f))
         ; Aws.Util.option_map v.associate_carrier_ip_address (fun f ->
               Aws.Query.Pair ("AssociateCarrierIpAddress", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.network_card_index (fun f ->
               "networkCardIndex", Integer.to_json f)
         ; Aws.Util.option_map v.subnet_id (fun f -> "subnetId", String.to_json f)
         ; Aws.Util.option_map v.secondary_private_ip_address_count (fun f ->
               "secondaryPrivateIpAddressCount", Integer.to_json f)
         ; Some
             ( "privateIpAddressesSet"
             , PrivateIpAddressSpecificationList.to_json v.private_ip_addresses )
         ; Aws.Util.option_map v.private_ip_address (fun f ->
               "privateIpAddress", String.to_json f)
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               "networkInterfaceId", String.to_json f)
         ; Some ("ipv6AddressesSet", InstanceIpv6AddressList.to_json v.ipv6_addresses)
         ; Aws.Util.option_map v.ipv6_address_count (fun f ->
               "ipv6AddressCount", Integer.to_json f)
         ; Aws.Util.option_map v.interface_type (fun f ->
               "interfaceType", String.to_json f)
         ; Some ("groupSet", GroupIdStringList.to_json v.groups)
         ; Aws.Util.option_map v.device_index (fun f -> "deviceIndex", Integer.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Aws.Util.option_map v.delete_on_termination (fun f ->
               "deleteOnTermination", Boolean.to_json f)
         ; Aws.Util.option_map v.associate_public_ip_address (fun f ->
               "associatePublicIpAddress", Boolean.to_json f)
         ; Aws.Util.option_map v.associate_carrier_ip_address (fun f ->
               "associateCarrierIpAddress", Boolean.to_json f)
         ])

  let of_json j =
    { associate_carrier_ip_address =
        Aws.Util.option_map
          (Aws.Json.lookup j "associateCarrierIpAddress")
          Boolean.of_json
    ; associate_public_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "associatePublicIpAddress") Boolean.of_json
    ; delete_on_termination =
        Aws.Util.option_map (Aws.Json.lookup j "deleteOnTermination") Boolean.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; device_index = Aws.Util.option_map (Aws.Json.lookup j "deviceIndex") Integer.of_json
    ; groups =
        GroupIdStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "groupSet"))
    ; interface_type =
        Aws.Util.option_map (Aws.Json.lookup j "interfaceType") String.of_json
    ; ipv6_address_count =
        Aws.Util.option_map (Aws.Json.lookup j "ipv6AddressCount") Integer.of_json
    ; ipv6_addresses =
        InstanceIpv6AddressList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ipv6AddressesSet"))
    ; network_interface_id =
        Aws.Util.option_map (Aws.Json.lookup j "networkInterfaceId") String.of_json
    ; private_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "privateIpAddress") String.of_json
    ; private_ip_addresses =
        PrivateIpAddressSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "privateIpAddressesSet"))
    ; secondary_private_ip_address_count =
        Aws.Util.option_map
          (Aws.Json.lookup j "secondaryPrivateIpAddressCount")
          Integer.of_json
    ; subnet_id = Aws.Util.option_map (Aws.Json.lookup j "subnetId") String.of_json
    ; network_card_index =
        Aws.Util.option_map (Aws.Json.lookup j "networkCardIndex") Integer.of_json
    }
end

module LaunchTemplateInstanceNetworkInterfaceSpecificationList = struct
  type t = LaunchTemplateInstanceNetworkInterfaceSpecification.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         LaunchTemplateInstanceNetworkInterfaceSpecification.parse
         (Aws.Xml.members "item" xml))

  let to_query v =
    Aws.Query.to_query_list LaunchTemplateInstanceNetworkInterfaceSpecification.to_query v

  let to_json v =
    `List (List.map LaunchTemplateInstanceNetworkInterfaceSpecification.to_json v)

  let of_json j =
    Aws.Json.to_list LaunchTemplateInstanceNetworkInterfaceSpecification.of_json j
end

module LaunchTemplateInstanceMetadataOptionsState = struct
  type t =
    | Pending
    | Applied

  let str_to_t = [ "applied", Applied; "pending", Pending ]

  let t_to_str = [ Applied, "applied"; Pending, "pending" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module LaunchTemplateInstanceMetadataEndpointState = struct
  type t =
    | Disabled
    | Enabled

  let str_to_t = [ "enabled", Enabled; "disabled", Disabled ]

  let t_to_str = [ Enabled, "enabled"; Disabled, "disabled" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module LaunchTemplateHttpTokensState = struct
  type t =
    | Optional
    | Required

  let str_to_t = [ "required", Required; "optional", Optional ]

  let t_to_str = [ Required, "required"; Optional, "optional" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module LaunchTemplateInstanceMetadataOptions = struct
  type t =
    { state : LaunchTemplateInstanceMetadataOptionsState.t option
    ; http_tokens : LaunchTemplateHttpTokensState.t option
    ; http_put_response_hop_limit : Integer.t option
    ; http_endpoint : LaunchTemplateInstanceMetadataEndpointState.t option
    }

  let make ?state ?http_tokens ?http_put_response_hop_limit ?http_endpoint () =
    { state; http_tokens; http_put_response_hop_limit; http_endpoint }

  let parse xml =
    Some
      { state =
          Aws.Util.option_bind
            (Aws.Xml.member "state" xml)
            LaunchTemplateInstanceMetadataOptionsState.parse
      ; http_tokens =
          Aws.Util.option_bind
            (Aws.Xml.member "httpTokens" xml)
            LaunchTemplateHttpTokensState.parse
      ; http_put_response_hop_limit =
          Aws.Util.option_bind
            (Aws.Xml.member "httpPutResponseHopLimit" xml)
            Integer.parse
      ; http_endpoint =
          Aws.Util.option_bind
            (Aws.Xml.member "httpEndpoint" xml)
            LaunchTemplateInstanceMetadataEndpointState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.http_endpoint (fun f ->
               Aws.Query.Pair
                 ("HttpEndpoint", LaunchTemplateInstanceMetadataEndpointState.to_query f))
         ; Aws.Util.option_map v.http_put_response_hop_limit (fun f ->
               Aws.Query.Pair ("HttpPutResponseHopLimit", Integer.to_query f))
         ; Aws.Util.option_map v.http_tokens (fun f ->
               Aws.Query.Pair ("HttpTokens", LaunchTemplateHttpTokensState.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair
                 ("State", LaunchTemplateInstanceMetadataOptionsState.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.http_endpoint (fun f ->
               "httpEndpoint", LaunchTemplateInstanceMetadataEndpointState.to_json f)
         ; Aws.Util.option_map v.http_put_response_hop_limit (fun f ->
               "httpPutResponseHopLimit", Integer.to_json f)
         ; Aws.Util.option_map v.http_tokens (fun f ->
               "httpTokens", LaunchTemplateHttpTokensState.to_json f)
         ; Aws.Util.option_map v.state (fun f ->
               "state", LaunchTemplateInstanceMetadataOptionsState.to_json f)
         ])

  let of_json j =
    { state =
        Aws.Util.option_map
          (Aws.Json.lookup j "state")
          LaunchTemplateInstanceMetadataOptionsState.of_json
    ; http_tokens =
        Aws.Util.option_map
          (Aws.Json.lookup j "httpTokens")
          LaunchTemplateHttpTokensState.of_json
    ; http_put_response_hop_limit =
        Aws.Util.option_map (Aws.Json.lookup j "httpPutResponseHopLimit") Integer.of_json
    ; http_endpoint =
        Aws.Util.option_map
          (Aws.Json.lookup j "httpEndpoint")
          LaunchTemplateInstanceMetadataEndpointState.of_json
    }
end

module MarketType = struct
  type t = Spot

  let str_to_t = [ "spot", Spot ]

  let t_to_str = [ Spot, "spot" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module SpotInstanceType = struct
  type t =
    | One_time
    | Persistent

  let str_to_t = [ "persistent", Persistent; "one-time", One_time ]

  let t_to_str = [ Persistent, "persistent"; One_time, "one-time" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module InstanceInterruptionBehavior = struct
  type t =
    | Hibernate
    | Stop
    | Terminate

  let str_to_t = [ "terminate", Terminate; "stop", Stop; "hibernate", Hibernate ]

  let t_to_str = [ Terminate, "terminate"; Stop, "stop"; Hibernate, "hibernate" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module LaunchTemplateSpotMarketOptions = struct
  type t =
    { max_price : String.t option
    ; spot_instance_type : SpotInstanceType.t option
    ; block_duration_minutes : Integer.t option
    ; valid_until : DateTime.t option
    ; instance_interruption_behavior : InstanceInterruptionBehavior.t option
    }

  let make
      ?max_price
      ?spot_instance_type
      ?block_duration_minutes
      ?valid_until
      ?instance_interruption_behavior
      () =
    { max_price
    ; spot_instance_type
    ; block_duration_minutes
    ; valid_until
    ; instance_interruption_behavior
    }

  let parse xml =
    Some
      { max_price = Aws.Util.option_bind (Aws.Xml.member "maxPrice" xml) String.parse
      ; spot_instance_type =
          Aws.Util.option_bind
            (Aws.Xml.member "spotInstanceType" xml)
            SpotInstanceType.parse
      ; block_duration_minutes =
          Aws.Util.option_bind (Aws.Xml.member "blockDurationMinutes" xml) Integer.parse
      ; valid_until =
          Aws.Util.option_bind (Aws.Xml.member "validUntil" xml) DateTime.parse
      ; instance_interruption_behavior =
          Aws.Util.option_bind
            (Aws.Xml.member "instanceInterruptionBehavior" xml)
            InstanceInterruptionBehavior.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_interruption_behavior (fun f ->
               Aws.Query.Pair
                 ("InstanceInterruptionBehavior", InstanceInterruptionBehavior.to_query f))
         ; Aws.Util.option_map v.valid_until (fun f ->
               Aws.Query.Pair ("ValidUntil", DateTime.to_query f))
         ; Aws.Util.option_map v.block_duration_minutes (fun f ->
               Aws.Query.Pair ("BlockDurationMinutes", Integer.to_query f))
         ; Aws.Util.option_map v.spot_instance_type (fun f ->
               Aws.Query.Pair ("SpotInstanceType", SpotInstanceType.to_query f))
         ; Aws.Util.option_map v.max_price (fun f ->
               Aws.Query.Pair ("MaxPrice", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_interruption_behavior (fun f ->
               "instanceInterruptionBehavior", InstanceInterruptionBehavior.to_json f)
         ; Aws.Util.option_map v.valid_until (fun f -> "validUntil", DateTime.to_json f)
         ; Aws.Util.option_map v.block_duration_minutes (fun f ->
               "blockDurationMinutes", Integer.to_json f)
         ; Aws.Util.option_map v.spot_instance_type (fun f ->
               "spotInstanceType", SpotInstanceType.to_json f)
         ; Aws.Util.option_map v.max_price (fun f -> "maxPrice", String.to_json f)
         ])

  let of_json j =
    { max_price = Aws.Util.option_map (Aws.Json.lookup j "maxPrice") String.of_json
    ; spot_instance_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "spotInstanceType")
          SpotInstanceType.of_json
    ; block_duration_minutes =
        Aws.Util.option_map (Aws.Json.lookup j "blockDurationMinutes") Integer.of_json
    ; valid_until = Aws.Util.option_map (Aws.Json.lookup j "validUntil") DateTime.of_json
    ; instance_interruption_behavior =
        Aws.Util.option_map
          (Aws.Json.lookup j "instanceInterruptionBehavior")
          InstanceInterruptionBehavior.of_json
    }
end

module LaunchTemplateInstanceMarketOptions = struct
  type t =
    { market_type : MarketType.t option
    ; spot_options : LaunchTemplateSpotMarketOptions.t option
    }

  let make ?market_type ?spot_options () = { market_type; spot_options }

  let parse xml =
    Some
      { market_type =
          Aws.Util.option_bind (Aws.Xml.member "marketType" xml) MarketType.parse
      ; spot_options =
          Aws.Util.option_bind
            (Aws.Xml.member "spotOptions" xml)
            LaunchTemplateSpotMarketOptions.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.spot_options (fun f ->
               Aws.Query.Pair ("SpotOptions", LaunchTemplateSpotMarketOptions.to_query f))
         ; Aws.Util.option_map v.market_type (fun f ->
               Aws.Query.Pair ("MarketType", MarketType.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.spot_options (fun f ->
               "spotOptions", LaunchTemplateSpotMarketOptions.to_json f)
         ; Aws.Util.option_map v.market_type (fun f -> "marketType", MarketType.to_json f)
         ])

  let of_json j =
    { market_type =
        Aws.Util.option_map (Aws.Json.lookup j "marketType") MarketType.of_json
    ; spot_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "spotOptions")
          LaunchTemplateSpotMarketOptions.of_json
    }
end

module LaunchTemplateIamInstanceProfileSpecification = struct
  type t =
    { arn : String.t option
    ; name : String.t option
    }

  let make ?arn ?name () = { arn; name }

  let parse xml =
    Some
      { arn = Aws.Util.option_bind (Aws.Xml.member "arn" xml) String.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "name" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.arn (fun f -> Aws.Query.Pair ("Arn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.name (fun f -> "name", String.to_json f)
         ; Aws.Util.option_map v.arn (fun f -> "arn", String.to_json f)
         ])

  let of_json j =
    { arn = Aws.Util.option_map (Aws.Json.lookup j "arn") String.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "name") String.of_json
    }
end

module LaunchTemplateHibernationOptions = struct
  type t = { configured : Boolean.t option }

  let make ?configured () = { configured }

  let parse xml =
    Some
      { configured = Aws.Util.option_bind (Aws.Xml.member "configured" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.configured (fun f ->
               Aws.Query.Pair ("Configured", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.configured (fun f -> "configured", Boolean.to_json f) ])

  let of_json j =
    { configured = Aws.Util.option_map (Aws.Json.lookup j "configured") Boolean.of_json }
end

module LaunchTemplateEnclaveOptions = struct
  type t = { enabled : Boolean.t option }

  let make ?enabled () = { enabled }

  let parse xml =
    Some { enabled = Aws.Util.option_bind (Aws.Xml.member "enabled" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enabled (fun f ->
               Aws.Query.Pair ("Enabled", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enabled (fun f -> "enabled", Boolean.to_json f) ])

  let of_json j =
    { enabled = Aws.Util.option_map (Aws.Json.lookup j "enabled") Boolean.of_json }
end

module LaunchTemplateElasticInferenceAcceleratorResponse = struct
  type t =
    { type_ : String.t option
    ; count : Integer.t option
    }

  let make ?type_ ?count () = { type_; count }

  let parse xml =
    Some
      { type_ = Aws.Util.option_bind (Aws.Xml.member "type" xml) String.parse
      ; count = Aws.Util.option_bind (Aws.Xml.member "count" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.count (fun f ->
               Aws.Query.Pair ("Count", Integer.to_query f))
         ; Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.count (fun f -> "count", Integer.to_json f)
         ; Aws.Util.option_map v.type_ (fun f -> "type", String.to_json f)
         ])

  let of_json j =
    { type_ = Aws.Util.option_map (Aws.Json.lookup j "type") String.of_json
    ; count = Aws.Util.option_map (Aws.Json.lookup j "count") Integer.of_json
    }
end

module LaunchTemplateElasticInferenceAcceleratorResponseList = struct
  type t = LaunchTemplateElasticInferenceAcceleratorResponse.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         LaunchTemplateElasticInferenceAcceleratorResponse.parse
         (Aws.Xml.members "item" xml))

  let to_query v =
    Aws.Query.to_query_list LaunchTemplateElasticInferenceAcceleratorResponse.to_query v

  let to_json v =
    `List (List.map LaunchTemplateElasticInferenceAcceleratorResponse.to_json v)

  let of_json j =
    Aws.Json.to_list LaunchTemplateElasticInferenceAcceleratorResponse.of_json j
end

module LaunchTemplateCpuOptions = struct
  type t =
    { core_count : Integer.t option
    ; threads_per_core : Integer.t option
    }

  let make ?core_count ?threads_per_core () = { core_count; threads_per_core }

  let parse xml =
    Some
      { core_count = Aws.Util.option_bind (Aws.Xml.member "coreCount" xml) Integer.parse
      ; threads_per_core =
          Aws.Util.option_bind (Aws.Xml.member "threadsPerCore" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.threads_per_core (fun f ->
               Aws.Query.Pair ("ThreadsPerCore", Integer.to_query f))
         ; Aws.Util.option_map v.core_count (fun f ->
               Aws.Query.Pair ("CoreCount", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.threads_per_core (fun f ->
               "threadsPerCore", Integer.to_json f)
         ; Aws.Util.option_map v.core_count (fun f -> "coreCount", Integer.to_json f)
         ])

  let of_json j =
    { core_count = Aws.Util.option_map (Aws.Json.lookup j "coreCount") Integer.of_json
    ; threads_per_core =
        Aws.Util.option_map (Aws.Json.lookup j "threadsPerCore") Integer.of_json
    }
end

module CapacityReservationTargetResponse = struct
  type t =
    { capacity_reservation_id : String.t option
    ; capacity_reservation_resource_group_arn : String.t option
    }

  let make ?capacity_reservation_id ?capacity_reservation_resource_group_arn () =
    { capacity_reservation_id; capacity_reservation_resource_group_arn }

  let parse xml =
    Some
      { capacity_reservation_id =
          Aws.Util.option_bind (Aws.Xml.member "capacityReservationId" xml) String.parse
      ; capacity_reservation_resource_group_arn =
          Aws.Util.option_bind
            (Aws.Xml.member "capacityReservationResourceGroupArn" xml)
            String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.capacity_reservation_resource_group_arn (fun f ->
               Aws.Query.Pair ("CapacityReservationResourceGroupArn", String.to_query f))
         ; Aws.Util.option_map v.capacity_reservation_id (fun f ->
               Aws.Query.Pair ("CapacityReservationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.capacity_reservation_resource_group_arn (fun f ->
               "capacityReservationResourceGroupArn", String.to_json f)
         ; Aws.Util.option_map v.capacity_reservation_id (fun f ->
               "capacityReservationId", String.to_json f)
         ])

  let of_json j =
    { capacity_reservation_id =
        Aws.Util.option_map (Aws.Json.lookup j "capacityReservationId") String.of_json
    ; capacity_reservation_resource_group_arn =
        Aws.Util.option_map
          (Aws.Json.lookup j "capacityReservationResourceGroupArn")
          String.of_json
    }
end

module CapacityReservationPreference = struct
  type t =
    | Open
    | None

  let str_to_t = [ "none", None; "open", Open ]

  let t_to_str = [ None, "none"; Open, "open" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module LaunchTemplateCapacityReservationSpecificationResponse = struct
  type t =
    { capacity_reservation_preference : CapacityReservationPreference.t option
    ; capacity_reservation_target : CapacityReservationTargetResponse.t option
    }

  let make ?capacity_reservation_preference ?capacity_reservation_target () =
    { capacity_reservation_preference; capacity_reservation_target }

  let parse xml =
    Some
      { capacity_reservation_preference =
          Aws.Util.option_bind
            (Aws.Xml.member "capacityReservationPreference" xml)
            CapacityReservationPreference.parse
      ; capacity_reservation_target =
          Aws.Util.option_bind
            (Aws.Xml.member "capacityReservationTarget" xml)
            CapacityReservationTargetResponse.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.capacity_reservation_target (fun f ->
               Aws.Query.Pair
                 ( "CapacityReservationTarget"
                 , CapacityReservationTargetResponse.to_query f ))
         ; Aws.Util.option_map v.capacity_reservation_preference (fun f ->
               Aws.Query.Pair
                 ( "CapacityReservationPreference"
                 , CapacityReservationPreference.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.capacity_reservation_target (fun f ->
               "capacityReservationTarget", CapacityReservationTargetResponse.to_json f)
         ; Aws.Util.option_map v.capacity_reservation_preference (fun f ->
               "capacityReservationPreference", CapacityReservationPreference.to_json f)
         ])

  let of_json j =
    { capacity_reservation_preference =
        Aws.Util.option_map
          (Aws.Json.lookup j "capacityReservationPreference")
          CapacityReservationPreference.of_json
    ; capacity_reservation_target =
        Aws.Util.option_map
          (Aws.Json.lookup j "capacityReservationTarget")
          CapacityReservationTargetResponse.of_json
    }
end

module VolumeType = struct
  type t =
    | Standard
    | Io1
    | Io2
    | Gp2
    | Sc1
    | St1

  let str_to_t =
    [ "st1", St1; "sc1", Sc1; "gp2", Gp2; "io2", Io2; "io1", Io1; "standard", Standard ]

  let t_to_str =
    [ St1, "st1"; Sc1, "sc1"; Gp2, "gp2"; Io2, "io2"; Io1, "io1"; Standard, "standard" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module LaunchTemplateEbsBlockDevice = struct
  type t =
    { encrypted : Boolean.t option
    ; delete_on_termination : Boolean.t option
    ; iops : Integer.t option
    ; kms_key_id : String.t option
    ; snapshot_id : String.t option
    ; volume_size : Integer.t option
    ; volume_type : VolumeType.t option
    }

  let make
      ?encrypted
      ?delete_on_termination
      ?iops
      ?kms_key_id
      ?snapshot_id
      ?volume_size
      ?volume_type
      () =
    { encrypted
    ; delete_on_termination
    ; iops
    ; kms_key_id
    ; snapshot_id
    ; volume_size
    ; volume_type
    }

  let parse xml =
    Some
      { encrypted = Aws.Util.option_bind (Aws.Xml.member "encrypted" xml) Boolean.parse
      ; delete_on_termination =
          Aws.Util.option_bind (Aws.Xml.member "deleteOnTermination" xml) Boolean.parse
      ; iops = Aws.Util.option_bind (Aws.Xml.member "iops" xml) Integer.parse
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "kmsKeyId" xml) String.parse
      ; snapshot_id = Aws.Util.option_bind (Aws.Xml.member "snapshotId" xml) String.parse
      ; volume_size = Aws.Util.option_bind (Aws.Xml.member "volumeSize" xml) Integer.parse
      ; volume_type =
          Aws.Util.option_bind (Aws.Xml.member "volumeType" xml) VolumeType.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.volume_type (fun f ->
               Aws.Query.Pair ("VolumeType", VolumeType.to_query f))
         ; Aws.Util.option_map v.volume_size (fun f ->
               Aws.Query.Pair ("VolumeSize", Integer.to_query f))
         ; Aws.Util.option_map v.snapshot_id (fun f ->
               Aws.Query.Pair ("SnapshotId", String.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Aws.Util.option_map v.iops (fun f ->
               Aws.Query.Pair ("Iops", Integer.to_query f))
         ; Aws.Util.option_map v.delete_on_termination (fun f ->
               Aws.Query.Pair ("DeleteOnTermination", Boolean.to_query f))
         ; Aws.Util.option_map v.encrypted (fun f ->
               Aws.Query.Pair ("Encrypted", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.volume_type (fun f -> "volumeType", VolumeType.to_json f)
         ; Aws.Util.option_map v.volume_size (fun f -> "volumeSize", Integer.to_json f)
         ; Aws.Util.option_map v.snapshot_id (fun f -> "snapshotId", String.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "kmsKeyId", String.to_json f)
         ; Aws.Util.option_map v.iops (fun f -> "iops", Integer.to_json f)
         ; Aws.Util.option_map v.delete_on_termination (fun f ->
               "deleteOnTermination", Boolean.to_json f)
         ; Aws.Util.option_map v.encrypted (fun f -> "encrypted", Boolean.to_json f)
         ])

  let of_json j =
    { encrypted = Aws.Util.option_map (Aws.Json.lookup j "encrypted") Boolean.of_json
    ; delete_on_termination =
        Aws.Util.option_map (Aws.Json.lookup j "deleteOnTermination") Boolean.of_json
    ; iops = Aws.Util.option_map (Aws.Json.lookup j "iops") Integer.of_json
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "kmsKeyId") String.of_json
    ; snapshot_id = Aws.Util.option_map (Aws.Json.lookup j "snapshotId") String.of_json
    ; volume_size = Aws.Util.option_map (Aws.Json.lookup j "volumeSize") Integer.of_json
    ; volume_type =
        Aws.Util.option_map (Aws.Json.lookup j "volumeType") VolumeType.of_json
    }
end

module LaunchTemplateBlockDeviceMapping = struct
  type t =
    { device_name : String.t option
    ; virtual_name : String.t option
    ; ebs : LaunchTemplateEbsBlockDevice.t option
    ; no_device : String.t option
    }

  let make ?device_name ?virtual_name ?ebs ?no_device () =
    { device_name; virtual_name; ebs; no_device }

  let parse xml =
    Some
      { device_name = Aws.Util.option_bind (Aws.Xml.member "deviceName" xml) String.parse
      ; virtual_name =
          Aws.Util.option_bind (Aws.Xml.member "virtualName" xml) String.parse
      ; ebs =
          Aws.Util.option_bind
            (Aws.Xml.member "ebs" xml)
            LaunchTemplateEbsBlockDevice.parse
      ; no_device = Aws.Util.option_bind (Aws.Xml.member "noDevice" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.no_device (fun f ->
               Aws.Query.Pair ("NoDevice", String.to_query f))
         ; Aws.Util.option_map v.ebs (fun f ->
               Aws.Query.Pair ("Ebs", LaunchTemplateEbsBlockDevice.to_query f))
         ; Aws.Util.option_map v.virtual_name (fun f ->
               Aws.Query.Pair ("VirtualName", String.to_query f))
         ; Aws.Util.option_map v.device_name (fun f ->
               Aws.Query.Pair ("DeviceName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.no_device (fun f -> "noDevice", String.to_json f)
         ; Aws.Util.option_map v.ebs (fun f ->
               "ebs", LaunchTemplateEbsBlockDevice.to_json f)
         ; Aws.Util.option_map v.virtual_name (fun f -> "virtualName", String.to_json f)
         ; Aws.Util.option_map v.device_name (fun f -> "deviceName", String.to_json f)
         ])

  let of_json j =
    { device_name = Aws.Util.option_map (Aws.Json.lookup j "deviceName") String.of_json
    ; virtual_name = Aws.Util.option_map (Aws.Json.lookup j "virtualName") String.of_json
    ; ebs =
        Aws.Util.option_map (Aws.Json.lookup j "ebs") LaunchTemplateEbsBlockDevice.of_json
    ; no_device = Aws.Util.option_map (Aws.Json.lookup j "noDevice") String.of_json
    }
end

module LaunchTemplateBlockDeviceMappingList = struct
  type t = LaunchTemplateBlockDeviceMapping.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map LaunchTemplateBlockDeviceMapping.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list LaunchTemplateBlockDeviceMapping.to_query v

  let to_json v = `List (List.map LaunchTemplateBlockDeviceMapping.to_json v)

  let of_json j = Aws.Json.to_list LaunchTemplateBlockDeviceMapping.of_json j
end

module InstanceType = struct
  type t =
    | T1_micro
    | T2_nano
    | T2_micro
    | T2_small
    | T2_medium
    | T2_large
    | T2_xlarge
    | T2_2xlarge
    | T3_nano
    | T3_micro
    | T3_small
    | T3_medium
    | T3_large
    | T3_xlarge
    | T3_2xlarge
    | T3a_nano
    | T3a_micro
    | T3a_small
    | T3a_medium
    | T3a_large
    | T3a_xlarge
    | T3a_2xlarge
    | T4g_nano
    | T4g_micro
    | T4g_small
    | T4g_medium
    | T4g_large
    | T4g_xlarge
    | T4g_2xlarge
    | M1_small
    | M1_medium
    | M1_large
    | M1_xlarge
    | M3_medium
    | M3_large
    | M3_xlarge
    | M3_2xlarge
    | M4_large
    | M4_xlarge
    | M4_2xlarge
    | M4_4xlarge
    | M4_10xlarge
    | M4_16xlarge
    | M2_xlarge
    | M2_2xlarge
    | M2_4xlarge
    | Cr1_8xlarge
    | R3_large
    | R3_xlarge
    | R3_2xlarge
    | R3_4xlarge
    | R3_8xlarge
    | R4_large
    | R4_xlarge
    | R4_2xlarge
    | R4_4xlarge
    | R4_8xlarge
    | R4_16xlarge
    | R5_large
    | R5_xlarge
    | R5_2xlarge
    | R5_4xlarge
    | R5_8xlarge
    | R5_12xlarge
    | R5_16xlarge
    | R5_24xlarge
    | R5_metal
    | R5a_large
    | R5a_xlarge
    | R5a_2xlarge
    | R5a_4xlarge
    | R5a_8xlarge
    | R5a_12xlarge
    | R5a_16xlarge
    | R5a_24xlarge
    | R5d_large
    | R5d_xlarge
    | R5d_2xlarge
    | R5d_4xlarge
    | R5d_8xlarge
    | R5d_12xlarge
    | R5d_16xlarge
    | R5d_24xlarge
    | R5d_metal
    | R5ad_large
    | R5ad_xlarge
    | R5ad_2xlarge
    | R5ad_4xlarge
    | R5ad_8xlarge
    | R5ad_12xlarge
    | R5ad_16xlarge
    | R5ad_24xlarge
    | R6g_metal
    | R6g_medium
    | R6g_large
    | R6g_xlarge
    | R6g_2xlarge
    | R6g_4xlarge
    | R6g_8xlarge
    | R6g_12xlarge
    | R6g_16xlarge
    | R6gd_metal
    | R6gd_medium
    | R6gd_large
    | R6gd_xlarge
    | R6gd_2xlarge
    | R6gd_4xlarge
    | R6gd_8xlarge
    | R6gd_12xlarge
    | R6gd_16xlarge
    | X1_16xlarge
    | X1_32xlarge
    | X1e_xlarge
    | X1e_2xlarge
    | X1e_4xlarge
    | X1e_8xlarge
    | X1e_16xlarge
    | X1e_32xlarge
    | I2_xlarge
    | I2_2xlarge
    | I2_4xlarge
    | I2_8xlarge
    | I3_large
    | I3_xlarge
    | I3_2xlarge
    | I3_4xlarge
    | I3_8xlarge
    | I3_16xlarge
    | I3_metal
    | I3en_large
    | I3en_xlarge
    | I3en_2xlarge
    | I3en_3xlarge
    | I3en_6xlarge
    | I3en_12xlarge
    | I3en_24xlarge
    | I3en_metal
    | Hi1_4xlarge
    | Hs1_8xlarge
    | C1_medium
    | C1_xlarge
    | C3_large
    | C3_xlarge
    | C3_2xlarge
    | C3_4xlarge
    | C3_8xlarge
    | C4_large
    | C4_xlarge
    | C4_2xlarge
    | C4_4xlarge
    | C4_8xlarge
    | C5_large
    | C5_xlarge
    | C5_2xlarge
    | C5_4xlarge
    | C5_9xlarge
    | C5_12xlarge
    | C5_18xlarge
    | C5_24xlarge
    | C5_metal
    | C5a_large
    | C5a_xlarge
    | C5a_2xlarge
    | C5a_4xlarge
    | C5a_8xlarge
    | C5a_12xlarge
    | C5a_16xlarge
    | C5a_24xlarge
    | C5ad_large
    | C5ad_xlarge
    | C5ad_2xlarge
    | C5ad_4xlarge
    | C5ad_8xlarge
    | C5ad_12xlarge
    | C5ad_16xlarge
    | C5ad_24xlarge
    | C5d_large
    | C5d_xlarge
    | C5d_2xlarge
    | C5d_4xlarge
    | C5d_9xlarge
    | C5d_12xlarge
    | C5d_18xlarge
    | C5d_24xlarge
    | C5d_metal
    | C5n_large
    | C5n_xlarge
    | C5n_2xlarge
    | C5n_4xlarge
    | C5n_9xlarge
    | C5n_18xlarge
    | C6g_metal
    | C6g_medium
    | C6g_large
    | C6g_xlarge
    | C6g_2xlarge
    | C6g_4xlarge
    | C6g_8xlarge
    | C6g_12xlarge
    | C6g_16xlarge
    | C6gd_metal
    | C6gd_medium
    | C6gd_large
    | C6gd_xlarge
    | C6gd_2xlarge
    | C6gd_4xlarge
    | C6gd_8xlarge
    | C6gd_12xlarge
    | C6gd_16xlarge
    | Cc1_4xlarge
    | Cc2_8xlarge
    | G2_2xlarge
    | G2_8xlarge
    | G3_4xlarge
    | G3_8xlarge
    | G3_16xlarge
    | G3s_xlarge
    | G4dn_xlarge
    | G4dn_2xlarge
    | G4dn_4xlarge
    | G4dn_8xlarge
    | G4dn_12xlarge
    | G4dn_16xlarge
    | G4dn_metal
    | Cg1_4xlarge
    | P2_xlarge
    | P2_8xlarge
    | P2_16xlarge
    | P3_2xlarge
    | P3_8xlarge
    | P3_16xlarge
    | P3dn_24xlarge
    | P4d_24xlarge
    | D2_xlarge
    | D2_2xlarge
    | D2_4xlarge
    | D2_8xlarge
    | F1_2xlarge
    | F1_4xlarge
    | F1_16xlarge
    | M5_large
    | M5_xlarge
    | M5_2xlarge
    | M5_4xlarge
    | M5_8xlarge
    | M5_12xlarge
    | M5_16xlarge
    | M5_24xlarge
    | M5_metal
    | M5a_large
    | M5a_xlarge
    | M5a_2xlarge
    | M5a_4xlarge
    | M5a_8xlarge
    | M5a_12xlarge
    | M5a_16xlarge
    | M5a_24xlarge
    | M5d_large
    | M5d_xlarge
    | M5d_2xlarge
    | M5d_4xlarge
    | M5d_8xlarge
    | M5d_12xlarge
    | M5d_16xlarge
    | M5d_24xlarge
    | M5d_metal
    | M5ad_large
    | M5ad_xlarge
    | M5ad_2xlarge
    | M5ad_4xlarge
    | M5ad_8xlarge
    | M5ad_12xlarge
    | M5ad_16xlarge
    | M5ad_24xlarge
    | H1_2xlarge
    | H1_4xlarge
    | H1_8xlarge
    | H1_16xlarge
    | Z1d_large
    | Z1d_xlarge
    | Z1d_2xlarge
    | Z1d_3xlarge
    | Z1d_6xlarge
    | Z1d_12xlarge
    | Z1d_metal
    | U_6tb1_metal
    | U_9tb1_metal
    | U_12tb1_metal
    | U_18tb1_metal
    | U_24tb1_metal
    | A1_medium
    | A1_large
    | A1_xlarge
    | A1_2xlarge
    | A1_4xlarge
    | A1_metal
    | M5dn_large
    | M5dn_xlarge
    | M5dn_2xlarge
    | M5dn_4xlarge
    | M5dn_8xlarge
    | M5dn_12xlarge
    | M5dn_16xlarge
    | M5dn_24xlarge
    | M5n_large
    | M5n_xlarge
    | M5n_2xlarge
    | M5n_4xlarge
    | M5n_8xlarge
    | M5n_12xlarge
    | M5n_16xlarge
    | M5n_24xlarge
    | R5dn_large
    | R5dn_xlarge
    | R5dn_2xlarge
    | R5dn_4xlarge
    | R5dn_8xlarge
    | R5dn_12xlarge
    | R5dn_16xlarge
    | R5dn_24xlarge
    | R5n_large
    | R5n_xlarge
    | R5n_2xlarge
    | R5n_4xlarge
    | R5n_8xlarge
    | R5n_12xlarge
    | R5n_16xlarge
    | R5n_24xlarge
    | Inf1_xlarge
    | Inf1_2xlarge
    | Inf1_6xlarge
    | Inf1_24xlarge
    | M6g_metal
    | M6g_medium
    | M6g_large
    | M6g_xlarge
    | M6g_2xlarge
    | M6g_4xlarge
    | M6g_8xlarge
    | M6g_12xlarge
    | M6g_16xlarge
    | M6gd_metal
    | M6gd_medium
    | M6gd_large
    | M6gd_xlarge
    | M6gd_2xlarge
    | M6gd_4xlarge
    | M6gd_8xlarge
    | M6gd_12xlarge
    | M6gd_16xlarge

  let str_to_t =
    [ "m6gd.16xlarge", M6gd_16xlarge
    ; "m6gd.12xlarge", M6gd_12xlarge
    ; "m6gd.8xlarge", M6gd_8xlarge
    ; "m6gd.4xlarge", M6gd_4xlarge
    ; "m6gd.2xlarge", M6gd_2xlarge
    ; "m6gd.xlarge", M6gd_xlarge
    ; "m6gd.large", M6gd_large
    ; "m6gd.medium", M6gd_medium
    ; "m6gd.metal", M6gd_metal
    ; "m6g.16xlarge", M6g_16xlarge
    ; "m6g.12xlarge", M6g_12xlarge
    ; "m6g.8xlarge", M6g_8xlarge
    ; "m6g.4xlarge", M6g_4xlarge
    ; "m6g.2xlarge", M6g_2xlarge
    ; "m6g.xlarge", M6g_xlarge
    ; "m6g.large", M6g_large
    ; "m6g.medium", M6g_medium
    ; "m6g.metal", M6g_metal
    ; "inf1.24xlarge", Inf1_24xlarge
    ; "inf1.6xlarge", Inf1_6xlarge
    ; "inf1.2xlarge", Inf1_2xlarge
    ; "inf1.xlarge", Inf1_xlarge
    ; "r5n.24xlarge", R5n_24xlarge
    ; "r5n.16xlarge", R5n_16xlarge
    ; "r5n.12xlarge", R5n_12xlarge
    ; "r5n.8xlarge", R5n_8xlarge
    ; "r5n.4xlarge", R5n_4xlarge
    ; "r5n.2xlarge", R5n_2xlarge
    ; "r5n.xlarge", R5n_xlarge
    ; "r5n.large", R5n_large
    ; "r5dn.24xlarge", R5dn_24xlarge
    ; "r5dn.16xlarge", R5dn_16xlarge
    ; "r5dn.12xlarge", R5dn_12xlarge
    ; "r5dn.8xlarge", R5dn_8xlarge
    ; "r5dn.4xlarge", R5dn_4xlarge
    ; "r5dn.2xlarge", R5dn_2xlarge
    ; "r5dn.xlarge", R5dn_xlarge
    ; "r5dn.large", R5dn_large
    ; "m5n.24xlarge", M5n_24xlarge
    ; "m5n.16xlarge", M5n_16xlarge
    ; "m5n.12xlarge", M5n_12xlarge
    ; "m5n.8xlarge", M5n_8xlarge
    ; "m5n.4xlarge", M5n_4xlarge
    ; "m5n.2xlarge", M5n_2xlarge
    ; "m5n.xlarge", M5n_xlarge
    ; "m5n.large", M5n_large
    ; "m5dn.24xlarge", M5dn_24xlarge
    ; "m5dn.16xlarge", M5dn_16xlarge
    ; "m5dn.12xlarge", M5dn_12xlarge
    ; "m5dn.8xlarge", M5dn_8xlarge
    ; "m5dn.4xlarge", M5dn_4xlarge
    ; "m5dn.2xlarge", M5dn_2xlarge
    ; "m5dn.xlarge", M5dn_xlarge
    ; "m5dn.large", M5dn_large
    ; "a1.metal", A1_metal
    ; "a1.4xlarge", A1_4xlarge
    ; "a1.2xlarge", A1_2xlarge
    ; "a1.xlarge", A1_xlarge
    ; "a1.large", A1_large
    ; "a1.medium", A1_medium
    ; "u-24tb1.metal", U_24tb1_metal
    ; "u-18tb1.metal", U_18tb1_metal
    ; "u-12tb1.metal", U_12tb1_metal
    ; "u-9tb1.metal", U_9tb1_metal
    ; "u-6tb1.metal", U_6tb1_metal
    ; "z1d.metal", Z1d_metal
    ; "z1d.12xlarge", Z1d_12xlarge
    ; "z1d.6xlarge", Z1d_6xlarge
    ; "z1d.3xlarge", Z1d_3xlarge
    ; "z1d.2xlarge", Z1d_2xlarge
    ; "z1d.xlarge", Z1d_xlarge
    ; "z1d.large", Z1d_large
    ; "h1.16xlarge", H1_16xlarge
    ; "h1.8xlarge", H1_8xlarge
    ; "h1.4xlarge", H1_4xlarge
    ; "h1.2xlarge", H1_2xlarge
    ; "m5ad.24xlarge", M5ad_24xlarge
    ; "m5ad.16xlarge", M5ad_16xlarge
    ; "m5ad.12xlarge", M5ad_12xlarge
    ; "m5ad.8xlarge", M5ad_8xlarge
    ; "m5ad.4xlarge", M5ad_4xlarge
    ; "m5ad.2xlarge", M5ad_2xlarge
    ; "m5ad.xlarge", M5ad_xlarge
    ; "m5ad.large", M5ad_large
    ; "m5d.metal", M5d_metal
    ; "m5d.24xlarge", M5d_24xlarge
    ; "m5d.16xlarge", M5d_16xlarge
    ; "m5d.12xlarge", M5d_12xlarge
    ; "m5d.8xlarge", M5d_8xlarge
    ; "m5d.4xlarge", M5d_4xlarge
    ; "m5d.2xlarge", M5d_2xlarge
    ; "m5d.xlarge", M5d_xlarge
    ; "m5d.large", M5d_large
    ; "m5a.24xlarge", M5a_24xlarge
    ; "m5a.16xlarge", M5a_16xlarge
    ; "m5a.12xlarge", M5a_12xlarge
    ; "m5a.8xlarge", M5a_8xlarge
    ; "m5a.4xlarge", M5a_4xlarge
    ; "m5a.2xlarge", M5a_2xlarge
    ; "m5a.xlarge", M5a_xlarge
    ; "m5a.large", M5a_large
    ; "m5.metal", M5_metal
    ; "m5.24xlarge", M5_24xlarge
    ; "m5.16xlarge", M5_16xlarge
    ; "m5.12xlarge", M5_12xlarge
    ; "m5.8xlarge", M5_8xlarge
    ; "m5.4xlarge", M5_4xlarge
    ; "m5.2xlarge", M5_2xlarge
    ; "m5.xlarge", M5_xlarge
    ; "m5.large", M5_large
    ; "f1.16xlarge", F1_16xlarge
    ; "f1.4xlarge", F1_4xlarge
    ; "f1.2xlarge", F1_2xlarge
    ; "d2.8xlarge", D2_8xlarge
    ; "d2.4xlarge", D2_4xlarge
    ; "d2.2xlarge", D2_2xlarge
    ; "d2.xlarge", D2_xlarge
    ; "p4d.24xlarge", P4d_24xlarge
    ; "p3dn.24xlarge", P3dn_24xlarge
    ; "p3.16xlarge", P3_16xlarge
    ; "p3.8xlarge", P3_8xlarge
    ; "p3.2xlarge", P3_2xlarge
    ; "p2.16xlarge", P2_16xlarge
    ; "p2.8xlarge", P2_8xlarge
    ; "p2.xlarge", P2_xlarge
    ; "cg1.4xlarge", Cg1_4xlarge
    ; "g4dn.metal", G4dn_metal
    ; "g4dn.16xlarge", G4dn_16xlarge
    ; "g4dn.12xlarge", G4dn_12xlarge
    ; "g4dn.8xlarge", G4dn_8xlarge
    ; "g4dn.4xlarge", G4dn_4xlarge
    ; "g4dn.2xlarge", G4dn_2xlarge
    ; "g4dn.xlarge", G4dn_xlarge
    ; "g3s.xlarge", G3s_xlarge
    ; "g3.16xlarge", G3_16xlarge
    ; "g3.8xlarge", G3_8xlarge
    ; "g3.4xlarge", G3_4xlarge
    ; "g2.8xlarge", G2_8xlarge
    ; "g2.2xlarge", G2_2xlarge
    ; "cc2.8xlarge", Cc2_8xlarge
    ; "cc1.4xlarge", Cc1_4xlarge
    ; "c6gd.16xlarge", C6gd_16xlarge
    ; "c6gd.12xlarge", C6gd_12xlarge
    ; "c6gd.8xlarge", C6gd_8xlarge
    ; "c6gd.4xlarge", C6gd_4xlarge
    ; "c6gd.2xlarge", C6gd_2xlarge
    ; "c6gd.xlarge", C6gd_xlarge
    ; "c6gd.large", C6gd_large
    ; "c6gd.medium", C6gd_medium
    ; "c6gd.metal", C6gd_metal
    ; "c6g.16xlarge", C6g_16xlarge
    ; "c6g.12xlarge", C6g_12xlarge
    ; "c6g.8xlarge", C6g_8xlarge
    ; "c6g.4xlarge", C6g_4xlarge
    ; "c6g.2xlarge", C6g_2xlarge
    ; "c6g.xlarge", C6g_xlarge
    ; "c6g.large", C6g_large
    ; "c6g.medium", C6g_medium
    ; "c6g.metal", C6g_metal
    ; "c5n.18xlarge", C5n_18xlarge
    ; "c5n.9xlarge", C5n_9xlarge
    ; "c5n.4xlarge", C5n_4xlarge
    ; "c5n.2xlarge", C5n_2xlarge
    ; "c5n.xlarge", C5n_xlarge
    ; "c5n.large", C5n_large
    ; "c5d.metal", C5d_metal
    ; "c5d.24xlarge", C5d_24xlarge
    ; "c5d.18xlarge", C5d_18xlarge
    ; "c5d.12xlarge", C5d_12xlarge
    ; "c5d.9xlarge", C5d_9xlarge
    ; "c5d.4xlarge", C5d_4xlarge
    ; "c5d.2xlarge", C5d_2xlarge
    ; "c5d.xlarge", C5d_xlarge
    ; "c5d.large", C5d_large
    ; "c5ad.24xlarge", C5ad_24xlarge
    ; "c5ad.16xlarge", C5ad_16xlarge
    ; "c5ad.12xlarge", C5ad_12xlarge
    ; "c5ad.8xlarge", C5ad_8xlarge
    ; "c5ad.4xlarge", C5ad_4xlarge
    ; "c5ad.2xlarge", C5ad_2xlarge
    ; "c5ad.xlarge", C5ad_xlarge
    ; "c5ad.large", C5ad_large
    ; "c5a.24xlarge", C5a_24xlarge
    ; "c5a.16xlarge", C5a_16xlarge
    ; "c5a.12xlarge", C5a_12xlarge
    ; "c5a.8xlarge", C5a_8xlarge
    ; "c5a.4xlarge", C5a_4xlarge
    ; "c5a.2xlarge", C5a_2xlarge
    ; "c5a.xlarge", C5a_xlarge
    ; "c5a.large", C5a_large
    ; "c5.metal", C5_metal
    ; "c5.24xlarge", C5_24xlarge
    ; "c5.18xlarge", C5_18xlarge
    ; "c5.12xlarge", C5_12xlarge
    ; "c5.9xlarge", C5_9xlarge
    ; "c5.4xlarge", C5_4xlarge
    ; "c5.2xlarge", C5_2xlarge
    ; "c5.xlarge", C5_xlarge
    ; "c5.large", C5_large
    ; "c4.8xlarge", C4_8xlarge
    ; "c4.4xlarge", C4_4xlarge
    ; "c4.2xlarge", C4_2xlarge
    ; "c4.xlarge", C4_xlarge
    ; "c4.large", C4_large
    ; "c3.8xlarge", C3_8xlarge
    ; "c3.4xlarge", C3_4xlarge
    ; "c3.2xlarge", C3_2xlarge
    ; "c3.xlarge", C3_xlarge
    ; "c3.large", C3_large
    ; "c1.xlarge", C1_xlarge
    ; "c1.medium", C1_medium
    ; "hs1.8xlarge", Hs1_8xlarge
    ; "hi1.4xlarge", Hi1_4xlarge
    ; "i3en.metal", I3en_metal
    ; "i3en.24xlarge", I3en_24xlarge
    ; "i3en.12xlarge", I3en_12xlarge
    ; "i3en.6xlarge", I3en_6xlarge
    ; "i3en.3xlarge", I3en_3xlarge
    ; "i3en.2xlarge", I3en_2xlarge
    ; "i3en.xlarge", I3en_xlarge
    ; "i3en.large", I3en_large
    ; "i3.metal", I3_metal
    ; "i3.16xlarge", I3_16xlarge
    ; "i3.8xlarge", I3_8xlarge
    ; "i3.4xlarge", I3_4xlarge
    ; "i3.2xlarge", I3_2xlarge
    ; "i3.xlarge", I3_xlarge
    ; "i3.large", I3_large
    ; "i2.8xlarge", I2_8xlarge
    ; "i2.4xlarge", I2_4xlarge
    ; "i2.2xlarge", I2_2xlarge
    ; "i2.xlarge", I2_xlarge
    ; "x1e.32xlarge", X1e_32xlarge
    ; "x1e.16xlarge", X1e_16xlarge
    ; "x1e.8xlarge", X1e_8xlarge
    ; "x1e.4xlarge", X1e_4xlarge
    ; "x1e.2xlarge", X1e_2xlarge
    ; "x1e.xlarge", X1e_xlarge
    ; "x1.32xlarge", X1_32xlarge
    ; "x1.16xlarge", X1_16xlarge
    ; "r6gd.16xlarge", R6gd_16xlarge
    ; "r6gd.12xlarge", R6gd_12xlarge
    ; "r6gd.8xlarge", R6gd_8xlarge
    ; "r6gd.4xlarge", R6gd_4xlarge
    ; "r6gd.2xlarge", R6gd_2xlarge
    ; "r6gd.xlarge", R6gd_xlarge
    ; "r6gd.large", R6gd_large
    ; "r6gd.medium", R6gd_medium
    ; "r6gd.metal", R6gd_metal
    ; "r6g.16xlarge", R6g_16xlarge
    ; "r6g.12xlarge", R6g_12xlarge
    ; "r6g.8xlarge", R6g_8xlarge
    ; "r6g.4xlarge", R6g_4xlarge
    ; "r6g.2xlarge", R6g_2xlarge
    ; "r6g.xlarge", R6g_xlarge
    ; "r6g.large", R6g_large
    ; "r6g.medium", R6g_medium
    ; "r6g.metal", R6g_metal
    ; "r5ad.24xlarge", R5ad_24xlarge
    ; "r5ad.16xlarge", R5ad_16xlarge
    ; "r5ad.12xlarge", R5ad_12xlarge
    ; "r5ad.8xlarge", R5ad_8xlarge
    ; "r5ad.4xlarge", R5ad_4xlarge
    ; "r5ad.2xlarge", R5ad_2xlarge
    ; "r5ad.xlarge", R5ad_xlarge
    ; "r5ad.large", R5ad_large
    ; "r5d.metal", R5d_metal
    ; "r5d.24xlarge", R5d_24xlarge
    ; "r5d.16xlarge", R5d_16xlarge
    ; "r5d.12xlarge", R5d_12xlarge
    ; "r5d.8xlarge", R5d_8xlarge
    ; "r5d.4xlarge", R5d_4xlarge
    ; "r5d.2xlarge", R5d_2xlarge
    ; "r5d.xlarge", R5d_xlarge
    ; "r5d.large", R5d_large
    ; "r5a.24xlarge", R5a_24xlarge
    ; "r5a.16xlarge", R5a_16xlarge
    ; "r5a.12xlarge", R5a_12xlarge
    ; "r5a.8xlarge", R5a_8xlarge
    ; "r5a.4xlarge", R5a_4xlarge
    ; "r5a.2xlarge", R5a_2xlarge
    ; "r5a.xlarge", R5a_xlarge
    ; "r5a.large", R5a_large
    ; "r5.metal", R5_metal
    ; "r5.24xlarge", R5_24xlarge
    ; "r5.16xlarge", R5_16xlarge
    ; "r5.12xlarge", R5_12xlarge
    ; "r5.8xlarge", R5_8xlarge
    ; "r5.4xlarge", R5_4xlarge
    ; "r5.2xlarge", R5_2xlarge
    ; "r5.xlarge", R5_xlarge
    ; "r5.large", R5_large
    ; "r4.16xlarge", R4_16xlarge
    ; "r4.8xlarge", R4_8xlarge
    ; "r4.4xlarge", R4_4xlarge
    ; "r4.2xlarge", R4_2xlarge
    ; "r4.xlarge", R4_xlarge
    ; "r4.large", R4_large
    ; "r3.8xlarge", R3_8xlarge
    ; "r3.4xlarge", R3_4xlarge
    ; "r3.2xlarge", R3_2xlarge
    ; "r3.xlarge", R3_xlarge
    ; "r3.large", R3_large
    ; "cr1.8xlarge", Cr1_8xlarge
    ; "m2.4xlarge", M2_4xlarge
    ; "m2.2xlarge", M2_2xlarge
    ; "m2.xlarge", M2_xlarge
    ; "m4.16xlarge", M4_16xlarge
    ; "m4.10xlarge", M4_10xlarge
    ; "m4.4xlarge", M4_4xlarge
    ; "m4.2xlarge", M4_2xlarge
    ; "m4.xlarge", M4_xlarge
    ; "m4.large", M4_large
    ; "m3.2xlarge", M3_2xlarge
    ; "m3.xlarge", M3_xlarge
    ; "m3.large", M3_large
    ; "m3.medium", M3_medium
    ; "m1.xlarge", M1_xlarge
    ; "m1.large", M1_large
    ; "m1.medium", M1_medium
    ; "m1.small", M1_small
    ; "t4g.2xlarge", T4g_2xlarge
    ; "t4g.xlarge", T4g_xlarge
    ; "t4g.large", T4g_large
    ; "t4g.medium", T4g_medium
    ; "t4g.small", T4g_small
    ; "t4g.micro", T4g_micro
    ; "t4g.nano", T4g_nano
    ; "t3a.2xlarge", T3a_2xlarge
    ; "t3a.xlarge", T3a_xlarge
    ; "t3a.large", T3a_large
    ; "t3a.medium", T3a_medium
    ; "t3a.small", T3a_small
    ; "t3a.micro", T3a_micro
    ; "t3a.nano", T3a_nano
    ; "t3.2xlarge", T3_2xlarge
    ; "t3.xlarge", T3_xlarge
    ; "t3.large", T3_large
    ; "t3.medium", T3_medium
    ; "t3.small", T3_small
    ; "t3.micro", T3_micro
    ; "t3.nano", T3_nano
    ; "t2.2xlarge", T2_2xlarge
    ; "t2.xlarge", T2_xlarge
    ; "t2.large", T2_large
    ; "t2.medium", T2_medium
    ; "t2.small", T2_small
    ; "t2.micro", T2_micro
    ; "t2.nano", T2_nano
    ; "t1.micro", T1_micro
    ]

  let t_to_str =
    [ M6gd_16xlarge, "m6gd.16xlarge"
    ; M6gd_12xlarge, "m6gd.12xlarge"
    ; M6gd_8xlarge, "m6gd.8xlarge"
    ; M6gd_4xlarge, "m6gd.4xlarge"
    ; M6gd_2xlarge, "m6gd.2xlarge"
    ; M6gd_xlarge, "m6gd.xlarge"
    ; M6gd_large, "m6gd.large"
    ; M6gd_medium, "m6gd.medium"
    ; M6gd_metal, "m6gd.metal"
    ; M6g_16xlarge, "m6g.16xlarge"
    ; M6g_12xlarge, "m6g.12xlarge"
    ; M6g_8xlarge, "m6g.8xlarge"
    ; M6g_4xlarge, "m6g.4xlarge"
    ; M6g_2xlarge, "m6g.2xlarge"
    ; M6g_xlarge, "m6g.xlarge"
    ; M6g_large, "m6g.large"
    ; M6g_medium, "m6g.medium"
    ; M6g_metal, "m6g.metal"
    ; Inf1_24xlarge, "inf1.24xlarge"
    ; Inf1_6xlarge, "inf1.6xlarge"
    ; Inf1_2xlarge, "inf1.2xlarge"
    ; Inf1_xlarge, "inf1.xlarge"
    ; R5n_24xlarge, "r5n.24xlarge"
    ; R5n_16xlarge, "r5n.16xlarge"
    ; R5n_12xlarge, "r5n.12xlarge"
    ; R5n_8xlarge, "r5n.8xlarge"
    ; R5n_4xlarge, "r5n.4xlarge"
    ; R5n_2xlarge, "r5n.2xlarge"
    ; R5n_xlarge, "r5n.xlarge"
    ; R5n_large, "r5n.large"
    ; R5dn_24xlarge, "r5dn.24xlarge"
    ; R5dn_16xlarge, "r5dn.16xlarge"
    ; R5dn_12xlarge, "r5dn.12xlarge"
    ; R5dn_8xlarge, "r5dn.8xlarge"
    ; R5dn_4xlarge, "r5dn.4xlarge"
    ; R5dn_2xlarge, "r5dn.2xlarge"
    ; R5dn_xlarge, "r5dn.xlarge"
    ; R5dn_large, "r5dn.large"
    ; M5n_24xlarge, "m5n.24xlarge"
    ; M5n_16xlarge, "m5n.16xlarge"
    ; M5n_12xlarge, "m5n.12xlarge"
    ; M5n_8xlarge, "m5n.8xlarge"
    ; M5n_4xlarge, "m5n.4xlarge"
    ; M5n_2xlarge, "m5n.2xlarge"
    ; M5n_xlarge, "m5n.xlarge"
    ; M5n_large, "m5n.large"
    ; M5dn_24xlarge, "m5dn.24xlarge"
    ; M5dn_16xlarge, "m5dn.16xlarge"
    ; M5dn_12xlarge, "m5dn.12xlarge"
    ; M5dn_8xlarge, "m5dn.8xlarge"
    ; M5dn_4xlarge, "m5dn.4xlarge"
    ; M5dn_2xlarge, "m5dn.2xlarge"
    ; M5dn_xlarge, "m5dn.xlarge"
    ; M5dn_large, "m5dn.large"
    ; A1_metal, "a1.metal"
    ; A1_4xlarge, "a1.4xlarge"
    ; A1_2xlarge, "a1.2xlarge"
    ; A1_xlarge, "a1.xlarge"
    ; A1_large, "a1.large"
    ; A1_medium, "a1.medium"
    ; U_24tb1_metal, "u-24tb1.metal"
    ; U_18tb1_metal, "u-18tb1.metal"
    ; U_12tb1_metal, "u-12tb1.metal"
    ; U_9tb1_metal, "u-9tb1.metal"
    ; U_6tb1_metal, "u-6tb1.metal"
    ; Z1d_metal, "z1d.metal"
    ; Z1d_12xlarge, "z1d.12xlarge"
    ; Z1d_6xlarge, "z1d.6xlarge"
    ; Z1d_3xlarge, "z1d.3xlarge"
    ; Z1d_2xlarge, "z1d.2xlarge"
    ; Z1d_xlarge, "z1d.xlarge"
    ; Z1d_large, "z1d.large"
    ; H1_16xlarge, "h1.16xlarge"
    ; H1_8xlarge, "h1.8xlarge"
    ; H1_4xlarge, "h1.4xlarge"
    ; H1_2xlarge, "h1.2xlarge"
    ; M5ad_24xlarge, "m5ad.24xlarge"
    ; M5ad_16xlarge, "m5ad.16xlarge"
    ; M5ad_12xlarge, "m5ad.12xlarge"
    ; M5ad_8xlarge, "m5ad.8xlarge"
    ; M5ad_4xlarge, "m5ad.4xlarge"
    ; M5ad_2xlarge, "m5ad.2xlarge"
    ; M5ad_xlarge, "m5ad.xlarge"
    ; M5ad_large, "m5ad.large"
    ; M5d_metal, "m5d.metal"
    ; M5d_24xlarge, "m5d.24xlarge"
    ; M5d_16xlarge, "m5d.16xlarge"
    ; M5d_12xlarge, "m5d.12xlarge"
    ; M5d_8xlarge, "m5d.8xlarge"
    ; M5d_4xlarge, "m5d.4xlarge"
    ; M5d_2xlarge, "m5d.2xlarge"
    ; M5d_xlarge, "m5d.xlarge"
    ; M5d_large, "m5d.large"
    ; M5a_24xlarge, "m5a.24xlarge"
    ; M5a_16xlarge, "m5a.16xlarge"
    ; M5a_12xlarge, "m5a.12xlarge"
    ; M5a_8xlarge, "m5a.8xlarge"
    ; M5a_4xlarge, "m5a.4xlarge"
    ; M5a_2xlarge, "m5a.2xlarge"
    ; M5a_xlarge, "m5a.xlarge"
    ; M5a_large, "m5a.large"
    ; M5_metal, "m5.metal"
    ; M5_24xlarge, "m5.24xlarge"
    ; M5_16xlarge, "m5.16xlarge"
    ; M5_12xlarge, "m5.12xlarge"
    ; M5_8xlarge, "m5.8xlarge"
    ; M5_4xlarge, "m5.4xlarge"
    ; M5_2xlarge, "m5.2xlarge"
    ; M5_xlarge, "m5.xlarge"
    ; M5_large, "m5.large"
    ; F1_16xlarge, "f1.16xlarge"
    ; F1_4xlarge, "f1.4xlarge"
    ; F1_2xlarge, "f1.2xlarge"
    ; D2_8xlarge, "d2.8xlarge"
    ; D2_4xlarge, "d2.4xlarge"
    ; D2_2xlarge, "d2.2xlarge"
    ; D2_xlarge, "d2.xlarge"
    ; P4d_24xlarge, "p4d.24xlarge"
    ; P3dn_24xlarge, "p3dn.24xlarge"
    ; P3_16xlarge, "p3.16xlarge"
    ; P3_8xlarge, "p3.8xlarge"
    ; P3_2xlarge, "p3.2xlarge"
    ; P2_16xlarge, "p2.16xlarge"
    ; P2_8xlarge, "p2.8xlarge"
    ; P2_xlarge, "p2.xlarge"
    ; Cg1_4xlarge, "cg1.4xlarge"
    ; G4dn_metal, "g4dn.metal"
    ; G4dn_16xlarge, "g4dn.16xlarge"
    ; G4dn_12xlarge, "g4dn.12xlarge"
    ; G4dn_8xlarge, "g4dn.8xlarge"
    ; G4dn_4xlarge, "g4dn.4xlarge"
    ; G4dn_2xlarge, "g4dn.2xlarge"
    ; G4dn_xlarge, "g4dn.xlarge"
    ; G3s_xlarge, "g3s.xlarge"
    ; G3_16xlarge, "g3.16xlarge"
    ; G3_8xlarge, "g3.8xlarge"
    ; G3_4xlarge, "g3.4xlarge"
    ; G2_8xlarge, "g2.8xlarge"
    ; G2_2xlarge, "g2.2xlarge"
    ; Cc2_8xlarge, "cc2.8xlarge"
    ; Cc1_4xlarge, "cc1.4xlarge"
    ; C6gd_16xlarge, "c6gd.16xlarge"
    ; C6gd_12xlarge, "c6gd.12xlarge"
    ; C6gd_8xlarge, "c6gd.8xlarge"
    ; C6gd_4xlarge, "c6gd.4xlarge"
    ; C6gd_2xlarge, "c6gd.2xlarge"
    ; C6gd_xlarge, "c6gd.xlarge"
    ; C6gd_large, "c6gd.large"
    ; C6gd_medium, "c6gd.medium"
    ; C6gd_metal, "c6gd.metal"
    ; C6g_16xlarge, "c6g.16xlarge"
    ; C6g_12xlarge, "c6g.12xlarge"
    ; C6g_8xlarge, "c6g.8xlarge"
    ; C6g_4xlarge, "c6g.4xlarge"
    ; C6g_2xlarge, "c6g.2xlarge"
    ; C6g_xlarge, "c6g.xlarge"
    ; C6g_large, "c6g.large"
    ; C6g_medium, "c6g.medium"
    ; C6g_metal, "c6g.metal"
    ; C5n_18xlarge, "c5n.18xlarge"
    ; C5n_9xlarge, "c5n.9xlarge"
    ; C5n_4xlarge, "c5n.4xlarge"
    ; C5n_2xlarge, "c5n.2xlarge"
    ; C5n_xlarge, "c5n.xlarge"
    ; C5n_large, "c5n.large"
    ; C5d_metal, "c5d.metal"
    ; C5d_24xlarge, "c5d.24xlarge"
    ; C5d_18xlarge, "c5d.18xlarge"
    ; C5d_12xlarge, "c5d.12xlarge"
    ; C5d_9xlarge, "c5d.9xlarge"
    ; C5d_4xlarge, "c5d.4xlarge"
    ; C5d_2xlarge, "c5d.2xlarge"
    ; C5d_xlarge, "c5d.xlarge"
    ; C5d_large, "c5d.large"
    ; C5ad_24xlarge, "c5ad.24xlarge"
    ; C5ad_16xlarge, "c5ad.16xlarge"
    ; C5ad_12xlarge, "c5ad.12xlarge"
    ; C5ad_8xlarge, "c5ad.8xlarge"
    ; C5ad_4xlarge, "c5ad.4xlarge"
    ; C5ad_2xlarge, "c5ad.2xlarge"
    ; C5ad_xlarge, "c5ad.xlarge"
    ; C5ad_large, "c5ad.large"
    ; C5a_24xlarge, "c5a.24xlarge"
    ; C5a_16xlarge, "c5a.16xlarge"
    ; C5a_12xlarge, "c5a.12xlarge"
    ; C5a_8xlarge, "c5a.8xlarge"
    ; C5a_4xlarge, "c5a.4xlarge"
    ; C5a_2xlarge, "c5a.2xlarge"
    ; C5a_xlarge, "c5a.xlarge"
    ; C5a_large, "c5a.large"
    ; C5_metal, "c5.metal"
    ; C5_24xlarge, "c5.24xlarge"
    ; C5_18xlarge, "c5.18xlarge"
    ; C5_12xlarge, "c5.12xlarge"
    ; C5_9xlarge, "c5.9xlarge"
    ; C5_4xlarge, "c5.4xlarge"
    ; C5_2xlarge, "c5.2xlarge"
    ; C5_xlarge, "c5.xlarge"
    ; C5_large, "c5.large"
    ; C4_8xlarge, "c4.8xlarge"
    ; C4_4xlarge, "c4.4xlarge"
    ; C4_2xlarge, "c4.2xlarge"
    ; C4_xlarge, "c4.xlarge"
    ; C4_large, "c4.large"
    ; C3_8xlarge, "c3.8xlarge"
    ; C3_4xlarge, "c3.4xlarge"
    ; C3_2xlarge, "c3.2xlarge"
    ; C3_xlarge, "c3.xlarge"
    ; C3_large, "c3.large"
    ; C1_xlarge, "c1.xlarge"
    ; C1_medium, "c1.medium"
    ; Hs1_8xlarge, "hs1.8xlarge"
    ; Hi1_4xlarge, "hi1.4xlarge"
    ; I3en_metal, "i3en.metal"
    ; I3en_24xlarge, "i3en.24xlarge"
    ; I3en_12xlarge, "i3en.12xlarge"
    ; I3en_6xlarge, "i3en.6xlarge"
    ; I3en_3xlarge, "i3en.3xlarge"
    ; I3en_2xlarge, "i3en.2xlarge"
    ; I3en_xlarge, "i3en.xlarge"
    ; I3en_large, "i3en.large"
    ; I3_metal, "i3.metal"
    ; I3_16xlarge, "i3.16xlarge"
    ; I3_8xlarge, "i3.8xlarge"
    ; I3_4xlarge, "i3.4xlarge"
    ; I3_2xlarge, "i3.2xlarge"
    ; I3_xlarge, "i3.xlarge"
    ; I3_large, "i3.large"
    ; I2_8xlarge, "i2.8xlarge"
    ; I2_4xlarge, "i2.4xlarge"
    ; I2_2xlarge, "i2.2xlarge"
    ; I2_xlarge, "i2.xlarge"
    ; X1e_32xlarge, "x1e.32xlarge"
    ; X1e_16xlarge, "x1e.16xlarge"
    ; X1e_8xlarge, "x1e.8xlarge"
    ; X1e_4xlarge, "x1e.4xlarge"
    ; X1e_2xlarge, "x1e.2xlarge"
    ; X1e_xlarge, "x1e.xlarge"
    ; X1_32xlarge, "x1.32xlarge"
    ; X1_16xlarge, "x1.16xlarge"
    ; R6gd_16xlarge, "r6gd.16xlarge"
    ; R6gd_12xlarge, "r6gd.12xlarge"
    ; R6gd_8xlarge, "r6gd.8xlarge"
    ; R6gd_4xlarge, "r6gd.4xlarge"
    ; R6gd_2xlarge, "r6gd.2xlarge"
    ; R6gd_xlarge, "r6gd.xlarge"
    ; R6gd_large, "r6gd.large"
    ; R6gd_medium, "r6gd.medium"
    ; R6gd_metal, "r6gd.metal"
    ; R6g_16xlarge, "r6g.16xlarge"
    ; R6g_12xlarge, "r6g.12xlarge"
    ; R6g_8xlarge, "r6g.8xlarge"
    ; R6g_4xlarge, "r6g.4xlarge"
    ; R6g_2xlarge, "r6g.2xlarge"
    ; R6g_xlarge, "r6g.xlarge"
    ; R6g_large, "r6g.large"
    ; R6g_medium, "r6g.medium"
    ; R6g_metal, "r6g.metal"
    ; R5ad_24xlarge, "r5ad.24xlarge"
    ; R5ad_16xlarge, "r5ad.16xlarge"
    ; R5ad_12xlarge, "r5ad.12xlarge"
    ; R5ad_8xlarge, "r5ad.8xlarge"
    ; R5ad_4xlarge, "r5ad.4xlarge"
    ; R5ad_2xlarge, "r5ad.2xlarge"
    ; R5ad_xlarge, "r5ad.xlarge"
    ; R5ad_large, "r5ad.large"
    ; R5d_metal, "r5d.metal"
    ; R5d_24xlarge, "r5d.24xlarge"
    ; R5d_16xlarge, "r5d.16xlarge"
    ; R5d_12xlarge, "r5d.12xlarge"
    ; R5d_8xlarge, "r5d.8xlarge"
    ; R5d_4xlarge, "r5d.4xlarge"
    ; R5d_2xlarge, "r5d.2xlarge"
    ; R5d_xlarge, "r5d.xlarge"
    ; R5d_large, "r5d.large"
    ; R5a_24xlarge, "r5a.24xlarge"
    ; R5a_16xlarge, "r5a.16xlarge"
    ; R5a_12xlarge, "r5a.12xlarge"
    ; R5a_8xlarge, "r5a.8xlarge"
    ; R5a_4xlarge, "r5a.4xlarge"
    ; R5a_2xlarge, "r5a.2xlarge"
    ; R5a_xlarge, "r5a.xlarge"
    ; R5a_large, "r5a.large"
    ; R5_metal, "r5.metal"
    ; R5_24xlarge, "r5.24xlarge"
    ; R5_16xlarge, "r5.16xlarge"
    ; R5_12xlarge, "r5.12xlarge"
    ; R5_8xlarge, "r5.8xlarge"
    ; R5_4xlarge, "r5.4xlarge"
    ; R5_2xlarge, "r5.2xlarge"
    ; R5_xlarge, "r5.xlarge"
    ; R5_large, "r5.large"
    ; R4_16xlarge, "r4.16xlarge"
    ; R4_8xlarge, "r4.8xlarge"
    ; R4_4xlarge, "r4.4xlarge"
    ; R4_2xlarge, "r4.2xlarge"
    ; R4_xlarge, "r4.xlarge"
    ; R4_large, "r4.large"
    ; R3_8xlarge, "r3.8xlarge"
    ; R3_4xlarge, "r3.4xlarge"
    ; R3_2xlarge, "r3.2xlarge"
    ; R3_xlarge, "r3.xlarge"
    ; R3_large, "r3.large"
    ; Cr1_8xlarge, "cr1.8xlarge"
    ; M2_4xlarge, "m2.4xlarge"
    ; M2_2xlarge, "m2.2xlarge"
    ; M2_xlarge, "m2.xlarge"
    ; M4_16xlarge, "m4.16xlarge"
    ; M4_10xlarge, "m4.10xlarge"
    ; M4_4xlarge, "m4.4xlarge"
    ; M4_2xlarge, "m4.2xlarge"
    ; M4_xlarge, "m4.xlarge"
    ; M4_large, "m4.large"
    ; M3_2xlarge, "m3.2xlarge"
    ; M3_xlarge, "m3.xlarge"
    ; M3_large, "m3.large"
    ; M3_medium, "m3.medium"
    ; M1_xlarge, "m1.xlarge"
    ; M1_large, "m1.large"
    ; M1_medium, "m1.medium"
    ; M1_small, "m1.small"
    ; T4g_2xlarge, "t4g.2xlarge"
    ; T4g_xlarge, "t4g.xlarge"
    ; T4g_large, "t4g.large"
    ; T4g_medium, "t4g.medium"
    ; T4g_small, "t4g.small"
    ; T4g_micro, "t4g.micro"
    ; T4g_nano, "t4g.nano"
    ; T3a_2xlarge, "t3a.2xlarge"
    ; T3a_xlarge, "t3a.xlarge"
    ; T3a_large, "t3a.large"
    ; T3a_medium, "t3a.medium"
    ; T3a_small, "t3a.small"
    ; T3a_micro, "t3a.micro"
    ; T3a_nano, "t3a.nano"
    ; T3_2xlarge, "t3.2xlarge"
    ; T3_xlarge, "t3.xlarge"
    ; T3_large, "t3.large"
    ; T3_medium, "t3.medium"
    ; T3_small, "t3.small"
    ; T3_micro, "t3.micro"
    ; T3_nano, "t3.nano"
    ; T2_2xlarge, "t2.2xlarge"
    ; T2_xlarge, "t2.xlarge"
    ; T2_large, "t2.large"
    ; T2_medium, "t2.medium"
    ; T2_small, "t2.small"
    ; T2_micro, "t2.micro"
    ; T2_nano, "t2.nano"
    ; T1_micro, "t1.micro"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ElasticGpuSpecificationResponse = struct
  type t = { type_ : String.t option }

  let make ?type_ () = { type_ }

  let parse xml =
    Some { type_ = Aws.Util.option_bind (Aws.Xml.member "type" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.type_ (fun f -> "type", String.to_json f) ])

  let of_json j =
    { type_ = Aws.Util.option_map (Aws.Json.lookup j "type") String.of_json }
end

module ElasticGpuSpecificationResponseList = struct
  type t = ElasticGpuSpecificationResponse.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ElasticGpuSpecificationResponse.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ElasticGpuSpecificationResponse.to_query v

  let to_json v = `List (List.map ElasticGpuSpecificationResponse.to_json v)

  let of_json j = Aws.Json.to_list ElasticGpuSpecificationResponse.of_json j
end

module CreditSpecification = struct
  type t = { cpu_credits : String.t option }

  let make ?cpu_credits () = { cpu_credits }

  let parse xml =
    Some
      { cpu_credits = Aws.Util.option_bind (Aws.Xml.member "cpuCredits" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cpu_credits (fun f ->
               Aws.Query.Pair ("CpuCredits", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cpu_credits (fun f -> "cpuCredits", String.to_json f) ])

  let of_json j =
    { cpu_credits = Aws.Util.option_map (Aws.Json.lookup j "cpuCredits") String.of_json }
end

module ResponseLaunchTemplateData = struct
  type t =
    { kernel_id : String.t option
    ; ebs_optimized : Boolean.t option
    ; iam_instance_profile : LaunchTemplateIamInstanceProfileSpecification.t option
    ; block_device_mappings : LaunchTemplateBlockDeviceMappingList.t
    ; network_interfaces : LaunchTemplateInstanceNetworkInterfaceSpecificationList.t
    ; image_id : String.t option
    ; instance_type : InstanceType.t option
    ; key_name : String.t option
    ; monitoring : LaunchTemplatesMonitoring.t option
    ; placement : LaunchTemplatePlacement.t option
    ; ram_disk_id : String.t option
    ; disable_api_termination : Boolean.t option
    ; instance_initiated_shutdown_behavior : ShutdownBehavior.t option
    ; user_data : String.t option
    ; tag_specifications : LaunchTemplateTagSpecificationList.t
    ; elastic_gpu_specifications : ElasticGpuSpecificationResponseList.t
    ; elastic_inference_accelerators :
        LaunchTemplateElasticInferenceAcceleratorResponseList.t
    ; security_group_ids : ValueStringList.t
    ; security_groups : ValueStringList.t
    ; instance_market_options : LaunchTemplateInstanceMarketOptions.t option
    ; credit_specification : CreditSpecification.t option
    ; cpu_options : LaunchTemplateCpuOptions.t option
    ; capacity_reservation_specification :
        LaunchTemplateCapacityReservationSpecificationResponse.t option
    ; license_specifications : LaunchTemplateLicenseList.t
    ; hibernation_options : LaunchTemplateHibernationOptions.t option
    ; metadata_options : LaunchTemplateInstanceMetadataOptions.t option
    ; enclave_options : LaunchTemplateEnclaveOptions.t option
    }

  let make
      ?kernel_id
      ?ebs_optimized
      ?iam_instance_profile
      ?(block_device_mappings = [])
      ?(network_interfaces = [])
      ?image_id
      ?instance_type
      ?key_name
      ?monitoring
      ?placement
      ?ram_disk_id
      ?disable_api_termination
      ?instance_initiated_shutdown_behavior
      ?user_data
      ?(tag_specifications = [])
      ?(elastic_gpu_specifications = [])
      ?(elastic_inference_accelerators = [])
      ?(security_group_ids = [])
      ?(security_groups = [])
      ?instance_market_options
      ?credit_specification
      ?cpu_options
      ?capacity_reservation_specification
      ?(license_specifications = [])
      ?hibernation_options
      ?metadata_options
      ?enclave_options
      () =
    { kernel_id
    ; ebs_optimized
    ; iam_instance_profile
    ; block_device_mappings
    ; network_interfaces
    ; image_id
    ; instance_type
    ; key_name
    ; monitoring
    ; placement
    ; ram_disk_id
    ; disable_api_termination
    ; instance_initiated_shutdown_behavior
    ; user_data
    ; tag_specifications
    ; elastic_gpu_specifications
    ; elastic_inference_accelerators
    ; security_group_ids
    ; security_groups
    ; instance_market_options
    ; credit_specification
    ; cpu_options
    ; capacity_reservation_specification
    ; license_specifications
    ; hibernation_options
    ; metadata_options
    ; enclave_options
    }

  let parse xml =
    Some
      { kernel_id = Aws.Util.option_bind (Aws.Xml.member "kernelId" xml) String.parse
      ; ebs_optimized =
          Aws.Util.option_bind (Aws.Xml.member "ebsOptimized" xml) Boolean.parse
      ; iam_instance_profile =
          Aws.Util.option_bind
            (Aws.Xml.member "iamInstanceProfile" xml)
            LaunchTemplateIamInstanceProfileSpecification.parse
      ; block_device_mappings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "blockDeviceMappingSet" xml)
               LaunchTemplateBlockDeviceMappingList.parse)
      ; network_interfaces =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "networkInterfaceSet" xml)
               LaunchTemplateInstanceNetworkInterfaceSpecificationList.parse)
      ; image_id = Aws.Util.option_bind (Aws.Xml.member "imageId" xml) String.parse
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) InstanceType.parse
      ; key_name = Aws.Util.option_bind (Aws.Xml.member "keyName" xml) String.parse
      ; monitoring =
          Aws.Util.option_bind
            (Aws.Xml.member "monitoring" xml)
            LaunchTemplatesMonitoring.parse
      ; placement =
          Aws.Util.option_bind
            (Aws.Xml.member "placement" xml)
            LaunchTemplatePlacement.parse
      ; ram_disk_id = Aws.Util.option_bind (Aws.Xml.member "ramDiskId" xml) String.parse
      ; disable_api_termination =
          Aws.Util.option_bind (Aws.Xml.member "disableApiTermination" xml) Boolean.parse
      ; instance_initiated_shutdown_behavior =
          Aws.Util.option_bind
            (Aws.Xml.member "instanceInitiatedShutdownBehavior" xml)
            ShutdownBehavior.parse
      ; user_data = Aws.Util.option_bind (Aws.Xml.member "userData" xml) String.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "tagSpecificationSet" xml)
               LaunchTemplateTagSpecificationList.parse)
      ; elastic_gpu_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "elasticGpuSpecificationSet" xml)
               ElasticGpuSpecificationResponseList.parse)
      ; elastic_inference_accelerators =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "elasticInferenceAcceleratorSet" xml)
               LaunchTemplateElasticInferenceAcceleratorResponseList.parse)
      ; security_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "securityGroupIdSet" xml)
               ValueStringList.parse)
      ; security_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "securityGroupSet" xml)
               ValueStringList.parse)
      ; instance_market_options =
          Aws.Util.option_bind
            (Aws.Xml.member "instanceMarketOptions" xml)
            LaunchTemplateInstanceMarketOptions.parse
      ; credit_specification =
          Aws.Util.option_bind
            (Aws.Xml.member "creditSpecification" xml)
            CreditSpecification.parse
      ; cpu_options =
          Aws.Util.option_bind
            (Aws.Xml.member "cpuOptions" xml)
            LaunchTemplateCpuOptions.parse
      ; capacity_reservation_specification =
          Aws.Util.option_bind
            (Aws.Xml.member "capacityReservationSpecification" xml)
            LaunchTemplateCapacityReservationSpecificationResponse.parse
      ; license_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "licenseSet" xml)
               LaunchTemplateLicenseList.parse)
      ; hibernation_options =
          Aws.Util.option_bind
            (Aws.Xml.member "hibernationOptions" xml)
            LaunchTemplateHibernationOptions.parse
      ; metadata_options =
          Aws.Util.option_bind
            (Aws.Xml.member "metadataOptions" xml)
            LaunchTemplateInstanceMetadataOptions.parse
      ; enclave_options =
          Aws.Util.option_bind
            (Aws.Xml.member "enclaveOptions" xml)
            LaunchTemplateEnclaveOptions.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enclave_options (fun f ->
               Aws.Query.Pair ("EnclaveOptions", LaunchTemplateEnclaveOptions.to_query f))
         ; Aws.Util.option_map v.metadata_options (fun f ->
               Aws.Query.Pair
                 ("MetadataOptions", LaunchTemplateInstanceMetadataOptions.to_query f))
         ; Aws.Util.option_map v.hibernation_options (fun f ->
               Aws.Query.Pair
                 ("HibernationOptions", LaunchTemplateHibernationOptions.to_query f))
         ; Some
             (Aws.Query.Pair
                ("LicenseSet", LaunchTemplateLicenseList.to_query v.license_specifications))
         ; Aws.Util.option_map v.capacity_reservation_specification (fun f ->
               Aws.Query.Pair
                 ( "CapacityReservationSpecification"
                 , LaunchTemplateCapacityReservationSpecificationResponse.to_query f ))
         ; Aws.Util.option_map v.cpu_options (fun f ->
               Aws.Query.Pair ("CpuOptions", LaunchTemplateCpuOptions.to_query f))
         ; Aws.Util.option_map v.credit_specification (fun f ->
               Aws.Query.Pair ("CreditSpecification", CreditSpecification.to_query f))
         ; Aws.Util.option_map v.instance_market_options (fun f ->
               Aws.Query.Pair
                 ("InstanceMarketOptions", LaunchTemplateInstanceMarketOptions.to_query f))
         ; Some
             (Aws.Query.Pair
                ("SecurityGroupSet", ValueStringList.to_query v.security_groups))
         ; Some
             (Aws.Query.Pair
                ("SecurityGroupIdSet", ValueStringList.to_query v.security_group_ids))
         ; Some
             (Aws.Query.Pair
                ( "ElasticInferenceAcceleratorSet"
                , LaunchTemplateElasticInferenceAcceleratorResponseList.to_query
                    v.elastic_inference_accelerators ))
         ; Some
             (Aws.Query.Pair
                ( "ElasticGpuSpecificationSet"
                , ElasticGpuSpecificationResponseList.to_query
                    v.elastic_gpu_specifications ))
         ; Some
             (Aws.Query.Pair
                ( "TagSpecificationSet"
                , LaunchTemplateTagSpecificationList.to_query v.tag_specifications ))
         ; Aws.Util.option_map v.user_data (fun f ->
               Aws.Query.Pair ("UserData", String.to_query f))
         ; Aws.Util.option_map v.instance_initiated_shutdown_behavior (fun f ->
               Aws.Query.Pair
                 ("InstanceInitiatedShutdownBehavior", ShutdownBehavior.to_query f))
         ; Aws.Util.option_map v.disable_api_termination (fun f ->
               Aws.Query.Pair ("DisableApiTermination", Boolean.to_query f))
         ; Aws.Util.option_map v.ram_disk_id (fun f ->
               Aws.Query.Pair ("RamDiskId", String.to_query f))
         ; Aws.Util.option_map v.placement (fun f ->
               Aws.Query.Pair ("Placement", LaunchTemplatePlacement.to_query f))
         ; Aws.Util.option_map v.monitoring (fun f ->
               Aws.Query.Pair ("Monitoring", LaunchTemplatesMonitoring.to_query f))
         ; Aws.Util.option_map v.key_name (fun f ->
               Aws.Query.Pair ("KeyName", String.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", InstanceType.to_query f))
         ; Aws.Util.option_map v.image_id (fun f ->
               Aws.Query.Pair ("ImageId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "NetworkInterfaceSet"
                , LaunchTemplateInstanceNetworkInterfaceSpecificationList.to_query
                    v.network_interfaces ))
         ; Some
             (Aws.Query.Pair
                ( "BlockDeviceMappingSet"
                , LaunchTemplateBlockDeviceMappingList.to_query v.block_device_mappings ))
         ; Aws.Util.option_map v.iam_instance_profile (fun f ->
               Aws.Query.Pair
                 ( "IamInstanceProfile"
                 , LaunchTemplateIamInstanceProfileSpecification.to_query f ))
         ; Aws.Util.option_map v.ebs_optimized (fun f ->
               Aws.Query.Pair ("EbsOptimized", Boolean.to_query f))
         ; Aws.Util.option_map v.kernel_id (fun f ->
               Aws.Query.Pair ("KernelId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enclave_options (fun f ->
               "enclaveOptions", LaunchTemplateEnclaveOptions.to_json f)
         ; Aws.Util.option_map v.metadata_options (fun f ->
               "metadataOptions", LaunchTemplateInstanceMetadataOptions.to_json f)
         ; Aws.Util.option_map v.hibernation_options (fun f ->
               "hibernationOptions", LaunchTemplateHibernationOptions.to_json f)
         ; Some ("licenseSet", LaunchTemplateLicenseList.to_json v.license_specifications)
         ; Aws.Util.option_map v.capacity_reservation_specification (fun f ->
               ( "capacityReservationSpecification"
               , LaunchTemplateCapacityReservationSpecificationResponse.to_json f ))
         ; Aws.Util.option_map v.cpu_options (fun f ->
               "cpuOptions", LaunchTemplateCpuOptions.to_json f)
         ; Aws.Util.option_map v.credit_specification (fun f ->
               "creditSpecification", CreditSpecification.to_json f)
         ; Aws.Util.option_map v.instance_market_options (fun f ->
               "instanceMarketOptions", LaunchTemplateInstanceMarketOptions.to_json f)
         ; Some ("securityGroupSet", ValueStringList.to_json v.security_groups)
         ; Some ("securityGroupIdSet", ValueStringList.to_json v.security_group_ids)
         ; Some
             ( "elasticInferenceAcceleratorSet"
             , LaunchTemplateElasticInferenceAcceleratorResponseList.to_json
                 v.elastic_inference_accelerators )
         ; Some
             ( "elasticGpuSpecificationSet"
             , ElasticGpuSpecificationResponseList.to_json v.elastic_gpu_specifications )
         ; Some
             ( "tagSpecificationSet"
             , LaunchTemplateTagSpecificationList.to_json v.tag_specifications )
         ; Aws.Util.option_map v.user_data (fun f -> "userData", String.to_json f)
         ; Aws.Util.option_map v.instance_initiated_shutdown_behavior (fun f ->
               "instanceInitiatedShutdownBehavior", ShutdownBehavior.to_json f)
         ; Aws.Util.option_map v.disable_api_termination (fun f ->
               "disableApiTermination", Boolean.to_json f)
         ; Aws.Util.option_map v.ram_disk_id (fun f -> "ramDiskId", String.to_json f)
         ; Aws.Util.option_map v.placement (fun f ->
               "placement", LaunchTemplatePlacement.to_json f)
         ; Aws.Util.option_map v.monitoring (fun f ->
               "monitoring", LaunchTemplatesMonitoring.to_json f)
         ; Aws.Util.option_map v.key_name (fun f -> "keyName", String.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f ->
               "instanceType", InstanceType.to_json f)
         ; Aws.Util.option_map v.image_id (fun f -> "imageId", String.to_json f)
         ; Some
             ( "networkInterfaceSet"
             , LaunchTemplateInstanceNetworkInterfaceSpecificationList.to_json
                 v.network_interfaces )
         ; Some
             ( "blockDeviceMappingSet"
             , LaunchTemplateBlockDeviceMappingList.to_json v.block_device_mappings )
         ; Aws.Util.option_map v.iam_instance_profile (fun f ->
               ( "iamInstanceProfile"
               , LaunchTemplateIamInstanceProfileSpecification.to_json f ))
         ; Aws.Util.option_map v.ebs_optimized (fun f ->
               "ebsOptimized", Boolean.to_json f)
         ; Aws.Util.option_map v.kernel_id (fun f -> "kernelId", String.to_json f)
         ])

  let of_json j =
    { kernel_id = Aws.Util.option_map (Aws.Json.lookup j "kernelId") String.of_json
    ; ebs_optimized =
        Aws.Util.option_map (Aws.Json.lookup j "ebsOptimized") Boolean.of_json
    ; iam_instance_profile =
        Aws.Util.option_map
          (Aws.Json.lookup j "iamInstanceProfile")
          LaunchTemplateIamInstanceProfileSpecification.of_json
    ; block_device_mappings =
        LaunchTemplateBlockDeviceMappingList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "blockDeviceMappingSet"))
    ; network_interfaces =
        LaunchTemplateInstanceNetworkInterfaceSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "networkInterfaceSet"))
    ; image_id = Aws.Util.option_map (Aws.Json.lookup j "imageId") String.of_json
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") InstanceType.of_json
    ; key_name = Aws.Util.option_map (Aws.Json.lookup j "keyName") String.of_json
    ; monitoring =
        Aws.Util.option_map
          (Aws.Json.lookup j "monitoring")
          LaunchTemplatesMonitoring.of_json
    ; placement =
        Aws.Util.option_map
          (Aws.Json.lookup j "placement")
          LaunchTemplatePlacement.of_json
    ; ram_disk_id = Aws.Util.option_map (Aws.Json.lookup j "ramDiskId") String.of_json
    ; disable_api_termination =
        Aws.Util.option_map (Aws.Json.lookup j "disableApiTermination") Boolean.of_json
    ; instance_initiated_shutdown_behavior =
        Aws.Util.option_map
          (Aws.Json.lookup j "instanceInitiatedShutdownBehavior")
          ShutdownBehavior.of_json
    ; user_data = Aws.Util.option_map (Aws.Json.lookup j "userData") String.of_json
    ; tag_specifications =
        LaunchTemplateTagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSpecificationSet"))
    ; elastic_gpu_specifications =
        ElasticGpuSpecificationResponseList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "elasticGpuSpecificationSet"))
    ; elastic_inference_accelerators =
        LaunchTemplateElasticInferenceAcceleratorResponseList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "elasticInferenceAcceleratorSet"))
    ; security_group_ids =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "securityGroupIdSet"))
    ; security_groups =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "securityGroupSet"))
    ; instance_market_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "instanceMarketOptions")
          LaunchTemplateInstanceMarketOptions.of_json
    ; credit_specification =
        Aws.Util.option_map
          (Aws.Json.lookup j "creditSpecification")
          CreditSpecification.of_json
    ; cpu_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "cpuOptions")
          LaunchTemplateCpuOptions.of_json
    ; capacity_reservation_specification =
        Aws.Util.option_map
          (Aws.Json.lookup j "capacityReservationSpecification")
          LaunchTemplateCapacityReservationSpecificationResponse.of_json
    ; license_specifications =
        LaunchTemplateLicenseList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "licenseSet"))
    ; hibernation_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "hibernationOptions")
          LaunchTemplateHibernationOptions.of_json
    ; metadata_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "metadataOptions")
          LaunchTemplateInstanceMetadataOptions.of_json
    ; enclave_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "enclaveOptions")
          LaunchTemplateEnclaveOptions.of_json
    }
end

module TelemetryStatus = struct
  type t =
    | UP
    | DOWN

  let str_to_t = [ "DOWN", DOWN; "UP", UP ]

  let t_to_str = [ DOWN, "DOWN"; UP, "UP" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module VgwTelemetry = struct
  type t =
    { accepted_route_count : Integer.t option
    ; last_status_change : DateTime.t option
    ; outside_ip_address : String.t option
    ; status : TelemetryStatus.t option
    ; status_message : String.t option
    ; certificate_arn : String.t option
    }

  let make
      ?accepted_route_count
      ?last_status_change
      ?outside_ip_address
      ?status
      ?status_message
      ?certificate_arn
      () =
    { accepted_route_count
    ; last_status_change
    ; outside_ip_address
    ; status
    ; status_message
    ; certificate_arn
    }

  let parse xml =
    Some
      { accepted_route_count =
          Aws.Util.option_bind (Aws.Xml.member "acceptedRouteCount" xml) Integer.parse
      ; last_status_change =
          Aws.Util.option_bind (Aws.Xml.member "lastStatusChange" xml) DateTime.parse
      ; outside_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "outsideIpAddress" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "status" xml) TelemetryStatus.parse
      ; status_message =
          Aws.Util.option_bind (Aws.Xml.member "statusMessage" xml) String.parse
      ; certificate_arn =
          Aws.Util.option_bind (Aws.Xml.member "certificateArn" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.certificate_arn (fun f ->
               Aws.Query.Pair ("CertificateArn", String.to_query f))
         ; Aws.Util.option_map v.status_message (fun f ->
               Aws.Query.Pair ("StatusMessage", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", TelemetryStatus.to_query f))
         ; Aws.Util.option_map v.outside_ip_address (fun f ->
               Aws.Query.Pair ("OutsideIpAddress", String.to_query f))
         ; Aws.Util.option_map v.last_status_change (fun f ->
               Aws.Query.Pair ("LastStatusChange", DateTime.to_query f))
         ; Aws.Util.option_map v.accepted_route_count (fun f ->
               Aws.Query.Pair ("AcceptedRouteCount", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.certificate_arn (fun f ->
               "certificateArn", String.to_json f)
         ; Aws.Util.option_map v.status_message (fun f ->
               "statusMessage", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "status", TelemetryStatus.to_json f)
         ; Aws.Util.option_map v.outside_ip_address (fun f ->
               "outsideIpAddress", String.to_json f)
         ; Aws.Util.option_map v.last_status_change (fun f ->
               "lastStatusChange", DateTime.to_json f)
         ; Aws.Util.option_map v.accepted_route_count (fun f ->
               "acceptedRouteCount", Integer.to_json f)
         ])

  let of_json j =
    { accepted_route_count =
        Aws.Util.option_map (Aws.Json.lookup j "acceptedRouteCount") Integer.of_json
    ; last_status_change =
        Aws.Util.option_map (Aws.Json.lookup j "lastStatusChange") DateTime.of_json
    ; outside_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "outsideIpAddress") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "status") TelemetryStatus.of_json
    ; status_message =
        Aws.Util.option_map (Aws.Json.lookup j "statusMessage") String.of_json
    ; certificate_arn =
        Aws.Util.option_map (Aws.Json.lookup j "certificateArn") String.of_json
    }
end

module VgwTelemetryList = struct
  type t = VgwTelemetry.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map VgwTelemetry.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list VgwTelemetry.to_query v

  let to_json v = `List (List.map VgwTelemetry.to_json v)

  let of_json j = Aws.Json.to_list VgwTelemetry.of_json j
end

module Region = struct
  type t =
    { endpoint : String.t option
    ; region_name : String.t option
    ; opt_in_status : String.t option
    }

  let make ?endpoint ?region_name ?opt_in_status () =
    { endpoint; region_name; opt_in_status }

  let parse xml =
    Some
      { endpoint = Aws.Util.option_bind (Aws.Xml.member "regionEndpoint" xml) String.parse
      ; region_name = Aws.Util.option_bind (Aws.Xml.member "regionName" xml) String.parse
      ; opt_in_status =
          Aws.Util.option_bind (Aws.Xml.member "optInStatus" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.opt_in_status (fun f ->
               Aws.Query.Pair ("OptInStatus", String.to_query f))
         ; Aws.Util.option_map v.region_name (fun f ->
               Aws.Query.Pair ("RegionName", String.to_query f))
         ; Aws.Util.option_map v.endpoint (fun f ->
               Aws.Query.Pair ("RegionEndpoint", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.opt_in_status (fun f -> "optInStatus", String.to_json f)
         ; Aws.Util.option_map v.region_name (fun f -> "regionName", String.to_json f)
         ; Aws.Util.option_map v.endpoint (fun f -> "regionEndpoint", String.to_json f)
         ])

  let of_json j =
    { endpoint = Aws.Util.option_map (Aws.Json.lookup j "regionEndpoint") String.of_json
    ; region_name = Aws.Util.option_map (Aws.Json.lookup j "regionName") String.of_json
    ; opt_in_status = Aws.Util.option_map (Aws.Json.lookup j "optInStatus") String.of_json
    }
end

module RegionList = struct
  type t = Region.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map Region.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Region.to_query v

  let to_json v = `List (List.map Region.to_json v)

  let of_json j = Aws.Json.to_list Region.of_json j
end

module LicenseConfigurationRequest = struct
  type t = { license_configuration_arn : String.t option }

  let make ?license_configuration_arn () = { license_configuration_arn }

  let parse xml =
    Some
      { license_configuration_arn =
          Aws.Util.option_bind (Aws.Xml.member "LicenseConfigurationArn" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.license_configuration_arn (fun f ->
               Aws.Query.Pair ("LicenseConfigurationArn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.license_configuration_arn (fun f ->
               "LicenseConfigurationArn", String.to_json f)
         ])

  let of_json j =
    { license_configuration_arn =
        Aws.Util.option_map (Aws.Json.lookup j "LicenseConfigurationArn") String.of_json
    }
end

module LicenseSpecificationListRequest = struct
  type t = LicenseConfigurationRequest.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map LicenseConfigurationRequest.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list LicenseConfigurationRequest.to_query v

  let to_json v = `List (List.map LicenseConfigurationRequest.to_json v)

  let of_json j = Aws.Json.to_list LicenseConfigurationRequest.of_json j
end

module CancelBatchErrorCode = struct
  type t =
    | FleetRequestIdDoesNotExist
    | FleetRequestIdMalformed
    | FleetRequestNotInCancellableState
    | UnexpectedError

  let str_to_t =
    [ "unexpectedError", UnexpectedError
    ; "fleetRequestNotInCancellableState", FleetRequestNotInCancellableState
    ; "fleetRequestIdMalformed", FleetRequestIdMalformed
    ; "fleetRequestIdDoesNotExist", FleetRequestIdDoesNotExist
    ]

  let t_to_str =
    [ UnexpectedError, "unexpectedError"
    ; FleetRequestNotInCancellableState, "fleetRequestNotInCancellableState"
    ; FleetRequestIdMalformed, "fleetRequestIdMalformed"
    ; FleetRequestIdDoesNotExist, "fleetRequestIdDoesNotExist"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module Phase1EncryptionAlgorithmsListValue = struct
  type t = { value : String.t option }

  let make ?value () = { value }

  let parse xml =
    Some { value = Aws.Util.option_bind (Aws.Xml.member "value" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f -> "value", String.to_json f) ])

  let of_json j =
    { value = Aws.Util.option_map (Aws.Json.lookup j "value") String.of_json }
end

module Phase1EncryptionAlgorithmsList = struct
  type t = Phase1EncryptionAlgorithmsListValue.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map Phase1EncryptionAlgorithmsListValue.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Phase1EncryptionAlgorithmsListValue.to_query v

  let to_json v = `List (List.map Phase1EncryptionAlgorithmsListValue.to_json v)

  let of_json j = Aws.Json.to_list Phase1EncryptionAlgorithmsListValue.of_json j
end

module PeeringConnectionOptionsRequest = struct
  type t =
    { allow_dns_resolution_from_remote_vpc : Boolean.t option
    ; allow_egress_from_local_classic_link_to_remote_vpc : Boolean.t option
    ; allow_egress_from_local_vpc_to_remote_classic_link : Boolean.t option
    }

  let make
      ?allow_dns_resolution_from_remote_vpc
      ?allow_egress_from_local_classic_link_to_remote_vpc
      ?allow_egress_from_local_vpc_to_remote_classic_link
      () =
    { allow_dns_resolution_from_remote_vpc
    ; allow_egress_from_local_classic_link_to_remote_vpc
    ; allow_egress_from_local_vpc_to_remote_classic_link
    }

  let parse xml =
    Some
      { allow_dns_resolution_from_remote_vpc =
          Aws.Util.option_bind
            (Aws.Xml.member "AllowDnsResolutionFromRemoteVpc" xml)
            Boolean.parse
      ; allow_egress_from_local_classic_link_to_remote_vpc =
          Aws.Util.option_bind
            (Aws.Xml.member "AllowEgressFromLocalClassicLinkToRemoteVpc" xml)
            Boolean.parse
      ; allow_egress_from_local_vpc_to_remote_classic_link =
          Aws.Util.option_bind
            (Aws.Xml.member "AllowEgressFromLocalVpcToRemoteClassicLink" xml)
            Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map
             v.allow_egress_from_local_vpc_to_remote_classic_link
             (fun f ->
               Aws.Query.Pair
                 ("AllowEgressFromLocalVpcToRemoteClassicLink", Boolean.to_query f))
         ; Aws.Util.option_map
             v.allow_egress_from_local_classic_link_to_remote_vpc
             (fun f ->
               Aws.Query.Pair
                 ("AllowEgressFromLocalClassicLinkToRemoteVpc", Boolean.to_query f))
         ; Aws.Util.option_map v.allow_dns_resolution_from_remote_vpc (fun f ->
               Aws.Query.Pair ("AllowDnsResolutionFromRemoteVpc", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map
             v.allow_egress_from_local_vpc_to_remote_classic_link
             (fun f -> "AllowEgressFromLocalVpcToRemoteClassicLink", Boolean.to_json f)
         ; Aws.Util.option_map
             v.allow_egress_from_local_classic_link_to_remote_vpc
             (fun f -> "AllowEgressFromLocalClassicLinkToRemoteVpc", Boolean.to_json f)
         ; Aws.Util.option_map v.allow_dns_resolution_from_remote_vpc (fun f ->
               "AllowDnsResolutionFromRemoteVpc", Boolean.to_json f)
         ])

  let of_json j =
    { allow_dns_resolution_from_remote_vpc =
        Aws.Util.option_map
          (Aws.Json.lookup j "AllowDnsResolutionFromRemoteVpc")
          Boolean.of_json
    ; allow_egress_from_local_classic_link_to_remote_vpc =
        Aws.Util.option_map
          (Aws.Json.lookup j "AllowEgressFromLocalClassicLinkToRemoteVpc")
          Boolean.of_json
    ; allow_egress_from_local_vpc_to_remote_classic_link =
        Aws.Util.option_map
          (Aws.Json.lookup j "AllowEgressFromLocalVpcToRemoteClassicLink")
          Boolean.of_json
    }
end

module LaunchTemplateElasticInferenceAccelerator = struct
  type t =
    { type_ : String.t
    ; count : Integer.t option
    }

  let make ~type_ ?count () = { type_; count }

  let parse xml =
    Some
      { type_ =
          Aws.Xml.required
            "Type"
            (Aws.Util.option_bind (Aws.Xml.member "Type" xml) String.parse)
      ; count = Aws.Util.option_bind (Aws.Xml.member "Count" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.count (fun f ->
               Aws.Query.Pair ("Count", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Type", String.to_query v.type_))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.count (fun f -> "Count", Integer.to_json f)
         ; Some ("Type", String.to_json v.type_)
         ])

  let of_json j =
    { type_ = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Type"))
    ; count = Aws.Util.option_map (Aws.Json.lookup j "Count") Integer.of_json
    }
end

module AttachmentStatus = struct
  type t =
    | Attaching
    | Attached
    | Detaching
    | Detached

  let str_to_t =
    [ "detached", Detached
    ; "detaching", Detaching
    ; "attached", Attached
    ; "attaching", Attaching
    ]

  let t_to_str =
    [ Detached, "detached"
    ; Detaching, "detaching"
    ; Attached, "attached"
    ; Attaching, "attaching"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module InternetGatewayAttachment = struct
  type t =
    { state : AttachmentStatus.t
    ; vpc_id : String.t
    }

  let make ~state ~vpc_id () = { state; vpc_id }

  let parse xml =
    Some
      { state =
          Aws.Xml.required
            "state"
            (Aws.Util.option_bind (Aws.Xml.member "state" xml) AttachmentStatus.parse)
      ; vpc_id =
          Aws.Xml.required
            "vpcId"
            (Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ; Some (Aws.Query.Pair ("State", AttachmentStatus.to_query v.state))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("vpcId", String.to_json v.vpc_id)
         ; Some ("state", AttachmentStatus.to_json v.state)
         ])

  let of_json j =
    { state =
        AttachmentStatus.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "state"))
    ; vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "vpcId"))
    }
end

module InternetGatewayAttachmentList = struct
  type t = InternetGatewayAttachment.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map InternetGatewayAttachment.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list InternetGatewayAttachment.to_query v

  let to_json v = `List (List.map InternetGatewayAttachment.to_json v)

  let of_json j = Aws.Json.to_list InternetGatewayAttachment.of_json j
end

module EgressOnlyInternetGateway = struct
  type t =
    { attachments : InternetGatewayAttachmentList.t
    ; egress_only_internet_gateway_id : String.t option
    ; tags : TagList.t
    }

  let make ?(attachments = []) ?egress_only_internet_gateway_id ?(tags = []) () =
    { attachments; egress_only_internet_gateway_id; tags }

  let parse xml =
    Some
      { attachments =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "attachmentSet" xml)
               InternetGatewayAttachmentList.parse)
      ; egress_only_internet_gateway_id =
          Aws.Util.option_bind
            (Aws.Xml.member "egressOnlyInternetGatewayId" xml)
            String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.egress_only_internet_gateway_id (fun f ->
               Aws.Query.Pair ("EgressOnlyInternetGatewayId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("AttachmentSet", InternetGatewayAttachmentList.to_query v.attachments))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.egress_only_internet_gateway_id (fun f ->
               "egressOnlyInternetGatewayId", String.to_json f)
         ; Some ("attachmentSet", InternetGatewayAttachmentList.to_json v.attachments)
         ])

  let of_json j =
    { attachments =
        InternetGatewayAttachmentList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "attachmentSet"))
    ; egress_only_internet_gateway_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "egressOnlyInternetGatewayId")
          String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module EgressOnlyInternetGatewayList = struct
  type t = EgressOnlyInternetGateway.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map EgressOnlyInternetGateway.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list EgressOnlyInternetGateway.to_query v

  let to_json v = `List (List.map EgressOnlyInternetGateway.to_json v)

  let of_json j = Aws.Json.to_list EgressOnlyInternetGateway.of_json j
end

module DescribeEgressOnlyInternetGatewaysResult = struct
  type t =
    { egress_only_internet_gateways : EgressOnlyInternetGatewayList.t
    ; next_token : String.t option
    }

  let make ?(egress_only_internet_gateways = []) ?next_token () =
    { egress_only_internet_gateways; next_token }

  let parse xml =
    Some
      { egress_only_internet_gateways =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "egressOnlyInternetGatewaySet" xml)
               EgressOnlyInternetGatewayList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "EgressOnlyInternetGatewaySet"
                , EgressOnlyInternetGatewayList.to_query v.egress_only_internet_gateways
                ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "egressOnlyInternetGatewaySet"
             , EgressOnlyInternetGatewayList.to_json v.egress_only_internet_gateways )
         ])

  let of_json j =
    { egress_only_internet_gateways =
        EgressOnlyInternetGatewayList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "egressOnlyInternetGatewaySet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module ConnectionNotificationIdsList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DeleteVpcEndpointConnectionNotificationsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; connection_notification_ids : ConnectionNotificationIdsList.t
    }

  let make ?dry_run ~connection_notification_ids () =
    { dry_run; connection_notification_ids }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; connection_notification_ids =
          Aws.Xml.required
            "ConnectionNotificationId"
            (Aws.Util.option_bind
               (Aws.Xml.member "ConnectionNotificationId" xml)
               ConnectionNotificationIdsList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "ConnectionNotificationId"
                , ConnectionNotificationIdsList.to_query v.connection_notification_ids ))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "ConnectionNotificationId"
             , ConnectionNotificationIdsList.to_json v.connection_notification_ids )
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; connection_notification_ids =
        ConnectionNotificationIdsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ConnectionNotificationId"))
    }
end

module NetworkInterfaceType = struct
  type t =
    | Interface
    | NatGateway
    | Efa

  let str_to_t = [ "efa", Efa; "natGateway", NatGateway; "interface", Interface ]

  let t_to_str = [ Efa, "efa"; NatGateway, "natGateway"; Interface, "interface" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module NetworkInterfaceStatus = struct
  type t =
    | Available
    | Associated
    | Attaching
    | In_use
    | Detaching

  let str_to_t =
    [ "detaching", Detaching
    ; "in-use", In_use
    ; "attaching", Attaching
    ; "associated", Associated
    ; "available", Available
    ]

  let t_to_str =
    [ Detaching, "detaching"
    ; In_use, "in-use"
    ; Attaching, "attaching"
    ; Associated, "associated"
    ; Available, "available"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module NetworkInterfaceAssociation = struct
  type t =
    { allocation_id : String.t option
    ; association_id : String.t option
    ; ip_owner_id : String.t option
    ; public_dns_name : String.t option
    ; public_ip : String.t option
    ; customer_owned_ip : String.t option
    ; carrier_ip : String.t option
    }

  let make
      ?allocation_id
      ?association_id
      ?ip_owner_id
      ?public_dns_name
      ?public_ip
      ?customer_owned_ip
      ?carrier_ip
      () =
    { allocation_id
    ; association_id
    ; ip_owner_id
    ; public_dns_name
    ; public_ip
    ; customer_owned_ip
    ; carrier_ip
    }

  let parse xml =
    Some
      { allocation_id =
          Aws.Util.option_bind (Aws.Xml.member "allocationId" xml) String.parse
      ; association_id =
          Aws.Util.option_bind (Aws.Xml.member "associationId" xml) String.parse
      ; ip_owner_id = Aws.Util.option_bind (Aws.Xml.member "ipOwnerId" xml) String.parse
      ; public_dns_name =
          Aws.Util.option_bind (Aws.Xml.member "publicDnsName" xml) String.parse
      ; public_ip = Aws.Util.option_bind (Aws.Xml.member "publicIp" xml) String.parse
      ; customer_owned_ip =
          Aws.Util.option_bind (Aws.Xml.member "customerOwnedIp" xml) String.parse
      ; carrier_ip = Aws.Util.option_bind (Aws.Xml.member "carrierIp" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.carrier_ip (fun f ->
               Aws.Query.Pair ("CarrierIp", String.to_query f))
         ; Aws.Util.option_map v.customer_owned_ip (fun f ->
               Aws.Query.Pair ("CustomerOwnedIp", String.to_query f))
         ; Aws.Util.option_map v.public_ip (fun f ->
               Aws.Query.Pair ("PublicIp", String.to_query f))
         ; Aws.Util.option_map v.public_dns_name (fun f ->
               Aws.Query.Pair ("PublicDnsName", String.to_query f))
         ; Aws.Util.option_map v.ip_owner_id (fun f ->
               Aws.Query.Pair ("IpOwnerId", String.to_query f))
         ; Aws.Util.option_map v.association_id (fun f ->
               Aws.Query.Pair ("AssociationId", String.to_query f))
         ; Aws.Util.option_map v.allocation_id (fun f ->
               Aws.Query.Pair ("AllocationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.carrier_ip (fun f -> "carrierIp", String.to_json f)
         ; Aws.Util.option_map v.customer_owned_ip (fun f ->
               "customerOwnedIp", String.to_json f)
         ; Aws.Util.option_map v.public_ip (fun f -> "publicIp", String.to_json f)
         ; Aws.Util.option_map v.public_dns_name (fun f ->
               "publicDnsName", String.to_json f)
         ; Aws.Util.option_map v.ip_owner_id (fun f -> "ipOwnerId", String.to_json f)
         ; Aws.Util.option_map v.association_id (fun f ->
               "associationId", String.to_json f)
         ; Aws.Util.option_map v.allocation_id (fun f -> "allocationId", String.to_json f)
         ])

  let of_json j =
    { allocation_id =
        Aws.Util.option_map (Aws.Json.lookup j "allocationId") String.of_json
    ; association_id =
        Aws.Util.option_map (Aws.Json.lookup j "associationId") String.of_json
    ; ip_owner_id = Aws.Util.option_map (Aws.Json.lookup j "ipOwnerId") String.of_json
    ; public_dns_name =
        Aws.Util.option_map (Aws.Json.lookup j "publicDnsName") String.of_json
    ; public_ip = Aws.Util.option_map (Aws.Json.lookup j "publicIp") String.of_json
    ; customer_owned_ip =
        Aws.Util.option_map (Aws.Json.lookup j "customerOwnedIp") String.of_json
    ; carrier_ip = Aws.Util.option_map (Aws.Json.lookup j "carrierIp") String.of_json
    }
end

module NetworkInterfacePrivateIpAddress = struct
  type t =
    { association : NetworkInterfaceAssociation.t option
    ; primary : Boolean.t option
    ; private_dns_name : String.t option
    ; private_ip_address : String.t option
    }

  let make ?association ?primary ?private_dns_name ?private_ip_address () =
    { association; primary; private_dns_name; private_ip_address }

  let parse xml =
    Some
      { association =
          Aws.Util.option_bind
            (Aws.Xml.member "association" xml)
            NetworkInterfaceAssociation.parse
      ; primary = Aws.Util.option_bind (Aws.Xml.member "primary" xml) Boolean.parse
      ; private_dns_name =
          Aws.Util.option_bind (Aws.Xml.member "privateDnsName" xml) String.parse
      ; private_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "privateIpAddress" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.private_ip_address (fun f ->
               Aws.Query.Pair ("PrivateIpAddress", String.to_query f))
         ; Aws.Util.option_map v.private_dns_name (fun f ->
               Aws.Query.Pair ("PrivateDnsName", String.to_query f))
         ; Aws.Util.option_map v.primary (fun f ->
               Aws.Query.Pair ("Primary", Boolean.to_query f))
         ; Aws.Util.option_map v.association (fun f ->
               Aws.Query.Pair ("Association", NetworkInterfaceAssociation.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.private_ip_address (fun f ->
               "privateIpAddress", String.to_json f)
         ; Aws.Util.option_map v.private_dns_name (fun f ->
               "privateDnsName", String.to_json f)
         ; Aws.Util.option_map v.primary (fun f -> "primary", Boolean.to_json f)
         ; Aws.Util.option_map v.association (fun f ->
               "association", NetworkInterfaceAssociation.to_json f)
         ])

  let of_json j =
    { association =
        Aws.Util.option_map
          (Aws.Json.lookup j "association")
          NetworkInterfaceAssociation.of_json
    ; primary = Aws.Util.option_map (Aws.Json.lookup j "primary") Boolean.of_json
    ; private_dns_name =
        Aws.Util.option_map (Aws.Json.lookup j "privateDnsName") String.of_json
    ; private_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "privateIpAddress") String.of_json
    }
end

module NetworkInterfacePrivateIpAddressList = struct
  type t = NetworkInterfacePrivateIpAddress.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map NetworkInterfacePrivateIpAddress.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list NetworkInterfacePrivateIpAddress.to_query v

  let to_json v = `List (List.map NetworkInterfacePrivateIpAddress.to_json v)

  let of_json j = Aws.Json.to_list NetworkInterfacePrivateIpAddress.of_json j
end

module NetworkInterfaceIpv6Address = struct
  type t = { ipv6_address : String.t option }

  let make ?ipv6_address () = { ipv6_address }

  let parse xml =
    Some
      { ipv6_address =
          Aws.Util.option_bind (Aws.Xml.member "ipv6Address" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ipv6_address (fun f ->
               Aws.Query.Pair ("Ipv6Address", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ipv6_address (fun f -> "ipv6Address", String.to_json f) ])

  let of_json j =
    { ipv6_address = Aws.Util.option_map (Aws.Json.lookup j "ipv6Address") String.of_json
    }
end

module NetworkInterfaceIpv6AddressesList = struct
  type t = NetworkInterfaceIpv6Address.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map NetworkInterfaceIpv6Address.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list NetworkInterfaceIpv6Address.to_query v

  let to_json v = `List (List.map NetworkInterfaceIpv6Address.to_json v)

  let of_json j = Aws.Json.to_list NetworkInterfaceIpv6Address.of_json j
end

module NetworkInterfaceAttachment = struct
  type t =
    { attach_time : DateTime.t option
    ; attachment_id : String.t option
    ; delete_on_termination : Boolean.t option
    ; device_index : Integer.t option
    ; network_card_index : Integer.t option
    ; instance_id : String.t option
    ; instance_owner_id : String.t option
    ; status : AttachmentStatus.t option
    }

  let make
      ?attach_time
      ?attachment_id
      ?delete_on_termination
      ?device_index
      ?network_card_index
      ?instance_id
      ?instance_owner_id
      ?status
      () =
    { attach_time
    ; attachment_id
    ; delete_on_termination
    ; device_index
    ; network_card_index
    ; instance_id
    ; instance_owner_id
    ; status
    }

  let parse xml =
    Some
      { attach_time =
          Aws.Util.option_bind (Aws.Xml.member "attachTime" xml) DateTime.parse
      ; attachment_id =
          Aws.Util.option_bind (Aws.Xml.member "attachmentId" xml) String.parse
      ; delete_on_termination =
          Aws.Util.option_bind (Aws.Xml.member "deleteOnTermination" xml) Boolean.parse
      ; device_index =
          Aws.Util.option_bind (Aws.Xml.member "deviceIndex" xml) Integer.parse
      ; network_card_index =
          Aws.Util.option_bind (Aws.Xml.member "networkCardIndex" xml) Integer.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      ; instance_owner_id =
          Aws.Util.option_bind (Aws.Xml.member "instanceOwnerId" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "status" xml) AttachmentStatus.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", AttachmentStatus.to_query f))
         ; Aws.Util.option_map v.instance_owner_id (fun f ->
               Aws.Query.Pair ("InstanceOwnerId", String.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.network_card_index (fun f ->
               Aws.Query.Pair ("NetworkCardIndex", Integer.to_query f))
         ; Aws.Util.option_map v.device_index (fun f ->
               Aws.Query.Pair ("DeviceIndex", Integer.to_query f))
         ; Aws.Util.option_map v.delete_on_termination (fun f ->
               Aws.Query.Pair ("DeleteOnTermination", Boolean.to_query f))
         ; Aws.Util.option_map v.attachment_id (fun f ->
               Aws.Query.Pair ("AttachmentId", String.to_query f))
         ; Aws.Util.option_map v.attach_time (fun f ->
               Aws.Query.Pair ("AttachTime", DateTime.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f -> "status", AttachmentStatus.to_json f)
         ; Aws.Util.option_map v.instance_owner_id (fun f ->
               "instanceOwnerId", String.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ; Aws.Util.option_map v.network_card_index (fun f ->
               "networkCardIndex", Integer.to_json f)
         ; Aws.Util.option_map v.device_index (fun f -> "deviceIndex", Integer.to_json f)
         ; Aws.Util.option_map v.delete_on_termination (fun f ->
               "deleteOnTermination", Boolean.to_json f)
         ; Aws.Util.option_map v.attachment_id (fun f -> "attachmentId", String.to_json f)
         ; Aws.Util.option_map v.attach_time (fun f -> "attachTime", DateTime.to_json f)
         ])

  let of_json j =
    { attach_time = Aws.Util.option_map (Aws.Json.lookup j "attachTime") DateTime.of_json
    ; attachment_id =
        Aws.Util.option_map (Aws.Json.lookup j "attachmentId") String.of_json
    ; delete_on_termination =
        Aws.Util.option_map (Aws.Json.lookup j "deleteOnTermination") Boolean.of_json
    ; device_index = Aws.Util.option_map (Aws.Json.lookup j "deviceIndex") Integer.of_json
    ; network_card_index =
        Aws.Util.option_map (Aws.Json.lookup j "networkCardIndex") Integer.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    ; instance_owner_id =
        Aws.Util.option_map (Aws.Json.lookup j "instanceOwnerId") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "status") AttachmentStatus.of_json
    }
end

module GroupIdentifier = struct
  type t =
    { group_name : String.t option
    ; group_id : String.t option
    }

  let make ?group_name ?group_id () = { group_name; group_id }

  let parse xml =
    Some
      { group_name = Aws.Util.option_bind (Aws.Xml.member "groupName" xml) String.parse
      ; group_id = Aws.Util.option_bind (Aws.Xml.member "groupId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.group_id (fun f ->
               Aws.Query.Pair ("GroupId", String.to_query f))
         ; Aws.Util.option_map v.group_name (fun f ->
               Aws.Query.Pair ("GroupName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.group_id (fun f -> "groupId", String.to_json f)
         ; Aws.Util.option_map v.group_name (fun f -> "groupName", String.to_json f)
         ])

  let of_json j =
    { group_name = Aws.Util.option_map (Aws.Json.lookup j "groupName") String.of_json
    ; group_id = Aws.Util.option_map (Aws.Json.lookup j "groupId") String.of_json
    }
end

module GroupIdentifierList = struct
  type t = GroupIdentifier.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map GroupIdentifier.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list GroupIdentifier.to_query v

  let to_json v = `List (List.map GroupIdentifier.to_json v)

  let of_json j = Aws.Json.to_list GroupIdentifier.of_json j
end

module NetworkInterface = struct
  type t =
    { association : NetworkInterfaceAssociation.t option
    ; attachment : NetworkInterfaceAttachment.t option
    ; availability_zone : String.t option
    ; description : String.t option
    ; groups : GroupIdentifierList.t
    ; interface_type : NetworkInterfaceType.t option
    ; ipv6_addresses : NetworkInterfaceIpv6AddressesList.t
    ; mac_address : String.t option
    ; network_interface_id : String.t option
    ; outpost_arn : String.t option
    ; owner_id : String.t option
    ; private_dns_name : String.t option
    ; private_ip_address : String.t option
    ; private_ip_addresses : NetworkInterfacePrivateIpAddressList.t
    ; requester_id : String.t option
    ; requester_managed : Boolean.t option
    ; source_dest_check : Boolean.t option
    ; status : NetworkInterfaceStatus.t option
    ; subnet_id : String.t option
    ; tag_set : TagList.t
    ; vpc_id : String.t option
    }

  let make
      ?association
      ?attachment
      ?availability_zone
      ?description
      ?(groups = [])
      ?interface_type
      ?(ipv6_addresses = [])
      ?mac_address
      ?network_interface_id
      ?outpost_arn
      ?owner_id
      ?private_dns_name
      ?private_ip_address
      ?(private_ip_addresses = [])
      ?requester_id
      ?requester_managed
      ?source_dest_check
      ?status
      ?subnet_id
      ?(tag_set = [])
      ?vpc_id
      () =
    { association
    ; attachment
    ; availability_zone
    ; description
    ; groups
    ; interface_type
    ; ipv6_addresses
    ; mac_address
    ; network_interface_id
    ; outpost_arn
    ; owner_id
    ; private_dns_name
    ; private_ip_address
    ; private_ip_addresses
    ; requester_id
    ; requester_managed
    ; source_dest_check
    ; status
    ; subnet_id
    ; tag_set
    ; vpc_id
    }

  let parse xml =
    Some
      { association =
          Aws.Util.option_bind
            (Aws.Xml.member "association" xml)
            NetworkInterfaceAssociation.parse
      ; attachment =
          Aws.Util.option_bind
            (Aws.Xml.member "attachment" xml)
            NetworkInterfaceAttachment.parse
      ; availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "groupSet" xml)
               GroupIdentifierList.parse)
      ; interface_type =
          Aws.Util.option_bind
            (Aws.Xml.member "interfaceType" xml)
            NetworkInterfaceType.parse
      ; ipv6_addresses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ipv6AddressesSet" xml)
               NetworkInterfaceIpv6AddressesList.parse)
      ; mac_address = Aws.Util.option_bind (Aws.Xml.member "macAddress" xml) String.parse
      ; network_interface_id =
          Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse
      ; outpost_arn = Aws.Util.option_bind (Aws.Xml.member "outpostArn" xml) String.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; private_dns_name =
          Aws.Util.option_bind (Aws.Xml.member "privateDnsName" xml) String.parse
      ; private_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "privateIpAddress" xml) String.parse
      ; private_ip_addresses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "privateIpAddressesSet" xml)
               NetworkInterfacePrivateIpAddressList.parse)
      ; requester_id =
          Aws.Util.option_bind (Aws.Xml.member "requesterId" xml) String.parse
      ; requester_managed =
          Aws.Util.option_bind (Aws.Xml.member "requesterManaged" xml) Boolean.parse
      ; source_dest_check =
          Aws.Util.option_bind (Aws.Xml.member "sourceDestCheck" xml) Boolean.parse
      ; status =
          Aws.Util.option_bind (Aws.Xml.member "status" xml) NetworkInterfaceStatus.parse
      ; subnet_id = Aws.Util.option_bind (Aws.Xml.member "subnetId" xml) String.parse
      ; tag_set =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tag_set))
         ; Aws.Util.option_map v.subnet_id (fun f ->
               Aws.Query.Pair ("SubnetId", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", NetworkInterfaceStatus.to_query f))
         ; Aws.Util.option_map v.source_dest_check (fun f ->
               Aws.Query.Pair ("SourceDestCheck", Boolean.to_query f))
         ; Aws.Util.option_map v.requester_managed (fun f ->
               Aws.Query.Pair ("RequesterManaged", Boolean.to_query f))
         ; Aws.Util.option_map v.requester_id (fun f ->
               Aws.Query.Pair ("RequesterId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "PrivateIpAddressesSet"
                , NetworkInterfacePrivateIpAddressList.to_query v.private_ip_addresses ))
         ; Aws.Util.option_map v.private_ip_address (fun f ->
               Aws.Query.Pair ("PrivateIpAddress", String.to_query f))
         ; Aws.Util.option_map v.private_dns_name (fun f ->
               Aws.Query.Pair ("PrivateDnsName", String.to_query f))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.outpost_arn (fun f ->
               Aws.Query.Pair ("OutpostArn", String.to_query f))
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               Aws.Query.Pair ("NetworkInterfaceId", String.to_query f))
         ; Aws.Util.option_map v.mac_address (fun f ->
               Aws.Query.Pair ("MacAddress", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "Ipv6AddressesSet"
                , NetworkInterfaceIpv6AddressesList.to_query v.ipv6_addresses ))
         ; Aws.Util.option_map v.interface_type (fun f ->
               Aws.Query.Pair ("InterfaceType", NetworkInterfaceType.to_query f))
         ; Some (Aws.Query.Pair ("GroupSet", GroupIdentifierList.to_query v.groups))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ; Aws.Util.option_map v.attachment (fun f ->
               Aws.Query.Pair ("Attachment", NetworkInterfaceAttachment.to_query f))
         ; Aws.Util.option_map v.association (fun f ->
               Aws.Query.Pair ("Association", NetworkInterfaceAssociation.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_id (fun f -> "vpcId", String.to_json f)
         ; Some ("tagSet", TagList.to_json v.tag_set)
         ; Aws.Util.option_map v.subnet_id (fun f -> "subnetId", String.to_json f)
         ; Aws.Util.option_map v.status (fun f ->
               "status", NetworkInterfaceStatus.to_json f)
         ; Aws.Util.option_map v.source_dest_check (fun f ->
               "sourceDestCheck", Boolean.to_json f)
         ; Aws.Util.option_map v.requester_managed (fun f ->
               "requesterManaged", Boolean.to_json f)
         ; Aws.Util.option_map v.requester_id (fun f -> "requesterId", String.to_json f)
         ; Some
             ( "privateIpAddressesSet"
             , NetworkInterfacePrivateIpAddressList.to_json v.private_ip_addresses )
         ; Aws.Util.option_map v.private_ip_address (fun f ->
               "privateIpAddress", String.to_json f)
         ; Aws.Util.option_map v.private_dns_name (fun f ->
               "privateDnsName", String.to_json f)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.outpost_arn (fun f -> "outpostArn", String.to_json f)
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               "networkInterfaceId", String.to_json f)
         ; Aws.Util.option_map v.mac_address (fun f -> "macAddress", String.to_json f)
         ; Some
             ( "ipv6AddressesSet"
             , NetworkInterfaceIpv6AddressesList.to_json v.ipv6_addresses )
         ; Aws.Util.option_map v.interface_type (fun f ->
               "interfaceType", NetworkInterfaceType.to_json f)
         ; Some ("groupSet", GroupIdentifierList.to_json v.groups)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ; Aws.Util.option_map v.attachment (fun f ->
               "attachment", NetworkInterfaceAttachment.to_json f)
         ; Aws.Util.option_map v.association (fun f ->
               "association", NetworkInterfaceAssociation.to_json f)
         ])

  let of_json j =
    { association =
        Aws.Util.option_map
          (Aws.Json.lookup j "association")
          NetworkInterfaceAssociation.of_json
    ; attachment =
        Aws.Util.option_map
          (Aws.Json.lookup j "attachment")
          NetworkInterfaceAttachment.of_json
    ; availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; groups =
        GroupIdentifierList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "groupSet"))
    ; interface_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "interfaceType")
          NetworkInterfaceType.of_json
    ; ipv6_addresses =
        NetworkInterfaceIpv6AddressesList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ipv6AddressesSet"))
    ; mac_address = Aws.Util.option_map (Aws.Json.lookup j "macAddress") String.of_json
    ; network_interface_id =
        Aws.Util.option_map (Aws.Json.lookup j "networkInterfaceId") String.of_json
    ; outpost_arn = Aws.Util.option_map (Aws.Json.lookup j "outpostArn") String.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; private_dns_name =
        Aws.Util.option_map (Aws.Json.lookup j "privateDnsName") String.of_json
    ; private_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "privateIpAddress") String.of_json
    ; private_ip_addresses =
        NetworkInterfacePrivateIpAddressList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "privateIpAddressesSet"))
    ; requester_id = Aws.Util.option_map (Aws.Json.lookup j "requesterId") String.of_json
    ; requester_managed =
        Aws.Util.option_map (Aws.Json.lookup j "requesterManaged") Boolean.of_json
    ; source_dest_check =
        Aws.Util.option_map (Aws.Json.lookup j "sourceDestCheck") Boolean.of_json
    ; status =
        Aws.Util.option_map (Aws.Json.lookup j "status") NetworkInterfaceStatus.of_json
    ; subnet_id = Aws.Util.option_map (Aws.Json.lookup j "subnetId") String.of_json
    ; tag_set = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "vpcId") String.of_json
    }
end

module NetworkInterfaceList = struct
  type t = NetworkInterface.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map NetworkInterface.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list NetworkInterface.to_query v

  let to_json v = `List (List.map NetworkInterface.to_json v)

  let of_json j = Aws.Json.to_list NetworkInterface.of_json j
end

module SpotInstanceStateFault = struct
  type t =
    { code : String.t option
    ; message : String.t option
    }

  let make ?code ?message () = { code; message }

  let parse xml =
    Some
      { code = Aws.Util.option_bind (Aws.Xml.member "code" xml) String.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair ("Code", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f)
         ; Aws.Util.option_map v.code (fun f -> "code", String.to_json f)
         ])

  let of_json j =
    { code = Aws.Util.option_map (Aws.Json.lookup j "code") String.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json
    }
end

module ExportClientVpnClientConfigurationResult = struct
  type t = { client_configuration : String.t option }

  let make ?client_configuration () = { client_configuration }

  let parse xml =
    Some
      { client_configuration =
          Aws.Util.option_bind (Aws.Xml.member "clientConfiguration" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_configuration (fun f ->
               Aws.Query.Pair ("ClientConfiguration", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_configuration (fun f ->
               "clientConfiguration", String.to_json f)
         ])

  let of_json j =
    { client_configuration =
        Aws.Util.option_map (Aws.Json.lookup j "clientConfiguration") String.of_json
    }
end

module DeleteNatGatewayResult = struct
  type t = { nat_gateway_id : String.t option }

  let make ?nat_gateway_id () = { nat_gateway_id }

  let parse xml =
    Some
      { nat_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "natGatewayId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.nat_gateway_id (fun f ->
               Aws.Query.Pair ("NatGatewayId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.nat_gateway_id (fun f ->
               "natGatewayId", String.to_json f)
         ])

  let of_json j =
    { nat_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "natGatewayId") String.of_json
    }
end

module DirectoryServiceAuthentication = struct
  type t = { directory_id : String.t option }

  let make ?directory_id () = { directory_id }

  let parse xml =
    Some
      { directory_id =
          Aws.Util.option_bind (Aws.Xml.member "directoryId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.directory_id (fun f ->
               Aws.Query.Pair ("DirectoryId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.directory_id (fun f -> "directoryId", String.to_json f) ])

  let of_json j =
    { directory_id = Aws.Util.option_map (Aws.Json.lookup j "directoryId") String.of_json
    }
end

module CurrencyCodeValues = struct
  type t = USD

  let str_to_t = [ "USD", USD ]

  let t_to_str = [ USD, "USD" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ReservedInstanceLimitPrice = struct
  type t =
    { amount : Double.t option
    ; currency_code : CurrencyCodeValues.t option
    }

  let make ?amount ?currency_code () = { amount; currency_code }

  let parse xml =
    Some
      { amount = Aws.Util.option_bind (Aws.Xml.member "amount" xml) Double.parse
      ; currency_code =
          Aws.Util.option_bind
            (Aws.Xml.member "currencyCode" xml)
            CurrencyCodeValues.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.currency_code (fun f ->
               Aws.Query.Pair ("CurrencyCode", CurrencyCodeValues.to_query f))
         ; Aws.Util.option_map v.amount (fun f ->
               Aws.Query.Pair ("Amount", Double.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.currency_code (fun f ->
               "currencyCode", CurrencyCodeValues.to_json f)
         ; Aws.Util.option_map v.amount (fun f -> "amount", Double.to_json f)
         ])

  let of_json j =
    { amount = Aws.Util.option_map (Aws.Json.lookup j "amount") Double.of_json
    ; currency_code =
        Aws.Util.option_map (Aws.Json.lookup j "currencyCode") CurrencyCodeValues.of_json
    }
end

module PurchaseReservedInstancesOfferingRequest = struct
  type t =
    { instance_count : Integer.t
    ; reserved_instances_offering_id : String.t
    ; dry_run : Boolean.t option
    ; limit_price : ReservedInstanceLimitPrice.t option
    ; purchase_time : DateTime.t option
    }

  let make
      ~instance_count
      ~reserved_instances_offering_id
      ?dry_run
      ?limit_price
      ?purchase_time
      () =
    { instance_count
    ; reserved_instances_offering_id
    ; dry_run
    ; limit_price
    ; purchase_time
    }

  let parse xml =
    Some
      { instance_count =
          Aws.Xml.required
            "InstanceCount"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceCount" xml) Integer.parse)
      ; reserved_instances_offering_id =
          Aws.Xml.required
            "ReservedInstancesOfferingId"
            (Aws.Util.option_bind
               (Aws.Xml.member "ReservedInstancesOfferingId" xml)
               String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; limit_price =
          Aws.Util.option_bind
            (Aws.Xml.member "limitPrice" xml)
            ReservedInstanceLimitPrice.parse
      ; purchase_time =
          Aws.Util.option_bind (Aws.Xml.member "PurchaseTime" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.purchase_time (fun f ->
               Aws.Query.Pair ("PurchaseTime", DateTime.to_query f))
         ; Aws.Util.option_map v.limit_price (fun f ->
               Aws.Query.Pair ("LimitPrice", ReservedInstanceLimitPrice.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ReservedInstancesOfferingId"
                , String.to_query v.reserved_instances_offering_id ))
         ; Some (Aws.Query.Pair ("InstanceCount", Integer.to_query v.instance_count))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.purchase_time (fun f ->
               "PurchaseTime", DateTime.to_json f)
         ; Aws.Util.option_map v.limit_price (fun f ->
               "limitPrice", ReservedInstanceLimitPrice.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some
             ( "ReservedInstancesOfferingId"
             , String.to_json v.reserved_instances_offering_id )
         ; Some ("InstanceCount", Integer.to_json v.instance_count)
         ])

  let of_json j =
    { instance_count =
        Integer.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceCount"))
    ; reserved_instances_offering_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ReservedInstancesOfferingId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; limit_price =
        Aws.Util.option_map
          (Aws.Json.lookup j "limitPrice")
          ReservedInstanceLimitPrice.of_json
    ; purchase_time =
        Aws.Util.option_map (Aws.Json.lookup j "PurchaseTime") DateTime.of_json
    }
end

module NetworkCardInfo = struct
  type t =
    { network_card_index : Integer.t option
    ; network_performance : String.t option
    ; maximum_network_interfaces : Integer.t option
    }

  let make ?network_card_index ?network_performance ?maximum_network_interfaces () =
    { network_card_index; network_performance; maximum_network_interfaces }

  let parse xml =
    Some
      { network_card_index =
          Aws.Util.option_bind (Aws.Xml.member "networkCardIndex" xml) Integer.parse
      ; network_performance =
          Aws.Util.option_bind (Aws.Xml.member "networkPerformance" xml) String.parse
      ; maximum_network_interfaces =
          Aws.Util.option_bind
            (Aws.Xml.member "maximumNetworkInterfaces" xml)
            Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.maximum_network_interfaces (fun f ->
               Aws.Query.Pair ("MaximumNetworkInterfaces", Integer.to_query f))
         ; Aws.Util.option_map v.network_performance (fun f ->
               Aws.Query.Pair ("NetworkPerformance", String.to_query f))
         ; Aws.Util.option_map v.network_card_index (fun f ->
               Aws.Query.Pair ("NetworkCardIndex", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.maximum_network_interfaces (fun f ->
               "maximumNetworkInterfaces", Integer.to_json f)
         ; Aws.Util.option_map v.network_performance (fun f ->
               "networkPerformance", String.to_json f)
         ; Aws.Util.option_map v.network_card_index (fun f ->
               "networkCardIndex", Integer.to_json f)
         ])

  let of_json j =
    { network_card_index =
        Aws.Util.option_map (Aws.Json.lookup j "networkCardIndex") Integer.of_json
    ; network_performance =
        Aws.Util.option_map (Aws.Json.lookup j "networkPerformance") String.of_json
    ; maximum_network_interfaces =
        Aws.Util.option_map (Aws.Json.lookup j "maximumNetworkInterfaces") Integer.of_json
    }
end

module Filter = struct
  type t =
    { name : String.t
    ; values : ValueStringList.t
    }

  let make ~name ?(values = []) () = { name; values }

  let parse xml =
    Some
      { name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      ; values =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Value" xml) ValueStringList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Value", ValueStringList.to_query v.values))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Value", ValueStringList.to_json v.values)
         ; Some ("Name", String.to_json v.name)
         ])

  let of_json j =
    { name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; values =
        ValueStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Value"))
    }
end

module FilterList = struct
  type t = Filter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Filter.parse (Aws.Xml.members "Filter" xml))

  let to_query v = Aws.Query.to_query_list Filter.to_query v

  let to_json v = `List (List.map Filter.to_json v)

  let of_json j = Aws.Json.to_list Filter.of_json j
end

module DescribeHostReservationOfferingsRequest = struct
  type t =
    { filter : FilterList.t
    ; max_duration : Integer.t option
    ; max_results : Integer.t option
    ; min_duration : Integer.t option
    ; next_token : String.t option
    ; offering_id : String.t option
    }

  let make
      ?(filter = [])
      ?max_duration
      ?max_results
      ?min_duration
      ?next_token
      ?offering_id
      () =
    { filter; max_duration; max_results; min_duration; next_token; offering_id }

  let parse xml =
    Some
      { filter =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_duration =
          Aws.Util.option_bind (Aws.Xml.member "MaxDuration" xml) Integer.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; min_duration =
          Aws.Util.option_bind (Aws.Xml.member "MinDuration" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; offering_id = Aws.Util.option_bind (Aws.Xml.member "OfferingId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.offering_id (fun f ->
               Aws.Query.Pair ("OfferingId", String.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.min_duration (fun f ->
               Aws.Query.Pair ("MinDuration", Integer.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.max_duration (fun f ->
               Aws.Query.Pair ("MaxDuration", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filter))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.offering_id (fun f -> "OfferingId", String.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.min_duration (fun f -> "MinDuration", Integer.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.max_duration (fun f -> "MaxDuration", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filter)
         ])

  let of_json j =
    { filter = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_duration = Aws.Util.option_map (Aws.Json.lookup j "MaxDuration") Integer.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; min_duration = Aws.Util.option_map (Aws.Json.lookup j "MinDuration") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; offering_id = Aws.Util.option_map (Aws.Json.lookup j "OfferingId") String.of_json
    }
end

module ListingStatus = struct
  type t =
    | Active
    | Pending
    | Cancelled
    | Closed

  let str_to_t =
    [ "closed", Closed; "cancelled", Cancelled; "pending", Pending; "active", Active ]

  let t_to_str =
    [ Closed, "closed"; Cancelled, "cancelled"; Pending, "pending"; Active, "active" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module PlacementResponse = struct
  type t = { group_name : String.t option }

  let make ?group_name () = { group_name }

  let parse xml =
    Some
      { group_name = Aws.Util.option_bind (Aws.Xml.member "groupName" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.group_name (fun f ->
               Aws.Query.Pair ("GroupName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.group_name (fun f -> "groupName", String.to_json f) ])

  let of_json j =
    { group_name = Aws.Util.option_map (Aws.Json.lookup j "groupName") String.of_json }
end

module FleetLaunchTemplateOverrides = struct
  type t =
    { instance_type : InstanceType.t option
    ; max_price : String.t option
    ; subnet_id : String.t option
    ; availability_zone : String.t option
    ; weighted_capacity : Double.t option
    ; priority : Double.t option
    ; placement : PlacementResponse.t option
    }

  let make
      ?instance_type
      ?max_price
      ?subnet_id
      ?availability_zone
      ?weighted_capacity
      ?priority
      ?placement
      () =
    { instance_type
    ; max_price
    ; subnet_id
    ; availability_zone
    ; weighted_capacity
    ; priority
    ; placement
    }

  let parse xml =
    Some
      { instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) InstanceType.parse
      ; max_price = Aws.Util.option_bind (Aws.Xml.member "maxPrice" xml) String.parse
      ; subnet_id = Aws.Util.option_bind (Aws.Xml.member "subnetId" xml) String.parse
      ; availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; weighted_capacity =
          Aws.Util.option_bind (Aws.Xml.member "weightedCapacity" xml) Double.parse
      ; priority = Aws.Util.option_bind (Aws.Xml.member "priority" xml) Double.parse
      ; placement =
          Aws.Util.option_bind (Aws.Xml.member "placement" xml) PlacementResponse.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.placement (fun f ->
               Aws.Query.Pair ("Placement", PlacementResponse.to_query f))
         ; Aws.Util.option_map v.priority (fun f ->
               Aws.Query.Pair ("Priority", Double.to_query f))
         ; Aws.Util.option_map v.weighted_capacity (fun f ->
               Aws.Query.Pair ("WeightedCapacity", Double.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ; Aws.Util.option_map v.subnet_id (fun f ->
               Aws.Query.Pair ("SubnetId", String.to_query f))
         ; Aws.Util.option_map v.max_price (fun f ->
               Aws.Query.Pair ("MaxPrice", String.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", InstanceType.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.placement (fun f ->
               "placement", PlacementResponse.to_json f)
         ; Aws.Util.option_map v.priority (fun f -> "priority", Double.to_json f)
         ; Aws.Util.option_map v.weighted_capacity (fun f ->
               "weightedCapacity", Double.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ; Aws.Util.option_map v.subnet_id (fun f -> "subnetId", String.to_json f)
         ; Aws.Util.option_map v.max_price (fun f -> "maxPrice", String.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f ->
               "instanceType", InstanceType.to_json f)
         ])

  let of_json j =
    { instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") InstanceType.of_json
    ; max_price = Aws.Util.option_map (Aws.Json.lookup j "maxPrice") String.of_json
    ; subnet_id = Aws.Util.option_map (Aws.Json.lookup j "subnetId") String.of_json
    ; availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; weighted_capacity =
        Aws.Util.option_map (Aws.Json.lookup j "weightedCapacity") Double.of_json
    ; priority = Aws.Util.option_map (Aws.Json.lookup j "priority") Double.of_json
    ; placement =
        Aws.Util.option_map (Aws.Json.lookup j "placement") PlacementResponse.of_json
    }
end

module FleetLaunchTemplateOverridesList = struct
  type t = FleetLaunchTemplateOverrides.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map FleetLaunchTemplateOverrides.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list FleetLaunchTemplateOverrides.to_query v

  let to_json v = `List (List.map FleetLaunchTemplateOverrides.to_json v)

  let of_json j = Aws.Json.to_list FleetLaunchTemplateOverrides.of_json j
end

module FastSnapshotRestoreStateCode = struct
  type t =
    | Enabling
    | Optimizing
    | Enabled
    | Disabling
    | Disabled

  let str_to_t =
    [ "disabled", Disabled
    ; "disabling", Disabling
    ; "enabled", Enabled
    ; "optimizing", Optimizing
    ; "enabling", Enabling
    ]

  let t_to_str =
    [ Disabled, "disabled"
    ; Disabling, "disabling"
    ; Enabled, "enabled"
    ; Optimizing, "optimizing"
    ; Enabling, "enabling"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DescribeFastSnapshotRestoreSuccessItem = struct
  type t =
    { snapshot_id : String.t option
    ; availability_zone : String.t option
    ; state : FastSnapshotRestoreStateCode.t option
    ; state_transition_reason : String.t option
    ; owner_id : String.t option
    ; owner_alias : String.t option
    ; enabling_time : DateTime.t option
    ; optimizing_time : DateTime.t option
    ; enabled_time : DateTime.t option
    ; disabling_time : DateTime.t option
    ; disabled_time : DateTime.t option
    }

  let make
      ?snapshot_id
      ?availability_zone
      ?state
      ?state_transition_reason
      ?owner_id
      ?owner_alias
      ?enabling_time
      ?optimizing_time
      ?enabled_time
      ?disabling_time
      ?disabled_time
      () =
    { snapshot_id
    ; availability_zone
    ; state
    ; state_transition_reason
    ; owner_id
    ; owner_alias
    ; enabling_time
    ; optimizing_time
    ; enabled_time
    ; disabling_time
    ; disabled_time
    }

  let parse xml =
    Some
      { snapshot_id = Aws.Util.option_bind (Aws.Xml.member "snapshotId" xml) String.parse
      ; availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; state =
          Aws.Util.option_bind
            (Aws.Xml.member "state" xml)
            FastSnapshotRestoreStateCode.parse
      ; state_transition_reason =
          Aws.Util.option_bind (Aws.Xml.member "stateTransitionReason" xml) String.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; owner_alias = Aws.Util.option_bind (Aws.Xml.member "ownerAlias" xml) String.parse
      ; enabling_time =
          Aws.Util.option_bind (Aws.Xml.member "enablingTime" xml) DateTime.parse
      ; optimizing_time =
          Aws.Util.option_bind (Aws.Xml.member "optimizingTime" xml) DateTime.parse
      ; enabled_time =
          Aws.Util.option_bind (Aws.Xml.member "enabledTime" xml) DateTime.parse
      ; disabling_time =
          Aws.Util.option_bind (Aws.Xml.member "disablingTime" xml) DateTime.parse
      ; disabled_time =
          Aws.Util.option_bind (Aws.Xml.member "disabledTime" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.disabled_time (fun f ->
               Aws.Query.Pair ("DisabledTime", DateTime.to_query f))
         ; Aws.Util.option_map v.disabling_time (fun f ->
               Aws.Query.Pair ("DisablingTime", DateTime.to_query f))
         ; Aws.Util.option_map v.enabled_time (fun f ->
               Aws.Query.Pair ("EnabledTime", DateTime.to_query f))
         ; Aws.Util.option_map v.optimizing_time (fun f ->
               Aws.Query.Pair ("OptimizingTime", DateTime.to_query f))
         ; Aws.Util.option_map v.enabling_time (fun f ->
               Aws.Query.Pair ("EnablingTime", DateTime.to_query f))
         ; Aws.Util.option_map v.owner_alias (fun f ->
               Aws.Query.Pair ("OwnerAlias", String.to_query f))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.state_transition_reason (fun f ->
               Aws.Query.Pair ("StateTransitionReason", String.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", FastSnapshotRestoreStateCode.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ; Aws.Util.option_map v.snapshot_id (fun f ->
               Aws.Query.Pair ("SnapshotId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.disabled_time (fun f ->
               "disabledTime", DateTime.to_json f)
         ; Aws.Util.option_map v.disabling_time (fun f ->
               "disablingTime", DateTime.to_json f)
         ; Aws.Util.option_map v.enabled_time (fun f -> "enabledTime", DateTime.to_json f)
         ; Aws.Util.option_map v.optimizing_time (fun f ->
               "optimizingTime", DateTime.to_json f)
         ; Aws.Util.option_map v.enabling_time (fun f ->
               "enablingTime", DateTime.to_json f)
         ; Aws.Util.option_map v.owner_alias (fun f -> "ownerAlias", String.to_json f)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.state_transition_reason (fun f ->
               "stateTransitionReason", String.to_json f)
         ; Aws.Util.option_map v.state (fun f ->
               "state", FastSnapshotRestoreStateCode.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ; Aws.Util.option_map v.snapshot_id (fun f -> "snapshotId", String.to_json f)
         ])

  let of_json j =
    { snapshot_id = Aws.Util.option_map (Aws.Json.lookup j "snapshotId") String.of_json
    ; availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; state =
        Aws.Util.option_map
          (Aws.Json.lookup j "state")
          FastSnapshotRestoreStateCode.of_json
    ; state_transition_reason =
        Aws.Util.option_map (Aws.Json.lookup j "stateTransitionReason") String.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; owner_alias = Aws.Util.option_map (Aws.Json.lookup j "ownerAlias") String.of_json
    ; enabling_time =
        Aws.Util.option_map (Aws.Json.lookup j "enablingTime") DateTime.of_json
    ; optimizing_time =
        Aws.Util.option_map (Aws.Json.lookup j "optimizingTime") DateTime.of_json
    ; enabled_time =
        Aws.Util.option_map (Aws.Json.lookup j "enabledTime") DateTime.of_json
    ; disabling_time =
        Aws.Util.option_map (Aws.Json.lookup j "disablingTime") DateTime.of_json
    ; disabled_time =
        Aws.Util.option_map (Aws.Json.lookup j "disabledTime") DateTime.of_json
    }
end

module DescribeFastSnapshotRestoreSuccessSet = struct
  type t = DescribeFastSnapshotRestoreSuccessItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map DescribeFastSnapshotRestoreSuccessItem.parse (Aws.Xml.members "item" xml))

  let to_query v =
    Aws.Query.to_query_list DescribeFastSnapshotRestoreSuccessItem.to_query v

  let to_json v = `List (List.map DescribeFastSnapshotRestoreSuccessItem.to_json v)

  let of_json j = Aws.Json.to_list DescribeFastSnapshotRestoreSuccessItem.of_json j
end

module DescribeFastSnapshotRestoresResult = struct
  type t =
    { fast_snapshot_restores : DescribeFastSnapshotRestoreSuccessSet.t
    ; next_token : String.t option
    }

  let make ?(fast_snapshot_restores = []) ?next_token () =
    { fast_snapshot_restores; next_token }

  let parse xml =
    Some
      { fast_snapshot_restores =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "fastSnapshotRestoreSet" xml)
               DescribeFastSnapshotRestoreSuccessSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "FastSnapshotRestoreSet"
                , DescribeFastSnapshotRestoreSuccessSet.to_query v.fast_snapshot_restores
                ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "fastSnapshotRestoreSet"
             , DescribeFastSnapshotRestoreSuccessSet.to_json v.fast_snapshot_restores )
         ])

  let of_json j =
    { fast_snapshot_restores =
        DescribeFastSnapshotRestoreSuccessSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "fastSnapshotRestoreSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module ElasticInferenceAcceleratorAssociation = struct
  type t =
    { elastic_inference_accelerator_arn : String.t option
    ; elastic_inference_accelerator_association_id : String.t option
    ; elastic_inference_accelerator_association_state : String.t option
    ; elastic_inference_accelerator_association_time : DateTime.t option
    }

  let make
      ?elastic_inference_accelerator_arn
      ?elastic_inference_accelerator_association_id
      ?elastic_inference_accelerator_association_state
      ?elastic_inference_accelerator_association_time
      () =
    { elastic_inference_accelerator_arn
    ; elastic_inference_accelerator_association_id
    ; elastic_inference_accelerator_association_state
    ; elastic_inference_accelerator_association_time
    }

  let parse xml =
    Some
      { elastic_inference_accelerator_arn =
          Aws.Util.option_bind
            (Aws.Xml.member "elasticInferenceAcceleratorArn" xml)
            String.parse
      ; elastic_inference_accelerator_association_id =
          Aws.Util.option_bind
            (Aws.Xml.member "elasticInferenceAcceleratorAssociationId" xml)
            String.parse
      ; elastic_inference_accelerator_association_state =
          Aws.Util.option_bind
            (Aws.Xml.member "elasticInferenceAcceleratorAssociationState" xml)
            String.parse
      ; elastic_inference_accelerator_association_time =
          Aws.Util.option_bind
            (Aws.Xml.member "elasticInferenceAcceleratorAssociationTime" xml)
            DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.elastic_inference_accelerator_association_time (fun f ->
               Aws.Query.Pair
                 ("ElasticInferenceAcceleratorAssociationTime", DateTime.to_query f))
         ; Aws.Util.option_map v.elastic_inference_accelerator_association_state (fun f ->
               Aws.Query.Pair
                 ("ElasticInferenceAcceleratorAssociationState", String.to_query f))
         ; Aws.Util.option_map v.elastic_inference_accelerator_association_id (fun f ->
               Aws.Query.Pair
                 ("ElasticInferenceAcceleratorAssociationId", String.to_query f))
         ; Aws.Util.option_map v.elastic_inference_accelerator_arn (fun f ->
               Aws.Query.Pair ("ElasticInferenceAcceleratorArn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.elastic_inference_accelerator_association_time (fun f ->
               "elasticInferenceAcceleratorAssociationTime", DateTime.to_json f)
         ; Aws.Util.option_map v.elastic_inference_accelerator_association_state (fun f ->
               "elasticInferenceAcceleratorAssociationState", String.to_json f)
         ; Aws.Util.option_map v.elastic_inference_accelerator_association_id (fun f ->
               "elasticInferenceAcceleratorAssociationId", String.to_json f)
         ; Aws.Util.option_map v.elastic_inference_accelerator_arn (fun f ->
               "elasticInferenceAcceleratorArn", String.to_json f)
         ])

  let of_json j =
    { elastic_inference_accelerator_arn =
        Aws.Util.option_map
          (Aws.Json.lookup j "elasticInferenceAcceleratorArn")
          String.of_json
    ; elastic_inference_accelerator_association_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "elasticInferenceAcceleratorAssociationId")
          String.of_json
    ; elastic_inference_accelerator_association_state =
        Aws.Util.option_map
          (Aws.Json.lookup j "elasticInferenceAcceleratorAssociationState")
          String.of_json
    ; elastic_inference_accelerator_association_time =
        Aws.Util.option_map
          (Aws.Json.lookup j "elasticInferenceAcceleratorAssociationTime")
          DateTime.of_json
    }
end

module ClientVpnEndpointAttributeStatusCode = struct
  type t =
    | Applying
    | Applied

  let str_to_t = [ "applied", Applied; "applying", Applying ]

  let t_to_str = [ Applied, "applied"; Applying, "applying" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ClientVpnEndpointAttributeStatus = struct
  type t =
    { code : ClientVpnEndpointAttributeStatusCode.t option
    ; message : String.t option
    }

  let make ?code ?message () = { code; message }

  let parse xml =
    Some
      { code =
          Aws.Util.option_bind
            (Aws.Xml.member "code" xml)
            ClientVpnEndpointAttributeStatusCode.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair ("Code", ClientVpnEndpointAttributeStatusCode.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f)
         ; Aws.Util.option_map v.code (fun f ->
               "code", ClientVpnEndpointAttributeStatusCode.to_json f)
         ])

  let of_json j =
    { code =
        Aws.Util.option_map
          (Aws.Json.lookup j "code")
          ClientVpnEndpointAttributeStatusCode.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json
    }
end

module ClientConnectResponseOptions = struct
  type t =
    { enabled : Boolean.t option
    ; lambda_function_arn : String.t option
    ; status : ClientVpnEndpointAttributeStatus.t option
    }

  let make ?enabled ?lambda_function_arn ?status () =
    { enabled; lambda_function_arn; status }

  let parse xml =
    Some
      { enabled = Aws.Util.option_bind (Aws.Xml.member "enabled" xml) Boolean.parse
      ; lambda_function_arn =
          Aws.Util.option_bind (Aws.Xml.member "lambdaFunctionArn" xml) String.parse
      ; status =
          Aws.Util.option_bind
            (Aws.Xml.member "status" xml)
            ClientVpnEndpointAttributeStatus.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", ClientVpnEndpointAttributeStatus.to_query f))
         ; Aws.Util.option_map v.lambda_function_arn (fun f ->
               Aws.Query.Pair ("LambdaFunctionArn", String.to_query f))
         ; Aws.Util.option_map v.enabled (fun f ->
               Aws.Query.Pair ("Enabled", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               "status", ClientVpnEndpointAttributeStatus.to_json f)
         ; Aws.Util.option_map v.lambda_function_arn (fun f ->
               "lambdaFunctionArn", String.to_json f)
         ; Aws.Util.option_map v.enabled (fun f -> "enabled", Boolean.to_json f)
         ])

  let of_json j =
    { enabled = Aws.Util.option_map (Aws.Json.lookup j "enabled") Boolean.of_json
    ; lambda_function_arn =
        Aws.Util.option_map (Aws.Json.lookup j "lambdaFunctionArn") String.of_json
    ; status =
        Aws.Util.option_map
          (Aws.Json.lookup j "status")
          ClientVpnEndpointAttributeStatus.of_json
    }
end

module S3Storage = struct
  type t =
    { a_w_s_access_key_id : String.t option
    ; bucket : String.t option
    ; prefix : String.t option
    ; upload_policy : Blob.t option
    ; upload_policy_signature : String.t option
    }

  let make ?a_w_s_access_key_id ?bucket ?prefix ?upload_policy ?upload_policy_signature ()
      =
    { a_w_s_access_key_id; bucket; prefix; upload_policy; upload_policy_signature }

  let parse xml =
    Some
      { a_w_s_access_key_id =
          Aws.Util.option_bind (Aws.Xml.member "AWSAccessKeyId" xml) String.parse
      ; bucket = Aws.Util.option_bind (Aws.Xml.member "bucket" xml) String.parse
      ; prefix = Aws.Util.option_bind (Aws.Xml.member "prefix" xml) String.parse
      ; upload_policy =
          Aws.Util.option_bind (Aws.Xml.member "uploadPolicy" xml) Blob.parse
      ; upload_policy_signature =
          Aws.Util.option_bind (Aws.Xml.member "uploadPolicySignature" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.upload_policy_signature (fun f ->
               Aws.Query.Pair ("UploadPolicySignature", String.to_query f))
         ; Aws.Util.option_map v.upload_policy (fun f ->
               Aws.Query.Pair ("UploadPolicy", Blob.to_query f))
         ; Aws.Util.option_map v.prefix (fun f ->
               Aws.Query.Pair ("Prefix", String.to_query f))
         ; Aws.Util.option_map v.bucket (fun f ->
               Aws.Query.Pair ("Bucket", String.to_query f))
         ; Aws.Util.option_map v.a_w_s_access_key_id (fun f ->
               Aws.Query.Pair ("AWSAccessKeyId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.upload_policy_signature (fun f ->
               "uploadPolicySignature", String.to_json f)
         ; Aws.Util.option_map v.upload_policy (fun f -> "uploadPolicy", Blob.to_json f)
         ; Aws.Util.option_map v.prefix (fun f -> "prefix", String.to_json f)
         ; Aws.Util.option_map v.bucket (fun f -> "bucket", String.to_json f)
         ; Aws.Util.option_map v.a_w_s_access_key_id (fun f ->
               "AWSAccessKeyId", String.to_json f)
         ])

  let of_json j =
    { a_w_s_access_key_id =
        Aws.Util.option_map (Aws.Json.lookup j "AWSAccessKeyId") String.of_json
    ; bucket = Aws.Util.option_map (Aws.Json.lookup j "bucket") String.of_json
    ; prefix = Aws.Util.option_map (Aws.Json.lookup j "prefix") String.of_json
    ; upload_policy = Aws.Util.option_map (Aws.Json.lookup j "uploadPolicy") Blob.of_json
    ; upload_policy_signature =
        Aws.Util.option_map (Aws.Json.lookup j "uploadPolicySignature") String.of_json
    }
end

module Storage = struct
  type t = { s3 : S3Storage.t option }

  let make ?s3 () = { s3 }

  let parse xml =
    Some { s3 = Aws.Util.option_bind (Aws.Xml.member "S3" xml) S3Storage.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.s3 (fun f -> Aws.Query.Pair ("S3", S3Storage.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.s3 (fun f -> "S3", S3Storage.to_json f) ])

  let of_json j = { s3 = Aws.Util.option_map (Aws.Json.lookup j "S3") S3Storage.of_json }
end

module InstanceUsage = struct
  type t =
    { account_id : String.t option
    ; used_instance_count : Integer.t option
    }

  let make ?account_id ?used_instance_count () = { account_id; used_instance_count }

  let parse xml =
    Some
      { account_id = Aws.Util.option_bind (Aws.Xml.member "accountId" xml) String.parse
      ; used_instance_count =
          Aws.Util.option_bind (Aws.Xml.member "usedInstanceCount" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.used_instance_count (fun f ->
               Aws.Query.Pair ("UsedInstanceCount", Integer.to_query f))
         ; Aws.Util.option_map v.account_id (fun f ->
               Aws.Query.Pair ("AccountId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.used_instance_count (fun f ->
               "usedInstanceCount", Integer.to_json f)
         ; Aws.Util.option_map v.account_id (fun f -> "accountId", String.to_json f)
         ])

  let of_json j =
    { account_id = Aws.Util.option_map (Aws.Json.lookup j "accountId") String.of_json
    ; used_instance_count =
        Aws.Util.option_map (Aws.Json.lookup j "usedInstanceCount") Integer.of_json
    }
end

module InstanceUsageSet = struct
  type t = InstanceUsage.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map InstanceUsage.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list InstanceUsage.to_query v

  let to_json v = `List (List.map InstanceUsage.to_json v)

  let of_json j = Aws.Json.to_list InstanceUsage.of_json j
end

module CapacityReservationState = struct
  type t =
    | Active
    | Expired
    | Cancelled
    | Pending
    | Failed

  let str_to_t =
    [ "failed", Failed
    ; "pending", Pending
    ; "cancelled", Cancelled
    ; "expired", Expired
    ; "active", Active
    ]

  let t_to_str =
    [ Failed, "failed"
    ; Pending, "pending"
    ; Cancelled, "cancelled"
    ; Expired, "expired"
    ; Active, "active"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module GetCapacityReservationUsageResult = struct
  type t =
    { next_token : String.t option
    ; capacity_reservation_id : String.t option
    ; instance_type : String.t option
    ; total_instance_count : Integer.t option
    ; available_instance_count : Integer.t option
    ; state : CapacityReservationState.t option
    ; instance_usages : InstanceUsageSet.t
    }

  let make
      ?next_token
      ?capacity_reservation_id
      ?instance_type
      ?total_instance_count
      ?available_instance_count
      ?state
      ?(instance_usages = [])
      () =
    { next_token
    ; capacity_reservation_id
    ; instance_type
    ; total_instance_count
    ; available_instance_count
    ; state
    ; instance_usages
    }

  let parse xml =
    Some
      { next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; capacity_reservation_id =
          Aws.Util.option_bind (Aws.Xml.member "capacityReservationId" xml) String.parse
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) String.parse
      ; total_instance_count =
          Aws.Util.option_bind (Aws.Xml.member "totalInstanceCount" xml) Integer.parse
      ; available_instance_count =
          Aws.Util.option_bind (Aws.Xml.member "availableInstanceCount" xml) Integer.parse
      ; state =
          Aws.Util.option_bind (Aws.Xml.member "state" xml) CapacityReservationState.parse
      ; instance_usages =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "instanceUsageSet" xml)
               InstanceUsageSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("InstanceUsageSet", InstanceUsageSet.to_query v.instance_usages))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", CapacityReservationState.to_query f))
         ; Aws.Util.option_map v.available_instance_count (fun f ->
               Aws.Query.Pair ("AvailableInstanceCount", Integer.to_query f))
         ; Aws.Util.option_map v.total_instance_count (fun f ->
               Aws.Query.Pair ("TotalInstanceCount", Integer.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", String.to_query f))
         ; Aws.Util.option_map v.capacity_reservation_id (fun f ->
               Aws.Query.Pair ("CapacityReservationId", String.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("instanceUsageSet", InstanceUsageSet.to_json v.instance_usages)
         ; Aws.Util.option_map v.state (fun f ->
               "state", CapacityReservationState.to_json f)
         ; Aws.Util.option_map v.available_instance_count (fun f ->
               "availableInstanceCount", Integer.to_json f)
         ; Aws.Util.option_map v.total_instance_count (fun f ->
               "totalInstanceCount", Integer.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f -> "instanceType", String.to_json f)
         ; Aws.Util.option_map v.capacity_reservation_id (fun f ->
               "capacityReservationId", String.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ])

  let of_json j =
    { next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; capacity_reservation_id =
        Aws.Util.option_map (Aws.Json.lookup j "capacityReservationId") String.of_json
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") String.of_json
    ; total_instance_count =
        Aws.Util.option_map (Aws.Json.lookup j "totalInstanceCount") Integer.of_json
    ; available_instance_count =
        Aws.Util.option_map (Aws.Json.lookup j "availableInstanceCount") Integer.of_json
    ; state =
        Aws.Util.option_map (Aws.Json.lookup j "state") CapacityReservationState.of_json
    ; instance_usages =
        InstanceUsageSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceUsageSet"))
    }
end

module PrefixListResourceIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module ArchitectureType = struct
  type t =
    | I386
    | X86_64
    | Arm64

  let str_to_t = [ "arm64", Arm64; "x86_64", X86_64; "i386", I386 ]

  let t_to_str = [ Arm64, "arm64"; X86_64, "x86_64"; I386, "i386" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ArchitectureTypeList = struct
  type t = ArchitectureType.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ArchitectureType.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ArchitectureType.to_query v

  let to_json v = `List (List.map ArchitectureType.to_json v)

  let of_json j = Aws.Json.to_list ArchitectureType.of_json j
end

module GpuDeviceMemoryInfo = struct
  type t = { size_in_mi_b : Integer.t option }

  let make ?size_in_mi_b () = { size_in_mi_b }

  let parse xml =
    Some
      { size_in_mi_b = Aws.Util.option_bind (Aws.Xml.member "sizeInMiB" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.size_in_mi_b (fun f ->
               Aws.Query.Pair ("SizeInMiB", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.size_in_mi_b (fun f -> "sizeInMiB", Integer.to_json f) ])

  let of_json j =
    { size_in_mi_b = Aws.Util.option_map (Aws.Json.lookup j "sizeInMiB") Integer.of_json }
end

module GpuDeviceInfo = struct
  type t =
    { name : String.t option
    ; manufacturer : String.t option
    ; count : Integer.t option
    ; memory_info : GpuDeviceMemoryInfo.t option
    }

  let make ?name ?manufacturer ?count ?memory_info () =
    { name; manufacturer; count; memory_info }

  let parse xml =
    Some
      { name = Aws.Util.option_bind (Aws.Xml.member "name" xml) String.parse
      ; manufacturer =
          Aws.Util.option_bind (Aws.Xml.member "manufacturer" xml) String.parse
      ; count = Aws.Util.option_bind (Aws.Xml.member "count" xml) Integer.parse
      ; memory_info =
          Aws.Util.option_bind (Aws.Xml.member "memoryInfo" xml) GpuDeviceMemoryInfo.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.memory_info (fun f ->
               Aws.Query.Pair ("MemoryInfo", GpuDeviceMemoryInfo.to_query f))
         ; Aws.Util.option_map v.count (fun f ->
               Aws.Query.Pair ("Count", Integer.to_query f))
         ; Aws.Util.option_map v.manufacturer (fun f ->
               Aws.Query.Pair ("Manufacturer", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.memory_info (fun f ->
               "memoryInfo", GpuDeviceMemoryInfo.to_json f)
         ; Aws.Util.option_map v.count (fun f -> "count", Integer.to_json f)
         ; Aws.Util.option_map v.manufacturer (fun f -> "manufacturer", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "name", String.to_json f)
         ])

  let of_json j =
    { name = Aws.Util.option_map (Aws.Json.lookup j "name") String.of_json
    ; manufacturer = Aws.Util.option_map (Aws.Json.lookup j "manufacturer") String.of_json
    ; count = Aws.Util.option_map (Aws.Json.lookup j "count") Integer.of_json
    ; memory_info =
        Aws.Util.option_map (Aws.Json.lookup j "memoryInfo") GpuDeviceMemoryInfo.of_json
    }
end

module GpuDeviceInfoList = struct
  type t = GpuDeviceInfo.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map GpuDeviceInfo.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list GpuDeviceInfo.to_query v

  let to_json v = `List (List.map GpuDeviceInfo.to_json v)

  let of_json j = Aws.Json.to_list GpuDeviceInfo.of_json j
end

module SecurityGroupReference = struct
  type t =
    { group_id : String.t option
    ; referencing_vpc_id : String.t option
    ; vpc_peering_connection_id : String.t option
    }

  let make ?group_id ?referencing_vpc_id ?vpc_peering_connection_id () =
    { group_id; referencing_vpc_id; vpc_peering_connection_id }

  let parse xml =
    Some
      { group_id = Aws.Util.option_bind (Aws.Xml.member "groupId" xml) String.parse
      ; referencing_vpc_id =
          Aws.Util.option_bind (Aws.Xml.member "referencingVpcId" xml) String.parse
      ; vpc_peering_connection_id =
          Aws.Util.option_bind (Aws.Xml.member "vpcPeeringConnectionId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_peering_connection_id (fun f ->
               Aws.Query.Pair ("VpcPeeringConnectionId", String.to_query f))
         ; Aws.Util.option_map v.referencing_vpc_id (fun f ->
               Aws.Query.Pair ("ReferencingVpcId", String.to_query f))
         ; Aws.Util.option_map v.group_id (fun f ->
               Aws.Query.Pair ("GroupId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_peering_connection_id (fun f ->
               "vpcPeeringConnectionId", String.to_json f)
         ; Aws.Util.option_map v.referencing_vpc_id (fun f ->
               "referencingVpcId", String.to_json f)
         ; Aws.Util.option_map v.group_id (fun f -> "groupId", String.to_json f)
         ])

  let of_json j =
    { group_id = Aws.Util.option_map (Aws.Json.lookup j "groupId") String.of_json
    ; referencing_vpc_id =
        Aws.Util.option_map (Aws.Json.lookup j "referencingVpcId") String.of_json
    ; vpc_peering_connection_id =
        Aws.Util.option_map (Aws.Json.lookup j "vpcPeeringConnectionId") String.of_json
    }
end

module SecurityGroupReferences = struct
  type t = SecurityGroupReference.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map SecurityGroupReference.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list SecurityGroupReference.to_query v

  let to_json v = `List (List.map SecurityGroupReference.to_json v)

  let of_json j = Aws.Json.to_list SecurityGroupReference.of_json j
end

module TerminateClientVpnConnectionsRequest = struct
  type t =
    { client_vpn_endpoint_id : String.t
    ; connection_id : String.t option
    ; username : String.t option
    ; dry_run : Boolean.t option
    }

  let make ~client_vpn_endpoint_id ?connection_id ?username ?dry_run () =
    { client_vpn_endpoint_id; connection_id; username; dry_run }

  let parse xml =
    Some
      { client_vpn_endpoint_id =
          Aws.Xml.required
            "ClientVpnEndpointId"
            (Aws.Util.option_bind (Aws.Xml.member "ClientVpnEndpointId" xml) String.parse)
      ; connection_id =
          Aws.Util.option_bind (Aws.Xml.member "ConnectionId" xml) String.parse
      ; username = Aws.Util.option_bind (Aws.Xml.member "Username" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.username (fun f ->
               Aws.Query.Pair ("Username", String.to_query f))
         ; Aws.Util.option_map v.connection_id (fun f ->
               Aws.Query.Pair ("ConnectionId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ClientVpnEndpointId", String.to_query v.client_vpn_endpoint_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.username (fun f -> "Username", String.to_json f)
         ; Aws.Util.option_map v.connection_id (fun f -> "ConnectionId", String.to_json f)
         ; Some ("ClientVpnEndpointId", String.to_json v.client_vpn_endpoint_id)
         ])

  let of_json j =
    { client_vpn_endpoint_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ClientVpnEndpointId"))
    ; connection_id =
        Aws.Util.option_map (Aws.Json.lookup j "ConnectionId") String.of_json
    ; username = Aws.Util.option_map (Aws.Json.lookup j "Username") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module InstanceCreditSpecificationRequest = struct
  type t =
    { instance_id : String.t option
    ; cpu_credits : String.t option
    }

  let make ?instance_id ?cpu_credits () = { instance_id; cpu_credits }

  let parse xml =
    Some
      { instance_id = Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse
      ; cpu_credits = Aws.Util.option_bind (Aws.Xml.member "CpuCredits" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cpu_credits (fun f ->
               Aws.Query.Pair ("CpuCredits", String.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cpu_credits (fun f -> "CpuCredits", String.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "InstanceId", String.to_json f)
         ])

  let of_json j =
    { instance_id = Aws.Util.option_map (Aws.Json.lookup j "InstanceId") String.of_json
    ; cpu_credits = Aws.Util.option_map (Aws.Json.lookup j "CpuCredits") String.of_json
    }
end

module EbsInstanceBlockDevice = struct
  type t =
    { attach_time : DateTime.t option
    ; delete_on_termination : Boolean.t option
    ; status : AttachmentStatus.t option
    ; volume_id : String.t option
    }

  let make ?attach_time ?delete_on_termination ?status ?volume_id () =
    { attach_time; delete_on_termination; status; volume_id }

  let parse xml =
    Some
      { attach_time =
          Aws.Util.option_bind (Aws.Xml.member "attachTime" xml) DateTime.parse
      ; delete_on_termination =
          Aws.Util.option_bind (Aws.Xml.member "deleteOnTermination" xml) Boolean.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "status" xml) AttachmentStatus.parse
      ; volume_id = Aws.Util.option_bind (Aws.Xml.member "volumeId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.volume_id (fun f ->
               Aws.Query.Pair ("VolumeId", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", AttachmentStatus.to_query f))
         ; Aws.Util.option_map v.delete_on_termination (fun f ->
               Aws.Query.Pair ("DeleteOnTermination", Boolean.to_query f))
         ; Aws.Util.option_map v.attach_time (fun f ->
               Aws.Query.Pair ("AttachTime", DateTime.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.volume_id (fun f -> "volumeId", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "status", AttachmentStatus.to_json f)
         ; Aws.Util.option_map v.delete_on_termination (fun f ->
               "deleteOnTermination", Boolean.to_json f)
         ; Aws.Util.option_map v.attach_time (fun f -> "attachTime", DateTime.to_json f)
         ])

  let of_json j =
    { attach_time = Aws.Util.option_map (Aws.Json.lookup j "attachTime") DateTime.of_json
    ; delete_on_termination =
        Aws.Util.option_map (Aws.Json.lookup j "deleteOnTermination") Boolean.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "status") AttachmentStatus.of_json
    ; volume_id = Aws.Util.option_map (Aws.Json.lookup j "volumeId") String.of_json
    }
end

module InstanceBlockDeviceMapping = struct
  type t =
    { device_name : String.t option
    ; ebs : EbsInstanceBlockDevice.t option
    }

  let make ?device_name ?ebs () = { device_name; ebs }

  let parse xml =
    Some
      { device_name = Aws.Util.option_bind (Aws.Xml.member "deviceName" xml) String.parse
      ; ebs = Aws.Util.option_bind (Aws.Xml.member "ebs" xml) EbsInstanceBlockDevice.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ebs (fun f ->
               Aws.Query.Pair ("Ebs", EbsInstanceBlockDevice.to_query f))
         ; Aws.Util.option_map v.device_name (fun f ->
               Aws.Query.Pair ("DeviceName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ebs (fun f -> "ebs", EbsInstanceBlockDevice.to_json f)
         ; Aws.Util.option_map v.device_name (fun f -> "deviceName", String.to_json f)
         ])

  let of_json j =
    { device_name = Aws.Util.option_map (Aws.Json.lookup j "deviceName") String.of_json
    ; ebs = Aws.Util.option_map (Aws.Json.lookup j "ebs") EbsInstanceBlockDevice.of_json
    }
end

module InstanceBlockDeviceMappingList = struct
  type t = InstanceBlockDeviceMapping.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map InstanceBlockDeviceMapping.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list InstanceBlockDeviceMapping.to_query v

  let to_json v = `List (List.map InstanceBlockDeviceMapping.to_json v)

  let of_json j = Aws.Json.to_list InstanceBlockDeviceMapping.of_json j
end

module SnapshotTaskDetail = struct
  type t =
    { description : String.t option
    ; disk_image_size : Double.t option
    ; encrypted : Boolean.t option
    ; format : String.t option
    ; kms_key_id : String.t option
    ; progress : String.t option
    ; snapshot_id : String.t option
    ; status : String.t option
    ; status_message : String.t option
    ; url : String.t option
    ; user_bucket : UserBucketDetails.t option
    }

  let make
      ?description
      ?disk_image_size
      ?encrypted
      ?format
      ?kms_key_id
      ?progress
      ?snapshot_id
      ?status
      ?status_message
      ?url
      ?user_bucket
      () =
    { description
    ; disk_image_size
    ; encrypted
    ; format
    ; kms_key_id
    ; progress
    ; snapshot_id
    ; status
    ; status_message
    ; url
    ; user_bucket
    }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; disk_image_size =
          Aws.Util.option_bind (Aws.Xml.member "diskImageSize" xml) Double.parse
      ; encrypted = Aws.Util.option_bind (Aws.Xml.member "encrypted" xml) Boolean.parse
      ; format = Aws.Util.option_bind (Aws.Xml.member "format" xml) String.parse
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "kmsKeyId" xml) String.parse
      ; progress = Aws.Util.option_bind (Aws.Xml.member "progress" xml) String.parse
      ; snapshot_id = Aws.Util.option_bind (Aws.Xml.member "snapshotId" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "status" xml) String.parse
      ; status_message =
          Aws.Util.option_bind (Aws.Xml.member "statusMessage" xml) String.parse
      ; url = Aws.Util.option_bind (Aws.Xml.member "url" xml) String.parse
      ; user_bucket =
          Aws.Util.option_bind (Aws.Xml.member "userBucket" xml) UserBucketDetails.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.user_bucket (fun f ->
               Aws.Query.Pair ("UserBucket", UserBucketDetails.to_query f))
         ; Aws.Util.option_map v.url (fun f -> Aws.Query.Pair ("Url", String.to_query f))
         ; Aws.Util.option_map v.status_message (fun f ->
               Aws.Query.Pair ("StatusMessage", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.snapshot_id (fun f ->
               Aws.Query.Pair ("SnapshotId", String.to_query f))
         ; Aws.Util.option_map v.progress (fun f ->
               Aws.Query.Pair ("Progress", String.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Aws.Util.option_map v.format (fun f ->
               Aws.Query.Pair ("Format", String.to_query f))
         ; Aws.Util.option_map v.encrypted (fun f ->
               Aws.Query.Pair ("Encrypted", Boolean.to_query f))
         ; Aws.Util.option_map v.disk_image_size (fun f ->
               Aws.Query.Pair ("DiskImageSize", Double.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.user_bucket (fun f ->
               "userBucket", UserBucketDetails.to_json f)
         ; Aws.Util.option_map v.url (fun f -> "url", String.to_json f)
         ; Aws.Util.option_map v.status_message (fun f ->
               "statusMessage", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "status", String.to_json f)
         ; Aws.Util.option_map v.snapshot_id (fun f -> "snapshotId", String.to_json f)
         ; Aws.Util.option_map v.progress (fun f -> "progress", String.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "kmsKeyId", String.to_json f)
         ; Aws.Util.option_map v.format (fun f -> "format", String.to_json f)
         ; Aws.Util.option_map v.encrypted (fun f -> "encrypted", Boolean.to_json f)
         ; Aws.Util.option_map v.disk_image_size (fun f ->
               "diskImageSize", Double.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; disk_image_size =
        Aws.Util.option_map (Aws.Json.lookup j "diskImageSize") Double.of_json
    ; encrypted = Aws.Util.option_map (Aws.Json.lookup j "encrypted") Boolean.of_json
    ; format = Aws.Util.option_map (Aws.Json.lookup j "format") String.of_json
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "kmsKeyId") String.of_json
    ; progress = Aws.Util.option_map (Aws.Json.lookup j "progress") String.of_json
    ; snapshot_id = Aws.Util.option_map (Aws.Json.lookup j "snapshotId") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "status") String.of_json
    ; status_message =
        Aws.Util.option_map (Aws.Json.lookup j "statusMessage") String.of_json
    ; url = Aws.Util.option_map (Aws.Json.lookup j "url") String.of_json
    ; user_bucket =
        Aws.Util.option_map (Aws.Json.lookup j "userBucket") UserBucketDetails.of_json
    }
end

module DatafeedSubscriptionState = struct
  type t =
    | Active
    | Inactive

  let str_to_t = [ "Inactive", Inactive; "Active", Active ]

  let t_to_str = [ Inactive, "Inactive"; Active, "Active" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module SpotDatafeedSubscription = struct
  type t =
    { bucket : String.t option
    ; fault : SpotInstanceStateFault.t option
    ; owner_id : String.t option
    ; prefix : String.t option
    ; state : DatafeedSubscriptionState.t option
    }

  let make ?bucket ?fault ?owner_id ?prefix ?state () =
    { bucket; fault; owner_id; prefix; state }

  let parse xml =
    Some
      { bucket = Aws.Util.option_bind (Aws.Xml.member "bucket" xml) String.parse
      ; fault =
          Aws.Util.option_bind (Aws.Xml.member "fault" xml) SpotInstanceStateFault.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; prefix = Aws.Util.option_bind (Aws.Xml.member "prefix" xml) String.parse
      ; state =
          Aws.Util.option_bind
            (Aws.Xml.member "state" xml)
            DatafeedSubscriptionState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", DatafeedSubscriptionState.to_query f))
         ; Aws.Util.option_map v.prefix (fun f ->
               Aws.Query.Pair ("Prefix", String.to_query f))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.fault (fun f ->
               Aws.Query.Pair ("Fault", SpotInstanceStateFault.to_query f))
         ; Aws.Util.option_map v.bucket (fun f ->
               Aws.Query.Pair ("Bucket", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               "state", DatafeedSubscriptionState.to_json f)
         ; Aws.Util.option_map v.prefix (fun f -> "prefix", String.to_json f)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.fault (fun f ->
               "fault", SpotInstanceStateFault.to_json f)
         ; Aws.Util.option_map v.bucket (fun f -> "bucket", String.to_json f)
         ])

  let of_json j =
    { bucket = Aws.Util.option_map (Aws.Json.lookup j "bucket") String.of_json
    ; fault =
        Aws.Util.option_map (Aws.Json.lookup j "fault") SpotInstanceStateFault.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; prefix = Aws.Util.option_map (Aws.Json.lookup j "prefix") String.of_json
    ; state =
        Aws.Util.option_map (Aws.Json.lookup j "state") DatafeedSubscriptionState.of_json
    }
end

module ProvisionedBandwidth = struct
  type t =
    { provision_time : DateTime.t option
    ; provisioned : String.t option
    ; request_time : DateTime.t option
    ; requested : String.t option
    ; status : String.t option
    }

  let make ?provision_time ?provisioned ?request_time ?requested ?status () =
    { provision_time; provisioned; request_time; requested; status }

  let parse xml =
    Some
      { provision_time =
          Aws.Util.option_bind (Aws.Xml.member "provisionTime" xml) DateTime.parse
      ; provisioned = Aws.Util.option_bind (Aws.Xml.member "provisioned" xml) String.parse
      ; request_time =
          Aws.Util.option_bind (Aws.Xml.member "requestTime" xml) DateTime.parse
      ; requested = Aws.Util.option_bind (Aws.Xml.member "requested" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "status" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.requested (fun f ->
               Aws.Query.Pair ("Requested", String.to_query f))
         ; Aws.Util.option_map v.request_time (fun f ->
               Aws.Query.Pair ("RequestTime", DateTime.to_query f))
         ; Aws.Util.option_map v.provisioned (fun f ->
               Aws.Query.Pair ("Provisioned", String.to_query f))
         ; Aws.Util.option_map v.provision_time (fun f ->
               Aws.Query.Pair ("ProvisionTime", DateTime.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f -> "status", String.to_json f)
         ; Aws.Util.option_map v.requested (fun f -> "requested", String.to_json f)
         ; Aws.Util.option_map v.request_time (fun f -> "requestTime", DateTime.to_json f)
         ; Aws.Util.option_map v.provisioned (fun f -> "provisioned", String.to_json f)
         ; Aws.Util.option_map v.provision_time (fun f ->
               "provisionTime", DateTime.to_json f)
         ])

  let of_json j =
    { provision_time =
        Aws.Util.option_map (Aws.Json.lookup j "provisionTime") DateTime.of_json
    ; provisioned = Aws.Util.option_map (Aws.Json.lookup j "provisioned") String.of_json
    ; request_time =
        Aws.Util.option_map (Aws.Json.lookup j "requestTime") DateTime.of_json
    ; requested = Aws.Util.option_map (Aws.Json.lookup j "requested") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "status") String.of_json
    }
end

module NatGatewayState = struct
  type t =
    | Pending
    | Failed
    | Available
    | Deleting
    | Deleted

  let str_to_t =
    [ "deleted", Deleted
    ; "deleting", Deleting
    ; "available", Available
    ; "failed", Failed
    ; "pending", Pending
    ]

  let t_to_str =
    [ Deleted, "deleted"
    ; Deleting, "deleting"
    ; Available, "available"
    ; Failed, "failed"
    ; Pending, "pending"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module NatGatewayAddress = struct
  type t =
    { allocation_id : String.t option
    ; network_interface_id : String.t option
    ; private_ip : String.t option
    ; public_ip : String.t option
    }

  let make ?allocation_id ?network_interface_id ?private_ip ?public_ip () =
    { allocation_id; network_interface_id; private_ip; public_ip }

  let parse xml =
    Some
      { allocation_id =
          Aws.Util.option_bind (Aws.Xml.member "allocationId" xml) String.parse
      ; network_interface_id =
          Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse
      ; private_ip = Aws.Util.option_bind (Aws.Xml.member "privateIp" xml) String.parse
      ; public_ip = Aws.Util.option_bind (Aws.Xml.member "publicIp" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.public_ip (fun f ->
               Aws.Query.Pair ("PublicIp", String.to_query f))
         ; Aws.Util.option_map v.private_ip (fun f ->
               Aws.Query.Pair ("PrivateIp", String.to_query f))
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               Aws.Query.Pair ("NetworkInterfaceId", String.to_query f))
         ; Aws.Util.option_map v.allocation_id (fun f ->
               Aws.Query.Pair ("AllocationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.public_ip (fun f -> "publicIp", String.to_json f)
         ; Aws.Util.option_map v.private_ip (fun f -> "privateIp", String.to_json f)
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               "networkInterfaceId", String.to_json f)
         ; Aws.Util.option_map v.allocation_id (fun f -> "allocationId", String.to_json f)
         ])

  let of_json j =
    { allocation_id =
        Aws.Util.option_map (Aws.Json.lookup j "allocationId") String.of_json
    ; network_interface_id =
        Aws.Util.option_map (Aws.Json.lookup j "networkInterfaceId") String.of_json
    ; private_ip = Aws.Util.option_map (Aws.Json.lookup j "privateIp") String.of_json
    ; public_ip = Aws.Util.option_map (Aws.Json.lookup j "publicIp") String.of_json
    }
end

module NatGatewayAddressList = struct
  type t = NatGatewayAddress.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map NatGatewayAddress.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list NatGatewayAddress.to_query v

  let to_json v = `List (List.map NatGatewayAddress.to_json v)

  let of_json j = Aws.Json.to_list NatGatewayAddress.of_json j
end

module NatGateway = struct
  type t =
    { create_time : DateTime.t option
    ; delete_time : DateTime.t option
    ; failure_code : String.t option
    ; failure_message : String.t option
    ; nat_gateway_addresses : NatGatewayAddressList.t
    ; nat_gateway_id : String.t option
    ; provisioned_bandwidth : ProvisionedBandwidth.t option
    ; state : NatGatewayState.t option
    ; subnet_id : String.t option
    ; vpc_id : String.t option
    ; tags : TagList.t
    }

  let make
      ?create_time
      ?delete_time
      ?failure_code
      ?failure_message
      ?(nat_gateway_addresses = [])
      ?nat_gateway_id
      ?provisioned_bandwidth
      ?state
      ?subnet_id
      ?vpc_id
      ?(tags = [])
      () =
    { create_time
    ; delete_time
    ; failure_code
    ; failure_message
    ; nat_gateway_addresses
    ; nat_gateway_id
    ; provisioned_bandwidth
    ; state
    ; subnet_id
    ; vpc_id
    ; tags
    }

  let parse xml =
    Some
      { create_time =
          Aws.Util.option_bind (Aws.Xml.member "createTime" xml) DateTime.parse
      ; delete_time =
          Aws.Util.option_bind (Aws.Xml.member "deleteTime" xml) DateTime.parse
      ; failure_code =
          Aws.Util.option_bind (Aws.Xml.member "failureCode" xml) String.parse
      ; failure_message =
          Aws.Util.option_bind (Aws.Xml.member "failureMessage" xml) String.parse
      ; nat_gateway_addresses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "natGatewayAddressSet" xml)
               NatGatewayAddressList.parse)
      ; nat_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "natGatewayId" xml) String.parse
      ; provisioned_bandwidth =
          Aws.Util.option_bind
            (Aws.Xml.member "provisionedBandwidth" xml)
            ProvisionedBandwidth.parse
      ; state = Aws.Util.option_bind (Aws.Xml.member "state" xml) NatGatewayState.parse
      ; subnet_id = Aws.Util.option_bind (Aws.Xml.member "subnetId" xml) String.parse
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Aws.Util.option_map v.subnet_id (fun f ->
               Aws.Query.Pair ("SubnetId", String.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", NatGatewayState.to_query f))
         ; Aws.Util.option_map v.provisioned_bandwidth (fun f ->
               Aws.Query.Pair ("ProvisionedBandwidth", ProvisionedBandwidth.to_query f))
         ; Aws.Util.option_map v.nat_gateway_id (fun f ->
               Aws.Query.Pair ("NatGatewayId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "NatGatewayAddressSet"
                , NatGatewayAddressList.to_query v.nat_gateway_addresses ))
         ; Aws.Util.option_map v.failure_message (fun f ->
               Aws.Query.Pair ("FailureMessage", String.to_query f))
         ; Aws.Util.option_map v.failure_code (fun f ->
               Aws.Query.Pair ("FailureCode", String.to_query f))
         ; Aws.Util.option_map v.delete_time (fun f ->
               Aws.Query.Pair ("DeleteTime", DateTime.to_query f))
         ; Aws.Util.option_map v.create_time (fun f ->
               Aws.Query.Pair ("CreateTime", DateTime.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.vpc_id (fun f -> "vpcId", String.to_json f)
         ; Aws.Util.option_map v.subnet_id (fun f -> "subnetId", String.to_json f)
         ; Aws.Util.option_map v.state (fun f -> "state", NatGatewayState.to_json f)
         ; Aws.Util.option_map v.provisioned_bandwidth (fun f ->
               "provisionedBandwidth", ProvisionedBandwidth.to_json f)
         ; Aws.Util.option_map v.nat_gateway_id (fun f ->
               "natGatewayId", String.to_json f)
         ; Some
             ( "natGatewayAddressSet"
             , NatGatewayAddressList.to_json v.nat_gateway_addresses )
         ; Aws.Util.option_map v.failure_message (fun f ->
               "failureMessage", String.to_json f)
         ; Aws.Util.option_map v.failure_code (fun f -> "failureCode", String.to_json f)
         ; Aws.Util.option_map v.delete_time (fun f -> "deleteTime", DateTime.to_json f)
         ; Aws.Util.option_map v.create_time (fun f -> "createTime", DateTime.to_json f)
         ])

  let of_json j =
    { create_time = Aws.Util.option_map (Aws.Json.lookup j "createTime") DateTime.of_json
    ; delete_time = Aws.Util.option_map (Aws.Json.lookup j "deleteTime") DateTime.of_json
    ; failure_code = Aws.Util.option_map (Aws.Json.lookup j "failureCode") String.of_json
    ; failure_message =
        Aws.Util.option_map (Aws.Json.lookup j "failureMessage") String.of_json
    ; nat_gateway_addresses =
        NatGatewayAddressList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "natGatewayAddressSet"))
    ; nat_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "natGatewayId") String.of_json
    ; provisioned_bandwidth =
        Aws.Util.option_map
          (Aws.Json.lookup j "provisionedBandwidth")
          ProvisionedBandwidth.of_json
    ; state = Aws.Util.option_map (Aws.Json.lookup j "state") NatGatewayState.of_json
    ; subnet_id = Aws.Util.option_map (Aws.Json.lookup j "subnetId") String.of_json
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "vpcId") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module NatGatewayList = struct
  type t = NatGateway.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map NatGateway.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list NatGateway.to_query v

  let to_json v = `List (List.map NatGateway.to_json v)

  let of_json j = Aws.Json.to_list NatGateway.of_json j
end

module DescribeNatGatewaysResult = struct
  type t =
    { nat_gateways : NatGatewayList.t
    ; next_token : String.t option
    }

  let make ?(nat_gateways = []) ?next_token () = { nat_gateways; next_token }

  let parse xml =
    Some
      { nat_gateways =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "natGatewaySet" xml)
               NatGatewayList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("NatGatewaySet", NatGatewayList.to_query v.nat_gateways))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("natGatewaySet", NatGatewayList.to_json v.nat_gateways)
         ])

  let of_json j =
    { nat_gateways =
        NatGatewayList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "natGatewaySet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module VersionStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DeleteLaunchTemplateVersionsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; launch_template_id : String.t option
    ; launch_template_name : String.t option
    ; versions : VersionStringList.t
    }

  let make ?dry_run ?launch_template_id ?launch_template_name ~versions () =
    { dry_run; launch_template_id; launch_template_name; versions }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; launch_template_id =
          Aws.Util.option_bind (Aws.Xml.member "LaunchTemplateId" xml) String.parse
      ; launch_template_name =
          Aws.Util.option_bind (Aws.Xml.member "LaunchTemplateName" xml) String.parse
      ; versions =
          Aws.Xml.required
            "LaunchTemplateVersion"
            (Aws.Util.option_bind
               (Aws.Xml.member "LaunchTemplateVersion" xml)
               VersionStringList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("LaunchTemplateVersion", VersionStringList.to_query v.versions))
         ; Aws.Util.option_map v.launch_template_name (fun f ->
               Aws.Query.Pair ("LaunchTemplateName", String.to_query f))
         ; Aws.Util.option_map v.launch_template_id (fun f ->
               Aws.Query.Pair ("LaunchTemplateId", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("LaunchTemplateVersion", VersionStringList.to_json v.versions)
         ; Aws.Util.option_map v.launch_template_name (fun f ->
               "LaunchTemplateName", String.to_json f)
         ; Aws.Util.option_map v.launch_template_id (fun f ->
               "LaunchTemplateId", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; launch_template_id =
        Aws.Util.option_map (Aws.Json.lookup j "LaunchTemplateId") String.of_json
    ; launch_template_name =
        Aws.Util.option_map (Aws.Json.lookup j "LaunchTemplateName") String.of_json
    ; versions =
        VersionStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "LaunchTemplateVersion"))
    }
end

module AttributeBooleanValue = struct
  type t = { value : Boolean.t option }

  let make ?value () = { value }

  let parse xml =
    Some { value = Aws.Util.option_bind (Aws.Xml.member "value" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f -> "value", Boolean.to_json f) ])

  let of_json j =
    { value = Aws.Util.option_map (Aws.Json.lookup j "value") Boolean.of_json }
end

module DescribeVpcAttributeResult = struct
  type t =
    { vpc_id : String.t option
    ; enable_dns_hostnames : AttributeBooleanValue.t option
    ; enable_dns_support : AttributeBooleanValue.t option
    }

  let make ?vpc_id ?enable_dns_hostnames ?enable_dns_support () =
    { vpc_id; enable_dns_hostnames; enable_dns_support }

  let parse xml =
    Some
      { vpc_id = Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse
      ; enable_dns_hostnames =
          Aws.Util.option_bind
            (Aws.Xml.member "enableDnsHostnames" xml)
            AttributeBooleanValue.parse
      ; enable_dns_support =
          Aws.Util.option_bind
            (Aws.Xml.member "enableDnsSupport" xml)
            AttributeBooleanValue.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enable_dns_support (fun f ->
               Aws.Query.Pair ("EnableDnsSupport", AttributeBooleanValue.to_query f))
         ; Aws.Util.option_map v.enable_dns_hostnames (fun f ->
               Aws.Query.Pair ("EnableDnsHostnames", AttributeBooleanValue.to_query f))
         ; Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enable_dns_support (fun f ->
               "enableDnsSupport", AttributeBooleanValue.to_json f)
         ; Aws.Util.option_map v.enable_dns_hostnames (fun f ->
               "enableDnsHostnames", AttributeBooleanValue.to_json f)
         ; Aws.Util.option_map v.vpc_id (fun f -> "vpcId", String.to_json f)
         ])

  let of_json j =
    { vpc_id = Aws.Util.option_map (Aws.Json.lookup j "vpcId") String.of_json
    ; enable_dns_hostnames =
        Aws.Util.option_map
          (Aws.Json.lookup j "enableDnsHostnames")
          AttributeBooleanValue.of_json
    ; enable_dns_support =
        Aws.Util.option_map
          (Aws.Json.lookup j "enableDnsSupport")
          AttributeBooleanValue.of_json
    }
end

module CoipPoolIdSet = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module ArchitectureValues = struct
  type t =
    | I386
    | X86_64
    | Arm64

  let str_to_t = [ "arm64", Arm64; "x86_64", X86_64; "i386", I386 ]

  let t_to_str = [ Arm64, "arm64"; X86_64, "x86_64"; I386, "i386" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module VpnEcmpSupportValue = struct
  type t =
    | Enable
    | Disable

  let str_to_t = [ "disable", Disable; "enable", Enable ]

  let t_to_str = [ Disable, "disable"; Enable, "enable" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DnsSupportValue = struct
  type t =
    | Enable
    | Disable

  let str_to_t = [ "disable", Disable; "enable", Enable ]

  let t_to_str = [ Disable, "disable"; Enable, "enable" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DefaultRouteTablePropagationValue = struct
  type t =
    | Enable
    | Disable

  let str_to_t = [ "disable", Disable; "enable", Enable ]

  let t_to_str = [ Disable, "disable"; Enable, "enable" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DefaultRouteTableAssociationValue = struct
  type t =
    | Enable
    | Disable

  let str_to_t = [ "disable", Disable; "enable", Enable ]

  let t_to_str = [ Disable, "disable"; Enable, "enable" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module AutoAcceptSharedAttachmentsValue = struct
  type t =
    | Enable
    | Disable

  let str_to_t = [ "disable", Disable; "enable", Enable ]

  let t_to_str = [ Disable, "disable"; Enable, "enable" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ModifyTransitGatewayOptions = struct
  type t =
    { vpn_ecmp_support : VpnEcmpSupportValue.t option
    ; dns_support : DnsSupportValue.t option
    ; auto_accept_shared_attachments : AutoAcceptSharedAttachmentsValue.t option
    ; default_route_table_association : DefaultRouteTableAssociationValue.t option
    ; association_default_route_table_id : String.t option
    ; default_route_table_propagation : DefaultRouteTablePropagationValue.t option
    ; propagation_default_route_table_id : String.t option
    }

  let make
      ?vpn_ecmp_support
      ?dns_support
      ?auto_accept_shared_attachments
      ?default_route_table_association
      ?association_default_route_table_id
      ?default_route_table_propagation
      ?propagation_default_route_table_id
      () =
    { vpn_ecmp_support
    ; dns_support
    ; auto_accept_shared_attachments
    ; default_route_table_association
    ; association_default_route_table_id
    ; default_route_table_propagation
    ; propagation_default_route_table_id
    }

  let parse xml =
    Some
      { vpn_ecmp_support =
          Aws.Util.option_bind
            (Aws.Xml.member "VpnEcmpSupport" xml)
            VpnEcmpSupportValue.parse
      ; dns_support =
          Aws.Util.option_bind (Aws.Xml.member "DnsSupport" xml) DnsSupportValue.parse
      ; auto_accept_shared_attachments =
          Aws.Util.option_bind
            (Aws.Xml.member "AutoAcceptSharedAttachments" xml)
            AutoAcceptSharedAttachmentsValue.parse
      ; default_route_table_association =
          Aws.Util.option_bind
            (Aws.Xml.member "DefaultRouteTableAssociation" xml)
            DefaultRouteTableAssociationValue.parse
      ; association_default_route_table_id =
          Aws.Util.option_bind
            (Aws.Xml.member "AssociationDefaultRouteTableId" xml)
            String.parse
      ; default_route_table_propagation =
          Aws.Util.option_bind
            (Aws.Xml.member "DefaultRouteTablePropagation" xml)
            DefaultRouteTablePropagationValue.parse
      ; propagation_default_route_table_id =
          Aws.Util.option_bind
            (Aws.Xml.member "PropagationDefaultRouteTableId" xml)
            String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.propagation_default_route_table_id (fun f ->
               Aws.Query.Pair ("PropagationDefaultRouteTableId", String.to_query f))
         ; Aws.Util.option_map v.default_route_table_propagation (fun f ->
               Aws.Query.Pair
                 ( "DefaultRouteTablePropagation"
                 , DefaultRouteTablePropagationValue.to_query f ))
         ; Aws.Util.option_map v.association_default_route_table_id (fun f ->
               Aws.Query.Pair ("AssociationDefaultRouteTableId", String.to_query f))
         ; Aws.Util.option_map v.default_route_table_association (fun f ->
               Aws.Query.Pair
                 ( "DefaultRouteTableAssociation"
                 , DefaultRouteTableAssociationValue.to_query f ))
         ; Aws.Util.option_map v.auto_accept_shared_attachments (fun f ->
               Aws.Query.Pair
                 ( "AutoAcceptSharedAttachments"
                 , AutoAcceptSharedAttachmentsValue.to_query f ))
         ; Aws.Util.option_map v.dns_support (fun f ->
               Aws.Query.Pair ("DnsSupport", DnsSupportValue.to_query f))
         ; Aws.Util.option_map v.vpn_ecmp_support (fun f ->
               Aws.Query.Pair ("VpnEcmpSupport", VpnEcmpSupportValue.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.propagation_default_route_table_id (fun f ->
               "PropagationDefaultRouteTableId", String.to_json f)
         ; Aws.Util.option_map v.default_route_table_propagation (fun f ->
               "DefaultRouteTablePropagation", DefaultRouteTablePropagationValue.to_json f)
         ; Aws.Util.option_map v.association_default_route_table_id (fun f ->
               "AssociationDefaultRouteTableId", String.to_json f)
         ; Aws.Util.option_map v.default_route_table_association (fun f ->
               "DefaultRouteTableAssociation", DefaultRouteTableAssociationValue.to_json f)
         ; Aws.Util.option_map v.auto_accept_shared_attachments (fun f ->
               "AutoAcceptSharedAttachments", AutoAcceptSharedAttachmentsValue.to_json f)
         ; Aws.Util.option_map v.dns_support (fun f ->
               "DnsSupport", DnsSupportValue.to_json f)
         ; Aws.Util.option_map v.vpn_ecmp_support (fun f ->
               "VpnEcmpSupport", VpnEcmpSupportValue.to_json f)
         ])

  let of_json j =
    { vpn_ecmp_support =
        Aws.Util.option_map
          (Aws.Json.lookup j "VpnEcmpSupport")
          VpnEcmpSupportValue.of_json
    ; dns_support =
        Aws.Util.option_map (Aws.Json.lookup j "DnsSupport") DnsSupportValue.of_json
    ; auto_accept_shared_attachments =
        Aws.Util.option_map
          (Aws.Json.lookup j "AutoAcceptSharedAttachments")
          AutoAcceptSharedAttachmentsValue.of_json
    ; default_route_table_association =
        Aws.Util.option_map
          (Aws.Json.lookup j "DefaultRouteTableAssociation")
          DefaultRouteTableAssociationValue.of_json
    ; association_default_route_table_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "AssociationDefaultRouteTableId")
          String.of_json
    ; default_route_table_propagation =
        Aws.Util.option_map
          (Aws.Json.lookup j "DefaultRouteTablePropagation")
          DefaultRouteTablePropagationValue.of_json
    ; propagation_default_route_table_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "PropagationDefaultRouteTableId")
          String.of_json
    }
end

module InstanceTagKeySet = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module RegisterInstanceTagAttributeRequest = struct
  type t =
    { include_all_tags_of_instance : Boolean.t option
    ; instance_tag_keys : InstanceTagKeySet.t
    }

  let make ?include_all_tags_of_instance ?(instance_tag_keys = []) () =
    { include_all_tags_of_instance; instance_tag_keys }

  let parse xml =
    Some
      { include_all_tags_of_instance =
          Aws.Util.option_bind
            (Aws.Xml.member "IncludeAllTagsOfInstance" xml)
            Boolean.parse
      ; instance_tag_keys =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "InstanceTagKey" xml)
               InstanceTagKeySet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("InstanceTagKey", InstanceTagKeySet.to_query v.instance_tag_keys))
         ; Aws.Util.option_map v.include_all_tags_of_instance (fun f ->
               Aws.Query.Pair ("IncludeAllTagsOfInstance", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("InstanceTagKey", InstanceTagKeySet.to_json v.instance_tag_keys)
         ; Aws.Util.option_map v.include_all_tags_of_instance (fun f ->
               "IncludeAllTagsOfInstance", Boolean.to_json f)
         ])

  let of_json j =
    { include_all_tags_of_instance =
        Aws.Util.option_map (Aws.Json.lookup j "IncludeAllTagsOfInstance") Boolean.of_json
    ; instance_tag_keys =
        InstanceTagKeySet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceTagKey"))
    }
end

module RegisterInstanceEventNotificationAttributesRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; instance_tag_attribute : RegisterInstanceTagAttributeRequest.t option
    }

  let make ?dry_run ?instance_tag_attribute () = { dry_run; instance_tag_attribute }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; instance_tag_attribute =
          Aws.Util.option_bind
            (Aws.Xml.member "InstanceTagAttribute" xml)
            RegisterInstanceTagAttributeRequest.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_tag_attribute (fun f ->
               Aws.Query.Pair
                 ("InstanceTagAttribute", RegisterInstanceTagAttributeRequest.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_tag_attribute (fun f ->
               "InstanceTagAttribute", RegisterInstanceTagAttributeRequest.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; instance_tag_attribute =
        Aws.Util.option_map
          (Aws.Json.lookup j "InstanceTagAttribute")
          RegisterInstanceTagAttributeRequest.of_json
    }
end

module EnableFastSnapshotRestoreStateError = struct
  type t =
    { code : String.t option
    ; message : String.t option
    }

  let make ?code ?message () = { code; message }

  let parse xml =
    Some
      { code = Aws.Util.option_bind (Aws.Xml.member "code" xml) String.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair ("Code", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f)
         ; Aws.Util.option_map v.code (fun f -> "code", String.to_json f)
         ])

  let of_json j =
    { code = Aws.Util.option_map (Aws.Json.lookup j "code") String.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json
    }
end

module EnableFastSnapshotRestoreStateErrorItem = struct
  type t =
    { availability_zone : String.t option
    ; error : EnableFastSnapshotRestoreStateError.t option
    }

  let make ?availability_zone ?error () = { availability_zone; error }

  let parse xml =
    Some
      { availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; error =
          Aws.Util.option_bind
            (Aws.Xml.member "error" xml)
            EnableFastSnapshotRestoreStateError.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.error (fun f ->
               Aws.Query.Pair ("Error", EnableFastSnapshotRestoreStateError.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.error (fun f ->
               "error", EnableFastSnapshotRestoreStateError.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ])

  let of_json j =
    { availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; error =
        Aws.Util.option_map
          (Aws.Json.lookup j "error")
          EnableFastSnapshotRestoreStateError.of_json
    }
end

module EnableFastSnapshotRestoreStateErrorSet = struct
  type t = EnableFastSnapshotRestoreStateErrorItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         EnableFastSnapshotRestoreStateErrorItem.parse
         (Aws.Xml.members "item" xml))

  let to_query v =
    Aws.Query.to_query_list EnableFastSnapshotRestoreStateErrorItem.to_query v

  let to_json v = `List (List.map EnableFastSnapshotRestoreStateErrorItem.to_json v)

  let of_json j = Aws.Json.to_list EnableFastSnapshotRestoreStateErrorItem.of_json j
end

module DisableVgwRoutePropagationRequest = struct
  type t =
    { gateway_id : String.t
    ; route_table_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~gateway_id ~route_table_id ?dry_run () =
    { gateway_id; route_table_id; dry_run }

  let parse xml =
    Some
      { gateway_id =
          Aws.Xml.required
            "GatewayId"
            (Aws.Util.option_bind (Aws.Xml.member "GatewayId" xml) String.parse)
      ; route_table_id =
          Aws.Xml.required
            "RouteTableId"
            (Aws.Util.option_bind (Aws.Xml.member "RouteTableId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("RouteTableId", String.to_query v.route_table_id))
         ; Some (Aws.Query.Pair ("GatewayId", String.to_query v.gateway_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("RouteTableId", String.to_json v.route_table_id)
         ; Some ("GatewayId", String.to_json v.gateway_id)
         ])

  let of_json j =
    { gateway_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "GatewayId"))
    ; route_table_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "RouteTableId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module FleetLaunchTemplateSpecification = struct
  type t =
    { launch_template_id : String.t option
    ; launch_template_name : String.t option
    ; version : String.t option
    }

  let make ?launch_template_id ?launch_template_name ?version () =
    { launch_template_id; launch_template_name; version }

  let parse xml =
    Some
      { launch_template_id =
          Aws.Util.option_bind (Aws.Xml.member "launchTemplateId" xml) String.parse
      ; launch_template_name =
          Aws.Util.option_bind (Aws.Xml.member "launchTemplateName" xml) String.parse
      ; version = Aws.Util.option_bind (Aws.Xml.member "version" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.version (fun f ->
               Aws.Query.Pair ("Version", String.to_query f))
         ; Aws.Util.option_map v.launch_template_name (fun f ->
               Aws.Query.Pair ("LaunchTemplateName", String.to_query f))
         ; Aws.Util.option_map v.launch_template_id (fun f ->
               Aws.Query.Pair ("LaunchTemplateId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.version (fun f -> "version", String.to_json f)
         ; Aws.Util.option_map v.launch_template_name (fun f ->
               "launchTemplateName", String.to_json f)
         ; Aws.Util.option_map v.launch_template_id (fun f ->
               "launchTemplateId", String.to_json f)
         ])

  let of_json j =
    { launch_template_id =
        Aws.Util.option_map (Aws.Json.lookup j "launchTemplateId") String.of_json
    ; launch_template_name =
        Aws.Util.option_map (Aws.Json.lookup j "launchTemplateName") String.of_json
    ; version = Aws.Util.option_map (Aws.Json.lookup j "version") String.of_json
    }
end

module LaunchTemplateAndOverridesResponse = struct
  type t =
    { launch_template_specification : FleetLaunchTemplateSpecification.t option
    ; overrides : FleetLaunchTemplateOverrides.t option
    }

  let make ?launch_template_specification ?overrides () =
    { launch_template_specification; overrides }

  let parse xml =
    Some
      { launch_template_specification =
          Aws.Util.option_bind
            (Aws.Xml.member "launchTemplateSpecification" xml)
            FleetLaunchTemplateSpecification.parse
      ; overrides =
          Aws.Util.option_bind
            (Aws.Xml.member "overrides" xml)
            FleetLaunchTemplateOverrides.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.overrides (fun f ->
               Aws.Query.Pair ("Overrides", FleetLaunchTemplateOverrides.to_query f))
         ; Aws.Util.option_map v.launch_template_specification (fun f ->
               Aws.Query.Pair
                 ( "LaunchTemplateSpecification"
                 , FleetLaunchTemplateSpecification.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.overrides (fun f ->
               "overrides", FleetLaunchTemplateOverrides.to_json f)
         ; Aws.Util.option_map v.launch_template_specification (fun f ->
               "launchTemplateSpecification", FleetLaunchTemplateSpecification.to_json f)
         ])

  let of_json j =
    { launch_template_specification =
        Aws.Util.option_map
          (Aws.Json.lookup j "launchTemplateSpecification")
          FleetLaunchTemplateSpecification.of_json
    ; overrides =
        Aws.Util.option_map
          (Aws.Json.lookup j "overrides")
          FleetLaunchTemplateOverrides.of_json
    }
end

module CarrierGatewayState = struct
  type t =
    | Pending
    | Available
    | Deleting
    | Deleted

  let str_to_t =
    [ "deleted", Deleted
    ; "deleting", Deleting
    ; "available", Available
    ; "pending", Pending
    ]

  let t_to_str =
    [ Deleted, "deleted"
    ; Deleting, "deleting"
    ; Available, "available"
    ; Pending, "pending"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module CarrierGateway = struct
  type t =
    { carrier_gateway_id : String.t option
    ; vpc_id : String.t option
    ; state : CarrierGatewayState.t option
    ; owner_id : String.t option
    ; tags : TagList.t
    }

  let make ?carrier_gateway_id ?vpc_id ?state ?owner_id ?(tags = []) () =
    { carrier_gateway_id; vpc_id; state; owner_id; tags }

  let parse xml =
    Some
      { carrier_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "carrierGatewayId" xml) String.parse
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse
      ; state =
          Aws.Util.option_bind (Aws.Xml.member "state" xml) CarrierGatewayState.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", CarrierGatewayState.to_query f))
         ; Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Aws.Util.option_map v.carrier_gateway_id (fun f ->
               Aws.Query.Pair ("CarrierGatewayId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.state (fun f -> "state", CarrierGatewayState.to_json f)
         ; Aws.Util.option_map v.vpc_id (fun f -> "vpcId", String.to_json f)
         ; Aws.Util.option_map v.carrier_gateway_id (fun f ->
               "carrierGatewayId", String.to_json f)
         ])

  let of_json j =
    { carrier_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "carrierGatewayId") String.of_json
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "vpcId") String.of_json
    ; state = Aws.Util.option_map (Aws.Json.lookup j "state") CarrierGatewayState.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module DeleteCarrierGatewayResult = struct
  type t = { carrier_gateway : CarrierGateway.t option }

  let make ?carrier_gateway () = { carrier_gateway }

  let parse xml =
    Some
      { carrier_gateway =
          Aws.Util.option_bind (Aws.Xml.member "carrierGateway" xml) CarrierGateway.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.carrier_gateway (fun f ->
               Aws.Query.Pair ("CarrierGateway", CarrierGateway.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.carrier_gateway (fun f ->
               "carrierGateway", CarrierGateway.to_json f)
         ])

  let of_json j =
    { carrier_gateway =
        Aws.Util.option_map (Aws.Json.lookup j "carrierGateway") CarrierGateway.of_json
    }
end

module InterfacePermissionType = struct
  type t =
    | INSTANCE_ATTACH
    | EIP_ASSOCIATE

  let str_to_t = [ "EIP-ASSOCIATE", EIP_ASSOCIATE; "INSTANCE-ATTACH", INSTANCE_ATTACH ]

  let t_to_str = [ EIP_ASSOCIATE, "EIP-ASSOCIATE"; INSTANCE_ATTACH, "INSTANCE-ATTACH" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module UpdateSecurityGroupRuleDescriptionsEgressResult = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module EbsBlockDevice = struct
  type t =
    { delete_on_termination : Boolean.t option
    ; iops : Integer.t option
    ; snapshot_id : String.t option
    ; volume_size : Integer.t option
    ; volume_type : VolumeType.t option
    ; kms_key_id : String.t option
    ; encrypted : Boolean.t option
    }

  let make
      ?delete_on_termination
      ?iops
      ?snapshot_id
      ?volume_size
      ?volume_type
      ?kms_key_id
      ?encrypted
      () =
    { delete_on_termination
    ; iops
    ; snapshot_id
    ; volume_size
    ; volume_type
    ; kms_key_id
    ; encrypted
    }

  let parse xml =
    Some
      { delete_on_termination =
          Aws.Util.option_bind (Aws.Xml.member "deleteOnTermination" xml) Boolean.parse
      ; iops = Aws.Util.option_bind (Aws.Xml.member "iops" xml) Integer.parse
      ; snapshot_id = Aws.Util.option_bind (Aws.Xml.member "snapshotId" xml) String.parse
      ; volume_size = Aws.Util.option_bind (Aws.Xml.member "volumeSize" xml) Integer.parse
      ; volume_type =
          Aws.Util.option_bind (Aws.Xml.member "volumeType" xml) VolumeType.parse
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "KmsKeyId" xml) String.parse
      ; encrypted = Aws.Util.option_bind (Aws.Xml.member "encrypted" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.encrypted (fun f ->
               Aws.Query.Pair ("Encrypted", Boolean.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Aws.Util.option_map v.volume_type (fun f ->
               Aws.Query.Pair ("VolumeType", VolumeType.to_query f))
         ; Aws.Util.option_map v.volume_size (fun f ->
               Aws.Query.Pair ("VolumeSize", Integer.to_query f))
         ; Aws.Util.option_map v.snapshot_id (fun f ->
               Aws.Query.Pair ("SnapshotId", String.to_query f))
         ; Aws.Util.option_map v.iops (fun f ->
               Aws.Query.Pair ("Iops", Integer.to_query f))
         ; Aws.Util.option_map v.delete_on_termination (fun f ->
               Aws.Query.Pair ("DeleteOnTermination", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.encrypted (fun f -> "encrypted", Boolean.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "KmsKeyId", String.to_json f)
         ; Aws.Util.option_map v.volume_type (fun f -> "volumeType", VolumeType.to_json f)
         ; Aws.Util.option_map v.volume_size (fun f -> "volumeSize", Integer.to_json f)
         ; Aws.Util.option_map v.snapshot_id (fun f -> "snapshotId", String.to_json f)
         ; Aws.Util.option_map v.iops (fun f -> "iops", Integer.to_json f)
         ; Aws.Util.option_map v.delete_on_termination (fun f ->
               "deleteOnTermination", Boolean.to_json f)
         ])

  let of_json j =
    { delete_on_termination =
        Aws.Util.option_map (Aws.Json.lookup j "deleteOnTermination") Boolean.of_json
    ; iops = Aws.Util.option_map (Aws.Json.lookup j "iops") Integer.of_json
    ; snapshot_id = Aws.Util.option_map (Aws.Json.lookup j "snapshotId") String.of_json
    ; volume_size = Aws.Util.option_map (Aws.Json.lookup j "volumeSize") Integer.of_json
    ; volume_type =
        Aws.Util.option_map (Aws.Json.lookup j "volumeType") VolumeType.of_json
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "KmsKeyId") String.of_json
    ; encrypted = Aws.Util.option_map (Aws.Json.lookup j "encrypted") Boolean.of_json
    }
end

module BlockDeviceMapping = struct
  type t =
    { device_name : String.t
    ; virtual_name : String.t option
    ; ebs : EbsBlockDevice.t option
    ; no_device : String.t option
    }

  let make ~device_name ?virtual_name ?ebs ?no_device () =
    { device_name; virtual_name; ebs; no_device }

  let parse xml =
    Some
      { device_name =
          Aws.Xml.required
            "deviceName"
            (Aws.Util.option_bind (Aws.Xml.member "deviceName" xml) String.parse)
      ; virtual_name =
          Aws.Util.option_bind (Aws.Xml.member "virtualName" xml) String.parse
      ; ebs = Aws.Util.option_bind (Aws.Xml.member "ebs" xml) EbsBlockDevice.parse
      ; no_device = Aws.Util.option_bind (Aws.Xml.member "noDevice" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.no_device (fun f ->
               Aws.Query.Pair ("NoDevice", String.to_query f))
         ; Aws.Util.option_map v.ebs (fun f ->
               Aws.Query.Pair ("Ebs", EbsBlockDevice.to_query f))
         ; Aws.Util.option_map v.virtual_name (fun f ->
               Aws.Query.Pair ("VirtualName", String.to_query f))
         ; Some (Aws.Query.Pair ("DeviceName", String.to_query v.device_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.no_device (fun f -> "noDevice", String.to_json f)
         ; Aws.Util.option_map v.ebs (fun f -> "ebs", EbsBlockDevice.to_json f)
         ; Aws.Util.option_map v.virtual_name (fun f -> "virtualName", String.to_json f)
         ; Some ("deviceName", String.to_json v.device_name)
         ])

  let of_json j =
    { device_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "deviceName"))
    ; virtual_name = Aws.Util.option_map (Aws.Json.lookup j "virtualName") String.of_json
    ; ebs = Aws.Util.option_map (Aws.Json.lookup j "ebs") EbsBlockDevice.of_json
    ; no_device = Aws.Util.option_map (Aws.Json.lookup j "noDevice") String.of_json
    }
end

module RevokeSecurityGroupIngressRequest = struct
  type t =
    { cidr_ip : String.t option
    ; from_port : Integer.t option
    ; group_id : String.t option
    ; group_name : String.t option
    ; ip_permissions : IpPermissionList.t
    ; ip_protocol : String.t option
    ; source_security_group_name : String.t option
    ; source_security_group_owner_id : String.t option
    ; to_port : Integer.t option
    ; dry_run : Boolean.t option
    }

  let make
      ?cidr_ip
      ?from_port
      ?group_id
      ?group_name
      ?(ip_permissions = [])
      ?ip_protocol
      ?source_security_group_name
      ?source_security_group_owner_id
      ?to_port
      ?dry_run
      () =
    { cidr_ip
    ; from_port
    ; group_id
    ; group_name
    ; ip_permissions
    ; ip_protocol
    ; source_security_group_name
    ; source_security_group_owner_id
    ; to_port
    ; dry_run
    }

  let parse xml =
    Some
      { cidr_ip = Aws.Util.option_bind (Aws.Xml.member "CidrIp" xml) String.parse
      ; from_port = Aws.Util.option_bind (Aws.Xml.member "FromPort" xml) Integer.parse
      ; group_id = Aws.Util.option_bind (Aws.Xml.member "GroupId" xml) String.parse
      ; group_name = Aws.Util.option_bind (Aws.Xml.member "GroupName" xml) String.parse
      ; ip_permissions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "IpPermissions" xml)
               IpPermissionList.parse)
      ; ip_protocol = Aws.Util.option_bind (Aws.Xml.member "IpProtocol" xml) String.parse
      ; source_security_group_name =
          Aws.Util.option_bind (Aws.Xml.member "SourceSecurityGroupName" xml) String.parse
      ; source_security_group_owner_id =
          Aws.Util.option_bind
            (Aws.Xml.member "SourceSecurityGroupOwnerId" xml)
            String.parse
      ; to_port = Aws.Util.option_bind (Aws.Xml.member "ToPort" xml) Integer.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.to_port (fun f ->
               Aws.Query.Pair ("ToPort", Integer.to_query f))
         ; Aws.Util.option_map v.source_security_group_owner_id (fun f ->
               Aws.Query.Pair ("SourceSecurityGroupOwnerId", String.to_query f))
         ; Aws.Util.option_map v.source_security_group_name (fun f ->
               Aws.Query.Pair ("SourceSecurityGroupName", String.to_query f))
         ; Aws.Util.option_map v.ip_protocol (fun f ->
               Aws.Query.Pair ("IpProtocol", String.to_query f))
         ; Some
             (Aws.Query.Pair ("IpPermissions", IpPermissionList.to_query v.ip_permissions))
         ; Aws.Util.option_map v.group_name (fun f ->
               Aws.Query.Pair ("GroupName", String.to_query f))
         ; Aws.Util.option_map v.group_id (fun f ->
               Aws.Query.Pair ("GroupId", String.to_query f))
         ; Aws.Util.option_map v.from_port (fun f ->
               Aws.Query.Pair ("FromPort", Integer.to_query f))
         ; Aws.Util.option_map v.cidr_ip (fun f ->
               Aws.Query.Pair ("CidrIp", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.to_port (fun f -> "ToPort", Integer.to_json f)
         ; Aws.Util.option_map v.source_security_group_owner_id (fun f ->
               "SourceSecurityGroupOwnerId", String.to_json f)
         ; Aws.Util.option_map v.source_security_group_name (fun f ->
               "SourceSecurityGroupName", String.to_json f)
         ; Aws.Util.option_map v.ip_protocol (fun f -> "IpProtocol", String.to_json f)
         ; Some ("IpPermissions", IpPermissionList.to_json v.ip_permissions)
         ; Aws.Util.option_map v.group_name (fun f -> "GroupName", String.to_json f)
         ; Aws.Util.option_map v.group_id (fun f -> "GroupId", String.to_json f)
         ; Aws.Util.option_map v.from_port (fun f -> "FromPort", Integer.to_json f)
         ; Aws.Util.option_map v.cidr_ip (fun f -> "CidrIp", String.to_json f)
         ])

  let of_json j =
    { cidr_ip = Aws.Util.option_map (Aws.Json.lookup j "CidrIp") String.of_json
    ; from_port = Aws.Util.option_map (Aws.Json.lookup j "FromPort") Integer.of_json
    ; group_id = Aws.Util.option_map (Aws.Json.lookup j "GroupId") String.of_json
    ; group_name = Aws.Util.option_map (Aws.Json.lookup j "GroupName") String.of_json
    ; ip_permissions =
        IpPermissionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "IpPermissions"))
    ; ip_protocol = Aws.Util.option_map (Aws.Json.lookup j "IpProtocol") String.of_json
    ; source_security_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "SourceSecurityGroupName") String.of_json
    ; source_security_group_owner_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "SourceSecurityGroupOwnerId")
          String.of_json
    ; to_port = Aws.Util.option_map (Aws.Json.lookup j "ToPort") Integer.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module DiskImageVolumeDescription = struct
  type t =
    { id : String.t option
    ; size : Long.t option
    }

  let make ?id ?size () = { id; size }

  let parse xml =
    Some
      { id = Aws.Util.option_bind (Aws.Xml.member "id" xml) String.parse
      ; size = Aws.Util.option_bind (Aws.Xml.member "size" xml) Long.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.size (fun f -> Aws.Query.Pair ("Size", Long.to_query f))
         ; Aws.Util.option_map v.id (fun f -> Aws.Query.Pair ("Id", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.size (fun f -> "size", Long.to_json f)
         ; Aws.Util.option_map v.id (fun f -> "id", String.to_json f)
         ])

  let of_json j =
    { id = Aws.Util.option_map (Aws.Json.lookup j "id") String.of_json
    ; size = Aws.Util.option_map (Aws.Json.lookup j "size") Long.of_json
    }
end

module DiskImageFormat = struct
  type t =
    | VMDK
    | RAW
    | VHD

  let str_to_t = [ "VHD", VHD; "RAW", RAW; "VMDK", VMDK ]

  let t_to_str = [ VHD, "VHD"; RAW, "RAW"; VMDK, "VMDK" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DiskImageDescription = struct
  type t =
    { checksum : String.t option
    ; format : DiskImageFormat.t option
    ; import_manifest_url : String.t option
    ; size : Long.t option
    }

  let make ?checksum ?format ?import_manifest_url ?size () =
    { checksum; format; import_manifest_url; size }

  let parse xml =
    Some
      { checksum = Aws.Util.option_bind (Aws.Xml.member "checksum" xml) String.parse
      ; format = Aws.Util.option_bind (Aws.Xml.member "format" xml) DiskImageFormat.parse
      ; import_manifest_url =
          Aws.Util.option_bind (Aws.Xml.member "importManifestUrl" xml) String.parse
      ; size = Aws.Util.option_bind (Aws.Xml.member "size" xml) Long.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.size (fun f -> Aws.Query.Pair ("Size", Long.to_query f))
         ; Aws.Util.option_map v.import_manifest_url (fun f ->
               Aws.Query.Pair ("ImportManifestUrl", String.to_query f))
         ; Aws.Util.option_map v.format (fun f ->
               Aws.Query.Pair ("Format", DiskImageFormat.to_query f))
         ; Aws.Util.option_map v.checksum (fun f ->
               Aws.Query.Pair ("Checksum", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.size (fun f -> "size", Long.to_json f)
         ; Aws.Util.option_map v.import_manifest_url (fun f ->
               "importManifestUrl", String.to_json f)
         ; Aws.Util.option_map v.format (fun f -> "format", DiskImageFormat.to_json f)
         ; Aws.Util.option_map v.checksum (fun f -> "checksum", String.to_json f)
         ])

  let of_json j =
    { checksum = Aws.Util.option_map (Aws.Json.lookup j "checksum") String.of_json
    ; format = Aws.Util.option_map (Aws.Json.lookup j "format") DiskImageFormat.of_json
    ; import_manifest_url =
        Aws.Util.option_map (Aws.Json.lookup j "importManifestUrl") String.of_json
    ; size = Aws.Util.option_map (Aws.Json.lookup j "size") Long.of_json
    }
end

module ImportVolumeTaskDetails = struct
  type t =
    { availability_zone : String.t option
    ; bytes_converted : Long.t option
    ; description : String.t option
    ; image : DiskImageDescription.t option
    ; volume : DiskImageVolumeDescription.t option
    }

  let make ?availability_zone ?bytes_converted ?description ?image ?volume () =
    { availability_zone; bytes_converted; description; image; volume }

  let parse xml =
    Some
      { availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; bytes_converted =
          Aws.Util.option_bind (Aws.Xml.member "bytesConverted" xml) Long.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; image =
          Aws.Util.option_bind (Aws.Xml.member "image" xml) DiskImageDescription.parse
      ; volume =
          Aws.Util.option_bind
            (Aws.Xml.member "volume" xml)
            DiskImageVolumeDescription.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.volume (fun f ->
               Aws.Query.Pair ("Volume", DiskImageVolumeDescription.to_query f))
         ; Aws.Util.option_map v.image (fun f ->
               Aws.Query.Pair ("Image", DiskImageDescription.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.bytes_converted (fun f ->
               Aws.Query.Pair ("BytesConverted", Long.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.volume (fun f ->
               "volume", DiskImageVolumeDescription.to_json f)
         ; Aws.Util.option_map v.image (fun f -> "image", DiskImageDescription.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Aws.Util.option_map v.bytes_converted (fun f ->
               "bytesConverted", Long.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ])

  let of_json j =
    { availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; bytes_converted =
        Aws.Util.option_map (Aws.Json.lookup j "bytesConverted") Long.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; image = Aws.Util.option_map (Aws.Json.lookup j "image") DiskImageDescription.of_json
    ; volume =
        Aws.Util.option_map
          (Aws.Json.lookup j "volume")
          DiskImageVolumeDescription.of_json
    }
end

module PlatformValues = struct
  type t = Windows

  let str_to_t = [ "Windows", Windows ]

  let t_to_str = [ Windows, "Windows" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ImportInstanceVolumeDetailItem = struct
  type t =
    { availability_zone : String.t option
    ; bytes_converted : Long.t option
    ; description : String.t option
    ; image : DiskImageDescription.t option
    ; status : String.t option
    ; status_message : String.t option
    ; volume : DiskImageVolumeDescription.t option
    }

  let make
      ?availability_zone
      ?bytes_converted
      ?description
      ?image
      ?status
      ?status_message
      ?volume
      () =
    { availability_zone
    ; bytes_converted
    ; description
    ; image
    ; status
    ; status_message
    ; volume
    }

  let parse xml =
    Some
      { availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; bytes_converted =
          Aws.Util.option_bind (Aws.Xml.member "bytesConverted" xml) Long.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; image =
          Aws.Util.option_bind (Aws.Xml.member "image" xml) DiskImageDescription.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "status" xml) String.parse
      ; status_message =
          Aws.Util.option_bind (Aws.Xml.member "statusMessage" xml) String.parse
      ; volume =
          Aws.Util.option_bind
            (Aws.Xml.member "volume" xml)
            DiskImageVolumeDescription.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.volume (fun f ->
               Aws.Query.Pair ("Volume", DiskImageVolumeDescription.to_query f))
         ; Aws.Util.option_map v.status_message (fun f ->
               Aws.Query.Pair ("StatusMessage", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.image (fun f ->
               Aws.Query.Pair ("Image", DiskImageDescription.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.bytes_converted (fun f ->
               Aws.Query.Pair ("BytesConverted", Long.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.volume (fun f ->
               "volume", DiskImageVolumeDescription.to_json f)
         ; Aws.Util.option_map v.status_message (fun f ->
               "statusMessage", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "status", String.to_json f)
         ; Aws.Util.option_map v.image (fun f -> "image", DiskImageDescription.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Aws.Util.option_map v.bytes_converted (fun f ->
               "bytesConverted", Long.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ])

  let of_json j =
    { availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; bytes_converted =
        Aws.Util.option_map (Aws.Json.lookup j "bytesConverted") Long.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; image = Aws.Util.option_map (Aws.Json.lookup j "image") DiskImageDescription.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "status") String.of_json
    ; status_message =
        Aws.Util.option_map (Aws.Json.lookup j "statusMessage") String.of_json
    ; volume =
        Aws.Util.option_map
          (Aws.Json.lookup j "volume")
          DiskImageVolumeDescription.of_json
    }
end

module ImportInstanceVolumeDetailSet = struct
  type t = ImportInstanceVolumeDetailItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ImportInstanceVolumeDetailItem.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ImportInstanceVolumeDetailItem.to_query v

  let to_json v = `List (List.map ImportInstanceVolumeDetailItem.to_json v)

  let of_json j = Aws.Json.to_list ImportInstanceVolumeDetailItem.of_json j
end

module ImportInstanceTaskDetails = struct
  type t =
    { description : String.t option
    ; instance_id : String.t option
    ; platform : PlatformValues.t option
    ; volumes : ImportInstanceVolumeDetailSet.t
    }

  let make ?description ?instance_id ?platform ?(volumes = []) () =
    { description; instance_id; platform; volumes }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      ; platform =
          Aws.Util.option_bind (Aws.Xml.member "platform" xml) PlatformValues.parse
      ; volumes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "volumes" xml)
               ImportInstanceVolumeDetailSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("Volumes", ImportInstanceVolumeDetailSet.to_query v.volumes))
         ; Aws.Util.option_map v.platform (fun f ->
               Aws.Query.Pair ("Platform", PlatformValues.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("volumes", ImportInstanceVolumeDetailSet.to_json v.volumes)
         ; Aws.Util.option_map v.platform (fun f -> "platform", PlatformValues.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    ; platform = Aws.Util.option_map (Aws.Json.lookup j "platform") PlatformValues.of_json
    ; volumes =
        ImportInstanceVolumeDetailSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "volumes"))
    }
end

module ConversionTaskState = struct
  type t =
    | Active
    | Cancelling
    | Cancelled
    | Completed

  let str_to_t =
    [ "completed", Completed
    ; "cancelled", Cancelled
    ; "cancelling", Cancelling
    ; "active", Active
    ]

  let t_to_str =
    [ Completed, "completed"
    ; Cancelled, "cancelled"
    ; Cancelling, "cancelling"
    ; Active, "active"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ConversionTask = struct
  type t =
    { conversion_task_id : String.t option
    ; expiration_time : String.t option
    ; import_instance : ImportInstanceTaskDetails.t option
    ; import_volume : ImportVolumeTaskDetails.t option
    ; state : ConversionTaskState.t option
    ; status_message : String.t option
    ; tags : TagList.t
    }

  let make
      ?conversion_task_id
      ?expiration_time
      ?import_instance
      ?import_volume
      ?state
      ?status_message
      ?(tags = [])
      () =
    { conversion_task_id
    ; expiration_time
    ; import_instance
    ; import_volume
    ; state
    ; status_message
    ; tags
    }

  let parse xml =
    Some
      { conversion_task_id =
          Aws.Util.option_bind (Aws.Xml.member "conversionTaskId" xml) String.parse
      ; expiration_time =
          Aws.Util.option_bind (Aws.Xml.member "expirationTime" xml) String.parse
      ; import_instance =
          Aws.Util.option_bind
            (Aws.Xml.member "importInstance" xml)
            ImportInstanceTaskDetails.parse
      ; import_volume =
          Aws.Util.option_bind
            (Aws.Xml.member "importVolume" xml)
            ImportVolumeTaskDetails.parse
      ; state =
          Aws.Util.option_bind (Aws.Xml.member "state" xml) ConversionTaskState.parse
      ; status_message =
          Aws.Util.option_bind (Aws.Xml.member "statusMessage" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.status_message (fun f ->
               Aws.Query.Pair ("StatusMessage", String.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", ConversionTaskState.to_query f))
         ; Aws.Util.option_map v.import_volume (fun f ->
               Aws.Query.Pair ("ImportVolume", ImportVolumeTaskDetails.to_query f))
         ; Aws.Util.option_map v.import_instance (fun f ->
               Aws.Query.Pair ("ImportInstance", ImportInstanceTaskDetails.to_query f))
         ; Aws.Util.option_map v.expiration_time (fun f ->
               Aws.Query.Pair ("ExpirationTime", String.to_query f))
         ; Aws.Util.option_map v.conversion_task_id (fun f ->
               Aws.Query.Pair ("ConversionTaskId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.status_message (fun f ->
               "statusMessage", String.to_json f)
         ; Aws.Util.option_map v.state (fun f -> "state", ConversionTaskState.to_json f)
         ; Aws.Util.option_map v.import_volume (fun f ->
               "importVolume", ImportVolumeTaskDetails.to_json f)
         ; Aws.Util.option_map v.import_instance (fun f ->
               "importInstance", ImportInstanceTaskDetails.to_json f)
         ; Aws.Util.option_map v.expiration_time (fun f ->
               "expirationTime", String.to_json f)
         ; Aws.Util.option_map v.conversion_task_id (fun f ->
               "conversionTaskId", String.to_json f)
         ])

  let of_json j =
    { conversion_task_id =
        Aws.Util.option_map (Aws.Json.lookup j "conversionTaskId") String.of_json
    ; expiration_time =
        Aws.Util.option_map (Aws.Json.lookup j "expirationTime") String.of_json
    ; import_instance =
        Aws.Util.option_map
          (Aws.Json.lookup j "importInstance")
          ImportInstanceTaskDetails.of_json
    ; import_volume =
        Aws.Util.option_map
          (Aws.Json.lookup j "importVolume")
          ImportVolumeTaskDetails.of_json
    ; state = Aws.Util.option_map (Aws.Json.lookup j "state") ConversionTaskState.of_json
    ; status_message =
        Aws.Util.option_map (Aws.Json.lookup j "statusMessage") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module DescribeConversionTaskList = struct
  type t = ConversionTask.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ConversionTask.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ConversionTask.to_query v

  let to_json v = `List (List.map ConversionTask.to_json v)

  let of_json j = Aws.Json.to_list ConversionTask.of_json j
end

module DeleteCustomerGatewayRequest = struct
  type t =
    { customer_gateway_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~customer_gateway_id ?dry_run () = { customer_gateway_id; dry_run }

  let parse xml =
    Some
      { customer_gateway_id =
          Aws.Xml.required
            "CustomerGatewayId"
            (Aws.Util.option_bind (Aws.Xml.member "CustomerGatewayId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair ("CustomerGatewayId", String.to_query v.customer_gateway_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("CustomerGatewayId", String.to_json v.customer_gateway_id)
         ])

  let of_json j =
    { customer_gateway_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "CustomerGatewayId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module SpotPlacement = struct
  type t =
    { availability_zone : String.t option
    ; group_name : String.t option
    ; tenancy : Tenancy.t option
    }

  let make ?availability_zone ?group_name ?tenancy () =
    { availability_zone; group_name; tenancy }

  let parse xml =
    Some
      { availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; group_name = Aws.Util.option_bind (Aws.Xml.member "groupName" xml) String.parse
      ; tenancy = Aws.Util.option_bind (Aws.Xml.member "tenancy" xml) Tenancy.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.tenancy (fun f ->
               Aws.Query.Pair ("Tenancy", Tenancy.to_query f))
         ; Aws.Util.option_map v.group_name (fun f ->
               Aws.Query.Pair ("GroupName", String.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.tenancy (fun f -> "tenancy", Tenancy.to_json f)
         ; Aws.Util.option_map v.group_name (fun f -> "groupName", String.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ])

  let of_json j =
    { availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; group_name = Aws.Util.option_map (Aws.Json.lookup j "groupName") String.of_json
    ; tenancy = Aws.Util.option_map (Aws.Json.lookup j "tenancy") Tenancy.of_json
    }
end

module SpotFleetTagSpecification = struct
  type t =
    { resource_type : ResourceType.t option
    ; tags : TagList.t
    }

  let make ?resource_type ?(tags = []) () = { resource_type; tags }

  let parse xml =
    Some
      { resource_type =
          Aws.Util.option_bind (Aws.Xml.member "resourceType" xml) ResourceType.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tag" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tag", TagList.to_query v.tags))
         ; Aws.Util.option_map v.resource_type (fun f ->
               Aws.Query.Pair ("ResourceType", ResourceType.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tag", TagList.to_json v.tags)
         ; Aws.Util.option_map v.resource_type (fun f ->
               "resourceType", ResourceType.to_json f)
         ])

  let of_json j =
    { resource_type =
        Aws.Util.option_map (Aws.Json.lookup j "resourceType") ResourceType.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tag"))
    }
end

module SpotFleetTagSpecificationList = struct
  type t = SpotFleetTagSpecification.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map SpotFleetTagSpecification.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list SpotFleetTagSpecification.to_query v

  let to_json v = `List (List.map SpotFleetTagSpecification.to_json v)

  let of_json j = Aws.Json.to_list SpotFleetTagSpecification.of_json j
end

module SpotFleetMonitoring = struct
  type t = { enabled : Boolean.t option }

  let make ?enabled () = { enabled }

  let parse xml =
    Some { enabled = Aws.Util.option_bind (Aws.Xml.member "enabled" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enabled (fun f ->
               Aws.Query.Pair ("Enabled", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enabled (fun f -> "enabled", Boolean.to_json f) ])

  let of_json j =
    { enabled = Aws.Util.option_map (Aws.Json.lookup j "enabled") Boolean.of_json }
end

module SecurityGroupIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "SecurityGroupId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module InstanceNetworkInterfaceSpecification = struct
  type t =
    { associate_public_ip_address : Boolean.t option
    ; delete_on_termination : Boolean.t option
    ; description : String.t option
    ; device_index : Integer.t option
    ; groups : SecurityGroupIdStringList.t
    ; ipv6_address_count : Integer.t option
    ; ipv6_addresses : InstanceIpv6AddressList.t
    ; network_interface_id : String.t option
    ; private_ip_address : String.t option
    ; private_ip_addresses : PrivateIpAddressSpecificationList.t
    ; secondary_private_ip_address_count : Integer.t option
    ; subnet_id : String.t option
    ; associate_carrier_ip_address : Boolean.t option
    ; interface_type : String.t option
    ; network_card_index : Integer.t option
    }

  let make
      ?associate_public_ip_address
      ?delete_on_termination
      ?description
      ?device_index
      ?(groups = [])
      ?ipv6_address_count
      ?(ipv6_addresses = [])
      ?network_interface_id
      ?private_ip_address
      ?(private_ip_addresses = [])
      ?secondary_private_ip_address_count
      ?subnet_id
      ?associate_carrier_ip_address
      ?interface_type
      ?network_card_index
      () =
    { associate_public_ip_address
    ; delete_on_termination
    ; description
    ; device_index
    ; groups
    ; ipv6_address_count
    ; ipv6_addresses
    ; network_interface_id
    ; private_ip_address
    ; private_ip_addresses
    ; secondary_private_ip_address_count
    ; subnet_id
    ; associate_carrier_ip_address
    ; interface_type
    ; network_card_index
    }

  let parse xml =
    Some
      { associate_public_ip_address =
          Aws.Util.option_bind
            (Aws.Xml.member "associatePublicIpAddress" xml)
            Boolean.parse
      ; delete_on_termination =
          Aws.Util.option_bind (Aws.Xml.member "deleteOnTermination" xml) Boolean.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; device_index =
          Aws.Util.option_bind (Aws.Xml.member "deviceIndex" xml) Integer.parse
      ; groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SecurityGroupId" xml)
               SecurityGroupIdStringList.parse)
      ; ipv6_address_count =
          Aws.Util.option_bind (Aws.Xml.member "ipv6AddressCount" xml) Integer.parse
      ; ipv6_addresses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ipv6AddressesSet" xml)
               InstanceIpv6AddressList.parse)
      ; network_interface_id =
          Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse
      ; private_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "privateIpAddress" xml) String.parse
      ; private_ip_addresses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "privateIpAddressesSet" xml)
               PrivateIpAddressSpecificationList.parse)
      ; secondary_private_ip_address_count =
          Aws.Util.option_bind
            (Aws.Xml.member "secondaryPrivateIpAddressCount" xml)
            Integer.parse
      ; subnet_id = Aws.Util.option_bind (Aws.Xml.member "subnetId" xml) String.parse
      ; associate_carrier_ip_address =
          Aws.Util.option_bind
            (Aws.Xml.member "AssociateCarrierIpAddress" xml)
            Boolean.parse
      ; interface_type =
          Aws.Util.option_bind (Aws.Xml.member "InterfaceType" xml) String.parse
      ; network_card_index =
          Aws.Util.option_bind (Aws.Xml.member "NetworkCardIndex" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.network_card_index (fun f ->
               Aws.Query.Pair ("NetworkCardIndex", Integer.to_query f))
         ; Aws.Util.option_map v.interface_type (fun f ->
               Aws.Query.Pair ("InterfaceType", String.to_query f))
         ; Aws.Util.option_map v.associate_carrier_ip_address (fun f ->
               Aws.Query.Pair ("AssociateCarrierIpAddress", Boolean.to_query f))
         ; Aws.Util.option_map v.subnet_id (fun f ->
               Aws.Query.Pair ("SubnetId", String.to_query f))
         ; Aws.Util.option_map v.secondary_private_ip_address_count (fun f ->
               Aws.Query.Pair ("SecondaryPrivateIpAddressCount", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "PrivateIpAddressesSet"
                , PrivateIpAddressSpecificationList.to_query v.private_ip_addresses ))
         ; Aws.Util.option_map v.private_ip_address (fun f ->
               Aws.Query.Pair ("PrivateIpAddress", String.to_query f))
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               Aws.Query.Pair ("NetworkInterfaceId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Ipv6AddressesSet", InstanceIpv6AddressList.to_query v.ipv6_addresses))
         ; Aws.Util.option_map v.ipv6_address_count (fun f ->
               Aws.Query.Pair ("Ipv6AddressCount", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("SecurityGroupId", SecurityGroupIdStringList.to_query v.groups))
         ; Aws.Util.option_map v.device_index (fun f ->
               Aws.Query.Pair ("DeviceIndex", Integer.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.delete_on_termination (fun f ->
               Aws.Query.Pair ("DeleteOnTermination", Boolean.to_query f))
         ; Aws.Util.option_map v.associate_public_ip_address (fun f ->
               Aws.Query.Pair ("AssociatePublicIpAddress", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.network_card_index (fun f ->
               "NetworkCardIndex", Integer.to_json f)
         ; Aws.Util.option_map v.interface_type (fun f ->
               "InterfaceType", String.to_json f)
         ; Aws.Util.option_map v.associate_carrier_ip_address (fun f ->
               "AssociateCarrierIpAddress", Boolean.to_json f)
         ; Aws.Util.option_map v.subnet_id (fun f -> "subnetId", String.to_json f)
         ; Aws.Util.option_map v.secondary_private_ip_address_count (fun f ->
               "secondaryPrivateIpAddressCount", Integer.to_json f)
         ; Some
             ( "privateIpAddressesSet"
             , PrivateIpAddressSpecificationList.to_json v.private_ip_addresses )
         ; Aws.Util.option_map v.private_ip_address (fun f ->
               "privateIpAddress", String.to_json f)
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               "networkInterfaceId", String.to_json f)
         ; Some ("ipv6AddressesSet", InstanceIpv6AddressList.to_json v.ipv6_addresses)
         ; Aws.Util.option_map v.ipv6_address_count (fun f ->
               "ipv6AddressCount", Integer.to_json f)
         ; Some ("SecurityGroupId", SecurityGroupIdStringList.to_json v.groups)
         ; Aws.Util.option_map v.device_index (fun f -> "deviceIndex", Integer.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Aws.Util.option_map v.delete_on_termination (fun f ->
               "deleteOnTermination", Boolean.to_json f)
         ; Aws.Util.option_map v.associate_public_ip_address (fun f ->
               "associatePublicIpAddress", Boolean.to_json f)
         ])

  let of_json j =
    { associate_public_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "associatePublicIpAddress") Boolean.of_json
    ; delete_on_termination =
        Aws.Util.option_map (Aws.Json.lookup j "deleteOnTermination") Boolean.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; device_index = Aws.Util.option_map (Aws.Json.lookup j "deviceIndex") Integer.of_json
    ; groups =
        SecurityGroupIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SecurityGroupId"))
    ; ipv6_address_count =
        Aws.Util.option_map (Aws.Json.lookup j "ipv6AddressCount") Integer.of_json
    ; ipv6_addresses =
        InstanceIpv6AddressList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ipv6AddressesSet"))
    ; network_interface_id =
        Aws.Util.option_map (Aws.Json.lookup j "networkInterfaceId") String.of_json
    ; private_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "privateIpAddress") String.of_json
    ; private_ip_addresses =
        PrivateIpAddressSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "privateIpAddressesSet"))
    ; secondary_private_ip_address_count =
        Aws.Util.option_map
          (Aws.Json.lookup j "secondaryPrivateIpAddressCount")
          Integer.of_json
    ; subnet_id = Aws.Util.option_map (Aws.Json.lookup j "subnetId") String.of_json
    ; associate_carrier_ip_address =
        Aws.Util.option_map
          (Aws.Json.lookup j "AssociateCarrierIpAddress")
          Boolean.of_json
    ; interface_type =
        Aws.Util.option_map (Aws.Json.lookup j "InterfaceType") String.of_json
    ; network_card_index =
        Aws.Util.option_map (Aws.Json.lookup j "NetworkCardIndex") Integer.of_json
    }
end

module InstanceNetworkInterfaceSpecificationList = struct
  type t = InstanceNetworkInterfaceSpecification.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map InstanceNetworkInterfaceSpecification.parse (Aws.Xml.members "item" xml))

  let to_query v =
    Aws.Query.to_query_list InstanceNetworkInterfaceSpecification.to_query v

  let to_json v = `List (List.map InstanceNetworkInterfaceSpecification.to_json v)

  let of_json j = Aws.Json.to_list InstanceNetworkInterfaceSpecification.of_json j
end

module IamInstanceProfileSpecification = struct
  type t =
    { arn : String.t option
    ; name : String.t option
    }

  let make ?arn ?name () = { arn; name }

  let parse xml =
    Some
      { arn = Aws.Util.option_bind (Aws.Xml.member "arn" xml) String.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "name" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.arn (fun f -> Aws.Query.Pair ("Arn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.name (fun f -> "name", String.to_json f)
         ; Aws.Util.option_map v.arn (fun f -> "arn", String.to_json f)
         ])

  let of_json j =
    { arn = Aws.Util.option_map (Aws.Json.lookup j "arn") String.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "name") String.of_json
    }
end

module BlockDeviceMappingList = struct
  type t = BlockDeviceMapping.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map BlockDeviceMapping.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list BlockDeviceMapping.to_query v

  let to_json v = `List (List.map BlockDeviceMapping.to_json v)

  let of_json j = Aws.Json.to_list BlockDeviceMapping.of_json j
end

module SpotFleetLaunchSpecification = struct
  type t =
    { security_groups : GroupIdentifierList.t
    ; addressing_type : String.t option
    ; block_device_mappings : BlockDeviceMappingList.t
    ; ebs_optimized : Boolean.t option
    ; iam_instance_profile : IamInstanceProfileSpecification.t option
    ; image_id : String.t option
    ; instance_type : InstanceType.t option
    ; kernel_id : String.t option
    ; key_name : String.t option
    ; monitoring : SpotFleetMonitoring.t option
    ; network_interfaces : InstanceNetworkInterfaceSpecificationList.t
    ; placement : SpotPlacement.t option
    ; ramdisk_id : String.t option
    ; spot_price : String.t option
    ; subnet_id : String.t option
    ; user_data : String.t option
    ; weighted_capacity : Double.t option
    ; tag_specifications : SpotFleetTagSpecificationList.t
    }

  let make
      ?(security_groups = [])
      ?addressing_type
      ?(block_device_mappings = [])
      ?ebs_optimized
      ?iam_instance_profile
      ?image_id
      ?instance_type
      ?kernel_id
      ?key_name
      ?monitoring
      ?(network_interfaces = [])
      ?placement
      ?ramdisk_id
      ?spot_price
      ?subnet_id
      ?user_data
      ?weighted_capacity
      ?(tag_specifications = [])
      () =
    { security_groups
    ; addressing_type
    ; block_device_mappings
    ; ebs_optimized
    ; iam_instance_profile
    ; image_id
    ; instance_type
    ; kernel_id
    ; key_name
    ; monitoring
    ; network_interfaces
    ; placement
    ; ramdisk_id
    ; spot_price
    ; subnet_id
    ; user_data
    ; weighted_capacity
    ; tag_specifications
    }

  let parse xml =
    Some
      { security_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "groupSet" xml)
               GroupIdentifierList.parse)
      ; addressing_type =
          Aws.Util.option_bind (Aws.Xml.member "addressingType" xml) String.parse
      ; block_device_mappings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "blockDeviceMapping" xml)
               BlockDeviceMappingList.parse)
      ; ebs_optimized =
          Aws.Util.option_bind (Aws.Xml.member "ebsOptimized" xml) Boolean.parse
      ; iam_instance_profile =
          Aws.Util.option_bind
            (Aws.Xml.member "iamInstanceProfile" xml)
            IamInstanceProfileSpecification.parse
      ; image_id = Aws.Util.option_bind (Aws.Xml.member "imageId" xml) String.parse
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) InstanceType.parse
      ; kernel_id = Aws.Util.option_bind (Aws.Xml.member "kernelId" xml) String.parse
      ; key_name = Aws.Util.option_bind (Aws.Xml.member "keyName" xml) String.parse
      ; monitoring =
          Aws.Util.option_bind (Aws.Xml.member "monitoring" xml) SpotFleetMonitoring.parse
      ; network_interfaces =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "networkInterfaceSet" xml)
               InstanceNetworkInterfaceSpecificationList.parse)
      ; placement =
          Aws.Util.option_bind (Aws.Xml.member "placement" xml) SpotPlacement.parse
      ; ramdisk_id = Aws.Util.option_bind (Aws.Xml.member "ramdiskId" xml) String.parse
      ; spot_price = Aws.Util.option_bind (Aws.Xml.member "spotPrice" xml) String.parse
      ; subnet_id = Aws.Util.option_bind (Aws.Xml.member "subnetId" xml) String.parse
      ; user_data = Aws.Util.option_bind (Aws.Xml.member "userData" xml) String.parse
      ; weighted_capacity =
          Aws.Util.option_bind (Aws.Xml.member "weightedCapacity" xml) Double.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "tagSpecificationSet" xml)
               SpotFleetTagSpecificationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "TagSpecificationSet"
                , SpotFleetTagSpecificationList.to_query v.tag_specifications ))
         ; Aws.Util.option_map v.weighted_capacity (fun f ->
               Aws.Query.Pair ("WeightedCapacity", Double.to_query f))
         ; Aws.Util.option_map v.user_data (fun f ->
               Aws.Query.Pair ("UserData", String.to_query f))
         ; Aws.Util.option_map v.subnet_id (fun f ->
               Aws.Query.Pair ("SubnetId", String.to_query f))
         ; Aws.Util.option_map v.spot_price (fun f ->
               Aws.Query.Pair ("SpotPrice", String.to_query f))
         ; Aws.Util.option_map v.ramdisk_id (fun f ->
               Aws.Query.Pair ("RamdiskId", String.to_query f))
         ; Aws.Util.option_map v.placement (fun f ->
               Aws.Query.Pair ("Placement", SpotPlacement.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "NetworkInterfaceSet"
                , InstanceNetworkInterfaceSpecificationList.to_query v.network_interfaces
                ))
         ; Aws.Util.option_map v.monitoring (fun f ->
               Aws.Query.Pair ("Monitoring", SpotFleetMonitoring.to_query f))
         ; Aws.Util.option_map v.key_name (fun f ->
               Aws.Query.Pair ("KeyName", String.to_query f))
         ; Aws.Util.option_map v.kernel_id (fun f ->
               Aws.Query.Pair ("KernelId", String.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", InstanceType.to_query f))
         ; Aws.Util.option_map v.image_id (fun f ->
               Aws.Query.Pair ("ImageId", String.to_query f))
         ; Aws.Util.option_map v.iam_instance_profile (fun f ->
               Aws.Query.Pair
                 ("IamInstanceProfile", IamInstanceProfileSpecification.to_query f))
         ; Aws.Util.option_map v.ebs_optimized (fun f ->
               Aws.Query.Pair ("EbsOptimized", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "BlockDeviceMapping"
                , BlockDeviceMappingList.to_query v.block_device_mappings ))
         ; Aws.Util.option_map v.addressing_type (fun f ->
               Aws.Query.Pair ("AddressingType", String.to_query f))
         ; Some
             (Aws.Query.Pair ("GroupSet", GroupIdentifierList.to_query v.security_groups))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "tagSpecificationSet"
             , SpotFleetTagSpecificationList.to_json v.tag_specifications )
         ; Aws.Util.option_map v.weighted_capacity (fun f ->
               "weightedCapacity", Double.to_json f)
         ; Aws.Util.option_map v.user_data (fun f -> "userData", String.to_json f)
         ; Aws.Util.option_map v.subnet_id (fun f -> "subnetId", String.to_json f)
         ; Aws.Util.option_map v.spot_price (fun f -> "spotPrice", String.to_json f)
         ; Aws.Util.option_map v.ramdisk_id (fun f -> "ramdiskId", String.to_json f)
         ; Aws.Util.option_map v.placement (fun f -> "placement", SpotPlacement.to_json f)
         ; Some
             ( "networkInterfaceSet"
             , InstanceNetworkInterfaceSpecificationList.to_json v.network_interfaces )
         ; Aws.Util.option_map v.monitoring (fun f ->
               "monitoring", SpotFleetMonitoring.to_json f)
         ; Aws.Util.option_map v.key_name (fun f -> "keyName", String.to_json f)
         ; Aws.Util.option_map v.kernel_id (fun f -> "kernelId", String.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f ->
               "instanceType", InstanceType.to_json f)
         ; Aws.Util.option_map v.image_id (fun f -> "imageId", String.to_json f)
         ; Aws.Util.option_map v.iam_instance_profile (fun f ->
               "iamInstanceProfile", IamInstanceProfileSpecification.to_json f)
         ; Aws.Util.option_map v.ebs_optimized (fun f ->
               "ebsOptimized", Boolean.to_json f)
         ; Some
             ("blockDeviceMapping", BlockDeviceMappingList.to_json v.block_device_mappings)
         ; Aws.Util.option_map v.addressing_type (fun f ->
               "addressingType", String.to_json f)
         ; Some ("groupSet", GroupIdentifierList.to_json v.security_groups)
         ])

  let of_json j =
    { security_groups =
        GroupIdentifierList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "groupSet"))
    ; addressing_type =
        Aws.Util.option_map (Aws.Json.lookup j "addressingType") String.of_json
    ; block_device_mappings =
        BlockDeviceMappingList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "blockDeviceMapping"))
    ; ebs_optimized =
        Aws.Util.option_map (Aws.Json.lookup j "ebsOptimized") Boolean.of_json
    ; iam_instance_profile =
        Aws.Util.option_map
          (Aws.Json.lookup j "iamInstanceProfile")
          IamInstanceProfileSpecification.of_json
    ; image_id = Aws.Util.option_map (Aws.Json.lookup j "imageId") String.of_json
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") InstanceType.of_json
    ; kernel_id = Aws.Util.option_map (Aws.Json.lookup j "kernelId") String.of_json
    ; key_name = Aws.Util.option_map (Aws.Json.lookup j "keyName") String.of_json
    ; monitoring =
        Aws.Util.option_map (Aws.Json.lookup j "monitoring") SpotFleetMonitoring.of_json
    ; network_interfaces =
        InstanceNetworkInterfaceSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "networkInterfaceSet"))
    ; placement =
        Aws.Util.option_map (Aws.Json.lookup j "placement") SpotPlacement.of_json
    ; ramdisk_id = Aws.Util.option_map (Aws.Json.lookup j "ramdiskId") String.of_json
    ; spot_price = Aws.Util.option_map (Aws.Json.lookup j "spotPrice") String.of_json
    ; subnet_id = Aws.Util.option_map (Aws.Json.lookup j "subnetId") String.of_json
    ; user_data = Aws.Util.option_map (Aws.Json.lookup j "userData") String.of_json
    ; weighted_capacity =
        Aws.Util.option_map (Aws.Json.lookup j "weightedCapacity") Double.of_json
    ; tag_specifications =
        SpotFleetTagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSpecificationSet"))
    }
end

module GpuInfo = struct
  type t =
    { gpus : GpuDeviceInfoList.t
    ; total_gpu_memory_in_mi_b : Integer.t option
    }

  let make ?(gpus = []) ?total_gpu_memory_in_mi_b () = { gpus; total_gpu_memory_in_mi_b }

  let parse xml =
    Some
      { gpus =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "gpus" xml) GpuDeviceInfoList.parse)
      ; total_gpu_memory_in_mi_b =
          Aws.Util.option_bind (Aws.Xml.member "totalGpuMemoryInMiB" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.total_gpu_memory_in_mi_b (fun f ->
               Aws.Query.Pair ("TotalGpuMemoryInMiB", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Gpus", GpuDeviceInfoList.to_query v.gpus))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.total_gpu_memory_in_mi_b (fun f ->
               "totalGpuMemoryInMiB", Integer.to_json f)
         ; Some ("gpus", GpuDeviceInfoList.to_json v.gpus)
         ])

  let of_json j =
    { gpus = GpuDeviceInfoList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "gpus"))
    ; total_gpu_memory_in_mi_b =
        Aws.Util.option_map (Aws.Json.lookup j "totalGpuMemoryInMiB") Integer.of_json
    }
end

module ExportImageTaskIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "ExportImageTaskId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeExportImageTasksRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; filters : FilterList.t
    ; export_image_task_ids : ExportImageTaskIdList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make
      ?dry_run
      ?(filters = [])
      ?(export_image_task_ids = [])
      ?max_results
      ?next_token
      () =
    { dry_run; filters; export_image_task_ids; max_results; next_token }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; export_image_task_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ExportImageTaskId" xml)
               ExportImageTaskIdList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ExportImageTaskId"
                , ExportImageTaskIdList.to_query v.export_image_task_ids ))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some
             ("ExportImageTaskId", ExportImageTaskIdList.to_json v.export_image_task_ids)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; export_image_task_ids =
        ExportImageTaskIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ExportImageTaskId"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module ScheduledInstancesSecurityGroupIdSet = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "SecurityGroupId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module ScheduledInstancesPlacement = struct
  type t =
    { availability_zone : String.t option
    ; group_name : String.t option
    }

  let make ?availability_zone ?group_name () = { availability_zone; group_name }

  let parse xml =
    Some
      { availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "AvailabilityZone" xml) String.parse
      ; group_name = Aws.Util.option_bind (Aws.Xml.member "GroupName" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.group_name (fun f ->
               Aws.Query.Pair ("GroupName", String.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.group_name (fun f -> "GroupName", String.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "AvailabilityZone", String.to_json f)
         ])

  let of_json j =
    { availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "AvailabilityZone") String.of_json
    ; group_name = Aws.Util.option_map (Aws.Json.lookup j "GroupName") String.of_json
    }
end

module ScheduledInstancesIpv6Address = struct
  type t = { ipv6_address : String.t option }

  let make ?ipv6_address () = { ipv6_address }

  let parse xml =
    Some
      { ipv6_address =
          Aws.Util.option_bind (Aws.Xml.member "Ipv6Address" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ipv6_address (fun f ->
               Aws.Query.Pair ("Ipv6Address", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ipv6_address (fun f -> "Ipv6Address", String.to_json f) ])

  let of_json j =
    { ipv6_address = Aws.Util.option_map (Aws.Json.lookup j "Ipv6Address") String.of_json
    }
end

module ScheduledInstancesIpv6AddressList = struct
  type t = ScheduledInstancesIpv6Address.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ScheduledInstancesIpv6Address.parse (Aws.Xml.members "Ipv6Address" xml))

  let to_query v = Aws.Query.to_query_list ScheduledInstancesIpv6Address.to_query v

  let to_json v = `List (List.map ScheduledInstancesIpv6Address.to_json v)

  let of_json j = Aws.Json.to_list ScheduledInstancesIpv6Address.of_json j
end

module ScheduledInstancesPrivateIpAddressConfig = struct
  type t =
    { primary : Boolean.t option
    ; private_ip_address : String.t option
    }

  let make ?primary ?private_ip_address () = { primary; private_ip_address }

  let parse xml =
    Some
      { primary = Aws.Util.option_bind (Aws.Xml.member "Primary" xml) Boolean.parse
      ; private_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "PrivateIpAddress" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.private_ip_address (fun f ->
               Aws.Query.Pair ("PrivateIpAddress", String.to_query f))
         ; Aws.Util.option_map v.primary (fun f ->
               Aws.Query.Pair ("Primary", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.private_ip_address (fun f ->
               "PrivateIpAddress", String.to_json f)
         ; Aws.Util.option_map v.primary (fun f -> "Primary", Boolean.to_json f)
         ])

  let of_json j =
    { primary = Aws.Util.option_map (Aws.Json.lookup j "Primary") Boolean.of_json
    ; private_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "PrivateIpAddress") String.of_json
    }
end

module PrivateIpAddressConfigSet = struct
  type t = ScheduledInstancesPrivateIpAddressConfig.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         ScheduledInstancesPrivateIpAddressConfig.parse
         (Aws.Xml.members "PrivateIpAddressConfigSet" xml))

  let to_query v =
    Aws.Query.to_query_list ScheduledInstancesPrivateIpAddressConfig.to_query v

  let to_json v = `List (List.map ScheduledInstancesPrivateIpAddressConfig.to_json v)

  let of_json j = Aws.Json.to_list ScheduledInstancesPrivateIpAddressConfig.of_json j
end

module ScheduledInstancesNetworkInterface = struct
  type t =
    { associate_public_ip_address : Boolean.t option
    ; delete_on_termination : Boolean.t option
    ; description : String.t option
    ; device_index : Integer.t option
    ; groups : ScheduledInstancesSecurityGroupIdSet.t
    ; ipv6_address_count : Integer.t option
    ; ipv6_addresses : ScheduledInstancesIpv6AddressList.t
    ; network_interface_id : String.t option
    ; private_ip_address : String.t option
    ; private_ip_address_configs : PrivateIpAddressConfigSet.t
    ; secondary_private_ip_address_count : Integer.t option
    ; subnet_id : String.t option
    }

  let make
      ?associate_public_ip_address
      ?delete_on_termination
      ?description
      ?device_index
      ?(groups = [])
      ?ipv6_address_count
      ?(ipv6_addresses = [])
      ?network_interface_id
      ?private_ip_address
      ?(private_ip_address_configs = [])
      ?secondary_private_ip_address_count
      ?subnet_id
      () =
    { associate_public_ip_address
    ; delete_on_termination
    ; description
    ; device_index
    ; groups
    ; ipv6_address_count
    ; ipv6_addresses
    ; network_interface_id
    ; private_ip_address
    ; private_ip_address_configs
    ; secondary_private_ip_address_count
    ; subnet_id
    }

  let parse xml =
    Some
      { associate_public_ip_address =
          Aws.Util.option_bind
            (Aws.Xml.member "AssociatePublicIpAddress" xml)
            Boolean.parse
      ; delete_on_termination =
          Aws.Util.option_bind (Aws.Xml.member "DeleteOnTermination" xml) Boolean.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; device_index =
          Aws.Util.option_bind (Aws.Xml.member "DeviceIndex" xml) Integer.parse
      ; groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Group" xml)
               ScheduledInstancesSecurityGroupIdSet.parse)
      ; ipv6_address_count =
          Aws.Util.option_bind (Aws.Xml.member "Ipv6AddressCount" xml) Integer.parse
      ; ipv6_addresses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Ipv6Address" xml)
               ScheduledInstancesIpv6AddressList.parse)
      ; network_interface_id =
          Aws.Util.option_bind (Aws.Xml.member "NetworkInterfaceId" xml) String.parse
      ; private_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "PrivateIpAddress" xml) String.parse
      ; private_ip_address_configs =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "PrivateIpAddressConfig" xml)
               PrivateIpAddressConfigSet.parse)
      ; secondary_private_ip_address_count =
          Aws.Util.option_bind
            (Aws.Xml.member "SecondaryPrivateIpAddressCount" xml)
            Integer.parse
      ; subnet_id = Aws.Util.option_bind (Aws.Xml.member "SubnetId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.subnet_id (fun f ->
               Aws.Query.Pair ("SubnetId", String.to_query f))
         ; Aws.Util.option_map v.secondary_private_ip_address_count (fun f ->
               Aws.Query.Pair ("SecondaryPrivateIpAddressCount", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "PrivateIpAddressConfig"
                , PrivateIpAddressConfigSet.to_query v.private_ip_address_configs ))
         ; Aws.Util.option_map v.private_ip_address (fun f ->
               Aws.Query.Pair ("PrivateIpAddress", String.to_query f))
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               Aws.Query.Pair ("NetworkInterfaceId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "Ipv6Address"
                , ScheduledInstancesIpv6AddressList.to_query v.ipv6_addresses ))
         ; Aws.Util.option_map v.ipv6_address_count (fun f ->
               Aws.Query.Pair ("Ipv6AddressCount", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Group", ScheduledInstancesSecurityGroupIdSet.to_query v.groups))
         ; Aws.Util.option_map v.device_index (fun f ->
               Aws.Query.Pair ("DeviceIndex", Integer.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.delete_on_termination (fun f ->
               Aws.Query.Pair ("DeleteOnTermination", Boolean.to_query f))
         ; Aws.Util.option_map v.associate_public_ip_address (fun f ->
               Aws.Query.Pair ("AssociatePublicIpAddress", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.subnet_id (fun f -> "SubnetId", String.to_json f)
         ; Aws.Util.option_map v.secondary_private_ip_address_count (fun f ->
               "SecondaryPrivateIpAddressCount", Integer.to_json f)
         ; Some
             ( "PrivateIpAddressConfig"
             , PrivateIpAddressConfigSet.to_json v.private_ip_address_configs )
         ; Aws.Util.option_map v.private_ip_address (fun f ->
               "PrivateIpAddress", String.to_json f)
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               "NetworkInterfaceId", String.to_json f)
         ; Some ("Ipv6Address", ScheduledInstancesIpv6AddressList.to_json v.ipv6_addresses)
         ; Aws.Util.option_map v.ipv6_address_count (fun f ->
               "Ipv6AddressCount", Integer.to_json f)
         ; Some ("Group", ScheduledInstancesSecurityGroupIdSet.to_json v.groups)
         ; Aws.Util.option_map v.device_index (fun f -> "DeviceIndex", Integer.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.delete_on_termination (fun f ->
               "DeleteOnTermination", Boolean.to_json f)
         ; Aws.Util.option_map v.associate_public_ip_address (fun f ->
               "AssociatePublicIpAddress", Boolean.to_json f)
         ])

  let of_json j =
    { associate_public_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "AssociatePublicIpAddress") Boolean.of_json
    ; delete_on_termination =
        Aws.Util.option_map (Aws.Json.lookup j "DeleteOnTermination") Boolean.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; device_index = Aws.Util.option_map (Aws.Json.lookup j "DeviceIndex") Integer.of_json
    ; groups =
        ScheduledInstancesSecurityGroupIdSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Group"))
    ; ipv6_address_count =
        Aws.Util.option_map (Aws.Json.lookup j "Ipv6AddressCount") Integer.of_json
    ; ipv6_addresses =
        ScheduledInstancesIpv6AddressList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Ipv6Address"))
    ; network_interface_id =
        Aws.Util.option_map (Aws.Json.lookup j "NetworkInterfaceId") String.of_json
    ; private_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "PrivateIpAddress") String.of_json
    ; private_ip_address_configs =
        PrivateIpAddressConfigSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "PrivateIpAddressConfig"))
    ; secondary_private_ip_address_count =
        Aws.Util.option_map
          (Aws.Json.lookup j "SecondaryPrivateIpAddressCount")
          Integer.of_json
    ; subnet_id = Aws.Util.option_map (Aws.Json.lookup j "SubnetId") String.of_json
    }
end

module ScheduledInstancesNetworkInterfaceSet = struct
  type t = ScheduledInstancesNetworkInterface.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         ScheduledInstancesNetworkInterface.parse
         (Aws.Xml.members "NetworkInterface" xml))

  let to_query v = Aws.Query.to_query_list ScheduledInstancesNetworkInterface.to_query v

  let to_json v = `List (List.map ScheduledInstancesNetworkInterface.to_json v)

  let of_json j = Aws.Json.to_list ScheduledInstancesNetworkInterface.of_json j
end

module ScheduledInstancesMonitoring = struct
  type t = { enabled : Boolean.t option }

  let make ?enabled () = { enabled }

  let parse xml =
    Some { enabled = Aws.Util.option_bind (Aws.Xml.member "Enabled" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enabled (fun f ->
               Aws.Query.Pair ("Enabled", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enabled (fun f -> "Enabled", Boolean.to_json f) ])

  let of_json j =
    { enabled = Aws.Util.option_map (Aws.Json.lookup j "Enabled") Boolean.of_json }
end

module ScheduledInstancesIamInstanceProfile = struct
  type t =
    { arn : String.t option
    ; name : String.t option
    }

  let make ?arn ?name () = { arn; name }

  let parse xml =
    Some
      { arn = Aws.Util.option_bind (Aws.Xml.member "Arn" xml) String.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.arn (fun f -> Aws.Query.Pair ("Arn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.arn (fun f -> "Arn", String.to_json f)
         ])

  let of_json j =
    { arn = Aws.Util.option_map (Aws.Json.lookup j "Arn") String.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    }
end

module ScheduledInstancesEbs = struct
  type t =
    { delete_on_termination : Boolean.t option
    ; encrypted : Boolean.t option
    ; iops : Integer.t option
    ; snapshot_id : String.t option
    ; volume_size : Integer.t option
    ; volume_type : String.t option
    }

  let make
      ?delete_on_termination
      ?encrypted
      ?iops
      ?snapshot_id
      ?volume_size
      ?volume_type
      () =
    { delete_on_termination; encrypted; iops; snapshot_id; volume_size; volume_type }

  let parse xml =
    Some
      { delete_on_termination =
          Aws.Util.option_bind (Aws.Xml.member "DeleteOnTermination" xml) Boolean.parse
      ; encrypted = Aws.Util.option_bind (Aws.Xml.member "Encrypted" xml) Boolean.parse
      ; iops = Aws.Util.option_bind (Aws.Xml.member "Iops" xml) Integer.parse
      ; snapshot_id = Aws.Util.option_bind (Aws.Xml.member "SnapshotId" xml) String.parse
      ; volume_size = Aws.Util.option_bind (Aws.Xml.member "VolumeSize" xml) Integer.parse
      ; volume_type = Aws.Util.option_bind (Aws.Xml.member "VolumeType" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.volume_type (fun f ->
               Aws.Query.Pair ("VolumeType", String.to_query f))
         ; Aws.Util.option_map v.volume_size (fun f ->
               Aws.Query.Pair ("VolumeSize", Integer.to_query f))
         ; Aws.Util.option_map v.snapshot_id (fun f ->
               Aws.Query.Pair ("SnapshotId", String.to_query f))
         ; Aws.Util.option_map v.iops (fun f ->
               Aws.Query.Pair ("Iops", Integer.to_query f))
         ; Aws.Util.option_map v.encrypted (fun f ->
               Aws.Query.Pair ("Encrypted", Boolean.to_query f))
         ; Aws.Util.option_map v.delete_on_termination (fun f ->
               Aws.Query.Pair ("DeleteOnTermination", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.volume_type (fun f -> "VolumeType", String.to_json f)
         ; Aws.Util.option_map v.volume_size (fun f -> "VolumeSize", Integer.to_json f)
         ; Aws.Util.option_map v.snapshot_id (fun f -> "SnapshotId", String.to_json f)
         ; Aws.Util.option_map v.iops (fun f -> "Iops", Integer.to_json f)
         ; Aws.Util.option_map v.encrypted (fun f -> "Encrypted", Boolean.to_json f)
         ; Aws.Util.option_map v.delete_on_termination (fun f ->
               "DeleteOnTermination", Boolean.to_json f)
         ])

  let of_json j =
    { delete_on_termination =
        Aws.Util.option_map (Aws.Json.lookup j "DeleteOnTermination") Boolean.of_json
    ; encrypted = Aws.Util.option_map (Aws.Json.lookup j "Encrypted") Boolean.of_json
    ; iops = Aws.Util.option_map (Aws.Json.lookup j "Iops") Integer.of_json
    ; snapshot_id = Aws.Util.option_map (Aws.Json.lookup j "SnapshotId") String.of_json
    ; volume_size = Aws.Util.option_map (Aws.Json.lookup j "VolumeSize") Integer.of_json
    ; volume_type = Aws.Util.option_map (Aws.Json.lookup j "VolumeType") String.of_json
    }
end

module ScheduledInstancesBlockDeviceMapping = struct
  type t =
    { device_name : String.t option
    ; ebs : ScheduledInstancesEbs.t option
    ; no_device : String.t option
    ; virtual_name : String.t option
    }

  let make ?device_name ?ebs ?no_device ?virtual_name () =
    { device_name; ebs; no_device; virtual_name }

  let parse xml =
    Some
      { device_name = Aws.Util.option_bind (Aws.Xml.member "DeviceName" xml) String.parse
      ; ebs = Aws.Util.option_bind (Aws.Xml.member "Ebs" xml) ScheduledInstancesEbs.parse
      ; no_device = Aws.Util.option_bind (Aws.Xml.member "NoDevice" xml) String.parse
      ; virtual_name =
          Aws.Util.option_bind (Aws.Xml.member "VirtualName" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.virtual_name (fun f ->
               Aws.Query.Pair ("VirtualName", String.to_query f))
         ; Aws.Util.option_map v.no_device (fun f ->
               Aws.Query.Pair ("NoDevice", String.to_query f))
         ; Aws.Util.option_map v.ebs (fun f ->
               Aws.Query.Pair ("Ebs", ScheduledInstancesEbs.to_query f))
         ; Aws.Util.option_map v.device_name (fun f ->
               Aws.Query.Pair ("DeviceName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.virtual_name (fun f -> "VirtualName", String.to_json f)
         ; Aws.Util.option_map v.no_device (fun f -> "NoDevice", String.to_json f)
         ; Aws.Util.option_map v.ebs (fun f -> "Ebs", ScheduledInstancesEbs.to_json f)
         ; Aws.Util.option_map v.device_name (fun f -> "DeviceName", String.to_json f)
         ])

  let of_json j =
    { device_name = Aws.Util.option_map (Aws.Json.lookup j "DeviceName") String.of_json
    ; ebs = Aws.Util.option_map (Aws.Json.lookup j "Ebs") ScheduledInstancesEbs.of_json
    ; no_device = Aws.Util.option_map (Aws.Json.lookup j "NoDevice") String.of_json
    ; virtual_name = Aws.Util.option_map (Aws.Json.lookup j "VirtualName") String.of_json
    }
end

module ScheduledInstancesBlockDeviceMappingSet = struct
  type t = ScheduledInstancesBlockDeviceMapping.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         ScheduledInstancesBlockDeviceMapping.parse
         (Aws.Xml.members "BlockDeviceMapping" xml))

  let to_query v = Aws.Query.to_query_list ScheduledInstancesBlockDeviceMapping.to_query v

  let to_json v = `List (List.map ScheduledInstancesBlockDeviceMapping.to_json v)

  let of_json j = Aws.Json.to_list ScheduledInstancesBlockDeviceMapping.of_json j
end

module ScheduledInstancesLaunchSpecification = struct
  type t =
    { block_device_mappings : ScheduledInstancesBlockDeviceMappingSet.t
    ; ebs_optimized : Boolean.t option
    ; iam_instance_profile : ScheduledInstancesIamInstanceProfile.t option
    ; image_id : String.t
    ; instance_type : String.t option
    ; kernel_id : String.t option
    ; key_name : String.t option
    ; monitoring : ScheduledInstancesMonitoring.t option
    ; network_interfaces : ScheduledInstancesNetworkInterfaceSet.t
    ; placement : ScheduledInstancesPlacement.t option
    ; ramdisk_id : String.t option
    ; security_group_ids : ScheduledInstancesSecurityGroupIdSet.t
    ; subnet_id : String.t option
    ; user_data : String.t option
    }

  let make
      ?(block_device_mappings = [])
      ?ebs_optimized
      ?iam_instance_profile
      ~image_id
      ?instance_type
      ?kernel_id
      ?key_name
      ?monitoring
      ?(network_interfaces = [])
      ?placement
      ?ramdisk_id
      ?(security_group_ids = [])
      ?subnet_id
      ?user_data
      () =
    { block_device_mappings
    ; ebs_optimized
    ; iam_instance_profile
    ; image_id
    ; instance_type
    ; kernel_id
    ; key_name
    ; monitoring
    ; network_interfaces
    ; placement
    ; ramdisk_id
    ; security_group_ids
    ; subnet_id
    ; user_data
    }

  let parse xml =
    Some
      { block_device_mappings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "BlockDeviceMapping" xml)
               ScheduledInstancesBlockDeviceMappingSet.parse)
      ; ebs_optimized =
          Aws.Util.option_bind (Aws.Xml.member "EbsOptimized" xml) Boolean.parse
      ; iam_instance_profile =
          Aws.Util.option_bind
            (Aws.Xml.member "IamInstanceProfile" xml)
            ScheduledInstancesIamInstanceProfile.parse
      ; image_id =
          Aws.Xml.required
            "ImageId"
            (Aws.Util.option_bind (Aws.Xml.member "ImageId" xml) String.parse)
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "InstanceType" xml) String.parse
      ; kernel_id = Aws.Util.option_bind (Aws.Xml.member "KernelId" xml) String.parse
      ; key_name = Aws.Util.option_bind (Aws.Xml.member "KeyName" xml) String.parse
      ; monitoring =
          Aws.Util.option_bind
            (Aws.Xml.member "Monitoring" xml)
            ScheduledInstancesMonitoring.parse
      ; network_interfaces =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "NetworkInterface" xml)
               ScheduledInstancesNetworkInterfaceSet.parse)
      ; placement =
          Aws.Util.option_bind
            (Aws.Xml.member "Placement" xml)
            ScheduledInstancesPlacement.parse
      ; ramdisk_id = Aws.Util.option_bind (Aws.Xml.member "RamdiskId" xml) String.parse
      ; security_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SecurityGroupId" xml)
               ScheduledInstancesSecurityGroupIdSet.parse)
      ; subnet_id = Aws.Util.option_bind (Aws.Xml.member "SubnetId" xml) String.parse
      ; user_data = Aws.Util.option_bind (Aws.Xml.member "UserData" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.user_data (fun f ->
               Aws.Query.Pair ("UserData", String.to_query f))
         ; Aws.Util.option_map v.subnet_id (fun f ->
               Aws.Query.Pair ("SubnetId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "SecurityGroupId"
                , ScheduledInstancesSecurityGroupIdSet.to_query v.security_group_ids ))
         ; Aws.Util.option_map v.ramdisk_id (fun f ->
               Aws.Query.Pair ("RamdiskId", String.to_query f))
         ; Aws.Util.option_map v.placement (fun f ->
               Aws.Query.Pair ("Placement", ScheduledInstancesPlacement.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "NetworkInterface"
                , ScheduledInstancesNetworkInterfaceSet.to_query v.network_interfaces ))
         ; Aws.Util.option_map v.monitoring (fun f ->
               Aws.Query.Pair ("Monitoring", ScheduledInstancesMonitoring.to_query f))
         ; Aws.Util.option_map v.key_name (fun f ->
               Aws.Query.Pair ("KeyName", String.to_query f))
         ; Aws.Util.option_map v.kernel_id (fun f ->
               Aws.Query.Pair ("KernelId", String.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", String.to_query f))
         ; Some (Aws.Query.Pair ("ImageId", String.to_query v.image_id))
         ; Aws.Util.option_map v.iam_instance_profile (fun f ->
               Aws.Query.Pair
                 ("IamInstanceProfile", ScheduledInstancesIamInstanceProfile.to_query f))
         ; Aws.Util.option_map v.ebs_optimized (fun f ->
               Aws.Query.Pair ("EbsOptimized", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "BlockDeviceMapping"
                , ScheduledInstancesBlockDeviceMappingSet.to_query v.block_device_mappings
                ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.user_data (fun f -> "UserData", String.to_json f)
         ; Aws.Util.option_map v.subnet_id (fun f -> "SubnetId", String.to_json f)
         ; Some
             ( "SecurityGroupId"
             , ScheduledInstancesSecurityGroupIdSet.to_json v.security_group_ids )
         ; Aws.Util.option_map v.ramdisk_id (fun f -> "RamdiskId", String.to_json f)
         ; Aws.Util.option_map v.placement (fun f ->
               "Placement", ScheduledInstancesPlacement.to_json f)
         ; Some
             ( "NetworkInterface"
             , ScheduledInstancesNetworkInterfaceSet.to_json v.network_interfaces )
         ; Aws.Util.option_map v.monitoring (fun f ->
               "Monitoring", ScheduledInstancesMonitoring.to_json f)
         ; Aws.Util.option_map v.key_name (fun f -> "KeyName", String.to_json f)
         ; Aws.Util.option_map v.kernel_id (fun f -> "KernelId", String.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f -> "InstanceType", String.to_json f)
         ; Some ("ImageId", String.to_json v.image_id)
         ; Aws.Util.option_map v.iam_instance_profile (fun f ->
               "IamInstanceProfile", ScheduledInstancesIamInstanceProfile.to_json f)
         ; Aws.Util.option_map v.ebs_optimized (fun f ->
               "EbsOptimized", Boolean.to_json f)
         ; Some
             ( "BlockDeviceMapping"
             , ScheduledInstancesBlockDeviceMappingSet.to_json v.block_device_mappings )
         ])

  let of_json j =
    { block_device_mappings =
        ScheduledInstancesBlockDeviceMappingSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "BlockDeviceMapping"))
    ; ebs_optimized =
        Aws.Util.option_map (Aws.Json.lookup j "EbsOptimized") Boolean.of_json
    ; iam_instance_profile =
        Aws.Util.option_map
          (Aws.Json.lookup j "IamInstanceProfile")
          ScheduledInstancesIamInstanceProfile.of_json
    ; image_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ImageId"))
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "InstanceType") String.of_json
    ; kernel_id = Aws.Util.option_map (Aws.Json.lookup j "KernelId") String.of_json
    ; key_name = Aws.Util.option_map (Aws.Json.lookup j "KeyName") String.of_json
    ; monitoring =
        Aws.Util.option_map
          (Aws.Json.lookup j "Monitoring")
          ScheduledInstancesMonitoring.of_json
    ; network_interfaces =
        ScheduledInstancesNetworkInterfaceSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "NetworkInterface"))
    ; placement =
        Aws.Util.option_map
          (Aws.Json.lookup j "Placement")
          ScheduledInstancesPlacement.of_json
    ; ramdisk_id = Aws.Util.option_map (Aws.Json.lookup j "RamdiskId") String.of_json
    ; security_group_ids =
        ScheduledInstancesSecurityGroupIdSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SecurityGroupId"))
    ; subnet_id = Aws.Util.option_map (Aws.Json.lookup j "SubnetId") String.of_json
    ; user_data = Aws.Util.option_map (Aws.Json.lookup j "UserData") String.of_json
    }
end

module RunScheduledInstancesRequest = struct
  type t =
    { client_token : String.t option
    ; dry_run : Boolean.t option
    ; instance_count : Integer.t option
    ; launch_specification : ScheduledInstancesLaunchSpecification.t
    ; scheduled_instance_id : String.t
    }

  let make
      ?client_token
      ?dry_run
      ?instance_count
      ~launch_specification
      ~scheduled_instance_id
      () =
    { client_token; dry_run; instance_count; launch_specification; scheduled_instance_id }

  let parse xml =
    Some
      { client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; instance_count =
          Aws.Util.option_bind (Aws.Xml.member "InstanceCount" xml) Integer.parse
      ; launch_specification =
          Aws.Xml.required
            "LaunchSpecification"
            (Aws.Util.option_bind
               (Aws.Xml.member "LaunchSpecification" xml)
               ScheduledInstancesLaunchSpecification.parse)
      ; scheduled_instance_id =
          Aws.Xml.required
            "ScheduledInstanceId"
            (Aws.Util.option_bind (Aws.Xml.member "ScheduledInstanceId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("ScheduledInstanceId", String.to_query v.scheduled_instance_id))
         ; Some
             (Aws.Query.Pair
                ( "LaunchSpecification"
                , ScheduledInstancesLaunchSpecification.to_query v.launch_specification ))
         ; Aws.Util.option_map v.instance_count (fun f ->
               Aws.Query.Pair ("InstanceCount", Integer.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("ScheduledInstanceId", String.to_json v.scheduled_instance_id)
         ; Some
             ( "LaunchSpecification"
             , ScheduledInstancesLaunchSpecification.to_json v.launch_specification )
         ; Aws.Util.option_map v.instance_count (fun f ->
               "InstanceCount", Integer.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ])

  let of_json j =
    { client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; instance_count =
        Aws.Util.option_map (Aws.Json.lookup j "InstanceCount") Integer.of_json
    ; launch_specification =
        ScheduledInstancesLaunchSpecification.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "LaunchSpecification"))
    ; scheduled_instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ScheduledInstanceId"))
    }
end

module PaymentOption = struct
  type t =
    | AllUpfront
    | PartialUpfront
    | NoUpfront

  let str_to_t =
    [ "NoUpfront", NoUpfront; "PartialUpfront", PartialUpfront; "AllUpfront", AllUpfront ]

  let t_to_str =
    [ NoUpfront, "NoUpfront"; PartialUpfront, "PartialUpfront"; AllUpfront, "AllUpfront" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module HostOffering = struct
  type t =
    { currency_code : CurrencyCodeValues.t option
    ; duration : Integer.t option
    ; hourly_price : String.t option
    ; instance_family : String.t option
    ; offering_id : String.t option
    ; payment_option : PaymentOption.t option
    ; upfront_price : String.t option
    }

  let make
      ?currency_code
      ?duration
      ?hourly_price
      ?instance_family
      ?offering_id
      ?payment_option
      ?upfront_price
      () =
    { currency_code
    ; duration
    ; hourly_price
    ; instance_family
    ; offering_id
    ; payment_option
    ; upfront_price
    }

  let parse xml =
    Some
      { currency_code =
          Aws.Util.option_bind
            (Aws.Xml.member "currencyCode" xml)
            CurrencyCodeValues.parse
      ; duration = Aws.Util.option_bind (Aws.Xml.member "duration" xml) Integer.parse
      ; hourly_price =
          Aws.Util.option_bind (Aws.Xml.member "hourlyPrice" xml) String.parse
      ; instance_family =
          Aws.Util.option_bind (Aws.Xml.member "instanceFamily" xml) String.parse
      ; offering_id = Aws.Util.option_bind (Aws.Xml.member "offeringId" xml) String.parse
      ; payment_option =
          Aws.Util.option_bind (Aws.Xml.member "paymentOption" xml) PaymentOption.parse
      ; upfront_price =
          Aws.Util.option_bind (Aws.Xml.member "upfrontPrice" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.upfront_price (fun f ->
               Aws.Query.Pair ("UpfrontPrice", String.to_query f))
         ; Aws.Util.option_map v.payment_option (fun f ->
               Aws.Query.Pair ("PaymentOption", PaymentOption.to_query f))
         ; Aws.Util.option_map v.offering_id (fun f ->
               Aws.Query.Pair ("OfferingId", String.to_query f))
         ; Aws.Util.option_map v.instance_family (fun f ->
               Aws.Query.Pair ("InstanceFamily", String.to_query f))
         ; Aws.Util.option_map v.hourly_price (fun f ->
               Aws.Query.Pair ("HourlyPrice", String.to_query f))
         ; Aws.Util.option_map v.duration (fun f ->
               Aws.Query.Pair ("Duration", Integer.to_query f))
         ; Aws.Util.option_map v.currency_code (fun f ->
               Aws.Query.Pair ("CurrencyCode", CurrencyCodeValues.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.upfront_price (fun f -> "upfrontPrice", String.to_json f)
         ; Aws.Util.option_map v.payment_option (fun f ->
               "paymentOption", PaymentOption.to_json f)
         ; Aws.Util.option_map v.offering_id (fun f -> "offeringId", String.to_json f)
         ; Aws.Util.option_map v.instance_family (fun f ->
               "instanceFamily", String.to_json f)
         ; Aws.Util.option_map v.hourly_price (fun f -> "hourlyPrice", String.to_json f)
         ; Aws.Util.option_map v.duration (fun f -> "duration", Integer.to_json f)
         ; Aws.Util.option_map v.currency_code (fun f ->
               "currencyCode", CurrencyCodeValues.to_json f)
         ])

  let of_json j =
    { currency_code =
        Aws.Util.option_map (Aws.Json.lookup j "currencyCode") CurrencyCodeValues.of_json
    ; duration = Aws.Util.option_map (Aws.Json.lookup j "duration") Integer.of_json
    ; hourly_price = Aws.Util.option_map (Aws.Json.lookup j "hourlyPrice") String.of_json
    ; instance_family =
        Aws.Util.option_map (Aws.Json.lookup j "instanceFamily") String.of_json
    ; offering_id = Aws.Util.option_map (Aws.Json.lookup j "offeringId") String.of_json
    ; payment_option =
        Aws.Util.option_map (Aws.Json.lookup j "paymentOption") PaymentOption.of_json
    ; upfront_price =
        Aws.Util.option_map (Aws.Json.lookup j "upfrontPrice") String.of_json
    }
end

module HostOfferingSet = struct
  type t = HostOffering.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map HostOffering.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list HostOffering.to_query v

  let to_json v = `List (List.map HostOffering.to_json v)

  let of_json j = Aws.Json.to_list HostOffering.of_json j
end

module TransitGatewayState = struct
  type t =
    | Pending
    | Available
    | Modifying
    | Deleting
    | Deleted

  let str_to_t =
    [ "deleted", Deleted
    ; "deleting", Deleting
    ; "modifying", Modifying
    ; "available", Available
    ; "pending", Pending
    ]

  let t_to_str =
    [ Deleted, "deleted"
    ; Deleting, "deleting"
    ; Modifying, "modifying"
    ; Available, "available"
    ; Pending, "pending"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module LocalGatewayRouteType = struct
  type t =
    | Static
    | Propagated

  let str_to_t = [ "propagated", Propagated; "static", Static ]

  let t_to_str = [ Propagated, "propagated"; Static, "static" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module LocalGatewayRouteState = struct
  type t =
    | Pending
    | Active
    | Blackhole
    | Deleting
    | Deleted

  let str_to_t =
    [ "deleted", Deleted
    ; "deleting", Deleting
    ; "blackhole", Blackhole
    ; "active", Active
    ; "pending", Pending
    ]

  let t_to_str =
    [ Deleted, "deleted"
    ; Deleting, "deleting"
    ; Blackhole, "blackhole"
    ; Active, "active"
    ; Pending, "pending"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module LocalGatewayRoute = struct
  type t =
    { destination_cidr_block : String.t option
    ; local_gateway_virtual_interface_group_id : String.t option
    ; type_ : LocalGatewayRouteType.t option
    ; state : LocalGatewayRouteState.t option
    ; local_gateway_route_table_id : String.t option
    ; local_gateway_route_table_arn : String.t option
    ; owner_id : String.t option
    }

  let make
      ?destination_cidr_block
      ?local_gateway_virtual_interface_group_id
      ?type_
      ?state
      ?local_gateway_route_table_id
      ?local_gateway_route_table_arn
      ?owner_id
      () =
    { destination_cidr_block
    ; local_gateway_virtual_interface_group_id
    ; type_
    ; state
    ; local_gateway_route_table_id
    ; local_gateway_route_table_arn
    ; owner_id
    }

  let parse xml =
    Some
      { destination_cidr_block =
          Aws.Util.option_bind (Aws.Xml.member "destinationCidrBlock" xml) String.parse
      ; local_gateway_virtual_interface_group_id =
          Aws.Util.option_bind
            (Aws.Xml.member "localGatewayVirtualInterfaceGroupId" xml)
            String.parse
      ; type_ =
          Aws.Util.option_bind (Aws.Xml.member "type" xml) LocalGatewayRouteType.parse
      ; state =
          Aws.Util.option_bind (Aws.Xml.member "state" xml) LocalGatewayRouteState.parse
      ; local_gateway_route_table_id =
          Aws.Util.option_bind
            (Aws.Xml.member "localGatewayRouteTableId" xml)
            String.parse
      ; local_gateway_route_table_arn =
          Aws.Util.option_bind
            (Aws.Xml.member "localGatewayRouteTableArn" xml)
            String.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.local_gateway_route_table_arn (fun f ->
               Aws.Query.Pair ("LocalGatewayRouteTableArn", String.to_query f))
         ; Aws.Util.option_map v.local_gateway_route_table_id (fun f ->
               Aws.Query.Pair ("LocalGatewayRouteTableId", String.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", LocalGatewayRouteState.to_query f))
         ; Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", LocalGatewayRouteType.to_query f))
         ; Aws.Util.option_map v.local_gateway_virtual_interface_group_id (fun f ->
               Aws.Query.Pair ("LocalGatewayVirtualInterfaceGroupId", String.to_query f))
         ; Aws.Util.option_map v.destination_cidr_block (fun f ->
               Aws.Query.Pair ("DestinationCidrBlock", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.local_gateway_route_table_arn (fun f ->
               "localGatewayRouteTableArn", String.to_json f)
         ; Aws.Util.option_map v.local_gateway_route_table_id (fun f ->
               "localGatewayRouteTableId", String.to_json f)
         ; Aws.Util.option_map v.state (fun f ->
               "state", LocalGatewayRouteState.to_json f)
         ; Aws.Util.option_map v.type_ (fun f -> "type", LocalGatewayRouteType.to_json f)
         ; Aws.Util.option_map v.local_gateway_virtual_interface_group_id (fun f ->
               "localGatewayVirtualInterfaceGroupId", String.to_json f)
         ; Aws.Util.option_map v.destination_cidr_block (fun f ->
               "destinationCidrBlock", String.to_json f)
         ])

  let of_json j =
    { destination_cidr_block =
        Aws.Util.option_map (Aws.Json.lookup j "destinationCidrBlock") String.of_json
    ; local_gateway_virtual_interface_group_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "localGatewayVirtualInterfaceGroupId")
          String.of_json
    ; type_ = Aws.Util.option_map (Aws.Json.lookup j "type") LocalGatewayRouteType.of_json
    ; state =
        Aws.Util.option_map (Aws.Json.lookup j "state") LocalGatewayRouteState.of_json
    ; local_gateway_route_table_id =
        Aws.Util.option_map (Aws.Json.lookup j "localGatewayRouteTableId") String.of_json
    ; local_gateway_route_table_arn =
        Aws.Util.option_map (Aws.Json.lookup j "localGatewayRouteTableArn") String.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    }
end

module LocalGatewayRouteList = struct
  type t = LocalGatewayRoute.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map LocalGatewayRoute.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list LocalGatewayRoute.to_query v

  let to_json v = `List (List.map LocalGatewayRoute.to_json v)

  let of_json j = Aws.Json.to_list LocalGatewayRoute.of_json j
end

module SearchLocalGatewayRoutesResult = struct
  type t =
    { routes : LocalGatewayRouteList.t
    ; next_token : String.t option
    }

  let make ?(routes = []) ?next_token () = { routes; next_token }

  let parse xml =
    Some
      { routes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "routeSet" xml)
               LocalGatewayRouteList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("RouteSet", LocalGatewayRouteList.to_query v.routes))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("routeSet", LocalGatewayRouteList.to_json v.routes)
         ])

  let of_json j =
    { routes =
        LocalGatewayRouteList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "routeSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module TransitGatewayAttachmentResourceType = struct
  type t =
    | Vpc
    | Vpn
    | Direct_connect_gateway
    | Peering
    | Tgw_peering

  let str_to_t =
    [ "tgw-peering", Tgw_peering
    ; "peering", Peering
    ; "direct-connect-gateway", Direct_connect_gateway
    ; "vpn", Vpn
    ; "vpc", Vpc
    ]

  let t_to_str =
    [ Tgw_peering, "tgw-peering"
    ; Peering, "peering"
    ; Direct_connect_gateway, "direct-connect-gateway"
    ; Vpn, "vpn"
    ; Vpc, "vpc"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module TransitGatewayAssociationState = struct
  type t =
    | Associating
    | Associated
    | Disassociating
    | Disassociated

  let str_to_t =
    [ "disassociated", Disassociated
    ; "disassociating", Disassociating
    ; "associated", Associated
    ; "associating", Associating
    ]

  let t_to_str =
    [ Disassociated, "disassociated"
    ; Disassociating, "disassociating"
    ; Associated, "associated"
    ; Associating, "associating"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module TransitGatewayRouteTableAssociation = struct
  type t =
    { transit_gateway_attachment_id : String.t option
    ; resource_id : String.t option
    ; resource_type : TransitGatewayAttachmentResourceType.t option
    ; state : TransitGatewayAssociationState.t option
    }

  let make ?transit_gateway_attachment_id ?resource_id ?resource_type ?state () =
    { transit_gateway_attachment_id; resource_id; resource_type; state }

  let parse xml =
    Some
      { transit_gateway_attachment_id =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayAttachmentId" xml)
            String.parse
      ; resource_id = Aws.Util.option_bind (Aws.Xml.member "resourceId" xml) String.parse
      ; resource_type =
          Aws.Util.option_bind
            (Aws.Xml.member "resourceType" xml)
            TransitGatewayAttachmentResourceType.parse
      ; state =
          Aws.Util.option_bind
            (Aws.Xml.member "state" xml)
            TransitGatewayAssociationState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", TransitGatewayAssociationState.to_query f))
         ; Aws.Util.option_map v.resource_type (fun f ->
               Aws.Query.Pair
                 ("ResourceType", TransitGatewayAttachmentResourceType.to_query f))
         ; Aws.Util.option_map v.resource_id (fun f ->
               Aws.Query.Pair ("ResourceId", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               Aws.Query.Pair ("TransitGatewayAttachmentId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               "state", TransitGatewayAssociationState.to_json f)
         ; Aws.Util.option_map v.resource_type (fun f ->
               "resourceType", TransitGatewayAttachmentResourceType.to_json f)
         ; Aws.Util.option_map v.resource_id (fun f -> "resourceId", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               "transitGatewayAttachmentId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_attachment_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayAttachmentId")
          String.of_json
    ; resource_id = Aws.Util.option_map (Aws.Json.lookup j "resourceId") String.of_json
    ; resource_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "resourceType")
          TransitGatewayAttachmentResourceType.of_json
    ; state =
        Aws.Util.option_map
          (Aws.Json.lookup j "state")
          TransitGatewayAssociationState.of_json
    }
end

module TransitGatewayRouteTableAssociationList = struct
  type t = TransitGatewayRouteTableAssociation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map TransitGatewayRouteTableAssociation.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list TransitGatewayRouteTableAssociation.to_query v

  let to_json v = `List (List.map TransitGatewayRouteTableAssociation.to_json v)

  let of_json j = Aws.Json.to_list TransitGatewayRouteTableAssociation.of_json j
end

module SubnetState = struct
  type t =
    | Pending
    | Available

  let str_to_t = [ "available", Available; "pending", Pending ]

  let t_to_str = [ Available, "available"; Pending, "pending" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module SubnetCidrBlockStateCode = struct
  type t =
    | Associating
    | Associated
    | Disassociating
    | Disassociated
    | Failing
    | Failed

  let str_to_t =
    [ "failed", Failed
    ; "failing", Failing
    ; "disassociated", Disassociated
    ; "disassociating", Disassociating
    ; "associated", Associated
    ; "associating", Associating
    ]

  let t_to_str =
    [ Failed, "failed"
    ; Failing, "failing"
    ; Disassociated, "disassociated"
    ; Disassociating, "disassociating"
    ; Associated, "associated"
    ; Associating, "associating"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module SubnetCidrBlockState = struct
  type t =
    { state : SubnetCidrBlockStateCode.t option
    ; status_message : String.t option
    }

  let make ?state ?status_message () = { state; status_message }

  let parse xml =
    Some
      { state =
          Aws.Util.option_bind (Aws.Xml.member "state" xml) SubnetCidrBlockStateCode.parse
      ; status_message =
          Aws.Util.option_bind (Aws.Xml.member "statusMessage" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status_message (fun f ->
               Aws.Query.Pair ("StatusMessage", String.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", SubnetCidrBlockStateCode.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status_message (fun f ->
               "statusMessage", String.to_json f)
         ; Aws.Util.option_map v.state (fun f ->
               "state", SubnetCidrBlockStateCode.to_json f)
         ])

  let of_json j =
    { state =
        Aws.Util.option_map (Aws.Json.lookup j "state") SubnetCidrBlockStateCode.of_json
    ; status_message =
        Aws.Util.option_map (Aws.Json.lookup j "statusMessage") String.of_json
    }
end

module SubnetIpv6CidrBlockAssociation = struct
  type t =
    { association_id : String.t option
    ; ipv6_cidr_block : String.t option
    ; ipv6_cidr_block_state : SubnetCidrBlockState.t option
    }

  let make ?association_id ?ipv6_cidr_block ?ipv6_cidr_block_state () =
    { association_id; ipv6_cidr_block; ipv6_cidr_block_state }

  let parse xml =
    Some
      { association_id =
          Aws.Util.option_bind (Aws.Xml.member "associationId" xml) String.parse
      ; ipv6_cidr_block =
          Aws.Util.option_bind (Aws.Xml.member "ipv6CidrBlock" xml) String.parse
      ; ipv6_cidr_block_state =
          Aws.Util.option_bind
            (Aws.Xml.member "ipv6CidrBlockState" xml)
            SubnetCidrBlockState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ipv6_cidr_block_state (fun f ->
               Aws.Query.Pair ("Ipv6CidrBlockState", SubnetCidrBlockState.to_query f))
         ; Aws.Util.option_map v.ipv6_cidr_block (fun f ->
               Aws.Query.Pair ("Ipv6CidrBlock", String.to_query f))
         ; Aws.Util.option_map v.association_id (fun f ->
               Aws.Query.Pair ("AssociationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ipv6_cidr_block_state (fun f ->
               "ipv6CidrBlockState", SubnetCidrBlockState.to_json f)
         ; Aws.Util.option_map v.ipv6_cidr_block (fun f ->
               "ipv6CidrBlock", String.to_json f)
         ; Aws.Util.option_map v.association_id (fun f ->
               "associationId", String.to_json f)
         ])

  let of_json j =
    { association_id =
        Aws.Util.option_map (Aws.Json.lookup j "associationId") String.of_json
    ; ipv6_cidr_block =
        Aws.Util.option_map (Aws.Json.lookup j "ipv6CidrBlock") String.of_json
    ; ipv6_cidr_block_state =
        Aws.Util.option_map
          (Aws.Json.lookup j "ipv6CidrBlockState")
          SubnetCidrBlockState.of_json
    }
end

module SubnetIpv6CidrBlockAssociationSet = struct
  type t = SubnetIpv6CidrBlockAssociation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map SubnetIpv6CidrBlockAssociation.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list SubnetIpv6CidrBlockAssociation.to_query v

  let to_json v = `List (List.map SubnetIpv6CidrBlockAssociation.to_json v)

  let of_json j = Aws.Json.to_list SubnetIpv6CidrBlockAssociation.of_json j
end

module Subnet = struct
  type t =
    { availability_zone : String.t
    ; availability_zone_id : String.t option
    ; available_ip_address_count : Integer.t
    ; cidr_block : String.t
    ; default_for_az : Boolean.t
    ; map_public_ip_on_launch : Boolean.t
    ; map_customer_owned_ip_on_launch : Boolean.t option
    ; customer_owned_ipv4_pool : String.t option
    ; state : SubnetState.t
    ; subnet_id : String.t
    ; vpc_id : String.t
    ; owner_id : String.t option
    ; assign_ipv6_address_on_creation : Boolean.t option
    ; ipv6_cidr_block_association_set : SubnetIpv6CidrBlockAssociationSet.t
    ; tags : TagList.t
    ; subnet_arn : String.t option
    ; outpost_arn : String.t option
    }

  let make
      ~availability_zone
      ?availability_zone_id
      ~available_ip_address_count
      ~cidr_block
      ~default_for_az
      ~map_public_ip_on_launch
      ?map_customer_owned_ip_on_launch
      ?customer_owned_ipv4_pool
      ~state
      ~subnet_id
      ~vpc_id
      ?owner_id
      ?assign_ipv6_address_on_creation
      ?(ipv6_cidr_block_association_set = [])
      ?(tags = [])
      ?subnet_arn
      ?outpost_arn
      () =
    { availability_zone
    ; availability_zone_id
    ; available_ip_address_count
    ; cidr_block
    ; default_for_az
    ; map_public_ip_on_launch
    ; map_customer_owned_ip_on_launch
    ; customer_owned_ipv4_pool
    ; state
    ; subnet_id
    ; vpc_id
    ; owner_id
    ; assign_ipv6_address_on_creation
    ; ipv6_cidr_block_association_set
    ; tags
    ; subnet_arn
    ; outpost_arn
    }

  let parse xml =
    Some
      { availability_zone =
          Aws.Xml.required
            "availabilityZone"
            (Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse)
      ; availability_zone_id =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZoneId" xml) String.parse
      ; available_ip_address_count =
          Aws.Xml.required
            "availableIpAddressCount"
            (Aws.Util.option_bind
               (Aws.Xml.member "availableIpAddressCount" xml)
               Integer.parse)
      ; cidr_block =
          Aws.Xml.required
            "cidrBlock"
            (Aws.Util.option_bind (Aws.Xml.member "cidrBlock" xml) String.parse)
      ; default_for_az =
          Aws.Xml.required
            "defaultForAz"
            (Aws.Util.option_bind (Aws.Xml.member "defaultForAz" xml) Boolean.parse)
      ; map_public_ip_on_launch =
          Aws.Xml.required
            "mapPublicIpOnLaunch"
            (Aws.Util.option_bind
               (Aws.Xml.member "mapPublicIpOnLaunch" xml)
               Boolean.parse)
      ; map_customer_owned_ip_on_launch =
          Aws.Util.option_bind
            (Aws.Xml.member "mapCustomerOwnedIpOnLaunch" xml)
            Boolean.parse
      ; customer_owned_ipv4_pool =
          Aws.Util.option_bind (Aws.Xml.member "customerOwnedIpv4Pool" xml) String.parse
      ; state =
          Aws.Xml.required
            "state"
            (Aws.Util.option_bind (Aws.Xml.member "state" xml) SubnetState.parse)
      ; subnet_id =
          Aws.Xml.required
            "subnetId"
            (Aws.Util.option_bind (Aws.Xml.member "subnetId" xml) String.parse)
      ; vpc_id =
          Aws.Xml.required
            "vpcId"
            (Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse)
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; assign_ipv6_address_on_creation =
          Aws.Util.option_bind
            (Aws.Xml.member "assignIpv6AddressOnCreation" xml)
            Boolean.parse
      ; ipv6_cidr_block_association_set =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ipv6CidrBlockAssociationSet" xml)
               SubnetIpv6CidrBlockAssociationSet.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      ; subnet_arn = Aws.Util.option_bind (Aws.Xml.member "subnetArn" xml) String.parse
      ; outpost_arn = Aws.Util.option_bind (Aws.Xml.member "outpostArn" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.outpost_arn (fun f ->
               Aws.Query.Pair ("OutpostArn", String.to_query f))
         ; Aws.Util.option_map v.subnet_arn (fun f ->
               Aws.Query.Pair ("SubnetArn", String.to_query f))
         ; Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Some
             (Aws.Query.Pair
                ( "Ipv6CidrBlockAssociationSet"
                , SubnetIpv6CidrBlockAssociationSet.to_query
                    v.ipv6_cidr_block_association_set ))
         ; Aws.Util.option_map v.assign_ipv6_address_on_creation (fun f ->
               Aws.Query.Pair ("AssignIpv6AddressOnCreation", Boolean.to_query f))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ; Some (Aws.Query.Pair ("SubnetId", String.to_query v.subnet_id))
         ; Some (Aws.Query.Pair ("State", SubnetState.to_query v.state))
         ; Aws.Util.option_map v.customer_owned_ipv4_pool (fun f ->
               Aws.Query.Pair ("CustomerOwnedIpv4Pool", String.to_query f))
         ; Aws.Util.option_map v.map_customer_owned_ip_on_launch (fun f ->
               Aws.Query.Pair ("MapCustomerOwnedIpOnLaunch", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("MapPublicIpOnLaunch", Boolean.to_query v.map_public_ip_on_launch))
         ; Some (Aws.Query.Pair ("DefaultForAz", Boolean.to_query v.default_for_az))
         ; Some (Aws.Query.Pair ("CidrBlock", String.to_query v.cidr_block))
         ; Some
             (Aws.Query.Pair
                ("AvailableIpAddressCount", Integer.to_query v.available_ip_address_count))
         ; Aws.Util.option_map v.availability_zone_id (fun f ->
               Aws.Query.Pair ("AvailabilityZoneId", String.to_query f))
         ; Some (Aws.Query.Pair ("AvailabilityZone", String.to_query v.availability_zone))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.outpost_arn (fun f -> "outpostArn", String.to_json f)
         ; Aws.Util.option_map v.subnet_arn (fun f -> "subnetArn", String.to_json f)
         ; Some ("tagSet", TagList.to_json v.tags)
         ; Some
             ( "ipv6CidrBlockAssociationSet"
             , SubnetIpv6CidrBlockAssociationSet.to_json v.ipv6_cidr_block_association_set
             )
         ; Aws.Util.option_map v.assign_ipv6_address_on_creation (fun f ->
               "assignIpv6AddressOnCreation", Boolean.to_json f)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Some ("vpcId", String.to_json v.vpc_id)
         ; Some ("subnetId", String.to_json v.subnet_id)
         ; Some ("state", SubnetState.to_json v.state)
         ; Aws.Util.option_map v.customer_owned_ipv4_pool (fun f ->
               "customerOwnedIpv4Pool", String.to_json f)
         ; Aws.Util.option_map v.map_customer_owned_ip_on_launch (fun f ->
               "mapCustomerOwnedIpOnLaunch", Boolean.to_json f)
         ; Some ("mapPublicIpOnLaunch", Boolean.to_json v.map_public_ip_on_launch)
         ; Some ("defaultForAz", Boolean.to_json v.default_for_az)
         ; Some ("cidrBlock", String.to_json v.cidr_block)
         ; Some ("availableIpAddressCount", Integer.to_json v.available_ip_address_count)
         ; Aws.Util.option_map v.availability_zone_id (fun f ->
               "availabilityZoneId", String.to_json f)
         ; Some ("availabilityZone", String.to_json v.availability_zone)
         ])

  let of_json j =
    { availability_zone =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "availabilityZone"))
    ; availability_zone_id =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZoneId") String.of_json
    ; available_ip_address_count =
        Integer.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "availableIpAddressCount"))
    ; cidr_block = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "cidrBlock"))
    ; default_for_az =
        Boolean.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "defaultForAz"))
    ; map_public_ip_on_launch =
        Boolean.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "mapPublicIpOnLaunch"))
    ; map_customer_owned_ip_on_launch =
        Aws.Util.option_map
          (Aws.Json.lookup j "mapCustomerOwnedIpOnLaunch")
          Boolean.of_json
    ; customer_owned_ipv4_pool =
        Aws.Util.option_map (Aws.Json.lookup j "customerOwnedIpv4Pool") String.of_json
    ; state = SubnetState.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "state"))
    ; subnet_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "subnetId"))
    ; vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "vpcId"))
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; assign_ipv6_address_on_creation =
        Aws.Util.option_map
          (Aws.Json.lookup j "assignIpv6AddressOnCreation")
          Boolean.of_json
    ; ipv6_cidr_block_association_set =
        SubnetIpv6CidrBlockAssociationSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ipv6CidrBlockAssociationSet"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    ; subnet_arn = Aws.Util.option_map (Aws.Json.lookup j "subnetArn") String.of_json
    ; outpost_arn = Aws.Util.option_map (Aws.Json.lookup j "outpostArn") String.of_json
    }
end

module SubnetList = struct
  type t = Subnet.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map Subnet.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Subnet.to_query v

  let to_json v = `List (List.map Subnet.to_json v)

  let of_json j = Aws.Json.to_list Subnet.of_json j
end

module SubnetIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "SubnetId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module TransitGatewayMulticastDomainState = struct
  type t =
    | Pending
    | Available
    | Deleting
    | Deleted

  let str_to_t =
    [ "deleted", Deleted
    ; "deleting", Deleting
    ; "available", Available
    ; "pending", Pending
    ]

  let t_to_str =
    [ Deleted, "deleted"
    ; Deleting, "deleting"
    ; Available, "available"
    ; Pending, "pending"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module TransitGatewayMulticastDomain = struct
  type t =
    { transit_gateway_multicast_domain_id : String.t option
    ; transit_gateway_id : String.t option
    ; state : TransitGatewayMulticastDomainState.t option
    ; creation_time : DateTime.t option
    ; tags : TagList.t
    }

  let make
      ?transit_gateway_multicast_domain_id
      ?transit_gateway_id
      ?state
      ?creation_time
      ?(tags = [])
      () =
    { transit_gateway_multicast_domain_id
    ; transit_gateway_id
    ; state
    ; creation_time
    ; tags
    }

  let parse xml =
    Some
      { transit_gateway_multicast_domain_id =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayMulticastDomainId" xml)
            String.parse
      ; transit_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "transitGatewayId" xml) String.parse
      ; state =
          Aws.Util.option_bind
            (Aws.Xml.member "state" xml)
            TransitGatewayMulticastDomainState.parse
      ; creation_time =
          Aws.Util.option_bind (Aws.Xml.member "creationTime" xml) DateTime.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.creation_time (fun f ->
               Aws.Query.Pair ("CreationTime", DateTime.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", TransitGatewayMulticastDomainState.to_query f))
         ; Aws.Util.option_map v.transit_gateway_id (fun f ->
               Aws.Query.Pair ("TransitGatewayId", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               Aws.Query.Pair ("TransitGatewayMulticastDomainId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.creation_time (fun f ->
               "creationTime", DateTime.to_json f)
         ; Aws.Util.option_map v.state (fun f ->
               "state", TransitGatewayMulticastDomainState.to_json f)
         ; Aws.Util.option_map v.transit_gateway_id (fun f ->
               "transitGatewayId", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               "transitGatewayMulticastDomainId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_multicast_domain_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayMulticastDomainId")
          String.of_json
    ; transit_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "transitGatewayId") String.of_json
    ; state =
        Aws.Util.option_map
          (Aws.Json.lookup j "state")
          TransitGatewayMulticastDomainState.of_json
    ; creation_time =
        Aws.Util.option_map (Aws.Json.lookup j "creationTime") DateTime.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module DeleteTransitGatewayMulticastDomainResult = struct
  type t = { transit_gateway_multicast_domain : TransitGatewayMulticastDomain.t option }

  let make ?transit_gateway_multicast_domain () = { transit_gateway_multicast_domain }

  let parse xml =
    Some
      { transit_gateway_multicast_domain =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayMulticastDomain" xml)
            TransitGatewayMulticastDomain.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_multicast_domain (fun f ->
               Aws.Query.Pair
                 ( "TransitGatewayMulticastDomain"
                 , TransitGatewayMulticastDomain.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_multicast_domain (fun f ->
               "transitGatewayMulticastDomain", TransitGatewayMulticastDomain.to_json f)
         ])

  let of_json j =
    { transit_gateway_multicast_domain =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayMulticastDomain")
          TransitGatewayMulticastDomain.of_json
    }
end

module AuthorizeSecurityGroupIngressRequest = struct
  type t =
    { cidr_ip : String.t option
    ; from_port : Integer.t option
    ; group_id : String.t option
    ; group_name : String.t option
    ; ip_permissions : IpPermissionList.t
    ; ip_protocol : String.t option
    ; source_security_group_name : String.t option
    ; source_security_group_owner_id : String.t option
    ; to_port : Integer.t option
    ; dry_run : Boolean.t option
    }

  let make
      ?cidr_ip
      ?from_port
      ?group_id
      ?group_name
      ?(ip_permissions = [])
      ?ip_protocol
      ?source_security_group_name
      ?source_security_group_owner_id
      ?to_port
      ?dry_run
      () =
    { cidr_ip
    ; from_port
    ; group_id
    ; group_name
    ; ip_permissions
    ; ip_protocol
    ; source_security_group_name
    ; source_security_group_owner_id
    ; to_port
    ; dry_run
    }

  let parse xml =
    Some
      { cidr_ip = Aws.Util.option_bind (Aws.Xml.member "CidrIp" xml) String.parse
      ; from_port = Aws.Util.option_bind (Aws.Xml.member "FromPort" xml) Integer.parse
      ; group_id = Aws.Util.option_bind (Aws.Xml.member "GroupId" xml) String.parse
      ; group_name = Aws.Util.option_bind (Aws.Xml.member "GroupName" xml) String.parse
      ; ip_permissions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "IpPermissions" xml)
               IpPermissionList.parse)
      ; ip_protocol = Aws.Util.option_bind (Aws.Xml.member "IpProtocol" xml) String.parse
      ; source_security_group_name =
          Aws.Util.option_bind (Aws.Xml.member "SourceSecurityGroupName" xml) String.parse
      ; source_security_group_owner_id =
          Aws.Util.option_bind
            (Aws.Xml.member "SourceSecurityGroupOwnerId" xml)
            String.parse
      ; to_port = Aws.Util.option_bind (Aws.Xml.member "ToPort" xml) Integer.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.to_port (fun f ->
               Aws.Query.Pair ("ToPort", Integer.to_query f))
         ; Aws.Util.option_map v.source_security_group_owner_id (fun f ->
               Aws.Query.Pair ("SourceSecurityGroupOwnerId", String.to_query f))
         ; Aws.Util.option_map v.source_security_group_name (fun f ->
               Aws.Query.Pair ("SourceSecurityGroupName", String.to_query f))
         ; Aws.Util.option_map v.ip_protocol (fun f ->
               Aws.Query.Pair ("IpProtocol", String.to_query f))
         ; Some
             (Aws.Query.Pair ("IpPermissions", IpPermissionList.to_query v.ip_permissions))
         ; Aws.Util.option_map v.group_name (fun f ->
               Aws.Query.Pair ("GroupName", String.to_query f))
         ; Aws.Util.option_map v.group_id (fun f ->
               Aws.Query.Pair ("GroupId", String.to_query f))
         ; Aws.Util.option_map v.from_port (fun f ->
               Aws.Query.Pair ("FromPort", Integer.to_query f))
         ; Aws.Util.option_map v.cidr_ip (fun f ->
               Aws.Query.Pair ("CidrIp", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.to_port (fun f -> "ToPort", Integer.to_json f)
         ; Aws.Util.option_map v.source_security_group_owner_id (fun f ->
               "SourceSecurityGroupOwnerId", String.to_json f)
         ; Aws.Util.option_map v.source_security_group_name (fun f ->
               "SourceSecurityGroupName", String.to_json f)
         ; Aws.Util.option_map v.ip_protocol (fun f -> "IpProtocol", String.to_json f)
         ; Some ("IpPermissions", IpPermissionList.to_json v.ip_permissions)
         ; Aws.Util.option_map v.group_name (fun f -> "GroupName", String.to_json f)
         ; Aws.Util.option_map v.group_id (fun f -> "GroupId", String.to_json f)
         ; Aws.Util.option_map v.from_port (fun f -> "FromPort", Integer.to_json f)
         ; Aws.Util.option_map v.cidr_ip (fun f -> "CidrIp", String.to_json f)
         ])

  let of_json j =
    { cidr_ip = Aws.Util.option_map (Aws.Json.lookup j "CidrIp") String.of_json
    ; from_port = Aws.Util.option_map (Aws.Json.lookup j "FromPort") Integer.of_json
    ; group_id = Aws.Util.option_map (Aws.Json.lookup j "GroupId") String.of_json
    ; group_name = Aws.Util.option_map (Aws.Json.lookup j "GroupName") String.of_json
    ; ip_permissions =
        IpPermissionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "IpPermissions"))
    ; ip_protocol = Aws.Util.option_map (Aws.Json.lookup j "IpProtocol") String.of_json
    ; source_security_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "SourceSecurityGroupName") String.of_json
    ; source_security_group_owner_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "SourceSecurityGroupOwnerId")
          String.of_json
    ; to_port = Aws.Util.option_map (Aws.Json.lookup j "ToPort") Integer.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module MonitoringState = struct
  type t =
    | Disabled
    | Disabling
    | Enabled
    | Pending

  let str_to_t =
    [ "pending", Pending
    ; "enabled", Enabled
    ; "disabling", Disabling
    ; "disabled", Disabled
    ]

  let t_to_str =
    [ Pending, "pending"
    ; Enabled, "enabled"
    ; Disabling, "disabling"
    ; Disabled, "disabled"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module Monitoring = struct
  type t = { state : MonitoringState.t option }

  let make ?state () = { state }

  let parse xml =
    Some
      { state = Aws.Util.option_bind (Aws.Xml.member "state" xml) MonitoringState.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", MonitoringState.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f -> "state", MonitoringState.to_json f) ])

  let of_json j =
    { state = Aws.Util.option_map (Aws.Json.lookup j "state") MonitoringState.of_json }
end

module InstanceMonitoring = struct
  type t =
    { instance_id : String.t option
    ; monitoring : Monitoring.t option
    }

  let make ?instance_id ?monitoring () = { instance_id; monitoring }

  let parse xml =
    Some
      { instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      ; monitoring =
          Aws.Util.option_bind (Aws.Xml.member "monitoring" xml) Monitoring.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.monitoring (fun f ->
               Aws.Query.Pair ("Monitoring", Monitoring.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.monitoring (fun f -> "monitoring", Monitoring.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ])

  let of_json j =
    { instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    ; monitoring = Aws.Util.option_map (Aws.Json.lookup j "monitoring") Monitoring.of_json
    }
end

module InstanceMonitoringList = struct
  type t = InstanceMonitoring.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map InstanceMonitoring.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list InstanceMonitoring.to_query v

  let to_json v = `List (List.map InstanceMonitoring.to_json v)

  let of_json j = Aws.Json.to_list InstanceMonitoring.of_json j
end

module MonitorInstancesResult = struct
  type t = { instance_monitorings : InstanceMonitoringList.t }

  let make ?(instance_monitorings = []) () = { instance_monitorings }

  let parse xml =
    Some
      { instance_monitorings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "instancesSet" xml)
               InstanceMonitoringList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("InstancesSet", InstanceMonitoringList.to_query v.instance_monitorings))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("instancesSet", InstanceMonitoringList.to_json v.instance_monitorings) ])

  let of_json j =
    { instance_monitorings =
        InstanceMonitoringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "instancesSet"))
    }
end

module DetachVpnGatewayRequest = struct
  type t =
    { vpc_id : String.t
    ; vpn_gateway_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~vpc_id ~vpn_gateway_id ?dry_run () = { vpc_id; vpn_gateway_id; dry_run }

  let parse xml =
    Some
      { vpc_id =
          Aws.Xml.required
            "VpcId"
            (Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) String.parse)
      ; vpn_gateway_id =
          Aws.Xml.required
            "VpnGatewayId"
            (Aws.Util.option_bind (Aws.Xml.member "VpnGatewayId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("VpnGatewayId", String.to_query v.vpn_gateway_id))
         ; Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("VpnGatewayId", String.to_json v.vpn_gateway_id)
         ; Some ("VpcId", String.to_json v.vpc_id)
         ])

  let of_json j =
    { vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcId"))
    ; vpn_gateway_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpnGatewayId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module DescribeSpotFleetInstancesRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; spot_fleet_request_id : String.t
    }

  let make ?dry_run ?max_results ?next_token ~spot_fleet_request_id () =
    { dry_run; max_results; next_token; spot_fleet_request_id }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "maxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; spot_fleet_request_id =
          Aws.Xml.required
            "spotFleetRequestId"
            (Aws.Util.option_bind (Aws.Xml.member "spotFleetRequestId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("SpotFleetRequestId", String.to_query v.spot_fleet_request_id))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("spotFleetRequestId", String.to_json v.spot_fleet_request_id)
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "maxResults", Integer.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "maxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; spot_fleet_request_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "spotFleetRequestId"))
    }
end

module AvailabilityZoneOptInStatus = struct
  type t =
    | Opt_in_not_required
    | Opted_in
    | Not_opted_in

  let str_to_t =
    [ "not-opted-in", Not_opted_in
    ; "opted-in", Opted_in
    ; "opt-in-not-required", Opt_in_not_required
    ]

  let t_to_str =
    [ Not_opted_in, "not-opted-in"
    ; Opted_in, "opted-in"
    ; Opt_in_not_required, "opt-in-not-required"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ClientVpnConnectionStatusCode = struct
  type t =
    | Active
    | Failed_to_terminate
    | Terminating
    | Terminated

  let str_to_t =
    [ "terminated", Terminated
    ; "terminating", Terminating
    ; "failed-to-terminate", Failed_to_terminate
    ; "active", Active
    ]

  let t_to_str =
    [ Terminated, "terminated"
    ; Terminating, "terminating"
    ; Failed_to_terminate, "failed-to-terminate"
    ; Active, "active"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ClientVpnConnectionStatus = struct
  type t =
    { code : ClientVpnConnectionStatusCode.t option
    ; message : String.t option
    }

  let make ?code ?message () = { code; message }

  let parse xml =
    Some
      { code =
          Aws.Util.option_bind
            (Aws.Xml.member "code" xml)
            ClientVpnConnectionStatusCode.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair ("Code", ClientVpnConnectionStatusCode.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f)
         ; Aws.Util.option_map v.code (fun f ->
               "code", ClientVpnConnectionStatusCode.to_json f)
         ])

  let of_json j =
    { code =
        Aws.Util.option_map
          (Aws.Json.lookup j "code")
          ClientVpnConnectionStatusCode.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json
    }
end

module TerminateConnectionStatus = struct
  type t =
    { connection_id : String.t option
    ; previous_status : ClientVpnConnectionStatus.t option
    ; current_status : ClientVpnConnectionStatus.t option
    }

  let make ?connection_id ?previous_status ?current_status () =
    { connection_id; previous_status; current_status }

  let parse xml =
    Some
      { connection_id =
          Aws.Util.option_bind (Aws.Xml.member "connectionId" xml) String.parse
      ; previous_status =
          Aws.Util.option_bind
            (Aws.Xml.member "previousStatus" xml)
            ClientVpnConnectionStatus.parse
      ; current_status =
          Aws.Util.option_bind
            (Aws.Xml.member "currentStatus" xml)
            ClientVpnConnectionStatus.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.current_status (fun f ->
               Aws.Query.Pair ("CurrentStatus", ClientVpnConnectionStatus.to_query f))
         ; Aws.Util.option_map v.previous_status (fun f ->
               Aws.Query.Pair ("PreviousStatus", ClientVpnConnectionStatus.to_query f))
         ; Aws.Util.option_map v.connection_id (fun f ->
               Aws.Query.Pair ("ConnectionId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.current_status (fun f ->
               "currentStatus", ClientVpnConnectionStatus.to_json f)
         ; Aws.Util.option_map v.previous_status (fun f ->
               "previousStatus", ClientVpnConnectionStatus.to_json f)
         ; Aws.Util.option_map v.connection_id (fun f -> "connectionId", String.to_json f)
         ])

  let of_json j =
    { connection_id =
        Aws.Util.option_map (Aws.Json.lookup j "connectionId") String.of_json
    ; previous_status =
        Aws.Util.option_map
          (Aws.Json.lookup j "previousStatus")
          ClientVpnConnectionStatus.of_json
    ; current_status =
        Aws.Util.option_map
          (Aws.Json.lookup j "currentStatus")
          ClientVpnConnectionStatus.of_json
    }
end

module VpcEndpointIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module RejectVpcEndpointConnectionsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; service_id : String.t
    ; vpc_endpoint_ids : VpcEndpointIdList.t
    }

  let make ?dry_run ~service_id ~vpc_endpoint_ids () =
    { dry_run; service_id; vpc_endpoint_ids }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; service_id =
          Aws.Xml.required
            "ServiceId"
            (Aws.Util.option_bind (Aws.Xml.member "ServiceId" xml) String.parse)
      ; vpc_endpoint_ids =
          Aws.Xml.required
            "VpcEndpointId"
            (Aws.Util.option_bind
               (Aws.Xml.member "VpcEndpointId" xml)
               VpcEndpointIdList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("VpcEndpointId", VpcEndpointIdList.to_query v.vpc_endpoint_ids))
         ; Some (Aws.Query.Pair ("ServiceId", String.to_query v.service_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("VpcEndpointId", VpcEndpointIdList.to_json v.vpc_endpoint_ids)
         ; Some ("ServiceId", String.to_json v.service_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; service_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ServiceId"))
    ; vpc_endpoint_ids =
        VpcEndpointIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcEndpointId"))
    }
end

module GetConsoleScreenshotRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; instance_id : String.t
    ; wake_up : Boolean.t option
    }

  let make ?dry_run ~instance_id ?wake_up () = { dry_run; instance_id; wake_up }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; instance_id =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse)
      ; wake_up = Aws.Util.option_bind (Aws.Xml.member "WakeUp" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.wake_up (fun f ->
               Aws.Query.Pair ("WakeUp", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.wake_up (fun f -> "WakeUp", Boolean.to_json f)
         ; Some ("InstanceId", String.to_json v.instance_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; wake_up = Aws.Util.option_map (Aws.Json.lookup j "WakeUp") Boolean.of_json
    }
end

module TransitGatewayPropagationState = struct
  type t =
    | Enabling
    | Enabled
    | Disabling
    | Disabled

  let str_to_t =
    [ "disabled", Disabled
    ; "disabling", Disabling
    ; "enabled", Enabled
    ; "enabling", Enabling
    ]

  let t_to_str =
    [ Disabled, "disabled"
    ; Disabling, "disabling"
    ; Enabled, "enabled"
    ; Enabling, "enabling"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module TransitGatewayPropagation = struct
  type t =
    { transit_gateway_attachment_id : String.t option
    ; resource_id : String.t option
    ; resource_type : TransitGatewayAttachmentResourceType.t option
    ; transit_gateway_route_table_id : String.t option
    ; state : TransitGatewayPropagationState.t option
    }

  let make
      ?transit_gateway_attachment_id
      ?resource_id
      ?resource_type
      ?transit_gateway_route_table_id
      ?state
      () =
    { transit_gateway_attachment_id
    ; resource_id
    ; resource_type
    ; transit_gateway_route_table_id
    ; state
    }

  let parse xml =
    Some
      { transit_gateway_attachment_id =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayAttachmentId" xml)
            String.parse
      ; resource_id = Aws.Util.option_bind (Aws.Xml.member "resourceId" xml) String.parse
      ; resource_type =
          Aws.Util.option_bind
            (Aws.Xml.member "resourceType" xml)
            TransitGatewayAttachmentResourceType.parse
      ; transit_gateway_route_table_id =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayRouteTableId" xml)
            String.parse
      ; state =
          Aws.Util.option_bind
            (Aws.Xml.member "state" xml)
            TransitGatewayPropagationState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", TransitGatewayPropagationState.to_query f))
         ; Aws.Util.option_map v.transit_gateway_route_table_id (fun f ->
               Aws.Query.Pair ("TransitGatewayRouteTableId", String.to_query f))
         ; Aws.Util.option_map v.resource_type (fun f ->
               Aws.Query.Pair
                 ("ResourceType", TransitGatewayAttachmentResourceType.to_query f))
         ; Aws.Util.option_map v.resource_id (fun f ->
               Aws.Query.Pair ("ResourceId", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               Aws.Query.Pair ("TransitGatewayAttachmentId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               "state", TransitGatewayPropagationState.to_json f)
         ; Aws.Util.option_map v.transit_gateway_route_table_id (fun f ->
               "transitGatewayRouteTableId", String.to_json f)
         ; Aws.Util.option_map v.resource_type (fun f ->
               "resourceType", TransitGatewayAttachmentResourceType.to_json f)
         ; Aws.Util.option_map v.resource_id (fun f -> "resourceId", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               "transitGatewayAttachmentId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_attachment_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayAttachmentId")
          String.of_json
    ; resource_id = Aws.Util.option_map (Aws.Json.lookup j "resourceId") String.of_json
    ; resource_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "resourceType")
          TransitGatewayAttachmentResourceType.of_json
    ; transit_gateway_route_table_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayRouteTableId")
          String.of_json
    ; state =
        Aws.Util.option_map
          (Aws.Json.lookup j "state")
          TransitGatewayPropagationState.of_json
    }
end

module EnableTransitGatewayRouteTablePropagationResult = struct
  type t = { propagation : TransitGatewayPropagation.t option }

  let make ?propagation () = { propagation }

  let parse xml =
    Some
      { propagation =
          Aws.Util.option_bind
            (Aws.Xml.member "propagation" xml)
            TransitGatewayPropagation.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.propagation (fun f ->
               Aws.Query.Pair ("Propagation", TransitGatewayPropagation.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.propagation (fun f ->
               "propagation", TransitGatewayPropagation.to_json f)
         ])

  let of_json j =
    { propagation =
        Aws.Util.option_map
          (Aws.Json.lookup j "propagation")
          TransitGatewayPropagation.of_json
    }
end

module InstanceIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "InstanceId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeInstanceCreditSpecificationsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; filters : FilterList.t
    ; instance_ids : InstanceIdStringList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?dry_run ?(filters = []) ?(instance_ids = []) ?max_results ?next_token () =
    { dry_run; filters; instance_ids; max_results; next_token }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; instance_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "InstanceId" xml)
               InstanceIdStringList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair ("InstanceId", InstanceIdStringList.to_query v.instance_ids))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("InstanceId", InstanceIdStringList.to_json v.instance_ids)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; instance_ids =
        InstanceIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module AcceptTransitGatewayVpcAttachmentRequest = struct
  type t =
    { transit_gateway_attachment_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~transit_gateway_attachment_id ?dry_run () =
    { transit_gateway_attachment_id; dry_run }

  let parse xml =
    Some
      { transit_gateway_attachment_id =
          Aws.Xml.required
            "TransitGatewayAttachmentId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayAttachmentId" xml)
               String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayAttachmentId"
                , String.to_query v.transit_gateway_attachment_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ("TransitGatewayAttachmentId", String.to_json v.transit_gateway_attachment_id)
         ])

  let of_json j =
    { transit_gateway_attachment_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayAttachmentId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module AssociationStatusCode = struct
  type t =
    | Associating
    | Associated
    | Association_failed
    | Disassociating
    | Disassociated

  let str_to_t =
    [ "disassociated", Disassociated
    ; "disassociating", Disassociating
    ; "association-failed", Association_failed
    ; "associated", Associated
    ; "associating", Associating
    ]

  let t_to_str =
    [ Disassociated, "disassociated"
    ; Disassociating, "disassociating"
    ; Association_failed, "association-failed"
    ; Associated, "associated"
    ; Associating, "associating"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module AssociationStatus = struct
  type t =
    { code : AssociationStatusCode.t option
    ; message : String.t option
    }

  let make ?code ?message () = { code; message }

  let parse xml =
    Some
      { code =
          Aws.Util.option_bind (Aws.Xml.member "code" xml) AssociationStatusCode.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair ("Code", AssociationStatusCode.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f)
         ; Aws.Util.option_map v.code (fun f -> "code", AssociationStatusCode.to_json f)
         ])

  let of_json j =
    { code = Aws.Util.option_map (Aws.Json.lookup j "code") AssociationStatusCode.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json
    }
end

module TargetNetwork = struct
  type t =
    { association_id : String.t option
    ; vpc_id : String.t option
    ; target_network_id : String.t option
    ; client_vpn_endpoint_id : String.t option
    ; status : AssociationStatus.t option
    ; security_groups : ValueStringList.t
    }

  let make
      ?association_id
      ?vpc_id
      ?target_network_id
      ?client_vpn_endpoint_id
      ?status
      ?(security_groups = [])
      () =
    { association_id
    ; vpc_id
    ; target_network_id
    ; client_vpn_endpoint_id
    ; status
    ; security_groups
    }

  let parse xml =
    Some
      { association_id =
          Aws.Util.option_bind (Aws.Xml.member "associationId" xml) String.parse
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse
      ; target_network_id =
          Aws.Util.option_bind (Aws.Xml.member "targetNetworkId" xml) String.parse
      ; client_vpn_endpoint_id =
          Aws.Util.option_bind (Aws.Xml.member "clientVpnEndpointId" xml) String.parse
      ; status =
          Aws.Util.option_bind (Aws.Xml.member "status" xml) AssociationStatus.parse
      ; security_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "securityGroups" xml)
               ValueStringList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("SecurityGroups", ValueStringList.to_query v.security_groups))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", AssociationStatus.to_query f))
         ; Aws.Util.option_map v.client_vpn_endpoint_id (fun f ->
               Aws.Query.Pair ("ClientVpnEndpointId", String.to_query f))
         ; Aws.Util.option_map v.target_network_id (fun f ->
               Aws.Query.Pair ("TargetNetworkId", String.to_query f))
         ; Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Aws.Util.option_map v.association_id (fun f ->
               Aws.Query.Pair ("AssociationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("securityGroups", ValueStringList.to_json v.security_groups)
         ; Aws.Util.option_map v.status (fun f -> "status", AssociationStatus.to_json f)
         ; Aws.Util.option_map v.client_vpn_endpoint_id (fun f ->
               "clientVpnEndpointId", String.to_json f)
         ; Aws.Util.option_map v.target_network_id (fun f ->
               "targetNetworkId", String.to_json f)
         ; Aws.Util.option_map v.vpc_id (fun f -> "vpcId", String.to_json f)
         ; Aws.Util.option_map v.association_id (fun f ->
               "associationId", String.to_json f)
         ])

  let of_json j =
    { association_id =
        Aws.Util.option_map (Aws.Json.lookup j "associationId") String.of_json
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "vpcId") String.of_json
    ; target_network_id =
        Aws.Util.option_map (Aws.Json.lookup j "targetNetworkId") String.of_json
    ; client_vpn_endpoint_id =
        Aws.Util.option_map (Aws.Json.lookup j "clientVpnEndpointId") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "status") AssociationStatus.of_json
    ; security_groups =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "securityGroups"))
    }
end

module ExportTaskState = struct
  type t =
    | Active
    | Cancelling
    | Cancelled
    | Completed

  let str_to_t =
    [ "completed", Completed
    ; "cancelled", Cancelled
    ; "cancelling", Cancelling
    ; "active", Active
    ]

  let t_to_str =
    [ Completed, "completed"
    ; Cancelled, "cancelled"
    ; Cancelling, "cancelling"
    ; Active, "active"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ConnectionLogResponseOptions = struct
  type t =
    { enabled : Boolean.t option
    ; cloudwatch_log_group : String.t option
    ; cloudwatch_log_stream : String.t option
    }

  let make ?enabled ?cloudwatch_log_group ?cloudwatch_log_stream () =
    { enabled; cloudwatch_log_group; cloudwatch_log_stream }

  let parse xml =
    Some
      { enabled = Aws.Util.option_bind (Aws.Xml.member "Enabled" xml) Boolean.parse
      ; cloudwatch_log_group =
          Aws.Util.option_bind (Aws.Xml.member "CloudwatchLogGroup" xml) String.parse
      ; cloudwatch_log_stream =
          Aws.Util.option_bind (Aws.Xml.member "CloudwatchLogStream" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cloudwatch_log_stream (fun f ->
               Aws.Query.Pair ("CloudwatchLogStream", String.to_query f))
         ; Aws.Util.option_map v.cloudwatch_log_group (fun f ->
               Aws.Query.Pair ("CloudwatchLogGroup", String.to_query f))
         ; Aws.Util.option_map v.enabled (fun f ->
               Aws.Query.Pair ("Enabled", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cloudwatch_log_stream (fun f ->
               "CloudwatchLogStream", String.to_json f)
         ; Aws.Util.option_map v.cloudwatch_log_group (fun f ->
               "CloudwatchLogGroup", String.to_json f)
         ; Aws.Util.option_map v.enabled (fun f -> "Enabled", Boolean.to_json f)
         ])

  let of_json j =
    { enabled = Aws.Util.option_map (Aws.Json.lookup j "Enabled") Boolean.of_json
    ; cloudwatch_log_group =
        Aws.Util.option_map (Aws.Json.lookup j "CloudwatchLogGroup") String.of_json
    ; cloudwatch_log_stream =
        Aws.Util.option_map (Aws.Json.lookup j "CloudwatchLogStream") String.of_json
    }
end

module ModifyVpcEndpointServiceConfigurationRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; service_id : String.t
    ; private_dns_name : String.t option
    ; remove_private_dns_name : Boolean.t option
    ; acceptance_required : Boolean.t option
    ; add_network_load_balancer_arns : ValueStringList.t
    ; remove_network_load_balancer_arns : ValueStringList.t
    ; add_gateway_load_balancer_arns : ValueStringList.t
    ; remove_gateway_load_balancer_arns : ValueStringList.t
    }

  let make
      ?dry_run
      ~service_id
      ?private_dns_name
      ?remove_private_dns_name
      ?acceptance_required
      ?(add_network_load_balancer_arns = [])
      ?(remove_network_load_balancer_arns = [])
      ?(add_gateway_load_balancer_arns = [])
      ?(remove_gateway_load_balancer_arns = [])
      () =
    { dry_run
    ; service_id
    ; private_dns_name
    ; remove_private_dns_name
    ; acceptance_required
    ; add_network_load_balancer_arns
    ; remove_network_load_balancer_arns
    ; add_gateway_load_balancer_arns
    ; remove_gateway_load_balancer_arns
    }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; service_id =
          Aws.Xml.required
            "ServiceId"
            (Aws.Util.option_bind (Aws.Xml.member "ServiceId" xml) String.parse)
      ; private_dns_name =
          Aws.Util.option_bind (Aws.Xml.member "PrivateDnsName" xml) String.parse
      ; remove_private_dns_name =
          Aws.Util.option_bind (Aws.Xml.member "RemovePrivateDnsName" xml) Boolean.parse
      ; acceptance_required =
          Aws.Util.option_bind (Aws.Xml.member "AcceptanceRequired" xml) Boolean.parse
      ; add_network_load_balancer_arns =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AddNetworkLoadBalancerArn" xml)
               ValueStringList.parse)
      ; remove_network_load_balancer_arns =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "RemoveNetworkLoadBalancerArn" xml)
               ValueStringList.parse)
      ; add_gateway_load_balancer_arns =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AddGatewayLoadBalancerArn" xml)
               ValueStringList.parse)
      ; remove_gateway_load_balancer_arns =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "RemoveGatewayLoadBalancerArn" xml)
               ValueStringList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "RemoveGatewayLoadBalancerArn"
                , ValueStringList.to_query v.remove_gateway_load_balancer_arns ))
         ; Some
             (Aws.Query.Pair
                ( "AddGatewayLoadBalancerArn"
                , ValueStringList.to_query v.add_gateway_load_balancer_arns ))
         ; Some
             (Aws.Query.Pair
                ( "RemoveNetworkLoadBalancerArn"
                , ValueStringList.to_query v.remove_network_load_balancer_arns ))
         ; Some
             (Aws.Query.Pair
                ( "AddNetworkLoadBalancerArn"
                , ValueStringList.to_query v.add_network_load_balancer_arns ))
         ; Aws.Util.option_map v.acceptance_required (fun f ->
               Aws.Query.Pair ("AcceptanceRequired", Boolean.to_query f))
         ; Aws.Util.option_map v.remove_private_dns_name (fun f ->
               Aws.Query.Pair ("RemovePrivateDnsName", Boolean.to_query f))
         ; Aws.Util.option_map v.private_dns_name (fun f ->
               Aws.Query.Pair ("PrivateDnsName", String.to_query f))
         ; Some (Aws.Query.Pair ("ServiceId", String.to_query v.service_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "RemoveGatewayLoadBalancerArn"
             , ValueStringList.to_json v.remove_gateway_load_balancer_arns )
         ; Some
             ( "AddGatewayLoadBalancerArn"
             , ValueStringList.to_json v.add_gateway_load_balancer_arns )
         ; Some
             ( "RemoveNetworkLoadBalancerArn"
             , ValueStringList.to_json v.remove_network_load_balancer_arns )
         ; Some
             ( "AddNetworkLoadBalancerArn"
             , ValueStringList.to_json v.add_network_load_balancer_arns )
         ; Aws.Util.option_map v.acceptance_required (fun f ->
               "AcceptanceRequired", Boolean.to_json f)
         ; Aws.Util.option_map v.remove_private_dns_name (fun f ->
               "RemovePrivateDnsName", Boolean.to_json f)
         ; Aws.Util.option_map v.private_dns_name (fun f ->
               "PrivateDnsName", String.to_json f)
         ; Some ("ServiceId", String.to_json v.service_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; service_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ServiceId"))
    ; private_dns_name =
        Aws.Util.option_map (Aws.Json.lookup j "PrivateDnsName") String.of_json
    ; remove_private_dns_name =
        Aws.Util.option_map (Aws.Json.lookup j "RemovePrivateDnsName") Boolean.of_json
    ; acceptance_required =
        Aws.Util.option_map (Aws.Json.lookup j "AcceptanceRequired") Boolean.of_json
    ; add_network_load_balancer_arns =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AddNetworkLoadBalancerArn"))
    ; remove_network_load_balancer_arns =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "RemoveNetworkLoadBalancerArn"))
    ; add_gateway_load_balancer_arns =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AddGatewayLoadBalancerArn"))
    ; remove_gateway_load_balancer_arns =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "RemoveGatewayLoadBalancerArn"))
    }
end

module TagSpecification = struct
  type t =
    { resource_type : ResourceType.t option
    ; tags : TagList.t
    }

  let make ?resource_type ?(tags = []) () = { resource_type; tags }

  let parse xml =
    Some
      { resource_type =
          Aws.Util.option_bind (Aws.Xml.member "resourceType" xml) ResourceType.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tag" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tag", TagList.to_query v.tags))
         ; Aws.Util.option_map v.resource_type (fun f ->
               Aws.Query.Pair ("ResourceType", ResourceType.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tag", TagList.to_json v.tags)
         ; Aws.Util.option_map v.resource_type (fun f ->
               "resourceType", ResourceType.to_json f)
         ])

  let of_json j =
    { resource_type =
        Aws.Util.option_map (Aws.Json.lookup j "resourceType") ResourceType.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tag"))
    }
end

module TagSpecificationList = struct
  type t = TagSpecification.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map TagSpecification.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list TagSpecification.to_query v

  let to_json v = `List (List.map TagSpecification.to_json v)

  let of_json j = Aws.Json.to_list TagSpecification.of_json j
end

module ImportImageLicenseConfigurationRequest = struct
  type t = { license_configuration_arn : String.t option }

  let make ?license_configuration_arn () = { license_configuration_arn }

  let parse xml =
    Some
      { license_configuration_arn =
          Aws.Util.option_bind (Aws.Xml.member "LicenseConfigurationArn" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.license_configuration_arn (fun f ->
               Aws.Query.Pair ("LicenseConfigurationArn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.license_configuration_arn (fun f ->
               "LicenseConfigurationArn", String.to_json f)
         ])

  let of_json j =
    { license_configuration_arn =
        Aws.Util.option_map (Aws.Json.lookup j "LicenseConfigurationArn") String.of_json
    }
end

module ImportImageLicenseSpecificationListRequest = struct
  type t = ImportImageLicenseConfigurationRequest.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ImportImageLicenseConfigurationRequest.parse (Aws.Xml.members "item" xml))

  let to_query v =
    Aws.Query.to_query_list ImportImageLicenseConfigurationRequest.to_query v

  let to_json v = `List (List.map ImportImageLicenseConfigurationRequest.to_json v)

  let of_json j = Aws.Json.to_list ImportImageLicenseConfigurationRequest.of_json j
end

module UserBucket = struct
  type t =
    { s3_bucket : String.t option
    ; s3_key : String.t option
    }

  let make ?s3_bucket ?s3_key () = { s3_bucket; s3_key }

  let parse xml =
    Some
      { s3_bucket = Aws.Util.option_bind (Aws.Xml.member "S3Bucket" xml) String.parse
      ; s3_key = Aws.Util.option_bind (Aws.Xml.member "S3Key" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.s3_key (fun f ->
               Aws.Query.Pair ("S3Key", String.to_query f))
         ; Aws.Util.option_map v.s3_bucket (fun f ->
               Aws.Query.Pair ("S3Bucket", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.s3_key (fun f -> "S3Key", String.to_json f)
         ; Aws.Util.option_map v.s3_bucket (fun f -> "S3Bucket", String.to_json f)
         ])

  let of_json j =
    { s3_bucket = Aws.Util.option_map (Aws.Json.lookup j "S3Bucket") String.of_json
    ; s3_key = Aws.Util.option_map (Aws.Json.lookup j "S3Key") String.of_json
    }
end

module ImageDiskContainer = struct
  type t =
    { description : String.t option
    ; device_name : String.t option
    ; format : String.t option
    ; snapshot_id : String.t option
    ; url : String.t option
    ; user_bucket : UserBucket.t option
    }

  let make ?description ?device_name ?format ?snapshot_id ?url ?user_bucket () =
    { description; device_name; format; snapshot_id; url; user_bucket }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; device_name = Aws.Util.option_bind (Aws.Xml.member "DeviceName" xml) String.parse
      ; format = Aws.Util.option_bind (Aws.Xml.member "Format" xml) String.parse
      ; snapshot_id = Aws.Util.option_bind (Aws.Xml.member "SnapshotId" xml) String.parse
      ; url = Aws.Util.option_bind (Aws.Xml.member "Url" xml) String.parse
      ; user_bucket =
          Aws.Util.option_bind (Aws.Xml.member "UserBucket" xml) UserBucket.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.user_bucket (fun f ->
               Aws.Query.Pair ("UserBucket", UserBucket.to_query f))
         ; Aws.Util.option_map v.url (fun f -> Aws.Query.Pair ("Url", String.to_query f))
         ; Aws.Util.option_map v.snapshot_id (fun f ->
               Aws.Query.Pair ("SnapshotId", String.to_query f))
         ; Aws.Util.option_map v.format (fun f ->
               Aws.Query.Pair ("Format", String.to_query f))
         ; Aws.Util.option_map v.device_name (fun f ->
               Aws.Query.Pair ("DeviceName", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.user_bucket (fun f -> "UserBucket", UserBucket.to_json f)
         ; Aws.Util.option_map v.url (fun f -> "Url", String.to_json f)
         ; Aws.Util.option_map v.snapshot_id (fun f -> "SnapshotId", String.to_json f)
         ; Aws.Util.option_map v.format (fun f -> "Format", String.to_json f)
         ; Aws.Util.option_map v.device_name (fun f -> "DeviceName", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; device_name = Aws.Util.option_map (Aws.Json.lookup j "DeviceName") String.of_json
    ; format = Aws.Util.option_map (Aws.Json.lookup j "Format") String.of_json
    ; snapshot_id = Aws.Util.option_map (Aws.Json.lookup j "SnapshotId") String.of_json
    ; url = Aws.Util.option_map (Aws.Json.lookup j "Url") String.of_json
    ; user_bucket =
        Aws.Util.option_map (Aws.Json.lookup j "UserBucket") UserBucket.of_json
    }
end

module ImageDiskContainerList = struct
  type t = ImageDiskContainer.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ImageDiskContainer.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ImageDiskContainer.to_query v

  let to_json v = `List (List.map ImageDiskContainer.to_json v)

  let of_json j = Aws.Json.to_list ImageDiskContainer.of_json j
end

module ClientData = struct
  type t =
    { comment : String.t option
    ; upload_end : DateTime.t option
    ; upload_size : Double.t option
    ; upload_start : DateTime.t option
    }

  let make ?comment ?upload_end ?upload_size ?upload_start () =
    { comment; upload_end; upload_size; upload_start }

  let parse xml =
    Some
      { comment = Aws.Util.option_bind (Aws.Xml.member "Comment" xml) String.parse
      ; upload_end = Aws.Util.option_bind (Aws.Xml.member "UploadEnd" xml) DateTime.parse
      ; upload_size = Aws.Util.option_bind (Aws.Xml.member "UploadSize" xml) Double.parse
      ; upload_start =
          Aws.Util.option_bind (Aws.Xml.member "UploadStart" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.upload_start (fun f ->
               Aws.Query.Pair ("UploadStart", DateTime.to_query f))
         ; Aws.Util.option_map v.upload_size (fun f ->
               Aws.Query.Pair ("UploadSize", Double.to_query f))
         ; Aws.Util.option_map v.upload_end (fun f ->
               Aws.Query.Pair ("UploadEnd", DateTime.to_query f))
         ; Aws.Util.option_map v.comment (fun f ->
               Aws.Query.Pair ("Comment", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.upload_start (fun f -> "UploadStart", DateTime.to_json f)
         ; Aws.Util.option_map v.upload_size (fun f -> "UploadSize", Double.to_json f)
         ; Aws.Util.option_map v.upload_end (fun f -> "UploadEnd", DateTime.to_json f)
         ; Aws.Util.option_map v.comment (fun f -> "Comment", String.to_json f)
         ])

  let of_json j =
    { comment = Aws.Util.option_map (Aws.Json.lookup j "Comment") String.of_json
    ; upload_end = Aws.Util.option_map (Aws.Json.lookup j "UploadEnd") DateTime.of_json
    ; upload_size = Aws.Util.option_map (Aws.Json.lookup j "UploadSize") Double.of_json
    ; upload_start =
        Aws.Util.option_map (Aws.Json.lookup j "UploadStart") DateTime.of_json
    }
end

module ImportImageRequest = struct
  type t =
    { architecture : String.t option
    ; client_data : ClientData.t option
    ; client_token : String.t option
    ; description : String.t option
    ; disk_containers : ImageDiskContainerList.t
    ; dry_run : Boolean.t option
    ; encrypted : Boolean.t option
    ; hypervisor : String.t option
    ; kms_key_id : String.t option
    ; license_type : String.t option
    ; platform : String.t option
    ; role_name : String.t option
    ; license_specifications : ImportImageLicenseSpecificationListRequest.t
    ; tag_specifications : TagSpecificationList.t
    }

  let make
      ?architecture
      ?client_data
      ?client_token
      ?description
      ?(disk_containers = [])
      ?dry_run
      ?encrypted
      ?hypervisor
      ?kms_key_id
      ?license_type
      ?platform
      ?role_name
      ?(license_specifications = [])
      ?(tag_specifications = [])
      () =
    { architecture
    ; client_data
    ; client_token
    ; description
    ; disk_containers
    ; dry_run
    ; encrypted
    ; hypervisor
    ; kms_key_id
    ; license_type
    ; platform
    ; role_name
    ; license_specifications
    ; tag_specifications
    }

  let parse xml =
    Some
      { architecture =
          Aws.Util.option_bind (Aws.Xml.member "Architecture" xml) String.parse
      ; client_data =
          Aws.Util.option_bind (Aws.Xml.member "ClientData" xml) ClientData.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; disk_containers =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DiskContainer" xml)
               ImageDiskContainerList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; encrypted = Aws.Util.option_bind (Aws.Xml.member "Encrypted" xml) Boolean.parse
      ; hypervisor = Aws.Util.option_bind (Aws.Xml.member "Hypervisor" xml) String.parse
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "KmsKeyId" xml) String.parse
      ; license_type =
          Aws.Util.option_bind (Aws.Xml.member "LicenseType" xml) String.parse
      ; platform = Aws.Util.option_bind (Aws.Xml.member "Platform" xml) String.parse
      ; role_name = Aws.Util.option_bind (Aws.Xml.member "RoleName" xml) String.parse
      ; license_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "LicenseSpecifications" xml)
               ImportImageLicenseSpecificationListRequest.parse)
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Some
             (Aws.Query.Pair
                ( "LicenseSpecifications"
                , ImportImageLicenseSpecificationListRequest.to_query
                    v.license_specifications ))
         ; Aws.Util.option_map v.role_name (fun f ->
               Aws.Query.Pair ("RoleName", String.to_query f))
         ; Aws.Util.option_map v.platform (fun f ->
               Aws.Query.Pair ("Platform", String.to_query f))
         ; Aws.Util.option_map v.license_type (fun f ->
               Aws.Query.Pair ("LicenseType", String.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Aws.Util.option_map v.hypervisor (fun f ->
               Aws.Query.Pair ("Hypervisor", String.to_query f))
         ; Aws.Util.option_map v.encrypted (fun f ->
               Aws.Query.Pair ("Encrypted", Boolean.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DiskContainer", ImageDiskContainerList.to_query v.disk_containers))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.client_data (fun f ->
               Aws.Query.Pair ("ClientData", ClientData.to_query f))
         ; Aws.Util.option_map v.architecture (fun f ->
               Aws.Query.Pair ("Architecture", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Some
             ( "LicenseSpecifications"
             , ImportImageLicenseSpecificationListRequest.to_json v.license_specifications
             )
         ; Aws.Util.option_map v.role_name (fun f -> "RoleName", String.to_json f)
         ; Aws.Util.option_map v.platform (fun f -> "Platform", String.to_json f)
         ; Aws.Util.option_map v.license_type (fun f -> "LicenseType", String.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "KmsKeyId", String.to_json f)
         ; Aws.Util.option_map v.hypervisor (fun f -> "Hypervisor", String.to_json f)
         ; Aws.Util.option_map v.encrypted (fun f -> "Encrypted", Boolean.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("DiskContainer", ImageDiskContainerList.to_json v.disk_containers)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Aws.Util.option_map v.client_data (fun f -> "ClientData", ClientData.to_json f)
         ; Aws.Util.option_map v.architecture (fun f -> "Architecture", String.to_json f)
         ])

  let of_json j =
    { architecture = Aws.Util.option_map (Aws.Json.lookup j "Architecture") String.of_json
    ; client_data =
        Aws.Util.option_map (Aws.Json.lookup j "ClientData") ClientData.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; disk_containers =
        ImageDiskContainerList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DiskContainer"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; encrypted = Aws.Util.option_map (Aws.Json.lookup j "Encrypted") Boolean.of_json
    ; hypervisor = Aws.Util.option_map (Aws.Json.lookup j "Hypervisor") String.of_json
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "KmsKeyId") String.of_json
    ; license_type = Aws.Util.option_map (Aws.Json.lookup j "LicenseType") String.of_json
    ; platform = Aws.Util.option_map (Aws.Json.lookup j "Platform") String.of_json
    ; role_name = Aws.Util.option_map (Aws.Json.lookup j "RoleName") String.of_json
    ; license_specifications =
        ImportImageLicenseSpecificationListRequest.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "LicenseSpecifications"))
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    }
end

module TransitGatewayAttachmentAssociation = struct
  type t =
    { transit_gateway_route_table_id : String.t option
    ; state : TransitGatewayAssociationState.t option
    }

  let make ?transit_gateway_route_table_id ?state () =
    { transit_gateway_route_table_id; state }

  let parse xml =
    Some
      { transit_gateway_route_table_id =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayRouteTableId" xml)
            String.parse
      ; state =
          Aws.Util.option_bind
            (Aws.Xml.member "state" xml)
            TransitGatewayAssociationState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", TransitGatewayAssociationState.to_query f))
         ; Aws.Util.option_map v.transit_gateway_route_table_id (fun f ->
               Aws.Query.Pair ("TransitGatewayRouteTableId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               "state", TransitGatewayAssociationState.to_json f)
         ; Aws.Util.option_map v.transit_gateway_route_table_id (fun f ->
               "transitGatewayRouteTableId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_route_table_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayRouteTableId")
          String.of_json
    ; state =
        Aws.Util.option_map
          (Aws.Json.lookup j "state")
          TransitGatewayAssociationState.of_json
    }
end

module TransitGatewayAttachment = struct
  type t =
    { transit_gateway_attachment_id : String.t option
    ; transit_gateway_id : String.t option
    ; transit_gateway_owner_id : String.t option
    ; resource_owner_id : String.t option
    ; resource_type : TransitGatewayAttachmentResourceType.t option
    ; resource_id : String.t option
    ; state : TransitGatewayAttachmentState.t option
    ; association : TransitGatewayAttachmentAssociation.t option
    ; creation_time : DateTime.t option
    ; tags : TagList.t
    }

  let make
      ?transit_gateway_attachment_id
      ?transit_gateway_id
      ?transit_gateway_owner_id
      ?resource_owner_id
      ?resource_type
      ?resource_id
      ?state
      ?association
      ?creation_time
      ?(tags = [])
      () =
    { transit_gateway_attachment_id
    ; transit_gateway_id
    ; transit_gateway_owner_id
    ; resource_owner_id
    ; resource_type
    ; resource_id
    ; state
    ; association
    ; creation_time
    ; tags
    }

  let parse xml =
    Some
      { transit_gateway_attachment_id =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayAttachmentId" xml)
            String.parse
      ; transit_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "transitGatewayId" xml) String.parse
      ; transit_gateway_owner_id =
          Aws.Util.option_bind (Aws.Xml.member "transitGatewayOwnerId" xml) String.parse
      ; resource_owner_id =
          Aws.Util.option_bind (Aws.Xml.member "resourceOwnerId" xml) String.parse
      ; resource_type =
          Aws.Util.option_bind
            (Aws.Xml.member "resourceType" xml)
            TransitGatewayAttachmentResourceType.parse
      ; resource_id = Aws.Util.option_bind (Aws.Xml.member "resourceId" xml) String.parse
      ; state =
          Aws.Util.option_bind
            (Aws.Xml.member "state" xml)
            TransitGatewayAttachmentState.parse
      ; association =
          Aws.Util.option_bind
            (Aws.Xml.member "association" xml)
            TransitGatewayAttachmentAssociation.parse
      ; creation_time =
          Aws.Util.option_bind (Aws.Xml.member "creationTime" xml) DateTime.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.creation_time (fun f ->
               Aws.Query.Pair ("CreationTime", DateTime.to_query f))
         ; Aws.Util.option_map v.association (fun f ->
               Aws.Query.Pair
                 ("Association", TransitGatewayAttachmentAssociation.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", TransitGatewayAttachmentState.to_query f))
         ; Aws.Util.option_map v.resource_id (fun f ->
               Aws.Query.Pair ("ResourceId", String.to_query f))
         ; Aws.Util.option_map v.resource_type (fun f ->
               Aws.Query.Pair
                 ("ResourceType", TransitGatewayAttachmentResourceType.to_query f))
         ; Aws.Util.option_map v.resource_owner_id (fun f ->
               Aws.Query.Pair ("ResourceOwnerId", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_owner_id (fun f ->
               Aws.Query.Pair ("TransitGatewayOwnerId", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_id (fun f ->
               Aws.Query.Pair ("TransitGatewayId", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               Aws.Query.Pair ("TransitGatewayAttachmentId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.creation_time (fun f ->
               "creationTime", DateTime.to_json f)
         ; Aws.Util.option_map v.association (fun f ->
               "association", TransitGatewayAttachmentAssociation.to_json f)
         ; Aws.Util.option_map v.state (fun f ->
               "state", TransitGatewayAttachmentState.to_json f)
         ; Aws.Util.option_map v.resource_id (fun f -> "resourceId", String.to_json f)
         ; Aws.Util.option_map v.resource_type (fun f ->
               "resourceType", TransitGatewayAttachmentResourceType.to_json f)
         ; Aws.Util.option_map v.resource_owner_id (fun f ->
               "resourceOwnerId", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_owner_id (fun f ->
               "transitGatewayOwnerId", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_id (fun f ->
               "transitGatewayId", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               "transitGatewayAttachmentId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_attachment_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayAttachmentId")
          String.of_json
    ; transit_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "transitGatewayId") String.of_json
    ; transit_gateway_owner_id =
        Aws.Util.option_map (Aws.Json.lookup j "transitGatewayOwnerId") String.of_json
    ; resource_owner_id =
        Aws.Util.option_map (Aws.Json.lookup j "resourceOwnerId") String.of_json
    ; resource_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "resourceType")
          TransitGatewayAttachmentResourceType.of_json
    ; resource_id = Aws.Util.option_map (Aws.Json.lookup j "resourceId") String.of_json
    ; state =
        Aws.Util.option_map
          (Aws.Json.lookup j "state")
          TransitGatewayAttachmentState.of_json
    ; association =
        Aws.Util.option_map
          (Aws.Json.lookup j "association")
          TransitGatewayAttachmentAssociation.of_json
    ; creation_time =
        Aws.Util.option_map (Aws.Json.lookup j "creationTime") DateTime.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module TransitGatewayAttachmentList = struct
  type t = TransitGatewayAttachment.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map TransitGatewayAttachment.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list TransitGatewayAttachment.to_query v

  let to_json v = `List (List.map TransitGatewayAttachment.to_json v)

  let of_json j = Aws.Json.to_list TransitGatewayAttachment.of_json j
end

module SlotDateTimeRangeRequest = struct
  type t =
    { earliest_time : DateTime.t
    ; latest_time : DateTime.t
    }

  let make ~earliest_time ~latest_time () = { earliest_time; latest_time }

  let parse xml =
    Some
      { earliest_time =
          Aws.Xml.required
            "EarliestTime"
            (Aws.Util.option_bind (Aws.Xml.member "EarliestTime" xml) DateTime.parse)
      ; latest_time =
          Aws.Xml.required
            "LatestTime"
            (Aws.Util.option_bind (Aws.Xml.member "LatestTime" xml) DateTime.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("LatestTime", DateTime.to_query v.latest_time))
         ; Some (Aws.Query.Pair ("EarliestTime", DateTime.to_query v.earliest_time))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("LatestTime", DateTime.to_json v.latest_time)
         ; Some ("EarliestTime", DateTime.to_json v.earliest_time)
         ])

  let of_json j =
    { earliest_time =
        DateTime.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "EarliestTime"))
    ; latest_time =
        DateTime.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "LatestTime"))
    }
end

module OccurrenceDayRequestSet = struct
  type t = Integer.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Integer.parse (Aws.Xml.members "OccurenceDay" xml))

  let to_query v = Aws.Query.to_query_list Integer.to_query v

  let to_json v = `List (List.map Integer.to_json v)

  let of_json j = Aws.Json.to_list Integer.of_json j
end

module ScheduledInstanceRecurrenceRequest = struct
  type t =
    { frequency : String.t option
    ; interval : Integer.t option
    ; occurrence_days : OccurrenceDayRequestSet.t
    ; occurrence_relative_to_end : Boolean.t option
    ; occurrence_unit : String.t option
    }

  let make
      ?frequency
      ?interval
      ?(occurrence_days = [])
      ?occurrence_relative_to_end
      ?occurrence_unit
      () =
    { frequency; interval; occurrence_days; occurrence_relative_to_end; occurrence_unit }

  let parse xml =
    Some
      { frequency = Aws.Util.option_bind (Aws.Xml.member "Frequency" xml) String.parse
      ; interval = Aws.Util.option_bind (Aws.Xml.member "Interval" xml) Integer.parse
      ; occurrence_days =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "OccurrenceDay" xml)
               OccurrenceDayRequestSet.parse)
      ; occurrence_relative_to_end =
          Aws.Util.option_bind
            (Aws.Xml.member "OccurrenceRelativeToEnd" xml)
            Boolean.parse
      ; occurrence_unit =
          Aws.Util.option_bind (Aws.Xml.member "OccurrenceUnit" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.occurrence_unit (fun f ->
               Aws.Query.Pair ("OccurrenceUnit", String.to_query f))
         ; Aws.Util.option_map v.occurrence_relative_to_end (fun f ->
               Aws.Query.Pair ("OccurrenceRelativeToEnd", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("OccurrenceDay", OccurrenceDayRequestSet.to_query v.occurrence_days))
         ; Aws.Util.option_map v.interval (fun f ->
               Aws.Query.Pair ("Interval", Integer.to_query f))
         ; Aws.Util.option_map v.frequency (fun f ->
               Aws.Query.Pair ("Frequency", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.occurrence_unit (fun f ->
               "OccurrenceUnit", String.to_json f)
         ; Aws.Util.option_map v.occurrence_relative_to_end (fun f ->
               "OccurrenceRelativeToEnd", Boolean.to_json f)
         ; Some ("OccurrenceDay", OccurrenceDayRequestSet.to_json v.occurrence_days)
         ; Aws.Util.option_map v.interval (fun f -> "Interval", Integer.to_json f)
         ; Aws.Util.option_map v.frequency (fun f -> "Frequency", String.to_json f)
         ])

  let of_json j =
    { frequency = Aws.Util.option_map (Aws.Json.lookup j "Frequency") String.of_json
    ; interval = Aws.Util.option_map (Aws.Json.lookup j "Interval") Integer.of_json
    ; occurrence_days =
        OccurrenceDayRequestSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "OccurrenceDay"))
    ; occurrence_relative_to_end =
        Aws.Util.option_map (Aws.Json.lookup j "OccurrenceRelativeToEnd") Boolean.of_json
    ; occurrence_unit =
        Aws.Util.option_map (Aws.Json.lookup j "OccurrenceUnit") String.of_json
    }
end

module DescribeScheduledInstanceAvailabilityRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; filters : FilterList.t
    ; first_slot_start_time_range : SlotDateTimeRangeRequest.t
    ; max_results : Integer.t option
    ; max_slot_duration_in_hours : Integer.t option
    ; min_slot_duration_in_hours : Integer.t option
    ; next_token : String.t option
    ; recurrence : ScheduledInstanceRecurrenceRequest.t
    }

  let make
      ?dry_run
      ?(filters = [])
      ~first_slot_start_time_range
      ?max_results
      ?max_slot_duration_in_hours
      ?min_slot_duration_in_hours
      ?next_token
      ~recurrence
      () =
    { dry_run
    ; filters
    ; first_slot_start_time_range
    ; max_results
    ; max_slot_duration_in_hours
    ; min_slot_duration_in_hours
    ; next_token
    ; recurrence
    }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; first_slot_start_time_range =
          Aws.Xml.required
            "FirstSlotStartTimeRange"
            (Aws.Util.option_bind
               (Aws.Xml.member "FirstSlotStartTimeRange" xml)
               SlotDateTimeRangeRequest.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; max_slot_duration_in_hours =
          Aws.Util.option_bind (Aws.Xml.member "MaxSlotDurationInHours" xml) Integer.parse
      ; min_slot_duration_in_hours =
          Aws.Util.option_bind (Aws.Xml.member "MinSlotDurationInHours" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; recurrence =
          Aws.Xml.required
            "Recurrence"
            (Aws.Util.option_bind
               (Aws.Xml.member "Recurrence" xml)
               ScheduledInstanceRecurrenceRequest.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("Recurrence", ScheduledInstanceRecurrenceRequest.to_query v.recurrence))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.min_slot_duration_in_hours (fun f ->
               Aws.Query.Pair ("MinSlotDurationInHours", Integer.to_query f))
         ; Aws.Util.option_map v.max_slot_duration_in_hours (fun f ->
               Aws.Query.Pair ("MaxSlotDurationInHours", Integer.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "FirstSlotStartTimeRange"
                , SlotDateTimeRangeRequest.to_query v.first_slot_start_time_range ))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Recurrence", ScheduledInstanceRecurrenceRequest.to_json v.recurrence)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.min_slot_duration_in_hours (fun f ->
               "MinSlotDurationInHours", Integer.to_json f)
         ; Aws.Util.option_map v.max_slot_duration_in_hours (fun f ->
               "MaxSlotDurationInHours", Integer.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some
             ( "FirstSlotStartTimeRange"
             , SlotDateTimeRangeRequest.to_json v.first_slot_start_time_range )
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; first_slot_start_time_range =
        SlotDateTimeRangeRequest.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "FirstSlotStartTimeRange"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; max_slot_duration_in_hours =
        Aws.Util.option_map (Aws.Json.lookup j "MaxSlotDurationInHours") Integer.of_json
    ; min_slot_duration_in_hours =
        Aws.Util.option_map (Aws.Json.lookup j "MinSlotDurationInHours") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; recurrence =
        ScheduledInstanceRecurrenceRequest.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Recurrence"))
    }
end

module TargetConfiguration = struct
  type t =
    { instance_count : Integer.t option
    ; offering_id : String.t option
    }

  let make ?instance_count ?offering_id () = { instance_count; offering_id }

  let parse xml =
    Some
      { instance_count =
          Aws.Util.option_bind (Aws.Xml.member "instanceCount" xml) Integer.parse
      ; offering_id = Aws.Util.option_bind (Aws.Xml.member "offeringId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.offering_id (fun f ->
               Aws.Query.Pair ("OfferingId", String.to_query f))
         ; Aws.Util.option_map v.instance_count (fun f ->
               Aws.Query.Pair ("InstanceCount", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.offering_id (fun f -> "offeringId", String.to_json f)
         ; Aws.Util.option_map v.instance_count (fun f ->
               "instanceCount", Integer.to_json f)
         ])

  let of_json j =
    { instance_count =
        Aws.Util.option_map (Aws.Json.lookup j "instanceCount") Integer.of_json
    ; offering_id = Aws.Util.option_map (Aws.Json.lookup j "offeringId") String.of_json
    }
end

module ReservationValue = struct
  type t =
    { hourly_price : String.t option
    ; remaining_total_value : String.t option
    ; remaining_upfront_value : String.t option
    }

  let make ?hourly_price ?remaining_total_value ?remaining_upfront_value () =
    { hourly_price; remaining_total_value; remaining_upfront_value }

  let parse xml =
    Some
      { hourly_price =
          Aws.Util.option_bind (Aws.Xml.member "hourlyPrice" xml) String.parse
      ; remaining_total_value =
          Aws.Util.option_bind (Aws.Xml.member "remainingTotalValue" xml) String.parse
      ; remaining_upfront_value =
          Aws.Util.option_bind (Aws.Xml.member "remainingUpfrontValue" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.remaining_upfront_value (fun f ->
               Aws.Query.Pair ("RemainingUpfrontValue", String.to_query f))
         ; Aws.Util.option_map v.remaining_total_value (fun f ->
               Aws.Query.Pair ("RemainingTotalValue", String.to_query f))
         ; Aws.Util.option_map v.hourly_price (fun f ->
               Aws.Query.Pair ("HourlyPrice", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.remaining_upfront_value (fun f ->
               "remainingUpfrontValue", String.to_json f)
         ; Aws.Util.option_map v.remaining_total_value (fun f ->
               "remainingTotalValue", String.to_json f)
         ; Aws.Util.option_map v.hourly_price (fun f -> "hourlyPrice", String.to_json f)
         ])

  let of_json j =
    { hourly_price = Aws.Util.option_map (Aws.Json.lookup j "hourlyPrice") String.of_json
    ; remaining_total_value =
        Aws.Util.option_map (Aws.Json.lookup j "remainingTotalValue") String.of_json
    ; remaining_upfront_value =
        Aws.Util.option_map (Aws.Json.lookup j "remainingUpfrontValue") String.of_json
    }
end

module TargetReservationValue = struct
  type t =
    { reservation_value : ReservationValue.t option
    ; target_configuration : TargetConfiguration.t option
    }

  let make ?reservation_value ?target_configuration () =
    { reservation_value; target_configuration }

  let parse xml =
    Some
      { reservation_value =
          Aws.Util.option_bind
            (Aws.Xml.member "reservationValue" xml)
            ReservationValue.parse
      ; target_configuration =
          Aws.Util.option_bind
            (Aws.Xml.member "targetConfiguration" xml)
            TargetConfiguration.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.target_configuration (fun f ->
               Aws.Query.Pair ("TargetConfiguration", TargetConfiguration.to_query f))
         ; Aws.Util.option_map v.reservation_value (fun f ->
               Aws.Query.Pair ("ReservationValue", ReservationValue.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.target_configuration (fun f ->
               "targetConfiguration", TargetConfiguration.to_json f)
         ; Aws.Util.option_map v.reservation_value (fun f ->
               "reservationValue", ReservationValue.to_json f)
         ])

  let of_json j =
    { reservation_value =
        Aws.Util.option_map
          (Aws.Json.lookup j "reservationValue")
          ReservationValue.of_json
    ; target_configuration =
        Aws.Util.option_map
          (Aws.Json.lookup j "targetConfiguration")
          TargetConfiguration.of_json
    }
end

module ConnectionNotificationType = struct
  type t = Topic

  let str_to_t = [ "Topic", Topic ]

  let t_to_str = [ Topic, "Topic" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ConnectionNotificationState = struct
  type t =
    | Enabled
    | Disabled

  let str_to_t = [ "Disabled", Disabled; "Enabled", Enabled ]

  let t_to_str = [ Disabled, "Disabled"; Enabled, "Enabled" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ConnectionNotification = struct
  type t =
    { connection_notification_id : String.t option
    ; service_id : String.t option
    ; vpc_endpoint_id : String.t option
    ; connection_notification_type : ConnectionNotificationType.t option
    ; connection_notification_arn : String.t option
    ; connection_events : ValueStringList.t
    ; connection_notification_state : ConnectionNotificationState.t option
    }

  let make
      ?connection_notification_id
      ?service_id
      ?vpc_endpoint_id
      ?connection_notification_type
      ?connection_notification_arn
      ?(connection_events = [])
      ?connection_notification_state
      () =
    { connection_notification_id
    ; service_id
    ; vpc_endpoint_id
    ; connection_notification_type
    ; connection_notification_arn
    ; connection_events
    ; connection_notification_state
    }

  let parse xml =
    Some
      { connection_notification_id =
          Aws.Util.option_bind
            (Aws.Xml.member "connectionNotificationId" xml)
            String.parse
      ; service_id = Aws.Util.option_bind (Aws.Xml.member "serviceId" xml) String.parse
      ; vpc_endpoint_id =
          Aws.Util.option_bind (Aws.Xml.member "vpcEndpointId" xml) String.parse
      ; connection_notification_type =
          Aws.Util.option_bind
            (Aws.Xml.member "connectionNotificationType" xml)
            ConnectionNotificationType.parse
      ; connection_notification_arn =
          Aws.Util.option_bind
            (Aws.Xml.member "connectionNotificationArn" xml)
            String.parse
      ; connection_events =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "connectionEvents" xml)
               ValueStringList.parse)
      ; connection_notification_state =
          Aws.Util.option_bind
            (Aws.Xml.member "connectionNotificationState" xml)
            ConnectionNotificationState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.connection_notification_state (fun f ->
               Aws.Query.Pair
                 ("ConnectionNotificationState", ConnectionNotificationState.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ConnectionEvents", ValueStringList.to_query v.connection_events))
         ; Aws.Util.option_map v.connection_notification_arn (fun f ->
               Aws.Query.Pair ("ConnectionNotificationArn", String.to_query f))
         ; Aws.Util.option_map v.connection_notification_type (fun f ->
               Aws.Query.Pair
                 ("ConnectionNotificationType", ConnectionNotificationType.to_query f))
         ; Aws.Util.option_map v.vpc_endpoint_id (fun f ->
               Aws.Query.Pair ("VpcEndpointId", String.to_query f))
         ; Aws.Util.option_map v.service_id (fun f ->
               Aws.Query.Pair ("ServiceId", String.to_query f))
         ; Aws.Util.option_map v.connection_notification_id (fun f ->
               Aws.Query.Pair ("ConnectionNotificationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.connection_notification_state (fun f ->
               "connectionNotificationState", ConnectionNotificationState.to_json f)
         ; Some ("connectionEvents", ValueStringList.to_json v.connection_events)
         ; Aws.Util.option_map v.connection_notification_arn (fun f ->
               "connectionNotificationArn", String.to_json f)
         ; Aws.Util.option_map v.connection_notification_type (fun f ->
               "connectionNotificationType", ConnectionNotificationType.to_json f)
         ; Aws.Util.option_map v.vpc_endpoint_id (fun f ->
               "vpcEndpointId", String.to_json f)
         ; Aws.Util.option_map v.service_id (fun f -> "serviceId", String.to_json f)
         ; Aws.Util.option_map v.connection_notification_id (fun f ->
               "connectionNotificationId", String.to_json f)
         ])

  let of_json j =
    { connection_notification_id =
        Aws.Util.option_map (Aws.Json.lookup j "connectionNotificationId") String.of_json
    ; service_id = Aws.Util.option_map (Aws.Json.lookup j "serviceId") String.of_json
    ; vpc_endpoint_id =
        Aws.Util.option_map (Aws.Json.lookup j "vpcEndpointId") String.of_json
    ; connection_notification_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "connectionNotificationType")
          ConnectionNotificationType.of_json
    ; connection_notification_arn =
        Aws.Util.option_map (Aws.Json.lookup j "connectionNotificationArn") String.of_json
    ; connection_events =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "connectionEvents"))
    ; connection_notification_state =
        Aws.Util.option_map
          (Aws.Json.lookup j "connectionNotificationState")
          ConnectionNotificationState.of_json
    }
end

module ConnectionNotificationSet = struct
  type t = ConnectionNotification.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ConnectionNotification.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ConnectionNotification.to_query v

  let to_json v = `List (List.map ConnectionNotification.to_json v)

  let of_json j = Aws.Json.to_list ConnectionNotification.of_json j
end

module IdFormat = struct
  type t =
    { deadline : DateTime.t option
    ; resource : String.t option
    ; use_long_ids : Boolean.t option
    }

  let make ?deadline ?resource ?use_long_ids () = { deadline; resource; use_long_ids }

  let parse xml =
    Some
      { deadline = Aws.Util.option_bind (Aws.Xml.member "deadline" xml) DateTime.parse
      ; resource = Aws.Util.option_bind (Aws.Xml.member "resource" xml) String.parse
      ; use_long_ids =
          Aws.Util.option_bind (Aws.Xml.member "useLongIds" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.use_long_ids (fun f ->
               Aws.Query.Pair ("UseLongIds", Boolean.to_query f))
         ; Aws.Util.option_map v.resource (fun f ->
               Aws.Query.Pair ("Resource", String.to_query f))
         ; Aws.Util.option_map v.deadline (fun f ->
               Aws.Query.Pair ("Deadline", DateTime.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.use_long_ids (fun f -> "useLongIds", Boolean.to_json f)
         ; Aws.Util.option_map v.resource (fun f -> "resource", String.to_json f)
         ; Aws.Util.option_map v.deadline (fun f -> "deadline", DateTime.to_json f)
         ])

  let of_json j =
    { deadline = Aws.Util.option_map (Aws.Json.lookup j "deadline") DateTime.of_json
    ; resource = Aws.Util.option_map (Aws.Json.lookup j "resource") String.of_json
    ; use_long_ids = Aws.Util.option_map (Aws.Json.lookup j "useLongIds") Boolean.of_json
    }
end

module IdFormatList = struct
  type t = IdFormat.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map IdFormat.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list IdFormat.to_query v

  let to_json v = `List (List.map IdFormat.to_json v)

  let of_json j = Aws.Json.to_list IdFormat.of_json j
end

module DescribeIdFormatResult = struct
  type t = { statuses : IdFormatList.t }

  let make ?(statuses = []) () = { statuses }

  let parse xml =
    Some
      { statuses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "statusSet" xml) IdFormatList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("StatusSet", IdFormatList.to_query v.statuses)) ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt [ Some ("statusSet", IdFormatList.to_json v.statuses) ])

  let of_json j =
    { statuses =
        IdFormatList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "statusSet"))
    }
end

module InternetGateway = struct
  type t =
    { attachments : InternetGatewayAttachmentList.t
    ; internet_gateway_id : String.t
    ; owner_id : String.t option
    ; tags : TagList.t
    }

  let make ?(attachments = []) ~internet_gateway_id ?owner_id ?(tags = []) () =
    { attachments; internet_gateway_id; owner_id; tags }

  let parse xml =
    Some
      { attachments =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "attachmentSet" xml)
               InternetGatewayAttachmentList.parse)
      ; internet_gateway_id =
          Aws.Xml.required
            "internetGatewayId"
            (Aws.Util.option_bind (Aws.Xml.member "internetGatewayId" xml) String.parse)
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Some
             (Aws.Query.Pair ("InternetGatewayId", String.to_query v.internet_gateway_id))
         ; Some
             (Aws.Query.Pair
                ("AttachmentSet", InternetGatewayAttachmentList.to_query v.attachments))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Some ("internetGatewayId", String.to_json v.internet_gateway_id)
         ; Some ("attachmentSet", InternetGatewayAttachmentList.to_json v.attachments)
         ])

  let of_json j =
    { attachments =
        InternetGatewayAttachmentList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "attachmentSet"))
    ; internet_gateway_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "internetGatewayId"))
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module CreateInternetGatewayResult = struct
  type t = { internet_gateway : InternetGateway.t option }

  let make ?internet_gateway () = { internet_gateway }

  let parse xml =
    Some
      { internet_gateway =
          Aws.Util.option_bind
            (Aws.Xml.member "internetGateway" xml)
            InternetGateway.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.internet_gateway (fun f ->
               Aws.Query.Pair ("InternetGateway", InternetGateway.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.internet_gateway (fun f ->
               "internetGateway", InternetGateway.to_json f)
         ])

  let of_json j =
    { internet_gateway =
        Aws.Util.option_map (Aws.Json.lookup j "internetGateway") InternetGateway.of_json
    }
end

module GetCoipPoolUsageRequest = struct
  type t =
    { pool_id : String.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make ~pool_id ?(filters = []) ?max_results ?next_token ?dry_run () =
    { pool_id; filters; max_results; next_token; dry_run }

  let parse xml =
    Some
      { pool_id =
          Aws.Xml.required
            "PoolId"
            (Aws.Util.option_bind (Aws.Xml.member "PoolId" xml) String.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some (Aws.Query.Pair ("PoolId", String.to_query v.pool_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some ("PoolId", String.to_json v.pool_id)
         ])

  let of_json j =
    { pool_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PoolId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module RevokeSecurityGroupEgressResult = struct
  type t =
    { return : Boolean.t option
    ; unknown_ip_permissions : IpPermissionList.t
    }

  let make ?return ?(unknown_ip_permissions = []) () = { return; unknown_ip_permissions }

  let parse xml =
    Some
      { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse
      ; unknown_ip_permissions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "unknownIpPermissionSet" xml)
               IpPermissionList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "UnknownIpPermissionSet"
                , IpPermissionList.to_query v.unknown_ip_permissions ))
         ; Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ("unknownIpPermissionSet", IpPermissionList.to_json v.unknown_ip_permissions)
         ; Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f)
         ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json
    ; unknown_ip_permissions =
        IpPermissionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "unknownIpPermissionSet"))
    }
end

module VpcClassicLink = struct
  type t =
    { classic_link_enabled : Boolean.t option
    ; tags : TagList.t
    ; vpc_id : String.t option
    }

  let make ?classic_link_enabled ?(tags = []) ?vpc_id () =
    { classic_link_enabled; tags; vpc_id }

  let parse xml =
    Some
      { classic_link_enabled =
          Aws.Util.option_bind (Aws.Xml.member "classicLinkEnabled" xml) Boolean.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.classic_link_enabled (fun f ->
               Aws.Query.Pair ("ClassicLinkEnabled", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_id (fun f -> "vpcId", String.to_json f)
         ; Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.classic_link_enabled (fun f ->
               "classicLinkEnabled", Boolean.to_json f)
         ])

  let of_json j =
    { classic_link_enabled =
        Aws.Util.option_map (Aws.Json.lookup j "classicLinkEnabled") Boolean.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "vpcId") String.of_json
    }
end

module VpcClassicLinkList = struct
  type t = VpcClassicLink.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map VpcClassicLink.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list VpcClassicLink.to_query v

  let to_json v = `List (List.map VpcClassicLink.to_json v)

  let of_json j = Aws.Json.to_list VpcClassicLink.of_json j
end

module DescribeClassicLinkInstancesRequest = struct
  type t =
    { filters : FilterList.t
    ; dry_run : Boolean.t option
    ; instance_ids : InstanceIdStringList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?(filters = []) ?dry_run ?(instance_ids = []) ?max_results ?next_token () =
    { filters; dry_run; instance_ids; max_results; next_token }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; instance_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "InstanceId" xml)
               InstanceIdStringList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "maxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair ("InstanceId", InstanceIdStringList.to_query v.instance_ids))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "maxResults", Integer.to_json f)
         ; Some ("InstanceId", InstanceIdStringList.to_json v.instance_ids)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; instance_ids =
        InstanceIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "maxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module ReplaceRouteTableAssociationRequest = struct
  type t =
    { association_id : String.t
    ; dry_run : Boolean.t option
    ; route_table_id : String.t
    }

  let make ~association_id ?dry_run ~route_table_id () =
    { association_id; dry_run; route_table_id }

  let parse xml =
    Some
      { association_id =
          Aws.Xml.required
            "associationId"
            (Aws.Util.option_bind (Aws.Xml.member "associationId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; route_table_id =
          Aws.Xml.required
            "routeTableId"
            (Aws.Util.option_bind (Aws.Xml.member "routeTableId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("RouteTableId", String.to_query v.route_table_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("AssociationId", String.to_query v.association_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("routeTableId", String.to_json v.route_table_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("associationId", String.to_json v.association_id)
         ])

  let of_json j =
    { association_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "associationId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; route_table_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "routeTableId"))
    }
end

module TrafficMirrorSessionField = struct
  type t =
    | Packet_length
    | Description
    | Virtual_network_id

  let str_to_t =
    [ "virtual-network-id", Virtual_network_id
    ; "description", Description
    ; "packet-length", Packet_length
    ]

  let t_to_str =
    [ Virtual_network_id, "virtual-network-id"
    ; Description, "description"
    ; Packet_length, "packet-length"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module TrafficMirrorSessionFieldList = struct
  type t = TrafficMirrorSessionField.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map TrafficMirrorSessionField.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list TrafficMirrorSessionField.to_query v

  let to_json v = `List (List.map TrafficMirrorSessionField.to_json v)

  let of_json j = Aws.Json.to_list TrafficMirrorSessionField.of_json j
end

module TransitGatewayNetworkInterfaceIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module FleetExcessCapacityTerminationPolicy = struct
  type t =
    | No_termination
    | Termination

  let str_to_t = [ "termination", Termination; "no-termination", No_termination ]

  let t_to_str = [ Termination, "termination"; No_termination, "no-termination" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ClientVpnEndpointStatusCode = struct
  type t =
    | Pending_associate
    | Available
    | Deleting
    | Deleted

  let str_to_t =
    [ "deleted", Deleted
    ; "deleting", Deleting
    ; "available", Available
    ; "pending-associate", Pending_associate
    ]

  let t_to_str =
    [ Deleted, "deleted"
    ; Deleting, "deleting"
    ; Available, "available"
    ; Pending_associate, "pending-associate"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module RestoreManagedPrefixListVersionRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; prefix_list_id : String.t
    ; previous_version : Long.t
    ; current_version : Long.t
    }

  let make ?dry_run ~prefix_list_id ~previous_version ~current_version () =
    { dry_run; prefix_list_id; previous_version; current_version }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; prefix_list_id =
          Aws.Xml.required
            "PrefixListId"
            (Aws.Util.option_bind (Aws.Xml.member "PrefixListId" xml) String.parse)
      ; previous_version =
          Aws.Xml.required
            "PreviousVersion"
            (Aws.Util.option_bind (Aws.Xml.member "PreviousVersion" xml) Long.parse)
      ; current_version =
          Aws.Xml.required
            "CurrentVersion"
            (Aws.Util.option_bind (Aws.Xml.member "CurrentVersion" xml) Long.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("CurrentVersion", Long.to_query v.current_version))
         ; Some (Aws.Query.Pair ("PreviousVersion", Long.to_query v.previous_version))
         ; Some (Aws.Query.Pair ("PrefixListId", String.to_query v.prefix_list_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("CurrentVersion", Long.to_json v.current_version)
         ; Some ("PreviousVersion", Long.to_json v.previous_version)
         ; Some ("PrefixListId", String.to_json v.prefix_list_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; prefix_list_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PrefixListId"))
    ; previous_version =
        Long.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PreviousVersion"))
    ; current_version =
        Long.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "CurrentVersion"))
    }
end

module RebootInstancesRequest = struct
  type t =
    { instance_ids : InstanceIdStringList.t
    ; dry_run : Boolean.t option
    }

  let make ~instance_ids ?dry_run () = { instance_ids; dry_run }

  let parse xml =
    Some
      { instance_ids =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind
               (Aws.Xml.member "InstanceId" xml)
               InstanceIdStringList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair ("InstanceId", InstanceIdStringList.to_query v.instance_ids))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("InstanceId", InstanceIdStringList.to_json v.instance_ids)
         ])

  let of_json j =
    { instance_ids =
        InstanceIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module LocalGateway = struct
  type t =
    { local_gateway_id : String.t option
    ; outpost_arn : String.t option
    ; owner_id : String.t option
    ; state : String.t option
    ; tags : TagList.t
    }

  let make ?local_gateway_id ?outpost_arn ?owner_id ?state ?(tags = []) () =
    { local_gateway_id; outpost_arn; owner_id; state; tags }

  let parse xml =
    Some
      { local_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "localGatewayId" xml) String.parse
      ; outpost_arn = Aws.Util.option_bind (Aws.Xml.member "outpostArn" xml) String.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; state = Aws.Util.option_bind (Aws.Xml.member "state" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", String.to_query f))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.outpost_arn (fun f ->
               Aws.Query.Pair ("OutpostArn", String.to_query f))
         ; Aws.Util.option_map v.local_gateway_id (fun f ->
               Aws.Query.Pair ("LocalGatewayId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.state (fun f -> "state", String.to_json f)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.outpost_arn (fun f -> "outpostArn", String.to_json f)
         ; Aws.Util.option_map v.local_gateway_id (fun f ->
               "localGatewayId", String.to_json f)
         ])

  let of_json j =
    { local_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "localGatewayId") String.of_json
    ; outpost_arn = Aws.Util.option_map (Aws.Json.lookup j "outpostArn") String.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; state = Aws.Util.option_map (Aws.Json.lookup j "state") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module LocalGatewaySet = struct
  type t = LocalGateway.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map LocalGateway.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list LocalGateway.to_query v

  let to_json v = `List (List.map LocalGateway.to_json v)

  let of_json j = Aws.Json.to_list LocalGateway.of_json j
end

module ExportTaskS3Location = struct
  type t =
    { s3_bucket : String.t option
    ; s3_prefix : String.t option
    }

  let make ?s3_bucket ?s3_prefix () = { s3_bucket; s3_prefix }

  let parse xml =
    Some
      { s3_bucket = Aws.Util.option_bind (Aws.Xml.member "s3Bucket" xml) String.parse
      ; s3_prefix = Aws.Util.option_bind (Aws.Xml.member "s3Prefix" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.s3_prefix (fun f ->
               Aws.Query.Pair ("S3Prefix", String.to_query f))
         ; Aws.Util.option_map v.s3_bucket (fun f ->
               Aws.Query.Pair ("S3Bucket", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.s3_prefix (fun f -> "s3Prefix", String.to_json f)
         ; Aws.Util.option_map v.s3_bucket (fun f -> "s3Bucket", String.to_json f)
         ])

  let of_json j =
    { s3_bucket = Aws.Util.option_map (Aws.Json.lookup j "s3Bucket") String.of_json
    ; s3_prefix = Aws.Util.option_map (Aws.Json.lookup j "s3Prefix") String.of_json
    }
end

module ExportImageTask = struct
  type t =
    { description : String.t option
    ; export_image_task_id : String.t option
    ; image_id : String.t option
    ; progress : String.t option
    ; s3_export_location : ExportTaskS3Location.t option
    ; status : String.t option
    ; status_message : String.t option
    ; tags : TagList.t
    }

  let make
      ?description
      ?export_image_task_id
      ?image_id
      ?progress
      ?s3_export_location
      ?status
      ?status_message
      ?(tags = [])
      () =
    { description
    ; export_image_task_id
    ; image_id
    ; progress
    ; s3_export_location
    ; status
    ; status_message
    ; tags
    }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; export_image_task_id =
          Aws.Util.option_bind (Aws.Xml.member "exportImageTaskId" xml) String.parse
      ; image_id = Aws.Util.option_bind (Aws.Xml.member "imageId" xml) String.parse
      ; progress = Aws.Util.option_bind (Aws.Xml.member "progress" xml) String.parse
      ; s3_export_location =
          Aws.Util.option_bind
            (Aws.Xml.member "s3ExportLocation" xml)
            ExportTaskS3Location.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "status" xml) String.parse
      ; status_message =
          Aws.Util.option_bind (Aws.Xml.member "statusMessage" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.status_message (fun f ->
               Aws.Query.Pair ("StatusMessage", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.s3_export_location (fun f ->
               Aws.Query.Pair ("S3ExportLocation", ExportTaskS3Location.to_query f))
         ; Aws.Util.option_map v.progress (fun f ->
               Aws.Query.Pair ("Progress", String.to_query f))
         ; Aws.Util.option_map v.image_id (fun f ->
               Aws.Query.Pair ("ImageId", String.to_query f))
         ; Aws.Util.option_map v.export_image_task_id (fun f ->
               Aws.Query.Pair ("ExportImageTaskId", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.status_message (fun f ->
               "statusMessage", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "status", String.to_json f)
         ; Aws.Util.option_map v.s3_export_location (fun f ->
               "s3ExportLocation", ExportTaskS3Location.to_json f)
         ; Aws.Util.option_map v.progress (fun f -> "progress", String.to_json f)
         ; Aws.Util.option_map v.image_id (fun f -> "imageId", String.to_json f)
         ; Aws.Util.option_map v.export_image_task_id (fun f ->
               "exportImageTaskId", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; export_image_task_id =
        Aws.Util.option_map (Aws.Json.lookup j "exportImageTaskId") String.of_json
    ; image_id = Aws.Util.option_map (Aws.Json.lookup j "imageId") String.of_json
    ; progress = Aws.Util.option_map (Aws.Json.lookup j "progress") String.of_json
    ; s3_export_location =
        Aws.Util.option_map
          (Aws.Json.lookup j "s3ExportLocation")
          ExportTaskS3Location.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "status") String.of_json
    ; status_message =
        Aws.Util.option_map (Aws.Json.lookup j "statusMessage") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module ExportImageTaskList = struct
  type t = ExportImageTask.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ExportImageTask.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ExportImageTask.to_query v

  let to_json v = `List (List.map ExportImageTask.to_json v)

  let of_json j = Aws.Json.to_list ExportImageTask.of_json j
end

module TransitGatewayRouteType = struct
  type t =
    | Static
    | Propagated

  let str_to_t = [ "propagated", Propagated; "static", Static ]

  let t_to_str = [ Propagated, "propagated"; Static, "static" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module TransitGatewayRouteState = struct
  type t =
    | Pending
    | Active
    | Blackhole
    | Deleting
    | Deleted

  let str_to_t =
    [ "deleted", Deleted
    ; "deleting", Deleting
    ; "blackhole", Blackhole
    ; "active", Active
    ; "pending", Pending
    ]

  let t_to_str =
    [ Deleted, "deleted"
    ; Deleting, "deleting"
    ; Blackhole, "blackhole"
    ; Active, "active"
    ; Pending, "pending"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module TransitGatewayRouteAttachment = struct
  type t =
    { resource_id : String.t option
    ; transit_gateway_attachment_id : String.t option
    ; resource_type : TransitGatewayAttachmentResourceType.t option
    }

  let make ?resource_id ?transit_gateway_attachment_id ?resource_type () =
    { resource_id; transit_gateway_attachment_id; resource_type }

  let parse xml =
    Some
      { resource_id = Aws.Util.option_bind (Aws.Xml.member "resourceId" xml) String.parse
      ; transit_gateway_attachment_id =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayAttachmentId" xml)
            String.parse
      ; resource_type =
          Aws.Util.option_bind
            (Aws.Xml.member "resourceType" xml)
            TransitGatewayAttachmentResourceType.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.resource_type (fun f ->
               Aws.Query.Pair
                 ("ResourceType", TransitGatewayAttachmentResourceType.to_query f))
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               Aws.Query.Pair ("TransitGatewayAttachmentId", String.to_query f))
         ; Aws.Util.option_map v.resource_id (fun f ->
               Aws.Query.Pair ("ResourceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.resource_type (fun f ->
               "resourceType", TransitGatewayAttachmentResourceType.to_json f)
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               "transitGatewayAttachmentId", String.to_json f)
         ; Aws.Util.option_map v.resource_id (fun f -> "resourceId", String.to_json f)
         ])

  let of_json j =
    { resource_id = Aws.Util.option_map (Aws.Json.lookup j "resourceId") String.of_json
    ; transit_gateway_attachment_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayAttachmentId")
          String.of_json
    ; resource_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "resourceType")
          TransitGatewayAttachmentResourceType.of_json
    }
end

module TransitGatewayRouteAttachmentList = struct
  type t = TransitGatewayRouteAttachment.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map TransitGatewayRouteAttachment.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list TransitGatewayRouteAttachment.to_query v

  let to_json v = `List (List.map TransitGatewayRouteAttachment.to_json v)

  let of_json j = Aws.Json.to_list TransitGatewayRouteAttachment.of_json j
end

module TransitGatewayRoute = struct
  type t =
    { destination_cidr_block : String.t option
    ; prefix_list_id : String.t option
    ; transit_gateway_attachments : TransitGatewayRouteAttachmentList.t
    ; type_ : TransitGatewayRouteType.t option
    ; state : TransitGatewayRouteState.t option
    }

  let make
      ?destination_cidr_block
      ?prefix_list_id
      ?(transit_gateway_attachments = [])
      ?type_
      ?state
      () =
    { destination_cidr_block; prefix_list_id; transit_gateway_attachments; type_; state }

  let parse xml =
    Some
      { destination_cidr_block =
          Aws.Util.option_bind (Aws.Xml.member "destinationCidrBlock" xml) String.parse
      ; prefix_list_id =
          Aws.Util.option_bind (Aws.Xml.member "prefixListId" xml) String.parse
      ; transit_gateway_attachments =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "transitGatewayAttachments" xml)
               TransitGatewayRouteAttachmentList.parse)
      ; type_ =
          Aws.Util.option_bind (Aws.Xml.member "type" xml) TransitGatewayRouteType.parse
      ; state =
          Aws.Util.option_bind (Aws.Xml.member "state" xml) TransitGatewayRouteState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", TransitGatewayRouteState.to_query f))
         ; Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", TransitGatewayRouteType.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayAttachments"
                , TransitGatewayRouteAttachmentList.to_query v.transit_gateway_attachments
                ))
         ; Aws.Util.option_map v.prefix_list_id (fun f ->
               Aws.Query.Pair ("PrefixListId", String.to_query f))
         ; Aws.Util.option_map v.destination_cidr_block (fun f ->
               Aws.Query.Pair ("DestinationCidrBlock", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               "state", TransitGatewayRouteState.to_json f)
         ; Aws.Util.option_map v.type_ (fun f ->
               "type", TransitGatewayRouteType.to_json f)
         ; Some
             ( "transitGatewayAttachments"
             , TransitGatewayRouteAttachmentList.to_json v.transit_gateway_attachments )
         ; Aws.Util.option_map v.prefix_list_id (fun f ->
               "prefixListId", String.to_json f)
         ; Aws.Util.option_map v.destination_cidr_block (fun f ->
               "destinationCidrBlock", String.to_json f)
         ])

  let of_json j =
    { destination_cidr_block =
        Aws.Util.option_map (Aws.Json.lookup j "destinationCidrBlock") String.of_json
    ; prefix_list_id =
        Aws.Util.option_map (Aws.Json.lookup j "prefixListId") String.of_json
    ; transit_gateway_attachments =
        TransitGatewayRouteAttachmentList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "transitGatewayAttachments"))
    ; type_ =
        Aws.Util.option_map (Aws.Json.lookup j "type") TransitGatewayRouteType.of_json
    ; state =
        Aws.Util.option_map (Aws.Json.lookup j "state") TransitGatewayRouteState.of_json
    }
end

module DeleteTransitGatewayRouteResult = struct
  type t = { route : TransitGatewayRoute.t option }

  let make ?route () = { route }

  let parse xml =
    Some
      { route =
          Aws.Util.option_bind (Aws.Xml.member "route" xml) TransitGatewayRoute.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.route (fun f ->
               Aws.Query.Pair ("Route", TransitGatewayRoute.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.route (fun f -> "route", TransitGatewayRoute.to_json f) ])

  let of_json j =
    { route = Aws.Util.option_map (Aws.Json.lookup j "route") TransitGatewayRoute.of_json
    }
end

module TrafficMirrorPortRangeRequest = struct
  type t =
    { from_port : Integer.t option
    ; to_port : Integer.t option
    }

  let make ?from_port ?to_port () = { from_port; to_port }

  let parse xml =
    Some
      { from_port = Aws.Util.option_bind (Aws.Xml.member "FromPort" xml) Integer.parse
      ; to_port = Aws.Util.option_bind (Aws.Xml.member "ToPort" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.to_port (fun f ->
               Aws.Query.Pair ("ToPort", Integer.to_query f))
         ; Aws.Util.option_map v.from_port (fun f ->
               Aws.Query.Pair ("FromPort", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.to_port (fun f -> "ToPort", Integer.to_json f)
         ; Aws.Util.option_map v.from_port (fun f -> "FromPort", Integer.to_json f)
         ])

  let of_json j =
    { from_port = Aws.Util.option_map (Aws.Json.lookup j "FromPort") Integer.of_json
    ; to_port = Aws.Util.option_map (Aws.Json.lookup j "ToPort") Integer.of_json
    }
end

module Phase1DHGroupNumbersRequestListValue = struct
  type t = { value : Integer.t option }

  let make ?value () = { value }

  let parse xml =
    Some { value = Aws.Util.option_bind (Aws.Xml.member "Value" xml) Integer.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f -> "Value", Integer.to_json f) ])

  let of_json j =
    { value = Aws.Util.option_map (Aws.Json.lookup j "Value") Integer.of_json }
end

module HostReservationIdSet = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeHostReservationsRequest = struct
  type t =
    { filter : FilterList.t
    ; host_reservation_id_set : HostReservationIdSet.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?(filter = []) ?(host_reservation_id_set = []) ?max_results ?next_token () =
    { filter; host_reservation_id_set; max_results; next_token }

  let parse xml =
    Some
      { filter =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; host_reservation_id_set =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "HostReservationIdSet" xml)
               HostReservationIdSet.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "HostReservationIdSet"
                , HostReservationIdSet.to_query v.host_reservation_id_set ))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filter))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some
             ( "HostReservationIdSet"
             , HostReservationIdSet.to_json v.host_reservation_id_set )
         ; Some ("Filter", FilterList.to_json v.filter)
         ])

  let of_json j =
    { filter = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; host_reservation_id_set =
        HostReservationIdSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "HostReservationIdSet"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module DeregisterImageRequest = struct
  type t =
    { image_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~image_id ?dry_run () = { image_id; dry_run }

  let parse xml =
    Some
      { image_id =
          Aws.Xml.required
            "ImageId"
            (Aws.Util.option_bind (Aws.Xml.member "ImageId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("ImageId", String.to_query v.image_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("ImageId", String.to_json v.image_id)
         ])

  let of_json j =
    { image_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ImageId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module CancelSpotInstanceRequestState = struct
  type t =
    | Active
    | Open
    | Closed
    | Cancelled
    | Completed

  let str_to_t =
    [ "completed", Completed
    ; "cancelled", Cancelled
    ; "closed", Closed
    ; "open", Open
    ; "active", Active
    ]

  let t_to_str =
    [ Completed, "completed"
    ; Cancelled, "cancelled"
    ; Closed, "closed"
    ; Open, "open"
    ; Active, "active"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module CancelledSpotInstanceRequest = struct
  type t =
    { spot_instance_request_id : String.t option
    ; state : CancelSpotInstanceRequestState.t option
    }

  let make ?spot_instance_request_id ?state () = { spot_instance_request_id; state }

  let parse xml =
    Some
      { spot_instance_request_id =
          Aws.Util.option_bind (Aws.Xml.member "spotInstanceRequestId" xml) String.parse
      ; state =
          Aws.Util.option_bind
            (Aws.Xml.member "state" xml)
            CancelSpotInstanceRequestState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", CancelSpotInstanceRequestState.to_query f))
         ; Aws.Util.option_map v.spot_instance_request_id (fun f ->
               Aws.Query.Pair ("SpotInstanceRequestId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               "state", CancelSpotInstanceRequestState.to_json f)
         ; Aws.Util.option_map v.spot_instance_request_id (fun f ->
               "spotInstanceRequestId", String.to_json f)
         ])

  let of_json j =
    { spot_instance_request_id =
        Aws.Util.option_map (Aws.Json.lookup j "spotInstanceRequestId") String.of_json
    ; state =
        Aws.Util.option_map
          (Aws.Json.lookup j "state")
          CancelSpotInstanceRequestState.of_json
    }
end

module GetPasswordDataRequest = struct
  type t =
    { instance_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~instance_id ?dry_run () = { instance_id; dry_run }

  let parse xml =
    Some
      { instance_id =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("InstanceId", String.to_json v.instance_id)
         ])

  let of_json j =
    { instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module ServiceState = struct
  type t =
    | Pending
    | Available
    | Deleting
    | Deleted
    | Failed

  let str_to_t =
    [ "Failed", Failed
    ; "Deleted", Deleted
    ; "Deleting", Deleting
    ; "Available", Available
    ; "Pending", Pending
    ]

  let t_to_str =
    [ Failed, "Failed"
    ; Deleted, "Deleted"
    ; Deleting, "Deleting"
    ; Available, "Available"
    ; Pending, "Pending"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module TransitGatewayMulticastRegisteredGroupSources = struct
  type t =
    { transit_gateway_multicast_domain_id : String.t option
    ; registered_network_interface_ids : ValueStringList.t
    ; group_ip_address : String.t option
    }

  let make
      ?transit_gateway_multicast_domain_id
      ?(registered_network_interface_ids = [])
      ?group_ip_address
      () =
    { transit_gateway_multicast_domain_id
    ; registered_network_interface_ids
    ; group_ip_address
    }

  let parse xml =
    Some
      { transit_gateway_multicast_domain_id =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayMulticastDomainId" xml)
            String.parse
      ; registered_network_interface_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "registeredNetworkInterfaceIds" xml)
               ValueStringList.parse)
      ; group_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "groupIpAddress" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.group_ip_address (fun f ->
               Aws.Query.Pair ("GroupIpAddress", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "RegisteredNetworkInterfaceIds"
                , ValueStringList.to_query v.registered_network_interface_ids ))
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               Aws.Query.Pair ("TransitGatewayMulticastDomainId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.group_ip_address (fun f ->
               "groupIpAddress", String.to_json f)
         ; Some
             ( "registeredNetworkInterfaceIds"
             , ValueStringList.to_json v.registered_network_interface_ids )
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               "transitGatewayMulticastDomainId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_multicast_domain_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayMulticastDomainId")
          String.of_json
    ; registered_network_interface_ids =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "registeredNetworkInterfaceIds"))
    ; group_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "groupIpAddress") String.of_json
    }
end

module TargetConfigurationRequest = struct
  type t =
    { instance_count : Integer.t option
    ; offering_id : String.t
    }

  let make ?instance_count ~offering_id () = { instance_count; offering_id }

  let parse xml =
    Some
      { instance_count =
          Aws.Util.option_bind (Aws.Xml.member "InstanceCount" xml) Integer.parse
      ; offering_id =
          Aws.Xml.required
            "OfferingId"
            (Aws.Util.option_bind (Aws.Xml.member "OfferingId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("OfferingId", String.to_query v.offering_id))
         ; Aws.Util.option_map v.instance_count (fun f ->
               Aws.Query.Pair ("InstanceCount", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("OfferingId", String.to_json v.offering_id)
         ; Aws.Util.option_map v.instance_count (fun f ->
               "InstanceCount", Integer.to_json f)
         ])

  let of_json j =
    { instance_count =
        Aws.Util.option_map (Aws.Json.lookup j "InstanceCount") Integer.of_json
    ; offering_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "OfferingId"))
    }
end

module TargetConfigurationRequestSet = struct
  type t = TargetConfigurationRequest.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         TargetConfigurationRequest.parse
         (Aws.Xml.members "TargetConfigurationRequest" xml))

  let to_query v = Aws.Query.to_query_list TargetConfigurationRequest.to_query v

  let to_json v = `List (List.map TargetConfigurationRequest.to_json v)

  let of_json j = Aws.Json.to_list TargetConfigurationRequest.of_json j
end

module ReservedInstanceIdSet = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "ReservedInstanceId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module GetReservedInstancesExchangeQuoteRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; reserved_instance_ids : ReservedInstanceIdSet.t
    ; target_configurations : TargetConfigurationRequestSet.t
    }

  let make ?dry_run ~reserved_instance_ids ?(target_configurations = []) () =
    { dry_run; reserved_instance_ids; target_configurations }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; reserved_instance_ids =
          Aws.Xml.required
            "ReservedInstanceId"
            (Aws.Util.option_bind
               (Aws.Xml.member "ReservedInstanceId" xml)
               ReservedInstanceIdSet.parse)
      ; target_configurations =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TargetConfiguration" xml)
               TargetConfigurationRequestSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "TargetConfiguration"
                , TargetConfigurationRequestSet.to_query v.target_configurations ))
         ; Some
             (Aws.Query.Pair
                ( "ReservedInstanceId"
                , ReservedInstanceIdSet.to_query v.reserved_instance_ids ))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "TargetConfiguration"
             , TargetConfigurationRequestSet.to_json v.target_configurations )
         ; Some
             ("ReservedInstanceId", ReservedInstanceIdSet.to_json v.reserved_instance_ids)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; reserved_instance_ids =
        ReservedInstanceIdSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ReservedInstanceId"))
    ; target_configurations =
        TargetConfigurationRequestSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TargetConfiguration"))
    }
end

module AssociationIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "AssociationId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module SpotInstanceStatus = struct
  type t =
    { code : String.t option
    ; message : String.t option
    ; update_time : DateTime.t option
    }

  let make ?code ?message ?update_time () = { code; message; update_time }

  let parse xml =
    Some
      { code = Aws.Util.option_bind (Aws.Xml.member "code" xml) String.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse
      ; update_time =
          Aws.Util.option_bind (Aws.Xml.member "updateTime" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.update_time (fun f ->
               Aws.Query.Pair ("UpdateTime", DateTime.to_query f))
         ; Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair ("Code", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.update_time (fun f -> "updateTime", DateTime.to_json f)
         ; Aws.Util.option_map v.message (fun f -> "message", String.to_json f)
         ; Aws.Util.option_map v.code (fun f -> "code", String.to_json f)
         ])

  let of_json j =
    { code = Aws.Util.option_map (Aws.Json.lookup j "code") String.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json
    ; update_time = Aws.Util.option_map (Aws.Json.lookup j "updateTime") DateTime.of_json
    }
end

module SpotInstanceState = struct
  type t =
    | Open
    | Active
    | Closed
    | Cancelled
    | Failed

  let str_to_t =
    [ "failed", Failed
    ; "cancelled", Cancelled
    ; "closed", Closed
    ; "active", Active
    ; "open", Open
    ]

  let t_to_str =
    [ Failed, "failed"
    ; Cancelled, "cancelled"
    ; Closed, "closed"
    ; Active, "active"
    ; Open, "open"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module RIProductDescription = struct
  type t =
    | Linux_UNIX
    | Linux_UNIX__Amazon_VPC_
    | Windows
    | Windows__Amazon_VPC_

  let str_to_t =
    [ "Windows (Amazon VPC)", Windows__Amazon_VPC_
    ; "Windows", Windows
    ; "Linux/UNIX (Amazon VPC)", Linux_UNIX__Amazon_VPC_
    ; "Linux/UNIX", Linux_UNIX
    ]

  let t_to_str =
    [ Windows__Amazon_VPC_, "Windows (Amazon VPC)"
    ; Windows, "Windows"
    ; Linux_UNIX__Amazon_VPC_, "Linux/UNIX (Amazon VPC)"
    ; Linux_UNIX, "Linux/UNIX"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module RunInstancesMonitoringEnabled = struct
  type t = { enabled : Boolean.t }

  let make ~enabled () = { enabled }

  let parse xml =
    Some
      { enabled =
          Aws.Xml.required
            "enabled"
            (Aws.Util.option_bind (Aws.Xml.member "enabled" xml) Boolean.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Enabled", Boolean.to_query v.enabled)) ])

  let to_json v =
    `Assoc (Aws.Util.list_filter_opt [ Some ("enabled", Boolean.to_json v.enabled) ])

  let of_json j =
    { enabled = Boolean.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "enabled")) }
end

module LaunchSpecification = struct
  type t =
    { user_data : String.t option
    ; security_groups : GroupIdentifierList.t
    ; addressing_type : String.t option
    ; block_device_mappings : BlockDeviceMappingList.t
    ; ebs_optimized : Boolean.t option
    ; iam_instance_profile : IamInstanceProfileSpecification.t option
    ; image_id : String.t option
    ; instance_type : InstanceType.t option
    ; kernel_id : String.t option
    ; key_name : String.t option
    ; network_interfaces : InstanceNetworkInterfaceSpecificationList.t
    ; placement : SpotPlacement.t option
    ; ramdisk_id : String.t option
    ; subnet_id : String.t option
    ; monitoring : RunInstancesMonitoringEnabled.t option
    }

  let make
      ?user_data
      ?(security_groups = [])
      ?addressing_type
      ?(block_device_mappings = [])
      ?ebs_optimized
      ?iam_instance_profile
      ?image_id
      ?instance_type
      ?kernel_id
      ?key_name
      ?(network_interfaces = [])
      ?placement
      ?ramdisk_id
      ?subnet_id
      ?monitoring
      () =
    { user_data
    ; security_groups
    ; addressing_type
    ; block_device_mappings
    ; ebs_optimized
    ; iam_instance_profile
    ; image_id
    ; instance_type
    ; kernel_id
    ; key_name
    ; network_interfaces
    ; placement
    ; ramdisk_id
    ; subnet_id
    ; monitoring
    }

  let parse xml =
    Some
      { user_data = Aws.Util.option_bind (Aws.Xml.member "userData" xml) String.parse
      ; security_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "groupSet" xml)
               GroupIdentifierList.parse)
      ; addressing_type =
          Aws.Util.option_bind (Aws.Xml.member "addressingType" xml) String.parse
      ; block_device_mappings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "blockDeviceMapping" xml)
               BlockDeviceMappingList.parse)
      ; ebs_optimized =
          Aws.Util.option_bind (Aws.Xml.member "ebsOptimized" xml) Boolean.parse
      ; iam_instance_profile =
          Aws.Util.option_bind
            (Aws.Xml.member "iamInstanceProfile" xml)
            IamInstanceProfileSpecification.parse
      ; image_id = Aws.Util.option_bind (Aws.Xml.member "imageId" xml) String.parse
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) InstanceType.parse
      ; kernel_id = Aws.Util.option_bind (Aws.Xml.member "kernelId" xml) String.parse
      ; key_name = Aws.Util.option_bind (Aws.Xml.member "keyName" xml) String.parse
      ; network_interfaces =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "networkInterfaceSet" xml)
               InstanceNetworkInterfaceSpecificationList.parse)
      ; placement =
          Aws.Util.option_bind (Aws.Xml.member "placement" xml) SpotPlacement.parse
      ; ramdisk_id = Aws.Util.option_bind (Aws.Xml.member "ramdiskId" xml) String.parse
      ; subnet_id = Aws.Util.option_bind (Aws.Xml.member "subnetId" xml) String.parse
      ; monitoring =
          Aws.Util.option_bind
            (Aws.Xml.member "monitoring" xml)
            RunInstancesMonitoringEnabled.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.monitoring (fun f ->
               Aws.Query.Pair ("Monitoring", RunInstancesMonitoringEnabled.to_query f))
         ; Aws.Util.option_map v.subnet_id (fun f ->
               Aws.Query.Pair ("SubnetId", String.to_query f))
         ; Aws.Util.option_map v.ramdisk_id (fun f ->
               Aws.Query.Pair ("RamdiskId", String.to_query f))
         ; Aws.Util.option_map v.placement (fun f ->
               Aws.Query.Pair ("Placement", SpotPlacement.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "NetworkInterfaceSet"
                , InstanceNetworkInterfaceSpecificationList.to_query v.network_interfaces
                ))
         ; Aws.Util.option_map v.key_name (fun f ->
               Aws.Query.Pair ("KeyName", String.to_query f))
         ; Aws.Util.option_map v.kernel_id (fun f ->
               Aws.Query.Pair ("KernelId", String.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", InstanceType.to_query f))
         ; Aws.Util.option_map v.image_id (fun f ->
               Aws.Query.Pair ("ImageId", String.to_query f))
         ; Aws.Util.option_map v.iam_instance_profile (fun f ->
               Aws.Query.Pair
                 ("IamInstanceProfile", IamInstanceProfileSpecification.to_query f))
         ; Aws.Util.option_map v.ebs_optimized (fun f ->
               Aws.Query.Pair ("EbsOptimized", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "BlockDeviceMapping"
                , BlockDeviceMappingList.to_query v.block_device_mappings ))
         ; Aws.Util.option_map v.addressing_type (fun f ->
               Aws.Query.Pair ("AddressingType", String.to_query f))
         ; Some
             (Aws.Query.Pair ("GroupSet", GroupIdentifierList.to_query v.security_groups))
         ; Aws.Util.option_map v.user_data (fun f ->
               Aws.Query.Pair ("UserData", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.monitoring (fun f ->
               "monitoring", RunInstancesMonitoringEnabled.to_json f)
         ; Aws.Util.option_map v.subnet_id (fun f -> "subnetId", String.to_json f)
         ; Aws.Util.option_map v.ramdisk_id (fun f -> "ramdiskId", String.to_json f)
         ; Aws.Util.option_map v.placement (fun f -> "placement", SpotPlacement.to_json f)
         ; Some
             ( "networkInterfaceSet"
             , InstanceNetworkInterfaceSpecificationList.to_json v.network_interfaces )
         ; Aws.Util.option_map v.key_name (fun f -> "keyName", String.to_json f)
         ; Aws.Util.option_map v.kernel_id (fun f -> "kernelId", String.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f ->
               "instanceType", InstanceType.to_json f)
         ; Aws.Util.option_map v.image_id (fun f -> "imageId", String.to_json f)
         ; Aws.Util.option_map v.iam_instance_profile (fun f ->
               "iamInstanceProfile", IamInstanceProfileSpecification.to_json f)
         ; Aws.Util.option_map v.ebs_optimized (fun f ->
               "ebsOptimized", Boolean.to_json f)
         ; Some
             ("blockDeviceMapping", BlockDeviceMappingList.to_json v.block_device_mappings)
         ; Aws.Util.option_map v.addressing_type (fun f ->
               "addressingType", String.to_json f)
         ; Some ("groupSet", GroupIdentifierList.to_json v.security_groups)
         ; Aws.Util.option_map v.user_data (fun f -> "userData", String.to_json f)
         ])

  let of_json j =
    { user_data = Aws.Util.option_map (Aws.Json.lookup j "userData") String.of_json
    ; security_groups =
        GroupIdentifierList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "groupSet"))
    ; addressing_type =
        Aws.Util.option_map (Aws.Json.lookup j "addressingType") String.of_json
    ; block_device_mappings =
        BlockDeviceMappingList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "blockDeviceMapping"))
    ; ebs_optimized =
        Aws.Util.option_map (Aws.Json.lookup j "ebsOptimized") Boolean.of_json
    ; iam_instance_profile =
        Aws.Util.option_map
          (Aws.Json.lookup j "iamInstanceProfile")
          IamInstanceProfileSpecification.of_json
    ; image_id = Aws.Util.option_map (Aws.Json.lookup j "imageId") String.of_json
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") InstanceType.of_json
    ; kernel_id = Aws.Util.option_map (Aws.Json.lookup j "kernelId") String.of_json
    ; key_name = Aws.Util.option_map (Aws.Json.lookup j "keyName") String.of_json
    ; network_interfaces =
        InstanceNetworkInterfaceSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "networkInterfaceSet"))
    ; placement =
        Aws.Util.option_map (Aws.Json.lookup j "placement") SpotPlacement.of_json
    ; ramdisk_id = Aws.Util.option_map (Aws.Json.lookup j "ramdiskId") String.of_json
    ; subnet_id = Aws.Util.option_map (Aws.Json.lookup j "subnetId") String.of_json
    ; monitoring =
        Aws.Util.option_map
          (Aws.Json.lookup j "monitoring")
          RunInstancesMonitoringEnabled.of_json
    }
end

module SpotInstanceRequest = struct
  type t =
    { actual_block_hourly_price : String.t option
    ; availability_zone_group : String.t option
    ; block_duration_minutes : Integer.t option
    ; create_time : DateTime.t option
    ; fault : SpotInstanceStateFault.t option
    ; instance_id : String.t option
    ; launch_group : String.t option
    ; launch_specification : LaunchSpecification.t option
    ; launched_availability_zone : String.t option
    ; product_description : RIProductDescription.t option
    ; spot_instance_request_id : String.t option
    ; spot_price : String.t option
    ; state : SpotInstanceState.t option
    ; status : SpotInstanceStatus.t option
    ; tags : TagList.t
    ; type_ : SpotInstanceType.t option
    ; valid_from : DateTime.t option
    ; valid_until : DateTime.t option
    ; instance_interruption_behavior : InstanceInterruptionBehavior.t option
    }

  let make
      ?actual_block_hourly_price
      ?availability_zone_group
      ?block_duration_minutes
      ?create_time
      ?fault
      ?instance_id
      ?launch_group
      ?launch_specification
      ?launched_availability_zone
      ?product_description
      ?spot_instance_request_id
      ?spot_price
      ?state
      ?status
      ?(tags = [])
      ?type_
      ?valid_from
      ?valid_until
      ?instance_interruption_behavior
      () =
    { actual_block_hourly_price
    ; availability_zone_group
    ; block_duration_minutes
    ; create_time
    ; fault
    ; instance_id
    ; launch_group
    ; launch_specification
    ; launched_availability_zone
    ; product_description
    ; spot_instance_request_id
    ; spot_price
    ; state
    ; status
    ; tags
    ; type_
    ; valid_from
    ; valid_until
    ; instance_interruption_behavior
    }

  let parse xml =
    Some
      { actual_block_hourly_price =
          Aws.Util.option_bind (Aws.Xml.member "actualBlockHourlyPrice" xml) String.parse
      ; availability_zone_group =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZoneGroup" xml) String.parse
      ; block_duration_minutes =
          Aws.Util.option_bind (Aws.Xml.member "blockDurationMinutes" xml) Integer.parse
      ; create_time =
          Aws.Util.option_bind (Aws.Xml.member "createTime" xml) DateTime.parse
      ; fault =
          Aws.Util.option_bind (Aws.Xml.member "fault" xml) SpotInstanceStateFault.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      ; launch_group =
          Aws.Util.option_bind (Aws.Xml.member "launchGroup" xml) String.parse
      ; launch_specification =
          Aws.Util.option_bind
            (Aws.Xml.member "launchSpecification" xml)
            LaunchSpecification.parse
      ; launched_availability_zone =
          Aws.Util.option_bind
            (Aws.Xml.member "launchedAvailabilityZone" xml)
            String.parse
      ; product_description =
          Aws.Util.option_bind
            (Aws.Xml.member "productDescription" xml)
            RIProductDescription.parse
      ; spot_instance_request_id =
          Aws.Util.option_bind (Aws.Xml.member "spotInstanceRequestId" xml) String.parse
      ; spot_price = Aws.Util.option_bind (Aws.Xml.member "spotPrice" xml) String.parse
      ; state = Aws.Util.option_bind (Aws.Xml.member "state" xml) SpotInstanceState.parse
      ; status =
          Aws.Util.option_bind (Aws.Xml.member "status" xml) SpotInstanceStatus.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      ; type_ = Aws.Util.option_bind (Aws.Xml.member "type" xml) SpotInstanceType.parse
      ; valid_from = Aws.Util.option_bind (Aws.Xml.member "validFrom" xml) DateTime.parse
      ; valid_until =
          Aws.Util.option_bind (Aws.Xml.member "validUntil" xml) DateTime.parse
      ; instance_interruption_behavior =
          Aws.Util.option_bind
            (Aws.Xml.member "instanceInterruptionBehavior" xml)
            InstanceInterruptionBehavior.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_interruption_behavior (fun f ->
               Aws.Query.Pair
                 ("InstanceInterruptionBehavior", InstanceInterruptionBehavior.to_query f))
         ; Aws.Util.option_map v.valid_until (fun f ->
               Aws.Query.Pair ("ValidUntil", DateTime.to_query f))
         ; Aws.Util.option_map v.valid_from (fun f ->
               Aws.Query.Pair ("ValidFrom", DateTime.to_query f))
         ; Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", SpotInstanceType.to_query f))
         ; Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", SpotInstanceStatus.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", SpotInstanceState.to_query f))
         ; Aws.Util.option_map v.spot_price (fun f ->
               Aws.Query.Pair ("SpotPrice", String.to_query f))
         ; Aws.Util.option_map v.spot_instance_request_id (fun f ->
               Aws.Query.Pair ("SpotInstanceRequestId", String.to_query f))
         ; Aws.Util.option_map v.product_description (fun f ->
               Aws.Query.Pair ("ProductDescription", RIProductDescription.to_query f))
         ; Aws.Util.option_map v.launched_availability_zone (fun f ->
               Aws.Query.Pair ("LaunchedAvailabilityZone", String.to_query f))
         ; Aws.Util.option_map v.launch_specification (fun f ->
               Aws.Query.Pair ("LaunchSpecification", LaunchSpecification.to_query f))
         ; Aws.Util.option_map v.launch_group (fun f ->
               Aws.Query.Pair ("LaunchGroup", String.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.fault (fun f ->
               Aws.Query.Pair ("Fault", SpotInstanceStateFault.to_query f))
         ; Aws.Util.option_map v.create_time (fun f ->
               Aws.Query.Pair ("CreateTime", DateTime.to_query f))
         ; Aws.Util.option_map v.block_duration_minutes (fun f ->
               Aws.Query.Pair ("BlockDurationMinutes", Integer.to_query f))
         ; Aws.Util.option_map v.availability_zone_group (fun f ->
               Aws.Query.Pair ("AvailabilityZoneGroup", String.to_query f))
         ; Aws.Util.option_map v.actual_block_hourly_price (fun f ->
               Aws.Query.Pair ("ActualBlockHourlyPrice", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_interruption_behavior (fun f ->
               "instanceInterruptionBehavior", InstanceInterruptionBehavior.to_json f)
         ; Aws.Util.option_map v.valid_until (fun f -> "validUntil", DateTime.to_json f)
         ; Aws.Util.option_map v.valid_from (fun f -> "validFrom", DateTime.to_json f)
         ; Aws.Util.option_map v.type_ (fun f -> "type", SpotInstanceType.to_json f)
         ; Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.status (fun f -> "status", SpotInstanceStatus.to_json f)
         ; Aws.Util.option_map v.state (fun f -> "state", SpotInstanceState.to_json f)
         ; Aws.Util.option_map v.spot_price (fun f -> "spotPrice", String.to_json f)
         ; Aws.Util.option_map v.spot_instance_request_id (fun f ->
               "spotInstanceRequestId", String.to_json f)
         ; Aws.Util.option_map v.product_description (fun f ->
               "productDescription", RIProductDescription.to_json f)
         ; Aws.Util.option_map v.launched_availability_zone (fun f ->
               "launchedAvailabilityZone", String.to_json f)
         ; Aws.Util.option_map v.launch_specification (fun f ->
               "launchSpecification", LaunchSpecification.to_json f)
         ; Aws.Util.option_map v.launch_group (fun f -> "launchGroup", String.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ; Aws.Util.option_map v.fault (fun f ->
               "fault", SpotInstanceStateFault.to_json f)
         ; Aws.Util.option_map v.create_time (fun f -> "createTime", DateTime.to_json f)
         ; Aws.Util.option_map v.block_duration_minutes (fun f ->
               "blockDurationMinutes", Integer.to_json f)
         ; Aws.Util.option_map v.availability_zone_group (fun f ->
               "availabilityZoneGroup", String.to_json f)
         ; Aws.Util.option_map v.actual_block_hourly_price (fun f ->
               "actualBlockHourlyPrice", String.to_json f)
         ])

  let of_json j =
    { actual_block_hourly_price =
        Aws.Util.option_map (Aws.Json.lookup j "actualBlockHourlyPrice") String.of_json
    ; availability_zone_group =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZoneGroup") String.of_json
    ; block_duration_minutes =
        Aws.Util.option_map (Aws.Json.lookup j "blockDurationMinutes") Integer.of_json
    ; create_time = Aws.Util.option_map (Aws.Json.lookup j "createTime") DateTime.of_json
    ; fault =
        Aws.Util.option_map (Aws.Json.lookup j "fault") SpotInstanceStateFault.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    ; launch_group = Aws.Util.option_map (Aws.Json.lookup j "launchGroup") String.of_json
    ; launch_specification =
        Aws.Util.option_map
          (Aws.Json.lookup j "launchSpecification")
          LaunchSpecification.of_json
    ; launched_availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "launchedAvailabilityZone") String.of_json
    ; product_description =
        Aws.Util.option_map
          (Aws.Json.lookup j "productDescription")
          RIProductDescription.of_json
    ; spot_instance_request_id =
        Aws.Util.option_map (Aws.Json.lookup j "spotInstanceRequestId") String.of_json
    ; spot_price = Aws.Util.option_map (Aws.Json.lookup j "spotPrice") String.of_json
    ; state = Aws.Util.option_map (Aws.Json.lookup j "state") SpotInstanceState.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "status") SpotInstanceStatus.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    ; type_ = Aws.Util.option_map (Aws.Json.lookup j "type") SpotInstanceType.of_json
    ; valid_from = Aws.Util.option_map (Aws.Json.lookup j "validFrom") DateTime.of_json
    ; valid_until = Aws.Util.option_map (Aws.Json.lookup j "validUntil") DateTime.of_json
    ; instance_interruption_behavior =
        Aws.Util.option_map
          (Aws.Json.lookup j "instanceInterruptionBehavior")
          InstanceInterruptionBehavior.of_json
    }
end

module SpotInstanceRequestList = struct
  type t = SpotInstanceRequest.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map SpotInstanceRequest.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list SpotInstanceRequest.to_query v

  let to_json v = `List (List.map SpotInstanceRequest.to_json v)

  let of_json j = Aws.Json.to_list SpotInstanceRequest.of_json j
end

module NetworkInterfaceCreationType = struct
  type t = Efa

  let str_to_t = [ "efa", Efa ]

  let t_to_str = [ Efa, "efa" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module CreateNetworkInterfaceRequest = struct
  type t =
    { description : String.t option
    ; dry_run : Boolean.t option
    ; groups : SecurityGroupIdStringList.t
    ; ipv6_address_count : Integer.t option
    ; ipv6_addresses : InstanceIpv6AddressList.t
    ; private_ip_address : String.t option
    ; private_ip_addresses : PrivateIpAddressSpecificationList.t
    ; secondary_private_ip_address_count : Integer.t option
    ; interface_type : NetworkInterfaceCreationType.t option
    ; subnet_id : String.t
    ; tag_specifications : TagSpecificationList.t
    }

  let make
      ?description
      ?dry_run
      ?(groups = [])
      ?ipv6_address_count
      ?(ipv6_addresses = [])
      ?private_ip_address
      ?(private_ip_addresses = [])
      ?secondary_private_ip_address_count
      ?interface_type
      ~subnet_id
      ?(tag_specifications = [])
      () =
    { description
    ; dry_run
    ; groups
    ; ipv6_address_count
    ; ipv6_addresses
    ; private_ip_address
    ; private_ip_addresses
    ; secondary_private_ip_address_count
    ; interface_type
    ; subnet_id
    ; tag_specifications
    }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SecurityGroupId" xml)
               SecurityGroupIdStringList.parse)
      ; ipv6_address_count =
          Aws.Util.option_bind (Aws.Xml.member "ipv6AddressCount" xml) Integer.parse
      ; ipv6_addresses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ipv6Addresses" xml)
               InstanceIpv6AddressList.parse)
      ; private_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "privateIpAddress" xml) String.parse
      ; private_ip_addresses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "privateIpAddresses" xml)
               PrivateIpAddressSpecificationList.parse)
      ; secondary_private_ip_address_count =
          Aws.Util.option_bind
            (Aws.Xml.member "secondaryPrivateIpAddressCount" xml)
            Integer.parse
      ; interface_type =
          Aws.Util.option_bind
            (Aws.Xml.member "InterfaceType" xml)
            NetworkInterfaceCreationType.parse
      ; subnet_id =
          Aws.Xml.required
            "subnetId"
            (Aws.Util.option_bind (Aws.Xml.member "subnetId" xml) String.parse)
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Some (Aws.Query.Pair ("SubnetId", String.to_query v.subnet_id))
         ; Aws.Util.option_map v.interface_type (fun f ->
               Aws.Query.Pair ("InterfaceType", NetworkInterfaceCreationType.to_query f))
         ; Aws.Util.option_map v.secondary_private_ip_address_count (fun f ->
               Aws.Query.Pair ("SecondaryPrivateIpAddressCount", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "PrivateIpAddresses"
                , PrivateIpAddressSpecificationList.to_query v.private_ip_addresses ))
         ; Aws.Util.option_map v.private_ip_address (fun f ->
               Aws.Query.Pair ("PrivateIpAddress", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Ipv6Addresses", InstanceIpv6AddressList.to_query v.ipv6_addresses))
         ; Aws.Util.option_map v.ipv6_address_count (fun f ->
               Aws.Query.Pair ("Ipv6AddressCount", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("SecurityGroupId", SecurityGroupIdStringList.to_query v.groups))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Some ("subnetId", String.to_json v.subnet_id)
         ; Aws.Util.option_map v.interface_type (fun f ->
               "InterfaceType", NetworkInterfaceCreationType.to_json f)
         ; Aws.Util.option_map v.secondary_private_ip_address_count (fun f ->
               "secondaryPrivateIpAddressCount", Integer.to_json f)
         ; Some
             ( "privateIpAddresses"
             , PrivateIpAddressSpecificationList.to_json v.private_ip_addresses )
         ; Aws.Util.option_map v.private_ip_address (fun f ->
               "privateIpAddress", String.to_json f)
         ; Some ("ipv6Addresses", InstanceIpv6AddressList.to_json v.ipv6_addresses)
         ; Aws.Util.option_map v.ipv6_address_count (fun f ->
               "ipv6AddressCount", Integer.to_json f)
         ; Some ("SecurityGroupId", SecurityGroupIdStringList.to_json v.groups)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; groups =
        SecurityGroupIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SecurityGroupId"))
    ; ipv6_address_count =
        Aws.Util.option_map (Aws.Json.lookup j "ipv6AddressCount") Integer.of_json
    ; ipv6_addresses =
        InstanceIpv6AddressList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ipv6Addresses"))
    ; private_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "privateIpAddress") String.of_json
    ; private_ip_addresses =
        PrivateIpAddressSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "privateIpAddresses"))
    ; secondary_private_ip_address_count =
        Aws.Util.option_map
          (Aws.Json.lookup j "secondaryPrivateIpAddressCount")
          Integer.of_json
    ; interface_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "InterfaceType")
          NetworkInterfaceCreationType.of_json
    ; subnet_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "subnetId"))
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    }
end

module DescribeLaunchTemplateVersionsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; launch_template_id : String.t option
    ; launch_template_name : String.t option
    ; versions : VersionStringList.t
    ; min_version : String.t option
    ; max_version : String.t option
    ; next_token : String.t option
    ; max_results : Integer.t option
    ; filters : FilterList.t
    }

  let make
      ?dry_run
      ?launch_template_id
      ?launch_template_name
      ?(versions = [])
      ?min_version
      ?max_version
      ?next_token
      ?max_results
      ?(filters = [])
      () =
    { dry_run
    ; launch_template_id
    ; launch_template_name
    ; versions
    ; min_version
    ; max_version
    ; next_token
    ; max_results
    ; filters
    }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; launch_template_id =
          Aws.Util.option_bind (Aws.Xml.member "LaunchTemplateId" xml) String.parse
      ; launch_template_name =
          Aws.Util.option_bind (Aws.Xml.member "LaunchTemplateName" xml) String.parse
      ; versions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "LaunchTemplateVersion" xml)
               VersionStringList.parse)
      ; min_version = Aws.Util.option_bind (Aws.Xml.member "MinVersion" xml) String.parse
      ; max_version = Aws.Util.option_bind (Aws.Xml.member "MaxVersion" xml) String.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_version (fun f ->
               Aws.Query.Pair ("MaxVersion", String.to_query f))
         ; Aws.Util.option_map v.min_version (fun f ->
               Aws.Query.Pair ("MinVersion", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("LaunchTemplateVersion", VersionStringList.to_query v.versions))
         ; Aws.Util.option_map v.launch_template_name (fun f ->
               Aws.Query.Pair ("LaunchTemplateName", String.to_query f))
         ; Aws.Util.option_map v.launch_template_id (fun f ->
               Aws.Query.Pair ("LaunchTemplateId", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Filter", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_version (fun f -> "MaxVersion", String.to_json f)
         ; Aws.Util.option_map v.min_version (fun f -> "MinVersion", String.to_json f)
         ; Some ("LaunchTemplateVersion", VersionStringList.to_json v.versions)
         ; Aws.Util.option_map v.launch_template_name (fun f ->
               "LaunchTemplateName", String.to_json f)
         ; Aws.Util.option_map v.launch_template_id (fun f ->
               "LaunchTemplateId", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; launch_template_id =
        Aws.Util.option_map (Aws.Json.lookup j "LaunchTemplateId") String.of_json
    ; launch_template_name =
        Aws.Util.option_map (Aws.Json.lookup j "LaunchTemplateName") String.of_json
    ; versions =
        VersionStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "LaunchTemplateVersion"))
    ; min_version = Aws.Util.option_map (Aws.Json.lookup j "MinVersion") String.of_json
    ; max_version = Aws.Util.option_map (Aws.Json.lookup j "MaxVersion") String.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    }
end

module PrincipalIdFormat = struct
  type t =
    { arn : String.t option
    ; statuses : IdFormatList.t
    }

  let make ?arn ?(statuses = []) () = { arn; statuses }

  let parse xml =
    Some
      { arn = Aws.Util.option_bind (Aws.Xml.member "arn" xml) String.parse
      ; statuses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "statusSet" xml) IdFormatList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("StatusSet", IdFormatList.to_query v.statuses))
         ; Aws.Util.option_map v.arn (fun f -> Aws.Query.Pair ("Arn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("statusSet", IdFormatList.to_json v.statuses)
         ; Aws.Util.option_map v.arn (fun f -> "arn", String.to_json f)
         ])

  let of_json j =
    { arn = Aws.Util.option_map (Aws.Json.lookup j "arn") String.of_json
    ; statuses =
        IdFormatList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "statusSet"))
    }
end

module ReservedInstancesId = struct
  type t = { reserved_instances_id : String.t option }

  let make ?reserved_instances_id () = { reserved_instances_id }

  let parse xml =
    Some
      { reserved_instances_id =
          Aws.Util.option_bind (Aws.Xml.member "reservedInstancesId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.reserved_instances_id (fun f ->
               Aws.Query.Pair ("ReservedInstancesId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.reserved_instances_id (fun f ->
               "reservedInstancesId", String.to_json f)
         ])

  let of_json j =
    { reserved_instances_id =
        Aws.Util.option_map (Aws.Json.lookup j "reservedInstancesId") String.of_json
    }
end

module DetachNetworkInterfaceRequest = struct
  type t =
    { attachment_id : String.t
    ; dry_run : Boolean.t option
    ; force : Boolean.t option
    }

  let make ~attachment_id ?dry_run ?force () = { attachment_id; dry_run; force }

  let parse xml =
    Some
      { attachment_id =
          Aws.Xml.required
            "attachmentId"
            (Aws.Util.option_bind (Aws.Xml.member "attachmentId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; force = Aws.Util.option_bind (Aws.Xml.member "force" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.force (fun f ->
               Aws.Query.Pair ("Force", Boolean.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("AttachmentId", String.to_query v.attachment_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.force (fun f -> "force", Boolean.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("attachmentId", String.to_json v.attachment_id)
         ])

  let of_json j =
    { attachment_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "attachmentId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; force = Aws.Util.option_map (Aws.Json.lookup j "force") Boolean.of_json
    }
end

module TrafficMirrorSession = struct
  type t =
    { traffic_mirror_session_id : String.t option
    ; traffic_mirror_target_id : String.t option
    ; traffic_mirror_filter_id : String.t option
    ; network_interface_id : String.t option
    ; owner_id : String.t option
    ; packet_length : Integer.t option
    ; session_number : Integer.t option
    ; virtual_network_id : Integer.t option
    ; description : String.t option
    ; tags : TagList.t
    }

  let make
      ?traffic_mirror_session_id
      ?traffic_mirror_target_id
      ?traffic_mirror_filter_id
      ?network_interface_id
      ?owner_id
      ?packet_length
      ?session_number
      ?virtual_network_id
      ?description
      ?(tags = [])
      () =
    { traffic_mirror_session_id
    ; traffic_mirror_target_id
    ; traffic_mirror_filter_id
    ; network_interface_id
    ; owner_id
    ; packet_length
    ; session_number
    ; virtual_network_id
    ; description
    ; tags
    }

  let parse xml =
    Some
      { traffic_mirror_session_id =
          Aws.Util.option_bind (Aws.Xml.member "trafficMirrorSessionId" xml) String.parse
      ; traffic_mirror_target_id =
          Aws.Util.option_bind (Aws.Xml.member "trafficMirrorTargetId" xml) String.parse
      ; traffic_mirror_filter_id =
          Aws.Util.option_bind (Aws.Xml.member "trafficMirrorFilterId" xml) String.parse
      ; network_interface_id =
          Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; packet_length =
          Aws.Util.option_bind (Aws.Xml.member "packetLength" xml) Integer.parse
      ; session_number =
          Aws.Util.option_bind (Aws.Xml.member "sessionNumber" xml) Integer.parse
      ; virtual_network_id =
          Aws.Util.option_bind (Aws.Xml.member "virtualNetworkId" xml) Integer.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.virtual_network_id (fun f ->
               Aws.Query.Pair ("VirtualNetworkId", Integer.to_query f))
         ; Aws.Util.option_map v.session_number (fun f ->
               Aws.Query.Pair ("SessionNumber", Integer.to_query f))
         ; Aws.Util.option_map v.packet_length (fun f ->
               Aws.Query.Pair ("PacketLength", Integer.to_query f))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               Aws.Query.Pair ("NetworkInterfaceId", String.to_query f))
         ; Aws.Util.option_map v.traffic_mirror_filter_id (fun f ->
               Aws.Query.Pair ("TrafficMirrorFilterId", String.to_query f))
         ; Aws.Util.option_map v.traffic_mirror_target_id (fun f ->
               Aws.Query.Pair ("TrafficMirrorTargetId", String.to_query f))
         ; Aws.Util.option_map v.traffic_mirror_session_id (fun f ->
               Aws.Query.Pair ("TrafficMirrorSessionId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Aws.Util.option_map v.virtual_network_id (fun f ->
               "virtualNetworkId", Integer.to_json f)
         ; Aws.Util.option_map v.session_number (fun f ->
               "sessionNumber", Integer.to_json f)
         ; Aws.Util.option_map v.packet_length (fun f ->
               "packetLength", Integer.to_json f)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               "networkInterfaceId", String.to_json f)
         ; Aws.Util.option_map v.traffic_mirror_filter_id (fun f ->
               "trafficMirrorFilterId", String.to_json f)
         ; Aws.Util.option_map v.traffic_mirror_target_id (fun f ->
               "trafficMirrorTargetId", String.to_json f)
         ; Aws.Util.option_map v.traffic_mirror_session_id (fun f ->
               "trafficMirrorSessionId", String.to_json f)
         ])

  let of_json j =
    { traffic_mirror_session_id =
        Aws.Util.option_map (Aws.Json.lookup j "trafficMirrorSessionId") String.of_json
    ; traffic_mirror_target_id =
        Aws.Util.option_map (Aws.Json.lookup j "trafficMirrorTargetId") String.of_json
    ; traffic_mirror_filter_id =
        Aws.Util.option_map (Aws.Json.lookup j "trafficMirrorFilterId") String.of_json
    ; network_interface_id =
        Aws.Util.option_map (Aws.Json.lookup j "networkInterfaceId") String.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; packet_length =
        Aws.Util.option_map (Aws.Json.lookup j "packetLength") Integer.of_json
    ; session_number =
        Aws.Util.option_map (Aws.Json.lookup j "sessionNumber") Integer.of_json
    ; virtual_network_id =
        Aws.Util.option_map (Aws.Json.lookup j "virtualNetworkId") Integer.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module TrafficMirrorSessionSet = struct
  type t = TrafficMirrorSession.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map TrafficMirrorSession.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list TrafficMirrorSession.to_query v

  let to_json v = `List (List.map TrafficMirrorSession.to_json v)

  let of_json j = Aws.Json.to_list TrafficMirrorSession.of_json j
end

module OccurrenceDaySet = struct
  type t = Integer.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Integer.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Integer.to_query v

  let to_json v = `List (List.map Integer.to_json v)

  let of_json j = Aws.Json.to_list Integer.of_json j
end

module ScheduledInstanceRecurrence = struct
  type t =
    { frequency : String.t option
    ; interval : Integer.t option
    ; occurrence_day_set : OccurrenceDaySet.t
    ; occurrence_relative_to_end : Boolean.t option
    ; occurrence_unit : String.t option
    }

  let make
      ?frequency
      ?interval
      ?(occurrence_day_set = [])
      ?occurrence_relative_to_end
      ?occurrence_unit
      () =
    { frequency
    ; interval
    ; occurrence_day_set
    ; occurrence_relative_to_end
    ; occurrence_unit
    }

  let parse xml =
    Some
      { frequency = Aws.Util.option_bind (Aws.Xml.member "frequency" xml) String.parse
      ; interval = Aws.Util.option_bind (Aws.Xml.member "interval" xml) Integer.parse
      ; occurrence_day_set =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "occurrenceDaySet" xml)
               OccurrenceDaySet.parse)
      ; occurrence_relative_to_end =
          Aws.Util.option_bind
            (Aws.Xml.member "occurrenceRelativeToEnd" xml)
            Boolean.parse
      ; occurrence_unit =
          Aws.Util.option_bind (Aws.Xml.member "occurrenceUnit" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.occurrence_unit (fun f ->
               Aws.Query.Pair ("OccurrenceUnit", String.to_query f))
         ; Aws.Util.option_map v.occurrence_relative_to_end (fun f ->
               Aws.Query.Pair ("OccurrenceRelativeToEnd", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("OccurrenceDaySet", OccurrenceDaySet.to_query v.occurrence_day_set))
         ; Aws.Util.option_map v.interval (fun f ->
               Aws.Query.Pair ("Interval", Integer.to_query f))
         ; Aws.Util.option_map v.frequency (fun f ->
               Aws.Query.Pair ("Frequency", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.occurrence_unit (fun f ->
               "occurrenceUnit", String.to_json f)
         ; Aws.Util.option_map v.occurrence_relative_to_end (fun f ->
               "occurrenceRelativeToEnd", Boolean.to_json f)
         ; Some ("occurrenceDaySet", OccurrenceDaySet.to_json v.occurrence_day_set)
         ; Aws.Util.option_map v.interval (fun f -> "interval", Integer.to_json f)
         ; Aws.Util.option_map v.frequency (fun f -> "frequency", String.to_json f)
         ])

  let of_json j =
    { frequency = Aws.Util.option_map (Aws.Json.lookup j "frequency") String.of_json
    ; interval = Aws.Util.option_map (Aws.Json.lookup j "interval") Integer.of_json
    ; occurrence_day_set =
        OccurrenceDaySet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "occurrenceDaySet"))
    ; occurrence_relative_to_end =
        Aws.Util.option_map (Aws.Json.lookup j "occurrenceRelativeToEnd") Boolean.of_json
    ; occurrence_unit =
        Aws.Util.option_map (Aws.Json.lookup j "occurrenceUnit") String.of_json
    }
end

module ScheduledInstanceAvailability = struct
  type t =
    { availability_zone : String.t option
    ; available_instance_count : Integer.t option
    ; first_slot_start_time : DateTime.t option
    ; hourly_price : String.t option
    ; instance_type : String.t option
    ; max_term_duration_in_days : Integer.t option
    ; min_term_duration_in_days : Integer.t option
    ; network_platform : String.t option
    ; platform : String.t option
    ; purchase_token : String.t option
    ; recurrence : ScheduledInstanceRecurrence.t option
    ; slot_duration_in_hours : Integer.t option
    ; total_scheduled_instance_hours : Integer.t option
    }

  let make
      ?availability_zone
      ?available_instance_count
      ?first_slot_start_time
      ?hourly_price
      ?instance_type
      ?max_term_duration_in_days
      ?min_term_duration_in_days
      ?network_platform
      ?platform
      ?purchase_token
      ?recurrence
      ?slot_duration_in_hours
      ?total_scheduled_instance_hours
      () =
    { availability_zone
    ; available_instance_count
    ; first_slot_start_time
    ; hourly_price
    ; instance_type
    ; max_term_duration_in_days
    ; min_term_duration_in_days
    ; network_platform
    ; platform
    ; purchase_token
    ; recurrence
    ; slot_duration_in_hours
    ; total_scheduled_instance_hours
    }

  let parse xml =
    Some
      { availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; available_instance_count =
          Aws.Util.option_bind (Aws.Xml.member "availableInstanceCount" xml) Integer.parse
      ; first_slot_start_time =
          Aws.Util.option_bind (Aws.Xml.member "firstSlotStartTime" xml) DateTime.parse
      ; hourly_price =
          Aws.Util.option_bind (Aws.Xml.member "hourlyPrice" xml) String.parse
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) String.parse
      ; max_term_duration_in_days =
          Aws.Util.option_bind (Aws.Xml.member "maxTermDurationInDays" xml) Integer.parse
      ; min_term_duration_in_days =
          Aws.Util.option_bind (Aws.Xml.member "minTermDurationInDays" xml) Integer.parse
      ; network_platform =
          Aws.Util.option_bind (Aws.Xml.member "networkPlatform" xml) String.parse
      ; platform = Aws.Util.option_bind (Aws.Xml.member "platform" xml) String.parse
      ; purchase_token =
          Aws.Util.option_bind (Aws.Xml.member "purchaseToken" xml) String.parse
      ; recurrence =
          Aws.Util.option_bind
            (Aws.Xml.member "recurrence" xml)
            ScheduledInstanceRecurrence.parse
      ; slot_duration_in_hours =
          Aws.Util.option_bind (Aws.Xml.member "slotDurationInHours" xml) Integer.parse
      ; total_scheduled_instance_hours =
          Aws.Util.option_bind
            (Aws.Xml.member "totalScheduledInstanceHours" xml)
            Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.total_scheduled_instance_hours (fun f ->
               Aws.Query.Pair ("TotalScheduledInstanceHours", Integer.to_query f))
         ; Aws.Util.option_map v.slot_duration_in_hours (fun f ->
               Aws.Query.Pair ("SlotDurationInHours", Integer.to_query f))
         ; Aws.Util.option_map v.recurrence (fun f ->
               Aws.Query.Pair ("Recurrence", ScheduledInstanceRecurrence.to_query f))
         ; Aws.Util.option_map v.purchase_token (fun f ->
               Aws.Query.Pair ("PurchaseToken", String.to_query f))
         ; Aws.Util.option_map v.platform (fun f ->
               Aws.Query.Pair ("Platform", String.to_query f))
         ; Aws.Util.option_map v.network_platform (fun f ->
               Aws.Query.Pair ("NetworkPlatform", String.to_query f))
         ; Aws.Util.option_map v.min_term_duration_in_days (fun f ->
               Aws.Query.Pair ("MinTermDurationInDays", Integer.to_query f))
         ; Aws.Util.option_map v.max_term_duration_in_days (fun f ->
               Aws.Query.Pair ("MaxTermDurationInDays", Integer.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", String.to_query f))
         ; Aws.Util.option_map v.hourly_price (fun f ->
               Aws.Query.Pair ("HourlyPrice", String.to_query f))
         ; Aws.Util.option_map v.first_slot_start_time (fun f ->
               Aws.Query.Pair ("FirstSlotStartTime", DateTime.to_query f))
         ; Aws.Util.option_map v.available_instance_count (fun f ->
               Aws.Query.Pair ("AvailableInstanceCount", Integer.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.total_scheduled_instance_hours (fun f ->
               "totalScheduledInstanceHours", Integer.to_json f)
         ; Aws.Util.option_map v.slot_duration_in_hours (fun f ->
               "slotDurationInHours", Integer.to_json f)
         ; Aws.Util.option_map v.recurrence (fun f ->
               "recurrence", ScheduledInstanceRecurrence.to_json f)
         ; Aws.Util.option_map v.purchase_token (fun f ->
               "purchaseToken", String.to_json f)
         ; Aws.Util.option_map v.platform (fun f -> "platform", String.to_json f)
         ; Aws.Util.option_map v.network_platform (fun f ->
               "networkPlatform", String.to_json f)
         ; Aws.Util.option_map v.min_term_duration_in_days (fun f ->
               "minTermDurationInDays", Integer.to_json f)
         ; Aws.Util.option_map v.max_term_duration_in_days (fun f ->
               "maxTermDurationInDays", Integer.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f -> "instanceType", String.to_json f)
         ; Aws.Util.option_map v.hourly_price (fun f -> "hourlyPrice", String.to_json f)
         ; Aws.Util.option_map v.first_slot_start_time (fun f ->
               "firstSlotStartTime", DateTime.to_json f)
         ; Aws.Util.option_map v.available_instance_count (fun f ->
               "availableInstanceCount", Integer.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ])

  let of_json j =
    { availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; available_instance_count =
        Aws.Util.option_map (Aws.Json.lookup j "availableInstanceCount") Integer.of_json
    ; first_slot_start_time =
        Aws.Util.option_map (Aws.Json.lookup j "firstSlotStartTime") DateTime.of_json
    ; hourly_price = Aws.Util.option_map (Aws.Json.lookup j "hourlyPrice") String.of_json
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") String.of_json
    ; max_term_duration_in_days =
        Aws.Util.option_map (Aws.Json.lookup j "maxTermDurationInDays") Integer.of_json
    ; min_term_duration_in_days =
        Aws.Util.option_map (Aws.Json.lookup j "minTermDurationInDays") Integer.of_json
    ; network_platform =
        Aws.Util.option_map (Aws.Json.lookup j "networkPlatform") String.of_json
    ; platform = Aws.Util.option_map (Aws.Json.lookup j "platform") String.of_json
    ; purchase_token =
        Aws.Util.option_map (Aws.Json.lookup j "purchaseToken") String.of_json
    ; recurrence =
        Aws.Util.option_map
          (Aws.Json.lookup j "recurrence")
          ScheduledInstanceRecurrence.of_json
    ; slot_duration_in_hours =
        Aws.Util.option_map (Aws.Json.lookup j "slotDurationInHours") Integer.of_json
    ; total_scheduled_instance_hours =
        Aws.Util.option_map
          (Aws.Json.lookup j "totalScheduledInstanceHours")
          Integer.of_json
    }
end

module ScheduledInstanceAvailabilitySet = struct
  type t = ScheduledInstanceAvailability.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ScheduledInstanceAvailability.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ScheduledInstanceAvailability.to_query v

  let to_json v = `List (List.map ScheduledInstanceAvailability.to_json v)

  let of_json j = Aws.Json.to_list ScheduledInstanceAvailability.of_json j
end

module DefaultTargetCapacityType = struct
  type t =
    | Spot
    | On_demand

  let str_to_t = [ "on-demand", On_demand; "spot", Spot ]

  let t_to_str = [ On_demand, "on-demand"; Spot, "spot" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module TargetCapacitySpecificationRequest = struct
  type t =
    { total_target_capacity : Integer.t
    ; on_demand_target_capacity : Integer.t option
    ; spot_target_capacity : Integer.t option
    ; default_target_capacity_type : DefaultTargetCapacityType.t option
    }

  let make
      ~total_target_capacity
      ?on_demand_target_capacity
      ?spot_target_capacity
      ?default_target_capacity_type
      () =
    { total_target_capacity
    ; on_demand_target_capacity
    ; spot_target_capacity
    ; default_target_capacity_type
    }

  let parse xml =
    Some
      { total_target_capacity =
          Aws.Xml.required
            "TotalTargetCapacity"
            (Aws.Util.option_bind
               (Aws.Xml.member "TotalTargetCapacity" xml)
               Integer.parse)
      ; on_demand_target_capacity =
          Aws.Util.option_bind (Aws.Xml.member "OnDemandTargetCapacity" xml) Integer.parse
      ; spot_target_capacity =
          Aws.Util.option_bind (Aws.Xml.member "SpotTargetCapacity" xml) Integer.parse
      ; default_target_capacity_type =
          Aws.Util.option_bind
            (Aws.Xml.member "DefaultTargetCapacityType" xml)
            DefaultTargetCapacityType.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.default_target_capacity_type (fun f ->
               Aws.Query.Pair
                 ("DefaultTargetCapacityType", DefaultTargetCapacityType.to_query f))
         ; Aws.Util.option_map v.spot_target_capacity (fun f ->
               Aws.Query.Pair ("SpotTargetCapacity", Integer.to_query f))
         ; Aws.Util.option_map v.on_demand_target_capacity (fun f ->
               Aws.Query.Pair ("OnDemandTargetCapacity", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TotalTargetCapacity", Integer.to_query v.total_target_capacity))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.default_target_capacity_type (fun f ->
               "DefaultTargetCapacityType", DefaultTargetCapacityType.to_json f)
         ; Aws.Util.option_map v.spot_target_capacity (fun f ->
               "SpotTargetCapacity", Integer.to_json f)
         ; Aws.Util.option_map v.on_demand_target_capacity (fun f ->
               "OnDemandTargetCapacity", Integer.to_json f)
         ; Some ("TotalTargetCapacity", Integer.to_json v.total_target_capacity)
         ])

  let of_json j =
    { total_target_capacity =
        Integer.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TotalTargetCapacity"))
    ; on_demand_target_capacity =
        Aws.Util.option_map (Aws.Json.lookup j "OnDemandTargetCapacity") Integer.of_json
    ; spot_target_capacity =
        Aws.Util.option_map (Aws.Json.lookup j "SpotTargetCapacity") Integer.of_json
    ; default_target_capacity_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "DefaultTargetCapacityType")
          DefaultTargetCapacityType.of_json
    }
end

module FleetLaunchTemplateSpecificationRequest = struct
  type t =
    { launch_template_id : String.t option
    ; launch_template_name : String.t option
    ; version : String.t option
    }

  let make ?launch_template_id ?launch_template_name ?version () =
    { launch_template_id; launch_template_name; version }

  let parse xml =
    Some
      { launch_template_id =
          Aws.Util.option_bind (Aws.Xml.member "LaunchTemplateId" xml) String.parse
      ; launch_template_name =
          Aws.Util.option_bind (Aws.Xml.member "LaunchTemplateName" xml) String.parse
      ; version = Aws.Util.option_bind (Aws.Xml.member "Version" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.version (fun f ->
               Aws.Query.Pair ("Version", String.to_query f))
         ; Aws.Util.option_map v.launch_template_name (fun f ->
               Aws.Query.Pair ("LaunchTemplateName", String.to_query f))
         ; Aws.Util.option_map v.launch_template_id (fun f ->
               Aws.Query.Pair ("LaunchTemplateId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.version (fun f -> "Version", String.to_json f)
         ; Aws.Util.option_map v.launch_template_name (fun f ->
               "LaunchTemplateName", String.to_json f)
         ; Aws.Util.option_map v.launch_template_id (fun f ->
               "LaunchTemplateId", String.to_json f)
         ])

  let of_json j =
    { launch_template_id =
        Aws.Util.option_map (Aws.Json.lookup j "LaunchTemplateId") String.of_json
    ; launch_template_name =
        Aws.Util.option_map (Aws.Json.lookup j "LaunchTemplateName") String.of_json
    ; version = Aws.Util.option_map (Aws.Json.lookup j "Version") String.of_json
    }
end

module Placement = struct
  type t =
    { availability_zone : String.t option
    ; affinity : String.t option
    ; group_name : String.t option
    ; partition_number : Integer.t option
    ; host_id : String.t option
    ; tenancy : Tenancy.t option
    ; spread_domain : String.t option
    ; host_resource_group_arn : String.t option
    }

  let make
      ?availability_zone
      ?affinity
      ?group_name
      ?partition_number
      ?host_id
      ?tenancy
      ?spread_domain
      ?host_resource_group_arn
      () =
    { availability_zone
    ; affinity
    ; group_name
    ; partition_number
    ; host_id
    ; tenancy
    ; spread_domain
    ; host_resource_group_arn
    }

  let parse xml =
    Some
      { availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; affinity = Aws.Util.option_bind (Aws.Xml.member "affinity" xml) String.parse
      ; group_name = Aws.Util.option_bind (Aws.Xml.member "groupName" xml) String.parse
      ; partition_number =
          Aws.Util.option_bind (Aws.Xml.member "partitionNumber" xml) Integer.parse
      ; host_id = Aws.Util.option_bind (Aws.Xml.member "hostId" xml) String.parse
      ; tenancy = Aws.Util.option_bind (Aws.Xml.member "tenancy" xml) Tenancy.parse
      ; spread_domain =
          Aws.Util.option_bind (Aws.Xml.member "spreadDomain" xml) String.parse
      ; host_resource_group_arn =
          Aws.Util.option_bind (Aws.Xml.member "hostResourceGroupArn" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.host_resource_group_arn (fun f ->
               Aws.Query.Pair ("HostResourceGroupArn", String.to_query f))
         ; Aws.Util.option_map v.spread_domain (fun f ->
               Aws.Query.Pair ("SpreadDomain", String.to_query f))
         ; Aws.Util.option_map v.tenancy (fun f ->
               Aws.Query.Pair ("Tenancy", Tenancy.to_query f))
         ; Aws.Util.option_map v.host_id (fun f ->
               Aws.Query.Pair ("HostId", String.to_query f))
         ; Aws.Util.option_map v.partition_number (fun f ->
               Aws.Query.Pair ("PartitionNumber", Integer.to_query f))
         ; Aws.Util.option_map v.group_name (fun f ->
               Aws.Query.Pair ("GroupName", String.to_query f))
         ; Aws.Util.option_map v.affinity (fun f ->
               Aws.Query.Pair ("Affinity", String.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.host_resource_group_arn (fun f ->
               "hostResourceGroupArn", String.to_json f)
         ; Aws.Util.option_map v.spread_domain (fun f -> "spreadDomain", String.to_json f)
         ; Aws.Util.option_map v.tenancy (fun f -> "tenancy", Tenancy.to_json f)
         ; Aws.Util.option_map v.host_id (fun f -> "hostId", String.to_json f)
         ; Aws.Util.option_map v.partition_number (fun f ->
               "partitionNumber", Integer.to_json f)
         ; Aws.Util.option_map v.group_name (fun f -> "groupName", String.to_json f)
         ; Aws.Util.option_map v.affinity (fun f -> "affinity", String.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ])

  let of_json j =
    { availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; affinity = Aws.Util.option_map (Aws.Json.lookup j "affinity") String.of_json
    ; group_name = Aws.Util.option_map (Aws.Json.lookup j "groupName") String.of_json
    ; partition_number =
        Aws.Util.option_map (Aws.Json.lookup j "partitionNumber") Integer.of_json
    ; host_id = Aws.Util.option_map (Aws.Json.lookup j "hostId") String.of_json
    ; tenancy = Aws.Util.option_map (Aws.Json.lookup j "tenancy") Tenancy.of_json
    ; spread_domain =
        Aws.Util.option_map (Aws.Json.lookup j "spreadDomain") String.of_json
    ; host_resource_group_arn =
        Aws.Util.option_map (Aws.Json.lookup j "hostResourceGroupArn") String.of_json
    }
end

module FleetLaunchTemplateOverridesRequest = struct
  type t =
    { instance_type : InstanceType.t option
    ; max_price : String.t option
    ; subnet_id : String.t option
    ; availability_zone : String.t option
    ; weighted_capacity : Double.t option
    ; priority : Double.t option
    ; placement : Placement.t option
    }

  let make
      ?instance_type
      ?max_price
      ?subnet_id
      ?availability_zone
      ?weighted_capacity
      ?priority
      ?placement
      () =
    { instance_type
    ; max_price
    ; subnet_id
    ; availability_zone
    ; weighted_capacity
    ; priority
    ; placement
    }

  let parse xml =
    Some
      { instance_type =
          Aws.Util.option_bind (Aws.Xml.member "InstanceType" xml) InstanceType.parse
      ; max_price = Aws.Util.option_bind (Aws.Xml.member "MaxPrice" xml) String.parse
      ; subnet_id = Aws.Util.option_bind (Aws.Xml.member "SubnetId" xml) String.parse
      ; availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "AvailabilityZone" xml) String.parse
      ; weighted_capacity =
          Aws.Util.option_bind (Aws.Xml.member "WeightedCapacity" xml) Double.parse
      ; priority = Aws.Util.option_bind (Aws.Xml.member "Priority" xml) Double.parse
      ; placement = Aws.Util.option_bind (Aws.Xml.member "Placement" xml) Placement.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.placement (fun f ->
               Aws.Query.Pair ("Placement", Placement.to_query f))
         ; Aws.Util.option_map v.priority (fun f ->
               Aws.Query.Pair ("Priority", Double.to_query f))
         ; Aws.Util.option_map v.weighted_capacity (fun f ->
               Aws.Query.Pair ("WeightedCapacity", Double.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ; Aws.Util.option_map v.subnet_id (fun f ->
               Aws.Query.Pair ("SubnetId", String.to_query f))
         ; Aws.Util.option_map v.max_price (fun f ->
               Aws.Query.Pair ("MaxPrice", String.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", InstanceType.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.placement (fun f -> "Placement", Placement.to_json f)
         ; Aws.Util.option_map v.priority (fun f -> "Priority", Double.to_json f)
         ; Aws.Util.option_map v.weighted_capacity (fun f ->
               "WeightedCapacity", Double.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "AvailabilityZone", String.to_json f)
         ; Aws.Util.option_map v.subnet_id (fun f -> "SubnetId", String.to_json f)
         ; Aws.Util.option_map v.max_price (fun f -> "MaxPrice", String.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f ->
               "InstanceType", InstanceType.to_json f)
         ])

  let of_json j =
    { instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "InstanceType") InstanceType.of_json
    ; max_price = Aws.Util.option_map (Aws.Json.lookup j "MaxPrice") String.of_json
    ; subnet_id = Aws.Util.option_map (Aws.Json.lookup j "SubnetId") String.of_json
    ; availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "AvailabilityZone") String.of_json
    ; weighted_capacity =
        Aws.Util.option_map (Aws.Json.lookup j "WeightedCapacity") Double.of_json
    ; priority = Aws.Util.option_map (Aws.Json.lookup j "Priority") Double.of_json
    ; placement = Aws.Util.option_map (Aws.Json.lookup j "Placement") Placement.of_json
    }
end

module FleetLaunchTemplateOverridesListRequest = struct
  type t = FleetLaunchTemplateOverridesRequest.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map FleetLaunchTemplateOverridesRequest.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list FleetLaunchTemplateOverridesRequest.to_query v

  let to_json v = `List (List.map FleetLaunchTemplateOverridesRequest.to_json v)

  let of_json j = Aws.Json.to_list FleetLaunchTemplateOverridesRequest.of_json j
end

module FleetLaunchTemplateConfigRequest = struct
  type t =
    { launch_template_specification : FleetLaunchTemplateSpecificationRequest.t option
    ; overrides : FleetLaunchTemplateOverridesListRequest.t
    }

  let make ?launch_template_specification ?(overrides = []) () =
    { launch_template_specification; overrides }

  let parse xml =
    Some
      { launch_template_specification =
          Aws.Util.option_bind
            (Aws.Xml.member "LaunchTemplateSpecification" xml)
            FleetLaunchTemplateSpecificationRequest.parse
      ; overrides =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Overrides" xml)
               FleetLaunchTemplateOverridesListRequest.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("Overrides", FleetLaunchTemplateOverridesListRequest.to_query v.overrides))
         ; Aws.Util.option_map v.launch_template_specification (fun f ->
               Aws.Query.Pair
                 ( "LaunchTemplateSpecification"
                 , FleetLaunchTemplateSpecificationRequest.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Overrides", FleetLaunchTemplateOverridesListRequest.to_json v.overrides)
         ; Aws.Util.option_map v.launch_template_specification (fun f ->
               ( "LaunchTemplateSpecification"
               , FleetLaunchTemplateSpecificationRequest.to_json f ))
         ])

  let of_json j =
    { launch_template_specification =
        Aws.Util.option_map
          (Aws.Json.lookup j "LaunchTemplateSpecification")
          FleetLaunchTemplateSpecificationRequest.of_json
    ; overrides =
        FleetLaunchTemplateOverridesListRequest.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Overrides"))
    }
end

module FleetLaunchTemplateConfigListRequest = struct
  type t = FleetLaunchTemplateConfigRequest.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map FleetLaunchTemplateConfigRequest.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list FleetLaunchTemplateConfigRequest.to_query v

  let to_json v = `List (List.map FleetLaunchTemplateConfigRequest.to_json v)

  let of_json j = Aws.Json.to_list FleetLaunchTemplateConfigRequest.of_json j
end

module ModifyFleetRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; excess_capacity_termination_policy : FleetExcessCapacityTerminationPolicy.t option
    ; launch_template_configs : FleetLaunchTemplateConfigListRequest.t
    ; fleet_id : String.t
    ; target_capacity_specification : TargetCapacitySpecificationRequest.t option
    }

  let make
      ?dry_run
      ?excess_capacity_termination_policy
      ?(launch_template_configs = [])
      ~fleet_id
      ?target_capacity_specification
      () =
    { dry_run
    ; excess_capacity_termination_policy
    ; launch_template_configs
    ; fleet_id
    ; target_capacity_specification
    }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; excess_capacity_termination_policy =
          Aws.Util.option_bind
            (Aws.Xml.member "ExcessCapacityTerminationPolicy" xml)
            FleetExcessCapacityTerminationPolicy.parse
      ; launch_template_configs =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "LaunchTemplateConfig" xml)
               FleetLaunchTemplateConfigListRequest.parse)
      ; fleet_id =
          Aws.Xml.required
            "FleetId"
            (Aws.Util.option_bind (Aws.Xml.member "FleetId" xml) String.parse)
      ; target_capacity_specification =
          Aws.Util.option_bind
            (Aws.Xml.member "TargetCapacitySpecification" xml)
            TargetCapacitySpecificationRequest.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.target_capacity_specification (fun f ->
               Aws.Query.Pair
                 ( "TargetCapacitySpecification"
                 , TargetCapacitySpecificationRequest.to_query f ))
         ; Some (Aws.Query.Pair ("FleetId", String.to_query v.fleet_id))
         ; Some
             (Aws.Query.Pair
                ( "LaunchTemplateConfig"
                , FleetLaunchTemplateConfigListRequest.to_query v.launch_template_configs
                ))
         ; Aws.Util.option_map v.excess_capacity_termination_policy (fun f ->
               Aws.Query.Pair
                 ( "ExcessCapacityTerminationPolicy"
                 , FleetExcessCapacityTerminationPolicy.to_query f ))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.target_capacity_specification (fun f ->
               "TargetCapacitySpecification", TargetCapacitySpecificationRequest.to_json f)
         ; Some ("FleetId", String.to_json v.fleet_id)
         ; Some
             ( "LaunchTemplateConfig"
             , FleetLaunchTemplateConfigListRequest.to_json v.launch_template_configs )
         ; Aws.Util.option_map v.excess_capacity_termination_policy (fun f ->
               ( "ExcessCapacityTerminationPolicy"
               , FleetExcessCapacityTerminationPolicy.to_json f ))
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; excess_capacity_termination_policy =
        Aws.Util.option_map
          (Aws.Json.lookup j "ExcessCapacityTerminationPolicy")
          FleetExcessCapacityTerminationPolicy.of_json
    ; launch_template_configs =
        FleetLaunchTemplateConfigListRequest.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "LaunchTemplateConfig"))
    ; fleet_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "FleetId"))
    ; target_capacity_specification =
        Aws.Util.option_map
          (Aws.Json.lookup j "TargetCapacitySpecification")
          TargetCapacitySpecificationRequest.of_json
    }
end

module DeleteClientVpnRouteRequest = struct
  type t =
    { client_vpn_endpoint_id : String.t
    ; target_vpc_subnet_id : String.t option
    ; destination_cidr_block : String.t
    ; dry_run : Boolean.t option
    }

  let make
      ~client_vpn_endpoint_id
      ?target_vpc_subnet_id
      ~destination_cidr_block
      ?dry_run
      () =
    { client_vpn_endpoint_id; target_vpc_subnet_id; destination_cidr_block; dry_run }

  let parse xml =
    Some
      { client_vpn_endpoint_id =
          Aws.Xml.required
            "ClientVpnEndpointId"
            (Aws.Util.option_bind (Aws.Xml.member "ClientVpnEndpointId" xml) String.parse)
      ; target_vpc_subnet_id =
          Aws.Util.option_bind (Aws.Xml.member "TargetVpcSubnetId" xml) String.parse
      ; destination_cidr_block =
          Aws.Xml.required
            "DestinationCidrBlock"
            (Aws.Util.option_bind
               (Aws.Xml.member "DestinationCidrBlock" xml)
               String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DestinationCidrBlock", String.to_query v.destination_cidr_block))
         ; Aws.Util.option_map v.target_vpc_subnet_id (fun f ->
               Aws.Query.Pair ("TargetVpcSubnetId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ClientVpnEndpointId", String.to_query v.client_vpn_endpoint_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("DestinationCidrBlock", String.to_json v.destination_cidr_block)
         ; Aws.Util.option_map v.target_vpc_subnet_id (fun f ->
               "TargetVpcSubnetId", String.to_json f)
         ; Some ("ClientVpnEndpointId", String.to_json v.client_vpn_endpoint_id)
         ])

  let of_json j =
    { client_vpn_endpoint_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ClientVpnEndpointId"))
    ; target_vpc_subnet_id =
        Aws.Util.option_map (Aws.Json.lookup j "TargetVpcSubnetId") String.of_json
    ; destination_cidr_block =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DestinationCidrBlock"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module HibernationOptions = struct
  type t = { configured : Boolean.t option }

  let make ?configured () = { configured }

  let parse xml =
    Some
      { configured = Aws.Util.option_bind (Aws.Xml.member "configured" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.configured (fun f ->
               Aws.Query.Pair ("Configured", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.configured (fun f -> "configured", Boolean.to_json f) ])

  let of_json j =
    { configured = Aws.Util.option_map (Aws.Json.lookup j "configured") Boolean.of_json }
end

module CreateVpcEndpointConnectionNotificationResult = struct
  type t =
    { connection_notification : ConnectionNotification.t option
    ; client_token : String.t option
    }

  let make ?connection_notification ?client_token () =
    { connection_notification; client_token }

  let parse xml =
    Some
      { connection_notification =
          Aws.Util.option_bind
            (Aws.Xml.member "connectionNotification" xml)
            ConnectionNotification.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "clientToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.connection_notification (fun f ->
               Aws.Query.Pair ("ConnectionNotification", ConnectionNotification.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f -> "clientToken", String.to_json f)
         ; Aws.Util.option_map v.connection_notification (fun f ->
               "connectionNotification", ConnectionNotification.to_json f)
         ])

  let of_json j =
    { connection_notification =
        Aws.Util.option_map
          (Aws.Json.lookup j "connectionNotification")
          ConnectionNotification.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "clientToken") String.of_json
    }
end

module RouteTableAssociationStateCode = struct
  type t =
    | Associating
    | Associated
    | Disassociating
    | Disassociated
    | Failed

  let str_to_t =
    [ "failed", Failed
    ; "disassociated", Disassociated
    ; "disassociating", Disassociating
    ; "associated", Associated
    ; "associating", Associating
    ]

  let t_to_str =
    [ Failed, "failed"
    ; Disassociated, "disassociated"
    ; Disassociating, "disassociating"
    ; Associated, "associated"
    ; Associating, "associating"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module RouteTableAssociationState = struct
  type t =
    { state : RouteTableAssociationStateCode.t option
    ; status_message : String.t option
    }

  let make ?state ?status_message () = { state; status_message }

  let parse xml =
    Some
      { state =
          Aws.Util.option_bind
            (Aws.Xml.member "state" xml)
            RouteTableAssociationStateCode.parse
      ; status_message =
          Aws.Util.option_bind (Aws.Xml.member "statusMessage" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status_message (fun f ->
               Aws.Query.Pair ("StatusMessage", String.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", RouteTableAssociationStateCode.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status_message (fun f ->
               "statusMessage", String.to_json f)
         ; Aws.Util.option_map v.state (fun f ->
               "state", RouteTableAssociationStateCode.to_json f)
         ])

  let of_json j =
    { state =
        Aws.Util.option_map
          (Aws.Json.lookup j "state")
          RouteTableAssociationStateCode.of_json
    ; status_message =
        Aws.Util.option_map (Aws.Json.lookup j "statusMessage") String.of_json
    }
end

module AssociateRouteTableResult = struct
  type t =
    { association_id : String.t option
    ; association_state : RouteTableAssociationState.t option
    }

  let make ?association_id ?association_state () = { association_id; association_state }

  let parse xml =
    Some
      { association_id =
          Aws.Util.option_bind (Aws.Xml.member "associationId" xml) String.parse
      ; association_state =
          Aws.Util.option_bind
            (Aws.Xml.member "associationState" xml)
            RouteTableAssociationState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_state (fun f ->
               Aws.Query.Pair ("AssociationState", RouteTableAssociationState.to_query f))
         ; Aws.Util.option_map v.association_id (fun f ->
               Aws.Query.Pair ("AssociationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_state (fun f ->
               "associationState", RouteTableAssociationState.to_json f)
         ; Aws.Util.option_map v.association_id (fun f ->
               "associationId", String.to_json f)
         ])

  let of_json j =
    { association_id =
        Aws.Util.option_map (Aws.Json.lookup j "associationId") String.of_json
    ; association_state =
        Aws.Util.option_map
          (Aws.Json.lookup j "associationState")
          RouteTableAssociationState.of_json
    }
end

module InstanceCreditSpecificationListRequest = struct
  type t = InstanceCreditSpecificationRequest.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map InstanceCreditSpecificationRequest.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list InstanceCreditSpecificationRequest.to_query v

  let to_json v = `List (List.map InstanceCreditSpecificationRequest.to_json v)

  let of_json j = Aws.Json.to_list InstanceCreditSpecificationRequest.of_json j
end

module ModifyInstanceCreditSpecificationRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; client_token : String.t option
    ; instance_credit_specifications : InstanceCreditSpecificationListRequest.t
    }

  let make ?dry_run ?client_token ~instance_credit_specifications () =
    { dry_run; client_token; instance_credit_specifications }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; instance_credit_specifications =
          Aws.Xml.required
            "InstanceCreditSpecification"
            (Aws.Util.option_bind
               (Aws.Xml.member "InstanceCreditSpecification" xml)
               InstanceCreditSpecificationListRequest.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "InstanceCreditSpecification"
                , InstanceCreditSpecificationListRequest.to_query
                    v.instance_credit_specifications ))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "InstanceCreditSpecification"
             , InstanceCreditSpecificationListRequest.to_json
                 v.instance_credit_specifications )
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; instance_credit_specifications =
        InstanceCreditSpecificationListRequest.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceCreditSpecification"))
    }
end

module VpcCidrBlockStateCode = struct
  type t =
    | Associating
    | Associated
    | Disassociating
    | Disassociated
    | Failing
    | Failed

  let str_to_t =
    [ "failed", Failed
    ; "failing", Failing
    ; "disassociated", Disassociated
    ; "disassociating", Disassociating
    ; "associated", Associated
    ; "associating", Associating
    ]

  let t_to_str =
    [ Failed, "failed"
    ; Failing, "failing"
    ; Disassociated, "disassociated"
    ; Disassociating, "disassociating"
    ; Associated, "associated"
    ; Associating, "associating"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module VpcCidrBlockState = struct
  type t =
    { state : VpcCidrBlockStateCode.t option
    ; status_message : String.t option
    }

  let make ?state ?status_message () = { state; status_message }

  let parse xml =
    Some
      { state =
          Aws.Util.option_bind (Aws.Xml.member "state" xml) VpcCidrBlockStateCode.parse
      ; status_message =
          Aws.Util.option_bind (Aws.Xml.member "statusMessage" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status_message (fun f ->
               Aws.Query.Pair ("StatusMessage", String.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", VpcCidrBlockStateCode.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status_message (fun f ->
               "statusMessage", String.to_json f)
         ; Aws.Util.option_map v.state (fun f -> "state", VpcCidrBlockStateCode.to_json f)
         ])

  let of_json j =
    { state =
        Aws.Util.option_map (Aws.Json.lookup j "state") VpcCidrBlockStateCode.of_json
    ; status_message =
        Aws.Util.option_map (Aws.Json.lookup j "statusMessage") String.of_json
    }
end

module VpcCidrBlockAssociation = struct
  type t =
    { association_id : String.t option
    ; cidr_block : String.t option
    ; cidr_block_state : VpcCidrBlockState.t option
    }

  let make ?association_id ?cidr_block ?cidr_block_state () =
    { association_id; cidr_block; cidr_block_state }

  let parse xml =
    Some
      { association_id =
          Aws.Util.option_bind (Aws.Xml.member "associationId" xml) String.parse
      ; cidr_block = Aws.Util.option_bind (Aws.Xml.member "cidrBlock" xml) String.parse
      ; cidr_block_state =
          Aws.Util.option_bind
            (Aws.Xml.member "cidrBlockState" xml)
            VpcCidrBlockState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cidr_block_state (fun f ->
               Aws.Query.Pair ("CidrBlockState", VpcCidrBlockState.to_query f))
         ; Aws.Util.option_map v.cidr_block (fun f ->
               Aws.Query.Pair ("CidrBlock", String.to_query f))
         ; Aws.Util.option_map v.association_id (fun f ->
               Aws.Query.Pair ("AssociationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cidr_block_state (fun f ->
               "cidrBlockState", VpcCidrBlockState.to_json f)
         ; Aws.Util.option_map v.cidr_block (fun f -> "cidrBlock", String.to_json f)
         ; Aws.Util.option_map v.association_id (fun f ->
               "associationId", String.to_json f)
         ])

  let of_json j =
    { association_id =
        Aws.Util.option_map (Aws.Json.lookup j "associationId") String.of_json
    ; cidr_block = Aws.Util.option_map (Aws.Json.lookup j "cidrBlock") String.of_json
    ; cidr_block_state =
        Aws.Util.option_map (Aws.Json.lookup j "cidrBlockState") VpcCidrBlockState.of_json
    }
end

module Phase1DHGroupNumbersRequestList = struct
  type t = Phase1DHGroupNumbersRequestListValue.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map Phase1DHGroupNumbersRequestListValue.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Phase1DHGroupNumbersRequestListValue.to_query v

  let to_json v = `List (List.map Phase1DHGroupNumbersRequestListValue.to_json v)

  let of_json j = Aws.Json.to_list Phase1DHGroupNumbersRequestListValue.of_json j
end

module NetworkAclIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module ImportClientVpnClientCertificateRevocationListResult = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module DeleteQueuedReservedInstancesErrorCode = struct
  type t =
    | Reserved_instances_id_invalid
    | Reserved_instances_not_in_queued_state
    | Unexpected_error

  let str_to_t =
    [ "unexpected-error", Unexpected_error
    ; "reserved-instances-not-in-queued-state", Reserved_instances_not_in_queued_state
    ; "reserved-instances-id-invalid", Reserved_instances_id_invalid
    ]

  let t_to_str =
    [ Unexpected_error, "unexpected-error"
    ; Reserved_instances_not_in_queued_state, "reserved-instances-not-in-queued-state"
    ; Reserved_instances_id_invalid, "reserved-instances-id-invalid"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DeleteQueuedReservedInstancesError = struct
  type t =
    { code : DeleteQueuedReservedInstancesErrorCode.t option
    ; message : String.t option
    }

  let make ?code ?message () = { code; message }

  let parse xml =
    Some
      { code =
          Aws.Util.option_bind
            (Aws.Xml.member "code" xml)
            DeleteQueuedReservedInstancesErrorCode.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair ("Code", DeleteQueuedReservedInstancesErrorCode.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f)
         ; Aws.Util.option_map v.code (fun f ->
               "code", DeleteQueuedReservedInstancesErrorCode.to_json f)
         ])

  let of_json j =
    { code =
        Aws.Util.option_map
          (Aws.Json.lookup j "code")
          DeleteQueuedReservedInstancesErrorCode.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json
    }
end

module FlowLogsResourceType = struct
  type t =
    | VPC
    | Subnet
    | NetworkInterface

  let str_to_t = [ "NetworkInterface", NetworkInterface; "Subnet", Subnet; "VPC", VPC ]

  let t_to_str = [ NetworkInterface, "NetworkInterface"; Subnet, "Subnet"; VPC, "VPC" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module LaunchTemplateEbsBlockDeviceRequest = struct
  type t =
    { encrypted : Boolean.t option
    ; delete_on_termination : Boolean.t option
    ; iops : Integer.t option
    ; kms_key_id : String.t option
    ; snapshot_id : String.t option
    ; volume_size : Integer.t option
    ; volume_type : VolumeType.t option
    }

  let make
      ?encrypted
      ?delete_on_termination
      ?iops
      ?kms_key_id
      ?snapshot_id
      ?volume_size
      ?volume_type
      () =
    { encrypted
    ; delete_on_termination
    ; iops
    ; kms_key_id
    ; snapshot_id
    ; volume_size
    ; volume_type
    }

  let parse xml =
    Some
      { encrypted = Aws.Util.option_bind (Aws.Xml.member "Encrypted" xml) Boolean.parse
      ; delete_on_termination =
          Aws.Util.option_bind (Aws.Xml.member "DeleteOnTermination" xml) Boolean.parse
      ; iops = Aws.Util.option_bind (Aws.Xml.member "Iops" xml) Integer.parse
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "KmsKeyId" xml) String.parse
      ; snapshot_id = Aws.Util.option_bind (Aws.Xml.member "SnapshotId" xml) String.parse
      ; volume_size = Aws.Util.option_bind (Aws.Xml.member "VolumeSize" xml) Integer.parse
      ; volume_type =
          Aws.Util.option_bind (Aws.Xml.member "VolumeType" xml) VolumeType.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.volume_type (fun f ->
               Aws.Query.Pair ("VolumeType", VolumeType.to_query f))
         ; Aws.Util.option_map v.volume_size (fun f ->
               Aws.Query.Pair ("VolumeSize", Integer.to_query f))
         ; Aws.Util.option_map v.snapshot_id (fun f ->
               Aws.Query.Pair ("SnapshotId", String.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Aws.Util.option_map v.iops (fun f ->
               Aws.Query.Pair ("Iops", Integer.to_query f))
         ; Aws.Util.option_map v.delete_on_termination (fun f ->
               Aws.Query.Pair ("DeleteOnTermination", Boolean.to_query f))
         ; Aws.Util.option_map v.encrypted (fun f ->
               Aws.Query.Pair ("Encrypted", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.volume_type (fun f -> "VolumeType", VolumeType.to_json f)
         ; Aws.Util.option_map v.volume_size (fun f -> "VolumeSize", Integer.to_json f)
         ; Aws.Util.option_map v.snapshot_id (fun f -> "SnapshotId", String.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "KmsKeyId", String.to_json f)
         ; Aws.Util.option_map v.iops (fun f -> "Iops", Integer.to_json f)
         ; Aws.Util.option_map v.delete_on_termination (fun f ->
               "DeleteOnTermination", Boolean.to_json f)
         ; Aws.Util.option_map v.encrypted (fun f -> "Encrypted", Boolean.to_json f)
         ])

  let of_json j =
    { encrypted = Aws.Util.option_map (Aws.Json.lookup j "Encrypted") Boolean.of_json
    ; delete_on_termination =
        Aws.Util.option_map (Aws.Json.lookup j "DeleteOnTermination") Boolean.of_json
    ; iops = Aws.Util.option_map (Aws.Json.lookup j "Iops") Integer.of_json
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "KmsKeyId") String.of_json
    ; snapshot_id = Aws.Util.option_map (Aws.Json.lookup j "SnapshotId") String.of_json
    ; volume_size = Aws.Util.option_map (Aws.Json.lookup j "VolumeSize") Integer.of_json
    ; volume_type =
        Aws.Util.option_map (Aws.Json.lookup j "VolumeType") VolumeType.of_json
    }
end

module LaunchTemplateBlockDeviceMappingRequest = struct
  type t =
    { device_name : String.t option
    ; virtual_name : String.t option
    ; ebs : LaunchTemplateEbsBlockDeviceRequest.t option
    ; no_device : String.t option
    }

  let make ?device_name ?virtual_name ?ebs ?no_device () =
    { device_name; virtual_name; ebs; no_device }

  let parse xml =
    Some
      { device_name = Aws.Util.option_bind (Aws.Xml.member "DeviceName" xml) String.parse
      ; virtual_name =
          Aws.Util.option_bind (Aws.Xml.member "VirtualName" xml) String.parse
      ; ebs =
          Aws.Util.option_bind
            (Aws.Xml.member "Ebs" xml)
            LaunchTemplateEbsBlockDeviceRequest.parse
      ; no_device = Aws.Util.option_bind (Aws.Xml.member "NoDevice" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.no_device (fun f ->
               Aws.Query.Pair ("NoDevice", String.to_query f))
         ; Aws.Util.option_map v.ebs (fun f ->
               Aws.Query.Pair ("Ebs", LaunchTemplateEbsBlockDeviceRequest.to_query f))
         ; Aws.Util.option_map v.virtual_name (fun f ->
               Aws.Query.Pair ("VirtualName", String.to_query f))
         ; Aws.Util.option_map v.device_name (fun f ->
               Aws.Query.Pair ("DeviceName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.no_device (fun f -> "NoDevice", String.to_json f)
         ; Aws.Util.option_map v.ebs (fun f ->
               "Ebs", LaunchTemplateEbsBlockDeviceRequest.to_json f)
         ; Aws.Util.option_map v.virtual_name (fun f -> "VirtualName", String.to_json f)
         ; Aws.Util.option_map v.device_name (fun f -> "DeviceName", String.to_json f)
         ])

  let of_json j =
    { device_name = Aws.Util.option_map (Aws.Json.lookup j "DeviceName") String.of_json
    ; virtual_name = Aws.Util.option_map (Aws.Json.lookup j "VirtualName") String.of_json
    ; ebs =
        Aws.Util.option_map
          (Aws.Json.lookup j "Ebs")
          LaunchTemplateEbsBlockDeviceRequest.of_json
    ; no_device = Aws.Util.option_map (Aws.Json.lookup j "NoDevice") String.of_json
    }
end

module LaunchTemplateBlockDeviceMappingRequestList = struct
  type t = LaunchTemplateBlockDeviceMappingRequest.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         LaunchTemplateBlockDeviceMappingRequest.parse
         (Aws.Xml.members "BlockDeviceMapping" xml))

  let to_query v =
    Aws.Query.to_query_list LaunchTemplateBlockDeviceMappingRequest.to_query v

  let to_json v = `List (List.map LaunchTemplateBlockDeviceMappingRequest.to_json v)

  let of_json j = Aws.Json.to_list LaunchTemplateBlockDeviceMappingRequest.of_json j
end

module ReservedInstancesOfferingIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module ReportStatusType = struct
  type t =
    | Ok
    | Impaired

  let str_to_t = [ "impaired", Impaired; "ok", Ok ]

  let t_to_str = [ Impaired, "impaired"; Ok, "ok" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ReportInstanceReasonCodes = struct
  type t =
    | Instance_stuck_in_state
    | Unresponsive
    | Not_accepting_credentials
    | Password_not_available
    | Performance_network
    | Performance_instance_store
    | Performance_ebs_volume
    | Performance_other
    | Other

  let str_to_t =
    [ "other", Other
    ; "performance-other", Performance_other
    ; "performance-ebs-volume", Performance_ebs_volume
    ; "performance-instance-store", Performance_instance_store
    ; "performance-network", Performance_network
    ; "password-not-available", Password_not_available
    ; "not-accepting-credentials", Not_accepting_credentials
    ; "unresponsive", Unresponsive
    ; "instance-stuck-in-state", Instance_stuck_in_state
    ]

  let t_to_str =
    [ Other, "other"
    ; Performance_other, "performance-other"
    ; Performance_ebs_volume, "performance-ebs-volume"
    ; Performance_instance_store, "performance-instance-store"
    ; Performance_network, "performance-network"
    ; Password_not_available, "password-not-available"
    ; Not_accepting_credentials, "not-accepting-credentials"
    ; Unresponsive, "unresponsive"
    ; Instance_stuck_in_state, "instance-stuck-in-state"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ReasonCodesList = struct
  type t = ReportInstanceReasonCodes.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ReportInstanceReasonCodes.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ReportInstanceReasonCodes.to_query v

  let to_json v = `List (List.map ReportInstanceReasonCodes.to_json v)

  let of_json j = Aws.Json.to_list ReportInstanceReasonCodes.of_json j
end

module ReportInstanceStatusRequest = struct
  type t =
    { description : String.t option
    ; dry_run : Boolean.t option
    ; end_time : DateTime.t option
    ; instances : InstanceIdStringList.t
    ; reason_codes : ReasonCodesList.t
    ; start_time : DateTime.t option
    ; status : ReportStatusType.t
    }

  let make ?description ?dry_run ?end_time ~instances ~reason_codes ?start_time ~status ()
      =
    { description; dry_run; end_time; instances; reason_codes; start_time; status }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; end_time = Aws.Util.option_bind (Aws.Xml.member "endTime" xml) DateTime.parse
      ; instances =
          Aws.Xml.required
            "instanceId"
            (Aws.Util.option_bind
               (Aws.Xml.member "instanceId" xml)
               InstanceIdStringList.parse)
      ; reason_codes =
          Aws.Xml.required
            "reasonCode"
            (Aws.Util.option_bind (Aws.Xml.member "reasonCode" xml) ReasonCodesList.parse)
      ; start_time = Aws.Util.option_bind (Aws.Xml.member "startTime" xml) DateTime.parse
      ; status =
          Aws.Xml.required
            "status"
            (Aws.Util.option_bind (Aws.Xml.member "status" xml) ReportStatusType.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Status", ReportStatusType.to_query v.status))
         ; Aws.Util.option_map v.start_time (fun f ->
               Aws.Query.Pair ("StartTime", DateTime.to_query f))
         ; Some (Aws.Query.Pair ("ReasonCode", ReasonCodesList.to_query v.reason_codes))
         ; Some (Aws.Query.Pair ("InstanceId", InstanceIdStringList.to_query v.instances))
         ; Aws.Util.option_map v.end_time (fun f ->
               Aws.Query.Pair ("EndTime", DateTime.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("status", ReportStatusType.to_json v.status)
         ; Aws.Util.option_map v.start_time (fun f -> "startTime", DateTime.to_json f)
         ; Some ("reasonCode", ReasonCodesList.to_json v.reason_codes)
         ; Some ("instanceId", InstanceIdStringList.to_json v.instances)
         ; Aws.Util.option_map v.end_time (fun f -> "endTime", DateTime.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; end_time = Aws.Util.option_map (Aws.Json.lookup j "endTime") DateTime.of_json
    ; instances =
        InstanceIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceId"))
    ; reason_codes =
        ReasonCodesList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "reasonCode"))
    ; start_time = Aws.Util.option_map (Aws.Json.lookup j "startTime") DateTime.of_json
    ; status =
        ReportStatusType.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "status"))
    }
end

module Ipv6SupportValue = struct
  type t =
    | Enable
    | Disable

  let str_to_t = [ "disable", Disable; "enable", Enable ]

  let t_to_str = [ Disable, "disable"; Enable, "enable" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ApplianceModeSupportValue = struct
  type t =
    | Enable
    | Disable

  let str_to_t = [ "disable", Disable; "enable", Enable ]

  let t_to_str = [ Disable, "disable"; Enable, "enable" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module TransitGatewayVpcAttachmentOptions = struct
  type t =
    { dns_support : DnsSupportValue.t option
    ; ipv6_support : Ipv6SupportValue.t option
    ; appliance_mode_support : ApplianceModeSupportValue.t option
    }

  let make ?dns_support ?ipv6_support ?appliance_mode_support () =
    { dns_support; ipv6_support; appliance_mode_support }

  let parse xml =
    Some
      { dns_support =
          Aws.Util.option_bind (Aws.Xml.member "dnsSupport" xml) DnsSupportValue.parse
      ; ipv6_support =
          Aws.Util.option_bind (Aws.Xml.member "ipv6Support" xml) Ipv6SupportValue.parse
      ; appliance_mode_support =
          Aws.Util.option_bind
            (Aws.Xml.member "applianceModeSupport" xml)
            ApplianceModeSupportValue.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.appliance_mode_support (fun f ->
               Aws.Query.Pair
                 ("ApplianceModeSupport", ApplianceModeSupportValue.to_query f))
         ; Aws.Util.option_map v.ipv6_support (fun f ->
               Aws.Query.Pair ("Ipv6Support", Ipv6SupportValue.to_query f))
         ; Aws.Util.option_map v.dns_support (fun f ->
               Aws.Query.Pair ("DnsSupport", DnsSupportValue.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.appliance_mode_support (fun f ->
               "applianceModeSupport", ApplianceModeSupportValue.to_json f)
         ; Aws.Util.option_map v.ipv6_support (fun f ->
               "ipv6Support", Ipv6SupportValue.to_json f)
         ; Aws.Util.option_map v.dns_support (fun f ->
               "dnsSupport", DnsSupportValue.to_json f)
         ])

  let of_json j =
    { dns_support =
        Aws.Util.option_map (Aws.Json.lookup j "dnsSupport") DnsSupportValue.of_json
    ; ipv6_support =
        Aws.Util.option_map (Aws.Json.lookup j "ipv6Support") Ipv6SupportValue.of_json
    ; appliance_mode_support =
        Aws.Util.option_map
          (Aws.Json.lookup j "applianceModeSupport")
          ApplianceModeSupportValue.of_json
    }
end

module TransitGatewayVpcAttachment = struct
  type t =
    { transit_gateway_attachment_id : String.t option
    ; transit_gateway_id : String.t option
    ; vpc_id : String.t option
    ; vpc_owner_id : String.t option
    ; state : TransitGatewayAttachmentState.t option
    ; subnet_ids : ValueStringList.t
    ; creation_time : DateTime.t option
    ; options : TransitGatewayVpcAttachmentOptions.t option
    ; tags : TagList.t
    }

  let make
      ?transit_gateway_attachment_id
      ?transit_gateway_id
      ?vpc_id
      ?vpc_owner_id
      ?state
      ?(subnet_ids = [])
      ?creation_time
      ?options
      ?(tags = [])
      () =
    { transit_gateway_attachment_id
    ; transit_gateway_id
    ; vpc_id
    ; vpc_owner_id
    ; state
    ; subnet_ids
    ; creation_time
    ; options
    ; tags
    }

  let parse xml =
    Some
      { transit_gateway_attachment_id =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayAttachmentId" xml)
            String.parse
      ; transit_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "transitGatewayId" xml) String.parse
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse
      ; vpc_owner_id = Aws.Util.option_bind (Aws.Xml.member "vpcOwnerId" xml) String.parse
      ; state =
          Aws.Util.option_bind
            (Aws.Xml.member "state" xml)
            TransitGatewayAttachmentState.parse
      ; subnet_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "subnetIds" xml) ValueStringList.parse)
      ; creation_time =
          Aws.Util.option_bind (Aws.Xml.member "creationTime" xml) DateTime.parse
      ; options =
          Aws.Util.option_bind
            (Aws.Xml.member "options" xml)
            TransitGatewayVpcAttachmentOptions.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.options (fun f ->
               Aws.Query.Pair ("Options", TransitGatewayVpcAttachmentOptions.to_query f))
         ; Aws.Util.option_map v.creation_time (fun f ->
               Aws.Query.Pair ("CreationTime", DateTime.to_query f))
         ; Some (Aws.Query.Pair ("SubnetIds", ValueStringList.to_query v.subnet_ids))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", TransitGatewayAttachmentState.to_query f))
         ; Aws.Util.option_map v.vpc_owner_id (fun f ->
               Aws.Query.Pair ("VpcOwnerId", String.to_query f))
         ; Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_id (fun f ->
               Aws.Query.Pair ("TransitGatewayId", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               Aws.Query.Pair ("TransitGatewayAttachmentId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.options (fun f ->
               "options", TransitGatewayVpcAttachmentOptions.to_json f)
         ; Aws.Util.option_map v.creation_time (fun f ->
               "creationTime", DateTime.to_json f)
         ; Some ("subnetIds", ValueStringList.to_json v.subnet_ids)
         ; Aws.Util.option_map v.state (fun f ->
               "state", TransitGatewayAttachmentState.to_json f)
         ; Aws.Util.option_map v.vpc_owner_id (fun f -> "vpcOwnerId", String.to_json f)
         ; Aws.Util.option_map v.vpc_id (fun f -> "vpcId", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_id (fun f ->
               "transitGatewayId", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               "transitGatewayAttachmentId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_attachment_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayAttachmentId")
          String.of_json
    ; transit_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "transitGatewayId") String.of_json
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "vpcId") String.of_json
    ; vpc_owner_id = Aws.Util.option_map (Aws.Json.lookup j "vpcOwnerId") String.of_json
    ; state =
        Aws.Util.option_map
          (Aws.Json.lookup j "state")
          TransitGatewayAttachmentState.of_json
    ; subnet_ids =
        ValueStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "subnetIds"))
    ; creation_time =
        Aws.Util.option_map (Aws.Json.lookup j "creationTime") DateTime.of_json
    ; options =
        Aws.Util.option_map
          (Aws.Json.lookup j "options")
          TransitGatewayVpcAttachmentOptions.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module TransitGatewayVpcAttachmentList = struct
  type t = TransitGatewayVpcAttachment.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map TransitGatewayVpcAttachment.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list TransitGatewayVpcAttachment.to_query v

  let to_json v = `List (List.map TransitGatewayVpcAttachment.to_json v)

  let of_json j = Aws.Json.to_list TransitGatewayVpcAttachment.of_json j
end

module VpcPeeringConnectionOptionsDescription = struct
  type t =
    { allow_dns_resolution_from_remote_vpc : Boolean.t option
    ; allow_egress_from_local_classic_link_to_remote_vpc : Boolean.t option
    ; allow_egress_from_local_vpc_to_remote_classic_link : Boolean.t option
    }

  let make
      ?allow_dns_resolution_from_remote_vpc
      ?allow_egress_from_local_classic_link_to_remote_vpc
      ?allow_egress_from_local_vpc_to_remote_classic_link
      () =
    { allow_dns_resolution_from_remote_vpc
    ; allow_egress_from_local_classic_link_to_remote_vpc
    ; allow_egress_from_local_vpc_to_remote_classic_link
    }

  let parse xml =
    Some
      { allow_dns_resolution_from_remote_vpc =
          Aws.Util.option_bind
            (Aws.Xml.member "allowDnsResolutionFromRemoteVpc" xml)
            Boolean.parse
      ; allow_egress_from_local_classic_link_to_remote_vpc =
          Aws.Util.option_bind
            (Aws.Xml.member "allowEgressFromLocalClassicLinkToRemoteVpc" xml)
            Boolean.parse
      ; allow_egress_from_local_vpc_to_remote_classic_link =
          Aws.Util.option_bind
            (Aws.Xml.member "allowEgressFromLocalVpcToRemoteClassicLink" xml)
            Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map
             v.allow_egress_from_local_vpc_to_remote_classic_link
             (fun f ->
               Aws.Query.Pair
                 ("AllowEgressFromLocalVpcToRemoteClassicLink", Boolean.to_query f))
         ; Aws.Util.option_map
             v.allow_egress_from_local_classic_link_to_remote_vpc
             (fun f ->
               Aws.Query.Pair
                 ("AllowEgressFromLocalClassicLinkToRemoteVpc", Boolean.to_query f))
         ; Aws.Util.option_map v.allow_dns_resolution_from_remote_vpc (fun f ->
               Aws.Query.Pair ("AllowDnsResolutionFromRemoteVpc", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map
             v.allow_egress_from_local_vpc_to_remote_classic_link
             (fun f -> "allowEgressFromLocalVpcToRemoteClassicLink", Boolean.to_json f)
         ; Aws.Util.option_map
             v.allow_egress_from_local_classic_link_to_remote_vpc
             (fun f -> "allowEgressFromLocalClassicLinkToRemoteVpc", Boolean.to_json f)
         ; Aws.Util.option_map v.allow_dns_resolution_from_remote_vpc (fun f ->
               "allowDnsResolutionFromRemoteVpc", Boolean.to_json f)
         ])

  let of_json j =
    { allow_dns_resolution_from_remote_vpc =
        Aws.Util.option_map
          (Aws.Json.lookup j "allowDnsResolutionFromRemoteVpc")
          Boolean.of_json
    ; allow_egress_from_local_classic_link_to_remote_vpc =
        Aws.Util.option_map
          (Aws.Json.lookup j "allowEgressFromLocalClassicLinkToRemoteVpc")
          Boolean.of_json
    ; allow_egress_from_local_vpc_to_remote_classic_link =
        Aws.Util.option_map
          (Aws.Json.lookup j "allowEgressFromLocalVpcToRemoteClassicLink")
          Boolean.of_json
    }
end

module Ipv6CidrBlock = struct
  type t = { ipv6_cidr_block : String.t option }

  let make ?ipv6_cidr_block () = { ipv6_cidr_block }

  let parse xml =
    Some
      { ipv6_cidr_block =
          Aws.Util.option_bind (Aws.Xml.member "ipv6CidrBlock" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ipv6_cidr_block (fun f ->
               Aws.Query.Pair ("Ipv6CidrBlock", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ipv6_cidr_block (fun f ->
               "ipv6CidrBlock", String.to_json f)
         ])

  let of_json j =
    { ipv6_cidr_block =
        Aws.Util.option_map (Aws.Json.lookup j "ipv6CidrBlock") String.of_json
    }
end

module Ipv6CidrBlockSet = struct
  type t = Ipv6CidrBlock.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Ipv6CidrBlock.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Ipv6CidrBlock.to_query v

  let to_json v = `List (List.map Ipv6CidrBlock.to_json v)

  let of_json j = Aws.Json.to_list Ipv6CidrBlock.of_json j
end

module CidrBlock = struct
  type t = { cidr_block : String.t option }

  let make ?cidr_block () = { cidr_block }

  let parse xml =
    Some
      { cidr_block = Aws.Util.option_bind (Aws.Xml.member "cidrBlock" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cidr_block (fun f ->
               Aws.Query.Pair ("CidrBlock", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cidr_block (fun f -> "cidrBlock", String.to_json f) ])

  let of_json j =
    { cidr_block = Aws.Util.option_map (Aws.Json.lookup j "cidrBlock") String.of_json }
end

module CidrBlockSet = struct
  type t = CidrBlock.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map CidrBlock.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list CidrBlock.to_query v

  let to_json v = `List (List.map CidrBlock.to_json v)

  let of_json j = Aws.Json.to_list CidrBlock.of_json j
end

module VpcPeeringConnectionVpcInfo = struct
  type t =
    { cidr_block : String.t option
    ; ipv6_cidr_block_set : Ipv6CidrBlockSet.t
    ; cidr_block_set : CidrBlockSet.t
    ; owner_id : String.t option
    ; peering_options : VpcPeeringConnectionOptionsDescription.t option
    ; vpc_id : String.t option
    ; region : String.t option
    }

  let make
      ?cidr_block
      ?(ipv6_cidr_block_set = [])
      ?(cidr_block_set = [])
      ?owner_id
      ?peering_options
      ?vpc_id
      ?region
      () =
    { cidr_block
    ; ipv6_cidr_block_set
    ; cidr_block_set
    ; owner_id
    ; peering_options
    ; vpc_id
    ; region
    }

  let parse xml =
    Some
      { cidr_block = Aws.Util.option_bind (Aws.Xml.member "cidrBlock" xml) String.parse
      ; ipv6_cidr_block_set =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ipv6CidrBlockSet" xml)
               Ipv6CidrBlockSet.parse)
      ; cidr_block_set =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "cidrBlockSet" xml) CidrBlockSet.parse)
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; peering_options =
          Aws.Util.option_bind
            (Aws.Xml.member "peeringOptions" xml)
            VpcPeeringConnectionOptionsDescription.parse
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse
      ; region = Aws.Util.option_bind (Aws.Xml.member "region" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.region (fun f ->
               Aws.Query.Pair ("Region", String.to_query f))
         ; Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Aws.Util.option_map v.peering_options (fun f ->
               Aws.Query.Pair
                 ("PeeringOptions", VpcPeeringConnectionOptionsDescription.to_query f))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Some (Aws.Query.Pair ("CidrBlockSet", CidrBlockSet.to_query v.cidr_block_set))
         ; Some
             (Aws.Query.Pair
                ("Ipv6CidrBlockSet", Ipv6CidrBlockSet.to_query v.ipv6_cidr_block_set))
         ; Aws.Util.option_map v.cidr_block (fun f ->
               Aws.Query.Pair ("CidrBlock", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.region (fun f -> "region", String.to_json f)
         ; Aws.Util.option_map v.vpc_id (fun f -> "vpcId", String.to_json f)
         ; Aws.Util.option_map v.peering_options (fun f ->
               "peeringOptions", VpcPeeringConnectionOptionsDescription.to_json f)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Some ("cidrBlockSet", CidrBlockSet.to_json v.cidr_block_set)
         ; Some ("ipv6CidrBlockSet", Ipv6CidrBlockSet.to_json v.ipv6_cidr_block_set)
         ; Aws.Util.option_map v.cidr_block (fun f -> "cidrBlock", String.to_json f)
         ])

  let of_json j =
    { cidr_block = Aws.Util.option_map (Aws.Json.lookup j "cidrBlock") String.of_json
    ; ipv6_cidr_block_set =
        Ipv6CidrBlockSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ipv6CidrBlockSet"))
    ; cidr_block_set =
        CidrBlockSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "cidrBlockSet"))
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; peering_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "peeringOptions")
          VpcPeeringConnectionOptionsDescription.of_json
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "vpcId") String.of_json
    ; region = Aws.Util.option_map (Aws.Json.lookup j "region") String.of_json
    }
end

module FleetReplacementStrategy = struct
  type t = Launch

  let str_to_t = [ "launch", Launch ]

  let t_to_str = [ Launch, "launch" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module SpotPrice = struct
  type t =
    { availability_zone : String.t option
    ; instance_type : InstanceType.t option
    ; product_description : RIProductDescription.t option
    ; spot_price : String.t option
    ; timestamp : DateTime.t option
    }

  let make
      ?availability_zone
      ?instance_type
      ?product_description
      ?spot_price
      ?timestamp
      () =
    { availability_zone; instance_type; product_description; spot_price; timestamp }

  let parse xml =
    Some
      { availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) InstanceType.parse
      ; product_description =
          Aws.Util.option_bind
            (Aws.Xml.member "productDescription" xml)
            RIProductDescription.parse
      ; spot_price = Aws.Util.option_bind (Aws.Xml.member "spotPrice" xml) String.parse
      ; timestamp = Aws.Util.option_bind (Aws.Xml.member "timestamp" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timestamp (fun f ->
               Aws.Query.Pair ("Timestamp", DateTime.to_query f))
         ; Aws.Util.option_map v.spot_price (fun f ->
               Aws.Query.Pair ("SpotPrice", String.to_query f))
         ; Aws.Util.option_map v.product_description (fun f ->
               Aws.Query.Pair ("ProductDescription", RIProductDescription.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", InstanceType.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timestamp (fun f -> "timestamp", DateTime.to_json f)
         ; Aws.Util.option_map v.spot_price (fun f -> "spotPrice", String.to_json f)
         ; Aws.Util.option_map v.product_description (fun f ->
               "productDescription", RIProductDescription.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f ->
               "instanceType", InstanceType.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ])

  let of_json j =
    { availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") InstanceType.of_json
    ; product_description =
        Aws.Util.option_map
          (Aws.Json.lookup j "productDescription")
          RIProductDescription.of_json
    ; spot_price = Aws.Util.option_map (Aws.Json.lookup j "spotPrice") String.of_json
    ; timestamp = Aws.Util.option_map (Aws.Json.lookup j "timestamp") DateTime.of_json
    }
end

module SpotPriceHistoryList = struct
  type t = SpotPrice.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map SpotPrice.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list SpotPrice.to_query v

  let to_json v = `List (List.map SpotPrice.to_json v)

  let of_json j = Aws.Json.to_list SpotPrice.of_json j
end

module DescribeSpotPriceHistoryResult = struct
  type t =
    { next_token : String.t option
    ; spot_price_history : SpotPriceHistoryList.t
    }

  let make ?next_token ?(spot_price_history = []) () = { next_token; spot_price_history }

  let parse xml =
    Some
      { next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; spot_price_history =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "spotPriceHistorySet" xml)
               SpotPriceHistoryList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("SpotPriceHistorySet", SpotPriceHistoryList.to_query v.spot_price_history))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("spotPriceHistorySet", SpotPriceHistoryList.to_json v.spot_price_history)
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ])

  let of_json j =
    { next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; spot_price_history =
        SpotPriceHistoryList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "spotPriceHistorySet"))
    }
end

module ReplacementStrategy = struct
  type t = Launch

  let str_to_t = [ "launch", Launch ]

  let t_to_str = [ Launch, "launch" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module SpotCapacityRebalance = struct
  type t = { replacement_strategy : ReplacementStrategy.t option }

  let make ?replacement_strategy () = { replacement_strategy }

  let parse xml =
    Some
      { replacement_strategy =
          Aws.Util.option_bind
            (Aws.Xml.member "replacementStrategy" xml)
            ReplacementStrategy.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.replacement_strategy (fun f ->
               Aws.Query.Pair ("ReplacementStrategy", ReplacementStrategy.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.replacement_strategy (fun f ->
               "replacementStrategy", ReplacementStrategy.to_json f)
         ])

  let of_json j =
    { replacement_strategy =
        Aws.Util.option_map
          (Aws.Json.lookup j "replacementStrategy")
          ReplacementStrategy.of_json
    }
end

module RequestHostIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeHostsRequest = struct
  type t =
    { filter : FilterList.t
    ; host_ids : RequestHostIdList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?(filter = []) ?(host_ids = []) ?max_results ?next_token () =
    { filter; host_ids; max_results; next_token }

  let parse xml =
    Some
      { filter =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "filter" xml) FilterList.parse)
      ; host_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "hostId" xml) RequestHostIdList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "maxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("HostId", RequestHostIdList.to_query v.host_ids))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filter))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "maxResults", Integer.to_json f)
         ; Some ("hostId", RequestHostIdList.to_json v.host_ids)
         ; Some ("filter", FilterList.to_json v.filter)
         ])

  let of_json j =
    { filter = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "filter"))
    ; host_ids =
        RequestHostIdList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "hostId"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "maxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DescribeAggregateIdFormatResult = struct
  type t =
    { use_long_ids_aggregated : Boolean.t option
    ; statuses : IdFormatList.t
    }

  let make ?use_long_ids_aggregated ?(statuses = []) () =
    { use_long_ids_aggregated; statuses }

  let parse xml =
    Some
      { use_long_ids_aggregated =
          Aws.Util.option_bind (Aws.Xml.member "useLongIdsAggregated" xml) Boolean.parse
      ; statuses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "statusSet" xml) IdFormatList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("StatusSet", IdFormatList.to_query v.statuses))
         ; Aws.Util.option_map v.use_long_ids_aggregated (fun f ->
               Aws.Query.Pair ("UseLongIdsAggregated", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("statusSet", IdFormatList.to_json v.statuses)
         ; Aws.Util.option_map v.use_long_ids_aggregated (fun f ->
               "useLongIdsAggregated", Boolean.to_json f)
         ])

  let of_json j =
    { use_long_ids_aggregated =
        Aws.Util.option_map (Aws.Json.lookup j "useLongIdsAggregated") Boolean.of_json
    ; statuses =
        IdFormatList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "statusSet"))
    }
end

module AssociateVpcCidrBlockRequest = struct
  type t =
    { amazon_provided_ipv6_cidr_block : Boolean.t option
    ; cidr_block : String.t option
    ; vpc_id : String.t
    ; ipv6_cidr_block_network_border_group : String.t option
    ; ipv6_pool : String.t option
    ; ipv6_cidr_block : String.t option
    }

  let make
      ?amazon_provided_ipv6_cidr_block
      ?cidr_block
      ~vpc_id
      ?ipv6_cidr_block_network_border_group
      ?ipv6_pool
      ?ipv6_cidr_block
      () =
    { amazon_provided_ipv6_cidr_block
    ; cidr_block
    ; vpc_id
    ; ipv6_cidr_block_network_border_group
    ; ipv6_pool
    ; ipv6_cidr_block
    }

  let parse xml =
    Some
      { amazon_provided_ipv6_cidr_block =
          Aws.Util.option_bind
            (Aws.Xml.member "amazonProvidedIpv6CidrBlock" xml)
            Boolean.parse
      ; cidr_block = Aws.Util.option_bind (Aws.Xml.member "CidrBlock" xml) String.parse
      ; vpc_id =
          Aws.Xml.required
            "vpcId"
            (Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse)
      ; ipv6_cidr_block_network_border_group =
          Aws.Util.option_bind
            (Aws.Xml.member "Ipv6CidrBlockNetworkBorderGroup" xml)
            String.parse
      ; ipv6_pool = Aws.Util.option_bind (Aws.Xml.member "Ipv6Pool" xml) String.parse
      ; ipv6_cidr_block =
          Aws.Util.option_bind (Aws.Xml.member "Ipv6CidrBlock" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ipv6_cidr_block (fun f ->
               Aws.Query.Pair ("Ipv6CidrBlock", String.to_query f))
         ; Aws.Util.option_map v.ipv6_pool (fun f ->
               Aws.Query.Pair ("Ipv6Pool", String.to_query f))
         ; Aws.Util.option_map v.ipv6_cidr_block_network_border_group (fun f ->
               Aws.Query.Pair ("Ipv6CidrBlockNetworkBorderGroup", String.to_query f))
         ; Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ; Aws.Util.option_map v.cidr_block (fun f ->
               Aws.Query.Pair ("CidrBlock", String.to_query f))
         ; Aws.Util.option_map v.amazon_provided_ipv6_cidr_block (fun f ->
               Aws.Query.Pair ("AmazonProvidedIpv6CidrBlock", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ipv6_cidr_block (fun f ->
               "Ipv6CidrBlock", String.to_json f)
         ; Aws.Util.option_map v.ipv6_pool (fun f -> "Ipv6Pool", String.to_json f)
         ; Aws.Util.option_map v.ipv6_cidr_block_network_border_group (fun f ->
               "Ipv6CidrBlockNetworkBorderGroup", String.to_json f)
         ; Some ("vpcId", String.to_json v.vpc_id)
         ; Aws.Util.option_map v.cidr_block (fun f -> "CidrBlock", String.to_json f)
         ; Aws.Util.option_map v.amazon_provided_ipv6_cidr_block (fun f ->
               "amazonProvidedIpv6CidrBlock", Boolean.to_json f)
         ])

  let of_json j =
    { amazon_provided_ipv6_cidr_block =
        Aws.Util.option_map
          (Aws.Json.lookup j "amazonProvidedIpv6CidrBlock")
          Boolean.of_json
    ; cidr_block = Aws.Util.option_map (Aws.Json.lookup j "CidrBlock") String.of_json
    ; vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "vpcId"))
    ; ipv6_cidr_block_network_border_group =
        Aws.Util.option_map
          (Aws.Json.lookup j "Ipv6CidrBlockNetworkBorderGroup")
          String.of_json
    ; ipv6_pool = Aws.Util.option_map (Aws.Json.lookup j "Ipv6Pool") String.of_json
    ; ipv6_cidr_block =
        Aws.Util.option_map (Aws.Json.lookup j "Ipv6CidrBlock") String.of_json
    }
end

module UnlimitedSupportedInstanceFamily = struct
  type t =
    | T2
    | T3
    | T3a
    | T4g

  let str_to_t = [ "t4g", T4g; "t3a", T3a; "t3", T3; "t2", T2 ]

  let t_to_str = [ T4g, "t4g"; T3a, "t3a"; T3, "t3"; T2, "t2" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ModifyDefaultCreditSpecificationRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; instance_family : UnlimitedSupportedInstanceFamily.t
    ; cpu_credits : String.t
    }

  let make ?dry_run ~instance_family ~cpu_credits () =
    { dry_run; instance_family; cpu_credits }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; instance_family =
          Aws.Xml.required
            "InstanceFamily"
            (Aws.Util.option_bind
               (Aws.Xml.member "InstanceFamily" xml)
               UnlimitedSupportedInstanceFamily.parse)
      ; cpu_credits =
          Aws.Xml.required
            "CpuCredits"
            (Aws.Util.option_bind (Aws.Xml.member "CpuCredits" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("CpuCredits", String.to_query v.cpu_credits))
         ; Some
             (Aws.Query.Pair
                ( "InstanceFamily"
                , UnlimitedSupportedInstanceFamily.to_query v.instance_family ))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("CpuCredits", String.to_json v.cpu_credits)
         ; Some
             ("InstanceFamily", UnlimitedSupportedInstanceFamily.to_json v.instance_family)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; instance_family =
        UnlimitedSupportedInstanceFamily.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceFamily"))
    ; cpu_credits =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "CpuCredits"))
    }
end

module DhcpOptionsIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "DhcpOptionsId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeDhcpOptionsRequest = struct
  type t =
    { dhcp_options_ids : DhcpOptionsIdStringList.t
    ; filters : FilterList.t
    ; dry_run : Boolean.t option
    ; next_token : String.t option
    ; max_results : Integer.t option
    }

  let make ?(dhcp_options_ids = []) ?(filters = []) ?dry_run ?next_token ?max_results () =
    { dhcp_options_ids; filters; dry_run; next_token; max_results }

  let parse xml =
    Some
      { dhcp_options_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "DhcpOptionsId" xml)
               DhcpOptionsIdStringList.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ("DhcpOptionsId", DhcpOptionsIdStringList.to_query v.dhcp_options_ids))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some ("DhcpOptionsId", DhcpOptionsIdStringList.to_json v.dhcp_options_ids)
         ])

  let of_json j =
    { dhcp_options_ids =
        DhcpOptionsIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DhcpOptionsId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module Scope = struct
  type t =
    | Availability_Zone
    | Region

  let str_to_t = [ "Region", Region; "Availability Zone", Availability_Zone ]

  let t_to_str = [ Region, "Region"; Availability_Zone, "Availability Zone" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ReservedInstanceState = struct
  type t =
    | Payment_pending
    | Active
    | Payment_failed
    | Retired
    | Queued
    | Queued_deleted

  let str_to_t =
    [ "queued-deleted", Queued_deleted
    ; "queued", Queued
    ; "retired", Retired
    ; "payment-failed", Payment_failed
    ; "active", Active
    ; "payment-pending", Payment_pending
    ]

  let t_to_str =
    [ Queued_deleted, "queued-deleted"
    ; Queued, "queued"
    ; Retired, "retired"
    ; Payment_failed, "payment-failed"
    ; Active, "active"
    ; Payment_pending, "payment-pending"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module RecurringChargeFrequency = struct
  type t = Hourly

  let str_to_t = [ "Hourly", Hourly ]

  let t_to_str = [ Hourly, "Hourly" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module RecurringCharge = struct
  type t =
    { amount : Double.t option
    ; frequency : RecurringChargeFrequency.t option
    }

  let make ?amount ?frequency () = { amount; frequency }

  let parse xml =
    Some
      { amount = Aws.Util.option_bind (Aws.Xml.member "amount" xml) Double.parse
      ; frequency =
          Aws.Util.option_bind
            (Aws.Xml.member "frequency" xml)
            RecurringChargeFrequency.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.frequency (fun f ->
               Aws.Query.Pair ("Frequency", RecurringChargeFrequency.to_query f))
         ; Aws.Util.option_map v.amount (fun f ->
               Aws.Query.Pair ("Amount", Double.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.frequency (fun f ->
               "frequency", RecurringChargeFrequency.to_json f)
         ; Aws.Util.option_map v.amount (fun f -> "amount", Double.to_json f)
         ])

  let of_json j =
    { amount = Aws.Util.option_map (Aws.Json.lookup j "amount") Double.of_json
    ; frequency =
        Aws.Util.option_map
          (Aws.Json.lookup j "frequency")
          RecurringChargeFrequency.of_json
    }
end

module RecurringChargesList = struct
  type t = RecurringCharge.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map RecurringCharge.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list RecurringCharge.to_query v

  let to_json v = `List (List.map RecurringCharge.to_json v)

  let of_json j = Aws.Json.to_list RecurringCharge.of_json j
end

module OfferingTypeValues = struct
  type t =
    | Heavy_Utilization
    | Medium_Utilization
    | Light_Utilization
    | No_Upfront
    | Partial_Upfront
    | All_Upfront

  let str_to_t =
    [ "All Upfront", All_Upfront
    ; "Partial Upfront", Partial_Upfront
    ; "No Upfront", No_Upfront
    ; "Light Utilization", Light_Utilization
    ; "Medium Utilization", Medium_Utilization
    ; "Heavy Utilization", Heavy_Utilization
    ]

  let t_to_str =
    [ All_Upfront, "All Upfront"
    ; Partial_Upfront, "Partial Upfront"
    ; No_Upfront, "No Upfront"
    ; Light_Utilization, "Light Utilization"
    ; Medium_Utilization, "Medium Utilization"
    ; Heavy_Utilization, "Heavy Utilization"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module OfferingClassType = struct
  type t =
    | Standard
    | Convertible

  let str_to_t = [ "convertible", Convertible; "standard", Standard ]

  let t_to_str = [ Convertible, "convertible"; Standard, "standard" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ReservedInstances = struct
  type t =
    { availability_zone : String.t option
    ; duration : Long.t option
    ; end_ : DateTime.t option
    ; fixed_price : Float.t option
    ; instance_count : Integer.t option
    ; instance_type : InstanceType.t option
    ; product_description : RIProductDescription.t option
    ; reserved_instances_id : String.t option
    ; start : DateTime.t option
    ; state : ReservedInstanceState.t option
    ; usage_price : Float.t option
    ; currency_code : CurrencyCodeValues.t option
    ; instance_tenancy : Tenancy.t option
    ; offering_class : OfferingClassType.t option
    ; offering_type : OfferingTypeValues.t option
    ; recurring_charges : RecurringChargesList.t
    ; scope : Scope.t option
    ; tags : TagList.t
    }

  let make
      ?availability_zone
      ?duration
      ?end_
      ?fixed_price
      ?instance_count
      ?instance_type
      ?product_description
      ?reserved_instances_id
      ?start
      ?state
      ?usage_price
      ?currency_code
      ?instance_tenancy
      ?offering_class
      ?offering_type
      ?(recurring_charges = [])
      ?scope
      ?(tags = [])
      () =
    { availability_zone
    ; duration
    ; end_
    ; fixed_price
    ; instance_count
    ; instance_type
    ; product_description
    ; reserved_instances_id
    ; start
    ; state
    ; usage_price
    ; currency_code
    ; instance_tenancy
    ; offering_class
    ; offering_type
    ; recurring_charges
    ; scope
    ; tags
    }

  let parse xml =
    Some
      { availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; duration = Aws.Util.option_bind (Aws.Xml.member "duration" xml) Long.parse
      ; end_ = Aws.Util.option_bind (Aws.Xml.member "end" xml) DateTime.parse
      ; fixed_price = Aws.Util.option_bind (Aws.Xml.member "fixedPrice" xml) Float.parse
      ; instance_count =
          Aws.Util.option_bind (Aws.Xml.member "instanceCount" xml) Integer.parse
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) InstanceType.parse
      ; product_description =
          Aws.Util.option_bind
            (Aws.Xml.member "productDescription" xml)
            RIProductDescription.parse
      ; reserved_instances_id =
          Aws.Util.option_bind (Aws.Xml.member "reservedInstancesId" xml) String.parse
      ; start = Aws.Util.option_bind (Aws.Xml.member "start" xml) DateTime.parse
      ; state =
          Aws.Util.option_bind (Aws.Xml.member "state" xml) ReservedInstanceState.parse
      ; usage_price = Aws.Util.option_bind (Aws.Xml.member "usagePrice" xml) Float.parse
      ; currency_code =
          Aws.Util.option_bind
            (Aws.Xml.member "currencyCode" xml)
            CurrencyCodeValues.parse
      ; instance_tenancy =
          Aws.Util.option_bind (Aws.Xml.member "instanceTenancy" xml) Tenancy.parse
      ; offering_class =
          Aws.Util.option_bind
            (Aws.Xml.member "offeringClass" xml)
            OfferingClassType.parse
      ; offering_type =
          Aws.Util.option_bind
            (Aws.Xml.member "offeringType" xml)
            OfferingTypeValues.parse
      ; recurring_charges =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "recurringCharges" xml)
               RecurringChargesList.parse)
      ; scope = Aws.Util.option_bind (Aws.Xml.member "scope" xml) Scope.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.scope (fun f ->
               Aws.Query.Pair ("Scope", Scope.to_query f))
         ; Some
             (Aws.Query.Pair
                ("RecurringCharges", RecurringChargesList.to_query v.recurring_charges))
         ; Aws.Util.option_map v.offering_type (fun f ->
               Aws.Query.Pair ("OfferingType", OfferingTypeValues.to_query f))
         ; Aws.Util.option_map v.offering_class (fun f ->
               Aws.Query.Pair ("OfferingClass", OfferingClassType.to_query f))
         ; Aws.Util.option_map v.instance_tenancy (fun f ->
               Aws.Query.Pair ("InstanceTenancy", Tenancy.to_query f))
         ; Aws.Util.option_map v.currency_code (fun f ->
               Aws.Query.Pair ("CurrencyCode", CurrencyCodeValues.to_query f))
         ; Aws.Util.option_map v.usage_price (fun f ->
               Aws.Query.Pair ("UsagePrice", Float.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", ReservedInstanceState.to_query f))
         ; Aws.Util.option_map v.start (fun f ->
               Aws.Query.Pair ("Start", DateTime.to_query f))
         ; Aws.Util.option_map v.reserved_instances_id (fun f ->
               Aws.Query.Pair ("ReservedInstancesId", String.to_query f))
         ; Aws.Util.option_map v.product_description (fun f ->
               Aws.Query.Pair ("ProductDescription", RIProductDescription.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", InstanceType.to_query f))
         ; Aws.Util.option_map v.instance_count (fun f ->
               Aws.Query.Pair ("InstanceCount", Integer.to_query f))
         ; Aws.Util.option_map v.fixed_price (fun f ->
               Aws.Query.Pair ("FixedPrice", Float.to_query f))
         ; Aws.Util.option_map v.end_ (fun f ->
               Aws.Query.Pair ("End", DateTime.to_query f))
         ; Aws.Util.option_map v.duration (fun f ->
               Aws.Query.Pair ("Duration", Long.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.scope (fun f -> "scope", Scope.to_json f)
         ; Some ("recurringCharges", RecurringChargesList.to_json v.recurring_charges)
         ; Aws.Util.option_map v.offering_type (fun f ->
               "offeringType", OfferingTypeValues.to_json f)
         ; Aws.Util.option_map v.offering_class (fun f ->
               "offeringClass", OfferingClassType.to_json f)
         ; Aws.Util.option_map v.instance_tenancy (fun f ->
               "instanceTenancy", Tenancy.to_json f)
         ; Aws.Util.option_map v.currency_code (fun f ->
               "currencyCode", CurrencyCodeValues.to_json f)
         ; Aws.Util.option_map v.usage_price (fun f -> "usagePrice", Float.to_json f)
         ; Aws.Util.option_map v.state (fun f -> "state", ReservedInstanceState.to_json f)
         ; Aws.Util.option_map v.start (fun f -> "start", DateTime.to_json f)
         ; Aws.Util.option_map v.reserved_instances_id (fun f ->
               "reservedInstancesId", String.to_json f)
         ; Aws.Util.option_map v.product_description (fun f ->
               "productDescription", RIProductDescription.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f ->
               "instanceType", InstanceType.to_json f)
         ; Aws.Util.option_map v.instance_count (fun f ->
               "instanceCount", Integer.to_json f)
         ; Aws.Util.option_map v.fixed_price (fun f -> "fixedPrice", Float.to_json f)
         ; Aws.Util.option_map v.end_ (fun f -> "end", DateTime.to_json f)
         ; Aws.Util.option_map v.duration (fun f -> "duration", Long.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ])

  let of_json j =
    { availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; duration = Aws.Util.option_map (Aws.Json.lookup j "duration") Long.of_json
    ; end_ = Aws.Util.option_map (Aws.Json.lookup j "end") DateTime.of_json
    ; fixed_price = Aws.Util.option_map (Aws.Json.lookup j "fixedPrice") Float.of_json
    ; instance_count =
        Aws.Util.option_map (Aws.Json.lookup j "instanceCount") Integer.of_json
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") InstanceType.of_json
    ; product_description =
        Aws.Util.option_map
          (Aws.Json.lookup j "productDescription")
          RIProductDescription.of_json
    ; reserved_instances_id =
        Aws.Util.option_map (Aws.Json.lookup j "reservedInstancesId") String.of_json
    ; start = Aws.Util.option_map (Aws.Json.lookup j "start") DateTime.of_json
    ; state =
        Aws.Util.option_map (Aws.Json.lookup j "state") ReservedInstanceState.of_json
    ; usage_price = Aws.Util.option_map (Aws.Json.lookup j "usagePrice") Float.of_json
    ; currency_code =
        Aws.Util.option_map (Aws.Json.lookup j "currencyCode") CurrencyCodeValues.of_json
    ; instance_tenancy =
        Aws.Util.option_map (Aws.Json.lookup j "instanceTenancy") Tenancy.of_json
    ; offering_class =
        Aws.Util.option_map (Aws.Json.lookup j "offeringClass") OfferingClassType.of_json
    ; offering_type =
        Aws.Util.option_map (Aws.Json.lookup j "offeringType") OfferingTypeValues.of_json
    ; recurring_charges =
        RecurringChargesList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "recurringCharges"))
    ; scope = Aws.Util.option_map (Aws.Json.lookup j "scope") Scope.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module ClientVpnAuthorizationRuleStatusCode = struct
  type t =
    | Authorizing
    | Active
    | Failed
    | Revoking

  let str_to_t =
    [ "revoking", Revoking
    ; "failed", Failed
    ; "active", Active
    ; "authorizing", Authorizing
    ]

  let t_to_str =
    [ Revoking, "revoking"
    ; Failed, "failed"
    ; Active, "active"
    ; Authorizing, "authorizing"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ClientVpnAuthorizationRuleStatus = struct
  type t =
    { code : ClientVpnAuthorizationRuleStatusCode.t option
    ; message : String.t option
    }

  let make ?code ?message () = { code; message }

  let parse xml =
    Some
      { code =
          Aws.Util.option_bind
            (Aws.Xml.member "code" xml)
            ClientVpnAuthorizationRuleStatusCode.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair ("Code", ClientVpnAuthorizationRuleStatusCode.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f)
         ; Aws.Util.option_map v.code (fun f ->
               "code", ClientVpnAuthorizationRuleStatusCode.to_json f)
         ])

  let of_json j =
    { code =
        Aws.Util.option_map
          (Aws.Json.lookup j "code")
          ClientVpnAuthorizationRuleStatusCode.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json
    }
end

module AuthorizationRule = struct
  type t =
    { client_vpn_endpoint_id : String.t option
    ; description : String.t option
    ; group_id : String.t option
    ; access_all : Boolean.t option
    ; destination_cidr : String.t option
    ; status : ClientVpnAuthorizationRuleStatus.t option
    }

  let make
      ?client_vpn_endpoint_id
      ?description
      ?group_id
      ?access_all
      ?destination_cidr
      ?status
      () =
    { client_vpn_endpoint_id
    ; description
    ; group_id
    ; access_all
    ; destination_cidr
    ; status
    }

  let parse xml =
    Some
      { client_vpn_endpoint_id =
          Aws.Util.option_bind (Aws.Xml.member "clientVpnEndpointId" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; group_id = Aws.Util.option_bind (Aws.Xml.member "groupId" xml) String.parse
      ; access_all = Aws.Util.option_bind (Aws.Xml.member "accessAll" xml) Boolean.parse
      ; destination_cidr =
          Aws.Util.option_bind (Aws.Xml.member "destinationCidr" xml) String.parse
      ; status =
          Aws.Util.option_bind
            (Aws.Xml.member "status" xml)
            ClientVpnAuthorizationRuleStatus.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", ClientVpnAuthorizationRuleStatus.to_query f))
         ; Aws.Util.option_map v.destination_cidr (fun f ->
               Aws.Query.Pair ("DestinationCidr", String.to_query f))
         ; Aws.Util.option_map v.access_all (fun f ->
               Aws.Query.Pair ("AccessAll", Boolean.to_query f))
         ; Aws.Util.option_map v.group_id (fun f ->
               Aws.Query.Pair ("GroupId", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.client_vpn_endpoint_id (fun f ->
               Aws.Query.Pair ("ClientVpnEndpointId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               "status", ClientVpnAuthorizationRuleStatus.to_json f)
         ; Aws.Util.option_map v.destination_cidr (fun f ->
               "destinationCidr", String.to_json f)
         ; Aws.Util.option_map v.access_all (fun f -> "accessAll", Boolean.to_json f)
         ; Aws.Util.option_map v.group_id (fun f -> "groupId", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Aws.Util.option_map v.client_vpn_endpoint_id (fun f ->
               "clientVpnEndpointId", String.to_json f)
         ])

  let of_json j =
    { client_vpn_endpoint_id =
        Aws.Util.option_map (Aws.Json.lookup j "clientVpnEndpointId") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; group_id = Aws.Util.option_map (Aws.Json.lookup j "groupId") String.of_json
    ; access_all = Aws.Util.option_map (Aws.Json.lookup j "accessAll") Boolean.of_json
    ; destination_cidr =
        Aws.Util.option_map (Aws.Json.lookup j "destinationCidr") String.of_json
    ; status =
        Aws.Util.option_map
          (Aws.Json.lookup j "status")
          ClientVpnAuthorizationRuleStatus.of_json
    }
end

module AuthorizationRuleSet = struct
  type t = AuthorizationRule.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map AuthorizationRule.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list AuthorizationRule.to_query v

  let to_json v = `List (List.map AuthorizationRule.to_json v)

  let of_json j = Aws.Json.to_list AuthorizationRule.of_json j
end

module AssignedPrivateIpAddress = struct
  type t = { private_ip_address : String.t option }

  let make ?private_ip_address () = { private_ip_address }

  let parse xml =
    Some
      { private_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "privateIpAddress" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.private_ip_address (fun f ->
               Aws.Query.Pair ("PrivateIpAddress", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.private_ip_address (fun f ->
               "privateIpAddress", String.to_json f)
         ])

  let of_json j =
    { private_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "privateIpAddress") String.of_json
    }
end

module AssignedPrivateIpAddressList = struct
  type t = AssignedPrivateIpAddress.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map AssignedPrivateIpAddress.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list AssignedPrivateIpAddress.to_query v

  let to_json v = `List (List.map AssignedPrivateIpAddress.to_json v)

  let of_json j = Aws.Json.to_list AssignedPrivateIpAddress.of_json j
end

module VolumeModificationState = struct
  type t =
    | Modifying
    | Optimizing
    | Completed
    | Failed

  let str_to_t =
    [ "failed", Failed
    ; "completed", Completed
    ; "optimizing", Optimizing
    ; "modifying", Modifying
    ]

  let t_to_str =
    [ Failed, "failed"
    ; Completed, "completed"
    ; Optimizing, "optimizing"
    ; Modifying, "modifying"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ImageAttributeName = struct
  type t =
    | Description
    | Kernel
    | Ramdisk
    | LaunchPermission
    | ProductCodes
    | BlockDeviceMapping
    | SriovNetSupport

  let str_to_t =
    [ "sriovNetSupport", SriovNetSupport
    ; "blockDeviceMapping", BlockDeviceMapping
    ; "productCodes", ProductCodes
    ; "launchPermission", LaunchPermission
    ; "ramdisk", Ramdisk
    ; "kernel", Kernel
    ; "description", Description
    ]

  let t_to_str =
    [ SriovNetSupport, "sriovNetSupport"
    ; BlockDeviceMapping, "blockDeviceMapping"
    ; ProductCodes, "productCodes"
    ; LaunchPermission, "launchPermission"
    ; Ramdisk, "ramdisk"
    ; Kernel, "kernel"
    ; Description, "description"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DeleteTransitGatewayPrefixListReferenceRequest = struct
  type t =
    { transit_gateway_route_table_id : String.t
    ; prefix_list_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~transit_gateway_route_table_id ~prefix_list_id ?dry_run () =
    { transit_gateway_route_table_id; prefix_list_id; dry_run }

  let parse xml =
    Some
      { transit_gateway_route_table_id =
          Aws.Xml.required
            "TransitGatewayRouteTableId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayRouteTableId" xml)
               String.parse)
      ; prefix_list_id =
          Aws.Xml.required
            "PrefixListId"
            (Aws.Util.option_bind (Aws.Xml.member "PrefixListId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("PrefixListId", String.to_query v.prefix_list_id))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayRouteTableId"
                , String.to_query v.transit_gateway_route_table_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("PrefixListId", String.to_json v.prefix_list_id)
         ; Some
             ( "TransitGatewayRouteTableId"
             , String.to_json v.transit_gateway_route_table_id )
         ])

  let of_json j =
    { transit_gateway_route_table_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayRouteTableId"))
    ; prefix_list_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PrefixListId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module AcceptReservedInstancesExchangeQuoteResult = struct
  type t = { exchange_id : String.t option }

  let make ?exchange_id () = { exchange_id }

  let parse xml =
    Some
      { exchange_id = Aws.Util.option_bind (Aws.Xml.member "exchangeId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.exchange_id (fun f ->
               Aws.Query.Pair ("ExchangeId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.exchange_id (fun f -> "exchangeId", String.to_json f) ])

  let of_json j =
    { exchange_id = Aws.Util.option_map (Aws.Json.lookup j "exchangeId") String.of_json }
end

module CopyFpgaImageResult = struct
  type t = { fpga_image_id : String.t option }

  let make ?fpga_image_id () = { fpga_image_id }

  let parse xml =
    Some
      { fpga_image_id =
          Aws.Util.option_bind (Aws.Xml.member "fpgaImageId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.fpga_image_id (fun f ->
               Aws.Query.Pair ("FpgaImageId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.fpga_image_id (fun f -> "fpgaImageId", String.to_json f)
         ])

  let of_json j =
    { fpga_image_id = Aws.Util.option_map (Aws.Json.lookup j "fpgaImageId") String.of_json
    }
end

module ClientVpnSecurityGroupIdSet = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module ApplySecurityGroupsToClientVpnTargetNetworkRequest = struct
  type t =
    { client_vpn_endpoint_id : String.t
    ; vpc_id : String.t
    ; security_group_ids : ClientVpnSecurityGroupIdSet.t
    ; dry_run : Boolean.t option
    }

  let make ~client_vpn_endpoint_id ~vpc_id ~security_group_ids ?dry_run () =
    { client_vpn_endpoint_id; vpc_id; security_group_ids; dry_run }

  let parse xml =
    Some
      { client_vpn_endpoint_id =
          Aws.Xml.required
            "ClientVpnEndpointId"
            (Aws.Util.option_bind (Aws.Xml.member "ClientVpnEndpointId" xml) String.parse)
      ; vpc_id =
          Aws.Xml.required
            "VpcId"
            (Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) String.parse)
      ; security_group_ids =
          Aws.Xml.required
            "SecurityGroupId"
            (Aws.Util.option_bind
               (Aws.Xml.member "SecurityGroupId" xml)
               ClientVpnSecurityGroupIdSet.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "SecurityGroupId"
                , ClientVpnSecurityGroupIdSet.to_query v.security_group_ids ))
         ; Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ; Some
             (Aws.Query.Pair
                ("ClientVpnEndpointId", String.to_query v.client_vpn_endpoint_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ("SecurityGroupId", ClientVpnSecurityGroupIdSet.to_json v.security_group_ids)
         ; Some ("VpcId", String.to_json v.vpc_id)
         ; Some ("ClientVpnEndpointId", String.to_json v.client_vpn_endpoint_id)
         ])

  let of_json j =
    { client_vpn_endpoint_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ClientVpnEndpointId"))
    ; vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcId"))
    ; security_group_ids =
        ClientVpnSecurityGroupIdSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SecurityGroupId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module ModifyAvailabilityZoneGroupResult = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module OwnerStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "Owner" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module FpgaImageIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeFpgaImagesRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; fpga_image_ids : FpgaImageIdList.t
    ; owners : OwnerStringList.t
    ; filters : FilterList.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    }

  let make
      ?dry_run
      ?(fpga_image_ids = [])
      ?(owners = [])
      ?(filters = [])
      ?next_token
      ?max_results
      () =
    { dry_run; fpga_image_ids; owners; filters; next_token; max_results }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; fpga_image_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "FpgaImageId" xml)
               FpgaImageIdList.parse)
      ; owners =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Owner" xml) OwnerStringList.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some (Aws.Query.Pair ("Owner", OwnerStringList.to_query v.owners))
         ; Some
             (Aws.Query.Pair ("FpgaImageId", FpgaImageIdList.to_query v.fpga_image_ids))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some ("Owner", OwnerStringList.to_json v.owners)
         ; Some ("FpgaImageId", FpgaImageIdList.to_json v.fpga_image_ids)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; fpga_image_ids =
        FpgaImageIdList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "FpgaImageId"))
    ; owners =
        OwnerStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Owner"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module FleetStateCode = struct
  type t =
    | Submitted
    | Active
    | Deleted
    | Failed
    | Deleted_running
    | Deleted_terminating
    | Modifying

  let str_to_t =
    [ "modifying", Modifying
    ; "deleted_terminating", Deleted_terminating
    ; "deleted_running", Deleted_running
    ; "failed", Failed
    ; "deleted", Deleted
    ; "active", Active
    ; "submitted", Submitted
    ]

  let t_to_str =
    [ Modifying, "modifying"
    ; Deleted_terminating, "deleted_terminating"
    ; Deleted_running, "deleted_running"
    ; Failed, "failed"
    ; Deleted, "deleted"
    ; Active, "active"
    ; Submitted, "submitted"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DeleteFleetSuccessItem = struct
  type t =
    { current_fleet_state : FleetStateCode.t option
    ; previous_fleet_state : FleetStateCode.t option
    ; fleet_id : String.t option
    }

  let make ?current_fleet_state ?previous_fleet_state ?fleet_id () =
    { current_fleet_state; previous_fleet_state; fleet_id }

  let parse xml =
    Some
      { current_fleet_state =
          Aws.Util.option_bind
            (Aws.Xml.member "currentFleetState" xml)
            FleetStateCode.parse
      ; previous_fleet_state =
          Aws.Util.option_bind
            (Aws.Xml.member "previousFleetState" xml)
            FleetStateCode.parse
      ; fleet_id = Aws.Util.option_bind (Aws.Xml.member "fleetId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.fleet_id (fun f ->
               Aws.Query.Pair ("FleetId", String.to_query f))
         ; Aws.Util.option_map v.previous_fleet_state (fun f ->
               Aws.Query.Pair ("PreviousFleetState", FleetStateCode.to_query f))
         ; Aws.Util.option_map v.current_fleet_state (fun f ->
               Aws.Query.Pair ("CurrentFleetState", FleetStateCode.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.fleet_id (fun f -> "fleetId", String.to_json f)
         ; Aws.Util.option_map v.previous_fleet_state (fun f ->
               "previousFleetState", FleetStateCode.to_json f)
         ; Aws.Util.option_map v.current_fleet_state (fun f ->
               "currentFleetState", FleetStateCode.to_json f)
         ])

  let of_json j =
    { current_fleet_state =
        Aws.Util.option_map (Aws.Json.lookup j "currentFleetState") FleetStateCode.of_json
    ; previous_fleet_state =
        Aws.Util.option_map
          (Aws.Json.lookup j "previousFleetState")
          FleetStateCode.of_json
    ; fleet_id = Aws.Util.option_map (Aws.Json.lookup j "fleetId") String.of_json
    }
end

module AssociatedRole = struct
  type t =
    { associated_role_arn : String.t option
    ; certificate_s3_bucket_name : String.t option
    ; certificate_s3_object_key : String.t option
    ; encryption_kms_key_id : String.t option
    }

  let make
      ?associated_role_arn
      ?certificate_s3_bucket_name
      ?certificate_s3_object_key
      ?encryption_kms_key_id
      () =
    { associated_role_arn
    ; certificate_s3_bucket_name
    ; certificate_s3_object_key
    ; encryption_kms_key_id
    }

  let parse xml =
    Some
      { associated_role_arn =
          Aws.Util.option_bind (Aws.Xml.member "associatedRoleArn" xml) String.parse
      ; certificate_s3_bucket_name =
          Aws.Util.option_bind (Aws.Xml.member "certificateS3BucketName" xml) String.parse
      ; certificate_s3_object_key =
          Aws.Util.option_bind (Aws.Xml.member "certificateS3ObjectKey" xml) String.parse
      ; encryption_kms_key_id =
          Aws.Util.option_bind (Aws.Xml.member "encryptionKmsKeyId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.encryption_kms_key_id (fun f ->
               Aws.Query.Pair ("EncryptionKmsKeyId", String.to_query f))
         ; Aws.Util.option_map v.certificate_s3_object_key (fun f ->
               Aws.Query.Pair ("CertificateS3ObjectKey", String.to_query f))
         ; Aws.Util.option_map v.certificate_s3_bucket_name (fun f ->
               Aws.Query.Pair ("CertificateS3BucketName", String.to_query f))
         ; Aws.Util.option_map v.associated_role_arn (fun f ->
               Aws.Query.Pair ("AssociatedRoleArn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.encryption_kms_key_id (fun f ->
               "encryptionKmsKeyId", String.to_json f)
         ; Aws.Util.option_map v.certificate_s3_object_key (fun f ->
               "certificateS3ObjectKey", String.to_json f)
         ; Aws.Util.option_map v.certificate_s3_bucket_name (fun f ->
               "certificateS3BucketName", String.to_json f)
         ; Aws.Util.option_map v.associated_role_arn (fun f ->
               "associatedRoleArn", String.to_json f)
         ])

  let of_json j =
    { associated_role_arn =
        Aws.Util.option_map (Aws.Json.lookup j "associatedRoleArn") String.of_json
    ; certificate_s3_bucket_name =
        Aws.Util.option_map (Aws.Json.lookup j "certificateS3BucketName") String.of_json
    ; certificate_s3_object_key =
        Aws.Util.option_map (Aws.Json.lookup j "certificateS3ObjectKey") String.of_json
    ; encryption_kms_key_id =
        Aws.Util.option_map (Aws.Json.lookup j "encryptionKmsKeyId") String.of_json
    }
end

module MulticastSupportValue = struct
  type t =
    | Enable
    | Disable

  let str_to_t = [ "disable", Disable; "enable", Enable ]

  let t_to_str = [ Disable, "disable"; Enable, "enable" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module MembershipType = struct
  type t =
    | Static
    | Igmp

  let str_to_t = [ "igmp", Igmp; "static", Static ]

  let t_to_str = [ Igmp, "igmp"; Static, "static" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module InstanceTypeList = struct
  type t = InstanceType.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map InstanceType.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list InstanceType.to_query v

  let to_json v = `List (List.map InstanceType.to_json v)

  let of_json j = Aws.Json.to_list InstanceType.of_json j
end

module InstanceLifecycle = struct
  type t =
    | Spot
    | On_demand

  let str_to_t = [ "on-demand", On_demand; "spot", Spot ]

  let t_to_str = [ On_demand, "on-demand"; Spot, "spot" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module CreateFleetError = struct
  type t =
    { launch_template_and_overrides : LaunchTemplateAndOverridesResponse.t option
    ; lifecycle : InstanceLifecycle.t option
    ; error_code : String.t option
    ; error_message : String.t option
    }

  let make ?launch_template_and_overrides ?lifecycle ?error_code ?error_message () =
    { launch_template_and_overrides; lifecycle; error_code; error_message }

  let parse xml =
    Some
      { launch_template_and_overrides =
          Aws.Util.option_bind
            (Aws.Xml.member "launchTemplateAndOverrides" xml)
            LaunchTemplateAndOverridesResponse.parse
      ; lifecycle =
          Aws.Util.option_bind (Aws.Xml.member "lifecycle" xml) InstanceLifecycle.parse
      ; error_code = Aws.Util.option_bind (Aws.Xml.member "errorCode" xml) String.parse
      ; error_message =
          Aws.Util.option_bind (Aws.Xml.member "errorMessage" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.error_message (fun f ->
               Aws.Query.Pair ("ErrorMessage", String.to_query f))
         ; Aws.Util.option_map v.error_code (fun f ->
               Aws.Query.Pair ("ErrorCode", String.to_query f))
         ; Aws.Util.option_map v.lifecycle (fun f ->
               Aws.Query.Pair ("Lifecycle", InstanceLifecycle.to_query f))
         ; Aws.Util.option_map v.launch_template_and_overrides (fun f ->
               Aws.Query.Pair
                 ( "LaunchTemplateAndOverrides"
                 , LaunchTemplateAndOverridesResponse.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.error_message (fun f -> "errorMessage", String.to_json f)
         ; Aws.Util.option_map v.error_code (fun f -> "errorCode", String.to_json f)
         ; Aws.Util.option_map v.lifecycle (fun f ->
               "lifecycle", InstanceLifecycle.to_json f)
         ; Aws.Util.option_map v.launch_template_and_overrides (fun f ->
               "launchTemplateAndOverrides", LaunchTemplateAndOverridesResponse.to_json f)
         ])

  let of_json j =
    { launch_template_and_overrides =
        Aws.Util.option_map
          (Aws.Json.lookup j "launchTemplateAndOverrides")
          LaunchTemplateAndOverridesResponse.of_json
    ; lifecycle =
        Aws.Util.option_map (Aws.Json.lookup j "lifecycle") InstanceLifecycle.of_json
    ; error_code = Aws.Util.option_map (Aws.Json.lookup j "errorCode") String.of_json
    ; error_message =
        Aws.Util.option_map (Aws.Json.lookup j "errorMessage") String.of_json
    }
end

module ClassicLinkDnsSupport = struct
  type t =
    { classic_link_dns_supported : Boolean.t option
    ; vpc_id : String.t option
    }

  let make ?classic_link_dns_supported ?vpc_id () = { classic_link_dns_supported; vpc_id }

  let parse xml =
    Some
      { classic_link_dns_supported =
          Aws.Util.option_bind
            (Aws.Xml.member "classicLinkDnsSupported" xml)
            Boolean.parse
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Aws.Util.option_map v.classic_link_dns_supported (fun f ->
               Aws.Query.Pair ("ClassicLinkDnsSupported", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_id (fun f -> "vpcId", String.to_json f)
         ; Aws.Util.option_map v.classic_link_dns_supported (fun f ->
               "classicLinkDnsSupported", Boolean.to_json f)
         ])

  let of_json j =
    { classic_link_dns_supported =
        Aws.Util.option_map (Aws.Json.lookup j "classicLinkDnsSupported") Boolean.of_json
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "vpcId") String.of_json
    }
end

module ClassicLinkDnsSupportList = struct
  type t = ClassicLinkDnsSupport.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ClassicLinkDnsSupport.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ClassicLinkDnsSupport.to_query v

  let to_json v = `List (List.map ClassicLinkDnsSupport.to_json v)

  let of_json j = Aws.Json.to_list ClassicLinkDnsSupport.of_json j
end

module VpcTenancy = struct
  type t = Default

  let str_to_t = [ "default", Default ]

  let t_to_str = [ Default, "default" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ModifyVpcTenancyRequest = struct
  type t =
    { vpc_id : String.t
    ; instance_tenancy : VpcTenancy.t
    ; dry_run : Boolean.t option
    }

  let make ~vpc_id ~instance_tenancy ?dry_run () = { vpc_id; instance_tenancy; dry_run }

  let parse xml =
    Some
      { vpc_id =
          Aws.Xml.required
            "VpcId"
            (Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) String.parse)
      ; instance_tenancy =
          Aws.Xml.required
            "InstanceTenancy"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceTenancy" xml) VpcTenancy.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair ("InstanceTenancy", VpcTenancy.to_query v.instance_tenancy))
         ; Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("InstanceTenancy", VpcTenancy.to_json v.instance_tenancy)
         ; Some ("VpcId", String.to_json v.vpc_id)
         ])

  let of_json j =
    { vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcId"))
    ; instance_tenancy =
        VpcTenancy.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceTenancy"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module ModifyVpcEndpointConnectionNotificationRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; connection_notification_id : String.t
    ; connection_notification_arn : String.t option
    ; connection_events : ValueStringList.t
    }

  let make
      ?dry_run
      ~connection_notification_id
      ?connection_notification_arn
      ?(connection_events = [])
      () =
    { dry_run
    ; connection_notification_id
    ; connection_notification_arn
    ; connection_events
    }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; connection_notification_id =
          Aws.Xml.required
            "ConnectionNotificationId"
            (Aws.Util.option_bind
               (Aws.Xml.member "ConnectionNotificationId" xml)
               String.parse)
      ; connection_notification_arn =
          Aws.Util.option_bind
            (Aws.Xml.member "ConnectionNotificationArn" xml)
            String.parse
      ; connection_events =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ConnectionEvents" xml)
               ValueStringList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("ConnectionEvents", ValueStringList.to_query v.connection_events))
         ; Aws.Util.option_map v.connection_notification_arn (fun f ->
               Aws.Query.Pair ("ConnectionNotificationArn", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ConnectionNotificationId", String.to_query v.connection_notification_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("ConnectionEvents", ValueStringList.to_json v.connection_events)
         ; Aws.Util.option_map v.connection_notification_arn (fun f ->
               "ConnectionNotificationArn", String.to_json f)
         ; Some ("ConnectionNotificationId", String.to_json v.connection_notification_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; connection_notification_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ConnectionNotificationId"))
    ; connection_notification_arn =
        Aws.Util.option_map (Aws.Json.lookup j "ConnectionNotificationArn") String.of_json
    ; connection_events =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ConnectionEvents"))
    }
end

module VpcEndpointServiceIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeVpcEndpointServiceConfigurationsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; service_ids : VpcEndpointServiceIdList.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?dry_run ?(service_ids = []) ?(filters = []) ?max_results ?next_token () =
    { dry_run; service_ids; filters; max_results; next_token }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; service_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ServiceId" xml)
               VpcEndpointServiceIdList.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair ("ServiceId", VpcEndpointServiceIdList.to_query v.service_ids))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some ("ServiceId", VpcEndpointServiceIdList.to_json v.service_ids)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; service_ids =
        VpcEndpointServiceIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ServiceId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module AssociateIamInstanceProfileRequest = struct
  type t =
    { iam_instance_profile : IamInstanceProfileSpecification.t
    ; instance_id : String.t
    }

  let make ~iam_instance_profile ~instance_id () = { iam_instance_profile; instance_id }

  let parse xml =
    Some
      { iam_instance_profile =
          Aws.Xml.required
            "IamInstanceProfile"
            (Aws.Util.option_bind
               (Aws.Xml.member "IamInstanceProfile" xml)
               IamInstanceProfileSpecification.parse)
      ; instance_id =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ; Some
             (Aws.Query.Pair
                ( "IamInstanceProfile"
                , IamInstanceProfileSpecification.to_query v.iam_instance_profile ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("InstanceId", String.to_json v.instance_id)
         ; Some
             ( "IamInstanceProfile"
             , IamInstanceProfileSpecification.to_json v.iam_instance_profile )
         ])

  let of_json j =
    { iam_instance_profile =
        IamInstanceProfileSpecification.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "IamInstanceProfile"))
    ; instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    }
end

module Phase2DHGroupNumbersListValue = struct
  type t = { value : Integer.t option }

  let make ?value () = { value }

  let parse xml =
    Some { value = Aws.Util.option_bind (Aws.Xml.member "value" xml) Integer.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f -> "value", Integer.to_json f) ])

  let of_json j =
    { value = Aws.Util.option_map (Aws.Json.lookup j "value") Integer.of_json }
end

module Phase2DHGroupNumbersList = struct
  type t = Phase2DHGroupNumbersListValue.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map Phase2DHGroupNumbersListValue.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Phase2DHGroupNumbersListValue.to_query v

  let to_json v = `List (List.map Phase2DHGroupNumbersListValue.to_json v)

  let of_json j = Aws.Json.to_list Phase2DHGroupNumbersListValue.of_json j
end

module ModifySpotFleetRequestResponse = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module CreateEgressOnlyInternetGatewayResult = struct
  type t =
    { client_token : String.t option
    ; egress_only_internet_gateway : EgressOnlyInternetGateway.t option
    }

  let make ?client_token ?egress_only_internet_gateway () =
    { client_token; egress_only_internet_gateway }

  let parse xml =
    Some
      { client_token =
          Aws.Util.option_bind (Aws.Xml.member "clientToken" xml) String.parse
      ; egress_only_internet_gateway =
          Aws.Util.option_bind
            (Aws.Xml.member "egressOnlyInternetGateway" xml)
            EgressOnlyInternetGateway.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.egress_only_internet_gateway (fun f ->
               Aws.Query.Pair
                 ("EgressOnlyInternetGateway", EgressOnlyInternetGateway.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.egress_only_internet_gateway (fun f ->
               "egressOnlyInternetGateway", EgressOnlyInternetGateway.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "clientToken", String.to_json f)
         ])

  let of_json j =
    { client_token = Aws.Util.option_map (Aws.Json.lookup j "clientToken") String.of_json
    ; egress_only_internet_gateway =
        Aws.Util.option_map
          (Aws.Json.lookup j "egressOnlyInternetGateway")
          EgressOnlyInternetGateway.of_json
    }
end

module CidrAuthorizationContext = struct
  type t =
    { message : String.t
    ; signature : String.t
    }

  let make ~message ~signature () = { message; signature }

  let parse xml =
    Some
      { message =
          Aws.Xml.required
            "Message"
            (Aws.Util.option_bind (Aws.Xml.member "Message" xml) String.parse)
      ; signature =
          Aws.Xml.required
            "Signature"
            (Aws.Util.option_bind (Aws.Xml.member "Signature" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Signature", String.to_query v.signature))
         ; Some (Aws.Query.Pair ("Message", String.to_query v.message))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Signature", String.to_json v.signature)
         ; Some ("Message", String.to_json v.message)
         ])

  let of_json j =
    { message = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Message"))
    ; signature = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Signature"))
    }
end

module ImageState = struct
  type t =
    | Pending
    | Available
    | Invalid
    | Deregistered
    | Transient
    | Failed
    | Error

  let str_to_t =
    [ "error", Error
    ; "failed", Failed
    ; "transient", Transient
    ; "deregistered", Deregistered
    ; "invalid", Invalid
    ; "available", Available
    ; "pending", Pending
    ]

  let t_to_str =
    [ Error, "error"
    ; Failed, "failed"
    ; Transient, "transient"
    ; Deregistered, "deregistered"
    ; Invalid, "invalid"
    ; Available, "available"
    ; Pending, "pending"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module InstanceCapacity = struct
  type t =
    { available_capacity : Integer.t option
    ; instance_type : String.t option
    ; total_capacity : Integer.t option
    }

  let make ?available_capacity ?instance_type ?total_capacity () =
    { available_capacity; instance_type; total_capacity }

  let parse xml =
    Some
      { available_capacity =
          Aws.Util.option_bind (Aws.Xml.member "availableCapacity" xml) Integer.parse
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) String.parse
      ; total_capacity =
          Aws.Util.option_bind (Aws.Xml.member "totalCapacity" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.total_capacity (fun f ->
               Aws.Query.Pair ("TotalCapacity", Integer.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", String.to_query f))
         ; Aws.Util.option_map v.available_capacity (fun f ->
               Aws.Query.Pair ("AvailableCapacity", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.total_capacity (fun f ->
               "totalCapacity", Integer.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f -> "instanceType", String.to_json f)
         ; Aws.Util.option_map v.available_capacity (fun f ->
               "availableCapacity", Integer.to_json f)
         ])

  let of_json j =
    { available_capacity =
        Aws.Util.option_map (Aws.Json.lookup j "availableCapacity") Integer.of_json
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") String.of_json
    ; total_capacity =
        Aws.Util.option_map (Aws.Json.lookup j "totalCapacity") Integer.of_json
    }
end

module AvailableInstanceCapacityList = struct
  type t = InstanceCapacity.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map InstanceCapacity.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list InstanceCapacity.to_query v

  let to_json v = `List (List.map InstanceCapacity.to_json v)

  let of_json j = Aws.Json.to_list InstanceCapacity.of_json j
end

module AssociatedNetworkType = struct
  type t = Vpc

  let str_to_t = [ "vpc", Vpc ]

  let t_to_str = [ Vpc, "vpc" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module AssociatedTargetNetwork = struct
  type t =
    { network_id : String.t option
    ; network_type : AssociatedNetworkType.t option
    }

  let make ?network_id ?network_type () = { network_id; network_type }

  let parse xml =
    Some
      { network_id = Aws.Util.option_bind (Aws.Xml.member "networkId" xml) String.parse
      ; network_type =
          Aws.Util.option_bind
            (Aws.Xml.member "networkType" xml)
            AssociatedNetworkType.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.network_type (fun f ->
               Aws.Query.Pair ("NetworkType", AssociatedNetworkType.to_query f))
         ; Aws.Util.option_map v.network_id (fun f ->
               Aws.Query.Pair ("NetworkId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.network_type (fun f ->
               "networkType", AssociatedNetworkType.to_json f)
         ; Aws.Util.option_map v.network_id (fun f -> "networkId", String.to_json f)
         ])

  let of_json j =
    { network_id = Aws.Util.option_map (Aws.Json.lookup j "networkId") String.of_json
    ; network_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "networkType")
          AssociatedNetworkType.of_json
    }
end

module ListingState = struct
  type t =
    | Available
    | Sold
    | Cancelled
    | Pending

  let str_to_t =
    [ "pending", Pending; "cancelled", Cancelled; "sold", Sold; "available", Available ]

  let t_to_str =
    [ Pending, "pending"; Cancelled, "cancelled"; Sold, "sold"; Available, "available" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module InstanceCount = struct
  type t =
    { instance_count : Integer.t option
    ; state : ListingState.t option
    }

  let make ?instance_count ?state () = { instance_count; state }

  let parse xml =
    Some
      { instance_count =
          Aws.Util.option_bind (Aws.Xml.member "instanceCount" xml) Integer.parse
      ; state = Aws.Util.option_bind (Aws.Xml.member "state" xml) ListingState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", ListingState.to_query f))
         ; Aws.Util.option_map v.instance_count (fun f ->
               Aws.Query.Pair ("InstanceCount", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f -> "state", ListingState.to_json f)
         ; Aws.Util.option_map v.instance_count (fun f ->
               "instanceCount", Integer.to_json f)
         ])

  let of_json j =
    { instance_count =
        Aws.Util.option_map (Aws.Json.lookup j "instanceCount") Integer.of_json
    ; state = Aws.Util.option_map (Aws.Json.lookup j "state") ListingState.of_json
    }
end

module InstanceCountList = struct
  type t = InstanceCount.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map InstanceCount.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list InstanceCount.to_query v

  let to_json v = `List (List.map InstanceCount.to_json v)

  let of_json j = Aws.Json.to_list InstanceCount.of_json j
end

module TrafficType = struct
  type t =
    | ACCEPT
    | REJECT
    | ALL

  let str_to_t = [ "ALL", ALL; "REJECT", REJECT; "ACCEPT", ACCEPT ]

  let t_to_str = [ ALL, "ALL"; REJECT, "REJECT"; ACCEPT, "ACCEPT" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module LogDestinationType = struct
  type t =
    | Cloud_watch_logs
    | S3

  let str_to_t = [ "s3", S3; "cloud-watch-logs", Cloud_watch_logs ]

  let t_to_str = [ S3, "s3"; Cloud_watch_logs, "cloud-watch-logs" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module FlowLog = struct
  type t =
    { creation_time : DateTime.t option
    ; deliver_logs_error_message : String.t option
    ; deliver_logs_permission_arn : String.t option
    ; deliver_logs_status : String.t option
    ; flow_log_id : String.t option
    ; flow_log_status : String.t option
    ; log_group_name : String.t option
    ; resource_id : String.t option
    ; traffic_type : TrafficType.t option
    ; log_destination_type : LogDestinationType.t option
    ; log_destination : String.t option
    ; log_format : String.t option
    ; tags : TagList.t
    ; max_aggregation_interval : Integer.t option
    }

  let make
      ?creation_time
      ?deliver_logs_error_message
      ?deliver_logs_permission_arn
      ?deliver_logs_status
      ?flow_log_id
      ?flow_log_status
      ?log_group_name
      ?resource_id
      ?traffic_type
      ?log_destination_type
      ?log_destination
      ?log_format
      ?(tags = [])
      ?max_aggregation_interval
      () =
    { creation_time
    ; deliver_logs_error_message
    ; deliver_logs_permission_arn
    ; deliver_logs_status
    ; flow_log_id
    ; flow_log_status
    ; log_group_name
    ; resource_id
    ; traffic_type
    ; log_destination_type
    ; log_destination
    ; log_format
    ; tags
    ; max_aggregation_interval
    }

  let parse xml =
    Some
      { creation_time =
          Aws.Util.option_bind (Aws.Xml.member "creationTime" xml) DateTime.parse
      ; deliver_logs_error_message =
          Aws.Util.option_bind (Aws.Xml.member "deliverLogsErrorMessage" xml) String.parse
      ; deliver_logs_permission_arn =
          Aws.Util.option_bind
            (Aws.Xml.member "deliverLogsPermissionArn" xml)
            String.parse
      ; deliver_logs_status =
          Aws.Util.option_bind (Aws.Xml.member "deliverLogsStatus" xml) String.parse
      ; flow_log_id = Aws.Util.option_bind (Aws.Xml.member "flowLogId" xml) String.parse
      ; flow_log_status =
          Aws.Util.option_bind (Aws.Xml.member "flowLogStatus" xml) String.parse
      ; log_group_name =
          Aws.Util.option_bind (Aws.Xml.member "logGroupName" xml) String.parse
      ; resource_id = Aws.Util.option_bind (Aws.Xml.member "resourceId" xml) String.parse
      ; traffic_type =
          Aws.Util.option_bind (Aws.Xml.member "trafficType" xml) TrafficType.parse
      ; log_destination_type =
          Aws.Util.option_bind
            (Aws.Xml.member "logDestinationType" xml)
            LogDestinationType.parse
      ; log_destination =
          Aws.Util.option_bind (Aws.Xml.member "logDestination" xml) String.parse
      ; log_format = Aws.Util.option_bind (Aws.Xml.member "logFormat" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      ; max_aggregation_interval =
          Aws.Util.option_bind (Aws.Xml.member "maxAggregationInterval" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_aggregation_interval (fun f ->
               Aws.Query.Pair ("MaxAggregationInterval", Integer.to_query f))
         ; Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.log_format (fun f ->
               Aws.Query.Pair ("LogFormat", String.to_query f))
         ; Aws.Util.option_map v.log_destination (fun f ->
               Aws.Query.Pair ("LogDestination", String.to_query f))
         ; Aws.Util.option_map v.log_destination_type (fun f ->
               Aws.Query.Pair ("LogDestinationType", LogDestinationType.to_query f))
         ; Aws.Util.option_map v.traffic_type (fun f ->
               Aws.Query.Pair ("TrafficType", TrafficType.to_query f))
         ; Aws.Util.option_map v.resource_id (fun f ->
               Aws.Query.Pair ("ResourceId", String.to_query f))
         ; Aws.Util.option_map v.log_group_name (fun f ->
               Aws.Query.Pair ("LogGroupName", String.to_query f))
         ; Aws.Util.option_map v.flow_log_status (fun f ->
               Aws.Query.Pair ("FlowLogStatus", String.to_query f))
         ; Aws.Util.option_map v.flow_log_id (fun f ->
               Aws.Query.Pair ("FlowLogId", String.to_query f))
         ; Aws.Util.option_map v.deliver_logs_status (fun f ->
               Aws.Query.Pair ("DeliverLogsStatus", String.to_query f))
         ; Aws.Util.option_map v.deliver_logs_permission_arn (fun f ->
               Aws.Query.Pair ("DeliverLogsPermissionArn", String.to_query f))
         ; Aws.Util.option_map v.deliver_logs_error_message (fun f ->
               Aws.Query.Pair ("DeliverLogsErrorMessage", String.to_query f))
         ; Aws.Util.option_map v.creation_time (fun f ->
               Aws.Query.Pair ("CreationTime", DateTime.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_aggregation_interval (fun f ->
               "maxAggregationInterval", Integer.to_json f)
         ; Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.log_format (fun f -> "logFormat", String.to_json f)
         ; Aws.Util.option_map v.log_destination (fun f ->
               "logDestination", String.to_json f)
         ; Aws.Util.option_map v.log_destination_type (fun f ->
               "logDestinationType", LogDestinationType.to_json f)
         ; Aws.Util.option_map v.traffic_type (fun f ->
               "trafficType", TrafficType.to_json f)
         ; Aws.Util.option_map v.resource_id (fun f -> "resourceId", String.to_json f)
         ; Aws.Util.option_map v.log_group_name (fun f ->
               "logGroupName", String.to_json f)
         ; Aws.Util.option_map v.flow_log_status (fun f ->
               "flowLogStatus", String.to_json f)
         ; Aws.Util.option_map v.flow_log_id (fun f -> "flowLogId", String.to_json f)
         ; Aws.Util.option_map v.deliver_logs_status (fun f ->
               "deliverLogsStatus", String.to_json f)
         ; Aws.Util.option_map v.deliver_logs_permission_arn (fun f ->
               "deliverLogsPermissionArn", String.to_json f)
         ; Aws.Util.option_map v.deliver_logs_error_message (fun f ->
               "deliverLogsErrorMessage", String.to_json f)
         ; Aws.Util.option_map v.creation_time (fun f ->
               "creationTime", DateTime.to_json f)
         ])

  let of_json j =
    { creation_time =
        Aws.Util.option_map (Aws.Json.lookup j "creationTime") DateTime.of_json
    ; deliver_logs_error_message =
        Aws.Util.option_map (Aws.Json.lookup j "deliverLogsErrorMessage") String.of_json
    ; deliver_logs_permission_arn =
        Aws.Util.option_map (Aws.Json.lookup j "deliverLogsPermissionArn") String.of_json
    ; deliver_logs_status =
        Aws.Util.option_map (Aws.Json.lookup j "deliverLogsStatus") String.of_json
    ; flow_log_id = Aws.Util.option_map (Aws.Json.lookup j "flowLogId") String.of_json
    ; flow_log_status =
        Aws.Util.option_map (Aws.Json.lookup j "flowLogStatus") String.of_json
    ; log_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "logGroupName") String.of_json
    ; resource_id = Aws.Util.option_map (Aws.Json.lookup j "resourceId") String.of_json
    ; traffic_type =
        Aws.Util.option_map (Aws.Json.lookup j "trafficType") TrafficType.of_json
    ; log_destination_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "logDestinationType")
          LogDestinationType.of_json
    ; log_destination =
        Aws.Util.option_map (Aws.Json.lookup j "logDestination") String.of_json
    ; log_format = Aws.Util.option_map (Aws.Json.lookup j "logFormat") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    ; max_aggregation_interval =
        Aws.Util.option_map (Aws.Json.lookup j "maxAggregationInterval") Integer.of_json
    }
end

module FlowLogResourceIds = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module CreateFlowLogsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; client_token : String.t option
    ; deliver_logs_permission_arn : String.t option
    ; log_group_name : String.t option
    ; resource_ids : FlowLogResourceIds.t
    ; resource_type : FlowLogsResourceType.t
    ; traffic_type : TrafficType.t
    ; log_destination_type : LogDestinationType.t option
    ; log_destination : String.t option
    ; log_format : String.t option
    ; tag_specifications : TagSpecificationList.t
    ; max_aggregation_interval : Integer.t option
    }

  let make
      ?dry_run
      ?client_token
      ?deliver_logs_permission_arn
      ?log_group_name
      ~resource_ids
      ~resource_type
      ~traffic_type
      ?log_destination_type
      ?log_destination
      ?log_format
      ?(tag_specifications = [])
      ?max_aggregation_interval
      () =
    { dry_run
    ; client_token
    ; deliver_logs_permission_arn
    ; log_group_name
    ; resource_ids
    ; resource_type
    ; traffic_type
    ; log_destination_type
    ; log_destination
    ; log_format
    ; tag_specifications
    ; max_aggregation_interval
    }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; deliver_logs_permission_arn =
          Aws.Util.option_bind
            (Aws.Xml.member "DeliverLogsPermissionArn" xml)
            String.parse
      ; log_group_name =
          Aws.Util.option_bind (Aws.Xml.member "LogGroupName" xml) String.parse
      ; resource_ids =
          Aws.Xml.required
            "ResourceId"
            (Aws.Util.option_bind
               (Aws.Xml.member "ResourceId" xml)
               FlowLogResourceIds.parse)
      ; resource_type =
          Aws.Xml.required
            "ResourceType"
            (Aws.Util.option_bind
               (Aws.Xml.member "ResourceType" xml)
               FlowLogsResourceType.parse)
      ; traffic_type =
          Aws.Xml.required
            "TrafficType"
            (Aws.Util.option_bind (Aws.Xml.member "TrafficType" xml) TrafficType.parse)
      ; log_destination_type =
          Aws.Util.option_bind
            (Aws.Xml.member "LogDestinationType" xml)
            LogDestinationType.parse
      ; log_destination =
          Aws.Util.option_bind (Aws.Xml.member "LogDestination" xml) String.parse
      ; log_format = Aws.Util.option_bind (Aws.Xml.member "LogFormat" xml) String.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      ; max_aggregation_interval =
          Aws.Util.option_bind (Aws.Xml.member "MaxAggregationInterval" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_aggregation_interval (fun f ->
               Aws.Query.Pair ("MaxAggregationInterval", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Aws.Util.option_map v.log_format (fun f ->
               Aws.Query.Pair ("LogFormat", String.to_query f))
         ; Aws.Util.option_map v.log_destination (fun f ->
               Aws.Query.Pair ("LogDestination", String.to_query f))
         ; Aws.Util.option_map v.log_destination_type (fun f ->
               Aws.Query.Pair ("LogDestinationType", LogDestinationType.to_query f))
         ; Some (Aws.Query.Pair ("TrafficType", TrafficType.to_query v.traffic_type))
         ; Some
             (Aws.Query.Pair
                ("ResourceType", FlowLogsResourceType.to_query v.resource_type))
         ; Some
             (Aws.Query.Pair ("ResourceId", FlowLogResourceIds.to_query v.resource_ids))
         ; Aws.Util.option_map v.log_group_name (fun f ->
               Aws.Query.Pair ("LogGroupName", String.to_query f))
         ; Aws.Util.option_map v.deliver_logs_permission_arn (fun f ->
               Aws.Query.Pair ("DeliverLogsPermissionArn", String.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_aggregation_interval (fun f ->
               "MaxAggregationInterval", Integer.to_json f)
         ; Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Aws.Util.option_map v.log_format (fun f -> "LogFormat", String.to_json f)
         ; Aws.Util.option_map v.log_destination (fun f ->
               "LogDestination", String.to_json f)
         ; Aws.Util.option_map v.log_destination_type (fun f ->
               "LogDestinationType", LogDestinationType.to_json f)
         ; Some ("TrafficType", TrafficType.to_json v.traffic_type)
         ; Some ("ResourceType", FlowLogsResourceType.to_json v.resource_type)
         ; Some ("ResourceId", FlowLogResourceIds.to_json v.resource_ids)
         ; Aws.Util.option_map v.log_group_name (fun f ->
               "LogGroupName", String.to_json f)
         ; Aws.Util.option_map v.deliver_logs_permission_arn (fun f ->
               "DeliverLogsPermissionArn", String.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; deliver_logs_permission_arn =
        Aws.Util.option_map (Aws.Json.lookup j "DeliverLogsPermissionArn") String.of_json
    ; log_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "LogGroupName") String.of_json
    ; resource_ids =
        FlowLogResourceIds.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ResourceId"))
    ; resource_type =
        FlowLogsResourceType.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ResourceType"))
    ; traffic_type =
        TrafficType.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TrafficType"))
    ; log_destination_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "LogDestinationType")
          LogDestinationType.of_json
    ; log_destination =
        Aws.Util.option_map (Aws.Json.lookup j "LogDestination") String.of_json
    ; log_format = Aws.Util.option_map (Aws.Json.lookup j "LogFormat") String.of_json
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    ; max_aggregation_interval =
        Aws.Util.option_map (Aws.Json.lookup j "MaxAggregationInterval") Integer.of_json
    }
end

module ReservedInstancesConfiguration = struct
  type t =
    { availability_zone : String.t option
    ; instance_count : Integer.t option
    ; instance_type : InstanceType.t option
    ; platform : String.t option
    ; scope : Scope.t option
    }

  let make ?availability_zone ?instance_count ?instance_type ?platform ?scope () =
    { availability_zone; instance_count; instance_type; platform; scope }

  let parse xml =
    Some
      { availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; instance_count =
          Aws.Util.option_bind (Aws.Xml.member "instanceCount" xml) Integer.parse
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) InstanceType.parse
      ; platform = Aws.Util.option_bind (Aws.Xml.member "platform" xml) String.parse
      ; scope = Aws.Util.option_bind (Aws.Xml.member "scope" xml) Scope.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.scope (fun f ->
               Aws.Query.Pair ("Scope", Scope.to_query f))
         ; Aws.Util.option_map v.platform (fun f ->
               Aws.Query.Pair ("Platform", String.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", InstanceType.to_query f))
         ; Aws.Util.option_map v.instance_count (fun f ->
               Aws.Query.Pair ("InstanceCount", Integer.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.scope (fun f -> "scope", Scope.to_json f)
         ; Aws.Util.option_map v.platform (fun f -> "platform", String.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f ->
               "instanceType", InstanceType.to_json f)
         ; Aws.Util.option_map v.instance_count (fun f ->
               "instanceCount", Integer.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ])

  let of_json j =
    { availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; instance_count =
        Aws.Util.option_map (Aws.Json.lookup j "instanceCount") Integer.of_json
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") InstanceType.of_json
    ; platform = Aws.Util.option_map (Aws.Json.lookup j "platform") String.of_json
    ; scope = Aws.Util.option_map (Aws.Json.lookup j "scope") Scope.of_json
    }
end

module ReservedInstancesModificationResult = struct
  type t =
    { reserved_instances_id : String.t option
    ; target_configuration : ReservedInstancesConfiguration.t option
    }

  let make ?reserved_instances_id ?target_configuration () =
    { reserved_instances_id; target_configuration }

  let parse xml =
    Some
      { reserved_instances_id =
          Aws.Util.option_bind (Aws.Xml.member "reservedInstancesId" xml) String.parse
      ; target_configuration =
          Aws.Util.option_bind
            (Aws.Xml.member "targetConfiguration" xml)
            ReservedInstancesConfiguration.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.target_configuration (fun f ->
               Aws.Query.Pair
                 ("TargetConfiguration", ReservedInstancesConfiguration.to_query f))
         ; Aws.Util.option_map v.reserved_instances_id (fun f ->
               Aws.Query.Pair ("ReservedInstancesId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.target_configuration (fun f ->
               "targetConfiguration", ReservedInstancesConfiguration.to_json f)
         ; Aws.Util.option_map v.reserved_instances_id (fun f ->
               "reservedInstancesId", String.to_json f)
         ])

  let of_json j =
    { reserved_instances_id =
        Aws.Util.option_map (Aws.Json.lookup j "reservedInstancesId") String.of_json
    ; target_configuration =
        Aws.Util.option_map
          (Aws.Json.lookup j "targetConfiguration")
          ReservedInstancesConfiguration.of_json
    }
end

module ByoipCidrState = struct
  type t =
    | Advertised
    | Deprovisioned
    | Failed_deprovision
    | Failed_provision
    | Pending_deprovision
    | Pending_provision
    | Provisioned
    | Provisioned_not_publicly_advertisable

  let str_to_t =
    [ "provisioned-not-publicly-advertisable", Provisioned_not_publicly_advertisable
    ; "provisioned", Provisioned
    ; "pending-provision", Pending_provision
    ; "pending-deprovision", Pending_deprovision
    ; "failed-provision", Failed_provision
    ; "failed-deprovision", Failed_deprovision
    ; "deprovisioned", Deprovisioned
    ; "advertised", Advertised
    ]

  let t_to_str =
    [ Provisioned_not_publicly_advertisable, "provisioned-not-publicly-advertisable"
    ; Provisioned, "provisioned"
    ; Pending_provision, "pending-provision"
    ; Pending_deprovision, "pending-deprovision"
    ; Failed_provision, "failed-provision"
    ; Failed_deprovision, "failed-deprovision"
    ; Deprovisioned, "deprovisioned"
    ; Advertised, "advertised"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ByoipCidr = struct
  type t =
    { cidr : String.t option
    ; description : String.t option
    ; status_message : String.t option
    ; state : ByoipCidrState.t option
    }

  let make ?cidr ?description ?status_message ?state () =
    { cidr; description; status_message; state }

  let parse xml =
    Some
      { cidr = Aws.Util.option_bind (Aws.Xml.member "cidr" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; status_message =
          Aws.Util.option_bind (Aws.Xml.member "statusMessage" xml) String.parse
      ; state = Aws.Util.option_bind (Aws.Xml.member "state" xml) ByoipCidrState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", ByoipCidrState.to_query f))
         ; Aws.Util.option_map v.status_message (fun f ->
               Aws.Query.Pair ("StatusMessage", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.cidr (fun f ->
               Aws.Query.Pair ("Cidr", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f -> "state", ByoipCidrState.to_json f)
         ; Aws.Util.option_map v.status_message (fun f ->
               "statusMessage", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Aws.Util.option_map v.cidr (fun f -> "cidr", String.to_json f)
         ])

  let of_json j =
    { cidr = Aws.Util.option_map (Aws.Json.lookup j "cidr") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; status_message =
        Aws.Util.option_map (Aws.Json.lookup j "statusMessage") String.of_json
    ; state = Aws.Util.option_map (Aws.Json.lookup j "state") ByoipCidrState.of_json
    }
end

module ProvisionByoipCidrResult = struct
  type t = { byoip_cidr : ByoipCidr.t option }

  let make ?byoip_cidr () = { byoip_cidr }

  let parse xml =
    Some
      { byoip_cidr = Aws.Util.option_bind (Aws.Xml.member "byoipCidr" xml) ByoipCidr.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.byoip_cidr (fun f ->
               Aws.Query.Pair ("ByoipCidr", ByoipCidr.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.byoip_cidr (fun f -> "byoipCidr", ByoipCidr.to_json f) ])

  let of_json j =
    { byoip_cidr = Aws.Util.option_map (Aws.Json.lookup j "byoipCidr") ByoipCidr.of_json }
end

module ModifyIdFormatRequest = struct
  type t =
    { resource : String.t
    ; use_long_ids : Boolean.t
    }

  let make ~resource ~use_long_ids () = { resource; use_long_ids }

  let parse xml =
    Some
      { resource =
          Aws.Xml.required
            "Resource"
            (Aws.Util.option_bind (Aws.Xml.member "Resource" xml) String.parse)
      ; use_long_ids =
          Aws.Xml.required
            "UseLongIds"
            (Aws.Util.option_bind (Aws.Xml.member "UseLongIds" xml) Boolean.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("UseLongIds", Boolean.to_query v.use_long_ids))
         ; Some (Aws.Query.Pair ("Resource", String.to_query v.resource))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("UseLongIds", Boolean.to_json v.use_long_ids)
         ; Some ("Resource", String.to_json v.resource)
         ])

  let of_json j =
    { resource = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Resource"))
    ; use_long_ids =
        Boolean.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "UseLongIds"))
    }
end

module DisableEbsEncryptionByDefaultResult = struct
  type t = { ebs_encryption_by_default : Boolean.t option }

  let make ?ebs_encryption_by_default () = { ebs_encryption_by_default }

  let parse xml =
    Some
      { ebs_encryption_by_default =
          Aws.Util.option_bind (Aws.Xml.member "ebsEncryptionByDefault" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ebs_encryption_by_default (fun f ->
               Aws.Query.Pair ("EbsEncryptionByDefault", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ebs_encryption_by_default (fun f ->
               "ebsEncryptionByDefault", Boolean.to_json f)
         ])

  let of_json j =
    { ebs_encryption_by_default =
        Aws.Util.option_map (Aws.Json.lookup j "ebsEncryptionByDefault") Boolean.of_json
    }
end

module ImportImageTaskList = struct
  type t = ImportImageTask.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ImportImageTask.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ImportImageTask.to_query v

  let to_json v = `List (List.map ImportImageTask.to_json v)

  let of_json j = Aws.Json.to_list ImportImageTask.of_json j
end

module DescribeImportImageTasksResult = struct
  type t =
    { import_image_tasks : ImportImageTaskList.t
    ; next_token : String.t option
    }

  let make ?(import_image_tasks = []) ?next_token () = { import_image_tasks; next_token }

  let parse xml =
    Some
      { import_image_tasks =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "importImageTaskSet" xml)
               ImportImageTaskList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ImportImageTaskSet", ImportImageTaskList.to_query v.import_image_tasks))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("importImageTaskSet", ImportImageTaskList.to_json v.import_image_tasks)
         ])

  let of_json j =
    { import_image_tasks =
        ImportImageTaskList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "importImageTaskSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module VpcPeeringConnectionStateReasonCode = struct
  type t =
    | Initiating_request
    | Pending_acceptance
    | Active
    | Deleted
    | Rejected
    | Failed
    | Expired
    | Provisioning
    | Deleting

  let str_to_t =
    [ "deleting", Deleting
    ; "provisioning", Provisioning
    ; "expired", Expired
    ; "failed", Failed
    ; "rejected", Rejected
    ; "deleted", Deleted
    ; "active", Active
    ; "pending-acceptance", Pending_acceptance
    ; "initiating-request", Initiating_request
    ]

  let t_to_str =
    [ Deleting, "deleting"
    ; Provisioning, "provisioning"
    ; Expired, "expired"
    ; Failed, "failed"
    ; Rejected, "rejected"
    ; Deleted, "deleted"
    ; Active, "active"
    ; Pending_acceptance, "pending-acceptance"
    ; Initiating_request, "initiating-request"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module FlowLogIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module PoolCidrBlock = struct
  type t = { cidr : String.t option }

  let make ?cidr () = { cidr }

  let parse xml =
    Some { cidr = Aws.Util.option_bind (Aws.Xml.member "poolCidrBlock" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cidr (fun f ->
               Aws.Query.Pair ("PoolCidrBlock", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cidr (fun f -> "poolCidrBlock", String.to_json f) ])

  let of_json j =
    { cidr = Aws.Util.option_map (Aws.Json.lookup j "poolCidrBlock") String.of_json }
end

module FederatedAuthenticationRequest = struct
  type t =
    { s_a_m_l_provider_arn : String.t option
    ; self_service_s_a_m_l_provider_arn : String.t option
    }

  let make ?s_a_m_l_provider_arn ?self_service_s_a_m_l_provider_arn () =
    { s_a_m_l_provider_arn; self_service_s_a_m_l_provider_arn }

  let parse xml =
    Some
      { s_a_m_l_provider_arn =
          Aws.Util.option_bind (Aws.Xml.member "SAMLProviderArn" xml) String.parse
      ; self_service_s_a_m_l_provider_arn =
          Aws.Util.option_bind
            (Aws.Xml.member "SelfServiceSAMLProviderArn" xml)
            String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.self_service_s_a_m_l_provider_arn (fun f ->
               Aws.Query.Pair ("SelfServiceSAMLProviderArn", String.to_query f))
         ; Aws.Util.option_map v.s_a_m_l_provider_arn (fun f ->
               Aws.Query.Pair ("SAMLProviderArn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.self_service_s_a_m_l_provider_arn (fun f ->
               "SelfServiceSAMLProviderArn", String.to_json f)
         ; Aws.Util.option_map v.s_a_m_l_provider_arn (fun f ->
               "SAMLProviderArn", String.to_json f)
         ])

  let of_json j =
    { s_a_m_l_provider_arn =
        Aws.Util.option_map (Aws.Json.lookup j "SAMLProviderArn") String.of_json
    ; self_service_s_a_m_l_provider_arn =
        Aws.Util.option_map
          (Aws.Json.lookup j "SelfServiceSAMLProviderArn")
          String.of_json
    }
end

module DirectoryServiceAuthenticationRequest = struct
  type t = { directory_id : String.t option }

  let make ?directory_id () = { directory_id }

  let parse xml =
    Some
      { directory_id =
          Aws.Util.option_bind (Aws.Xml.member "DirectoryId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.directory_id (fun f ->
               Aws.Query.Pair ("DirectoryId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.directory_id (fun f -> "DirectoryId", String.to_json f) ])

  let of_json j =
    { directory_id = Aws.Util.option_map (Aws.Json.lookup j "DirectoryId") String.of_json
    }
end

module ClientVpnAuthenticationType = struct
  type t =
    | Certificate_authentication
    | Directory_service_authentication
    | Federated_authentication

  let str_to_t =
    [ "federated-authentication", Federated_authentication
    ; "directory-service-authentication", Directory_service_authentication
    ; "certificate-authentication", Certificate_authentication
    ]

  let t_to_str =
    [ Federated_authentication, "federated-authentication"
    ; Directory_service_authentication, "directory-service-authentication"
    ; Certificate_authentication, "certificate-authentication"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module CertificateAuthenticationRequest = struct
  type t = { client_root_certificate_chain_arn : String.t option }

  let make ?client_root_certificate_chain_arn () = { client_root_certificate_chain_arn }

  let parse xml =
    Some
      { client_root_certificate_chain_arn =
          Aws.Util.option_bind
            (Aws.Xml.member "ClientRootCertificateChainArn" xml)
            String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_root_certificate_chain_arn (fun f ->
               Aws.Query.Pair ("ClientRootCertificateChainArn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_root_certificate_chain_arn (fun f ->
               "ClientRootCertificateChainArn", String.to_json f)
         ])

  let of_json j =
    { client_root_certificate_chain_arn =
        Aws.Util.option_map
          (Aws.Json.lookup j "ClientRootCertificateChainArn")
          String.of_json
    }
end

module ClientVpnAuthenticationRequest = struct
  type t =
    { type_ : ClientVpnAuthenticationType.t option
    ; active_directory : DirectoryServiceAuthenticationRequest.t option
    ; mutual_authentication : CertificateAuthenticationRequest.t option
    ; federated_authentication : FederatedAuthenticationRequest.t option
    }

  let make ?type_ ?active_directory ?mutual_authentication ?federated_authentication () =
    { type_; active_directory; mutual_authentication; federated_authentication }

  let parse xml =
    Some
      { type_ =
          Aws.Util.option_bind
            (Aws.Xml.member "Type" xml)
            ClientVpnAuthenticationType.parse
      ; active_directory =
          Aws.Util.option_bind
            (Aws.Xml.member "ActiveDirectory" xml)
            DirectoryServiceAuthenticationRequest.parse
      ; mutual_authentication =
          Aws.Util.option_bind
            (Aws.Xml.member "MutualAuthentication" xml)
            CertificateAuthenticationRequest.parse
      ; federated_authentication =
          Aws.Util.option_bind
            (Aws.Xml.member "FederatedAuthentication" xml)
            FederatedAuthenticationRequest.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.federated_authentication (fun f ->
               Aws.Query.Pair
                 ("FederatedAuthentication", FederatedAuthenticationRequest.to_query f))
         ; Aws.Util.option_map v.mutual_authentication (fun f ->
               Aws.Query.Pair
                 ("MutualAuthentication", CertificateAuthenticationRequest.to_query f))
         ; Aws.Util.option_map v.active_directory (fun f ->
               Aws.Query.Pair
                 ("ActiveDirectory", DirectoryServiceAuthenticationRequest.to_query f))
         ; Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", ClientVpnAuthenticationType.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.federated_authentication (fun f ->
               "FederatedAuthentication", FederatedAuthenticationRequest.to_json f)
         ; Aws.Util.option_map v.mutual_authentication (fun f ->
               "MutualAuthentication", CertificateAuthenticationRequest.to_json f)
         ; Aws.Util.option_map v.active_directory (fun f ->
               "ActiveDirectory", DirectoryServiceAuthenticationRequest.to_json f)
         ; Aws.Util.option_map v.type_ (fun f ->
               "Type", ClientVpnAuthenticationType.to_json f)
         ])

  let of_json j =
    { type_ =
        Aws.Util.option_map (Aws.Json.lookup j "Type") ClientVpnAuthenticationType.of_json
    ; active_directory =
        Aws.Util.option_map
          (Aws.Json.lookup j "ActiveDirectory")
          DirectoryServiceAuthenticationRequest.of_json
    ; mutual_authentication =
        Aws.Util.option_map
          (Aws.Json.lookup j "MutualAuthentication")
          CertificateAuthenticationRequest.of_json
    ; federated_authentication =
        Aws.Util.option_map
          (Aws.Json.lookup j "FederatedAuthentication")
          FederatedAuthenticationRequest.of_json
    }
end

module UnsuccessfulItemError = struct
  type t =
    { code : String.t option
    ; message : String.t option
    }

  let make ?code ?message () = { code; message }

  let parse xml =
    Some
      { code = Aws.Util.option_bind (Aws.Xml.member "code" xml) String.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair ("Code", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f)
         ; Aws.Util.option_map v.code (fun f -> "code", String.to_json f)
         ])

  let of_json j =
    { code = Aws.Util.option_map (Aws.Json.lookup j "code") String.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json
    }
end

module DescribeVpcClassicLinkResult = struct
  type t = { vpcs : VpcClassicLinkList.t }

  let make ?(vpcs = []) () = { vpcs }

  let parse xml =
    Some
      { vpcs =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "vpcSet" xml) VpcClassicLinkList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("VpcSet", VpcClassicLinkList.to_query v.vpcs)) ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt [ Some ("vpcSet", VpcClassicLinkList.to_json v.vpcs) ])

  let of_json j =
    { vpcs =
        VpcClassicLinkList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "vpcSet"))
    }
end

module UsageClassType = struct
  type t =
    | Spot
    | On_demand

  let str_to_t = [ "on-demand", On_demand; "spot", Spot ]

  let t_to_str = [ On_demand, "on-demand"; Spot, "spot" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module LocationType = struct
  type t =
    | Region
    | Availability_zone
    | Availability_zone_id

  let str_to_t =
    [ "availability-zone-id", Availability_zone_id
    ; "availability-zone", Availability_zone
    ; "region", Region
    ]

  let t_to_str =
    [ Availability_zone_id, "availability-zone-id"
    ; Availability_zone, "availability-zone"
    ; Region, "region"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module InstanceTypeOffering = struct
  type t =
    { instance_type : InstanceType.t option
    ; location_type : LocationType.t option
    ; location : String.t option
    }

  let make ?instance_type ?location_type ?location () =
    { instance_type; location_type; location }

  let parse xml =
    Some
      { instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) InstanceType.parse
      ; location_type =
          Aws.Util.option_bind (Aws.Xml.member "locationType" xml) LocationType.parse
      ; location = Aws.Util.option_bind (Aws.Xml.member "location" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.location (fun f ->
               Aws.Query.Pair ("Location", String.to_query f))
         ; Aws.Util.option_map v.location_type (fun f ->
               Aws.Query.Pair ("LocationType", LocationType.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", InstanceType.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.location (fun f -> "location", String.to_json f)
         ; Aws.Util.option_map v.location_type (fun f ->
               "locationType", LocationType.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f ->
               "instanceType", InstanceType.to_json f)
         ])

  let of_json j =
    { instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") InstanceType.of_json
    ; location_type =
        Aws.Util.option_map (Aws.Json.lookup j "locationType") LocationType.of_json
    ; location = Aws.Util.option_map (Aws.Json.lookup j "location") String.of_json
    }
end

module InstanceTypeOfferingsList = struct
  type t = InstanceTypeOffering.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map InstanceTypeOffering.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list InstanceTypeOffering.to_query v

  let to_json v = `List (List.map InstanceTypeOffering.to_json v)

  let of_json j = Aws.Json.to_list InstanceTypeOffering.of_json j
end

module Phase2IntegrityAlgorithmsRequestListValue = struct
  type t = { value : String.t option }

  let make ?value () = { value }

  let parse xml =
    Some { value = Aws.Util.option_bind (Aws.Xml.member "Value" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f -> "Value", String.to_json f) ])

  let of_json j =
    { value = Aws.Util.option_map (Aws.Json.lookup j "Value") String.of_json }
end

module Phase2IntegrityAlgorithmsRequestList = struct
  type t = Phase2IntegrityAlgorithmsRequestListValue.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         Phase2IntegrityAlgorithmsRequestListValue.parse
         (Aws.Xml.members "item" xml))

  let to_query v =
    Aws.Query.to_query_list Phase2IntegrityAlgorithmsRequestListValue.to_query v

  let to_json v = `List (List.map Phase2IntegrityAlgorithmsRequestListValue.to_json v)

  let of_json j = Aws.Json.to_list Phase2IntegrityAlgorithmsRequestListValue.of_json j
end

module Phase2EncryptionAlgorithmsRequestListValue = struct
  type t = { value : String.t option }

  let make ?value () = { value }

  let parse xml =
    Some { value = Aws.Util.option_bind (Aws.Xml.member "Value" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f -> "Value", String.to_json f) ])

  let of_json j =
    { value = Aws.Util.option_map (Aws.Json.lookup j "Value") String.of_json }
end

module Phase2EncryptionAlgorithmsRequestList = struct
  type t = Phase2EncryptionAlgorithmsRequestListValue.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         Phase2EncryptionAlgorithmsRequestListValue.parse
         (Aws.Xml.members "item" xml))

  let to_query v =
    Aws.Query.to_query_list Phase2EncryptionAlgorithmsRequestListValue.to_query v

  let to_json v = `List (List.map Phase2EncryptionAlgorithmsRequestListValue.to_json v)

  let of_json j = Aws.Json.to_list Phase2EncryptionAlgorithmsRequestListValue.of_json j
end

module Phase2DHGroupNumbersRequestListValue = struct
  type t = { value : Integer.t option }

  let make ?value () = { value }

  let parse xml =
    Some { value = Aws.Util.option_bind (Aws.Xml.member "Value" xml) Integer.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f -> "Value", Integer.to_json f) ])

  let of_json j =
    { value = Aws.Util.option_map (Aws.Json.lookup j "Value") Integer.of_json }
end

module Phase2DHGroupNumbersRequestList = struct
  type t = Phase2DHGroupNumbersRequestListValue.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map Phase2DHGroupNumbersRequestListValue.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Phase2DHGroupNumbersRequestListValue.to_query v

  let to_json v = `List (List.map Phase2DHGroupNumbersRequestListValue.to_json v)

  let of_json j = Aws.Json.to_list Phase2DHGroupNumbersRequestListValue.of_json j
end

module Phase1IntegrityAlgorithmsRequestListValue = struct
  type t = { value : String.t option }

  let make ?value () = { value }

  let parse xml =
    Some { value = Aws.Util.option_bind (Aws.Xml.member "Value" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f -> "Value", String.to_json f) ])

  let of_json j =
    { value = Aws.Util.option_map (Aws.Json.lookup j "Value") String.of_json }
end

module Phase1IntegrityAlgorithmsRequestList = struct
  type t = Phase1IntegrityAlgorithmsRequestListValue.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         Phase1IntegrityAlgorithmsRequestListValue.parse
         (Aws.Xml.members "item" xml))

  let to_query v =
    Aws.Query.to_query_list Phase1IntegrityAlgorithmsRequestListValue.to_query v

  let to_json v = `List (List.map Phase1IntegrityAlgorithmsRequestListValue.to_json v)

  let of_json j = Aws.Json.to_list Phase1IntegrityAlgorithmsRequestListValue.of_json j
end

module Phase1EncryptionAlgorithmsRequestListValue = struct
  type t = { value : String.t option }

  let make ?value () = { value }

  let parse xml =
    Some { value = Aws.Util.option_bind (Aws.Xml.member "Value" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f -> "Value", String.to_json f) ])

  let of_json j =
    { value = Aws.Util.option_map (Aws.Json.lookup j "Value") String.of_json }
end

module Phase1EncryptionAlgorithmsRequestList = struct
  type t = Phase1EncryptionAlgorithmsRequestListValue.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         Phase1EncryptionAlgorithmsRequestListValue.parse
         (Aws.Xml.members "item" xml))

  let to_query v =
    Aws.Query.to_query_list Phase1EncryptionAlgorithmsRequestListValue.to_query v

  let to_json v = `List (List.map Phase1EncryptionAlgorithmsRequestListValue.to_json v)

  let of_json j = Aws.Json.to_list Phase1EncryptionAlgorithmsRequestListValue.of_json j
end

module IKEVersionsRequestListValue = struct
  type t = { value : String.t option }

  let make ?value () = { value }

  let parse xml =
    Some { value = Aws.Util.option_bind (Aws.Xml.member "Value" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f -> "Value", String.to_json f) ])

  let of_json j =
    { value = Aws.Util.option_map (Aws.Json.lookup j "Value") String.of_json }
end

module IKEVersionsRequestList = struct
  type t = IKEVersionsRequestListValue.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map IKEVersionsRequestListValue.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list IKEVersionsRequestListValue.to_query v

  let to_json v = `List (List.map IKEVersionsRequestListValue.to_json v)

  let of_json j = Aws.Json.to_list IKEVersionsRequestListValue.of_json j
end

module VpnTunnelOptionsSpecification = struct
  type t =
    { tunnel_inside_cidr : String.t option
    ; tunnel_inside_ipv6_cidr : String.t option
    ; pre_shared_key : String.t option
    ; phase1_lifetime_seconds : Integer.t option
    ; phase2_lifetime_seconds : Integer.t option
    ; rekey_margin_time_seconds : Integer.t option
    ; rekey_fuzz_percentage : Integer.t option
    ; replay_window_size : Integer.t option
    ; d_p_d_timeout_seconds : Integer.t option
    ; d_p_d_timeout_action : String.t option
    ; phase1_encryption_algorithms : Phase1EncryptionAlgorithmsRequestList.t
    ; phase2_encryption_algorithms : Phase2EncryptionAlgorithmsRequestList.t
    ; phase1_integrity_algorithms : Phase1IntegrityAlgorithmsRequestList.t
    ; phase2_integrity_algorithms : Phase2IntegrityAlgorithmsRequestList.t
    ; phase1_d_h_group_numbers : Phase1DHGroupNumbersRequestList.t
    ; phase2_d_h_group_numbers : Phase2DHGroupNumbersRequestList.t
    ; i_k_e_versions : IKEVersionsRequestList.t
    ; startup_action : String.t option
    }

  let make
      ?tunnel_inside_cidr
      ?tunnel_inside_ipv6_cidr
      ?pre_shared_key
      ?phase1_lifetime_seconds
      ?phase2_lifetime_seconds
      ?rekey_margin_time_seconds
      ?rekey_fuzz_percentage
      ?replay_window_size
      ?d_p_d_timeout_seconds
      ?d_p_d_timeout_action
      ?(phase1_encryption_algorithms = [])
      ?(phase2_encryption_algorithms = [])
      ?(phase1_integrity_algorithms = [])
      ?(phase2_integrity_algorithms = [])
      ?(phase1_d_h_group_numbers = [])
      ?(phase2_d_h_group_numbers = [])
      ?(i_k_e_versions = [])
      ?startup_action
      () =
    { tunnel_inside_cidr
    ; tunnel_inside_ipv6_cidr
    ; pre_shared_key
    ; phase1_lifetime_seconds
    ; phase2_lifetime_seconds
    ; rekey_margin_time_seconds
    ; rekey_fuzz_percentage
    ; replay_window_size
    ; d_p_d_timeout_seconds
    ; d_p_d_timeout_action
    ; phase1_encryption_algorithms
    ; phase2_encryption_algorithms
    ; phase1_integrity_algorithms
    ; phase2_integrity_algorithms
    ; phase1_d_h_group_numbers
    ; phase2_d_h_group_numbers
    ; i_k_e_versions
    ; startup_action
    }

  let parse xml =
    Some
      { tunnel_inside_cidr =
          Aws.Util.option_bind (Aws.Xml.member "TunnelInsideCidr" xml) String.parse
      ; tunnel_inside_ipv6_cidr =
          Aws.Util.option_bind (Aws.Xml.member "TunnelInsideIpv6Cidr" xml) String.parse
      ; pre_shared_key =
          Aws.Util.option_bind (Aws.Xml.member "PreSharedKey" xml) String.parse
      ; phase1_lifetime_seconds =
          Aws.Util.option_bind (Aws.Xml.member "Phase1LifetimeSeconds" xml) Integer.parse
      ; phase2_lifetime_seconds =
          Aws.Util.option_bind (Aws.Xml.member "Phase2LifetimeSeconds" xml) Integer.parse
      ; rekey_margin_time_seconds =
          Aws.Util.option_bind (Aws.Xml.member "RekeyMarginTimeSeconds" xml) Integer.parse
      ; rekey_fuzz_percentage =
          Aws.Util.option_bind (Aws.Xml.member "RekeyFuzzPercentage" xml) Integer.parse
      ; replay_window_size =
          Aws.Util.option_bind (Aws.Xml.member "ReplayWindowSize" xml) Integer.parse
      ; d_p_d_timeout_seconds =
          Aws.Util.option_bind (Aws.Xml.member "DPDTimeoutSeconds" xml) Integer.parse
      ; d_p_d_timeout_action =
          Aws.Util.option_bind (Aws.Xml.member "DPDTimeoutAction" xml) String.parse
      ; phase1_encryption_algorithms =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Phase1EncryptionAlgorithm" xml)
               Phase1EncryptionAlgorithmsRequestList.parse)
      ; phase2_encryption_algorithms =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Phase2EncryptionAlgorithm" xml)
               Phase2EncryptionAlgorithmsRequestList.parse)
      ; phase1_integrity_algorithms =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Phase1IntegrityAlgorithm" xml)
               Phase1IntegrityAlgorithmsRequestList.parse)
      ; phase2_integrity_algorithms =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Phase2IntegrityAlgorithm" xml)
               Phase2IntegrityAlgorithmsRequestList.parse)
      ; phase1_d_h_group_numbers =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Phase1DHGroupNumber" xml)
               Phase1DHGroupNumbersRequestList.parse)
      ; phase2_d_h_group_numbers =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Phase2DHGroupNumber" xml)
               Phase2DHGroupNumbersRequestList.parse)
      ; i_k_e_versions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "IKEVersion" xml)
               IKEVersionsRequestList.parse)
      ; startup_action =
          Aws.Util.option_bind (Aws.Xml.member "StartupAction" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.startup_action (fun f ->
               Aws.Query.Pair ("StartupAction", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("IKEVersion", IKEVersionsRequestList.to_query v.i_k_e_versions))
         ; Some
             (Aws.Query.Pair
                ( "Phase2DHGroupNumber"
                , Phase2DHGroupNumbersRequestList.to_query v.phase2_d_h_group_numbers ))
         ; Some
             (Aws.Query.Pair
                ( "Phase1DHGroupNumber"
                , Phase1DHGroupNumbersRequestList.to_query v.phase1_d_h_group_numbers ))
         ; Some
             (Aws.Query.Pair
                ( "Phase2IntegrityAlgorithm"
                , Phase2IntegrityAlgorithmsRequestList.to_query
                    v.phase2_integrity_algorithms ))
         ; Some
             (Aws.Query.Pair
                ( "Phase1IntegrityAlgorithm"
                , Phase1IntegrityAlgorithmsRequestList.to_query
                    v.phase1_integrity_algorithms ))
         ; Some
             (Aws.Query.Pair
                ( "Phase2EncryptionAlgorithm"
                , Phase2EncryptionAlgorithmsRequestList.to_query
                    v.phase2_encryption_algorithms ))
         ; Some
             (Aws.Query.Pair
                ( "Phase1EncryptionAlgorithm"
                , Phase1EncryptionAlgorithmsRequestList.to_query
                    v.phase1_encryption_algorithms ))
         ; Aws.Util.option_map v.d_p_d_timeout_action (fun f ->
               Aws.Query.Pair ("DPDTimeoutAction", String.to_query f))
         ; Aws.Util.option_map v.d_p_d_timeout_seconds (fun f ->
               Aws.Query.Pair ("DPDTimeoutSeconds", Integer.to_query f))
         ; Aws.Util.option_map v.replay_window_size (fun f ->
               Aws.Query.Pair ("ReplayWindowSize", Integer.to_query f))
         ; Aws.Util.option_map v.rekey_fuzz_percentage (fun f ->
               Aws.Query.Pair ("RekeyFuzzPercentage", Integer.to_query f))
         ; Aws.Util.option_map v.rekey_margin_time_seconds (fun f ->
               Aws.Query.Pair ("RekeyMarginTimeSeconds", Integer.to_query f))
         ; Aws.Util.option_map v.phase2_lifetime_seconds (fun f ->
               Aws.Query.Pair ("Phase2LifetimeSeconds", Integer.to_query f))
         ; Aws.Util.option_map v.phase1_lifetime_seconds (fun f ->
               Aws.Query.Pair ("Phase1LifetimeSeconds", Integer.to_query f))
         ; Aws.Util.option_map v.pre_shared_key (fun f ->
               Aws.Query.Pair ("PreSharedKey", String.to_query f))
         ; Aws.Util.option_map v.tunnel_inside_ipv6_cidr (fun f ->
               Aws.Query.Pair ("TunnelInsideIpv6Cidr", String.to_query f))
         ; Aws.Util.option_map v.tunnel_inside_cidr (fun f ->
               Aws.Query.Pair ("TunnelInsideCidr", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.startup_action (fun f ->
               "StartupAction", String.to_json f)
         ; Some ("IKEVersion", IKEVersionsRequestList.to_json v.i_k_e_versions)
         ; Some
             ( "Phase2DHGroupNumber"
             , Phase2DHGroupNumbersRequestList.to_json v.phase2_d_h_group_numbers )
         ; Some
             ( "Phase1DHGroupNumber"
             , Phase1DHGroupNumbersRequestList.to_json v.phase1_d_h_group_numbers )
         ; Some
             ( "Phase2IntegrityAlgorithm"
             , Phase2IntegrityAlgorithmsRequestList.to_json v.phase2_integrity_algorithms
             )
         ; Some
             ( "Phase1IntegrityAlgorithm"
             , Phase1IntegrityAlgorithmsRequestList.to_json v.phase1_integrity_algorithms
             )
         ; Some
             ( "Phase2EncryptionAlgorithm"
             , Phase2EncryptionAlgorithmsRequestList.to_json
                 v.phase2_encryption_algorithms )
         ; Some
             ( "Phase1EncryptionAlgorithm"
             , Phase1EncryptionAlgorithmsRequestList.to_json
                 v.phase1_encryption_algorithms )
         ; Aws.Util.option_map v.d_p_d_timeout_action (fun f ->
               "DPDTimeoutAction", String.to_json f)
         ; Aws.Util.option_map v.d_p_d_timeout_seconds (fun f ->
               "DPDTimeoutSeconds", Integer.to_json f)
         ; Aws.Util.option_map v.replay_window_size (fun f ->
               "ReplayWindowSize", Integer.to_json f)
         ; Aws.Util.option_map v.rekey_fuzz_percentage (fun f ->
               "RekeyFuzzPercentage", Integer.to_json f)
         ; Aws.Util.option_map v.rekey_margin_time_seconds (fun f ->
               "RekeyMarginTimeSeconds", Integer.to_json f)
         ; Aws.Util.option_map v.phase2_lifetime_seconds (fun f ->
               "Phase2LifetimeSeconds", Integer.to_json f)
         ; Aws.Util.option_map v.phase1_lifetime_seconds (fun f ->
               "Phase1LifetimeSeconds", Integer.to_json f)
         ; Aws.Util.option_map v.pre_shared_key (fun f ->
               "PreSharedKey", String.to_json f)
         ; Aws.Util.option_map v.tunnel_inside_ipv6_cidr (fun f ->
               "TunnelInsideIpv6Cidr", String.to_json f)
         ; Aws.Util.option_map v.tunnel_inside_cidr (fun f ->
               "TunnelInsideCidr", String.to_json f)
         ])

  let of_json j =
    { tunnel_inside_cidr =
        Aws.Util.option_map (Aws.Json.lookup j "TunnelInsideCidr") String.of_json
    ; tunnel_inside_ipv6_cidr =
        Aws.Util.option_map (Aws.Json.lookup j "TunnelInsideIpv6Cidr") String.of_json
    ; pre_shared_key =
        Aws.Util.option_map (Aws.Json.lookup j "PreSharedKey") String.of_json
    ; phase1_lifetime_seconds =
        Aws.Util.option_map (Aws.Json.lookup j "Phase1LifetimeSeconds") Integer.of_json
    ; phase2_lifetime_seconds =
        Aws.Util.option_map (Aws.Json.lookup j "Phase2LifetimeSeconds") Integer.of_json
    ; rekey_margin_time_seconds =
        Aws.Util.option_map (Aws.Json.lookup j "RekeyMarginTimeSeconds") Integer.of_json
    ; rekey_fuzz_percentage =
        Aws.Util.option_map (Aws.Json.lookup j "RekeyFuzzPercentage") Integer.of_json
    ; replay_window_size =
        Aws.Util.option_map (Aws.Json.lookup j "ReplayWindowSize") Integer.of_json
    ; d_p_d_timeout_seconds =
        Aws.Util.option_map (Aws.Json.lookup j "DPDTimeoutSeconds") Integer.of_json
    ; d_p_d_timeout_action =
        Aws.Util.option_map (Aws.Json.lookup j "DPDTimeoutAction") String.of_json
    ; phase1_encryption_algorithms =
        Phase1EncryptionAlgorithmsRequestList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Phase1EncryptionAlgorithm"))
    ; phase2_encryption_algorithms =
        Phase2EncryptionAlgorithmsRequestList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Phase2EncryptionAlgorithm"))
    ; phase1_integrity_algorithms =
        Phase1IntegrityAlgorithmsRequestList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Phase1IntegrityAlgorithm"))
    ; phase2_integrity_algorithms =
        Phase2IntegrityAlgorithmsRequestList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Phase2IntegrityAlgorithm"))
    ; phase1_d_h_group_numbers =
        Phase1DHGroupNumbersRequestList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Phase1DHGroupNumber"))
    ; phase2_d_h_group_numbers =
        Phase2DHGroupNumbersRequestList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Phase2DHGroupNumber"))
    ; i_k_e_versions =
        IKEVersionsRequestList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "IKEVersion"))
    ; startup_action =
        Aws.Util.option_map (Aws.Json.lookup j "StartupAction") String.of_json
    }
end

module VpnTunnelOptionsSpecificationsList = struct
  type t = VpnTunnelOptionsSpecification.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map VpnTunnelOptionsSpecification.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list VpnTunnelOptionsSpecification.to_query v

  let to_json v = `List (List.map VpnTunnelOptionsSpecification.to_json v)

  let of_json j = Aws.Json.to_list VpnTunnelOptionsSpecification.of_json j
end

module TunnelInsideIpVersion = struct
  type t =
    | Ipv4
    | Ipv6

  let str_to_t = [ "ipv6", Ipv6; "ipv4", Ipv4 ]

  let t_to_str = [ Ipv6, "ipv6"; Ipv4, "ipv4" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module VpnConnectionOptionsSpecification = struct
  type t =
    { enable_acceleration : Boolean.t option
    ; static_routes_only : Boolean.t option
    ; tunnel_inside_ip_version : TunnelInsideIpVersion.t option
    ; tunnel_options : VpnTunnelOptionsSpecificationsList.t
    ; local_ipv4_network_cidr : String.t option
    ; remote_ipv4_network_cidr : String.t option
    ; local_ipv6_network_cidr : String.t option
    ; remote_ipv6_network_cidr : String.t option
    }

  let make
      ?enable_acceleration
      ?static_routes_only
      ?tunnel_inside_ip_version
      ?(tunnel_options = [])
      ?local_ipv4_network_cidr
      ?remote_ipv4_network_cidr
      ?local_ipv6_network_cidr
      ?remote_ipv6_network_cidr
      () =
    { enable_acceleration
    ; static_routes_only
    ; tunnel_inside_ip_version
    ; tunnel_options
    ; local_ipv4_network_cidr
    ; remote_ipv4_network_cidr
    ; local_ipv6_network_cidr
    ; remote_ipv6_network_cidr
    }

  let parse xml =
    Some
      { enable_acceleration =
          Aws.Util.option_bind (Aws.Xml.member "EnableAcceleration" xml) Boolean.parse
      ; static_routes_only =
          Aws.Util.option_bind (Aws.Xml.member "staticRoutesOnly" xml) Boolean.parse
      ; tunnel_inside_ip_version =
          Aws.Util.option_bind
            (Aws.Xml.member "TunnelInsideIpVersion" xml)
            TunnelInsideIpVersion.parse
      ; tunnel_options =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TunnelOptions" xml)
               VpnTunnelOptionsSpecificationsList.parse)
      ; local_ipv4_network_cidr =
          Aws.Util.option_bind (Aws.Xml.member "LocalIpv4NetworkCidr" xml) String.parse
      ; remote_ipv4_network_cidr =
          Aws.Util.option_bind (Aws.Xml.member "RemoteIpv4NetworkCidr" xml) String.parse
      ; local_ipv6_network_cidr =
          Aws.Util.option_bind (Aws.Xml.member "LocalIpv6NetworkCidr" xml) String.parse
      ; remote_ipv6_network_cidr =
          Aws.Util.option_bind (Aws.Xml.member "RemoteIpv6NetworkCidr" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.remote_ipv6_network_cidr (fun f ->
               Aws.Query.Pair ("RemoteIpv6NetworkCidr", String.to_query f))
         ; Aws.Util.option_map v.local_ipv6_network_cidr (fun f ->
               Aws.Query.Pair ("LocalIpv6NetworkCidr", String.to_query f))
         ; Aws.Util.option_map v.remote_ipv4_network_cidr (fun f ->
               Aws.Query.Pair ("RemoteIpv4NetworkCidr", String.to_query f))
         ; Aws.Util.option_map v.local_ipv4_network_cidr (fun f ->
               Aws.Query.Pair ("LocalIpv4NetworkCidr", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TunnelOptions"
                , VpnTunnelOptionsSpecificationsList.to_query v.tunnel_options ))
         ; Aws.Util.option_map v.tunnel_inside_ip_version (fun f ->
               Aws.Query.Pair ("TunnelInsideIpVersion", TunnelInsideIpVersion.to_query f))
         ; Aws.Util.option_map v.static_routes_only (fun f ->
               Aws.Query.Pair ("StaticRoutesOnly", Boolean.to_query f))
         ; Aws.Util.option_map v.enable_acceleration (fun f ->
               Aws.Query.Pair ("EnableAcceleration", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.remote_ipv6_network_cidr (fun f ->
               "RemoteIpv6NetworkCidr", String.to_json f)
         ; Aws.Util.option_map v.local_ipv6_network_cidr (fun f ->
               "LocalIpv6NetworkCidr", String.to_json f)
         ; Aws.Util.option_map v.remote_ipv4_network_cidr (fun f ->
               "RemoteIpv4NetworkCidr", String.to_json f)
         ; Aws.Util.option_map v.local_ipv4_network_cidr (fun f ->
               "LocalIpv4NetworkCidr", String.to_json f)
         ; Some
             ("TunnelOptions", VpnTunnelOptionsSpecificationsList.to_json v.tunnel_options)
         ; Aws.Util.option_map v.tunnel_inside_ip_version (fun f ->
               "TunnelInsideIpVersion", TunnelInsideIpVersion.to_json f)
         ; Aws.Util.option_map v.static_routes_only (fun f ->
               "staticRoutesOnly", Boolean.to_json f)
         ; Aws.Util.option_map v.enable_acceleration (fun f ->
               "EnableAcceleration", Boolean.to_json f)
         ])

  let of_json j =
    { enable_acceleration =
        Aws.Util.option_map (Aws.Json.lookup j "EnableAcceleration") Boolean.of_json
    ; static_routes_only =
        Aws.Util.option_map (Aws.Json.lookup j "staticRoutesOnly") Boolean.of_json
    ; tunnel_inside_ip_version =
        Aws.Util.option_map
          (Aws.Json.lookup j "TunnelInsideIpVersion")
          TunnelInsideIpVersion.of_json
    ; tunnel_options =
        VpnTunnelOptionsSpecificationsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TunnelOptions"))
    ; local_ipv4_network_cidr =
        Aws.Util.option_map (Aws.Json.lookup j "LocalIpv4NetworkCidr") String.of_json
    ; remote_ipv4_network_cidr =
        Aws.Util.option_map (Aws.Json.lookup j "RemoteIpv4NetworkCidr") String.of_json
    ; local_ipv6_network_cidr =
        Aws.Util.option_map (Aws.Json.lookup j "LocalIpv6NetworkCidr") String.of_json
    ; remote_ipv6_network_cidr =
        Aws.Util.option_map (Aws.Json.lookup j "RemoteIpv6NetworkCidr") String.of_json
    }
end

module DisassociateClientVpnTargetNetworkResult = struct
  type t =
    { association_id : String.t option
    ; status : AssociationStatus.t option
    }

  let make ?association_id ?status () = { association_id; status }

  let parse xml =
    Some
      { association_id =
          Aws.Util.option_bind (Aws.Xml.member "associationId" xml) String.parse
      ; status =
          Aws.Util.option_bind (Aws.Xml.member "status" xml) AssociationStatus.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", AssociationStatus.to_query f))
         ; Aws.Util.option_map v.association_id (fun f ->
               Aws.Query.Pair ("AssociationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f -> "status", AssociationStatus.to_json f)
         ; Aws.Util.option_map v.association_id (fun f ->
               "associationId", String.to_json f)
         ])

  let of_json j =
    { association_id =
        Aws.Util.option_map (Aws.Json.lookup j "associationId") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "status") AssociationStatus.of_json
    }
end

module ElasticGpuState = struct
  type t = ATTACHED

  let str_to_t = [ "ATTACHED", ATTACHED ]

  let t_to_str = [ ATTACHED, "ATTACHED" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ElasticGpuStatus = struct
  type t =
    | OK
    | IMPAIRED

  let str_to_t = [ "IMPAIRED", IMPAIRED; "OK", OK ]

  let t_to_str = [ IMPAIRED, "IMPAIRED"; OK, "OK" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ElasticGpuHealth = struct
  type t = { status : ElasticGpuStatus.t option }

  let make ?status () = { status }

  let parse xml =
    Some
      { status = Aws.Util.option_bind (Aws.Xml.member "status" xml) ElasticGpuStatus.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", ElasticGpuStatus.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f -> "status", ElasticGpuStatus.to_json f) ])

  let of_json j =
    { status = Aws.Util.option_map (Aws.Json.lookup j "status") ElasticGpuStatus.of_json }
end

module ElasticGpus = struct
  type t =
    { elastic_gpu_id : String.t option
    ; availability_zone : String.t option
    ; elastic_gpu_type : String.t option
    ; elastic_gpu_health : ElasticGpuHealth.t option
    ; elastic_gpu_state : ElasticGpuState.t option
    ; instance_id : String.t option
    ; tags : TagList.t
    }

  let make
      ?elastic_gpu_id
      ?availability_zone
      ?elastic_gpu_type
      ?elastic_gpu_health
      ?elastic_gpu_state
      ?instance_id
      ?(tags = [])
      () =
    { elastic_gpu_id
    ; availability_zone
    ; elastic_gpu_type
    ; elastic_gpu_health
    ; elastic_gpu_state
    ; instance_id
    ; tags
    }

  let parse xml =
    Some
      { elastic_gpu_id =
          Aws.Util.option_bind (Aws.Xml.member "elasticGpuId" xml) String.parse
      ; availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; elastic_gpu_type =
          Aws.Util.option_bind (Aws.Xml.member "elasticGpuType" xml) String.parse
      ; elastic_gpu_health =
          Aws.Util.option_bind
            (Aws.Xml.member "elasticGpuHealth" xml)
            ElasticGpuHealth.parse
      ; elastic_gpu_state =
          Aws.Util.option_bind
            (Aws.Xml.member "elasticGpuState" xml)
            ElasticGpuState.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.elastic_gpu_state (fun f ->
               Aws.Query.Pair ("ElasticGpuState", ElasticGpuState.to_query f))
         ; Aws.Util.option_map v.elastic_gpu_health (fun f ->
               Aws.Query.Pair ("ElasticGpuHealth", ElasticGpuHealth.to_query f))
         ; Aws.Util.option_map v.elastic_gpu_type (fun f ->
               Aws.Query.Pair ("ElasticGpuType", String.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ; Aws.Util.option_map v.elastic_gpu_id (fun f ->
               Aws.Query.Pair ("ElasticGpuId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ; Aws.Util.option_map v.elastic_gpu_state (fun f ->
               "elasticGpuState", ElasticGpuState.to_json f)
         ; Aws.Util.option_map v.elastic_gpu_health (fun f ->
               "elasticGpuHealth", ElasticGpuHealth.to_json f)
         ; Aws.Util.option_map v.elastic_gpu_type (fun f ->
               "elasticGpuType", String.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ; Aws.Util.option_map v.elastic_gpu_id (fun f ->
               "elasticGpuId", String.to_json f)
         ])

  let of_json j =
    { elastic_gpu_id =
        Aws.Util.option_map (Aws.Json.lookup j "elasticGpuId") String.of_json
    ; availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; elastic_gpu_type =
        Aws.Util.option_map (Aws.Json.lookup j "elasticGpuType") String.of_json
    ; elastic_gpu_health =
        Aws.Util.option_map
          (Aws.Json.lookup j "elasticGpuHealth")
          ElasticGpuHealth.of_json
    ; elastic_gpu_state =
        Aws.Util.option_map (Aws.Json.lookup j "elasticGpuState") ElasticGpuState.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module ElasticGpuSet = struct
  type t = ElasticGpus.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ElasticGpus.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ElasticGpus.to_query v

  let to_json v = `List (List.map ElasticGpus.to_json v)

  let of_json j = Aws.Json.to_list ElasticGpus.of_json j
end

module DescribeElasticGpusResult = struct
  type t =
    { elastic_gpu_set : ElasticGpuSet.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?(elastic_gpu_set = []) ?max_results ?next_token () =
    { elastic_gpu_set; max_results; next_token }

  let parse xml =
    Some
      { elastic_gpu_set =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "elasticGpuSet" xml)
               ElasticGpuSet.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "maxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair ("ElasticGpuSet", ElasticGpuSet.to_query v.elastic_gpu_set))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "maxResults", Integer.to_json f)
         ; Some ("elasticGpuSet", ElasticGpuSet.to_json v.elastic_gpu_set)
         ])

  let of_json j =
    { elastic_gpu_set =
        ElasticGpuSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "elasticGpuSet"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "maxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module BatchState = struct
  type t =
    | Submitted
    | Active
    | Cancelled
    | Failed
    | Cancelled_running
    | Cancelled_terminating
    | Modifying

  let str_to_t =
    [ "modifying", Modifying
    ; "cancelled_terminating", Cancelled_terminating
    ; "cancelled_running", Cancelled_running
    ; "failed", Failed
    ; "cancelled", Cancelled
    ; "active", Active
    ; "submitted", Submitted
    ]

  let t_to_str =
    [ Modifying, "modifying"
    ; Cancelled_terminating, "cancelled_terminating"
    ; Cancelled_running, "cancelled_running"
    ; Failed, "failed"
    ; Cancelled, "cancelled"
    ; Active, "active"
    ; Submitted, "submitted"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module CancelSpotFleetRequestsSuccessItem = struct
  type t =
    { current_spot_fleet_request_state : BatchState.t option
    ; previous_spot_fleet_request_state : BatchState.t option
    ; spot_fleet_request_id : String.t option
    }

  let make
      ?current_spot_fleet_request_state
      ?previous_spot_fleet_request_state
      ?spot_fleet_request_id
      () =
    { current_spot_fleet_request_state
    ; previous_spot_fleet_request_state
    ; spot_fleet_request_id
    }

  let parse xml =
    Some
      { current_spot_fleet_request_state =
          Aws.Util.option_bind
            (Aws.Xml.member "currentSpotFleetRequestState" xml)
            BatchState.parse
      ; previous_spot_fleet_request_state =
          Aws.Util.option_bind
            (Aws.Xml.member "previousSpotFleetRequestState" xml)
            BatchState.parse
      ; spot_fleet_request_id =
          Aws.Util.option_bind (Aws.Xml.member "spotFleetRequestId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.spot_fleet_request_id (fun f ->
               Aws.Query.Pair ("SpotFleetRequestId", String.to_query f))
         ; Aws.Util.option_map v.previous_spot_fleet_request_state (fun f ->
               Aws.Query.Pair ("PreviousSpotFleetRequestState", BatchState.to_query f))
         ; Aws.Util.option_map v.current_spot_fleet_request_state (fun f ->
               Aws.Query.Pair ("CurrentSpotFleetRequestState", BatchState.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.spot_fleet_request_id (fun f ->
               "spotFleetRequestId", String.to_json f)
         ; Aws.Util.option_map v.previous_spot_fleet_request_state (fun f ->
               "previousSpotFleetRequestState", BatchState.to_json f)
         ; Aws.Util.option_map v.current_spot_fleet_request_state (fun f ->
               "currentSpotFleetRequestState", BatchState.to_json f)
         ])

  let of_json j =
    { current_spot_fleet_request_state =
        Aws.Util.option_map
          (Aws.Json.lookup j "currentSpotFleetRequestState")
          BatchState.of_json
    ; previous_spot_fleet_request_state =
        Aws.Util.option_map
          (Aws.Json.lookup j "previousSpotFleetRequestState")
          BatchState.of_json
    ; spot_fleet_request_id =
        Aws.Util.option_map (Aws.Json.lookup j "spotFleetRequestId") String.of_json
    }
end

module BundleTaskState = struct
  type t =
    | Pending
    | Waiting_for_shutdown
    | Bundling
    | Storing
    | Cancelling
    | Complete
    | Failed

  let str_to_t =
    [ "failed", Failed
    ; "complete", Complete
    ; "cancelling", Cancelling
    ; "storing", Storing
    ; "bundling", Bundling
    ; "waiting-for-shutdown", Waiting_for_shutdown
    ; "pending", Pending
    ]

  let t_to_str =
    [ Failed, "failed"
    ; Complete, "complete"
    ; Cancelling, "cancelling"
    ; Storing, "storing"
    ; Bundling, "bundling"
    ; Waiting_for_shutdown, "waiting-for-shutdown"
    ; Pending, "pending"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DetachInternetGatewayRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; internet_gateway_id : String.t
    ; vpc_id : String.t
    }

  let make ?dry_run ~internet_gateway_id ~vpc_id () =
    { dry_run; internet_gateway_id; vpc_id }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; internet_gateway_id =
          Aws.Xml.required
            "internetGatewayId"
            (Aws.Util.option_bind (Aws.Xml.member "internetGatewayId" xml) String.parse)
      ; vpc_id =
          Aws.Xml.required
            "vpcId"
            (Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ; Some
             (Aws.Query.Pair ("InternetGatewayId", String.to_query v.internet_gateway_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("vpcId", String.to_json v.vpc_id)
         ; Some ("internetGatewayId", String.to_json v.internet_gateway_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; internet_gateway_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "internetGatewayId"))
    ; vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "vpcId"))
    }
end

module Ipv6AddressList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module AssignIpv6AddressesResult = struct
  type t =
    { assigned_ipv6_addresses : Ipv6AddressList.t
    ; network_interface_id : String.t option
    }

  let make ?(assigned_ipv6_addresses = []) ?network_interface_id () =
    { assigned_ipv6_addresses; network_interface_id }

  let parse xml =
    Some
      { assigned_ipv6_addresses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "assignedIpv6Addresses" xml)
               Ipv6AddressList.parse)
      ; network_interface_id =
          Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.network_interface_id (fun f ->
               Aws.Query.Pair ("NetworkInterfaceId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "AssignedIpv6Addresses"
                , Ipv6AddressList.to_query v.assigned_ipv6_addresses ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.network_interface_id (fun f ->
               "networkInterfaceId", String.to_json f)
         ; Some
             ("assignedIpv6Addresses", Ipv6AddressList.to_json v.assigned_ipv6_addresses)
         ])

  let of_json j =
    { assigned_ipv6_addresses =
        Ipv6AddressList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "assignedIpv6Addresses"))
    ; network_interface_id =
        Aws.Util.option_map (Aws.Json.lookup j "networkInterfaceId") String.of_json
    }
end

module LaunchTemplateOverrides = struct
  type t =
    { instance_type : InstanceType.t option
    ; spot_price : String.t option
    ; subnet_id : String.t option
    ; availability_zone : String.t option
    ; weighted_capacity : Double.t option
    ; priority : Double.t option
    }

  let make
      ?instance_type
      ?spot_price
      ?subnet_id
      ?availability_zone
      ?weighted_capacity
      ?priority
      () =
    { instance_type
    ; spot_price
    ; subnet_id
    ; availability_zone
    ; weighted_capacity
    ; priority
    }

  let parse xml =
    Some
      { instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) InstanceType.parse
      ; spot_price = Aws.Util.option_bind (Aws.Xml.member "spotPrice" xml) String.parse
      ; subnet_id = Aws.Util.option_bind (Aws.Xml.member "subnetId" xml) String.parse
      ; availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; weighted_capacity =
          Aws.Util.option_bind (Aws.Xml.member "weightedCapacity" xml) Double.parse
      ; priority = Aws.Util.option_bind (Aws.Xml.member "priority" xml) Double.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.priority (fun f ->
               Aws.Query.Pair ("Priority", Double.to_query f))
         ; Aws.Util.option_map v.weighted_capacity (fun f ->
               Aws.Query.Pair ("WeightedCapacity", Double.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ; Aws.Util.option_map v.subnet_id (fun f ->
               Aws.Query.Pair ("SubnetId", String.to_query f))
         ; Aws.Util.option_map v.spot_price (fun f ->
               Aws.Query.Pair ("SpotPrice", String.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", InstanceType.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.priority (fun f -> "priority", Double.to_json f)
         ; Aws.Util.option_map v.weighted_capacity (fun f ->
               "weightedCapacity", Double.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ; Aws.Util.option_map v.subnet_id (fun f -> "subnetId", String.to_json f)
         ; Aws.Util.option_map v.spot_price (fun f -> "spotPrice", String.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f ->
               "instanceType", InstanceType.to_json f)
         ])

  let of_json j =
    { instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") InstanceType.of_json
    ; spot_price = Aws.Util.option_map (Aws.Json.lookup j "spotPrice") String.of_json
    ; subnet_id = Aws.Util.option_map (Aws.Json.lookup j "subnetId") String.of_json
    ; availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; weighted_capacity =
        Aws.Util.option_map (Aws.Json.lookup j "weightedCapacity") Double.of_json
    ; priority = Aws.Util.option_map (Aws.Json.lookup j "priority") Double.of_json
    }
end

module LaunchTemplateOverridesList = struct
  type t = LaunchTemplateOverrides.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map LaunchTemplateOverrides.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list LaunchTemplateOverrides.to_query v

  let to_json v = `List (List.map LaunchTemplateOverrides.to_json v)

  let of_json j = Aws.Json.to_list LaunchTemplateOverrides.of_json j
end

module LaunchTemplateConfig = struct
  type t =
    { launch_template_specification : FleetLaunchTemplateSpecification.t option
    ; overrides : LaunchTemplateOverridesList.t
    }

  let make ?launch_template_specification ?(overrides = []) () =
    { launch_template_specification; overrides }

  let parse xml =
    Some
      { launch_template_specification =
          Aws.Util.option_bind
            (Aws.Xml.member "launchTemplateSpecification" xml)
            FleetLaunchTemplateSpecification.parse
      ; overrides =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "overrides" xml)
               LaunchTemplateOverridesList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("Overrides", LaunchTemplateOverridesList.to_query v.overrides))
         ; Aws.Util.option_map v.launch_template_specification (fun f ->
               Aws.Query.Pair
                 ( "LaunchTemplateSpecification"
                 , FleetLaunchTemplateSpecification.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("overrides", LaunchTemplateOverridesList.to_json v.overrides)
         ; Aws.Util.option_map v.launch_template_specification (fun f ->
               "launchTemplateSpecification", FleetLaunchTemplateSpecification.to_json f)
         ])

  let of_json j =
    { launch_template_specification =
        Aws.Util.option_map
          (Aws.Json.lookup j "launchTemplateSpecification")
          FleetLaunchTemplateSpecification.of_json
    ; overrides =
        LaunchTemplateOverridesList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "overrides"))
    }
end

module LaunchTemplateConfigList = struct
  type t = LaunchTemplateConfig.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map LaunchTemplateConfig.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list LaunchTemplateConfig.to_query v

  let to_json v = `List (List.map LaunchTemplateConfig.to_json v)

  let of_json j = Aws.Json.to_list LaunchTemplateConfig.of_json j
end

module ExcessCapacityTerminationPolicy = struct
  type t =
    | NoTermination
    | Default

  let str_to_t = [ "default", Default; "noTermination", NoTermination ]

  let t_to_str = [ Default, "default"; NoTermination, "noTermination" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ModifySpotFleetRequestRequest = struct
  type t =
    { excess_capacity_termination_policy : ExcessCapacityTerminationPolicy.t option
    ; launch_template_configs : LaunchTemplateConfigList.t
    ; spot_fleet_request_id : String.t
    ; target_capacity : Integer.t option
    ; on_demand_target_capacity : Integer.t option
    }

  let make
      ?excess_capacity_termination_policy
      ?(launch_template_configs = [])
      ~spot_fleet_request_id
      ?target_capacity
      ?on_demand_target_capacity
      () =
    { excess_capacity_termination_policy
    ; launch_template_configs
    ; spot_fleet_request_id
    ; target_capacity
    ; on_demand_target_capacity
    }

  let parse xml =
    Some
      { excess_capacity_termination_policy =
          Aws.Util.option_bind
            (Aws.Xml.member "excessCapacityTerminationPolicy" xml)
            ExcessCapacityTerminationPolicy.parse
      ; launch_template_configs =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "LaunchTemplateConfig" xml)
               LaunchTemplateConfigList.parse)
      ; spot_fleet_request_id =
          Aws.Xml.required
            "spotFleetRequestId"
            (Aws.Util.option_bind (Aws.Xml.member "spotFleetRequestId" xml) String.parse)
      ; target_capacity =
          Aws.Util.option_bind (Aws.Xml.member "targetCapacity" xml) Integer.parse
      ; on_demand_target_capacity =
          Aws.Util.option_bind (Aws.Xml.member "OnDemandTargetCapacity" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.on_demand_target_capacity (fun f ->
               Aws.Query.Pair ("OnDemandTargetCapacity", Integer.to_query f))
         ; Aws.Util.option_map v.target_capacity (fun f ->
               Aws.Query.Pair ("TargetCapacity", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("SpotFleetRequestId", String.to_query v.spot_fleet_request_id))
         ; Some
             (Aws.Query.Pair
                ( "LaunchTemplateConfig"
                , LaunchTemplateConfigList.to_query v.launch_template_configs ))
         ; Aws.Util.option_map v.excess_capacity_termination_policy (fun f ->
               Aws.Query.Pair
                 ( "ExcessCapacityTerminationPolicy"
                 , ExcessCapacityTerminationPolicy.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.on_demand_target_capacity (fun f ->
               "OnDemandTargetCapacity", Integer.to_json f)
         ; Aws.Util.option_map v.target_capacity (fun f ->
               "targetCapacity", Integer.to_json f)
         ; Some ("spotFleetRequestId", String.to_json v.spot_fleet_request_id)
         ; Some
             ( "LaunchTemplateConfig"
             , LaunchTemplateConfigList.to_json v.launch_template_configs )
         ; Aws.Util.option_map v.excess_capacity_termination_policy (fun f ->
               ( "excessCapacityTerminationPolicy"
               , ExcessCapacityTerminationPolicy.to_json f ))
         ])

  let of_json j =
    { excess_capacity_termination_policy =
        Aws.Util.option_map
          (Aws.Json.lookup j "excessCapacityTerminationPolicy")
          ExcessCapacityTerminationPolicy.of_json
    ; launch_template_configs =
        LaunchTemplateConfigList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "LaunchTemplateConfig"))
    ; spot_fleet_request_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "spotFleetRequestId"))
    ; target_capacity =
        Aws.Util.option_map (Aws.Json.lookup j "targetCapacity") Integer.of_json
    ; on_demand_target_capacity =
        Aws.Util.option_map (Aws.Json.lookup j "OnDemandTargetCapacity") Integer.of_json
    }
end

module BundleTaskError = struct
  type t =
    { code : String.t option
    ; message : String.t option
    }

  let make ?code ?message () = { code; message }

  let parse xml =
    Some
      { code = Aws.Util.option_bind (Aws.Xml.member "code" xml) String.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair ("Code", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f)
         ; Aws.Util.option_map v.code (fun f -> "code", String.to_json f)
         ])

  let of_json j =
    { code = Aws.Util.option_map (Aws.Json.lookup j "code") String.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json
    }
end

module BundleTask = struct
  type t =
    { bundle_id : String.t
    ; bundle_task_error : BundleTaskError.t option
    ; instance_id : String.t
    ; progress : String.t
    ; start_time : DateTime.t
    ; state : BundleTaskState.t
    ; storage : Storage.t
    ; update_time : DateTime.t
    }

  let make
      ~bundle_id
      ?bundle_task_error
      ~instance_id
      ~progress
      ~start_time
      ~state
      ~storage
      ~update_time
      () =
    { bundle_id
    ; bundle_task_error
    ; instance_id
    ; progress
    ; start_time
    ; state
    ; storage
    ; update_time
    }

  let parse xml =
    Some
      { bundle_id =
          Aws.Xml.required
            "bundleId"
            (Aws.Util.option_bind (Aws.Xml.member "bundleId" xml) String.parse)
      ; bundle_task_error =
          Aws.Util.option_bind (Aws.Xml.member "error" xml) BundleTaskError.parse
      ; instance_id =
          Aws.Xml.required
            "instanceId"
            (Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse)
      ; progress =
          Aws.Xml.required
            "progress"
            (Aws.Util.option_bind (Aws.Xml.member "progress" xml) String.parse)
      ; start_time =
          Aws.Xml.required
            "startTime"
            (Aws.Util.option_bind (Aws.Xml.member "startTime" xml) DateTime.parse)
      ; state =
          Aws.Xml.required
            "state"
            (Aws.Util.option_bind (Aws.Xml.member "state" xml) BundleTaskState.parse)
      ; storage =
          Aws.Xml.required
            "storage"
            (Aws.Util.option_bind (Aws.Xml.member "storage" xml) Storage.parse)
      ; update_time =
          Aws.Xml.required
            "updateTime"
            (Aws.Util.option_bind (Aws.Xml.member "updateTime" xml) DateTime.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("UpdateTime", DateTime.to_query v.update_time))
         ; Some (Aws.Query.Pair ("Storage", Storage.to_query v.storage))
         ; Some (Aws.Query.Pair ("State", BundleTaskState.to_query v.state))
         ; Some (Aws.Query.Pair ("StartTime", DateTime.to_query v.start_time))
         ; Some (Aws.Query.Pair ("Progress", String.to_query v.progress))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ; Aws.Util.option_map v.bundle_task_error (fun f ->
               Aws.Query.Pair ("Error", BundleTaskError.to_query f))
         ; Some (Aws.Query.Pair ("BundleId", String.to_query v.bundle_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("updateTime", DateTime.to_json v.update_time)
         ; Some ("storage", Storage.to_json v.storage)
         ; Some ("state", BundleTaskState.to_json v.state)
         ; Some ("startTime", DateTime.to_json v.start_time)
         ; Some ("progress", String.to_json v.progress)
         ; Some ("instanceId", String.to_json v.instance_id)
         ; Aws.Util.option_map v.bundle_task_error (fun f ->
               "error", BundleTaskError.to_json f)
         ; Some ("bundleId", String.to_json v.bundle_id)
         ])

  let of_json j =
    { bundle_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "bundleId"))
    ; bundle_task_error =
        Aws.Util.option_map (Aws.Json.lookup j "error") BundleTaskError.of_json
    ; instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceId"))
    ; progress = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "progress"))
    ; start_time =
        DateTime.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "startTime"))
    ; state = BundleTaskState.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "state"))
    ; storage = Storage.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "storage"))
    ; update_time =
        DateTime.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "updateTime"))
    }
end

module CancelBundleTaskResult = struct
  type t = { bundle_task : BundleTask.t option }

  let make ?bundle_task () = { bundle_task }

  let parse xml =
    Some
      { bundle_task =
          Aws.Util.option_bind (Aws.Xml.member "bundleInstanceTask" xml) BundleTask.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.bundle_task (fun f ->
               Aws.Query.Pair ("BundleInstanceTask", BundleTask.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.bundle_task (fun f ->
               "bundleInstanceTask", BundleTask.to_json f)
         ])

  let of_json j =
    { bundle_task =
        Aws.Util.option_map (Aws.Json.lookup j "bundleInstanceTask") BundleTask.of_json
    }
end

module GetTransitGatewayRouteTableAssociationsRequest = struct
  type t =
    { transit_gateway_route_table_id : String.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make
      ~transit_gateway_route_table_id
      ?(filters = [])
      ?max_results
      ?next_token
      ?dry_run
      () =
    { transit_gateway_route_table_id; filters; max_results; next_token; dry_run }

  let parse xml =
    Some
      { transit_gateway_route_table_id =
          Aws.Xml.required
            "TransitGatewayRouteTableId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayRouteTableId" xml)
               String.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayRouteTableId"
                , String.to_query v.transit_gateway_route_table_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some
             ( "TransitGatewayRouteTableId"
             , String.to_json v.transit_gateway_route_table_id )
         ])

  let of_json j =
    { transit_gateway_route_table_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayRouteTableId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DescribeSubnetsResult = struct
  type t =
    { subnets : SubnetList.t
    ; next_token : String.t option
    }

  let make ?(subnets = []) ?next_token () = { subnets; next_token }

  let parse xml =
    Some
      { subnets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "subnetSet" xml) SubnetList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("SubnetSet", SubnetList.to_query v.subnets))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("subnetSet", SubnetList.to_json v.subnets)
         ])

  let of_json j =
    { subnets =
        SubnetList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "subnetSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module NetworkInterfacePermissionStateCode = struct
  type t =
    | Pending
    | Granted
    | Revoking
    | Revoked

  let str_to_t =
    [ "revoked", Revoked; "revoking", Revoking; "granted", Granted; "pending", Pending ]

  let t_to_str =
    [ Revoked, "revoked"; Revoking, "revoking"; Granted, "granted"; Pending, "pending" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ModifyLaunchTemplateResult = struct
  type t = { launch_template : LaunchTemplate.t option }

  let make ?launch_template () = { launch_template }

  let parse xml =
    Some
      { launch_template =
          Aws.Util.option_bind (Aws.Xml.member "launchTemplate" xml) LaunchTemplate.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.launch_template (fun f ->
               Aws.Query.Pair ("LaunchTemplate", LaunchTemplate.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.launch_template (fun f ->
               "launchTemplate", LaunchTemplate.to_json f)
         ])

  let of_json j =
    { launch_template =
        Aws.Util.option_map (Aws.Json.lookup j "launchTemplate") LaunchTemplate.of_json
    }
end

module DnsEntry = struct
  type t =
    { dns_name : String.t option
    ; hosted_zone_id : String.t option
    }

  let make ?dns_name ?hosted_zone_id () = { dns_name; hosted_zone_id }

  let parse xml =
    Some
      { dns_name = Aws.Util.option_bind (Aws.Xml.member "dnsName" xml) String.parse
      ; hosted_zone_id =
          Aws.Util.option_bind (Aws.Xml.member "hostedZoneId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.hosted_zone_id (fun f ->
               Aws.Query.Pair ("HostedZoneId", String.to_query f))
         ; Aws.Util.option_map v.dns_name (fun f ->
               Aws.Query.Pair ("DnsName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.hosted_zone_id (fun f ->
               "hostedZoneId", String.to_json f)
         ; Aws.Util.option_map v.dns_name (fun f -> "dnsName", String.to_json f)
         ])

  let of_json j =
    { dns_name = Aws.Util.option_map (Aws.Json.lookup j "dnsName") String.of_json
    ; hosted_zone_id =
        Aws.Util.option_map (Aws.Json.lookup j "hostedZoneId") String.of_json
    }
end

module DnsEntrySet = struct
  type t = DnsEntry.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map DnsEntry.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list DnsEntry.to_query v

  let to_json v = `List (List.map DnsEntry.to_json v)

  let of_json j = Aws.Json.to_list DnsEntry.of_json j
end

module SuccessfulQueuedPurchaseDeletion = struct
  type t = { reserved_instances_id : String.t option }

  let make ?reserved_instances_id () = { reserved_instances_id }

  let parse xml =
    Some
      { reserved_instances_id =
          Aws.Util.option_bind (Aws.Xml.member "reservedInstancesId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.reserved_instances_id (fun f ->
               Aws.Query.Pair ("ReservedInstancesId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.reserved_instances_id (fun f ->
               "reservedInstancesId", String.to_json f)
         ])

  let of_json j =
    { reserved_instances_id =
        Aws.Util.option_map (Aws.Json.lookup j "reservedInstancesId") String.of_json
    }
end

module DescribePrefixListsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; prefix_list_ids : PrefixListResourceIdStringList.t
    }

  let make ?dry_run ?(filters = []) ?max_results ?next_token ?(prefix_list_ids = []) () =
    { dry_run; filters; max_results; next_token; prefix_list_ids }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; prefix_list_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "PrefixListId" xml)
               PrefixListResourceIdStringList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("PrefixListId", PrefixListResourceIdStringList.to_query v.prefix_list_ids))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("PrefixListId", PrefixListResourceIdStringList.to_json v.prefix_list_ids)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; prefix_list_ids =
        PrefixListResourceIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "PrefixListId"))
    }
end

module DescribeLocalGatewaysResult = struct
  type t =
    { local_gateways : LocalGatewaySet.t
    ; next_token : String.t option
    }

  let make ?(local_gateways = []) ?next_token () = { local_gateways; next_token }

  let parse xml =
    Some
      { local_gateways =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "localGatewaySet" xml)
               LocalGatewaySet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair ("LocalGatewaySet", LocalGatewaySet.to_query v.local_gateways))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("localGatewaySet", LocalGatewaySet.to_json v.local_gateways)
         ])

  let of_json j =
    { local_gateways =
        LocalGatewaySet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "localGatewaySet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module VpcState = struct
  type t =
    | Pending
    | Available

  let str_to_t = [ "available", Available; "pending", Pending ]

  let t_to_str = [ Available, "available"; Pending, "pending" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module VpcIpv6CidrBlockAssociation = struct
  type t =
    { association_id : String.t option
    ; ipv6_cidr_block : String.t option
    ; ipv6_cidr_block_state : VpcCidrBlockState.t option
    ; network_border_group : String.t option
    ; ipv6_pool : String.t option
    }

  let make
      ?association_id
      ?ipv6_cidr_block
      ?ipv6_cidr_block_state
      ?network_border_group
      ?ipv6_pool
      () =
    { association_id
    ; ipv6_cidr_block
    ; ipv6_cidr_block_state
    ; network_border_group
    ; ipv6_pool
    }

  let parse xml =
    Some
      { association_id =
          Aws.Util.option_bind (Aws.Xml.member "associationId" xml) String.parse
      ; ipv6_cidr_block =
          Aws.Util.option_bind (Aws.Xml.member "ipv6CidrBlock" xml) String.parse
      ; ipv6_cidr_block_state =
          Aws.Util.option_bind
            (Aws.Xml.member "ipv6CidrBlockState" xml)
            VpcCidrBlockState.parse
      ; network_border_group =
          Aws.Util.option_bind (Aws.Xml.member "networkBorderGroup" xml) String.parse
      ; ipv6_pool = Aws.Util.option_bind (Aws.Xml.member "ipv6Pool" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ipv6_pool (fun f ->
               Aws.Query.Pair ("Ipv6Pool", String.to_query f))
         ; Aws.Util.option_map v.network_border_group (fun f ->
               Aws.Query.Pair ("NetworkBorderGroup", String.to_query f))
         ; Aws.Util.option_map v.ipv6_cidr_block_state (fun f ->
               Aws.Query.Pair ("Ipv6CidrBlockState", VpcCidrBlockState.to_query f))
         ; Aws.Util.option_map v.ipv6_cidr_block (fun f ->
               Aws.Query.Pair ("Ipv6CidrBlock", String.to_query f))
         ; Aws.Util.option_map v.association_id (fun f ->
               Aws.Query.Pair ("AssociationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ipv6_pool (fun f -> "ipv6Pool", String.to_json f)
         ; Aws.Util.option_map v.network_border_group (fun f ->
               "networkBorderGroup", String.to_json f)
         ; Aws.Util.option_map v.ipv6_cidr_block_state (fun f ->
               "ipv6CidrBlockState", VpcCidrBlockState.to_json f)
         ; Aws.Util.option_map v.ipv6_cidr_block (fun f ->
               "ipv6CidrBlock", String.to_json f)
         ; Aws.Util.option_map v.association_id (fun f ->
               "associationId", String.to_json f)
         ])

  let of_json j =
    { association_id =
        Aws.Util.option_map (Aws.Json.lookup j "associationId") String.of_json
    ; ipv6_cidr_block =
        Aws.Util.option_map (Aws.Json.lookup j "ipv6CidrBlock") String.of_json
    ; ipv6_cidr_block_state =
        Aws.Util.option_map
          (Aws.Json.lookup j "ipv6CidrBlockState")
          VpcCidrBlockState.of_json
    ; network_border_group =
        Aws.Util.option_map (Aws.Json.lookup j "networkBorderGroup") String.of_json
    ; ipv6_pool = Aws.Util.option_map (Aws.Json.lookup j "ipv6Pool") String.of_json
    }
end

module VpcIpv6CidrBlockAssociationSet = struct
  type t = VpcIpv6CidrBlockAssociation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map VpcIpv6CidrBlockAssociation.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list VpcIpv6CidrBlockAssociation.to_query v

  let to_json v = `List (List.map VpcIpv6CidrBlockAssociation.to_json v)

  let of_json j = Aws.Json.to_list VpcIpv6CidrBlockAssociation.of_json j
end

module VpcCidrBlockAssociationSet = struct
  type t = VpcCidrBlockAssociation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map VpcCidrBlockAssociation.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list VpcCidrBlockAssociation.to_query v

  let to_json v = `List (List.map VpcCidrBlockAssociation.to_json v)

  let of_json j = Aws.Json.to_list VpcCidrBlockAssociation.of_json j
end

module Vpc = struct
  type t =
    { cidr_block : String.t
    ; dhcp_options_id : String.t
    ; state : VpcState.t
    ; vpc_id : String.t
    ; owner_id : String.t option
    ; instance_tenancy : Tenancy.t
    ; ipv6_cidr_block_association_set : VpcIpv6CidrBlockAssociationSet.t
    ; cidr_block_association_set : VpcCidrBlockAssociationSet.t
    ; is_default : Boolean.t
    ; tags : TagList.t
    }

  let make
      ~cidr_block
      ~dhcp_options_id
      ~state
      ~vpc_id
      ?owner_id
      ~instance_tenancy
      ?(ipv6_cidr_block_association_set = [])
      ?(cidr_block_association_set = [])
      ~is_default
      ?(tags = [])
      () =
    { cidr_block
    ; dhcp_options_id
    ; state
    ; vpc_id
    ; owner_id
    ; instance_tenancy
    ; ipv6_cidr_block_association_set
    ; cidr_block_association_set
    ; is_default
    ; tags
    }

  let parse xml =
    Some
      { cidr_block =
          Aws.Xml.required
            "cidrBlock"
            (Aws.Util.option_bind (Aws.Xml.member "cidrBlock" xml) String.parse)
      ; dhcp_options_id =
          Aws.Xml.required
            "dhcpOptionsId"
            (Aws.Util.option_bind (Aws.Xml.member "dhcpOptionsId" xml) String.parse)
      ; state =
          Aws.Xml.required
            "state"
            (Aws.Util.option_bind (Aws.Xml.member "state" xml) VpcState.parse)
      ; vpc_id =
          Aws.Xml.required
            "vpcId"
            (Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse)
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; instance_tenancy =
          Aws.Xml.required
            "instanceTenancy"
            (Aws.Util.option_bind (Aws.Xml.member "instanceTenancy" xml) Tenancy.parse)
      ; ipv6_cidr_block_association_set =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ipv6CidrBlockAssociationSet" xml)
               VpcIpv6CidrBlockAssociationSet.parse)
      ; cidr_block_association_set =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "cidrBlockAssociationSet" xml)
               VpcCidrBlockAssociationSet.parse)
      ; is_default =
          Aws.Xml.required
            "isDefault"
            (Aws.Util.option_bind (Aws.Xml.member "isDefault" xml) Boolean.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Some (Aws.Query.Pair ("IsDefault", Boolean.to_query v.is_default))
         ; Some
             (Aws.Query.Pair
                ( "CidrBlockAssociationSet"
                , VpcCidrBlockAssociationSet.to_query v.cidr_block_association_set ))
         ; Some
             (Aws.Query.Pair
                ( "Ipv6CidrBlockAssociationSet"
                , VpcIpv6CidrBlockAssociationSet.to_query
                    v.ipv6_cidr_block_association_set ))
         ; Some (Aws.Query.Pair ("InstanceTenancy", Tenancy.to_query v.instance_tenancy))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ; Some (Aws.Query.Pair ("State", VpcState.to_query v.state))
         ; Some (Aws.Query.Pair ("DhcpOptionsId", String.to_query v.dhcp_options_id))
         ; Some (Aws.Query.Pair ("CidrBlock", String.to_query v.cidr_block))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Some ("isDefault", Boolean.to_json v.is_default)
         ; Some
             ( "cidrBlockAssociationSet"
             , VpcCidrBlockAssociationSet.to_json v.cidr_block_association_set )
         ; Some
             ( "ipv6CidrBlockAssociationSet"
             , VpcIpv6CidrBlockAssociationSet.to_json v.ipv6_cidr_block_association_set )
         ; Some ("instanceTenancy", Tenancy.to_json v.instance_tenancy)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Some ("vpcId", String.to_json v.vpc_id)
         ; Some ("state", VpcState.to_json v.state)
         ; Some ("dhcpOptionsId", String.to_json v.dhcp_options_id)
         ; Some ("cidrBlock", String.to_json v.cidr_block)
         ])

  let of_json j =
    { cidr_block = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "cidrBlock"))
    ; dhcp_options_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "dhcpOptionsId"))
    ; state = VpcState.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "state"))
    ; vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "vpcId"))
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; instance_tenancy =
        Tenancy.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceTenancy"))
    ; ipv6_cidr_block_association_set =
        VpcIpv6CidrBlockAssociationSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ipv6CidrBlockAssociationSet"))
    ; cidr_block_association_set =
        VpcCidrBlockAssociationSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "cidrBlockAssociationSet"))
    ; is_default =
        Boolean.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "isDefault"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module VpcList = struct
  type t = Vpc.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map Vpc.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Vpc.to_query v

  let to_json v = `List (List.map Vpc.to_json v)

  let of_json j = Aws.Json.to_list Vpc.of_json j
end

module DescribeVpcsResult = struct
  type t =
    { vpcs : VpcList.t
    ; next_token : String.t option
    }

  let make ?(vpcs = []) ?next_token () = { vpcs; next_token }

  let parse xml =
    Some
      { vpcs =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "vpcSet" xml) VpcList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("VpcSet", VpcList.to_query v.vpcs))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("vpcSet", VpcList.to_json v.vpcs)
         ])

  let of_json j =
    { vpcs = VpcList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "vpcSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module ProductCodeValues = struct
  type t =
    | Devpay
    | Marketplace

  let str_to_t = [ "marketplace", Marketplace; "devpay", Devpay ]

  let t_to_str = [ Marketplace, "marketplace"; Devpay, "devpay" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ProductCode = struct
  type t =
    { product_code_id : String.t option
    ; product_code_type : ProductCodeValues.t option
    }

  let make ?product_code_id ?product_code_type () = { product_code_id; product_code_type }

  let parse xml =
    Some
      { product_code_id =
          Aws.Util.option_bind (Aws.Xml.member "productCode" xml) String.parse
      ; product_code_type =
          Aws.Util.option_bind (Aws.Xml.member "type" xml) ProductCodeValues.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.product_code_type (fun f ->
               Aws.Query.Pair ("Type", ProductCodeValues.to_query f))
         ; Aws.Util.option_map v.product_code_id (fun f ->
               Aws.Query.Pair ("ProductCode", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.product_code_type (fun f ->
               "type", ProductCodeValues.to_json f)
         ; Aws.Util.option_map v.product_code_id (fun f ->
               "productCode", String.to_json f)
         ])

  let of_json j =
    { product_code_id =
        Aws.Util.option_map (Aws.Json.lookup j "productCode") String.of_json
    ; product_code_type =
        Aws.Util.option_map (Aws.Json.lookup j "type") ProductCodeValues.of_json
    }
end

module ProductCodeList = struct
  type t = ProductCode.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ProductCode.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ProductCode.to_query v

  let to_json v = `List (List.map ProductCode.to_json v)

  let of_json j = Aws.Json.to_list ProductCode.of_json j
end

module DescribeVolumeAttributeResult = struct
  type t =
    { auto_enable_i_o : AttributeBooleanValue.t option
    ; product_codes : ProductCodeList.t
    ; volume_id : String.t option
    }

  let make ?auto_enable_i_o ?(product_codes = []) ?volume_id () =
    { auto_enable_i_o; product_codes; volume_id }

  let parse xml =
    Some
      { auto_enable_i_o =
          Aws.Util.option_bind
            (Aws.Xml.member "autoEnableIO" xml)
            AttributeBooleanValue.parse
      ; product_codes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "productCodes" xml)
               ProductCodeList.parse)
      ; volume_id = Aws.Util.option_bind (Aws.Xml.member "volumeId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.volume_id (fun f ->
               Aws.Query.Pair ("VolumeId", String.to_query f))
         ; Some
             (Aws.Query.Pair ("ProductCodes", ProductCodeList.to_query v.product_codes))
         ; Aws.Util.option_map v.auto_enable_i_o (fun f ->
               Aws.Query.Pair ("AutoEnableIO", AttributeBooleanValue.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.volume_id (fun f -> "volumeId", String.to_json f)
         ; Some ("productCodes", ProductCodeList.to_json v.product_codes)
         ; Aws.Util.option_map v.auto_enable_i_o (fun f ->
               "autoEnableIO", AttributeBooleanValue.to_json f)
         ])

  let of_json j =
    { auto_enable_i_o =
        Aws.Util.option_map
          (Aws.Json.lookup j "autoEnableIO")
          AttributeBooleanValue.of_json
    ; product_codes =
        ProductCodeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "productCodes"))
    ; volume_id = Aws.Util.option_map (Aws.Json.lookup j "volumeId") String.of_json
    }
end

module LocalGatewayVirtualInterfaceIdSet = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeLocalGatewayVirtualInterfacesRequest = struct
  type t =
    { local_gateway_virtual_interface_ids : LocalGatewayVirtualInterfaceIdSet.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make
      ?(local_gateway_virtual_interface_ids = [])
      ?(filters = [])
      ?max_results
      ?next_token
      ?dry_run
      () =
    { local_gateway_virtual_interface_ids; filters; max_results; next_token; dry_run }

  let parse xml =
    Some
      { local_gateway_virtual_interface_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "LocalGatewayVirtualInterfaceId" xml)
               LocalGatewayVirtualInterfaceIdSet.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ( "LocalGatewayVirtualInterfaceId"
                , LocalGatewayVirtualInterfaceIdSet.to_query
                    v.local_gateway_virtual_interface_ids ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some
             ( "LocalGatewayVirtualInterfaceId"
             , LocalGatewayVirtualInterfaceIdSet.to_json
                 v.local_gateway_virtual_interface_ids )
         ])

  let of_json j =
    { local_gateway_virtual_interface_ids =
        LocalGatewayVirtualInterfaceIdSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "LocalGatewayVirtualInterfaceId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module GetLaunchTemplateDataRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; instance_id : String.t
    }

  let make ?dry_run ~instance_id () = { dry_run; instance_id }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; instance_id =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("InstanceId", String.to_json v.instance_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    }
end

module InternetGatewayList = struct
  type t = InternetGateway.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map InternetGateway.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list InternetGateway.to_query v

  let to_json v = `List (List.map InternetGateway.to_json v)

  let of_json j = Aws.Json.to_list InternetGateway.of_json j
end

module ResponseHostIdSet = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module ReservationState = struct
  type t =
    | Payment_pending
    | Payment_failed
    | Active
    | Retired

  let str_to_t =
    [ "retired", Retired
    ; "active", Active
    ; "payment-failed", Payment_failed
    ; "payment-pending", Payment_pending
    ]

  let t_to_str =
    [ Retired, "retired"
    ; Active, "active"
    ; Payment_failed, "payment-failed"
    ; Payment_pending, "payment-pending"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module HostReservation = struct
  type t =
    { count : Integer.t option
    ; currency_code : CurrencyCodeValues.t option
    ; duration : Integer.t option
    ; end_ : DateTime.t option
    ; host_id_set : ResponseHostIdSet.t
    ; host_reservation_id : String.t option
    ; hourly_price : String.t option
    ; instance_family : String.t option
    ; offering_id : String.t option
    ; payment_option : PaymentOption.t option
    ; start : DateTime.t option
    ; state : ReservationState.t option
    ; upfront_price : String.t option
    ; tags : TagList.t
    }

  let make
      ?count
      ?currency_code
      ?duration
      ?end_
      ?(host_id_set = [])
      ?host_reservation_id
      ?hourly_price
      ?instance_family
      ?offering_id
      ?payment_option
      ?start
      ?state
      ?upfront_price
      ?(tags = [])
      () =
    { count
    ; currency_code
    ; duration
    ; end_
    ; host_id_set
    ; host_reservation_id
    ; hourly_price
    ; instance_family
    ; offering_id
    ; payment_option
    ; start
    ; state
    ; upfront_price
    ; tags
    }

  let parse xml =
    Some
      { count = Aws.Util.option_bind (Aws.Xml.member "count" xml) Integer.parse
      ; currency_code =
          Aws.Util.option_bind
            (Aws.Xml.member "currencyCode" xml)
            CurrencyCodeValues.parse
      ; duration = Aws.Util.option_bind (Aws.Xml.member "duration" xml) Integer.parse
      ; end_ = Aws.Util.option_bind (Aws.Xml.member "end" xml) DateTime.parse
      ; host_id_set =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "hostIdSet" xml)
               ResponseHostIdSet.parse)
      ; host_reservation_id =
          Aws.Util.option_bind (Aws.Xml.member "hostReservationId" xml) String.parse
      ; hourly_price =
          Aws.Util.option_bind (Aws.Xml.member "hourlyPrice" xml) String.parse
      ; instance_family =
          Aws.Util.option_bind (Aws.Xml.member "instanceFamily" xml) String.parse
      ; offering_id = Aws.Util.option_bind (Aws.Xml.member "offeringId" xml) String.parse
      ; payment_option =
          Aws.Util.option_bind (Aws.Xml.member "paymentOption" xml) PaymentOption.parse
      ; start = Aws.Util.option_bind (Aws.Xml.member "start" xml) DateTime.parse
      ; state = Aws.Util.option_bind (Aws.Xml.member "state" xml) ReservationState.parse
      ; upfront_price =
          Aws.Util.option_bind (Aws.Xml.member "upfrontPrice" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.upfront_price (fun f ->
               Aws.Query.Pair ("UpfrontPrice", String.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", ReservationState.to_query f))
         ; Aws.Util.option_map v.start (fun f ->
               Aws.Query.Pair ("Start", DateTime.to_query f))
         ; Aws.Util.option_map v.payment_option (fun f ->
               Aws.Query.Pair ("PaymentOption", PaymentOption.to_query f))
         ; Aws.Util.option_map v.offering_id (fun f ->
               Aws.Query.Pair ("OfferingId", String.to_query f))
         ; Aws.Util.option_map v.instance_family (fun f ->
               Aws.Query.Pair ("InstanceFamily", String.to_query f))
         ; Aws.Util.option_map v.hourly_price (fun f ->
               Aws.Query.Pair ("HourlyPrice", String.to_query f))
         ; Aws.Util.option_map v.host_reservation_id (fun f ->
               Aws.Query.Pair ("HostReservationId", String.to_query f))
         ; Some (Aws.Query.Pair ("HostIdSet", ResponseHostIdSet.to_query v.host_id_set))
         ; Aws.Util.option_map v.end_ (fun f ->
               Aws.Query.Pair ("End", DateTime.to_query f))
         ; Aws.Util.option_map v.duration (fun f ->
               Aws.Query.Pair ("Duration", Integer.to_query f))
         ; Aws.Util.option_map v.currency_code (fun f ->
               Aws.Query.Pair ("CurrencyCode", CurrencyCodeValues.to_query f))
         ; Aws.Util.option_map v.count (fun f ->
               Aws.Query.Pair ("Count", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.upfront_price (fun f -> "upfrontPrice", String.to_json f)
         ; Aws.Util.option_map v.state (fun f -> "state", ReservationState.to_json f)
         ; Aws.Util.option_map v.start (fun f -> "start", DateTime.to_json f)
         ; Aws.Util.option_map v.payment_option (fun f ->
               "paymentOption", PaymentOption.to_json f)
         ; Aws.Util.option_map v.offering_id (fun f -> "offeringId", String.to_json f)
         ; Aws.Util.option_map v.instance_family (fun f ->
               "instanceFamily", String.to_json f)
         ; Aws.Util.option_map v.hourly_price (fun f -> "hourlyPrice", String.to_json f)
         ; Aws.Util.option_map v.host_reservation_id (fun f ->
               "hostReservationId", String.to_json f)
         ; Some ("hostIdSet", ResponseHostIdSet.to_json v.host_id_set)
         ; Aws.Util.option_map v.end_ (fun f -> "end", DateTime.to_json f)
         ; Aws.Util.option_map v.duration (fun f -> "duration", Integer.to_json f)
         ; Aws.Util.option_map v.currency_code (fun f ->
               "currencyCode", CurrencyCodeValues.to_json f)
         ; Aws.Util.option_map v.count (fun f -> "count", Integer.to_json f)
         ])

  let of_json j =
    { count = Aws.Util.option_map (Aws.Json.lookup j "count") Integer.of_json
    ; currency_code =
        Aws.Util.option_map (Aws.Json.lookup j "currencyCode") CurrencyCodeValues.of_json
    ; duration = Aws.Util.option_map (Aws.Json.lookup j "duration") Integer.of_json
    ; end_ = Aws.Util.option_map (Aws.Json.lookup j "end") DateTime.of_json
    ; host_id_set =
        ResponseHostIdSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "hostIdSet"))
    ; host_reservation_id =
        Aws.Util.option_map (Aws.Json.lookup j "hostReservationId") String.of_json
    ; hourly_price = Aws.Util.option_map (Aws.Json.lookup j "hourlyPrice") String.of_json
    ; instance_family =
        Aws.Util.option_map (Aws.Json.lookup j "instanceFamily") String.of_json
    ; offering_id = Aws.Util.option_map (Aws.Json.lookup j "offeringId") String.of_json
    ; payment_option =
        Aws.Util.option_map (Aws.Json.lookup j "paymentOption") PaymentOption.of_json
    ; start = Aws.Util.option_map (Aws.Json.lookup j "start") DateTime.of_json
    ; state = Aws.Util.option_map (Aws.Json.lookup j "state") ReservationState.of_json
    ; upfront_price =
        Aws.Util.option_map (Aws.Json.lookup j "upfrontPrice") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module HostReservationSet = struct
  type t = HostReservation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map HostReservation.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list HostReservation.to_query v

  let to_json v = `List (List.map HostReservation.to_json v)

  let of_json j = Aws.Json.to_list HostReservation.of_json j
end

module State = struct
  type t =
    | PendingAcceptance
    | Pending
    | Available
    | Deleting
    | Deleted
    | Rejected
    | Failed
    | Expired

  let str_to_t =
    [ "Expired", Expired
    ; "Failed", Failed
    ; "Rejected", Rejected
    ; "Deleted", Deleted
    ; "Deleting", Deleting
    ; "Available", Available
    ; "Pending", Pending
    ; "PendingAcceptance", PendingAcceptance
    ]

  let t_to_str =
    [ Expired, "Expired"
    ; Failed, "Failed"
    ; Rejected, "Rejected"
    ; Deleted, "Deleted"
    ; Deleting, "Deleting"
    ; Available, "Available"
    ; Pending, "Pending"
    ; PendingAcceptance, "PendingAcceptance"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module VpcEndpointConnection = struct
  type t =
    { service_id : String.t option
    ; vpc_endpoint_id : String.t option
    ; vpc_endpoint_owner : String.t option
    ; vpc_endpoint_state : State.t option
    ; creation_timestamp : DateTime.t option
    ; dns_entries : DnsEntrySet.t
    ; network_load_balancer_arns : ValueStringList.t
    ; gateway_load_balancer_arns : ValueStringList.t
    }

  let make
      ?service_id
      ?vpc_endpoint_id
      ?vpc_endpoint_owner
      ?vpc_endpoint_state
      ?creation_timestamp
      ?(dns_entries = [])
      ?(network_load_balancer_arns = [])
      ?(gateway_load_balancer_arns = [])
      () =
    { service_id
    ; vpc_endpoint_id
    ; vpc_endpoint_owner
    ; vpc_endpoint_state
    ; creation_timestamp
    ; dns_entries
    ; network_load_balancer_arns
    ; gateway_load_balancer_arns
    }

  let parse xml =
    Some
      { service_id = Aws.Util.option_bind (Aws.Xml.member "serviceId" xml) String.parse
      ; vpc_endpoint_id =
          Aws.Util.option_bind (Aws.Xml.member "vpcEndpointId" xml) String.parse
      ; vpc_endpoint_owner =
          Aws.Util.option_bind (Aws.Xml.member "vpcEndpointOwner" xml) String.parse
      ; vpc_endpoint_state =
          Aws.Util.option_bind (Aws.Xml.member "vpcEndpointState" xml) State.parse
      ; creation_timestamp =
          Aws.Util.option_bind (Aws.Xml.member "creationTimestamp" xml) DateTime.parse
      ; dns_entries =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "dnsEntrySet" xml) DnsEntrySet.parse)
      ; network_load_balancer_arns =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "networkLoadBalancerArnSet" xml)
               ValueStringList.parse)
      ; gateway_load_balancer_arns =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "gatewayLoadBalancerArnSet" xml)
               ValueStringList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "GatewayLoadBalancerArnSet"
                , ValueStringList.to_query v.gateway_load_balancer_arns ))
         ; Some
             (Aws.Query.Pair
                ( "NetworkLoadBalancerArnSet"
                , ValueStringList.to_query v.network_load_balancer_arns ))
         ; Some (Aws.Query.Pair ("DnsEntrySet", DnsEntrySet.to_query v.dns_entries))
         ; Aws.Util.option_map v.creation_timestamp (fun f ->
               Aws.Query.Pair ("CreationTimestamp", DateTime.to_query f))
         ; Aws.Util.option_map v.vpc_endpoint_state (fun f ->
               Aws.Query.Pair ("VpcEndpointState", State.to_query f))
         ; Aws.Util.option_map v.vpc_endpoint_owner (fun f ->
               Aws.Query.Pair ("VpcEndpointOwner", String.to_query f))
         ; Aws.Util.option_map v.vpc_endpoint_id (fun f ->
               Aws.Query.Pair ("VpcEndpointId", String.to_query f))
         ; Aws.Util.option_map v.service_id (fun f ->
               Aws.Query.Pair ("ServiceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "gatewayLoadBalancerArnSet"
             , ValueStringList.to_json v.gateway_load_balancer_arns )
         ; Some
             ( "networkLoadBalancerArnSet"
             , ValueStringList.to_json v.network_load_balancer_arns )
         ; Some ("dnsEntrySet", DnsEntrySet.to_json v.dns_entries)
         ; Aws.Util.option_map v.creation_timestamp (fun f ->
               "creationTimestamp", DateTime.to_json f)
         ; Aws.Util.option_map v.vpc_endpoint_state (fun f ->
               "vpcEndpointState", State.to_json f)
         ; Aws.Util.option_map v.vpc_endpoint_owner (fun f ->
               "vpcEndpointOwner", String.to_json f)
         ; Aws.Util.option_map v.vpc_endpoint_id (fun f ->
               "vpcEndpointId", String.to_json f)
         ; Aws.Util.option_map v.service_id (fun f -> "serviceId", String.to_json f)
         ])

  let of_json j =
    { service_id = Aws.Util.option_map (Aws.Json.lookup j "serviceId") String.of_json
    ; vpc_endpoint_id =
        Aws.Util.option_map (Aws.Json.lookup j "vpcEndpointId") String.of_json
    ; vpc_endpoint_owner =
        Aws.Util.option_map (Aws.Json.lookup j "vpcEndpointOwner") String.of_json
    ; vpc_endpoint_state =
        Aws.Util.option_map (Aws.Json.lookup j "vpcEndpointState") State.of_json
    ; creation_timestamp =
        Aws.Util.option_map (Aws.Json.lookup j "creationTimestamp") DateTime.of_json
    ; dns_entries =
        DnsEntrySet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "dnsEntrySet"))
    ; network_load_balancer_arns =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "networkLoadBalancerArnSet"))
    ; gateway_load_balancer_arns =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "gatewayLoadBalancerArnSet"))
    }
end

module VpnGatewayIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "VpnGatewayId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module ClientVpnRouteStatusCode = struct
  type t =
    | Creating
    | Active
    | Failed
    | Deleting

  let str_to_t =
    [ "deleting", Deleting; "failed", Failed; "active", Active; "creating", Creating ]

  let t_to_str =
    [ Deleting, "deleting"; Failed, "failed"; Active, "active"; Creating, "creating" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ClientVpnRouteStatus = struct
  type t =
    { code : ClientVpnRouteStatusCode.t option
    ; message : String.t option
    }

  let make ?code ?message () = { code; message }

  let parse xml =
    Some
      { code =
          Aws.Util.option_bind (Aws.Xml.member "code" xml) ClientVpnRouteStatusCode.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair ("Code", ClientVpnRouteStatusCode.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f)
         ; Aws.Util.option_map v.code (fun f ->
               "code", ClientVpnRouteStatusCode.to_json f)
         ])

  let of_json j =
    { code =
        Aws.Util.option_map (Aws.Json.lookup j "code") ClientVpnRouteStatusCode.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json
    }
end

module ClientVpnRoute = struct
  type t =
    { client_vpn_endpoint_id : String.t option
    ; destination_cidr : String.t option
    ; target_subnet : String.t option
    ; type_ : String.t option
    ; origin : String.t option
    ; status : ClientVpnRouteStatus.t option
    ; description : String.t option
    }

  let make
      ?client_vpn_endpoint_id
      ?destination_cidr
      ?target_subnet
      ?type_
      ?origin
      ?status
      ?description
      () =
    { client_vpn_endpoint_id
    ; destination_cidr
    ; target_subnet
    ; type_
    ; origin
    ; status
    ; description
    }

  let parse xml =
    Some
      { client_vpn_endpoint_id =
          Aws.Util.option_bind (Aws.Xml.member "clientVpnEndpointId" xml) String.parse
      ; destination_cidr =
          Aws.Util.option_bind (Aws.Xml.member "destinationCidr" xml) String.parse
      ; target_subnet =
          Aws.Util.option_bind (Aws.Xml.member "targetSubnet" xml) String.parse
      ; type_ = Aws.Util.option_bind (Aws.Xml.member "type" xml) String.parse
      ; origin = Aws.Util.option_bind (Aws.Xml.member "origin" xml) String.parse
      ; status =
          Aws.Util.option_bind (Aws.Xml.member "status" xml) ClientVpnRouteStatus.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", ClientVpnRouteStatus.to_query f))
         ; Aws.Util.option_map v.origin (fun f ->
               Aws.Query.Pair ("Origin", String.to_query f))
         ; Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", String.to_query f))
         ; Aws.Util.option_map v.target_subnet (fun f ->
               Aws.Query.Pair ("TargetSubnet", String.to_query f))
         ; Aws.Util.option_map v.destination_cidr (fun f ->
               Aws.Query.Pair ("DestinationCidr", String.to_query f))
         ; Aws.Util.option_map v.client_vpn_endpoint_id (fun f ->
               Aws.Query.Pair ("ClientVpnEndpointId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Aws.Util.option_map v.status (fun f ->
               "status", ClientVpnRouteStatus.to_json f)
         ; Aws.Util.option_map v.origin (fun f -> "origin", String.to_json f)
         ; Aws.Util.option_map v.type_ (fun f -> "type", String.to_json f)
         ; Aws.Util.option_map v.target_subnet (fun f -> "targetSubnet", String.to_json f)
         ; Aws.Util.option_map v.destination_cidr (fun f ->
               "destinationCidr", String.to_json f)
         ; Aws.Util.option_map v.client_vpn_endpoint_id (fun f ->
               "clientVpnEndpointId", String.to_json f)
         ])

  let of_json j =
    { client_vpn_endpoint_id =
        Aws.Util.option_map (Aws.Json.lookup j "clientVpnEndpointId") String.of_json
    ; destination_cidr =
        Aws.Util.option_map (Aws.Json.lookup j "destinationCidr") String.of_json
    ; target_subnet =
        Aws.Util.option_map (Aws.Json.lookup j "targetSubnet") String.of_json
    ; type_ = Aws.Util.option_map (Aws.Json.lookup j "type") String.of_json
    ; origin = Aws.Util.option_map (Aws.Json.lookup j "origin") String.of_json
    ; status =
        Aws.Util.option_map (Aws.Json.lookup j "status") ClientVpnRouteStatus.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    }
end

module RouteTableAssociation = struct
  type t =
    { main : Boolean.t option
    ; route_table_association_id : String.t option
    ; route_table_id : String.t option
    ; subnet_id : String.t option
    ; gateway_id : String.t option
    ; association_state : RouteTableAssociationState.t option
    }

  let make
      ?main
      ?route_table_association_id
      ?route_table_id
      ?subnet_id
      ?gateway_id
      ?association_state
      () =
    { main
    ; route_table_association_id
    ; route_table_id
    ; subnet_id
    ; gateway_id
    ; association_state
    }

  let parse xml =
    Some
      { main = Aws.Util.option_bind (Aws.Xml.member "main" xml) Boolean.parse
      ; route_table_association_id =
          Aws.Util.option_bind (Aws.Xml.member "routeTableAssociationId" xml) String.parse
      ; route_table_id =
          Aws.Util.option_bind (Aws.Xml.member "routeTableId" xml) String.parse
      ; subnet_id = Aws.Util.option_bind (Aws.Xml.member "subnetId" xml) String.parse
      ; gateway_id = Aws.Util.option_bind (Aws.Xml.member "gatewayId" xml) String.parse
      ; association_state =
          Aws.Util.option_bind
            (Aws.Xml.member "associationState" xml)
            RouteTableAssociationState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_state (fun f ->
               Aws.Query.Pair ("AssociationState", RouteTableAssociationState.to_query f))
         ; Aws.Util.option_map v.gateway_id (fun f ->
               Aws.Query.Pair ("GatewayId", String.to_query f))
         ; Aws.Util.option_map v.subnet_id (fun f ->
               Aws.Query.Pair ("SubnetId", String.to_query f))
         ; Aws.Util.option_map v.route_table_id (fun f ->
               Aws.Query.Pair ("RouteTableId", String.to_query f))
         ; Aws.Util.option_map v.route_table_association_id (fun f ->
               Aws.Query.Pair ("RouteTableAssociationId", String.to_query f))
         ; Aws.Util.option_map v.main (fun f ->
               Aws.Query.Pair ("Main", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_state (fun f ->
               "associationState", RouteTableAssociationState.to_json f)
         ; Aws.Util.option_map v.gateway_id (fun f -> "gatewayId", String.to_json f)
         ; Aws.Util.option_map v.subnet_id (fun f -> "subnetId", String.to_json f)
         ; Aws.Util.option_map v.route_table_id (fun f ->
               "routeTableId", String.to_json f)
         ; Aws.Util.option_map v.route_table_association_id (fun f ->
               "routeTableAssociationId", String.to_json f)
         ; Aws.Util.option_map v.main (fun f -> "main", Boolean.to_json f)
         ])

  let of_json j =
    { main = Aws.Util.option_map (Aws.Json.lookup j "main") Boolean.of_json
    ; route_table_association_id =
        Aws.Util.option_map (Aws.Json.lookup j "routeTableAssociationId") String.of_json
    ; route_table_id =
        Aws.Util.option_map (Aws.Json.lookup j "routeTableId") String.of_json
    ; subnet_id = Aws.Util.option_map (Aws.Json.lookup j "subnetId") String.of_json
    ; gateway_id = Aws.Util.option_map (Aws.Json.lookup j "gatewayId") String.of_json
    ; association_state =
        Aws.Util.option_map
          (Aws.Json.lookup j "associationState")
          RouteTableAssociationState.of_json
    }
end

module RouteTableAssociationList = struct
  type t = RouteTableAssociation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map RouteTableAssociation.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list RouteTableAssociation.to_query v

  let to_json v = `List (List.map RouteTableAssociation.to_json v)

  let of_json j = Aws.Json.to_list RouteTableAssociation.of_json j
end

module PropagatingVgw = struct
  type t = { gateway_id : String.t option }

  let make ?gateway_id () = { gateway_id }

  let parse xml =
    Some
      { gateway_id = Aws.Util.option_bind (Aws.Xml.member "gatewayId" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.gateway_id (fun f ->
               Aws.Query.Pair ("GatewayId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.gateway_id (fun f -> "gatewayId", String.to_json f) ])

  let of_json j =
    { gateway_id = Aws.Util.option_map (Aws.Json.lookup j "gatewayId") String.of_json }
end

module PropagatingVgwList = struct
  type t = PropagatingVgw.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map PropagatingVgw.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list PropagatingVgw.to_query v

  let to_json v = `List (List.map PropagatingVgw.to_json v)

  let of_json j = Aws.Json.to_list PropagatingVgw.of_json j
end

module RouteTable = struct
  type t =
    { associations : RouteTableAssociationList.t
    ; propagating_vgws : PropagatingVgwList.t
    ; route_table_id : String.t option
    ; routes : RouteList.t
    ; tags : TagList.t
    ; vpc_id : String.t option
    ; owner_id : String.t option
    }

  let make
      ?(associations = [])
      ?(propagating_vgws = [])
      ?route_table_id
      ?(routes = [])
      ?(tags = [])
      ?vpc_id
      ?owner_id
      () =
    { associations; propagating_vgws; route_table_id; routes; tags; vpc_id; owner_id }

  let parse xml =
    Some
      { associations =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "associationSet" xml)
               RouteTableAssociationList.parse)
      ; propagating_vgws =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "propagatingVgwSet" xml)
               PropagatingVgwList.parse)
      ; route_table_id =
          Aws.Util.option_bind (Aws.Xml.member "routeTableId" xml) String.parse
      ; routes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "routeSet" xml) RouteList.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Some (Aws.Query.Pair ("RouteSet", RouteList.to_query v.routes))
         ; Aws.Util.option_map v.route_table_id (fun f ->
               Aws.Query.Pair ("RouteTableId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("PropagatingVgwSet", PropagatingVgwList.to_query v.propagating_vgws))
         ; Some
             (Aws.Query.Pair
                ("AssociationSet", RouteTableAssociationList.to_query v.associations))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.vpc_id (fun f -> "vpcId", String.to_json f)
         ; Some ("tagSet", TagList.to_json v.tags)
         ; Some ("routeSet", RouteList.to_json v.routes)
         ; Aws.Util.option_map v.route_table_id (fun f ->
               "routeTableId", String.to_json f)
         ; Some ("propagatingVgwSet", PropagatingVgwList.to_json v.propagating_vgws)
         ; Some ("associationSet", RouteTableAssociationList.to_json v.associations)
         ])

  let of_json j =
    { associations =
        RouteTableAssociationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "associationSet"))
    ; propagating_vgws =
        PropagatingVgwList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "propagatingVgwSet"))
    ; route_table_id =
        Aws.Util.option_map (Aws.Json.lookup j "routeTableId") String.of_json
    ; routes = RouteList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "routeSet"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "vpcId") String.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    }
end

module RouteTableList = struct
  type t = RouteTable.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map RouteTable.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list RouteTable.to_query v

  let to_json v = `List (List.map RouteTable.to_json v)

  let of_json j = Aws.Json.to_list RouteTable.of_json j
end

module RouteTableIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module PublicIpv4PoolRangeSet = struct
  type t = PublicIpv4PoolRange.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map PublicIpv4PoolRange.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list PublicIpv4PoolRange.to_query v

  let to_json v = `List (List.map PublicIpv4PoolRange.to_json v)

  let of_json j = Aws.Json.to_list PublicIpv4PoolRange.of_json j
end

module PublicIpv4Pool = struct
  type t =
    { pool_id : String.t option
    ; description : String.t option
    ; pool_address_ranges : PublicIpv4PoolRangeSet.t
    ; total_address_count : Integer.t option
    ; total_available_address_count : Integer.t option
    ; network_border_group : String.t option
    ; tags : TagList.t
    }

  let make
      ?pool_id
      ?description
      ?(pool_address_ranges = [])
      ?total_address_count
      ?total_available_address_count
      ?network_border_group
      ?(tags = [])
      () =
    { pool_id
    ; description
    ; pool_address_ranges
    ; total_address_count
    ; total_available_address_count
    ; network_border_group
    ; tags
    }

  let parse xml =
    Some
      { pool_id = Aws.Util.option_bind (Aws.Xml.member "poolId" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; pool_address_ranges =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "poolAddressRangeSet" xml)
               PublicIpv4PoolRangeSet.parse)
      ; total_address_count =
          Aws.Util.option_bind (Aws.Xml.member "totalAddressCount" xml) Integer.parse
      ; total_available_address_count =
          Aws.Util.option_bind
            (Aws.Xml.member "totalAvailableAddressCount" xml)
            Integer.parse
      ; network_border_group =
          Aws.Util.option_bind (Aws.Xml.member "networkBorderGroup" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.network_border_group (fun f ->
               Aws.Query.Pair ("NetworkBorderGroup", String.to_query f))
         ; Aws.Util.option_map v.total_available_address_count (fun f ->
               Aws.Query.Pair ("TotalAvailableAddressCount", Integer.to_query f))
         ; Aws.Util.option_map v.total_address_count (fun f ->
               Aws.Query.Pair ("TotalAddressCount", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "PoolAddressRangeSet"
                , PublicIpv4PoolRangeSet.to_query v.pool_address_ranges ))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.pool_id (fun f ->
               Aws.Query.Pair ("PoolId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.network_border_group (fun f ->
               "networkBorderGroup", String.to_json f)
         ; Aws.Util.option_map v.total_available_address_count (fun f ->
               "totalAvailableAddressCount", Integer.to_json f)
         ; Aws.Util.option_map v.total_address_count (fun f ->
               "totalAddressCount", Integer.to_json f)
         ; Some
             ("poolAddressRangeSet", PublicIpv4PoolRangeSet.to_json v.pool_address_ranges)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Aws.Util.option_map v.pool_id (fun f -> "poolId", String.to_json f)
         ])

  let of_json j =
    { pool_id = Aws.Util.option_map (Aws.Json.lookup j "poolId") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; pool_address_ranges =
        PublicIpv4PoolRangeSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "poolAddressRangeSet"))
    ; total_address_count =
        Aws.Util.option_map (Aws.Json.lookup j "totalAddressCount") Integer.of_json
    ; total_available_address_count =
        Aws.Util.option_map
          (Aws.Json.lookup j "totalAvailableAddressCount")
          Integer.of_json
    ; network_border_group =
        Aws.Util.option_map (Aws.Json.lookup j "networkBorderGroup") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module PublicIpv4PoolSet = struct
  type t = PublicIpv4Pool.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map PublicIpv4Pool.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list PublicIpv4Pool.to_query v

  let to_json v = `List (List.map PublicIpv4Pool.to_json v)

  let of_json j = Aws.Json.to_list PublicIpv4Pool.of_json j
end

module DescribePublicIpv4PoolsResult = struct
  type t =
    { public_ipv4_pools : PublicIpv4PoolSet.t
    ; next_token : String.t option
    }

  let make ?(public_ipv4_pools = []) ?next_token () = { public_ipv4_pools; next_token }

  let parse xml =
    Some
      { public_ipv4_pools =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "publicIpv4PoolSet" xml)
               PublicIpv4PoolSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("PublicIpv4PoolSet", PublicIpv4PoolSet.to_query v.public_ipv4_pools))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("publicIpv4PoolSet", PublicIpv4PoolSet.to_json v.public_ipv4_pools)
         ])

  let of_json j =
    { public_ipv4_pools =
        PublicIpv4PoolSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "publicIpv4PoolSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DescribeIdFormatRequest = struct
  type t = { resource : String.t option }

  let make ?resource () = { resource }

  let parse xml =
    Some { resource = Aws.Util.option_bind (Aws.Xml.member "Resource" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.resource (fun f ->
               Aws.Query.Pair ("Resource", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.resource (fun f -> "Resource", String.to_json f) ])

  let of_json j =
    { resource = Aws.Util.option_map (Aws.Json.lookup j "Resource") String.of_json }
end

module ModifyVpnTunnelOptionsSpecification = struct
  type t =
    { tunnel_inside_cidr : String.t option
    ; tunnel_inside_ipv6_cidr : String.t option
    ; pre_shared_key : String.t option
    ; phase1_lifetime_seconds : Integer.t option
    ; phase2_lifetime_seconds : Integer.t option
    ; rekey_margin_time_seconds : Integer.t option
    ; rekey_fuzz_percentage : Integer.t option
    ; replay_window_size : Integer.t option
    ; d_p_d_timeout_seconds : Integer.t option
    ; d_p_d_timeout_action : String.t option
    ; phase1_encryption_algorithms : Phase1EncryptionAlgorithmsRequestList.t
    ; phase2_encryption_algorithms : Phase2EncryptionAlgorithmsRequestList.t
    ; phase1_integrity_algorithms : Phase1IntegrityAlgorithmsRequestList.t
    ; phase2_integrity_algorithms : Phase2IntegrityAlgorithmsRequestList.t
    ; phase1_d_h_group_numbers : Phase1DHGroupNumbersRequestList.t
    ; phase2_d_h_group_numbers : Phase2DHGroupNumbersRequestList.t
    ; i_k_e_versions : IKEVersionsRequestList.t
    ; startup_action : String.t option
    }

  let make
      ?tunnel_inside_cidr
      ?tunnel_inside_ipv6_cidr
      ?pre_shared_key
      ?phase1_lifetime_seconds
      ?phase2_lifetime_seconds
      ?rekey_margin_time_seconds
      ?rekey_fuzz_percentage
      ?replay_window_size
      ?d_p_d_timeout_seconds
      ?d_p_d_timeout_action
      ?(phase1_encryption_algorithms = [])
      ?(phase2_encryption_algorithms = [])
      ?(phase1_integrity_algorithms = [])
      ?(phase2_integrity_algorithms = [])
      ?(phase1_d_h_group_numbers = [])
      ?(phase2_d_h_group_numbers = [])
      ?(i_k_e_versions = [])
      ?startup_action
      () =
    { tunnel_inside_cidr
    ; tunnel_inside_ipv6_cidr
    ; pre_shared_key
    ; phase1_lifetime_seconds
    ; phase2_lifetime_seconds
    ; rekey_margin_time_seconds
    ; rekey_fuzz_percentage
    ; replay_window_size
    ; d_p_d_timeout_seconds
    ; d_p_d_timeout_action
    ; phase1_encryption_algorithms
    ; phase2_encryption_algorithms
    ; phase1_integrity_algorithms
    ; phase2_integrity_algorithms
    ; phase1_d_h_group_numbers
    ; phase2_d_h_group_numbers
    ; i_k_e_versions
    ; startup_action
    }

  let parse xml =
    Some
      { tunnel_inside_cidr =
          Aws.Util.option_bind (Aws.Xml.member "TunnelInsideCidr" xml) String.parse
      ; tunnel_inside_ipv6_cidr =
          Aws.Util.option_bind (Aws.Xml.member "TunnelInsideIpv6Cidr" xml) String.parse
      ; pre_shared_key =
          Aws.Util.option_bind (Aws.Xml.member "PreSharedKey" xml) String.parse
      ; phase1_lifetime_seconds =
          Aws.Util.option_bind (Aws.Xml.member "Phase1LifetimeSeconds" xml) Integer.parse
      ; phase2_lifetime_seconds =
          Aws.Util.option_bind (Aws.Xml.member "Phase2LifetimeSeconds" xml) Integer.parse
      ; rekey_margin_time_seconds =
          Aws.Util.option_bind (Aws.Xml.member "RekeyMarginTimeSeconds" xml) Integer.parse
      ; rekey_fuzz_percentage =
          Aws.Util.option_bind (Aws.Xml.member "RekeyFuzzPercentage" xml) Integer.parse
      ; replay_window_size =
          Aws.Util.option_bind (Aws.Xml.member "ReplayWindowSize" xml) Integer.parse
      ; d_p_d_timeout_seconds =
          Aws.Util.option_bind (Aws.Xml.member "DPDTimeoutSeconds" xml) Integer.parse
      ; d_p_d_timeout_action =
          Aws.Util.option_bind (Aws.Xml.member "DPDTimeoutAction" xml) String.parse
      ; phase1_encryption_algorithms =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Phase1EncryptionAlgorithm" xml)
               Phase1EncryptionAlgorithmsRequestList.parse)
      ; phase2_encryption_algorithms =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Phase2EncryptionAlgorithm" xml)
               Phase2EncryptionAlgorithmsRequestList.parse)
      ; phase1_integrity_algorithms =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Phase1IntegrityAlgorithm" xml)
               Phase1IntegrityAlgorithmsRequestList.parse)
      ; phase2_integrity_algorithms =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Phase2IntegrityAlgorithm" xml)
               Phase2IntegrityAlgorithmsRequestList.parse)
      ; phase1_d_h_group_numbers =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Phase1DHGroupNumber" xml)
               Phase1DHGroupNumbersRequestList.parse)
      ; phase2_d_h_group_numbers =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Phase2DHGroupNumber" xml)
               Phase2DHGroupNumbersRequestList.parse)
      ; i_k_e_versions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "IKEVersion" xml)
               IKEVersionsRequestList.parse)
      ; startup_action =
          Aws.Util.option_bind (Aws.Xml.member "StartupAction" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.startup_action (fun f ->
               Aws.Query.Pair ("StartupAction", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("IKEVersion", IKEVersionsRequestList.to_query v.i_k_e_versions))
         ; Some
             (Aws.Query.Pair
                ( "Phase2DHGroupNumber"
                , Phase2DHGroupNumbersRequestList.to_query v.phase2_d_h_group_numbers ))
         ; Some
             (Aws.Query.Pair
                ( "Phase1DHGroupNumber"
                , Phase1DHGroupNumbersRequestList.to_query v.phase1_d_h_group_numbers ))
         ; Some
             (Aws.Query.Pair
                ( "Phase2IntegrityAlgorithm"
                , Phase2IntegrityAlgorithmsRequestList.to_query
                    v.phase2_integrity_algorithms ))
         ; Some
             (Aws.Query.Pair
                ( "Phase1IntegrityAlgorithm"
                , Phase1IntegrityAlgorithmsRequestList.to_query
                    v.phase1_integrity_algorithms ))
         ; Some
             (Aws.Query.Pair
                ( "Phase2EncryptionAlgorithm"
                , Phase2EncryptionAlgorithmsRequestList.to_query
                    v.phase2_encryption_algorithms ))
         ; Some
             (Aws.Query.Pair
                ( "Phase1EncryptionAlgorithm"
                , Phase1EncryptionAlgorithmsRequestList.to_query
                    v.phase1_encryption_algorithms ))
         ; Aws.Util.option_map v.d_p_d_timeout_action (fun f ->
               Aws.Query.Pair ("DPDTimeoutAction", String.to_query f))
         ; Aws.Util.option_map v.d_p_d_timeout_seconds (fun f ->
               Aws.Query.Pair ("DPDTimeoutSeconds", Integer.to_query f))
         ; Aws.Util.option_map v.replay_window_size (fun f ->
               Aws.Query.Pair ("ReplayWindowSize", Integer.to_query f))
         ; Aws.Util.option_map v.rekey_fuzz_percentage (fun f ->
               Aws.Query.Pair ("RekeyFuzzPercentage", Integer.to_query f))
         ; Aws.Util.option_map v.rekey_margin_time_seconds (fun f ->
               Aws.Query.Pair ("RekeyMarginTimeSeconds", Integer.to_query f))
         ; Aws.Util.option_map v.phase2_lifetime_seconds (fun f ->
               Aws.Query.Pair ("Phase2LifetimeSeconds", Integer.to_query f))
         ; Aws.Util.option_map v.phase1_lifetime_seconds (fun f ->
               Aws.Query.Pair ("Phase1LifetimeSeconds", Integer.to_query f))
         ; Aws.Util.option_map v.pre_shared_key (fun f ->
               Aws.Query.Pair ("PreSharedKey", String.to_query f))
         ; Aws.Util.option_map v.tunnel_inside_ipv6_cidr (fun f ->
               Aws.Query.Pair ("TunnelInsideIpv6Cidr", String.to_query f))
         ; Aws.Util.option_map v.tunnel_inside_cidr (fun f ->
               Aws.Query.Pair ("TunnelInsideCidr", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.startup_action (fun f ->
               "StartupAction", String.to_json f)
         ; Some ("IKEVersion", IKEVersionsRequestList.to_json v.i_k_e_versions)
         ; Some
             ( "Phase2DHGroupNumber"
             , Phase2DHGroupNumbersRequestList.to_json v.phase2_d_h_group_numbers )
         ; Some
             ( "Phase1DHGroupNumber"
             , Phase1DHGroupNumbersRequestList.to_json v.phase1_d_h_group_numbers )
         ; Some
             ( "Phase2IntegrityAlgorithm"
             , Phase2IntegrityAlgorithmsRequestList.to_json v.phase2_integrity_algorithms
             )
         ; Some
             ( "Phase1IntegrityAlgorithm"
             , Phase1IntegrityAlgorithmsRequestList.to_json v.phase1_integrity_algorithms
             )
         ; Some
             ( "Phase2EncryptionAlgorithm"
             , Phase2EncryptionAlgorithmsRequestList.to_json
                 v.phase2_encryption_algorithms )
         ; Some
             ( "Phase1EncryptionAlgorithm"
             , Phase1EncryptionAlgorithmsRequestList.to_json
                 v.phase1_encryption_algorithms )
         ; Aws.Util.option_map v.d_p_d_timeout_action (fun f ->
               "DPDTimeoutAction", String.to_json f)
         ; Aws.Util.option_map v.d_p_d_timeout_seconds (fun f ->
               "DPDTimeoutSeconds", Integer.to_json f)
         ; Aws.Util.option_map v.replay_window_size (fun f ->
               "ReplayWindowSize", Integer.to_json f)
         ; Aws.Util.option_map v.rekey_fuzz_percentage (fun f ->
               "RekeyFuzzPercentage", Integer.to_json f)
         ; Aws.Util.option_map v.rekey_margin_time_seconds (fun f ->
               "RekeyMarginTimeSeconds", Integer.to_json f)
         ; Aws.Util.option_map v.phase2_lifetime_seconds (fun f ->
               "Phase2LifetimeSeconds", Integer.to_json f)
         ; Aws.Util.option_map v.phase1_lifetime_seconds (fun f ->
               "Phase1LifetimeSeconds", Integer.to_json f)
         ; Aws.Util.option_map v.pre_shared_key (fun f ->
               "PreSharedKey", String.to_json f)
         ; Aws.Util.option_map v.tunnel_inside_ipv6_cidr (fun f ->
               "TunnelInsideIpv6Cidr", String.to_json f)
         ; Aws.Util.option_map v.tunnel_inside_cidr (fun f ->
               "TunnelInsideCidr", String.to_json f)
         ])

  let of_json j =
    { tunnel_inside_cidr =
        Aws.Util.option_map (Aws.Json.lookup j "TunnelInsideCidr") String.of_json
    ; tunnel_inside_ipv6_cidr =
        Aws.Util.option_map (Aws.Json.lookup j "TunnelInsideIpv6Cidr") String.of_json
    ; pre_shared_key =
        Aws.Util.option_map (Aws.Json.lookup j "PreSharedKey") String.of_json
    ; phase1_lifetime_seconds =
        Aws.Util.option_map (Aws.Json.lookup j "Phase1LifetimeSeconds") Integer.of_json
    ; phase2_lifetime_seconds =
        Aws.Util.option_map (Aws.Json.lookup j "Phase2LifetimeSeconds") Integer.of_json
    ; rekey_margin_time_seconds =
        Aws.Util.option_map (Aws.Json.lookup j "RekeyMarginTimeSeconds") Integer.of_json
    ; rekey_fuzz_percentage =
        Aws.Util.option_map (Aws.Json.lookup j "RekeyFuzzPercentage") Integer.of_json
    ; replay_window_size =
        Aws.Util.option_map (Aws.Json.lookup j "ReplayWindowSize") Integer.of_json
    ; d_p_d_timeout_seconds =
        Aws.Util.option_map (Aws.Json.lookup j "DPDTimeoutSeconds") Integer.of_json
    ; d_p_d_timeout_action =
        Aws.Util.option_map (Aws.Json.lookup j "DPDTimeoutAction") String.of_json
    ; phase1_encryption_algorithms =
        Phase1EncryptionAlgorithmsRequestList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Phase1EncryptionAlgorithm"))
    ; phase2_encryption_algorithms =
        Phase2EncryptionAlgorithmsRequestList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Phase2EncryptionAlgorithm"))
    ; phase1_integrity_algorithms =
        Phase1IntegrityAlgorithmsRequestList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Phase1IntegrityAlgorithm"))
    ; phase2_integrity_algorithms =
        Phase2IntegrityAlgorithmsRequestList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Phase2IntegrityAlgorithm"))
    ; phase1_d_h_group_numbers =
        Phase1DHGroupNumbersRequestList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Phase1DHGroupNumber"))
    ; phase2_d_h_group_numbers =
        Phase2DHGroupNumbersRequestList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Phase2DHGroupNumber"))
    ; i_k_e_versions =
        IKEVersionsRequestList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "IKEVersion"))
    ; startup_action =
        Aws.Util.option_map (Aws.Json.lookup j "StartupAction") String.of_json
    }
end

module FailedQueuedPurchaseDeletion = struct
  type t =
    { error : DeleteQueuedReservedInstancesError.t option
    ; reserved_instances_id : String.t option
    }

  let make ?error ?reserved_instances_id () = { error; reserved_instances_id }

  let parse xml =
    Some
      { error =
          Aws.Util.option_bind
            (Aws.Xml.member "error" xml)
            DeleteQueuedReservedInstancesError.parse
      ; reserved_instances_id =
          Aws.Util.option_bind (Aws.Xml.member "reservedInstancesId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.reserved_instances_id (fun f ->
               Aws.Query.Pair ("ReservedInstancesId", String.to_query f))
         ; Aws.Util.option_map v.error (fun f ->
               Aws.Query.Pair ("Error", DeleteQueuedReservedInstancesError.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.reserved_instances_id (fun f ->
               "reservedInstancesId", String.to_json f)
         ; Aws.Util.option_map v.error (fun f ->
               "error", DeleteQueuedReservedInstancesError.to_json f)
         ])

  let of_json j =
    { error =
        Aws.Util.option_map
          (Aws.Json.lookup j "error")
          DeleteQueuedReservedInstancesError.of_json
    ; reserved_instances_id =
        Aws.Util.option_map (Aws.Json.lookup j "reservedInstancesId") String.of_json
    }
end

module ModifyEbsDefaultKmsKeyIdRequest = struct
  type t =
    { kms_key_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~kms_key_id ?dry_run () = { kms_key_id; dry_run }

  let parse xml =
    Some
      { kms_key_id =
          Aws.Xml.required
            "KmsKeyId"
            (Aws.Util.option_bind (Aws.Xml.member "KmsKeyId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("KmsKeyId", String.to_query v.kms_key_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("KmsKeyId", String.to_json v.kms_key_id)
         ])

  let of_json j =
    { kms_key_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "KmsKeyId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module LaunchTemplateNameStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module CreateClientVpnRouteResult = struct
  type t = { status : ClientVpnRouteStatus.t option }

  let make ?status () = { status }

  let parse xml =
    Some
      { status =
          Aws.Util.option_bind (Aws.Xml.member "status" xml) ClientVpnRouteStatus.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", ClientVpnRouteStatus.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               "status", ClientVpnRouteStatus.to_json f)
         ])

  let of_json j =
    { status =
        Aws.Util.option_map (Aws.Json.lookup j "status") ClientVpnRouteStatus.of_json
    }
end

module Purchase = struct
  type t =
    { currency_code : CurrencyCodeValues.t option
    ; duration : Integer.t option
    ; host_id_set : ResponseHostIdSet.t
    ; host_reservation_id : String.t option
    ; hourly_price : String.t option
    ; instance_family : String.t option
    ; payment_option : PaymentOption.t option
    ; upfront_price : String.t option
    }

  let make
      ?currency_code
      ?duration
      ?(host_id_set = [])
      ?host_reservation_id
      ?hourly_price
      ?instance_family
      ?payment_option
      ?upfront_price
      () =
    { currency_code
    ; duration
    ; host_id_set
    ; host_reservation_id
    ; hourly_price
    ; instance_family
    ; payment_option
    ; upfront_price
    }

  let parse xml =
    Some
      { currency_code =
          Aws.Util.option_bind
            (Aws.Xml.member "currencyCode" xml)
            CurrencyCodeValues.parse
      ; duration = Aws.Util.option_bind (Aws.Xml.member "duration" xml) Integer.parse
      ; host_id_set =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "hostIdSet" xml)
               ResponseHostIdSet.parse)
      ; host_reservation_id =
          Aws.Util.option_bind (Aws.Xml.member "hostReservationId" xml) String.parse
      ; hourly_price =
          Aws.Util.option_bind (Aws.Xml.member "hourlyPrice" xml) String.parse
      ; instance_family =
          Aws.Util.option_bind (Aws.Xml.member "instanceFamily" xml) String.parse
      ; payment_option =
          Aws.Util.option_bind (Aws.Xml.member "paymentOption" xml) PaymentOption.parse
      ; upfront_price =
          Aws.Util.option_bind (Aws.Xml.member "upfrontPrice" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.upfront_price (fun f ->
               Aws.Query.Pair ("UpfrontPrice", String.to_query f))
         ; Aws.Util.option_map v.payment_option (fun f ->
               Aws.Query.Pair ("PaymentOption", PaymentOption.to_query f))
         ; Aws.Util.option_map v.instance_family (fun f ->
               Aws.Query.Pair ("InstanceFamily", String.to_query f))
         ; Aws.Util.option_map v.hourly_price (fun f ->
               Aws.Query.Pair ("HourlyPrice", String.to_query f))
         ; Aws.Util.option_map v.host_reservation_id (fun f ->
               Aws.Query.Pair ("HostReservationId", String.to_query f))
         ; Some (Aws.Query.Pair ("HostIdSet", ResponseHostIdSet.to_query v.host_id_set))
         ; Aws.Util.option_map v.duration (fun f ->
               Aws.Query.Pair ("Duration", Integer.to_query f))
         ; Aws.Util.option_map v.currency_code (fun f ->
               Aws.Query.Pair ("CurrencyCode", CurrencyCodeValues.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.upfront_price (fun f -> "upfrontPrice", String.to_json f)
         ; Aws.Util.option_map v.payment_option (fun f ->
               "paymentOption", PaymentOption.to_json f)
         ; Aws.Util.option_map v.instance_family (fun f ->
               "instanceFamily", String.to_json f)
         ; Aws.Util.option_map v.hourly_price (fun f -> "hourlyPrice", String.to_json f)
         ; Aws.Util.option_map v.host_reservation_id (fun f ->
               "hostReservationId", String.to_json f)
         ; Some ("hostIdSet", ResponseHostIdSet.to_json v.host_id_set)
         ; Aws.Util.option_map v.duration (fun f -> "duration", Integer.to_json f)
         ; Aws.Util.option_map v.currency_code (fun f ->
               "currencyCode", CurrencyCodeValues.to_json f)
         ])

  let of_json j =
    { currency_code =
        Aws.Util.option_map (Aws.Json.lookup j "currencyCode") CurrencyCodeValues.of_json
    ; duration = Aws.Util.option_map (Aws.Json.lookup j "duration") Integer.of_json
    ; host_id_set =
        ResponseHostIdSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "hostIdSet"))
    ; host_reservation_id =
        Aws.Util.option_map (Aws.Json.lookup j "hostReservationId") String.of_json
    ; hourly_price = Aws.Util.option_map (Aws.Json.lookup j "hourlyPrice") String.of_json
    ; instance_family =
        Aws.Util.option_map (Aws.Json.lookup j "instanceFamily") String.of_json
    ; payment_option =
        Aws.Util.option_map (Aws.Json.lookup j "paymentOption") PaymentOption.of_json
    ; upfront_price =
        Aws.Util.option_map (Aws.Json.lookup j "upfrontPrice") String.of_json
    }
end

module PurchaseSet = struct
  type t = Purchase.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Purchase.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Purchase.to_query v

  let to_json v = `List (List.map Purchase.to_json v)

  let of_json j = Aws.Json.to_list Purchase.of_json j
end

module PurchaseHostReservationResult = struct
  type t =
    { client_token : String.t option
    ; currency_code : CurrencyCodeValues.t option
    ; purchase : PurchaseSet.t
    ; total_hourly_price : String.t option
    ; total_upfront_price : String.t option
    }

  let make
      ?client_token
      ?currency_code
      ?(purchase = [])
      ?total_hourly_price
      ?total_upfront_price
      () =
    { client_token; currency_code; purchase; total_hourly_price; total_upfront_price }

  let parse xml =
    Some
      { client_token =
          Aws.Util.option_bind (Aws.Xml.member "clientToken" xml) String.parse
      ; currency_code =
          Aws.Util.option_bind
            (Aws.Xml.member "currencyCode" xml)
            CurrencyCodeValues.parse
      ; purchase =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "purchase" xml) PurchaseSet.parse)
      ; total_hourly_price =
          Aws.Util.option_bind (Aws.Xml.member "totalHourlyPrice" xml) String.parse
      ; total_upfront_price =
          Aws.Util.option_bind (Aws.Xml.member "totalUpfrontPrice" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.total_upfront_price (fun f ->
               Aws.Query.Pair ("TotalUpfrontPrice", String.to_query f))
         ; Aws.Util.option_map v.total_hourly_price (fun f ->
               Aws.Query.Pair ("TotalHourlyPrice", String.to_query f))
         ; Some (Aws.Query.Pair ("Purchase", PurchaseSet.to_query v.purchase))
         ; Aws.Util.option_map v.currency_code (fun f ->
               Aws.Query.Pair ("CurrencyCode", CurrencyCodeValues.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.total_upfront_price (fun f ->
               "totalUpfrontPrice", String.to_json f)
         ; Aws.Util.option_map v.total_hourly_price (fun f ->
               "totalHourlyPrice", String.to_json f)
         ; Some ("purchase", PurchaseSet.to_json v.purchase)
         ; Aws.Util.option_map v.currency_code (fun f ->
               "currencyCode", CurrencyCodeValues.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "clientToken", String.to_json f)
         ])

  let of_json j =
    { client_token = Aws.Util.option_map (Aws.Json.lookup j "clientToken") String.of_json
    ; currency_code =
        Aws.Util.option_map (Aws.Json.lookup j "currencyCode") CurrencyCodeValues.of_json
    ; purchase =
        PurchaseSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "purchase"))
    ; total_hourly_price =
        Aws.Util.option_map (Aws.Json.lookup j "totalHourlyPrice") String.of_json
    ; total_upfront_price =
        Aws.Util.option_map (Aws.Json.lookup j "totalUpfrontPrice") String.of_json
    }
end

module MonitorInstancesRequest = struct
  type t =
    { instance_ids : InstanceIdStringList.t
    ; dry_run : Boolean.t option
    }

  let make ~instance_ids ?dry_run () = { instance_ids; dry_run }

  let parse xml =
    Some
      { instance_ids =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind
               (Aws.Xml.member "InstanceId" xml)
               InstanceIdStringList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair ("InstanceId", InstanceIdStringList.to_query v.instance_ids))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("InstanceId", InstanceIdStringList.to_json v.instance_ids)
         ])

  let of_json j =
    { instance_ids =
        InstanceIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module InstanceNetworkInterfaceAssociation = struct
  type t =
    { carrier_ip : String.t option
    ; ip_owner_id : String.t option
    ; public_dns_name : String.t option
    ; public_ip : String.t option
    }

  let make ?carrier_ip ?ip_owner_id ?public_dns_name ?public_ip () =
    { carrier_ip; ip_owner_id; public_dns_name; public_ip }

  let parse xml =
    Some
      { carrier_ip = Aws.Util.option_bind (Aws.Xml.member "carrierIp" xml) String.parse
      ; ip_owner_id = Aws.Util.option_bind (Aws.Xml.member "ipOwnerId" xml) String.parse
      ; public_dns_name =
          Aws.Util.option_bind (Aws.Xml.member "publicDnsName" xml) String.parse
      ; public_ip = Aws.Util.option_bind (Aws.Xml.member "publicIp" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.public_ip (fun f ->
               Aws.Query.Pair ("PublicIp", String.to_query f))
         ; Aws.Util.option_map v.public_dns_name (fun f ->
               Aws.Query.Pair ("PublicDnsName", String.to_query f))
         ; Aws.Util.option_map v.ip_owner_id (fun f ->
               Aws.Query.Pair ("IpOwnerId", String.to_query f))
         ; Aws.Util.option_map v.carrier_ip (fun f ->
               Aws.Query.Pair ("CarrierIp", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.public_ip (fun f -> "publicIp", String.to_json f)
         ; Aws.Util.option_map v.public_dns_name (fun f ->
               "publicDnsName", String.to_json f)
         ; Aws.Util.option_map v.ip_owner_id (fun f -> "ipOwnerId", String.to_json f)
         ; Aws.Util.option_map v.carrier_ip (fun f -> "carrierIp", String.to_json f)
         ])

  let of_json j =
    { carrier_ip = Aws.Util.option_map (Aws.Json.lookup j "carrierIp") String.of_json
    ; ip_owner_id = Aws.Util.option_map (Aws.Json.lookup j "ipOwnerId") String.of_json
    ; public_dns_name =
        Aws.Util.option_map (Aws.Json.lookup j "publicDnsName") String.of_json
    ; public_ip = Aws.Util.option_map (Aws.Json.lookup j "publicIp") String.of_json
    }
end

module InstancePrivateIpAddress = struct
  type t =
    { association : InstanceNetworkInterfaceAssociation.t option
    ; primary : Boolean.t option
    ; private_dns_name : String.t option
    ; private_ip_address : String.t option
    }

  let make ?association ?primary ?private_dns_name ?private_ip_address () =
    { association; primary; private_dns_name; private_ip_address }

  let parse xml =
    Some
      { association =
          Aws.Util.option_bind
            (Aws.Xml.member "association" xml)
            InstanceNetworkInterfaceAssociation.parse
      ; primary = Aws.Util.option_bind (Aws.Xml.member "primary" xml) Boolean.parse
      ; private_dns_name =
          Aws.Util.option_bind (Aws.Xml.member "privateDnsName" xml) String.parse
      ; private_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "privateIpAddress" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.private_ip_address (fun f ->
               Aws.Query.Pair ("PrivateIpAddress", String.to_query f))
         ; Aws.Util.option_map v.private_dns_name (fun f ->
               Aws.Query.Pair ("PrivateDnsName", String.to_query f))
         ; Aws.Util.option_map v.primary (fun f ->
               Aws.Query.Pair ("Primary", Boolean.to_query f))
         ; Aws.Util.option_map v.association (fun f ->
               Aws.Query.Pair
                 ("Association", InstanceNetworkInterfaceAssociation.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.private_ip_address (fun f ->
               "privateIpAddress", String.to_json f)
         ; Aws.Util.option_map v.private_dns_name (fun f ->
               "privateDnsName", String.to_json f)
         ; Aws.Util.option_map v.primary (fun f -> "primary", Boolean.to_json f)
         ; Aws.Util.option_map v.association (fun f ->
               "association", InstanceNetworkInterfaceAssociation.to_json f)
         ])

  let of_json j =
    { association =
        Aws.Util.option_map
          (Aws.Json.lookup j "association")
          InstanceNetworkInterfaceAssociation.of_json
    ; primary = Aws.Util.option_map (Aws.Json.lookup j "primary") Boolean.of_json
    ; private_dns_name =
        Aws.Util.option_map (Aws.Json.lookup j "privateDnsName") String.of_json
    ; private_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "privateIpAddress") String.of_json
    }
end

module InstancePrivateIpAddressList = struct
  type t = InstancePrivateIpAddress.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map InstancePrivateIpAddress.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list InstancePrivateIpAddress.to_query v

  let to_json v = `List (List.map InstancePrivateIpAddress.to_json v)

  let of_json j = Aws.Json.to_list InstancePrivateIpAddress.of_json j
end

module InstanceNetworkInterfaceAttachment = struct
  type t =
    { attach_time : DateTime.t option
    ; attachment_id : String.t option
    ; delete_on_termination : Boolean.t option
    ; device_index : Integer.t option
    ; status : AttachmentStatus.t option
    ; network_card_index : Integer.t option
    }

  let make
      ?attach_time
      ?attachment_id
      ?delete_on_termination
      ?device_index
      ?status
      ?network_card_index
      () =
    { attach_time
    ; attachment_id
    ; delete_on_termination
    ; device_index
    ; status
    ; network_card_index
    }

  let parse xml =
    Some
      { attach_time =
          Aws.Util.option_bind (Aws.Xml.member "attachTime" xml) DateTime.parse
      ; attachment_id =
          Aws.Util.option_bind (Aws.Xml.member "attachmentId" xml) String.parse
      ; delete_on_termination =
          Aws.Util.option_bind (Aws.Xml.member "deleteOnTermination" xml) Boolean.parse
      ; device_index =
          Aws.Util.option_bind (Aws.Xml.member "deviceIndex" xml) Integer.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "status" xml) AttachmentStatus.parse
      ; network_card_index =
          Aws.Util.option_bind (Aws.Xml.member "networkCardIndex" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.network_card_index (fun f ->
               Aws.Query.Pair ("NetworkCardIndex", Integer.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", AttachmentStatus.to_query f))
         ; Aws.Util.option_map v.device_index (fun f ->
               Aws.Query.Pair ("DeviceIndex", Integer.to_query f))
         ; Aws.Util.option_map v.delete_on_termination (fun f ->
               Aws.Query.Pair ("DeleteOnTermination", Boolean.to_query f))
         ; Aws.Util.option_map v.attachment_id (fun f ->
               Aws.Query.Pair ("AttachmentId", String.to_query f))
         ; Aws.Util.option_map v.attach_time (fun f ->
               Aws.Query.Pair ("AttachTime", DateTime.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.network_card_index (fun f ->
               "networkCardIndex", Integer.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "status", AttachmentStatus.to_json f)
         ; Aws.Util.option_map v.device_index (fun f -> "deviceIndex", Integer.to_json f)
         ; Aws.Util.option_map v.delete_on_termination (fun f ->
               "deleteOnTermination", Boolean.to_json f)
         ; Aws.Util.option_map v.attachment_id (fun f -> "attachmentId", String.to_json f)
         ; Aws.Util.option_map v.attach_time (fun f -> "attachTime", DateTime.to_json f)
         ])

  let of_json j =
    { attach_time = Aws.Util.option_map (Aws.Json.lookup j "attachTime") DateTime.of_json
    ; attachment_id =
        Aws.Util.option_map (Aws.Json.lookup j "attachmentId") String.of_json
    ; delete_on_termination =
        Aws.Util.option_map (Aws.Json.lookup j "deleteOnTermination") Boolean.of_json
    ; device_index = Aws.Util.option_map (Aws.Json.lookup j "deviceIndex") Integer.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "status") AttachmentStatus.of_json
    ; network_card_index =
        Aws.Util.option_map (Aws.Json.lookup j "networkCardIndex") Integer.of_json
    }
end

module InstanceNetworkInterface = struct
  type t =
    { association : InstanceNetworkInterfaceAssociation.t option
    ; attachment : InstanceNetworkInterfaceAttachment.t option
    ; description : String.t option
    ; groups : GroupIdentifierList.t
    ; ipv6_addresses : InstanceIpv6AddressList.t
    ; mac_address : String.t option
    ; network_interface_id : String.t option
    ; owner_id : String.t option
    ; private_dns_name : String.t option
    ; private_ip_address : String.t option
    ; private_ip_addresses : InstancePrivateIpAddressList.t
    ; source_dest_check : Boolean.t option
    ; status : NetworkInterfaceStatus.t option
    ; subnet_id : String.t option
    ; vpc_id : String.t option
    ; interface_type : String.t option
    }

  let make
      ?association
      ?attachment
      ?description
      ?(groups = [])
      ?(ipv6_addresses = [])
      ?mac_address
      ?network_interface_id
      ?owner_id
      ?private_dns_name
      ?private_ip_address
      ?(private_ip_addresses = [])
      ?source_dest_check
      ?status
      ?subnet_id
      ?vpc_id
      ?interface_type
      () =
    { association
    ; attachment
    ; description
    ; groups
    ; ipv6_addresses
    ; mac_address
    ; network_interface_id
    ; owner_id
    ; private_dns_name
    ; private_ip_address
    ; private_ip_addresses
    ; source_dest_check
    ; status
    ; subnet_id
    ; vpc_id
    ; interface_type
    }

  let parse xml =
    Some
      { association =
          Aws.Util.option_bind
            (Aws.Xml.member "association" xml)
            InstanceNetworkInterfaceAssociation.parse
      ; attachment =
          Aws.Util.option_bind
            (Aws.Xml.member "attachment" xml)
            InstanceNetworkInterfaceAttachment.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "groupSet" xml)
               GroupIdentifierList.parse)
      ; ipv6_addresses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ipv6AddressesSet" xml)
               InstanceIpv6AddressList.parse)
      ; mac_address = Aws.Util.option_bind (Aws.Xml.member "macAddress" xml) String.parse
      ; network_interface_id =
          Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; private_dns_name =
          Aws.Util.option_bind (Aws.Xml.member "privateDnsName" xml) String.parse
      ; private_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "privateIpAddress" xml) String.parse
      ; private_ip_addresses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "privateIpAddressesSet" xml)
               InstancePrivateIpAddressList.parse)
      ; source_dest_check =
          Aws.Util.option_bind (Aws.Xml.member "sourceDestCheck" xml) Boolean.parse
      ; status =
          Aws.Util.option_bind (Aws.Xml.member "status" xml) NetworkInterfaceStatus.parse
      ; subnet_id = Aws.Util.option_bind (Aws.Xml.member "subnetId" xml) String.parse
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse
      ; interface_type =
          Aws.Util.option_bind (Aws.Xml.member "interfaceType" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.interface_type (fun f ->
               Aws.Query.Pair ("InterfaceType", String.to_query f))
         ; Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Aws.Util.option_map v.subnet_id (fun f ->
               Aws.Query.Pair ("SubnetId", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", NetworkInterfaceStatus.to_query f))
         ; Aws.Util.option_map v.source_dest_check (fun f ->
               Aws.Query.Pair ("SourceDestCheck", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "PrivateIpAddressesSet"
                , InstancePrivateIpAddressList.to_query v.private_ip_addresses ))
         ; Aws.Util.option_map v.private_ip_address (fun f ->
               Aws.Query.Pair ("PrivateIpAddress", String.to_query f))
         ; Aws.Util.option_map v.private_dns_name (fun f ->
               Aws.Query.Pair ("PrivateDnsName", String.to_query f))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               Aws.Query.Pair ("NetworkInterfaceId", String.to_query f))
         ; Aws.Util.option_map v.mac_address (fun f ->
               Aws.Query.Pair ("MacAddress", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Ipv6AddressesSet", InstanceIpv6AddressList.to_query v.ipv6_addresses))
         ; Some (Aws.Query.Pair ("GroupSet", GroupIdentifierList.to_query v.groups))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.attachment (fun f ->
               Aws.Query.Pair ("Attachment", InstanceNetworkInterfaceAttachment.to_query f))
         ; Aws.Util.option_map v.association (fun f ->
               Aws.Query.Pair
                 ("Association", InstanceNetworkInterfaceAssociation.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.interface_type (fun f ->
               "interfaceType", String.to_json f)
         ; Aws.Util.option_map v.vpc_id (fun f -> "vpcId", String.to_json f)
         ; Aws.Util.option_map v.subnet_id (fun f -> "subnetId", String.to_json f)
         ; Aws.Util.option_map v.status (fun f ->
               "status", NetworkInterfaceStatus.to_json f)
         ; Aws.Util.option_map v.source_dest_check (fun f ->
               "sourceDestCheck", Boolean.to_json f)
         ; Some
             ( "privateIpAddressesSet"
             , InstancePrivateIpAddressList.to_json v.private_ip_addresses )
         ; Aws.Util.option_map v.private_ip_address (fun f ->
               "privateIpAddress", String.to_json f)
         ; Aws.Util.option_map v.private_dns_name (fun f ->
               "privateDnsName", String.to_json f)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               "networkInterfaceId", String.to_json f)
         ; Aws.Util.option_map v.mac_address (fun f -> "macAddress", String.to_json f)
         ; Some ("ipv6AddressesSet", InstanceIpv6AddressList.to_json v.ipv6_addresses)
         ; Some ("groupSet", GroupIdentifierList.to_json v.groups)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Aws.Util.option_map v.attachment (fun f ->
               "attachment", InstanceNetworkInterfaceAttachment.to_json f)
         ; Aws.Util.option_map v.association (fun f ->
               "association", InstanceNetworkInterfaceAssociation.to_json f)
         ])

  let of_json j =
    { association =
        Aws.Util.option_map
          (Aws.Json.lookup j "association")
          InstanceNetworkInterfaceAssociation.of_json
    ; attachment =
        Aws.Util.option_map
          (Aws.Json.lookup j "attachment")
          InstanceNetworkInterfaceAttachment.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; groups =
        GroupIdentifierList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "groupSet"))
    ; ipv6_addresses =
        InstanceIpv6AddressList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ipv6AddressesSet"))
    ; mac_address = Aws.Util.option_map (Aws.Json.lookup j "macAddress") String.of_json
    ; network_interface_id =
        Aws.Util.option_map (Aws.Json.lookup j "networkInterfaceId") String.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; private_dns_name =
        Aws.Util.option_map (Aws.Json.lookup j "privateDnsName") String.of_json
    ; private_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "privateIpAddress") String.of_json
    ; private_ip_addresses =
        InstancePrivateIpAddressList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "privateIpAddressesSet"))
    ; source_dest_check =
        Aws.Util.option_map (Aws.Json.lookup j "sourceDestCheck") Boolean.of_json
    ; status =
        Aws.Util.option_map (Aws.Json.lookup j "status") NetworkInterfaceStatus.of_json
    ; subnet_id = Aws.Util.option_map (Aws.Json.lookup j "subnetId") String.of_json
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "vpcId") String.of_json
    ; interface_type =
        Aws.Util.option_map (Aws.Json.lookup j "interfaceType") String.of_json
    }
end

module VolumeIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "VolumeId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeVolumesRequest = struct
  type t =
    { filters : FilterList.t
    ; volume_ids : VolumeIdStringList.t
    ; dry_run : Boolean.t option
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?(filters = []) ?(volume_ids = []) ?dry_run ?max_results ?next_token () =
    { filters; volume_ids; dry_run; max_results; next_token }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; volume_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "VolumeId" xml)
               VolumeIdStringList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "maxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("VolumeId", VolumeIdStringList.to_query v.volume_ids))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "maxResults", Integer.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("VolumeId", VolumeIdStringList.to_json v.volume_ids)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; volume_ids =
        VolumeIdStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VolumeId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "maxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module InstanceHealthStatus = struct
  type t =
    | Healthy
    | Unhealthy

  let str_to_t = [ "unhealthy", Unhealthy; "healthy", Healthy ]

  let t_to_str = [ Unhealthy, "unhealthy"; Healthy, "healthy" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ActiveInstance = struct
  type t =
    { instance_id : String.t option
    ; instance_type : String.t option
    ; spot_instance_request_id : String.t option
    ; instance_health : InstanceHealthStatus.t option
    }

  let make ?instance_id ?instance_type ?spot_instance_request_id ?instance_health () =
    { instance_id; instance_type; spot_instance_request_id; instance_health }

  let parse xml =
    Some
      { instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) String.parse
      ; spot_instance_request_id =
          Aws.Util.option_bind (Aws.Xml.member "spotInstanceRequestId" xml) String.parse
      ; instance_health =
          Aws.Util.option_bind
            (Aws.Xml.member "instanceHealth" xml)
            InstanceHealthStatus.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_health (fun f ->
               Aws.Query.Pair ("InstanceHealth", InstanceHealthStatus.to_query f))
         ; Aws.Util.option_map v.spot_instance_request_id (fun f ->
               Aws.Query.Pair ("SpotInstanceRequestId", String.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", String.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_health (fun f ->
               "instanceHealth", InstanceHealthStatus.to_json f)
         ; Aws.Util.option_map v.spot_instance_request_id (fun f ->
               "spotInstanceRequestId", String.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f -> "instanceType", String.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ])

  let of_json j =
    { instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") String.of_json
    ; spot_instance_request_id =
        Aws.Util.option_map (Aws.Json.lookup j "spotInstanceRequestId") String.of_json
    ; instance_health =
        Aws.Util.option_map
          (Aws.Json.lookup j "instanceHealth")
          InstanceHealthStatus.of_json
    }
end

module ActiveInstanceSet = struct
  type t = ActiveInstance.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ActiveInstance.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ActiveInstance.to_query v

  let to_json v = `List (List.map ActiveInstance.to_json v)

  let of_json j = Aws.Json.to_list ActiveInstance.of_json j
end

module CreateVpcResult = struct
  type t = { vpc : Vpc.t option }

  let make ?vpc () = { vpc }

  let parse xml = Some { vpc = Aws.Util.option_bind (Aws.Xml.member "vpc" xml) Vpc.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc (fun f -> Aws.Query.Pair ("Vpc", Vpc.to_query f)) ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc (fun f -> "vpc", Vpc.to_json f) ])

  let of_json j = { vpc = Aws.Util.option_map (Aws.Json.lookup j "vpc") Vpc.of_json }
end

module DescribeIdentityIdFormatResult = struct
  type t = { statuses : IdFormatList.t }

  let make ?(statuses = []) () = { statuses }

  let parse xml =
    Some
      { statuses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "statusSet" xml) IdFormatList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("StatusSet", IdFormatList.to_query v.statuses)) ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt [ Some ("statusSet", IdFormatList.to_json v.statuses) ])

  let of_json j =
    { statuses =
        IdFormatList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "statusSet"))
    }
end

module LocalGatewayVirtualInterfaceGroupIdSet = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeLocalGatewayVirtualInterfaceGroupsRequest = struct
  type t =
    { local_gateway_virtual_interface_group_ids : LocalGatewayVirtualInterfaceGroupIdSet.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make
      ?(local_gateway_virtual_interface_group_ids = [])
      ?(filters = [])
      ?max_results
      ?next_token
      ?dry_run
      () =
    { local_gateway_virtual_interface_group_ids
    ; filters
    ; max_results
    ; next_token
    ; dry_run
    }

  let parse xml =
    Some
      { local_gateway_virtual_interface_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "LocalGatewayVirtualInterfaceGroupId" xml)
               LocalGatewayVirtualInterfaceGroupIdSet.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ( "LocalGatewayVirtualInterfaceGroupId"
                , LocalGatewayVirtualInterfaceGroupIdSet.to_query
                    v.local_gateway_virtual_interface_group_ids ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some
             ( "LocalGatewayVirtualInterfaceGroupId"
             , LocalGatewayVirtualInterfaceGroupIdSet.to_json
                 v.local_gateway_virtual_interface_group_ids )
         ])

  let of_json j =
    { local_gateway_virtual_interface_group_ids =
        LocalGatewayVirtualInterfaceGroupIdSet.of_json
          (Aws.Util.of_option_exn
             (Aws.Json.lookup j "LocalGatewayVirtualInterfaceGroupId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module TransitGatewayRouteTableState = struct
  type t =
    | Pending
    | Available
    | Deleting
    | Deleted

  let str_to_t =
    [ "deleted", Deleted
    ; "deleting", Deleting
    ; "available", Available
    ; "pending", Pending
    ]

  let t_to_str =
    [ Deleted, "deleted"
    ; Deleting, "deleting"
    ; Available, "available"
    ; Pending, "pending"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module TransitGatewayRouteTable = struct
  type t =
    { transit_gateway_route_table_id : String.t option
    ; transit_gateway_id : String.t option
    ; state : TransitGatewayRouteTableState.t option
    ; default_association_route_table : Boolean.t option
    ; default_propagation_route_table : Boolean.t option
    ; creation_time : DateTime.t option
    ; tags : TagList.t
    }

  let make
      ?transit_gateway_route_table_id
      ?transit_gateway_id
      ?state
      ?default_association_route_table
      ?default_propagation_route_table
      ?creation_time
      ?(tags = [])
      () =
    { transit_gateway_route_table_id
    ; transit_gateway_id
    ; state
    ; default_association_route_table
    ; default_propagation_route_table
    ; creation_time
    ; tags
    }

  let parse xml =
    Some
      { transit_gateway_route_table_id =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayRouteTableId" xml)
            String.parse
      ; transit_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "transitGatewayId" xml) String.parse
      ; state =
          Aws.Util.option_bind
            (Aws.Xml.member "state" xml)
            TransitGatewayRouteTableState.parse
      ; default_association_route_table =
          Aws.Util.option_bind
            (Aws.Xml.member "defaultAssociationRouteTable" xml)
            Boolean.parse
      ; default_propagation_route_table =
          Aws.Util.option_bind
            (Aws.Xml.member "defaultPropagationRouteTable" xml)
            Boolean.parse
      ; creation_time =
          Aws.Util.option_bind (Aws.Xml.member "creationTime" xml) DateTime.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.creation_time (fun f ->
               Aws.Query.Pair ("CreationTime", DateTime.to_query f))
         ; Aws.Util.option_map v.default_propagation_route_table (fun f ->
               Aws.Query.Pair ("DefaultPropagationRouteTable", Boolean.to_query f))
         ; Aws.Util.option_map v.default_association_route_table (fun f ->
               Aws.Query.Pair ("DefaultAssociationRouteTable", Boolean.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", TransitGatewayRouteTableState.to_query f))
         ; Aws.Util.option_map v.transit_gateway_id (fun f ->
               Aws.Query.Pair ("TransitGatewayId", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_route_table_id (fun f ->
               Aws.Query.Pair ("TransitGatewayRouteTableId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.creation_time (fun f ->
               "creationTime", DateTime.to_json f)
         ; Aws.Util.option_map v.default_propagation_route_table (fun f ->
               "defaultPropagationRouteTable", Boolean.to_json f)
         ; Aws.Util.option_map v.default_association_route_table (fun f ->
               "defaultAssociationRouteTable", Boolean.to_json f)
         ; Aws.Util.option_map v.state (fun f ->
               "state", TransitGatewayRouteTableState.to_json f)
         ; Aws.Util.option_map v.transit_gateway_id (fun f ->
               "transitGatewayId", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_route_table_id (fun f ->
               "transitGatewayRouteTableId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_route_table_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayRouteTableId")
          String.of_json
    ; transit_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "transitGatewayId") String.of_json
    ; state =
        Aws.Util.option_map
          (Aws.Json.lookup j "state")
          TransitGatewayRouteTableState.of_json
    ; default_association_route_table =
        Aws.Util.option_map
          (Aws.Json.lookup j "defaultAssociationRouteTable")
          Boolean.of_json
    ; default_propagation_route_table =
        Aws.Util.option_map
          (Aws.Json.lookup j "defaultPropagationRouteTable")
          Boolean.of_json
    ; creation_time =
        Aws.Util.option_map (Aws.Json.lookup j "creationTime") DateTime.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module ReservedInstancesConfigurationList = struct
  type t = ReservedInstancesConfiguration.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ReservedInstancesConfiguration.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ReservedInstancesConfiguration.to_query v

  let to_json v = `List (List.map ReservedInstancesConfiguration.to_json v)

  let of_json j = Aws.Json.to_list ReservedInstancesConfiguration.of_json j
end

module TrafficMirrorTargetType = struct
  type t =
    | Network_interface
    | Network_load_balancer

  let str_to_t =
    [ "network-load-balancer", Network_load_balancer
    ; "network-interface", Network_interface
    ]

  let t_to_str =
    [ Network_load_balancer, "network-load-balancer"
    ; Network_interface, "network-interface"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module TrafficMirrorTarget = struct
  type t =
    { traffic_mirror_target_id : String.t option
    ; network_interface_id : String.t option
    ; network_load_balancer_arn : String.t option
    ; type_ : TrafficMirrorTargetType.t option
    ; description : String.t option
    ; owner_id : String.t option
    ; tags : TagList.t
    }

  let make
      ?traffic_mirror_target_id
      ?network_interface_id
      ?network_load_balancer_arn
      ?type_
      ?description
      ?owner_id
      ?(tags = [])
      () =
    { traffic_mirror_target_id
    ; network_interface_id
    ; network_load_balancer_arn
    ; type_
    ; description
    ; owner_id
    ; tags
    }

  let parse xml =
    Some
      { traffic_mirror_target_id =
          Aws.Util.option_bind (Aws.Xml.member "trafficMirrorTargetId" xml) String.parse
      ; network_interface_id =
          Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse
      ; network_load_balancer_arn =
          Aws.Util.option_bind (Aws.Xml.member "networkLoadBalancerArn" xml) String.parse
      ; type_ =
          Aws.Util.option_bind (Aws.Xml.member "type" xml) TrafficMirrorTargetType.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", TrafficMirrorTargetType.to_query f))
         ; Aws.Util.option_map v.network_load_balancer_arn (fun f ->
               Aws.Query.Pair ("NetworkLoadBalancerArn", String.to_query f))
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               Aws.Query.Pair ("NetworkInterfaceId", String.to_query f))
         ; Aws.Util.option_map v.traffic_mirror_target_id (fun f ->
               Aws.Query.Pair ("TrafficMirrorTargetId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Aws.Util.option_map v.type_ (fun f ->
               "type", TrafficMirrorTargetType.to_json f)
         ; Aws.Util.option_map v.network_load_balancer_arn (fun f ->
               "networkLoadBalancerArn", String.to_json f)
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               "networkInterfaceId", String.to_json f)
         ; Aws.Util.option_map v.traffic_mirror_target_id (fun f ->
               "trafficMirrorTargetId", String.to_json f)
         ])

  let of_json j =
    { traffic_mirror_target_id =
        Aws.Util.option_map (Aws.Json.lookup j "trafficMirrorTargetId") String.of_json
    ; network_interface_id =
        Aws.Util.option_map (Aws.Json.lookup j "networkInterfaceId") String.of_json
    ; network_load_balancer_arn =
        Aws.Util.option_map (Aws.Json.lookup j "networkLoadBalancerArn") String.of_json
    ; type_ =
        Aws.Util.option_map (Aws.Json.lookup j "type") TrafficMirrorTargetType.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module TrafficMirrorTargetSet = struct
  type t = TrafficMirrorTarget.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map TrafficMirrorTarget.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list TrafficMirrorTarget.to_query v

  let to_json v = `List (List.map TrafficMirrorTarget.to_json v)

  let of_json j = Aws.Json.to_list TrafficMirrorTarget.of_json j
end

module TransitGatewayPrefixListReferenceState = struct
  type t =
    | Pending
    | Available
    | Modifying
    | Deleting

  let str_to_t =
    [ "deleting", Deleting
    ; "modifying", Modifying
    ; "available", Available
    ; "pending", Pending
    ]

  let t_to_str =
    [ Deleting, "deleting"
    ; Modifying, "modifying"
    ; Available, "available"
    ; Pending, "pending"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module TransitGatewayPrefixListAttachment = struct
  type t =
    { transit_gateway_attachment_id : String.t option
    ; resource_type : TransitGatewayAttachmentResourceType.t option
    ; resource_id : String.t option
    }

  let make ?transit_gateway_attachment_id ?resource_type ?resource_id () =
    { transit_gateway_attachment_id; resource_type; resource_id }

  let parse xml =
    Some
      { transit_gateway_attachment_id =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayAttachmentId" xml)
            String.parse
      ; resource_type =
          Aws.Util.option_bind
            (Aws.Xml.member "resourceType" xml)
            TransitGatewayAttachmentResourceType.parse
      ; resource_id = Aws.Util.option_bind (Aws.Xml.member "resourceId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.resource_id (fun f ->
               Aws.Query.Pair ("ResourceId", String.to_query f))
         ; Aws.Util.option_map v.resource_type (fun f ->
               Aws.Query.Pair
                 ("ResourceType", TransitGatewayAttachmentResourceType.to_query f))
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               Aws.Query.Pair ("TransitGatewayAttachmentId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.resource_id (fun f -> "resourceId", String.to_json f)
         ; Aws.Util.option_map v.resource_type (fun f ->
               "resourceType", TransitGatewayAttachmentResourceType.to_json f)
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               "transitGatewayAttachmentId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_attachment_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayAttachmentId")
          String.of_json
    ; resource_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "resourceType")
          TransitGatewayAttachmentResourceType.of_json
    ; resource_id = Aws.Util.option_map (Aws.Json.lookup j "resourceId") String.of_json
    }
end

module TransitGatewayPrefixListReference = struct
  type t =
    { transit_gateway_route_table_id : String.t option
    ; prefix_list_id : String.t option
    ; prefix_list_owner_id : String.t option
    ; state : TransitGatewayPrefixListReferenceState.t option
    ; blackhole : Boolean.t option
    ; transit_gateway_attachment : TransitGatewayPrefixListAttachment.t option
    }

  let make
      ?transit_gateway_route_table_id
      ?prefix_list_id
      ?prefix_list_owner_id
      ?state
      ?blackhole
      ?transit_gateway_attachment
      () =
    { transit_gateway_route_table_id
    ; prefix_list_id
    ; prefix_list_owner_id
    ; state
    ; blackhole
    ; transit_gateway_attachment
    }

  let parse xml =
    Some
      { transit_gateway_route_table_id =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayRouteTableId" xml)
            String.parse
      ; prefix_list_id =
          Aws.Util.option_bind (Aws.Xml.member "prefixListId" xml) String.parse
      ; prefix_list_owner_id =
          Aws.Util.option_bind (Aws.Xml.member "prefixListOwnerId" xml) String.parse
      ; state =
          Aws.Util.option_bind
            (Aws.Xml.member "state" xml)
            TransitGatewayPrefixListReferenceState.parse
      ; blackhole = Aws.Util.option_bind (Aws.Xml.member "blackhole" xml) Boolean.parse
      ; transit_gateway_attachment =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayAttachment" xml)
            TransitGatewayPrefixListAttachment.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_attachment (fun f ->
               Aws.Query.Pair
                 ( "TransitGatewayAttachment"
                 , TransitGatewayPrefixListAttachment.to_query f ))
         ; Aws.Util.option_map v.blackhole (fun f ->
               Aws.Query.Pair ("Blackhole", Boolean.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", TransitGatewayPrefixListReferenceState.to_query f))
         ; Aws.Util.option_map v.prefix_list_owner_id (fun f ->
               Aws.Query.Pair ("PrefixListOwnerId", String.to_query f))
         ; Aws.Util.option_map v.prefix_list_id (fun f ->
               Aws.Query.Pair ("PrefixListId", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_route_table_id (fun f ->
               Aws.Query.Pair ("TransitGatewayRouteTableId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_attachment (fun f ->
               "transitGatewayAttachment", TransitGatewayPrefixListAttachment.to_json f)
         ; Aws.Util.option_map v.blackhole (fun f -> "blackhole", Boolean.to_json f)
         ; Aws.Util.option_map v.state (fun f ->
               "state", TransitGatewayPrefixListReferenceState.to_json f)
         ; Aws.Util.option_map v.prefix_list_owner_id (fun f ->
               "prefixListOwnerId", String.to_json f)
         ; Aws.Util.option_map v.prefix_list_id (fun f ->
               "prefixListId", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_route_table_id (fun f ->
               "transitGatewayRouteTableId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_route_table_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayRouteTableId")
          String.of_json
    ; prefix_list_id =
        Aws.Util.option_map (Aws.Json.lookup j "prefixListId") String.of_json
    ; prefix_list_owner_id =
        Aws.Util.option_map (Aws.Json.lookup j "prefixListOwnerId") String.of_json
    ; state =
        Aws.Util.option_map
          (Aws.Json.lookup j "state")
          TransitGatewayPrefixListReferenceState.of_json
    ; blackhole = Aws.Util.option_map (Aws.Json.lookup j "blackhole") Boolean.of_json
    ; transit_gateway_attachment =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayAttachment")
          TransitGatewayPrefixListAttachment.of_json
    }
end

module DeleteTransitGatewayPrefixListReferenceResult = struct
  type t =
    { transit_gateway_prefix_list_reference : TransitGatewayPrefixListReference.t option }

  let make ?transit_gateway_prefix_list_reference () =
    { transit_gateway_prefix_list_reference }

  let parse xml =
    Some
      { transit_gateway_prefix_list_reference =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayPrefixListReference" xml)
            TransitGatewayPrefixListReference.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_prefix_list_reference (fun f ->
               Aws.Query.Pair
                 ( "TransitGatewayPrefixListReference"
                 , TransitGatewayPrefixListReference.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_prefix_list_reference (fun f ->
               ( "transitGatewayPrefixListReference"
               , TransitGatewayPrefixListReference.to_json f ))
         ])

  let of_json j =
    { transit_gateway_prefix_list_reference =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayPrefixListReference")
          TransitGatewayPrefixListReference.of_json
    }
end

module FleetIdSet = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DeleteFleetsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; fleet_ids : FleetIdSet.t
    ; terminate_instances : Boolean.t
    }

  let make ?dry_run ~fleet_ids ~terminate_instances () =
    { dry_run; fleet_ids; terminate_instances }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; fleet_ids =
          Aws.Xml.required
            "FleetId"
            (Aws.Util.option_bind (Aws.Xml.member "FleetId" xml) FleetIdSet.parse)
      ; terminate_instances =
          Aws.Xml.required
            "TerminateInstances"
            (Aws.Util.option_bind (Aws.Xml.member "TerminateInstances" xml) Boolean.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("TerminateInstances", Boolean.to_query v.terminate_instances))
         ; Some (Aws.Query.Pair ("FleetId", FleetIdSet.to_query v.fleet_ids))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TerminateInstances", Boolean.to_json v.terminate_instances)
         ; Some ("FleetId", FleetIdSet.to_json v.fleet_ids)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; fleet_ids =
        FleetIdSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "FleetId"))
    ; terminate_instances =
        Boolean.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TerminateInstances"))
    }
end

module FleetSpotCapacityRebalanceRequest = struct
  type t = { replacement_strategy : FleetReplacementStrategy.t option }

  let make ?replacement_strategy () = { replacement_strategy }

  let parse xml =
    Some
      { replacement_strategy =
          Aws.Util.option_bind
            (Aws.Xml.member "ReplacementStrategy" xml)
            FleetReplacementStrategy.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.replacement_strategy (fun f ->
               Aws.Query.Pair ("ReplacementStrategy", FleetReplacementStrategy.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.replacement_strategy (fun f ->
               "ReplacementStrategy", FleetReplacementStrategy.to_json f)
         ])

  let of_json j =
    { replacement_strategy =
        Aws.Util.option_map
          (Aws.Json.lookup j "ReplacementStrategy")
          FleetReplacementStrategy.of_json
    }
end

module FleetSpotMaintenanceStrategiesRequest = struct
  type t = { capacity_rebalance : FleetSpotCapacityRebalanceRequest.t option }

  let make ?capacity_rebalance () = { capacity_rebalance }

  let parse xml =
    Some
      { capacity_rebalance =
          Aws.Util.option_bind
            (Aws.Xml.member "CapacityRebalance" xml)
            FleetSpotCapacityRebalanceRequest.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.capacity_rebalance (fun f ->
               Aws.Query.Pair
                 ("CapacityRebalance", FleetSpotCapacityRebalanceRequest.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.capacity_rebalance (fun f ->
               "CapacityRebalance", FleetSpotCapacityRebalanceRequest.to_json f)
         ])

  let of_json j =
    { capacity_rebalance =
        Aws.Util.option_map
          (Aws.Json.lookup j "CapacityRebalance")
          FleetSpotCapacityRebalanceRequest.of_json
    }
end

module TransitGatewayRouteTableList = struct
  type t = TransitGatewayRouteTable.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map TransitGatewayRouteTable.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list TransitGatewayRouteTable.to_query v

  let to_json v = `List (List.map TransitGatewayRouteTable.to_json v)

  let of_json j = Aws.Json.to_list TransitGatewayRouteTable.of_json j
end

module LaunchTemplateIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DeleteClientVpnRouteResult = struct
  type t = { status : ClientVpnRouteStatus.t option }

  let make ?status () = { status }

  let parse xml =
    Some
      { status =
          Aws.Util.option_bind (Aws.Xml.member "status" xml) ClientVpnRouteStatus.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", ClientVpnRouteStatus.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               "status", ClientVpnRouteStatus.to_json f)
         ])

  let of_json j =
    { status =
        Aws.Util.option_map (Aws.Json.lookup j "status") ClientVpnRouteStatus.of_json
    }
end

module VirtualizationType = struct
  type t =
    | Hvm
    | Paravirtual

  let str_to_t = [ "paravirtual", Paravirtual; "hvm", Hvm ]

  let t_to_str = [ Paravirtual, "paravirtual"; Hvm, "hvm" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module StateReason = struct
  type t =
    { code : String.t option
    ; message : String.t option
    }

  let make ?code ?message () = { code; message }

  let parse xml =
    Some
      { code = Aws.Util.option_bind (Aws.Xml.member "code" xml) String.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair ("Code", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f)
         ; Aws.Util.option_map v.code (fun f -> "code", String.to_json f)
         ])

  let of_json j =
    { code = Aws.Util.option_map (Aws.Json.lookup j "code") String.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json
    }
end

module LicenseConfiguration = struct
  type t = { license_configuration_arn : String.t option }

  let make ?license_configuration_arn () = { license_configuration_arn }

  let parse xml =
    Some
      { license_configuration_arn =
          Aws.Util.option_bind (Aws.Xml.member "licenseConfigurationArn" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.license_configuration_arn (fun f ->
               Aws.Query.Pair ("LicenseConfigurationArn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.license_configuration_arn (fun f ->
               "licenseConfigurationArn", String.to_json f)
         ])

  let of_json j =
    { license_configuration_arn =
        Aws.Util.option_map (Aws.Json.lookup j "licenseConfigurationArn") String.of_json
    }
end

module LicenseList = struct
  type t = LicenseConfiguration.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map LicenseConfiguration.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list LicenseConfiguration.to_query v

  let to_json v = `List (List.map LicenseConfiguration.to_json v)

  let of_json j = Aws.Json.to_list LicenseConfiguration.of_json j
end

module InstanceStateName = struct
  type t =
    | Pending
    | Running
    | Shutting_down
    | Terminated
    | Stopping
    | Stopped

  let str_to_t =
    [ "stopped", Stopped
    ; "stopping", Stopping
    ; "terminated", Terminated
    ; "shutting-down", Shutting_down
    ; "running", Running
    ; "pending", Pending
    ]

  let t_to_str =
    [ Stopped, "stopped"
    ; Stopping, "stopping"
    ; Terminated, "terminated"
    ; Shutting_down, "shutting-down"
    ; Running, "running"
    ; Pending, "pending"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module InstanceState = struct
  type t =
    { code : Integer.t
    ; name : InstanceStateName.t
    }

  let make ~code ~name () = { code; name }

  let parse xml =
    Some
      { code =
          Aws.Xml.required
            "code"
            (Aws.Util.option_bind (Aws.Xml.member "code" xml) Integer.parse)
      ; name =
          Aws.Xml.required
            "name"
            (Aws.Util.option_bind (Aws.Xml.member "name" xml) InstanceStateName.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Name", InstanceStateName.to_query v.name))
         ; Some (Aws.Query.Pair ("Code", Integer.to_query v.code))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("name", InstanceStateName.to_json v.name)
         ; Some ("code", Integer.to_json v.code)
         ])

  let of_json j =
    { code = Integer.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "code"))
    ; name = InstanceStateName.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "name"))
    }
end

module InstanceNetworkInterfaceList = struct
  type t = InstanceNetworkInterface.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map InstanceNetworkInterface.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list InstanceNetworkInterface.to_query v

  let to_json v = `List (List.map InstanceNetworkInterface.to_json v)

  let of_json j = Aws.Json.to_list InstanceNetworkInterface.of_json j
end

module InstanceMetadataOptionsState = struct
  type t =
    | Pending
    | Applied

  let str_to_t = [ "applied", Applied; "pending", Pending ]

  let t_to_str = [ Applied, "applied"; Pending, "pending" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module InstanceMetadataEndpointState = struct
  type t =
    | Disabled
    | Enabled

  let str_to_t = [ "enabled", Enabled; "disabled", Disabled ]

  let t_to_str = [ Enabled, "enabled"; Disabled, "disabled" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module HttpTokensState = struct
  type t =
    | Optional
    | Required

  let str_to_t = [ "required", Required; "optional", Optional ]

  let t_to_str = [ Required, "required"; Optional, "optional" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module InstanceMetadataOptionsResponse = struct
  type t =
    { state : InstanceMetadataOptionsState.t option
    ; http_tokens : HttpTokensState.t option
    ; http_put_response_hop_limit : Integer.t option
    ; http_endpoint : InstanceMetadataEndpointState.t option
    }

  let make ?state ?http_tokens ?http_put_response_hop_limit ?http_endpoint () =
    { state; http_tokens; http_put_response_hop_limit; http_endpoint }

  let parse xml =
    Some
      { state =
          Aws.Util.option_bind
            (Aws.Xml.member "state" xml)
            InstanceMetadataOptionsState.parse
      ; http_tokens =
          Aws.Util.option_bind (Aws.Xml.member "httpTokens" xml) HttpTokensState.parse
      ; http_put_response_hop_limit =
          Aws.Util.option_bind
            (Aws.Xml.member "httpPutResponseHopLimit" xml)
            Integer.parse
      ; http_endpoint =
          Aws.Util.option_bind
            (Aws.Xml.member "httpEndpoint" xml)
            InstanceMetadataEndpointState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.http_endpoint (fun f ->
               Aws.Query.Pair ("HttpEndpoint", InstanceMetadataEndpointState.to_query f))
         ; Aws.Util.option_map v.http_put_response_hop_limit (fun f ->
               Aws.Query.Pair ("HttpPutResponseHopLimit", Integer.to_query f))
         ; Aws.Util.option_map v.http_tokens (fun f ->
               Aws.Query.Pair ("HttpTokens", HttpTokensState.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", InstanceMetadataOptionsState.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.http_endpoint (fun f ->
               "httpEndpoint", InstanceMetadataEndpointState.to_json f)
         ; Aws.Util.option_map v.http_put_response_hop_limit (fun f ->
               "httpPutResponseHopLimit", Integer.to_json f)
         ; Aws.Util.option_map v.http_tokens (fun f ->
               "httpTokens", HttpTokensState.to_json f)
         ; Aws.Util.option_map v.state (fun f ->
               "state", InstanceMetadataOptionsState.to_json f)
         ])

  let of_json j =
    { state =
        Aws.Util.option_map
          (Aws.Json.lookup j "state")
          InstanceMetadataOptionsState.of_json
    ; http_tokens =
        Aws.Util.option_map (Aws.Json.lookup j "httpTokens") HttpTokensState.of_json
    ; http_put_response_hop_limit =
        Aws.Util.option_map (Aws.Json.lookup j "httpPutResponseHopLimit") Integer.of_json
    ; http_endpoint =
        Aws.Util.option_map
          (Aws.Json.lookup j "httpEndpoint")
          InstanceMetadataEndpointState.of_json
    }
end

module InstanceLifecycleType = struct
  type t =
    | Spot
    | Scheduled

  let str_to_t = [ "scheduled", Scheduled; "spot", Spot ]

  let t_to_str = [ Scheduled, "scheduled"; Spot, "spot" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module IamInstanceProfile = struct
  type t =
    { arn : String.t option
    ; id : String.t option
    }

  let make ?arn ?id () = { arn; id }

  let parse xml =
    Some
      { arn = Aws.Util.option_bind (Aws.Xml.member "arn" xml) String.parse
      ; id = Aws.Util.option_bind (Aws.Xml.member "id" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.id (fun f -> Aws.Query.Pair ("Id", String.to_query f))
         ; Aws.Util.option_map v.arn (fun f -> Aws.Query.Pair ("Arn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.id (fun f -> "id", String.to_json f)
         ; Aws.Util.option_map v.arn (fun f -> "arn", String.to_json f)
         ])

  let of_json j =
    { arn = Aws.Util.option_map (Aws.Json.lookup j "arn") String.of_json
    ; id = Aws.Util.option_map (Aws.Json.lookup j "id") String.of_json
    }
end

module HypervisorType = struct
  type t =
    | Ovm
    | Xen

  let str_to_t = [ "xen", Xen; "ovm", Ovm ]

  let t_to_str = [ Xen, "xen"; Ovm, "ovm" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module EnclaveOptions = struct
  type t = { enabled : Boolean.t option }

  let make ?enabled () = { enabled }

  let parse xml =
    Some { enabled = Aws.Util.option_bind (Aws.Xml.member "enabled" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enabled (fun f ->
               Aws.Query.Pair ("Enabled", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enabled (fun f -> "enabled", Boolean.to_json f) ])

  let of_json j =
    { enabled = Aws.Util.option_map (Aws.Json.lookup j "enabled") Boolean.of_json }
end

module ElasticInferenceAcceleratorAssociationList = struct
  type t = ElasticInferenceAcceleratorAssociation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ElasticInferenceAcceleratorAssociation.parse (Aws.Xml.members "item" xml))

  let to_query v =
    Aws.Query.to_query_list ElasticInferenceAcceleratorAssociation.to_query v

  let to_json v = `List (List.map ElasticInferenceAcceleratorAssociation.to_json v)

  let of_json j = Aws.Json.to_list ElasticInferenceAcceleratorAssociation.of_json j
end

module ElasticGpuAssociation = struct
  type t =
    { elastic_gpu_id : String.t option
    ; elastic_gpu_association_id : String.t option
    ; elastic_gpu_association_state : String.t option
    ; elastic_gpu_association_time : String.t option
    }

  let make
      ?elastic_gpu_id
      ?elastic_gpu_association_id
      ?elastic_gpu_association_state
      ?elastic_gpu_association_time
      () =
    { elastic_gpu_id
    ; elastic_gpu_association_id
    ; elastic_gpu_association_state
    ; elastic_gpu_association_time
    }

  let parse xml =
    Some
      { elastic_gpu_id =
          Aws.Util.option_bind (Aws.Xml.member "elasticGpuId" xml) String.parse
      ; elastic_gpu_association_id =
          Aws.Util.option_bind (Aws.Xml.member "elasticGpuAssociationId" xml) String.parse
      ; elastic_gpu_association_state =
          Aws.Util.option_bind
            (Aws.Xml.member "elasticGpuAssociationState" xml)
            String.parse
      ; elastic_gpu_association_time =
          Aws.Util.option_bind
            (Aws.Xml.member "elasticGpuAssociationTime" xml)
            String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.elastic_gpu_association_time (fun f ->
               Aws.Query.Pair ("ElasticGpuAssociationTime", String.to_query f))
         ; Aws.Util.option_map v.elastic_gpu_association_state (fun f ->
               Aws.Query.Pair ("ElasticGpuAssociationState", String.to_query f))
         ; Aws.Util.option_map v.elastic_gpu_association_id (fun f ->
               Aws.Query.Pair ("ElasticGpuAssociationId", String.to_query f))
         ; Aws.Util.option_map v.elastic_gpu_id (fun f ->
               Aws.Query.Pair ("ElasticGpuId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.elastic_gpu_association_time (fun f ->
               "elasticGpuAssociationTime", String.to_json f)
         ; Aws.Util.option_map v.elastic_gpu_association_state (fun f ->
               "elasticGpuAssociationState", String.to_json f)
         ; Aws.Util.option_map v.elastic_gpu_association_id (fun f ->
               "elasticGpuAssociationId", String.to_json f)
         ; Aws.Util.option_map v.elastic_gpu_id (fun f ->
               "elasticGpuId", String.to_json f)
         ])

  let of_json j =
    { elastic_gpu_id =
        Aws.Util.option_map (Aws.Json.lookup j "elasticGpuId") String.of_json
    ; elastic_gpu_association_id =
        Aws.Util.option_map (Aws.Json.lookup j "elasticGpuAssociationId") String.of_json
    ; elastic_gpu_association_state =
        Aws.Util.option_map
          (Aws.Json.lookup j "elasticGpuAssociationState")
          String.of_json
    ; elastic_gpu_association_time =
        Aws.Util.option_map (Aws.Json.lookup j "elasticGpuAssociationTime") String.of_json
    }
end

module ElasticGpuAssociationList = struct
  type t = ElasticGpuAssociation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ElasticGpuAssociation.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ElasticGpuAssociation.to_query v

  let to_json v = `List (List.map ElasticGpuAssociation.to_json v)

  let of_json j = Aws.Json.to_list ElasticGpuAssociation.of_json j
end

module DeviceType = struct
  type t =
    | Ebs
    | Instance_store

  let str_to_t = [ "instance-store", Instance_store; "ebs", Ebs ]

  let t_to_str = [ Instance_store, "instance-store"; Ebs, "ebs" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module CpuOptions = struct
  type t =
    { core_count : Integer.t option
    ; threads_per_core : Integer.t option
    }

  let make ?core_count ?threads_per_core () = { core_count; threads_per_core }

  let parse xml =
    Some
      { core_count = Aws.Util.option_bind (Aws.Xml.member "coreCount" xml) Integer.parse
      ; threads_per_core =
          Aws.Util.option_bind (Aws.Xml.member "threadsPerCore" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.threads_per_core (fun f ->
               Aws.Query.Pair ("ThreadsPerCore", Integer.to_query f))
         ; Aws.Util.option_map v.core_count (fun f ->
               Aws.Query.Pair ("CoreCount", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.threads_per_core (fun f ->
               "threadsPerCore", Integer.to_json f)
         ; Aws.Util.option_map v.core_count (fun f -> "coreCount", Integer.to_json f)
         ])

  let of_json j =
    { core_count = Aws.Util.option_map (Aws.Json.lookup j "coreCount") Integer.of_json
    ; threads_per_core =
        Aws.Util.option_map (Aws.Json.lookup j "threadsPerCore") Integer.of_json
    }
end

module CapacityReservationSpecificationResponse = struct
  type t =
    { capacity_reservation_preference : CapacityReservationPreference.t option
    ; capacity_reservation_target : CapacityReservationTargetResponse.t option
    }

  let make ?capacity_reservation_preference ?capacity_reservation_target () =
    { capacity_reservation_preference; capacity_reservation_target }

  let parse xml =
    Some
      { capacity_reservation_preference =
          Aws.Util.option_bind
            (Aws.Xml.member "capacityReservationPreference" xml)
            CapacityReservationPreference.parse
      ; capacity_reservation_target =
          Aws.Util.option_bind
            (Aws.Xml.member "capacityReservationTarget" xml)
            CapacityReservationTargetResponse.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.capacity_reservation_target (fun f ->
               Aws.Query.Pair
                 ( "CapacityReservationTarget"
                 , CapacityReservationTargetResponse.to_query f ))
         ; Aws.Util.option_map v.capacity_reservation_preference (fun f ->
               Aws.Query.Pair
                 ( "CapacityReservationPreference"
                 , CapacityReservationPreference.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.capacity_reservation_target (fun f ->
               "capacityReservationTarget", CapacityReservationTargetResponse.to_json f)
         ; Aws.Util.option_map v.capacity_reservation_preference (fun f ->
               "capacityReservationPreference", CapacityReservationPreference.to_json f)
         ])

  let of_json j =
    { capacity_reservation_preference =
        Aws.Util.option_map
          (Aws.Json.lookup j "capacityReservationPreference")
          CapacityReservationPreference.of_json
    ; capacity_reservation_target =
        Aws.Util.option_map
          (Aws.Json.lookup j "capacityReservationTarget")
          CapacityReservationTargetResponse.of_json
    }
end

module Instance = struct
  type t =
    { ami_launch_index : Integer.t
    ; image_id : String.t
    ; instance_id : String.t
    ; instance_type : InstanceType.t
    ; kernel_id : String.t option
    ; key_name : String.t option
    ; launch_time : DateTime.t
    ; monitoring : Monitoring.t
    ; placement : Placement.t
    ; platform : PlatformValues.t option
    ; private_dns_name : String.t option
    ; private_ip_address : String.t option
    ; product_codes : ProductCodeList.t
    ; public_dns_name : String.t option
    ; public_ip_address : String.t option
    ; ramdisk_id : String.t option
    ; state : InstanceState.t
    ; state_transition_reason : String.t option
    ; subnet_id : String.t option
    ; vpc_id : String.t option
    ; architecture : ArchitectureValues.t
    ; block_device_mappings : InstanceBlockDeviceMappingList.t
    ; client_token : String.t option
    ; ebs_optimized : Boolean.t option
    ; ena_support : Boolean.t option
    ; hypervisor : HypervisorType.t
    ; iam_instance_profile : IamInstanceProfile.t option
    ; instance_lifecycle : InstanceLifecycleType.t option
    ; elastic_gpu_associations : ElasticGpuAssociationList.t
    ; elastic_inference_accelerator_associations :
        ElasticInferenceAcceleratorAssociationList.t
    ; network_interfaces : InstanceNetworkInterfaceList.t
    ; outpost_arn : String.t option
    ; root_device_name : String.t option
    ; root_device_type : DeviceType.t
    ; security_groups : GroupIdentifierList.t
    ; source_dest_check : Boolean.t option
    ; spot_instance_request_id : String.t option
    ; sriov_net_support : String.t option
    ; state_reason : StateReason.t option
    ; tags : TagList.t
    ; virtualization_type : VirtualizationType.t
    ; cpu_options : CpuOptions.t option
    ; capacity_reservation_id : String.t option
    ; capacity_reservation_specification :
        CapacityReservationSpecificationResponse.t option
    ; hibernation_options : HibernationOptions.t option
    ; licenses : LicenseList.t
    ; metadata_options : InstanceMetadataOptionsResponse.t option
    ; enclave_options : EnclaveOptions.t option
    }

  let make
      ~ami_launch_index
      ~image_id
      ~instance_id
      ~instance_type
      ?kernel_id
      ?key_name
      ~launch_time
      ~monitoring
      ~placement
      ?platform
      ?private_dns_name
      ?private_ip_address
      ?(product_codes = [])
      ?public_dns_name
      ?public_ip_address
      ?ramdisk_id
      ~state
      ?state_transition_reason
      ?subnet_id
      ?vpc_id
      ~architecture
      ?(block_device_mappings = [])
      ?client_token
      ?ebs_optimized
      ?ena_support
      ~hypervisor
      ?iam_instance_profile
      ?instance_lifecycle
      ?(elastic_gpu_associations = [])
      ?(elastic_inference_accelerator_associations = [])
      ?(network_interfaces = [])
      ?outpost_arn
      ?root_device_name
      ~root_device_type
      ?(security_groups = [])
      ?source_dest_check
      ?spot_instance_request_id
      ?sriov_net_support
      ?state_reason
      ?(tags = [])
      ~virtualization_type
      ?cpu_options
      ?capacity_reservation_id
      ?capacity_reservation_specification
      ?hibernation_options
      ?(licenses = [])
      ?metadata_options
      ?enclave_options
      () =
    { ami_launch_index
    ; image_id
    ; instance_id
    ; instance_type
    ; kernel_id
    ; key_name
    ; launch_time
    ; monitoring
    ; placement
    ; platform
    ; private_dns_name
    ; private_ip_address
    ; product_codes
    ; public_dns_name
    ; public_ip_address
    ; ramdisk_id
    ; state
    ; state_transition_reason
    ; subnet_id
    ; vpc_id
    ; architecture
    ; block_device_mappings
    ; client_token
    ; ebs_optimized
    ; ena_support
    ; hypervisor
    ; iam_instance_profile
    ; instance_lifecycle
    ; elastic_gpu_associations
    ; elastic_inference_accelerator_associations
    ; network_interfaces
    ; outpost_arn
    ; root_device_name
    ; root_device_type
    ; security_groups
    ; source_dest_check
    ; spot_instance_request_id
    ; sriov_net_support
    ; state_reason
    ; tags
    ; virtualization_type
    ; cpu_options
    ; capacity_reservation_id
    ; capacity_reservation_specification
    ; hibernation_options
    ; licenses
    ; metadata_options
    ; enclave_options
    }

  let parse xml =
    Some
      { ami_launch_index =
          Aws.Xml.required
            "amiLaunchIndex"
            (Aws.Util.option_bind (Aws.Xml.member "amiLaunchIndex" xml) Integer.parse)
      ; image_id =
          Aws.Xml.required
            "imageId"
            (Aws.Util.option_bind (Aws.Xml.member "imageId" xml) String.parse)
      ; instance_id =
          Aws.Xml.required
            "instanceId"
            (Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse)
      ; instance_type =
          Aws.Xml.required
            "instanceType"
            (Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) InstanceType.parse)
      ; kernel_id = Aws.Util.option_bind (Aws.Xml.member "kernelId" xml) String.parse
      ; key_name = Aws.Util.option_bind (Aws.Xml.member "keyName" xml) String.parse
      ; launch_time =
          Aws.Xml.required
            "launchTime"
            (Aws.Util.option_bind (Aws.Xml.member "launchTime" xml) DateTime.parse)
      ; monitoring =
          Aws.Xml.required
            "monitoring"
            (Aws.Util.option_bind (Aws.Xml.member "monitoring" xml) Monitoring.parse)
      ; placement =
          Aws.Xml.required
            "placement"
            (Aws.Util.option_bind (Aws.Xml.member "placement" xml) Placement.parse)
      ; platform =
          Aws.Util.option_bind (Aws.Xml.member "platform" xml) PlatformValues.parse
      ; private_dns_name =
          Aws.Util.option_bind (Aws.Xml.member "privateDnsName" xml) String.parse
      ; private_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "privateIpAddress" xml) String.parse
      ; product_codes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "productCodes" xml)
               ProductCodeList.parse)
      ; public_dns_name = Aws.Util.option_bind (Aws.Xml.member "dnsName" xml) String.parse
      ; public_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "ipAddress" xml) String.parse
      ; ramdisk_id = Aws.Util.option_bind (Aws.Xml.member "ramdiskId" xml) String.parse
      ; state =
          Aws.Xml.required
            "instanceState"
            (Aws.Util.option_bind
               (Aws.Xml.member "instanceState" xml)
               InstanceState.parse)
      ; state_transition_reason =
          Aws.Util.option_bind (Aws.Xml.member "reason" xml) String.parse
      ; subnet_id = Aws.Util.option_bind (Aws.Xml.member "subnetId" xml) String.parse
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse
      ; architecture =
          Aws.Xml.required
            "architecture"
            (Aws.Util.option_bind
               (Aws.Xml.member "architecture" xml)
               ArchitectureValues.parse)
      ; block_device_mappings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "blockDeviceMapping" xml)
               InstanceBlockDeviceMappingList.parse)
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "clientToken" xml) String.parse
      ; ebs_optimized =
          Aws.Util.option_bind (Aws.Xml.member "ebsOptimized" xml) Boolean.parse
      ; ena_support = Aws.Util.option_bind (Aws.Xml.member "enaSupport" xml) Boolean.parse
      ; hypervisor =
          Aws.Xml.required
            "hypervisor"
            (Aws.Util.option_bind (Aws.Xml.member "hypervisor" xml) HypervisorType.parse)
      ; iam_instance_profile =
          Aws.Util.option_bind
            (Aws.Xml.member "iamInstanceProfile" xml)
            IamInstanceProfile.parse
      ; instance_lifecycle =
          Aws.Util.option_bind
            (Aws.Xml.member "instanceLifecycle" xml)
            InstanceLifecycleType.parse
      ; elastic_gpu_associations =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "elasticGpuAssociationSet" xml)
               ElasticGpuAssociationList.parse)
      ; elastic_inference_accelerator_associations =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "elasticInferenceAcceleratorAssociationSet" xml)
               ElasticInferenceAcceleratorAssociationList.parse)
      ; network_interfaces =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "networkInterfaceSet" xml)
               InstanceNetworkInterfaceList.parse)
      ; outpost_arn = Aws.Util.option_bind (Aws.Xml.member "outpostArn" xml) String.parse
      ; root_device_name =
          Aws.Util.option_bind (Aws.Xml.member "rootDeviceName" xml) String.parse
      ; root_device_type =
          Aws.Xml.required
            "rootDeviceType"
            (Aws.Util.option_bind (Aws.Xml.member "rootDeviceType" xml) DeviceType.parse)
      ; security_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "groupSet" xml)
               GroupIdentifierList.parse)
      ; source_dest_check =
          Aws.Util.option_bind (Aws.Xml.member "sourceDestCheck" xml) Boolean.parse
      ; spot_instance_request_id =
          Aws.Util.option_bind (Aws.Xml.member "spotInstanceRequestId" xml) String.parse
      ; sriov_net_support =
          Aws.Util.option_bind (Aws.Xml.member "sriovNetSupport" xml) String.parse
      ; state_reason =
          Aws.Util.option_bind (Aws.Xml.member "stateReason" xml) StateReason.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      ; virtualization_type =
          Aws.Xml.required
            "virtualizationType"
            (Aws.Util.option_bind
               (Aws.Xml.member "virtualizationType" xml)
               VirtualizationType.parse)
      ; cpu_options =
          Aws.Util.option_bind (Aws.Xml.member "cpuOptions" xml) CpuOptions.parse
      ; capacity_reservation_id =
          Aws.Util.option_bind (Aws.Xml.member "capacityReservationId" xml) String.parse
      ; capacity_reservation_specification =
          Aws.Util.option_bind
            (Aws.Xml.member "capacityReservationSpecification" xml)
            CapacityReservationSpecificationResponse.parse
      ; hibernation_options =
          Aws.Util.option_bind
            (Aws.Xml.member "hibernationOptions" xml)
            HibernationOptions.parse
      ; licenses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "licenseSet" xml) LicenseList.parse)
      ; metadata_options =
          Aws.Util.option_bind
            (Aws.Xml.member "metadataOptions" xml)
            InstanceMetadataOptionsResponse.parse
      ; enclave_options =
          Aws.Util.option_bind (Aws.Xml.member "enclaveOptions" xml) EnclaveOptions.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enclave_options (fun f ->
               Aws.Query.Pair ("EnclaveOptions", EnclaveOptions.to_query f))
         ; Aws.Util.option_map v.metadata_options (fun f ->
               Aws.Query.Pair
                 ("MetadataOptions", InstanceMetadataOptionsResponse.to_query f))
         ; Some (Aws.Query.Pair ("LicenseSet", LicenseList.to_query v.licenses))
         ; Aws.Util.option_map v.hibernation_options (fun f ->
               Aws.Query.Pair ("HibernationOptions", HibernationOptions.to_query f))
         ; Aws.Util.option_map v.capacity_reservation_specification (fun f ->
               Aws.Query.Pair
                 ( "CapacityReservationSpecification"
                 , CapacityReservationSpecificationResponse.to_query f ))
         ; Aws.Util.option_map v.capacity_reservation_id (fun f ->
               Aws.Query.Pair ("CapacityReservationId", String.to_query f))
         ; Aws.Util.option_map v.cpu_options (fun f ->
               Aws.Query.Pair ("CpuOptions", CpuOptions.to_query f))
         ; Some
             (Aws.Query.Pair
                ("VirtualizationType", VirtualizationType.to_query v.virtualization_type))
         ; Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.state_reason (fun f ->
               Aws.Query.Pair ("StateReason", StateReason.to_query f))
         ; Aws.Util.option_map v.sriov_net_support (fun f ->
               Aws.Query.Pair ("SriovNetSupport", String.to_query f))
         ; Aws.Util.option_map v.spot_instance_request_id (fun f ->
               Aws.Query.Pair ("SpotInstanceRequestId", String.to_query f))
         ; Aws.Util.option_map v.source_dest_check (fun f ->
               Aws.Query.Pair ("SourceDestCheck", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair ("GroupSet", GroupIdentifierList.to_query v.security_groups))
         ; Some
             (Aws.Query.Pair ("RootDeviceType", DeviceType.to_query v.root_device_type))
         ; Aws.Util.option_map v.root_device_name (fun f ->
               Aws.Query.Pair ("RootDeviceName", String.to_query f))
         ; Aws.Util.option_map v.outpost_arn (fun f ->
               Aws.Query.Pair ("OutpostArn", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "NetworkInterfaceSet"
                , InstanceNetworkInterfaceList.to_query v.network_interfaces ))
         ; Some
             (Aws.Query.Pair
                ( "ElasticInferenceAcceleratorAssociationSet"
                , ElasticInferenceAcceleratorAssociationList.to_query
                    v.elastic_inference_accelerator_associations ))
         ; Some
             (Aws.Query.Pair
                ( "ElasticGpuAssociationSet"
                , ElasticGpuAssociationList.to_query v.elastic_gpu_associations ))
         ; Aws.Util.option_map v.instance_lifecycle (fun f ->
               Aws.Query.Pair ("InstanceLifecycle", InstanceLifecycleType.to_query f))
         ; Aws.Util.option_map v.iam_instance_profile (fun f ->
               Aws.Query.Pair ("IamInstanceProfile", IamInstanceProfile.to_query f))
         ; Some (Aws.Query.Pair ("Hypervisor", HypervisorType.to_query v.hypervisor))
         ; Aws.Util.option_map v.ena_support (fun f ->
               Aws.Query.Pair ("EnaSupport", Boolean.to_query f))
         ; Aws.Util.option_map v.ebs_optimized (fun f ->
               Aws.Query.Pair ("EbsOptimized", Boolean.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "BlockDeviceMapping"
                , InstanceBlockDeviceMappingList.to_query v.block_device_mappings ))
         ; Some
             (Aws.Query.Pair ("Architecture", ArchitectureValues.to_query v.architecture))
         ; Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Aws.Util.option_map v.subnet_id (fun f ->
               Aws.Query.Pair ("SubnetId", String.to_query f))
         ; Aws.Util.option_map v.state_transition_reason (fun f ->
               Aws.Query.Pair ("Reason", String.to_query f))
         ; Some (Aws.Query.Pair ("InstanceState", InstanceState.to_query v.state))
         ; Aws.Util.option_map v.ramdisk_id (fun f ->
               Aws.Query.Pair ("RamdiskId", String.to_query f))
         ; Aws.Util.option_map v.public_ip_address (fun f ->
               Aws.Query.Pair ("IpAddress", String.to_query f))
         ; Aws.Util.option_map v.public_dns_name (fun f ->
               Aws.Query.Pair ("DnsName", String.to_query f))
         ; Some
             (Aws.Query.Pair ("ProductCodes", ProductCodeList.to_query v.product_codes))
         ; Aws.Util.option_map v.private_ip_address (fun f ->
               Aws.Query.Pair ("PrivateIpAddress", String.to_query f))
         ; Aws.Util.option_map v.private_dns_name (fun f ->
               Aws.Query.Pair ("PrivateDnsName", String.to_query f))
         ; Aws.Util.option_map v.platform (fun f ->
               Aws.Query.Pair ("Platform", PlatformValues.to_query f))
         ; Some (Aws.Query.Pair ("Placement", Placement.to_query v.placement))
         ; Some (Aws.Query.Pair ("Monitoring", Monitoring.to_query v.monitoring))
         ; Some (Aws.Query.Pair ("LaunchTime", DateTime.to_query v.launch_time))
         ; Aws.Util.option_map v.key_name (fun f ->
               Aws.Query.Pair ("KeyName", String.to_query f))
         ; Aws.Util.option_map v.kernel_id (fun f ->
               Aws.Query.Pair ("KernelId", String.to_query f))
         ; Some (Aws.Query.Pair ("InstanceType", InstanceType.to_query v.instance_type))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ; Some (Aws.Query.Pair ("ImageId", String.to_query v.image_id))
         ; Some (Aws.Query.Pair ("AmiLaunchIndex", Integer.to_query v.ami_launch_index))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enclave_options (fun f ->
               "enclaveOptions", EnclaveOptions.to_json f)
         ; Aws.Util.option_map v.metadata_options (fun f ->
               "metadataOptions", InstanceMetadataOptionsResponse.to_json f)
         ; Some ("licenseSet", LicenseList.to_json v.licenses)
         ; Aws.Util.option_map v.hibernation_options (fun f ->
               "hibernationOptions", HibernationOptions.to_json f)
         ; Aws.Util.option_map v.capacity_reservation_specification (fun f ->
               ( "capacityReservationSpecification"
               , CapacityReservationSpecificationResponse.to_json f ))
         ; Aws.Util.option_map v.capacity_reservation_id (fun f ->
               "capacityReservationId", String.to_json f)
         ; Aws.Util.option_map v.cpu_options (fun f -> "cpuOptions", CpuOptions.to_json f)
         ; Some ("virtualizationType", VirtualizationType.to_json v.virtualization_type)
         ; Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.state_reason (fun f ->
               "stateReason", StateReason.to_json f)
         ; Aws.Util.option_map v.sriov_net_support (fun f ->
               "sriovNetSupport", String.to_json f)
         ; Aws.Util.option_map v.spot_instance_request_id (fun f ->
               "spotInstanceRequestId", String.to_json f)
         ; Aws.Util.option_map v.source_dest_check (fun f ->
               "sourceDestCheck", Boolean.to_json f)
         ; Some ("groupSet", GroupIdentifierList.to_json v.security_groups)
         ; Some ("rootDeviceType", DeviceType.to_json v.root_device_type)
         ; Aws.Util.option_map v.root_device_name (fun f ->
               "rootDeviceName", String.to_json f)
         ; Aws.Util.option_map v.outpost_arn (fun f -> "outpostArn", String.to_json f)
         ; Some
             ( "networkInterfaceSet"
             , InstanceNetworkInterfaceList.to_json v.network_interfaces )
         ; Some
             ( "elasticInferenceAcceleratorAssociationSet"
             , ElasticInferenceAcceleratorAssociationList.to_json
                 v.elastic_inference_accelerator_associations )
         ; Some
             ( "elasticGpuAssociationSet"
             , ElasticGpuAssociationList.to_json v.elastic_gpu_associations )
         ; Aws.Util.option_map v.instance_lifecycle (fun f ->
               "instanceLifecycle", InstanceLifecycleType.to_json f)
         ; Aws.Util.option_map v.iam_instance_profile (fun f ->
               "iamInstanceProfile", IamInstanceProfile.to_json f)
         ; Some ("hypervisor", HypervisorType.to_json v.hypervisor)
         ; Aws.Util.option_map v.ena_support (fun f -> "enaSupport", Boolean.to_json f)
         ; Aws.Util.option_map v.ebs_optimized (fun f ->
               "ebsOptimized", Boolean.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "clientToken", String.to_json f)
         ; Some
             ( "blockDeviceMapping"
             , InstanceBlockDeviceMappingList.to_json v.block_device_mappings )
         ; Some ("architecture", ArchitectureValues.to_json v.architecture)
         ; Aws.Util.option_map v.vpc_id (fun f -> "vpcId", String.to_json f)
         ; Aws.Util.option_map v.subnet_id (fun f -> "subnetId", String.to_json f)
         ; Aws.Util.option_map v.state_transition_reason (fun f ->
               "reason", String.to_json f)
         ; Some ("instanceState", InstanceState.to_json v.state)
         ; Aws.Util.option_map v.ramdisk_id (fun f -> "ramdiskId", String.to_json f)
         ; Aws.Util.option_map v.public_ip_address (fun f ->
               "ipAddress", String.to_json f)
         ; Aws.Util.option_map v.public_dns_name (fun f -> "dnsName", String.to_json f)
         ; Some ("productCodes", ProductCodeList.to_json v.product_codes)
         ; Aws.Util.option_map v.private_ip_address (fun f ->
               "privateIpAddress", String.to_json f)
         ; Aws.Util.option_map v.private_dns_name (fun f ->
               "privateDnsName", String.to_json f)
         ; Aws.Util.option_map v.platform (fun f -> "platform", PlatformValues.to_json f)
         ; Some ("placement", Placement.to_json v.placement)
         ; Some ("monitoring", Monitoring.to_json v.monitoring)
         ; Some ("launchTime", DateTime.to_json v.launch_time)
         ; Aws.Util.option_map v.key_name (fun f -> "keyName", String.to_json f)
         ; Aws.Util.option_map v.kernel_id (fun f -> "kernelId", String.to_json f)
         ; Some ("instanceType", InstanceType.to_json v.instance_type)
         ; Some ("instanceId", String.to_json v.instance_id)
         ; Some ("imageId", String.to_json v.image_id)
         ; Some ("amiLaunchIndex", Integer.to_json v.ami_launch_index)
         ])

  let of_json j =
    { ami_launch_index =
        Integer.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "amiLaunchIndex"))
    ; image_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "imageId"))
    ; instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceId"))
    ; instance_type =
        InstanceType.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceType"))
    ; kernel_id = Aws.Util.option_map (Aws.Json.lookup j "kernelId") String.of_json
    ; key_name = Aws.Util.option_map (Aws.Json.lookup j "keyName") String.of_json
    ; launch_time =
        DateTime.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "launchTime"))
    ; monitoring =
        Monitoring.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "monitoring"))
    ; placement =
        Placement.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "placement"))
    ; platform = Aws.Util.option_map (Aws.Json.lookup j "platform") PlatformValues.of_json
    ; private_dns_name =
        Aws.Util.option_map (Aws.Json.lookup j "privateDnsName") String.of_json
    ; private_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "privateIpAddress") String.of_json
    ; product_codes =
        ProductCodeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "productCodes"))
    ; public_dns_name = Aws.Util.option_map (Aws.Json.lookup j "dnsName") String.of_json
    ; public_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "ipAddress") String.of_json
    ; ramdisk_id = Aws.Util.option_map (Aws.Json.lookup j "ramdiskId") String.of_json
    ; state =
        InstanceState.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceState"))
    ; state_transition_reason =
        Aws.Util.option_map (Aws.Json.lookup j "reason") String.of_json
    ; subnet_id = Aws.Util.option_map (Aws.Json.lookup j "subnetId") String.of_json
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "vpcId") String.of_json
    ; architecture =
        ArchitectureValues.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "architecture"))
    ; block_device_mappings =
        InstanceBlockDeviceMappingList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "blockDeviceMapping"))
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "clientToken") String.of_json
    ; ebs_optimized =
        Aws.Util.option_map (Aws.Json.lookup j "ebsOptimized") Boolean.of_json
    ; ena_support = Aws.Util.option_map (Aws.Json.lookup j "enaSupport") Boolean.of_json
    ; hypervisor =
        HypervisorType.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "hypervisor"))
    ; iam_instance_profile =
        Aws.Util.option_map
          (Aws.Json.lookup j "iamInstanceProfile")
          IamInstanceProfile.of_json
    ; instance_lifecycle =
        Aws.Util.option_map
          (Aws.Json.lookup j "instanceLifecycle")
          InstanceLifecycleType.of_json
    ; elastic_gpu_associations =
        ElasticGpuAssociationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "elasticGpuAssociationSet"))
    ; elastic_inference_accelerator_associations =
        ElasticInferenceAcceleratorAssociationList.of_json
          (Aws.Util.of_option_exn
             (Aws.Json.lookup j "elasticInferenceAcceleratorAssociationSet"))
    ; network_interfaces =
        InstanceNetworkInterfaceList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "networkInterfaceSet"))
    ; outpost_arn = Aws.Util.option_map (Aws.Json.lookup j "outpostArn") String.of_json
    ; root_device_name =
        Aws.Util.option_map (Aws.Json.lookup j "rootDeviceName") String.of_json
    ; root_device_type =
        DeviceType.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "rootDeviceType"))
    ; security_groups =
        GroupIdentifierList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "groupSet"))
    ; source_dest_check =
        Aws.Util.option_map (Aws.Json.lookup j "sourceDestCheck") Boolean.of_json
    ; spot_instance_request_id =
        Aws.Util.option_map (Aws.Json.lookup j "spotInstanceRequestId") String.of_json
    ; sriov_net_support =
        Aws.Util.option_map (Aws.Json.lookup j "sriovNetSupport") String.of_json
    ; state_reason =
        Aws.Util.option_map (Aws.Json.lookup j "stateReason") StateReason.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    ; virtualization_type =
        VirtualizationType.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "virtualizationType"))
    ; cpu_options =
        Aws.Util.option_map (Aws.Json.lookup j "cpuOptions") CpuOptions.of_json
    ; capacity_reservation_id =
        Aws.Util.option_map (Aws.Json.lookup j "capacityReservationId") String.of_json
    ; capacity_reservation_specification =
        Aws.Util.option_map
          (Aws.Json.lookup j "capacityReservationSpecification")
          CapacityReservationSpecificationResponse.of_json
    ; hibernation_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "hibernationOptions")
          HibernationOptions.of_json
    ; licenses =
        LicenseList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "licenseSet"))
    ; metadata_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "metadataOptions")
          InstanceMetadataOptionsResponse.of_json
    ; enclave_options =
        Aws.Util.option_map (Aws.Json.lookup j "enclaveOptions") EnclaveOptions.of_json
    }
end

module InstanceList = struct
  type t = Instance.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Instance.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Instance.to_query v

  let to_json v = `List (List.map Instance.to_json v)

  let of_json j = Aws.Json.to_list Instance.of_json j
end

module Reservation = struct
  type t =
    { groups : GroupIdentifierList.t
    ; instances : InstanceList.t
    ; owner_id : String.t
    ; requester_id : String.t option
    ; reservation_id : String.t
    }

  let make ?(groups = []) ?(instances = []) ~owner_id ?requester_id ~reservation_id () =
    { groups; instances; owner_id; requester_id; reservation_id }

  let parse xml =
    Some
      { groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "groupSet" xml)
               GroupIdentifierList.parse)
      ; instances =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "instancesSet" xml) InstanceList.parse)
      ; owner_id =
          Aws.Xml.required
            "ownerId"
            (Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse)
      ; requester_id =
          Aws.Util.option_bind (Aws.Xml.member "requesterId" xml) String.parse
      ; reservation_id =
          Aws.Xml.required
            "reservationId"
            (Aws.Util.option_bind (Aws.Xml.member "reservationId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("ReservationId", String.to_query v.reservation_id))
         ; Aws.Util.option_map v.requester_id (fun f ->
               Aws.Query.Pair ("RequesterId", String.to_query f))
         ; Some (Aws.Query.Pair ("OwnerId", String.to_query v.owner_id))
         ; Some (Aws.Query.Pair ("InstancesSet", InstanceList.to_query v.instances))
         ; Some (Aws.Query.Pair ("GroupSet", GroupIdentifierList.to_query v.groups))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("reservationId", String.to_json v.reservation_id)
         ; Aws.Util.option_map v.requester_id (fun f -> "requesterId", String.to_json f)
         ; Some ("ownerId", String.to_json v.owner_id)
         ; Some ("instancesSet", InstanceList.to_json v.instances)
         ; Some ("groupSet", GroupIdentifierList.to_json v.groups)
         ])

  let of_json j =
    { groups =
        GroupIdentifierList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "groupSet"))
    ; instances =
        InstanceList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "instancesSet"))
    ; owner_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ownerId"))
    ; requester_id = Aws.Util.option_map (Aws.Json.lookup j "requesterId") String.of_json
    ; reservation_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "reservationId"))
    }
end

module ReservationList = struct
  type t = Reservation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Reservation.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Reservation.to_query v

  let to_json v = `List (List.map Reservation.to_json v)

  let of_json j = Aws.Json.to_list Reservation.of_json j
end

module DescribeInstancesResult = struct
  type t =
    { reservations : ReservationList.t
    ; next_token : String.t option
    }

  let make ?(reservations = []) ?next_token () = { reservations; next_token }

  let parse xml =
    Some
      { reservations =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "reservationSet" xml)
               ReservationList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair ("ReservationSet", ReservationList.to_query v.reservations))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("reservationSet", ReservationList.to_json v.reservations)
         ])

  let of_json j =
    { reservations =
        ReservationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "reservationSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module VirtualizationTypeList = struct
  type t = VirtualizationType.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map VirtualizationType.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list VirtualizationType.to_query v

  let to_json v = `List (List.map VirtualizationType.to_json v)

  let of_json j = Aws.Json.to_list VirtualizationType.of_json j
end

module ThreadsPerCoreList = struct
  type t = Integer.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Integer.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Integer.to_query v

  let to_json v = `List (List.map Integer.to_json v)

  let of_json j = Aws.Json.to_list Integer.of_json j
end

module CoreCountList = struct
  type t = Integer.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Integer.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Integer.to_query v

  let to_json v = `List (List.map Integer.to_json v)

  let of_json j = Aws.Json.to_list Integer.of_json j
end

module VCpuInfo = struct
  type t =
    { default_v_cpus : Integer.t option
    ; default_cores : Integer.t option
    ; default_threads_per_core : Integer.t option
    ; valid_cores : CoreCountList.t
    ; valid_threads_per_core : ThreadsPerCoreList.t
    }

  let make
      ?default_v_cpus
      ?default_cores
      ?default_threads_per_core
      ?(valid_cores = [])
      ?(valid_threads_per_core = [])
      () =
    { default_v_cpus
    ; default_cores
    ; default_threads_per_core
    ; valid_cores
    ; valid_threads_per_core
    }

  let parse xml =
    Some
      { default_v_cpus =
          Aws.Util.option_bind (Aws.Xml.member "defaultVCpus" xml) Integer.parse
      ; default_cores =
          Aws.Util.option_bind (Aws.Xml.member "defaultCores" xml) Integer.parse
      ; default_threads_per_core =
          Aws.Util.option_bind (Aws.Xml.member "defaultThreadsPerCore" xml) Integer.parse
      ; valid_cores =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "validCores" xml) CoreCountList.parse)
      ; valid_threads_per_core =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "validThreadsPerCore" xml)
               ThreadsPerCoreList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "ValidThreadsPerCore"
                , ThreadsPerCoreList.to_query v.valid_threads_per_core ))
         ; Some (Aws.Query.Pair ("ValidCores", CoreCountList.to_query v.valid_cores))
         ; Aws.Util.option_map v.default_threads_per_core (fun f ->
               Aws.Query.Pair ("DefaultThreadsPerCore", Integer.to_query f))
         ; Aws.Util.option_map v.default_cores (fun f ->
               Aws.Query.Pair ("DefaultCores", Integer.to_query f))
         ; Aws.Util.option_map v.default_v_cpus (fun f ->
               Aws.Query.Pair ("DefaultVCpus", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ("validThreadsPerCore", ThreadsPerCoreList.to_json v.valid_threads_per_core)
         ; Some ("validCores", CoreCountList.to_json v.valid_cores)
         ; Aws.Util.option_map v.default_threads_per_core (fun f ->
               "defaultThreadsPerCore", Integer.to_json f)
         ; Aws.Util.option_map v.default_cores (fun f ->
               "defaultCores", Integer.to_json f)
         ; Aws.Util.option_map v.default_v_cpus (fun f ->
               "defaultVCpus", Integer.to_json f)
         ])

  let of_json j =
    { default_v_cpus =
        Aws.Util.option_map (Aws.Json.lookup j "defaultVCpus") Integer.of_json
    ; default_cores =
        Aws.Util.option_map (Aws.Json.lookup j "defaultCores") Integer.of_json
    ; default_threads_per_core =
        Aws.Util.option_map (Aws.Json.lookup j "defaultThreadsPerCore") Integer.of_json
    ; valid_cores =
        CoreCountList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "validCores"))
    ; valid_threads_per_core =
        ThreadsPerCoreList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "validThreadsPerCore"))
    }
end

module UsageClassTypeList = struct
  type t = UsageClassType.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map UsageClassType.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list UsageClassType.to_query v

  let to_json v = `List (List.map UsageClassType.to_json v)

  let of_json j = Aws.Json.to_list UsageClassType.of_json j
end

module RootDeviceType = struct
  type t =
    | Ebs
    | Instance_store

  let str_to_t = [ "instance-store", Instance_store; "ebs", Ebs ]

  let t_to_str = [ Instance_store, "instance-store"; Ebs, "ebs" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module RootDeviceTypeList = struct
  type t = RootDeviceType.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map RootDeviceType.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list RootDeviceType.to_query v

  let to_json v = `List (List.map RootDeviceType.to_json v)

  let of_json j = Aws.Json.to_list RootDeviceType.of_json j
end

module ProcessorInfo = struct
  type t =
    { supported_architectures : ArchitectureTypeList.t
    ; sustained_clock_speed_in_ghz : Double.t option
    }

  let make ?(supported_architectures = []) ?sustained_clock_speed_in_ghz () =
    { supported_architectures; sustained_clock_speed_in_ghz }

  let parse xml =
    Some
      { supported_architectures =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "supportedArchitectures" xml)
               ArchitectureTypeList.parse)
      ; sustained_clock_speed_in_ghz =
          Aws.Util.option_bind
            (Aws.Xml.member "sustainedClockSpeedInGhz" xml)
            Double.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.sustained_clock_speed_in_ghz (fun f ->
               Aws.Query.Pair ("SustainedClockSpeedInGhz", Double.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "SupportedArchitectures"
                , ArchitectureTypeList.to_query v.supported_architectures ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.sustained_clock_speed_in_ghz (fun f ->
               "sustainedClockSpeedInGhz", Double.to_json f)
         ; Some
             ( "supportedArchitectures"
             , ArchitectureTypeList.to_json v.supported_architectures )
         ])

  let of_json j =
    { supported_architectures =
        ArchitectureTypeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "supportedArchitectures"))
    ; sustained_clock_speed_in_ghz =
        Aws.Util.option_map (Aws.Json.lookup j "sustainedClockSpeedInGhz") Double.of_json
    }
end

module PlacementGroupStrategy = struct
  type t =
    | Cluster
    | Partition
    | Spread

  let str_to_t = [ "spread", Spread; "partition", Partition; "cluster", Cluster ]

  let t_to_str = [ Spread, "spread"; Partition, "partition"; Cluster, "cluster" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module PlacementGroupStrategyList = struct
  type t = PlacementGroupStrategy.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map PlacementGroupStrategy.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list PlacementGroupStrategy.to_query v

  let to_json v = `List (List.map PlacementGroupStrategy.to_json v)

  let of_json j = Aws.Json.to_list PlacementGroupStrategy.of_json j
end

module PlacementGroupInfo = struct
  type t = { supported_strategies : PlacementGroupStrategyList.t }

  let make ?(supported_strategies = []) () = { supported_strategies }

  let parse xml =
    Some
      { supported_strategies =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "supportedStrategies" xml)
               PlacementGroupStrategyList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "SupportedStrategies"
                , PlacementGroupStrategyList.to_query v.supported_strategies ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "supportedStrategies"
             , PlacementGroupStrategyList.to_json v.supported_strategies )
         ])

  let of_json j =
    { supported_strategies =
        PlacementGroupStrategyList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "supportedStrategies"))
    }
end

module NetworkCardInfoList = struct
  type t = NetworkCardInfo.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map NetworkCardInfo.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list NetworkCardInfo.to_query v

  let to_json v = `List (List.map NetworkCardInfo.to_json v)

  let of_json j = Aws.Json.to_list NetworkCardInfo.of_json j
end

module EnaSupport = struct
  type t =
    | Unsupported
    | Supported
    | Required

  let str_to_t =
    [ "required", Required; "supported", Supported; "unsupported", Unsupported ]

  let t_to_str =
    [ Required, "required"; Supported, "supported"; Unsupported, "unsupported" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module NetworkInfo = struct
  type t =
    { network_performance : String.t option
    ; maximum_network_interfaces : Integer.t option
    ; maximum_network_cards : Integer.t option
    ; default_network_card_index : Integer.t option
    ; network_cards : NetworkCardInfoList.t
    ; ipv4_addresses_per_interface : Integer.t option
    ; ipv6_addresses_per_interface : Integer.t option
    ; ipv6_supported : Boolean.t option
    ; ena_support : EnaSupport.t option
    ; efa_supported : Boolean.t option
    }

  let make
      ?network_performance
      ?maximum_network_interfaces
      ?maximum_network_cards
      ?default_network_card_index
      ?(network_cards = [])
      ?ipv4_addresses_per_interface
      ?ipv6_addresses_per_interface
      ?ipv6_supported
      ?ena_support
      ?efa_supported
      () =
    { network_performance
    ; maximum_network_interfaces
    ; maximum_network_cards
    ; default_network_card_index
    ; network_cards
    ; ipv4_addresses_per_interface
    ; ipv6_addresses_per_interface
    ; ipv6_supported
    ; ena_support
    ; efa_supported
    }

  let parse xml =
    Some
      { network_performance =
          Aws.Util.option_bind (Aws.Xml.member "networkPerformance" xml) String.parse
      ; maximum_network_interfaces =
          Aws.Util.option_bind
            (Aws.Xml.member "maximumNetworkInterfaces" xml)
            Integer.parse
      ; maximum_network_cards =
          Aws.Util.option_bind (Aws.Xml.member "maximumNetworkCards" xml) Integer.parse
      ; default_network_card_index =
          Aws.Util.option_bind
            (Aws.Xml.member "defaultNetworkCardIndex" xml)
            Integer.parse
      ; network_cards =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "networkCards" xml)
               NetworkCardInfoList.parse)
      ; ipv4_addresses_per_interface =
          Aws.Util.option_bind
            (Aws.Xml.member "ipv4AddressesPerInterface" xml)
            Integer.parse
      ; ipv6_addresses_per_interface =
          Aws.Util.option_bind
            (Aws.Xml.member "ipv6AddressesPerInterface" xml)
            Integer.parse
      ; ipv6_supported =
          Aws.Util.option_bind (Aws.Xml.member "ipv6Supported" xml) Boolean.parse
      ; ena_support =
          Aws.Util.option_bind (Aws.Xml.member "enaSupport" xml) EnaSupport.parse
      ; efa_supported =
          Aws.Util.option_bind (Aws.Xml.member "efaSupported" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.efa_supported (fun f ->
               Aws.Query.Pair ("EfaSupported", Boolean.to_query f))
         ; Aws.Util.option_map v.ena_support (fun f ->
               Aws.Query.Pair ("EnaSupport", EnaSupport.to_query f))
         ; Aws.Util.option_map v.ipv6_supported (fun f ->
               Aws.Query.Pair ("Ipv6Supported", Boolean.to_query f))
         ; Aws.Util.option_map v.ipv6_addresses_per_interface (fun f ->
               Aws.Query.Pair ("Ipv6AddressesPerInterface", Integer.to_query f))
         ; Aws.Util.option_map v.ipv4_addresses_per_interface (fun f ->
               Aws.Query.Pair ("Ipv4AddressesPerInterface", Integer.to_query f))
         ; Some
             (Aws.Query.Pair ("NetworkCards", NetworkCardInfoList.to_query v.network_cards))
         ; Aws.Util.option_map v.default_network_card_index (fun f ->
               Aws.Query.Pair ("DefaultNetworkCardIndex", Integer.to_query f))
         ; Aws.Util.option_map v.maximum_network_cards (fun f ->
               Aws.Query.Pair ("MaximumNetworkCards", Integer.to_query f))
         ; Aws.Util.option_map v.maximum_network_interfaces (fun f ->
               Aws.Query.Pair ("MaximumNetworkInterfaces", Integer.to_query f))
         ; Aws.Util.option_map v.network_performance (fun f ->
               Aws.Query.Pair ("NetworkPerformance", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.efa_supported (fun f ->
               "efaSupported", Boolean.to_json f)
         ; Aws.Util.option_map v.ena_support (fun f -> "enaSupport", EnaSupport.to_json f)
         ; Aws.Util.option_map v.ipv6_supported (fun f ->
               "ipv6Supported", Boolean.to_json f)
         ; Aws.Util.option_map v.ipv6_addresses_per_interface (fun f ->
               "ipv6AddressesPerInterface", Integer.to_json f)
         ; Aws.Util.option_map v.ipv4_addresses_per_interface (fun f ->
               "ipv4AddressesPerInterface", Integer.to_json f)
         ; Some ("networkCards", NetworkCardInfoList.to_json v.network_cards)
         ; Aws.Util.option_map v.default_network_card_index (fun f ->
               "defaultNetworkCardIndex", Integer.to_json f)
         ; Aws.Util.option_map v.maximum_network_cards (fun f ->
               "maximumNetworkCards", Integer.to_json f)
         ; Aws.Util.option_map v.maximum_network_interfaces (fun f ->
               "maximumNetworkInterfaces", Integer.to_json f)
         ; Aws.Util.option_map v.network_performance (fun f ->
               "networkPerformance", String.to_json f)
         ])

  let of_json j =
    { network_performance =
        Aws.Util.option_map (Aws.Json.lookup j "networkPerformance") String.of_json
    ; maximum_network_interfaces =
        Aws.Util.option_map (Aws.Json.lookup j "maximumNetworkInterfaces") Integer.of_json
    ; maximum_network_cards =
        Aws.Util.option_map (Aws.Json.lookup j "maximumNetworkCards") Integer.of_json
    ; default_network_card_index =
        Aws.Util.option_map (Aws.Json.lookup j "defaultNetworkCardIndex") Integer.of_json
    ; network_cards =
        NetworkCardInfoList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "networkCards"))
    ; ipv4_addresses_per_interface =
        Aws.Util.option_map
          (Aws.Json.lookup j "ipv4AddressesPerInterface")
          Integer.of_json
    ; ipv6_addresses_per_interface =
        Aws.Util.option_map
          (Aws.Json.lookup j "ipv6AddressesPerInterface")
          Integer.of_json
    ; ipv6_supported =
        Aws.Util.option_map (Aws.Json.lookup j "ipv6Supported") Boolean.of_json
    ; ena_support =
        Aws.Util.option_map (Aws.Json.lookup j "enaSupport") EnaSupport.of_json
    ; efa_supported =
        Aws.Util.option_map (Aws.Json.lookup j "efaSupported") Boolean.of_json
    }
end

module MemoryInfo = struct
  type t = { size_in_mi_b : Long.t option }

  let make ?size_in_mi_b () = { size_in_mi_b }

  let parse xml =
    Some
      { size_in_mi_b = Aws.Util.option_bind (Aws.Xml.member "sizeInMiB" xml) Long.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.size_in_mi_b (fun f ->
               Aws.Query.Pair ("SizeInMiB", Long.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.size_in_mi_b (fun f -> "sizeInMiB", Long.to_json f) ])

  let of_json j =
    { size_in_mi_b = Aws.Util.option_map (Aws.Json.lookup j "sizeInMiB") Long.of_json }
end

module InstanceTypeHypervisor = struct
  type t =
    | Nitro
    | Xen

  let str_to_t = [ "xen", Xen; "nitro", Nitro ]

  let t_to_str = [ Xen, "xen"; Nitro, "nitro" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module EphemeralNvmeSupport = struct
  type t =
    | Unsupported
    | Supported
    | Required

  let str_to_t =
    [ "required", Required; "supported", Supported; "unsupported", Unsupported ]

  let t_to_str =
    [ Required, "required"; Supported, "supported"; Unsupported, "unsupported" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DiskType = struct
  type t =
    | Hdd
    | Ssd

  let str_to_t = [ "ssd", Ssd; "hdd", Hdd ]

  let t_to_str = [ Ssd, "ssd"; Hdd, "hdd" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DiskInfo = struct
  type t =
    { size_in_g_b : Long.t option
    ; count : Integer.t option
    ; type_ : DiskType.t option
    }

  let make ?size_in_g_b ?count ?type_ () = { size_in_g_b; count; type_ }

  let parse xml =
    Some
      { size_in_g_b = Aws.Util.option_bind (Aws.Xml.member "sizeInGB" xml) Long.parse
      ; count = Aws.Util.option_bind (Aws.Xml.member "count" xml) Integer.parse
      ; type_ = Aws.Util.option_bind (Aws.Xml.member "type" xml) DiskType.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", DiskType.to_query f))
         ; Aws.Util.option_map v.count (fun f ->
               Aws.Query.Pair ("Count", Integer.to_query f))
         ; Aws.Util.option_map v.size_in_g_b (fun f ->
               Aws.Query.Pair ("SizeInGB", Long.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.type_ (fun f -> "type", DiskType.to_json f)
         ; Aws.Util.option_map v.count (fun f -> "count", Integer.to_json f)
         ; Aws.Util.option_map v.size_in_g_b (fun f -> "sizeInGB", Long.to_json f)
         ])

  let of_json j =
    { size_in_g_b = Aws.Util.option_map (Aws.Json.lookup j "sizeInGB") Long.of_json
    ; count = Aws.Util.option_map (Aws.Json.lookup j "count") Integer.of_json
    ; type_ = Aws.Util.option_map (Aws.Json.lookup j "type") DiskType.of_json
    }
end

module DiskInfoList = struct
  type t = DiskInfo.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map DiskInfo.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list DiskInfo.to_query v

  let to_json v = `List (List.map DiskInfo.to_json v)

  let of_json j = Aws.Json.to_list DiskInfo.of_json j
end

module InstanceStorageInfo = struct
  type t =
    { total_size_in_g_b : Long.t option
    ; disks : DiskInfoList.t
    ; nvme_support : EphemeralNvmeSupport.t option
    }

  let make ?total_size_in_g_b ?(disks = []) ?nvme_support () =
    { total_size_in_g_b; disks; nvme_support }

  let parse xml =
    Some
      { total_size_in_g_b =
          Aws.Util.option_bind (Aws.Xml.member "totalSizeInGB" xml) Long.parse
      ; disks =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "disks" xml) DiskInfoList.parse)
      ; nvme_support =
          Aws.Util.option_bind
            (Aws.Xml.member "nvmeSupport" xml)
            EphemeralNvmeSupport.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.nvme_support (fun f ->
               Aws.Query.Pair ("NvmeSupport", EphemeralNvmeSupport.to_query f))
         ; Some (Aws.Query.Pair ("Disks", DiskInfoList.to_query v.disks))
         ; Aws.Util.option_map v.total_size_in_g_b (fun f ->
               Aws.Query.Pair ("TotalSizeInGB", Long.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.nvme_support (fun f ->
               "nvmeSupport", EphemeralNvmeSupport.to_json f)
         ; Some ("disks", DiskInfoList.to_json v.disks)
         ; Aws.Util.option_map v.total_size_in_g_b (fun f ->
               "totalSizeInGB", Long.to_json f)
         ])

  let of_json j =
    { total_size_in_g_b =
        Aws.Util.option_map (Aws.Json.lookup j "totalSizeInGB") Long.of_json
    ; disks = DiskInfoList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "disks"))
    ; nvme_support =
        Aws.Util.option_map (Aws.Json.lookup j "nvmeSupport") EphemeralNvmeSupport.of_json
    }
end

module InferenceDeviceInfo = struct
  type t =
    { count : Integer.t option
    ; name : String.t option
    ; manufacturer : String.t option
    }

  let make ?count ?name ?manufacturer () = { count; name; manufacturer }

  let parse xml =
    Some
      { count = Aws.Util.option_bind (Aws.Xml.member "count" xml) Integer.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "name" xml) String.parse
      ; manufacturer =
          Aws.Util.option_bind (Aws.Xml.member "manufacturer" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.manufacturer (fun f ->
               Aws.Query.Pair ("Manufacturer", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.count (fun f ->
               Aws.Query.Pair ("Count", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.manufacturer (fun f -> "manufacturer", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "name", String.to_json f)
         ; Aws.Util.option_map v.count (fun f -> "count", Integer.to_json f)
         ])

  let of_json j =
    { count = Aws.Util.option_map (Aws.Json.lookup j "count") Integer.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "name") String.of_json
    ; manufacturer = Aws.Util.option_map (Aws.Json.lookup j "manufacturer") String.of_json
    }
end

module InferenceDeviceInfoList = struct
  type t = InferenceDeviceInfo.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map InferenceDeviceInfo.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list InferenceDeviceInfo.to_query v

  let to_json v = `List (List.map InferenceDeviceInfo.to_json v)

  let of_json j = Aws.Json.to_list InferenceDeviceInfo.of_json j
end

module InferenceAcceleratorInfo = struct
  type t = { accelerators : InferenceDeviceInfoList.t }

  let make ?(accelerators = []) () = { accelerators }

  let parse xml =
    Some
      { accelerators =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "accelerators" xml)
               InferenceDeviceInfoList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("Accelerators", InferenceDeviceInfoList.to_query v.accelerators))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("accelerators", InferenceDeviceInfoList.to_json v.accelerators) ])

  let of_json j =
    { accelerators =
        InferenceDeviceInfoList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "accelerators"))
    }
end

module FpgaDeviceMemoryInfo = struct
  type t = { size_in_mi_b : Integer.t option }

  let make ?size_in_mi_b () = { size_in_mi_b }

  let parse xml =
    Some
      { size_in_mi_b = Aws.Util.option_bind (Aws.Xml.member "sizeInMiB" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.size_in_mi_b (fun f ->
               Aws.Query.Pair ("SizeInMiB", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.size_in_mi_b (fun f -> "sizeInMiB", Integer.to_json f) ])

  let of_json j =
    { size_in_mi_b = Aws.Util.option_map (Aws.Json.lookup j "sizeInMiB") Integer.of_json }
end

module FpgaDeviceInfo = struct
  type t =
    { name : String.t option
    ; manufacturer : String.t option
    ; count : Integer.t option
    ; memory_info : FpgaDeviceMemoryInfo.t option
    }

  let make ?name ?manufacturer ?count ?memory_info () =
    { name; manufacturer; count; memory_info }

  let parse xml =
    Some
      { name = Aws.Util.option_bind (Aws.Xml.member "name" xml) String.parse
      ; manufacturer =
          Aws.Util.option_bind (Aws.Xml.member "manufacturer" xml) String.parse
      ; count = Aws.Util.option_bind (Aws.Xml.member "count" xml) Integer.parse
      ; memory_info =
          Aws.Util.option_bind
            (Aws.Xml.member "memoryInfo" xml)
            FpgaDeviceMemoryInfo.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.memory_info (fun f ->
               Aws.Query.Pair ("MemoryInfo", FpgaDeviceMemoryInfo.to_query f))
         ; Aws.Util.option_map v.count (fun f ->
               Aws.Query.Pair ("Count", Integer.to_query f))
         ; Aws.Util.option_map v.manufacturer (fun f ->
               Aws.Query.Pair ("Manufacturer", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.memory_info (fun f ->
               "memoryInfo", FpgaDeviceMemoryInfo.to_json f)
         ; Aws.Util.option_map v.count (fun f -> "count", Integer.to_json f)
         ; Aws.Util.option_map v.manufacturer (fun f -> "manufacturer", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "name", String.to_json f)
         ])

  let of_json j =
    { name = Aws.Util.option_map (Aws.Json.lookup j "name") String.of_json
    ; manufacturer = Aws.Util.option_map (Aws.Json.lookup j "manufacturer") String.of_json
    ; count = Aws.Util.option_map (Aws.Json.lookup j "count") Integer.of_json
    ; memory_info =
        Aws.Util.option_map (Aws.Json.lookup j "memoryInfo") FpgaDeviceMemoryInfo.of_json
    }
end

module FpgaDeviceInfoList = struct
  type t = FpgaDeviceInfo.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map FpgaDeviceInfo.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list FpgaDeviceInfo.to_query v

  let to_json v = `List (List.map FpgaDeviceInfo.to_json v)

  let of_json j = Aws.Json.to_list FpgaDeviceInfo.of_json j
end

module FpgaInfo = struct
  type t =
    { fpgas : FpgaDeviceInfoList.t
    ; total_fpga_memory_in_mi_b : Integer.t option
    }

  let make ?(fpgas = []) ?total_fpga_memory_in_mi_b () =
    { fpgas; total_fpga_memory_in_mi_b }

  let parse xml =
    Some
      { fpgas =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "fpgas" xml) FpgaDeviceInfoList.parse)
      ; total_fpga_memory_in_mi_b =
          Aws.Util.option_bind (Aws.Xml.member "totalFpgaMemoryInMiB" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.total_fpga_memory_in_mi_b (fun f ->
               Aws.Query.Pair ("TotalFpgaMemoryInMiB", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Fpgas", FpgaDeviceInfoList.to_query v.fpgas))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.total_fpga_memory_in_mi_b (fun f ->
               "totalFpgaMemoryInMiB", Integer.to_json f)
         ; Some ("fpgas", FpgaDeviceInfoList.to_json v.fpgas)
         ])

  let of_json j =
    { fpgas =
        FpgaDeviceInfoList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "fpgas"))
    ; total_fpga_memory_in_mi_b =
        Aws.Util.option_map (Aws.Json.lookup j "totalFpgaMemoryInMiB") Integer.of_json
    }
end

module EbsOptimizedSupport = struct
  type t =
    | Unsupported
    | Supported
    | Default

  let str_to_t =
    [ "default", Default; "supported", Supported; "unsupported", Unsupported ]

  let t_to_str =
    [ Default, "default"; Supported, "supported"; Unsupported, "unsupported" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module EbsOptimizedInfo = struct
  type t =
    { baseline_bandwidth_in_mbps : Integer.t option
    ; baseline_throughput_in_m_bps : Double.t option
    ; baseline_iops : Integer.t option
    ; maximum_bandwidth_in_mbps : Integer.t option
    ; maximum_throughput_in_m_bps : Double.t option
    ; maximum_iops : Integer.t option
    }

  let make
      ?baseline_bandwidth_in_mbps
      ?baseline_throughput_in_m_bps
      ?baseline_iops
      ?maximum_bandwidth_in_mbps
      ?maximum_throughput_in_m_bps
      ?maximum_iops
      () =
    { baseline_bandwidth_in_mbps
    ; baseline_throughput_in_m_bps
    ; baseline_iops
    ; maximum_bandwidth_in_mbps
    ; maximum_throughput_in_m_bps
    ; maximum_iops
    }

  let parse xml =
    Some
      { baseline_bandwidth_in_mbps =
          Aws.Util.option_bind
            (Aws.Xml.member "baselineBandwidthInMbps" xml)
            Integer.parse
      ; baseline_throughput_in_m_bps =
          Aws.Util.option_bind
            (Aws.Xml.member "baselineThroughputInMBps" xml)
            Double.parse
      ; baseline_iops =
          Aws.Util.option_bind (Aws.Xml.member "baselineIops" xml) Integer.parse
      ; maximum_bandwidth_in_mbps =
          Aws.Util.option_bind (Aws.Xml.member "maximumBandwidthInMbps" xml) Integer.parse
      ; maximum_throughput_in_m_bps =
          Aws.Util.option_bind (Aws.Xml.member "maximumThroughputInMBps" xml) Double.parse
      ; maximum_iops =
          Aws.Util.option_bind (Aws.Xml.member "maximumIops" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.maximum_iops (fun f ->
               Aws.Query.Pair ("MaximumIops", Integer.to_query f))
         ; Aws.Util.option_map v.maximum_throughput_in_m_bps (fun f ->
               Aws.Query.Pair ("MaximumThroughputInMBps", Double.to_query f))
         ; Aws.Util.option_map v.maximum_bandwidth_in_mbps (fun f ->
               Aws.Query.Pair ("MaximumBandwidthInMbps", Integer.to_query f))
         ; Aws.Util.option_map v.baseline_iops (fun f ->
               Aws.Query.Pair ("BaselineIops", Integer.to_query f))
         ; Aws.Util.option_map v.baseline_throughput_in_m_bps (fun f ->
               Aws.Query.Pair ("BaselineThroughputInMBps", Double.to_query f))
         ; Aws.Util.option_map v.baseline_bandwidth_in_mbps (fun f ->
               Aws.Query.Pair ("BaselineBandwidthInMbps", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.maximum_iops (fun f -> "maximumIops", Integer.to_json f)
         ; Aws.Util.option_map v.maximum_throughput_in_m_bps (fun f ->
               "maximumThroughputInMBps", Double.to_json f)
         ; Aws.Util.option_map v.maximum_bandwidth_in_mbps (fun f ->
               "maximumBandwidthInMbps", Integer.to_json f)
         ; Aws.Util.option_map v.baseline_iops (fun f ->
               "baselineIops", Integer.to_json f)
         ; Aws.Util.option_map v.baseline_throughput_in_m_bps (fun f ->
               "baselineThroughputInMBps", Double.to_json f)
         ; Aws.Util.option_map v.baseline_bandwidth_in_mbps (fun f ->
               "baselineBandwidthInMbps", Integer.to_json f)
         ])

  let of_json j =
    { baseline_bandwidth_in_mbps =
        Aws.Util.option_map (Aws.Json.lookup j "baselineBandwidthInMbps") Integer.of_json
    ; baseline_throughput_in_m_bps =
        Aws.Util.option_map (Aws.Json.lookup j "baselineThroughputInMBps") Double.of_json
    ; baseline_iops =
        Aws.Util.option_map (Aws.Json.lookup j "baselineIops") Integer.of_json
    ; maximum_bandwidth_in_mbps =
        Aws.Util.option_map (Aws.Json.lookup j "maximumBandwidthInMbps") Integer.of_json
    ; maximum_throughput_in_m_bps =
        Aws.Util.option_map (Aws.Json.lookup j "maximumThroughputInMBps") Double.of_json
    ; maximum_iops = Aws.Util.option_map (Aws.Json.lookup j "maximumIops") Integer.of_json
    }
end

module EbsNvmeSupport = struct
  type t =
    | Unsupported
    | Supported
    | Required

  let str_to_t =
    [ "required", Required; "supported", Supported; "unsupported", Unsupported ]

  let t_to_str =
    [ Required, "required"; Supported, "supported"; Unsupported, "unsupported" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module EbsEncryptionSupport = struct
  type t =
    | Unsupported
    | Supported

  let str_to_t = [ "supported", Supported; "unsupported", Unsupported ]

  let t_to_str = [ Supported, "supported"; Unsupported, "unsupported" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module EbsInfo = struct
  type t =
    { ebs_optimized_support : EbsOptimizedSupport.t option
    ; encryption_support : EbsEncryptionSupport.t option
    ; ebs_optimized_info : EbsOptimizedInfo.t option
    ; nvme_support : EbsNvmeSupport.t option
    }

  let make ?ebs_optimized_support ?encryption_support ?ebs_optimized_info ?nvme_support ()
      =
    { ebs_optimized_support; encryption_support; ebs_optimized_info; nvme_support }

  let parse xml =
    Some
      { ebs_optimized_support =
          Aws.Util.option_bind
            (Aws.Xml.member "ebsOptimizedSupport" xml)
            EbsOptimizedSupport.parse
      ; encryption_support =
          Aws.Util.option_bind
            (Aws.Xml.member "encryptionSupport" xml)
            EbsEncryptionSupport.parse
      ; ebs_optimized_info =
          Aws.Util.option_bind
            (Aws.Xml.member "ebsOptimizedInfo" xml)
            EbsOptimizedInfo.parse
      ; nvme_support =
          Aws.Util.option_bind (Aws.Xml.member "nvmeSupport" xml) EbsNvmeSupport.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.nvme_support (fun f ->
               Aws.Query.Pair ("NvmeSupport", EbsNvmeSupport.to_query f))
         ; Aws.Util.option_map v.ebs_optimized_info (fun f ->
               Aws.Query.Pair ("EbsOptimizedInfo", EbsOptimizedInfo.to_query f))
         ; Aws.Util.option_map v.encryption_support (fun f ->
               Aws.Query.Pair ("EncryptionSupport", EbsEncryptionSupport.to_query f))
         ; Aws.Util.option_map v.ebs_optimized_support (fun f ->
               Aws.Query.Pair ("EbsOptimizedSupport", EbsOptimizedSupport.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.nvme_support (fun f ->
               "nvmeSupport", EbsNvmeSupport.to_json f)
         ; Aws.Util.option_map v.ebs_optimized_info (fun f ->
               "ebsOptimizedInfo", EbsOptimizedInfo.to_json f)
         ; Aws.Util.option_map v.encryption_support (fun f ->
               "encryptionSupport", EbsEncryptionSupport.to_json f)
         ; Aws.Util.option_map v.ebs_optimized_support (fun f ->
               "ebsOptimizedSupport", EbsOptimizedSupport.to_json f)
         ])

  let of_json j =
    { ebs_optimized_support =
        Aws.Util.option_map
          (Aws.Json.lookup j "ebsOptimizedSupport")
          EbsOptimizedSupport.of_json
    ; encryption_support =
        Aws.Util.option_map
          (Aws.Json.lookup j "encryptionSupport")
          EbsEncryptionSupport.of_json
    ; ebs_optimized_info =
        Aws.Util.option_map
          (Aws.Json.lookup j "ebsOptimizedInfo")
          EbsOptimizedInfo.of_json
    ; nvme_support =
        Aws.Util.option_map (Aws.Json.lookup j "nvmeSupport") EbsNvmeSupport.of_json
    }
end

module InstanceTypeInfo = struct
  type t =
    { instance_type : InstanceType.t option
    ; current_generation : Boolean.t option
    ; free_tier_eligible : Boolean.t option
    ; supported_usage_classes : UsageClassTypeList.t
    ; supported_root_device_types : RootDeviceTypeList.t
    ; supported_virtualization_types : VirtualizationTypeList.t
    ; bare_metal : Boolean.t option
    ; hypervisor : InstanceTypeHypervisor.t option
    ; processor_info : ProcessorInfo.t option
    ; v_cpu_info : VCpuInfo.t option
    ; memory_info : MemoryInfo.t option
    ; instance_storage_supported : Boolean.t option
    ; instance_storage_info : InstanceStorageInfo.t option
    ; ebs_info : EbsInfo.t option
    ; network_info : NetworkInfo.t option
    ; gpu_info : GpuInfo.t option
    ; fpga_info : FpgaInfo.t option
    ; placement_group_info : PlacementGroupInfo.t option
    ; inference_accelerator_info : InferenceAcceleratorInfo.t option
    ; hibernation_supported : Boolean.t option
    ; burstable_performance_supported : Boolean.t option
    ; dedicated_hosts_supported : Boolean.t option
    ; auto_recovery_supported : Boolean.t option
    }

  let make
      ?instance_type
      ?current_generation
      ?free_tier_eligible
      ?(supported_usage_classes = [])
      ?(supported_root_device_types = [])
      ?(supported_virtualization_types = [])
      ?bare_metal
      ?hypervisor
      ?processor_info
      ?v_cpu_info
      ?memory_info
      ?instance_storage_supported
      ?instance_storage_info
      ?ebs_info
      ?network_info
      ?gpu_info
      ?fpga_info
      ?placement_group_info
      ?inference_accelerator_info
      ?hibernation_supported
      ?burstable_performance_supported
      ?dedicated_hosts_supported
      ?auto_recovery_supported
      () =
    { instance_type
    ; current_generation
    ; free_tier_eligible
    ; supported_usage_classes
    ; supported_root_device_types
    ; supported_virtualization_types
    ; bare_metal
    ; hypervisor
    ; processor_info
    ; v_cpu_info
    ; memory_info
    ; instance_storage_supported
    ; instance_storage_info
    ; ebs_info
    ; network_info
    ; gpu_info
    ; fpga_info
    ; placement_group_info
    ; inference_accelerator_info
    ; hibernation_supported
    ; burstable_performance_supported
    ; dedicated_hosts_supported
    ; auto_recovery_supported
    }

  let parse xml =
    Some
      { instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) InstanceType.parse
      ; current_generation =
          Aws.Util.option_bind (Aws.Xml.member "currentGeneration" xml) Boolean.parse
      ; free_tier_eligible =
          Aws.Util.option_bind (Aws.Xml.member "freeTierEligible" xml) Boolean.parse
      ; supported_usage_classes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "supportedUsageClasses" xml)
               UsageClassTypeList.parse)
      ; supported_root_device_types =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "supportedRootDeviceTypes" xml)
               RootDeviceTypeList.parse)
      ; supported_virtualization_types =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "supportedVirtualizationTypes" xml)
               VirtualizationTypeList.parse)
      ; bare_metal = Aws.Util.option_bind (Aws.Xml.member "bareMetal" xml) Boolean.parse
      ; hypervisor =
          Aws.Util.option_bind
            (Aws.Xml.member "hypervisor" xml)
            InstanceTypeHypervisor.parse
      ; processor_info =
          Aws.Util.option_bind (Aws.Xml.member "processorInfo" xml) ProcessorInfo.parse
      ; v_cpu_info = Aws.Util.option_bind (Aws.Xml.member "vCpuInfo" xml) VCpuInfo.parse
      ; memory_info =
          Aws.Util.option_bind (Aws.Xml.member "memoryInfo" xml) MemoryInfo.parse
      ; instance_storage_supported =
          Aws.Util.option_bind
            (Aws.Xml.member "instanceStorageSupported" xml)
            Boolean.parse
      ; instance_storage_info =
          Aws.Util.option_bind
            (Aws.Xml.member "instanceStorageInfo" xml)
            InstanceStorageInfo.parse
      ; ebs_info = Aws.Util.option_bind (Aws.Xml.member "ebsInfo" xml) EbsInfo.parse
      ; network_info =
          Aws.Util.option_bind (Aws.Xml.member "networkInfo" xml) NetworkInfo.parse
      ; gpu_info = Aws.Util.option_bind (Aws.Xml.member "gpuInfo" xml) GpuInfo.parse
      ; fpga_info = Aws.Util.option_bind (Aws.Xml.member "fpgaInfo" xml) FpgaInfo.parse
      ; placement_group_info =
          Aws.Util.option_bind
            (Aws.Xml.member "placementGroupInfo" xml)
            PlacementGroupInfo.parse
      ; inference_accelerator_info =
          Aws.Util.option_bind
            (Aws.Xml.member "inferenceAcceleratorInfo" xml)
            InferenceAcceleratorInfo.parse
      ; hibernation_supported =
          Aws.Util.option_bind (Aws.Xml.member "hibernationSupported" xml) Boolean.parse
      ; burstable_performance_supported =
          Aws.Util.option_bind
            (Aws.Xml.member "burstablePerformanceSupported" xml)
            Boolean.parse
      ; dedicated_hosts_supported =
          Aws.Util.option_bind
            (Aws.Xml.member "dedicatedHostsSupported" xml)
            Boolean.parse
      ; auto_recovery_supported =
          Aws.Util.option_bind (Aws.Xml.member "autoRecoverySupported" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.auto_recovery_supported (fun f ->
               Aws.Query.Pair ("AutoRecoverySupported", Boolean.to_query f))
         ; Aws.Util.option_map v.dedicated_hosts_supported (fun f ->
               Aws.Query.Pair ("DedicatedHostsSupported", Boolean.to_query f))
         ; Aws.Util.option_map v.burstable_performance_supported (fun f ->
               Aws.Query.Pair ("BurstablePerformanceSupported", Boolean.to_query f))
         ; Aws.Util.option_map v.hibernation_supported (fun f ->
               Aws.Query.Pair ("HibernationSupported", Boolean.to_query f))
         ; Aws.Util.option_map v.inference_accelerator_info (fun f ->
               Aws.Query.Pair
                 ("InferenceAcceleratorInfo", InferenceAcceleratorInfo.to_query f))
         ; Aws.Util.option_map v.placement_group_info (fun f ->
               Aws.Query.Pair ("PlacementGroupInfo", PlacementGroupInfo.to_query f))
         ; Aws.Util.option_map v.fpga_info (fun f ->
               Aws.Query.Pair ("FpgaInfo", FpgaInfo.to_query f))
         ; Aws.Util.option_map v.gpu_info (fun f ->
               Aws.Query.Pair ("GpuInfo", GpuInfo.to_query f))
         ; Aws.Util.option_map v.network_info (fun f ->
               Aws.Query.Pair ("NetworkInfo", NetworkInfo.to_query f))
         ; Aws.Util.option_map v.ebs_info (fun f ->
               Aws.Query.Pair ("EbsInfo", EbsInfo.to_query f))
         ; Aws.Util.option_map v.instance_storage_info (fun f ->
               Aws.Query.Pair ("InstanceStorageInfo", InstanceStorageInfo.to_query f))
         ; Aws.Util.option_map v.instance_storage_supported (fun f ->
               Aws.Query.Pair ("InstanceStorageSupported", Boolean.to_query f))
         ; Aws.Util.option_map v.memory_info (fun f ->
               Aws.Query.Pair ("MemoryInfo", MemoryInfo.to_query f))
         ; Aws.Util.option_map v.v_cpu_info (fun f ->
               Aws.Query.Pair ("VCpuInfo", VCpuInfo.to_query f))
         ; Aws.Util.option_map v.processor_info (fun f ->
               Aws.Query.Pair ("ProcessorInfo", ProcessorInfo.to_query f))
         ; Aws.Util.option_map v.hypervisor (fun f ->
               Aws.Query.Pair ("Hypervisor", InstanceTypeHypervisor.to_query f))
         ; Aws.Util.option_map v.bare_metal (fun f ->
               Aws.Query.Pair ("BareMetal", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "SupportedVirtualizationTypes"
                , VirtualizationTypeList.to_query v.supported_virtualization_types ))
         ; Some
             (Aws.Query.Pair
                ( "SupportedRootDeviceTypes"
                , RootDeviceTypeList.to_query v.supported_root_device_types ))
         ; Some
             (Aws.Query.Pair
                ( "SupportedUsageClasses"
                , UsageClassTypeList.to_query v.supported_usage_classes ))
         ; Aws.Util.option_map v.free_tier_eligible (fun f ->
               Aws.Query.Pair ("FreeTierEligible", Boolean.to_query f))
         ; Aws.Util.option_map v.current_generation (fun f ->
               Aws.Query.Pair ("CurrentGeneration", Boolean.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", InstanceType.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.auto_recovery_supported (fun f ->
               "autoRecoverySupported", Boolean.to_json f)
         ; Aws.Util.option_map v.dedicated_hosts_supported (fun f ->
               "dedicatedHostsSupported", Boolean.to_json f)
         ; Aws.Util.option_map v.burstable_performance_supported (fun f ->
               "burstablePerformanceSupported", Boolean.to_json f)
         ; Aws.Util.option_map v.hibernation_supported (fun f ->
               "hibernationSupported", Boolean.to_json f)
         ; Aws.Util.option_map v.inference_accelerator_info (fun f ->
               "inferenceAcceleratorInfo", InferenceAcceleratorInfo.to_json f)
         ; Aws.Util.option_map v.placement_group_info (fun f ->
               "placementGroupInfo", PlacementGroupInfo.to_json f)
         ; Aws.Util.option_map v.fpga_info (fun f -> "fpgaInfo", FpgaInfo.to_json f)
         ; Aws.Util.option_map v.gpu_info (fun f -> "gpuInfo", GpuInfo.to_json f)
         ; Aws.Util.option_map v.network_info (fun f ->
               "networkInfo", NetworkInfo.to_json f)
         ; Aws.Util.option_map v.ebs_info (fun f -> "ebsInfo", EbsInfo.to_json f)
         ; Aws.Util.option_map v.instance_storage_info (fun f ->
               "instanceStorageInfo", InstanceStorageInfo.to_json f)
         ; Aws.Util.option_map v.instance_storage_supported (fun f ->
               "instanceStorageSupported", Boolean.to_json f)
         ; Aws.Util.option_map v.memory_info (fun f -> "memoryInfo", MemoryInfo.to_json f)
         ; Aws.Util.option_map v.v_cpu_info (fun f -> "vCpuInfo", VCpuInfo.to_json f)
         ; Aws.Util.option_map v.processor_info (fun f ->
               "processorInfo", ProcessorInfo.to_json f)
         ; Aws.Util.option_map v.hypervisor (fun f ->
               "hypervisor", InstanceTypeHypervisor.to_json f)
         ; Aws.Util.option_map v.bare_metal (fun f -> "bareMetal", Boolean.to_json f)
         ; Some
             ( "supportedVirtualizationTypes"
             , VirtualizationTypeList.to_json v.supported_virtualization_types )
         ; Some
             ( "supportedRootDeviceTypes"
             , RootDeviceTypeList.to_json v.supported_root_device_types )
         ; Some
             ( "supportedUsageClasses"
             , UsageClassTypeList.to_json v.supported_usage_classes )
         ; Aws.Util.option_map v.free_tier_eligible (fun f ->
               "freeTierEligible", Boolean.to_json f)
         ; Aws.Util.option_map v.current_generation (fun f ->
               "currentGeneration", Boolean.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f ->
               "instanceType", InstanceType.to_json f)
         ])

  let of_json j =
    { instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") InstanceType.of_json
    ; current_generation =
        Aws.Util.option_map (Aws.Json.lookup j "currentGeneration") Boolean.of_json
    ; free_tier_eligible =
        Aws.Util.option_map (Aws.Json.lookup j "freeTierEligible") Boolean.of_json
    ; supported_usage_classes =
        UsageClassTypeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "supportedUsageClasses"))
    ; supported_root_device_types =
        RootDeviceTypeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "supportedRootDeviceTypes"))
    ; supported_virtualization_types =
        VirtualizationTypeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "supportedVirtualizationTypes"))
    ; bare_metal = Aws.Util.option_map (Aws.Json.lookup j "bareMetal") Boolean.of_json
    ; hypervisor =
        Aws.Util.option_map
          (Aws.Json.lookup j "hypervisor")
          InstanceTypeHypervisor.of_json
    ; processor_info =
        Aws.Util.option_map (Aws.Json.lookup j "processorInfo") ProcessorInfo.of_json
    ; v_cpu_info = Aws.Util.option_map (Aws.Json.lookup j "vCpuInfo") VCpuInfo.of_json
    ; memory_info =
        Aws.Util.option_map (Aws.Json.lookup j "memoryInfo") MemoryInfo.of_json
    ; instance_storage_supported =
        Aws.Util.option_map (Aws.Json.lookup j "instanceStorageSupported") Boolean.of_json
    ; instance_storage_info =
        Aws.Util.option_map
          (Aws.Json.lookup j "instanceStorageInfo")
          InstanceStorageInfo.of_json
    ; ebs_info = Aws.Util.option_map (Aws.Json.lookup j "ebsInfo") EbsInfo.of_json
    ; network_info =
        Aws.Util.option_map (Aws.Json.lookup j "networkInfo") NetworkInfo.of_json
    ; gpu_info = Aws.Util.option_map (Aws.Json.lookup j "gpuInfo") GpuInfo.of_json
    ; fpga_info = Aws.Util.option_map (Aws.Json.lookup j "fpgaInfo") FpgaInfo.of_json
    ; placement_group_info =
        Aws.Util.option_map
          (Aws.Json.lookup j "placementGroupInfo")
          PlacementGroupInfo.of_json
    ; inference_accelerator_info =
        Aws.Util.option_map
          (Aws.Json.lookup j "inferenceAcceleratorInfo")
          InferenceAcceleratorInfo.of_json
    ; hibernation_supported =
        Aws.Util.option_map (Aws.Json.lookup j "hibernationSupported") Boolean.of_json
    ; burstable_performance_supported =
        Aws.Util.option_map
          (Aws.Json.lookup j "burstablePerformanceSupported")
          Boolean.of_json
    ; dedicated_hosts_supported =
        Aws.Util.option_map (Aws.Json.lookup j "dedicatedHostsSupported") Boolean.of_json
    ; auto_recovery_supported =
        Aws.Util.option_map (Aws.Json.lookup j "autoRecoverySupported") Boolean.of_json
    }
end

module InstanceTypeInfoList = struct
  type t = InstanceTypeInfo.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map InstanceTypeInfo.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list InstanceTypeInfo.to_query v

  let to_json v = `List (List.map InstanceTypeInfo.to_json v)

  let of_json j = Aws.Json.to_list InstanceTypeInfo.of_json j
end

module PrefixListState = struct
  type t =
    | Create_in_progress
    | Create_complete
    | Create_failed
    | Modify_in_progress
    | Modify_complete
    | Modify_failed
    | Restore_in_progress
    | Restore_complete
    | Restore_failed
    | Delete_in_progress
    | Delete_complete
    | Delete_failed

  let str_to_t =
    [ "delete-failed", Delete_failed
    ; "delete-complete", Delete_complete
    ; "delete-in-progress", Delete_in_progress
    ; "restore-failed", Restore_failed
    ; "restore-complete", Restore_complete
    ; "restore-in-progress", Restore_in_progress
    ; "modify-failed", Modify_failed
    ; "modify-complete", Modify_complete
    ; "modify-in-progress", Modify_in_progress
    ; "create-failed", Create_failed
    ; "create-complete", Create_complete
    ; "create-in-progress", Create_in_progress
    ]

  let t_to_str =
    [ Delete_failed, "delete-failed"
    ; Delete_complete, "delete-complete"
    ; Delete_in_progress, "delete-in-progress"
    ; Restore_failed, "restore-failed"
    ; Restore_complete, "restore-complete"
    ; Restore_in_progress, "restore-in-progress"
    ; Modify_failed, "modify-failed"
    ; Modify_complete, "modify-complete"
    ; Modify_in_progress, "modify-in-progress"
    ; Create_failed, "create-failed"
    ; Create_complete, "create-complete"
    ; Create_in_progress, "create-in-progress"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ManagedPrefixList = struct
  type t =
    { prefix_list_id : String.t option
    ; address_family : String.t option
    ; state : PrefixListState.t option
    ; state_message : String.t option
    ; prefix_list_arn : String.t option
    ; prefix_list_name : String.t option
    ; max_entries : Integer.t option
    ; version : Long.t option
    ; tags : TagList.t
    ; owner_id : String.t option
    }

  let make
      ?prefix_list_id
      ?address_family
      ?state
      ?state_message
      ?prefix_list_arn
      ?prefix_list_name
      ?max_entries
      ?version
      ?(tags = [])
      ?owner_id
      () =
    { prefix_list_id
    ; address_family
    ; state
    ; state_message
    ; prefix_list_arn
    ; prefix_list_name
    ; max_entries
    ; version
    ; tags
    ; owner_id
    }

  let parse xml =
    Some
      { prefix_list_id =
          Aws.Util.option_bind (Aws.Xml.member "prefixListId" xml) String.parse
      ; address_family =
          Aws.Util.option_bind (Aws.Xml.member "addressFamily" xml) String.parse
      ; state = Aws.Util.option_bind (Aws.Xml.member "state" xml) PrefixListState.parse
      ; state_message =
          Aws.Util.option_bind (Aws.Xml.member "stateMessage" xml) String.parse
      ; prefix_list_arn =
          Aws.Util.option_bind (Aws.Xml.member "prefixListArn" xml) String.parse
      ; prefix_list_name =
          Aws.Util.option_bind (Aws.Xml.member "prefixListName" xml) String.parse
      ; max_entries = Aws.Util.option_bind (Aws.Xml.member "maxEntries" xml) Integer.parse
      ; version = Aws.Util.option_bind (Aws.Xml.member "version" xml) Long.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.version (fun f ->
               Aws.Query.Pair ("Version", Long.to_query f))
         ; Aws.Util.option_map v.max_entries (fun f ->
               Aws.Query.Pair ("MaxEntries", Integer.to_query f))
         ; Aws.Util.option_map v.prefix_list_name (fun f ->
               Aws.Query.Pair ("PrefixListName", String.to_query f))
         ; Aws.Util.option_map v.prefix_list_arn (fun f ->
               Aws.Query.Pair ("PrefixListArn", String.to_query f))
         ; Aws.Util.option_map v.state_message (fun f ->
               Aws.Query.Pair ("StateMessage", String.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", PrefixListState.to_query f))
         ; Aws.Util.option_map v.address_family (fun f ->
               Aws.Query.Pair ("AddressFamily", String.to_query f))
         ; Aws.Util.option_map v.prefix_list_id (fun f ->
               Aws.Query.Pair ("PrefixListId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.version (fun f -> "version", Long.to_json f)
         ; Aws.Util.option_map v.max_entries (fun f -> "maxEntries", Integer.to_json f)
         ; Aws.Util.option_map v.prefix_list_name (fun f ->
               "prefixListName", String.to_json f)
         ; Aws.Util.option_map v.prefix_list_arn (fun f ->
               "prefixListArn", String.to_json f)
         ; Aws.Util.option_map v.state_message (fun f -> "stateMessage", String.to_json f)
         ; Aws.Util.option_map v.state (fun f -> "state", PrefixListState.to_json f)
         ; Aws.Util.option_map v.address_family (fun f ->
               "addressFamily", String.to_json f)
         ; Aws.Util.option_map v.prefix_list_id (fun f ->
               "prefixListId", String.to_json f)
         ])

  let of_json j =
    { prefix_list_id =
        Aws.Util.option_map (Aws.Json.lookup j "prefixListId") String.of_json
    ; address_family =
        Aws.Util.option_map (Aws.Json.lookup j "addressFamily") String.of_json
    ; state = Aws.Util.option_map (Aws.Json.lookup j "state") PrefixListState.of_json
    ; state_message =
        Aws.Util.option_map (Aws.Json.lookup j "stateMessage") String.of_json
    ; prefix_list_arn =
        Aws.Util.option_map (Aws.Json.lookup j "prefixListArn") String.of_json
    ; prefix_list_name =
        Aws.Util.option_map (Aws.Json.lookup j "prefixListName") String.of_json
    ; max_entries = Aws.Util.option_map (Aws.Json.lookup j "maxEntries") Integer.of_json
    ; version = Aws.Util.option_map (Aws.Json.lookup j "version") Long.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    }
end

module RestoreManagedPrefixListVersionResult = struct
  type t = { prefix_list : ManagedPrefixList.t option }

  let make ?prefix_list () = { prefix_list }

  let parse xml =
    Some
      { prefix_list =
          Aws.Util.option_bind (Aws.Xml.member "prefixList" xml) ManagedPrefixList.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.prefix_list (fun f ->
               Aws.Query.Pair ("PrefixList", ManagedPrefixList.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.prefix_list (fun f ->
               "prefixList", ManagedPrefixList.to_json f)
         ])

  let of_json j =
    { prefix_list =
        Aws.Util.option_map (Aws.Json.lookup j "prefixList") ManagedPrefixList.of_json
    }
end

module DescribeScheduledInstanceAvailabilityResult = struct
  type t =
    { next_token : String.t option
    ; scheduled_instance_availability_set : ScheduledInstanceAvailabilitySet.t
    }

  let make ?next_token ?(scheduled_instance_availability_set = []) () =
    { next_token; scheduled_instance_availability_set }

  let parse xml =
    Some
      { next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; scheduled_instance_availability_set =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "scheduledInstanceAvailabilitySet" xml)
               ScheduledInstanceAvailabilitySet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "ScheduledInstanceAvailabilitySet"
                , ScheduledInstanceAvailabilitySet.to_query
                    v.scheduled_instance_availability_set ))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "scheduledInstanceAvailabilitySet"
             , ScheduledInstanceAvailabilitySet.to_json
                 v.scheduled_instance_availability_set )
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ])

  let of_json j =
    { next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; scheduled_instance_availability_set =
        ScheduledInstanceAvailabilitySet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "scheduledInstanceAvailabilitySet"))
    }
end

module DeleteKeyPairRequest = struct
  type t =
    { key_name : String.t option
    ; key_pair_id : String.t option
    ; dry_run : Boolean.t option
    }

  let make ?key_name ?key_pair_id ?dry_run () = { key_name; key_pair_id; dry_run }

  let parse xml =
    Some
      { key_name = Aws.Util.option_bind (Aws.Xml.member "KeyName" xml) String.parse
      ; key_pair_id = Aws.Util.option_bind (Aws.Xml.member "KeyPairId" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.key_pair_id (fun f ->
               Aws.Query.Pair ("KeyPairId", String.to_query f))
         ; Aws.Util.option_map v.key_name (fun f ->
               Aws.Query.Pair ("KeyName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.key_pair_id (fun f -> "KeyPairId", String.to_json f)
         ; Aws.Util.option_map v.key_name (fun f -> "KeyName", String.to_json f)
         ])

  let of_json j =
    { key_name = Aws.Util.option_map (Aws.Json.lookup j "KeyName") String.of_json
    ; key_pair_id = Aws.Util.option_map (Aws.Json.lookup j "KeyPairId") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module AuthorizeClientVpnIngressResult = struct
  type t = { status : ClientVpnAuthorizationRuleStatus.t option }

  let make ?status () = { status }

  let parse xml =
    Some
      { status =
          Aws.Util.option_bind
            (Aws.Xml.member "status" xml)
            ClientVpnAuthorizationRuleStatus.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", ClientVpnAuthorizationRuleStatus.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               "status", ClientVpnAuthorizationRuleStatus.to_json f)
         ])

  let of_json j =
    { status =
        Aws.Util.option_map
          (Aws.Json.lookup j "status")
          ClientVpnAuthorizationRuleStatus.of_json
    }
end

module AssociateDhcpOptionsRequest = struct
  type t =
    { dhcp_options_id : String.t
    ; vpc_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~dhcp_options_id ~vpc_id ?dry_run () = { dhcp_options_id; vpc_id; dry_run }

  let parse xml =
    Some
      { dhcp_options_id =
          Aws.Xml.required
            "DhcpOptionsId"
            (Aws.Util.option_bind (Aws.Xml.member "DhcpOptionsId" xml) String.parse)
      ; vpc_id =
          Aws.Xml.required
            "VpcId"
            (Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ; Some (Aws.Query.Pair ("DhcpOptionsId", String.to_query v.dhcp_options_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("VpcId", String.to_json v.vpc_id)
         ; Some ("DhcpOptionsId", String.to_json v.dhcp_options_id)
         ])

  let of_json j =
    { dhcp_options_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DhcpOptionsId"))
    ; vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module PricingDetail = struct
  type t =
    { count : Integer.t option
    ; price : Double.t option
    }

  let make ?count ?price () = { count; price }

  let parse xml =
    Some
      { count = Aws.Util.option_bind (Aws.Xml.member "count" xml) Integer.parse
      ; price = Aws.Util.option_bind (Aws.Xml.member "price" xml) Double.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.price (fun f ->
               Aws.Query.Pair ("Price", Double.to_query f))
         ; Aws.Util.option_map v.count (fun f ->
               Aws.Query.Pair ("Count", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.price (fun f -> "price", Double.to_json f)
         ; Aws.Util.option_map v.count (fun f -> "count", Integer.to_json f)
         ])

  let of_json j =
    { count = Aws.Util.option_map (Aws.Json.lookup j "count") Integer.of_json
    ; price = Aws.Util.option_map (Aws.Json.lookup j "price") Double.of_json
    }
end

module PricingDetailsList = struct
  type t = PricingDetail.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map PricingDetail.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list PricingDetail.to_query v

  let to_json v = `List (List.map PricingDetail.to_json v)

  let of_json j = Aws.Json.to_list PricingDetail.of_json j
end

module ReservedInstancesOffering = struct
  type t =
    { availability_zone : String.t option
    ; duration : Long.t option
    ; fixed_price : Float.t option
    ; instance_type : InstanceType.t option
    ; product_description : RIProductDescription.t option
    ; reserved_instances_offering_id : String.t option
    ; usage_price : Float.t option
    ; currency_code : CurrencyCodeValues.t option
    ; instance_tenancy : Tenancy.t option
    ; marketplace : Boolean.t option
    ; offering_class : OfferingClassType.t option
    ; offering_type : OfferingTypeValues.t option
    ; pricing_details : PricingDetailsList.t
    ; recurring_charges : RecurringChargesList.t
    ; scope : Scope.t option
    }

  let make
      ?availability_zone
      ?duration
      ?fixed_price
      ?instance_type
      ?product_description
      ?reserved_instances_offering_id
      ?usage_price
      ?currency_code
      ?instance_tenancy
      ?marketplace
      ?offering_class
      ?offering_type
      ?(pricing_details = [])
      ?(recurring_charges = [])
      ?scope
      () =
    { availability_zone
    ; duration
    ; fixed_price
    ; instance_type
    ; product_description
    ; reserved_instances_offering_id
    ; usage_price
    ; currency_code
    ; instance_tenancy
    ; marketplace
    ; offering_class
    ; offering_type
    ; pricing_details
    ; recurring_charges
    ; scope
    }

  let parse xml =
    Some
      { availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; duration = Aws.Util.option_bind (Aws.Xml.member "duration" xml) Long.parse
      ; fixed_price = Aws.Util.option_bind (Aws.Xml.member "fixedPrice" xml) Float.parse
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) InstanceType.parse
      ; product_description =
          Aws.Util.option_bind
            (Aws.Xml.member "productDescription" xml)
            RIProductDescription.parse
      ; reserved_instances_offering_id =
          Aws.Util.option_bind
            (Aws.Xml.member "reservedInstancesOfferingId" xml)
            String.parse
      ; usage_price = Aws.Util.option_bind (Aws.Xml.member "usagePrice" xml) Float.parse
      ; currency_code =
          Aws.Util.option_bind
            (Aws.Xml.member "currencyCode" xml)
            CurrencyCodeValues.parse
      ; instance_tenancy =
          Aws.Util.option_bind (Aws.Xml.member "instanceTenancy" xml) Tenancy.parse
      ; marketplace =
          Aws.Util.option_bind (Aws.Xml.member "marketplace" xml) Boolean.parse
      ; offering_class =
          Aws.Util.option_bind
            (Aws.Xml.member "offeringClass" xml)
            OfferingClassType.parse
      ; offering_type =
          Aws.Util.option_bind
            (Aws.Xml.member "offeringType" xml)
            OfferingTypeValues.parse
      ; pricing_details =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "pricingDetailsSet" xml)
               PricingDetailsList.parse)
      ; recurring_charges =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "recurringCharges" xml)
               RecurringChargesList.parse)
      ; scope = Aws.Util.option_bind (Aws.Xml.member "scope" xml) Scope.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.scope (fun f ->
               Aws.Query.Pair ("Scope", Scope.to_query f))
         ; Some
             (Aws.Query.Pair
                ("RecurringCharges", RecurringChargesList.to_query v.recurring_charges))
         ; Some
             (Aws.Query.Pair
                ("PricingDetailsSet", PricingDetailsList.to_query v.pricing_details))
         ; Aws.Util.option_map v.offering_type (fun f ->
               Aws.Query.Pair ("OfferingType", OfferingTypeValues.to_query f))
         ; Aws.Util.option_map v.offering_class (fun f ->
               Aws.Query.Pair ("OfferingClass", OfferingClassType.to_query f))
         ; Aws.Util.option_map v.marketplace (fun f ->
               Aws.Query.Pair ("Marketplace", Boolean.to_query f))
         ; Aws.Util.option_map v.instance_tenancy (fun f ->
               Aws.Query.Pair ("InstanceTenancy", Tenancy.to_query f))
         ; Aws.Util.option_map v.currency_code (fun f ->
               Aws.Query.Pair ("CurrencyCode", CurrencyCodeValues.to_query f))
         ; Aws.Util.option_map v.usage_price (fun f ->
               Aws.Query.Pair ("UsagePrice", Float.to_query f))
         ; Aws.Util.option_map v.reserved_instances_offering_id (fun f ->
               Aws.Query.Pair ("ReservedInstancesOfferingId", String.to_query f))
         ; Aws.Util.option_map v.product_description (fun f ->
               Aws.Query.Pair ("ProductDescription", RIProductDescription.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", InstanceType.to_query f))
         ; Aws.Util.option_map v.fixed_price (fun f ->
               Aws.Query.Pair ("FixedPrice", Float.to_query f))
         ; Aws.Util.option_map v.duration (fun f ->
               Aws.Query.Pair ("Duration", Long.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.scope (fun f -> "scope", Scope.to_json f)
         ; Some ("recurringCharges", RecurringChargesList.to_json v.recurring_charges)
         ; Some ("pricingDetailsSet", PricingDetailsList.to_json v.pricing_details)
         ; Aws.Util.option_map v.offering_type (fun f ->
               "offeringType", OfferingTypeValues.to_json f)
         ; Aws.Util.option_map v.offering_class (fun f ->
               "offeringClass", OfferingClassType.to_json f)
         ; Aws.Util.option_map v.marketplace (fun f -> "marketplace", Boolean.to_json f)
         ; Aws.Util.option_map v.instance_tenancy (fun f ->
               "instanceTenancy", Tenancy.to_json f)
         ; Aws.Util.option_map v.currency_code (fun f ->
               "currencyCode", CurrencyCodeValues.to_json f)
         ; Aws.Util.option_map v.usage_price (fun f -> "usagePrice", Float.to_json f)
         ; Aws.Util.option_map v.reserved_instances_offering_id (fun f ->
               "reservedInstancesOfferingId", String.to_json f)
         ; Aws.Util.option_map v.product_description (fun f ->
               "productDescription", RIProductDescription.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f ->
               "instanceType", InstanceType.to_json f)
         ; Aws.Util.option_map v.fixed_price (fun f -> "fixedPrice", Float.to_json f)
         ; Aws.Util.option_map v.duration (fun f -> "duration", Long.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ])

  let of_json j =
    { availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; duration = Aws.Util.option_map (Aws.Json.lookup j "duration") Long.of_json
    ; fixed_price = Aws.Util.option_map (Aws.Json.lookup j "fixedPrice") Float.of_json
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") InstanceType.of_json
    ; product_description =
        Aws.Util.option_map
          (Aws.Json.lookup j "productDescription")
          RIProductDescription.of_json
    ; reserved_instances_offering_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "reservedInstancesOfferingId")
          String.of_json
    ; usage_price = Aws.Util.option_map (Aws.Json.lookup j "usagePrice") Float.of_json
    ; currency_code =
        Aws.Util.option_map (Aws.Json.lookup j "currencyCode") CurrencyCodeValues.of_json
    ; instance_tenancy =
        Aws.Util.option_map (Aws.Json.lookup j "instanceTenancy") Tenancy.of_json
    ; marketplace = Aws.Util.option_map (Aws.Json.lookup j "marketplace") Boolean.of_json
    ; offering_class =
        Aws.Util.option_map (Aws.Json.lookup j "offeringClass") OfferingClassType.of_json
    ; offering_type =
        Aws.Util.option_map (Aws.Json.lookup j "offeringType") OfferingTypeValues.of_json
    ; pricing_details =
        PricingDetailsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "pricingDetailsSet"))
    ; recurring_charges =
        RecurringChargesList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "recurringCharges"))
    ; scope = Aws.Util.option_map (Aws.Json.lookup j "scope") Scope.of_json
    }
end

module ReservedInstancesOfferingList = struct
  type t = ReservedInstancesOffering.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ReservedInstancesOffering.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ReservedInstancesOffering.to_query v

  let to_json v = `List (List.map ReservedInstancesOffering.to_json v)

  let of_json j = Aws.Json.to_list ReservedInstancesOffering.of_json j
end

module DescribeReservedInstancesOfferingsResult = struct
  type t =
    { reserved_instances_offerings : ReservedInstancesOfferingList.t
    ; next_token : String.t option
    }

  let make ?(reserved_instances_offerings = []) ?next_token () =
    { reserved_instances_offerings; next_token }

  let parse xml =
    Some
      { reserved_instances_offerings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "reservedInstancesOfferingsSet" xml)
               ReservedInstancesOfferingList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ReservedInstancesOfferingsSet"
                , ReservedInstancesOfferingList.to_query v.reserved_instances_offerings ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "reservedInstancesOfferingsSet"
             , ReservedInstancesOfferingList.to_json v.reserved_instances_offerings )
         ])

  let of_json j =
    { reserved_instances_offerings =
        ReservedInstancesOfferingList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "reservedInstancesOfferingsSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module ModifyTransitGatewayPrefixListReferenceResult = struct
  type t =
    { transit_gateway_prefix_list_reference : TransitGatewayPrefixListReference.t option }

  let make ?transit_gateway_prefix_list_reference () =
    { transit_gateway_prefix_list_reference }

  let parse xml =
    Some
      { transit_gateway_prefix_list_reference =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayPrefixListReference" xml)
            TransitGatewayPrefixListReference.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_prefix_list_reference (fun f ->
               Aws.Query.Pair
                 ( "TransitGatewayPrefixListReference"
                 , TransitGatewayPrefixListReference.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_prefix_list_reference (fun f ->
               ( "transitGatewayPrefixListReference"
               , TransitGatewayPrefixListReference.to_json f ))
         ])

  let of_json j =
    { transit_gateway_prefix_list_reference =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayPrefixListReference")
          TransitGatewayPrefixListReference.of_json
    }
end

module UnsuccessfulInstanceCreditSpecificationErrorCode = struct
  type t =
    | InvalidInstanceID_Malformed
    | InvalidInstanceID_NotFound
    | IncorrectInstanceState
    | InstanceCreditSpecification_NotSupported

  let str_to_t =
    [ "InstanceCreditSpecification.NotSupported", InstanceCreditSpecification_NotSupported
    ; "IncorrectInstanceState", IncorrectInstanceState
    ; "InvalidInstanceID.NotFound", InvalidInstanceID_NotFound
    ; "InvalidInstanceID.Malformed", InvalidInstanceID_Malformed
    ]

  let t_to_str =
    [ InstanceCreditSpecification_NotSupported, "InstanceCreditSpecification.NotSupported"
    ; IncorrectInstanceState, "IncorrectInstanceState"
    ; InvalidInstanceID_NotFound, "InvalidInstanceID.NotFound"
    ; InvalidInstanceID_Malformed, "InvalidInstanceID.Malformed"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module UnsuccessfulInstanceCreditSpecificationItemError = struct
  type t =
    { code : UnsuccessfulInstanceCreditSpecificationErrorCode.t option
    ; message : String.t option
    }

  let make ?code ?message () = { code; message }

  let parse xml =
    Some
      { code =
          Aws.Util.option_bind
            (Aws.Xml.member "code" xml)
            UnsuccessfulInstanceCreditSpecificationErrorCode.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair
                 ("Code", UnsuccessfulInstanceCreditSpecificationErrorCode.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f)
         ; Aws.Util.option_map v.code (fun f ->
               "code", UnsuccessfulInstanceCreditSpecificationErrorCode.to_json f)
         ])

  let of_json j =
    { code =
        Aws.Util.option_map
          (Aws.Json.lookup j "code")
          UnsuccessfulInstanceCreditSpecificationErrorCode.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json
    }
end

module UnsuccessfulInstanceCreditSpecificationItem = struct
  type t =
    { instance_id : String.t option
    ; error : UnsuccessfulInstanceCreditSpecificationItemError.t option
    }

  let make ?instance_id ?error () = { instance_id; error }

  let parse xml =
    Some
      { instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      ; error =
          Aws.Util.option_bind
            (Aws.Xml.member "error" xml)
            UnsuccessfulInstanceCreditSpecificationItemError.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.error (fun f ->
               Aws.Query.Pair
                 ("Error", UnsuccessfulInstanceCreditSpecificationItemError.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.error (fun f ->
               "error", UnsuccessfulInstanceCreditSpecificationItemError.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ])

  let of_json j =
    { instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    ; error =
        Aws.Util.option_map
          (Aws.Json.lookup j "error")
          UnsuccessfulInstanceCreditSpecificationItemError.of_json
    }
end

module UnsuccessfulInstanceCreditSpecificationSet = struct
  type t = UnsuccessfulInstanceCreditSpecificationItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         UnsuccessfulInstanceCreditSpecificationItem.parse
         (Aws.Xml.members "item" xml))

  let to_query v =
    Aws.Query.to_query_list UnsuccessfulInstanceCreditSpecificationItem.to_query v

  let to_json v = `List (List.map UnsuccessfulInstanceCreditSpecificationItem.to_json v)

  let of_json j = Aws.Json.to_list UnsuccessfulInstanceCreditSpecificationItem.of_json j
end

module SuccessfulInstanceCreditSpecificationItem = struct
  type t = { instance_id : String.t option }

  let make ?instance_id () = { instance_id }

  let parse xml =
    Some
      { instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f) ])

  let of_json j =
    { instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json }
end

module SuccessfulInstanceCreditSpecificationSet = struct
  type t = SuccessfulInstanceCreditSpecificationItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         SuccessfulInstanceCreditSpecificationItem.parse
         (Aws.Xml.members "item" xml))

  let to_query v =
    Aws.Query.to_query_list SuccessfulInstanceCreditSpecificationItem.to_query v

  let to_json v = `List (List.map SuccessfulInstanceCreditSpecificationItem.to_json v)

  let of_json j = Aws.Json.to_list SuccessfulInstanceCreditSpecificationItem.of_json j
end

module ModifyInstanceCreditSpecificationResult = struct
  type t =
    { successful_instance_credit_specifications :
        SuccessfulInstanceCreditSpecificationSet.t
    ; unsuccessful_instance_credit_specifications :
        UnsuccessfulInstanceCreditSpecificationSet.t
    }

  let make
      ?(successful_instance_credit_specifications = [])
      ?(unsuccessful_instance_credit_specifications = [])
      () =
    { successful_instance_credit_specifications
    ; unsuccessful_instance_credit_specifications
    }

  let parse xml =
    Some
      { successful_instance_credit_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "successfulInstanceCreditSpecificationSet" xml)
               SuccessfulInstanceCreditSpecificationSet.parse)
      ; unsuccessful_instance_credit_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "unsuccessfulInstanceCreditSpecificationSet" xml)
               UnsuccessfulInstanceCreditSpecificationSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "UnsuccessfulInstanceCreditSpecificationSet"
                , UnsuccessfulInstanceCreditSpecificationSet.to_query
                    v.unsuccessful_instance_credit_specifications ))
         ; Some
             (Aws.Query.Pair
                ( "SuccessfulInstanceCreditSpecificationSet"
                , SuccessfulInstanceCreditSpecificationSet.to_query
                    v.successful_instance_credit_specifications ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "unsuccessfulInstanceCreditSpecificationSet"
             , UnsuccessfulInstanceCreditSpecificationSet.to_json
                 v.unsuccessful_instance_credit_specifications )
         ; Some
             ( "successfulInstanceCreditSpecificationSet"
             , SuccessfulInstanceCreditSpecificationSet.to_json
                 v.successful_instance_credit_specifications )
         ])

  let of_json j =
    { successful_instance_credit_specifications =
        SuccessfulInstanceCreditSpecificationSet.of_json
          (Aws.Util.of_option_exn
             (Aws.Json.lookup j "successfulInstanceCreditSpecificationSet"))
    ; unsuccessful_instance_credit_specifications =
        UnsuccessfulInstanceCreditSpecificationSet.of_json
          (Aws.Util.of_option_exn
             (Aws.Json.lookup j "unsuccessfulInstanceCreditSpecificationSet"))
    }
end

module LaunchTemplateElasticInferenceAcceleratorList = struct
  type t = LaunchTemplateElasticInferenceAccelerator.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         LaunchTemplateElasticInferenceAccelerator.parse
         (Aws.Xml.members "item" xml))

  let to_query v =
    Aws.Query.to_query_list LaunchTemplateElasticInferenceAccelerator.to_query v

  let to_json v = `List (List.map LaunchTemplateElasticInferenceAccelerator.to_json v)

  let of_json j = Aws.Json.to_list LaunchTemplateElasticInferenceAccelerator.of_json j
end

module CreateTransitGatewayPeeringAttachmentRequest = struct
  type t =
    { transit_gateway_id : String.t
    ; peer_transit_gateway_id : String.t
    ; peer_account_id : String.t
    ; peer_region : String.t
    ; tag_specifications : TagSpecificationList.t
    ; dry_run : Boolean.t option
    }

  let make
      ~transit_gateway_id
      ~peer_transit_gateway_id
      ~peer_account_id
      ~peer_region
      ?(tag_specifications = [])
      ?dry_run
      () =
    { transit_gateway_id
    ; peer_transit_gateway_id
    ; peer_account_id
    ; peer_region
    ; tag_specifications
    ; dry_run
    }

  let parse xml =
    Some
      { transit_gateway_id =
          Aws.Xml.required
            "TransitGatewayId"
            (Aws.Util.option_bind (Aws.Xml.member "TransitGatewayId" xml) String.parse)
      ; peer_transit_gateway_id =
          Aws.Xml.required
            "PeerTransitGatewayId"
            (Aws.Util.option_bind
               (Aws.Xml.member "PeerTransitGatewayId" xml)
               String.parse)
      ; peer_account_id =
          Aws.Xml.required
            "PeerAccountId"
            (Aws.Util.option_bind (Aws.Xml.member "PeerAccountId" xml) String.parse)
      ; peer_region =
          Aws.Xml.required
            "PeerRegion"
            (Aws.Util.option_bind (Aws.Xml.member "PeerRegion" xml) String.parse)
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Some (Aws.Query.Pair ("PeerRegion", String.to_query v.peer_region))
         ; Some (Aws.Query.Pair ("PeerAccountId", String.to_query v.peer_account_id))
         ; Some
             (Aws.Query.Pair
                ("PeerTransitGatewayId", String.to_query v.peer_transit_gateway_id))
         ; Some
             (Aws.Query.Pair ("TransitGatewayId", String.to_query v.transit_gateway_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Some ("PeerRegion", String.to_json v.peer_region)
         ; Some ("PeerAccountId", String.to_json v.peer_account_id)
         ; Some ("PeerTransitGatewayId", String.to_json v.peer_transit_gateway_id)
         ; Some ("TransitGatewayId", String.to_json v.transit_gateway_id)
         ])

  let of_json j =
    { transit_gateway_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayId"))
    ; peer_transit_gateway_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PeerTransitGatewayId"))
    ; peer_account_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PeerAccountId"))
    ; peer_region =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PeerRegion"))
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module CancelSpotFleetRequestsSuccessSet = struct
  type t = CancelSpotFleetRequestsSuccessItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map CancelSpotFleetRequestsSuccessItem.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list CancelSpotFleetRequestsSuccessItem.to_query v

  let to_json v = `List (List.map CancelSpotFleetRequestsSuccessItem.to_json v)

  let of_json j = Aws.Json.to_list CancelSpotFleetRequestsSuccessItem.of_json j
end

module ModifyTrafficMirrorSessionRequest = struct
  type t =
    { traffic_mirror_session_id : String.t
    ; traffic_mirror_target_id : String.t option
    ; traffic_mirror_filter_id : String.t option
    ; packet_length : Integer.t option
    ; session_number : Integer.t option
    ; virtual_network_id : Integer.t option
    ; description : String.t option
    ; remove_fields : TrafficMirrorSessionFieldList.t
    ; dry_run : Boolean.t option
    }

  let make
      ~traffic_mirror_session_id
      ?traffic_mirror_target_id
      ?traffic_mirror_filter_id
      ?packet_length
      ?session_number
      ?virtual_network_id
      ?description
      ?(remove_fields = [])
      ?dry_run
      () =
    { traffic_mirror_session_id
    ; traffic_mirror_target_id
    ; traffic_mirror_filter_id
    ; packet_length
    ; session_number
    ; virtual_network_id
    ; description
    ; remove_fields
    ; dry_run
    }

  let parse xml =
    Some
      { traffic_mirror_session_id =
          Aws.Xml.required
            "TrafficMirrorSessionId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TrafficMirrorSessionId" xml)
               String.parse)
      ; traffic_mirror_target_id =
          Aws.Util.option_bind (Aws.Xml.member "TrafficMirrorTargetId" xml) String.parse
      ; traffic_mirror_filter_id =
          Aws.Util.option_bind (Aws.Xml.member "TrafficMirrorFilterId" xml) String.parse
      ; packet_length =
          Aws.Util.option_bind (Aws.Xml.member "PacketLength" xml) Integer.parse
      ; session_number =
          Aws.Util.option_bind (Aws.Xml.member "SessionNumber" xml) Integer.parse
      ; virtual_network_id =
          Aws.Util.option_bind (Aws.Xml.member "VirtualNetworkId" xml) Integer.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; remove_fields =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "RemoveField" xml)
               TrafficMirrorSessionFieldList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("RemoveField", TrafficMirrorSessionFieldList.to_query v.remove_fields))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.virtual_network_id (fun f ->
               Aws.Query.Pair ("VirtualNetworkId", Integer.to_query f))
         ; Aws.Util.option_map v.session_number (fun f ->
               Aws.Query.Pair ("SessionNumber", Integer.to_query f))
         ; Aws.Util.option_map v.packet_length (fun f ->
               Aws.Query.Pair ("PacketLength", Integer.to_query f))
         ; Aws.Util.option_map v.traffic_mirror_filter_id (fun f ->
               Aws.Query.Pair ("TrafficMirrorFilterId", String.to_query f))
         ; Aws.Util.option_map v.traffic_mirror_target_id (fun f ->
               Aws.Query.Pair ("TrafficMirrorTargetId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TrafficMirrorSessionId", String.to_query v.traffic_mirror_session_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("RemoveField", TrafficMirrorSessionFieldList.to_json v.remove_fields)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.virtual_network_id (fun f ->
               "VirtualNetworkId", Integer.to_json f)
         ; Aws.Util.option_map v.session_number (fun f ->
               "SessionNumber", Integer.to_json f)
         ; Aws.Util.option_map v.packet_length (fun f ->
               "PacketLength", Integer.to_json f)
         ; Aws.Util.option_map v.traffic_mirror_filter_id (fun f ->
               "TrafficMirrorFilterId", String.to_json f)
         ; Aws.Util.option_map v.traffic_mirror_target_id (fun f ->
               "TrafficMirrorTargetId", String.to_json f)
         ; Some ("TrafficMirrorSessionId", String.to_json v.traffic_mirror_session_id)
         ])

  let of_json j =
    { traffic_mirror_session_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TrafficMirrorSessionId"))
    ; traffic_mirror_target_id =
        Aws.Util.option_map (Aws.Json.lookup j "TrafficMirrorTargetId") String.of_json
    ; traffic_mirror_filter_id =
        Aws.Util.option_map (Aws.Json.lookup j "TrafficMirrorFilterId") String.of_json
    ; packet_length =
        Aws.Util.option_map (Aws.Json.lookup j "PacketLength") Integer.of_json
    ; session_number =
        Aws.Util.option_map (Aws.Json.lookup j "SessionNumber") Integer.of_json
    ; virtual_network_id =
        Aws.Util.option_map (Aws.Json.lookup j "VirtualNetworkId") Integer.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; remove_fields =
        TrafficMirrorSessionFieldList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "RemoveField"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module PriceSchedule = struct
  type t =
    { active : Boolean.t option
    ; currency_code : CurrencyCodeValues.t option
    ; price : Double.t option
    ; term : Long.t option
    }

  let make ?active ?currency_code ?price ?term () = { active; currency_code; price; term }

  let parse xml =
    Some
      { active = Aws.Util.option_bind (Aws.Xml.member "active" xml) Boolean.parse
      ; currency_code =
          Aws.Util.option_bind
            (Aws.Xml.member "currencyCode" xml)
            CurrencyCodeValues.parse
      ; price = Aws.Util.option_bind (Aws.Xml.member "price" xml) Double.parse
      ; term = Aws.Util.option_bind (Aws.Xml.member "term" xml) Long.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.term (fun f -> Aws.Query.Pair ("Term", Long.to_query f))
         ; Aws.Util.option_map v.price (fun f ->
               Aws.Query.Pair ("Price", Double.to_query f))
         ; Aws.Util.option_map v.currency_code (fun f ->
               Aws.Query.Pair ("CurrencyCode", CurrencyCodeValues.to_query f))
         ; Aws.Util.option_map v.active (fun f ->
               Aws.Query.Pair ("Active", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.term (fun f -> "term", Long.to_json f)
         ; Aws.Util.option_map v.price (fun f -> "price", Double.to_json f)
         ; Aws.Util.option_map v.currency_code (fun f ->
               "currencyCode", CurrencyCodeValues.to_json f)
         ; Aws.Util.option_map v.active (fun f -> "active", Boolean.to_json f)
         ])

  let of_json j =
    { active = Aws.Util.option_map (Aws.Json.lookup j "active") Boolean.of_json
    ; currency_code =
        Aws.Util.option_map (Aws.Json.lookup j "currencyCode") CurrencyCodeValues.of_json
    ; price = Aws.Util.option_map (Aws.Json.lookup j "price") Double.of_json
    ; term = Aws.Util.option_map (Aws.Json.lookup j "term") Long.of_json
    }
end

module PriceScheduleList = struct
  type t = PriceSchedule.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map PriceSchedule.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list PriceSchedule.to_query v

  let to_json v = `List (List.map PriceSchedule.to_json v)

  let of_json j = Aws.Json.to_list PriceSchedule.of_json j
end

module ReservedInstancesListing = struct
  type t =
    { client_token : String.t option
    ; create_date : DateTime.t option
    ; instance_counts : InstanceCountList.t
    ; price_schedules : PriceScheduleList.t
    ; reserved_instances_id : String.t option
    ; reserved_instances_listing_id : String.t option
    ; status : ListingStatus.t option
    ; status_message : String.t option
    ; tags : TagList.t
    ; update_date : DateTime.t option
    }

  let make
      ?client_token
      ?create_date
      ?(instance_counts = [])
      ?(price_schedules = [])
      ?reserved_instances_id
      ?reserved_instances_listing_id
      ?status
      ?status_message
      ?(tags = [])
      ?update_date
      () =
    { client_token
    ; create_date
    ; instance_counts
    ; price_schedules
    ; reserved_instances_id
    ; reserved_instances_listing_id
    ; status
    ; status_message
    ; tags
    ; update_date
    }

  let parse xml =
    Some
      { client_token =
          Aws.Util.option_bind (Aws.Xml.member "clientToken" xml) String.parse
      ; create_date =
          Aws.Util.option_bind (Aws.Xml.member "createDate" xml) DateTime.parse
      ; instance_counts =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "instanceCounts" xml)
               InstanceCountList.parse)
      ; price_schedules =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "priceSchedules" xml)
               PriceScheduleList.parse)
      ; reserved_instances_id =
          Aws.Util.option_bind (Aws.Xml.member "reservedInstancesId" xml) String.parse
      ; reserved_instances_listing_id =
          Aws.Util.option_bind
            (Aws.Xml.member "reservedInstancesListingId" xml)
            String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "status" xml) ListingStatus.parse
      ; status_message =
          Aws.Util.option_bind (Aws.Xml.member "statusMessage" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      ; update_date =
          Aws.Util.option_bind (Aws.Xml.member "updateDate" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.update_date (fun f ->
               Aws.Query.Pair ("UpdateDate", DateTime.to_query f))
         ; Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.status_message (fun f ->
               Aws.Query.Pair ("StatusMessage", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", ListingStatus.to_query f))
         ; Aws.Util.option_map v.reserved_instances_listing_id (fun f ->
               Aws.Query.Pair ("ReservedInstancesListingId", String.to_query f))
         ; Aws.Util.option_map v.reserved_instances_id (fun f ->
               Aws.Query.Pair ("ReservedInstancesId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("PriceSchedules", PriceScheduleList.to_query v.price_schedules))
         ; Some
             (Aws.Query.Pair
                ("InstanceCounts", InstanceCountList.to_query v.instance_counts))
         ; Aws.Util.option_map v.create_date (fun f ->
               Aws.Query.Pair ("CreateDate", DateTime.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.update_date (fun f -> "updateDate", DateTime.to_json f)
         ; Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.status_message (fun f ->
               "statusMessage", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "status", ListingStatus.to_json f)
         ; Aws.Util.option_map v.reserved_instances_listing_id (fun f ->
               "reservedInstancesListingId", String.to_json f)
         ; Aws.Util.option_map v.reserved_instances_id (fun f ->
               "reservedInstancesId", String.to_json f)
         ; Some ("priceSchedules", PriceScheduleList.to_json v.price_schedules)
         ; Some ("instanceCounts", InstanceCountList.to_json v.instance_counts)
         ; Aws.Util.option_map v.create_date (fun f -> "createDate", DateTime.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "clientToken", String.to_json f)
         ])

  let of_json j =
    { client_token = Aws.Util.option_map (Aws.Json.lookup j "clientToken") String.of_json
    ; create_date = Aws.Util.option_map (Aws.Json.lookup j "createDate") DateTime.of_json
    ; instance_counts =
        InstanceCountList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceCounts"))
    ; price_schedules =
        PriceScheduleList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "priceSchedules"))
    ; reserved_instances_id =
        Aws.Util.option_map (Aws.Json.lookup j "reservedInstancesId") String.of_json
    ; reserved_instances_listing_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "reservedInstancesListingId")
          String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "status") ListingStatus.of_json
    ; status_message =
        Aws.Util.option_map (Aws.Json.lookup j "statusMessage") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    ; update_date = Aws.Util.option_map (Aws.Json.lookup j "updateDate") DateTime.of_json
    }
end

module RuleAction = struct
  type t =
    | Allow
    | Deny

  let str_to_t = [ "deny", Deny; "allow", Allow ]

  let t_to_str = [ Deny, "deny"; Allow, "allow" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module PortRange = struct
  type t =
    { from : Integer.t option
    ; to_ : Integer.t option
    }

  let make ?from ?to_ () = { from; to_ }

  let parse xml =
    Some
      { from = Aws.Util.option_bind (Aws.Xml.member "from" xml) Integer.parse
      ; to_ = Aws.Util.option_bind (Aws.Xml.member "to" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.to_ (fun f -> Aws.Query.Pair ("To", Integer.to_query f))
         ; Aws.Util.option_map v.from (fun f ->
               Aws.Query.Pair ("From", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.to_ (fun f -> "to", Integer.to_json f)
         ; Aws.Util.option_map v.from (fun f -> "from", Integer.to_json f)
         ])

  let of_json j =
    { from = Aws.Util.option_map (Aws.Json.lookup j "from") Integer.of_json
    ; to_ = Aws.Util.option_map (Aws.Json.lookup j "to") Integer.of_json
    }
end

module IcmpTypeCode = struct
  type t =
    { code : Integer.t option
    ; type_ : Integer.t option
    }

  let make ?code ?type_ () = { code; type_ }

  let parse xml =
    Some
      { code = Aws.Util.option_bind (Aws.Xml.member "code" xml) Integer.parse
      ; type_ = Aws.Util.option_bind (Aws.Xml.member "type" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", Integer.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair ("Code", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.type_ (fun f -> "type", Integer.to_json f)
         ; Aws.Util.option_map v.code (fun f -> "code", Integer.to_json f)
         ])

  let of_json j =
    { code = Aws.Util.option_map (Aws.Json.lookup j "code") Integer.of_json
    ; type_ = Aws.Util.option_map (Aws.Json.lookup j "type") Integer.of_json
    }
end

module NetworkAclEntry = struct
  type t =
    { cidr_block : String.t option
    ; egress : Boolean.t option
    ; icmp_type_code : IcmpTypeCode.t option
    ; ipv6_cidr_block : String.t option
    ; port_range : PortRange.t option
    ; protocol : String.t option
    ; rule_action : RuleAction.t option
    ; rule_number : Integer.t option
    }

  let make
      ?cidr_block
      ?egress
      ?icmp_type_code
      ?ipv6_cidr_block
      ?port_range
      ?protocol
      ?rule_action
      ?rule_number
      () =
    { cidr_block
    ; egress
    ; icmp_type_code
    ; ipv6_cidr_block
    ; port_range
    ; protocol
    ; rule_action
    ; rule_number
    }

  let parse xml =
    Some
      { cidr_block = Aws.Util.option_bind (Aws.Xml.member "cidrBlock" xml) String.parse
      ; egress = Aws.Util.option_bind (Aws.Xml.member "egress" xml) Boolean.parse
      ; icmp_type_code =
          Aws.Util.option_bind (Aws.Xml.member "icmpTypeCode" xml) IcmpTypeCode.parse
      ; ipv6_cidr_block =
          Aws.Util.option_bind (Aws.Xml.member "ipv6CidrBlock" xml) String.parse
      ; port_range = Aws.Util.option_bind (Aws.Xml.member "portRange" xml) PortRange.parse
      ; protocol = Aws.Util.option_bind (Aws.Xml.member "protocol" xml) String.parse
      ; rule_action =
          Aws.Util.option_bind (Aws.Xml.member "ruleAction" xml) RuleAction.parse
      ; rule_number = Aws.Util.option_bind (Aws.Xml.member "ruleNumber" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.rule_number (fun f ->
               Aws.Query.Pair ("RuleNumber", Integer.to_query f))
         ; Aws.Util.option_map v.rule_action (fun f ->
               Aws.Query.Pair ("RuleAction", RuleAction.to_query f))
         ; Aws.Util.option_map v.protocol (fun f ->
               Aws.Query.Pair ("Protocol", String.to_query f))
         ; Aws.Util.option_map v.port_range (fun f ->
               Aws.Query.Pair ("PortRange", PortRange.to_query f))
         ; Aws.Util.option_map v.ipv6_cidr_block (fun f ->
               Aws.Query.Pair ("Ipv6CidrBlock", String.to_query f))
         ; Aws.Util.option_map v.icmp_type_code (fun f ->
               Aws.Query.Pair ("IcmpTypeCode", IcmpTypeCode.to_query f))
         ; Aws.Util.option_map v.egress (fun f ->
               Aws.Query.Pair ("Egress", Boolean.to_query f))
         ; Aws.Util.option_map v.cidr_block (fun f ->
               Aws.Query.Pair ("CidrBlock", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.rule_number (fun f -> "ruleNumber", Integer.to_json f)
         ; Aws.Util.option_map v.rule_action (fun f -> "ruleAction", RuleAction.to_json f)
         ; Aws.Util.option_map v.protocol (fun f -> "protocol", String.to_json f)
         ; Aws.Util.option_map v.port_range (fun f -> "portRange", PortRange.to_json f)
         ; Aws.Util.option_map v.ipv6_cidr_block (fun f ->
               "ipv6CidrBlock", String.to_json f)
         ; Aws.Util.option_map v.icmp_type_code (fun f ->
               "icmpTypeCode", IcmpTypeCode.to_json f)
         ; Aws.Util.option_map v.egress (fun f -> "egress", Boolean.to_json f)
         ; Aws.Util.option_map v.cidr_block (fun f -> "cidrBlock", String.to_json f)
         ])

  let of_json j =
    { cidr_block = Aws.Util.option_map (Aws.Json.lookup j "cidrBlock") String.of_json
    ; egress = Aws.Util.option_map (Aws.Json.lookup j "egress") Boolean.of_json
    ; icmp_type_code =
        Aws.Util.option_map (Aws.Json.lookup j "icmpTypeCode") IcmpTypeCode.of_json
    ; ipv6_cidr_block =
        Aws.Util.option_map (Aws.Json.lookup j "ipv6CidrBlock") String.of_json
    ; port_range = Aws.Util.option_map (Aws.Json.lookup j "portRange") PortRange.of_json
    ; protocol = Aws.Util.option_map (Aws.Json.lookup j "protocol") String.of_json
    ; rule_action =
        Aws.Util.option_map (Aws.Json.lookup j "ruleAction") RuleAction.of_json
    ; rule_number = Aws.Util.option_map (Aws.Json.lookup j "ruleNumber") Integer.of_json
    }
end

module NetworkAclEntryList = struct
  type t = NetworkAclEntry.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map NetworkAclEntry.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list NetworkAclEntry.to_query v

  let to_json v = `List (List.map NetworkAclEntry.to_json v)

  let of_json j = Aws.Json.to_list NetworkAclEntry.of_json j
end

module TransitGatewayMulitcastDomainAssociationState = struct
  type t =
    | Associating
    | Associated
    | Disassociating
    | Disassociated

  let str_to_t =
    [ "disassociated", Disassociated
    ; "disassociating", Disassociating
    ; "associated", Associated
    ; "associating", Associating
    ]

  let t_to_str =
    [ Disassociated, "disassociated"
    ; Disassociating, "disassociating"
    ; Associated, "associated"
    ; Associating, "associating"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module SubnetAssociation = struct
  type t =
    { subnet_id : String.t option
    ; state : TransitGatewayMulitcastDomainAssociationState.t option
    }

  let make ?subnet_id ?state () = { subnet_id; state }

  let parse xml =
    Some
      { subnet_id = Aws.Util.option_bind (Aws.Xml.member "subnetId" xml) String.parse
      ; state =
          Aws.Util.option_bind
            (Aws.Xml.member "state" xml)
            TransitGatewayMulitcastDomainAssociationState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair
                 ("State", TransitGatewayMulitcastDomainAssociationState.to_query f))
         ; Aws.Util.option_map v.subnet_id (fun f ->
               Aws.Query.Pair ("SubnetId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               "state", TransitGatewayMulitcastDomainAssociationState.to_json f)
         ; Aws.Util.option_map v.subnet_id (fun f -> "subnetId", String.to_json f)
         ])

  let of_json j =
    { subnet_id = Aws.Util.option_map (Aws.Json.lookup j "subnetId") String.of_json
    ; state =
        Aws.Util.option_map
          (Aws.Json.lookup j "state")
          TransitGatewayMulitcastDomainAssociationState.of_json
    }
end

module TransitGatewayMulticastDomainAssociation = struct
  type t =
    { transit_gateway_attachment_id : String.t option
    ; resource_id : String.t option
    ; resource_type : TransitGatewayAttachmentResourceType.t option
    ; subnet : SubnetAssociation.t option
    }

  let make ?transit_gateway_attachment_id ?resource_id ?resource_type ?subnet () =
    { transit_gateway_attachment_id; resource_id; resource_type; subnet }

  let parse xml =
    Some
      { transit_gateway_attachment_id =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayAttachmentId" xml)
            String.parse
      ; resource_id = Aws.Util.option_bind (Aws.Xml.member "resourceId" xml) String.parse
      ; resource_type =
          Aws.Util.option_bind
            (Aws.Xml.member "resourceType" xml)
            TransitGatewayAttachmentResourceType.parse
      ; subnet =
          Aws.Util.option_bind (Aws.Xml.member "subnet" xml) SubnetAssociation.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.subnet (fun f ->
               Aws.Query.Pair ("Subnet", SubnetAssociation.to_query f))
         ; Aws.Util.option_map v.resource_type (fun f ->
               Aws.Query.Pair
                 ("ResourceType", TransitGatewayAttachmentResourceType.to_query f))
         ; Aws.Util.option_map v.resource_id (fun f ->
               Aws.Query.Pair ("ResourceId", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               Aws.Query.Pair ("TransitGatewayAttachmentId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.subnet (fun f -> "subnet", SubnetAssociation.to_json f)
         ; Aws.Util.option_map v.resource_type (fun f ->
               "resourceType", TransitGatewayAttachmentResourceType.to_json f)
         ; Aws.Util.option_map v.resource_id (fun f -> "resourceId", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               "transitGatewayAttachmentId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_attachment_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayAttachmentId")
          String.of_json
    ; resource_id = Aws.Util.option_map (Aws.Json.lookup j "resourceId") String.of_json
    ; resource_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "resourceType")
          TransitGatewayAttachmentResourceType.of_json
    ; subnet = Aws.Util.option_map (Aws.Json.lookup j "subnet") SubnetAssociation.of_json
    }
end

module TransitGatewayMulticastDomainAssociationList = struct
  type t = TransitGatewayMulticastDomainAssociation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         TransitGatewayMulticastDomainAssociation.parse
         (Aws.Xml.members "item" xml))

  let to_query v =
    Aws.Query.to_query_list TransitGatewayMulticastDomainAssociation.to_query v

  let to_json v = `List (List.map TransitGatewayMulticastDomainAssociation.to_json v)

  let of_json j = Aws.Json.to_list TransitGatewayMulticastDomainAssociation.of_json j
end

module GetTransitGatewayMulticastDomainAssociationsResult = struct
  type t =
    { multicast_domain_associations : TransitGatewayMulticastDomainAssociationList.t
    ; next_token : String.t option
    }

  let make ?(multicast_domain_associations = []) ?next_token () =
    { multicast_domain_associations; next_token }

  let parse xml =
    Some
      { multicast_domain_associations =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "multicastDomainAssociations" xml)
               TransitGatewayMulticastDomainAssociationList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "MulticastDomainAssociations"
                , TransitGatewayMulticastDomainAssociationList.to_query
                    v.multicast_domain_associations ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "multicastDomainAssociations"
             , TransitGatewayMulticastDomainAssociationList.to_json
                 v.multicast_domain_associations )
         ])

  let of_json j =
    { multicast_domain_associations =
        TransitGatewayMulticastDomainAssociationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "multicastDomainAssociations"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module HostTenancy = struct
  type t =
    | Dedicated
    | Host

  let str_to_t = [ "host", Host; "dedicated", Dedicated ]

  let t_to_str = [ Host, "host"; Dedicated, "dedicated" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module RequestSpotFleetResponse = struct
  type t = { spot_fleet_request_id : String.t option }

  let make ?spot_fleet_request_id () = { spot_fleet_request_id }

  let parse xml =
    Some
      { spot_fleet_request_id =
          Aws.Util.option_bind (Aws.Xml.member "spotFleetRequestId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.spot_fleet_request_id (fun f ->
               Aws.Query.Pair ("SpotFleetRequestId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.spot_fleet_request_id (fun f ->
               "spotFleetRequestId", String.to_json f)
         ])

  let of_json j =
    { spot_fleet_request_id =
        Aws.Util.option_map (Aws.Json.lookup j "spotFleetRequestId") String.of_json
    }
end

module ExportEnvironment = struct
  type t =
    | Citrix
    | Vmware
    | Microsoft

  let str_to_t = [ "microsoft", Microsoft; "vmware", Vmware; "citrix", Citrix ]

  let t_to_str = [ Microsoft, "microsoft"; Vmware, "vmware"; Citrix, "citrix" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module InstanceExportDetails = struct
  type t =
    { instance_id : String.t option
    ; target_environment : ExportEnvironment.t option
    }

  let make ?instance_id ?target_environment () = { instance_id; target_environment }

  let parse xml =
    Some
      { instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      ; target_environment =
          Aws.Util.option_bind
            (Aws.Xml.member "targetEnvironment" xml)
            ExportEnvironment.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.target_environment (fun f ->
               Aws.Query.Pair ("TargetEnvironment", ExportEnvironment.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.target_environment (fun f ->
               "targetEnvironment", ExportEnvironment.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ])

  let of_json j =
    { instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    ; target_environment =
        Aws.Util.option_map
          (Aws.Json.lookup j "targetEnvironment")
          ExportEnvironment.of_json
    }
end

module InstanceStateChange = struct
  type t =
    { current_state : InstanceState.t option
    ; instance_id : String.t option
    ; previous_state : InstanceState.t option
    }

  let make ?current_state ?instance_id ?previous_state () =
    { current_state; instance_id; previous_state }

  let parse xml =
    Some
      { current_state =
          Aws.Util.option_bind (Aws.Xml.member "currentState" xml) InstanceState.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      ; previous_state =
          Aws.Util.option_bind (Aws.Xml.member "previousState" xml) InstanceState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.previous_state (fun f ->
               Aws.Query.Pair ("PreviousState", InstanceState.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.current_state (fun f ->
               Aws.Query.Pair ("CurrentState", InstanceState.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.previous_state (fun f ->
               "previousState", InstanceState.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ; Aws.Util.option_map v.current_state (fun f ->
               "currentState", InstanceState.to_json f)
         ])

  let of_json j =
    { current_state =
        Aws.Util.option_map (Aws.Json.lookup j "currentState") InstanceState.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    ; previous_state =
        Aws.Util.option_map (Aws.Json.lookup j "previousState") InstanceState.of_json
    }
end

module InstanceStateChangeList = struct
  type t = InstanceStateChange.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map InstanceStateChange.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list InstanceStateChange.to_query v

  let to_json v = `List (List.map InstanceStateChange.to_json v)

  let of_json j = Aws.Json.to_list InstanceStateChange.of_json j
end

module StopInstancesResult = struct
  type t = { stopping_instances : InstanceStateChangeList.t }

  let make ?(stopping_instances = []) () = { stopping_instances }

  let parse xml =
    Some
      { stopping_instances =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "instancesSet" xml)
               InstanceStateChangeList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("InstancesSet", InstanceStateChangeList.to_query v.stopping_instances))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("instancesSet", InstanceStateChangeList.to_json v.stopping_instances) ])

  let of_json j =
    { stopping_instances =
        InstanceStateChangeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "instancesSet"))
    }
end

module ContainerFormat = struct
  type t = Ova

  let str_to_t = [ "ova", Ova ]

  let t_to_str = [ Ova, "ova" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ExportToS3Task = struct
  type t =
    { container_format : ContainerFormat.t option
    ; disk_image_format : DiskImageFormat.t option
    ; s3_bucket : String.t option
    ; s3_key : String.t option
    }

  let make ?container_format ?disk_image_format ?s3_bucket ?s3_key () =
    { container_format; disk_image_format; s3_bucket; s3_key }

  let parse xml =
    Some
      { container_format =
          Aws.Util.option_bind
            (Aws.Xml.member "containerFormat" xml)
            ContainerFormat.parse
      ; disk_image_format =
          Aws.Util.option_bind
            (Aws.Xml.member "diskImageFormat" xml)
            DiskImageFormat.parse
      ; s3_bucket = Aws.Util.option_bind (Aws.Xml.member "s3Bucket" xml) String.parse
      ; s3_key = Aws.Util.option_bind (Aws.Xml.member "s3Key" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.s3_key (fun f ->
               Aws.Query.Pair ("S3Key", String.to_query f))
         ; Aws.Util.option_map v.s3_bucket (fun f ->
               Aws.Query.Pair ("S3Bucket", String.to_query f))
         ; Aws.Util.option_map v.disk_image_format (fun f ->
               Aws.Query.Pair ("DiskImageFormat", DiskImageFormat.to_query f))
         ; Aws.Util.option_map v.container_format (fun f ->
               Aws.Query.Pair ("ContainerFormat", ContainerFormat.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.s3_key (fun f -> "s3Key", String.to_json f)
         ; Aws.Util.option_map v.s3_bucket (fun f -> "s3Bucket", String.to_json f)
         ; Aws.Util.option_map v.disk_image_format (fun f ->
               "diskImageFormat", DiskImageFormat.to_json f)
         ; Aws.Util.option_map v.container_format (fun f ->
               "containerFormat", ContainerFormat.to_json f)
         ])

  let of_json j =
    { container_format =
        Aws.Util.option_map (Aws.Json.lookup j "containerFormat") ContainerFormat.of_json
    ; disk_image_format =
        Aws.Util.option_map (Aws.Json.lookup j "diskImageFormat") DiskImageFormat.of_json
    ; s3_bucket = Aws.Util.option_map (Aws.Json.lookup j "s3Bucket") String.of_json
    ; s3_key = Aws.Util.option_map (Aws.Json.lookup j "s3Key") String.of_json
    }
end

module ExportTask = struct
  type t =
    { description : String.t
    ; export_task_id : String.t
    ; export_to_s3_task : ExportToS3Task.t
    ; instance_export_details : InstanceExportDetails.t
    ; state : ExportTaskState.t
    ; status_message : String.t
    ; tags : TagList.t
    }

  let make
      ~description
      ~export_task_id
      ~export_to_s3_task
      ~instance_export_details
      ~state
      ~status_message
      ?(tags = [])
      () =
    { description
    ; export_task_id
    ; export_to_s3_task
    ; instance_export_details
    ; state
    ; status_message
    ; tags
    }

  let parse xml =
    Some
      { description =
          Aws.Xml.required
            "description"
            (Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse)
      ; export_task_id =
          Aws.Xml.required
            "exportTaskId"
            (Aws.Util.option_bind (Aws.Xml.member "exportTaskId" xml) String.parse)
      ; export_to_s3_task =
          Aws.Xml.required
            "exportToS3"
            (Aws.Util.option_bind (Aws.Xml.member "exportToS3" xml) ExportToS3Task.parse)
      ; instance_export_details =
          Aws.Xml.required
            "instanceExport"
            (Aws.Util.option_bind
               (Aws.Xml.member "instanceExport" xml)
               InstanceExportDetails.parse)
      ; state =
          Aws.Xml.required
            "state"
            (Aws.Util.option_bind (Aws.Xml.member "state" xml) ExportTaskState.parse)
      ; status_message =
          Aws.Xml.required
            "statusMessage"
            (Aws.Util.option_bind (Aws.Xml.member "statusMessage" xml) String.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Some (Aws.Query.Pair ("StatusMessage", String.to_query v.status_message))
         ; Some (Aws.Query.Pair ("State", ExportTaskState.to_query v.state))
         ; Some
             (Aws.Query.Pair
                ( "InstanceExport"
                , InstanceExportDetails.to_query v.instance_export_details ))
         ; Some
             (Aws.Query.Pair ("ExportToS3", ExportToS3Task.to_query v.export_to_s3_task))
         ; Some (Aws.Query.Pair ("ExportTaskId", String.to_query v.export_task_id))
         ; Some (Aws.Query.Pair ("Description", String.to_query v.description))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Some ("statusMessage", String.to_json v.status_message)
         ; Some ("state", ExportTaskState.to_json v.state)
         ; Some ("instanceExport", InstanceExportDetails.to_json v.instance_export_details)
         ; Some ("exportToS3", ExportToS3Task.to_json v.export_to_s3_task)
         ; Some ("exportTaskId", String.to_json v.export_task_id)
         ; Some ("description", String.to_json v.description)
         ])

  let of_json j =
    { description =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "description"))
    ; export_task_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "exportTaskId"))
    ; export_to_s3_task =
        ExportToS3Task.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "exportToS3"))
    ; instance_export_details =
        InstanceExportDetails.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceExport"))
    ; state = ExportTaskState.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "state"))
    ; status_message =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "statusMessage"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module ExportTaskList = struct
  type t = ExportTask.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ExportTask.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ExportTask.to_query v

  let to_json v = `List (List.map ExportTask.to_json v)

  let of_json j = Aws.Json.to_list ExportTask.of_json j
end

module EgressOnlyInternetGatewayIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module IpRanges = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeFleetInstancesRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; fleet_id : String.t
    ; filters : FilterList.t
    }

  let make ?dry_run ?max_results ?next_token ~fleet_id ?(filters = []) () =
    { dry_run; max_results; next_token; fleet_id; filters }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; fleet_id =
          Aws.Xml.required
            "FleetId"
            (Aws.Util.option_bind (Aws.Xml.member "FleetId" xml) String.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some (Aws.Query.Pair ("FleetId", String.to_query v.fleet_id))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Filter", FilterList.to_json v.filters)
         ; Some ("FleetId", String.to_json v.fleet_id)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; fleet_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "FleetId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    }
end

module TrafficDirection = struct
  type t =
    | Ingress
    | Egress

  let str_to_t = [ "egress", Egress; "ingress", Ingress ]

  let t_to_str = [ Egress, "egress"; Ingress, "ingress" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module FleetLaunchTemplateConfig = struct
  type t =
    { launch_template_specification : FleetLaunchTemplateSpecification.t option
    ; overrides : FleetLaunchTemplateOverridesList.t
    }

  let make ?launch_template_specification ?(overrides = []) () =
    { launch_template_specification; overrides }

  let parse xml =
    Some
      { launch_template_specification =
          Aws.Util.option_bind
            (Aws.Xml.member "launchTemplateSpecification" xml)
            FleetLaunchTemplateSpecification.parse
      ; overrides =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "overrides" xml)
               FleetLaunchTemplateOverridesList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("Overrides", FleetLaunchTemplateOverridesList.to_query v.overrides))
         ; Aws.Util.option_map v.launch_template_specification (fun f ->
               Aws.Query.Pair
                 ( "LaunchTemplateSpecification"
                 , FleetLaunchTemplateSpecification.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("overrides", FleetLaunchTemplateOverridesList.to_json v.overrides)
         ; Aws.Util.option_map v.launch_template_specification (fun f ->
               "launchTemplateSpecification", FleetLaunchTemplateSpecification.to_json f)
         ])

  let of_json j =
    { launch_template_specification =
        Aws.Util.option_map
          (Aws.Json.lookup j "launchTemplateSpecification")
          FleetLaunchTemplateSpecification.of_json
    ; overrides =
        FleetLaunchTemplateOverridesList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "overrides"))
    }
end

module FleetLaunchTemplateConfigList = struct
  type t = FleetLaunchTemplateConfig.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map FleetLaunchTemplateConfig.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list FleetLaunchTemplateConfig.to_query v

  let to_json v = `List (List.map FleetLaunchTemplateConfig.to_json v)

  let of_json j = Aws.Json.to_list FleetLaunchTemplateConfig.of_json j
end

module DescribeClientVpnAuthorizationRulesResult = struct
  type t =
    { authorization_rules : AuthorizationRuleSet.t
    ; next_token : String.t option
    }

  let make ?(authorization_rules = []) ?next_token () =
    { authorization_rules; next_token }

  let parse xml =
    Some
      { authorization_rules =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "authorizationRule" xml)
               AuthorizationRuleSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("AuthorizationRule", AuthorizationRuleSet.to_query v.authorization_rules))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("authorizationRule", AuthorizationRuleSet.to_json v.authorization_rules)
         ])

  let of_json j =
    { authorization_rules =
        AuthorizationRuleSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "authorizationRule"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module SpotInstanceRequestIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map String.parse (Aws.Xml.members "SpotInstanceRequestId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module TransitGatewayMulticastDeregisteredGroupMembers = struct
  type t =
    { transit_gateway_multicast_domain_id : String.t option
    ; deregistered_network_interface_ids : ValueStringList.t
    ; group_ip_address : String.t option
    }

  let make
      ?transit_gateway_multicast_domain_id
      ?(deregistered_network_interface_ids = [])
      ?group_ip_address
      () =
    { transit_gateway_multicast_domain_id
    ; deregistered_network_interface_ids
    ; group_ip_address
    }

  let parse xml =
    Some
      { transit_gateway_multicast_domain_id =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayMulticastDomainId" xml)
            String.parse
      ; deregistered_network_interface_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "deregisteredNetworkInterfaceIds" xml)
               ValueStringList.parse)
      ; group_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "groupIpAddress" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.group_ip_address (fun f ->
               Aws.Query.Pair ("GroupIpAddress", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "DeregisteredNetworkInterfaceIds"
                , ValueStringList.to_query v.deregistered_network_interface_ids ))
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               Aws.Query.Pair ("TransitGatewayMulticastDomainId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.group_ip_address (fun f ->
               "groupIpAddress", String.to_json f)
         ; Some
             ( "deregisteredNetworkInterfaceIds"
             , ValueStringList.to_json v.deregistered_network_interface_ids )
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               "transitGatewayMulticastDomainId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_multicast_domain_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayMulticastDomainId")
          String.of_json
    ; deregistered_network_interface_ids =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "deregisteredNetworkInterfaceIds"))
    ; group_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "groupIpAddress") String.of_json
    }
end

module DeregisterTransitGatewayMulticastGroupMembersResult = struct
  type t =
    { deregistered_multicast_group_members :
        TransitGatewayMulticastDeregisteredGroupMembers.t option
    }

  let make ?deregistered_multicast_group_members () =
    { deregistered_multicast_group_members }

  let parse xml =
    Some
      { deregistered_multicast_group_members =
          Aws.Util.option_bind
            (Aws.Xml.member "deregisteredMulticastGroupMembers" xml)
            TransitGatewayMulticastDeregisteredGroupMembers.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.deregistered_multicast_group_members (fun f ->
               Aws.Query.Pair
                 ( "DeregisteredMulticastGroupMembers"
                 , TransitGatewayMulticastDeregisteredGroupMembers.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.deregistered_multicast_group_members (fun f ->
               ( "deregisteredMulticastGroupMembers"
               , TransitGatewayMulticastDeregisteredGroupMembers.to_json f ))
         ])

  let of_json j =
    { deregistered_multicast_group_members =
        Aws.Util.option_map
          (Aws.Json.lookup j "deregisteredMulticastGroupMembers")
          TransitGatewayMulticastDeregisteredGroupMembers.of_json
    }
end

module UnsuccessfulItem = struct
  type t =
    { error : UnsuccessfulItemError.t option
    ; resource_id : String.t option
    }

  let make ?error ?resource_id () = { error; resource_id }

  let parse xml =
    Some
      { error =
          Aws.Util.option_bind (Aws.Xml.member "error" xml) UnsuccessfulItemError.parse
      ; resource_id = Aws.Util.option_bind (Aws.Xml.member "resourceId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.resource_id (fun f ->
               Aws.Query.Pair ("ResourceId", String.to_query f))
         ; Aws.Util.option_map v.error (fun f ->
               Aws.Query.Pair ("Error", UnsuccessfulItemError.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.resource_id (fun f -> "resourceId", String.to_json f)
         ; Aws.Util.option_map v.error (fun f -> "error", UnsuccessfulItemError.to_json f)
         ])

  let of_json j =
    { error =
        Aws.Util.option_map (Aws.Json.lookup j "error") UnsuccessfulItemError.of_json
    ; resource_id = Aws.Util.option_map (Aws.Json.lookup j "resourceId") String.of_json
    }
end

module UnsuccessfulItemList = struct
  type t = UnsuccessfulItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map UnsuccessfulItem.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list UnsuccessfulItem.to_query v

  let to_json v = `List (List.map UnsuccessfulItem.to_json v)

  let of_json j = Aws.Json.to_list UnsuccessfulItem.of_json j
end

module ResponseHostIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module ModifyHostsResult = struct
  type t =
    { successful : ResponseHostIdList.t
    ; unsuccessful : UnsuccessfulItemList.t
    }

  let make ?(successful = []) ?(unsuccessful = []) () = { successful; unsuccessful }

  let parse xml =
    Some
      { successful =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "successful" xml)
               ResponseHostIdList.parse)
      ; unsuccessful =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "unsuccessful" xml)
               UnsuccessfulItemList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("Unsuccessful", UnsuccessfulItemList.to_query v.unsuccessful))
         ; Some (Aws.Query.Pair ("Successful", ResponseHostIdList.to_query v.successful))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("unsuccessful", UnsuccessfulItemList.to_json v.unsuccessful)
         ; Some ("successful", ResponseHostIdList.to_json v.successful)
         ])

  let of_json j =
    { successful =
        ResponseHostIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "successful"))
    ; unsuccessful =
        UnsuccessfulItemList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "unsuccessful"))
    }
end

module CustomerGateway = struct
  type t =
    { bgp_asn : String.t
    ; customer_gateway_id : String.t
    ; ip_address : String.t
    ; certificate_arn : String.t option
    ; state : String.t
    ; type_ : String.t
    ; device_name : String.t option
    ; tags : TagList.t
    }

  let make
      ~bgp_asn
      ~customer_gateway_id
      ~ip_address
      ?certificate_arn
      ~state
      ~type_
      ?device_name
      ?(tags = [])
      () =
    { bgp_asn
    ; customer_gateway_id
    ; ip_address
    ; certificate_arn
    ; state
    ; type_
    ; device_name
    ; tags
    }

  let parse xml =
    Some
      { bgp_asn =
          Aws.Xml.required
            "bgpAsn"
            (Aws.Util.option_bind (Aws.Xml.member "bgpAsn" xml) String.parse)
      ; customer_gateway_id =
          Aws.Xml.required
            "customerGatewayId"
            (Aws.Util.option_bind (Aws.Xml.member "customerGatewayId" xml) String.parse)
      ; ip_address =
          Aws.Xml.required
            "ipAddress"
            (Aws.Util.option_bind (Aws.Xml.member "ipAddress" xml) String.parse)
      ; certificate_arn =
          Aws.Util.option_bind (Aws.Xml.member "certificateArn" xml) String.parse
      ; state =
          Aws.Xml.required
            "state"
            (Aws.Util.option_bind (Aws.Xml.member "state" xml) String.parse)
      ; type_ =
          Aws.Xml.required
            "type"
            (Aws.Util.option_bind (Aws.Xml.member "type" xml) String.parse)
      ; device_name = Aws.Util.option_bind (Aws.Xml.member "deviceName" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.device_name (fun f ->
               Aws.Query.Pair ("DeviceName", String.to_query f))
         ; Some (Aws.Query.Pair ("Type", String.to_query v.type_))
         ; Some (Aws.Query.Pair ("State", String.to_query v.state))
         ; Aws.Util.option_map v.certificate_arn (fun f ->
               Aws.Query.Pair ("CertificateArn", String.to_query f))
         ; Some (Aws.Query.Pair ("IpAddress", String.to_query v.ip_address))
         ; Some
             (Aws.Query.Pair ("CustomerGatewayId", String.to_query v.customer_gateway_id))
         ; Some (Aws.Query.Pair ("BgpAsn", String.to_query v.bgp_asn))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.device_name (fun f -> "deviceName", String.to_json f)
         ; Some ("type", String.to_json v.type_)
         ; Some ("state", String.to_json v.state)
         ; Aws.Util.option_map v.certificate_arn (fun f ->
               "certificateArn", String.to_json f)
         ; Some ("ipAddress", String.to_json v.ip_address)
         ; Some ("customerGatewayId", String.to_json v.customer_gateway_id)
         ; Some ("bgpAsn", String.to_json v.bgp_asn)
         ])

  let of_json j =
    { bgp_asn = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "bgpAsn"))
    ; customer_gateway_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "customerGatewayId"))
    ; ip_address = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ipAddress"))
    ; certificate_arn =
        Aws.Util.option_map (Aws.Json.lookup j "certificateArn") String.of_json
    ; state = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "state"))
    ; type_ = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "type"))
    ; device_name = Aws.Util.option_map (Aws.Json.lookup j "deviceName") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module CustomerGatewayList = struct
  type t = CustomerGateway.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map CustomerGateway.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list CustomerGateway.to_query v

  let to_json v = `List (List.map CustomerGateway.to_json v)

  let of_json j = Aws.Json.to_list CustomerGateway.of_json j
end

module SnapshotDiskContainer = struct
  type t =
    { description : String.t option
    ; format : String.t option
    ; url : String.t option
    ; user_bucket : UserBucket.t option
    }

  let make ?description ?format ?url ?user_bucket () =
    { description; format; url; user_bucket }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; format = Aws.Util.option_bind (Aws.Xml.member "Format" xml) String.parse
      ; url = Aws.Util.option_bind (Aws.Xml.member "Url" xml) String.parse
      ; user_bucket =
          Aws.Util.option_bind (Aws.Xml.member "UserBucket" xml) UserBucket.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.user_bucket (fun f ->
               Aws.Query.Pair ("UserBucket", UserBucket.to_query f))
         ; Aws.Util.option_map v.url (fun f -> Aws.Query.Pair ("Url", String.to_query f))
         ; Aws.Util.option_map v.format (fun f ->
               Aws.Query.Pair ("Format", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.user_bucket (fun f -> "UserBucket", UserBucket.to_json f)
         ; Aws.Util.option_map v.url (fun f -> "Url", String.to_json f)
         ; Aws.Util.option_map v.format (fun f -> "Format", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; format = Aws.Util.option_map (Aws.Json.lookup j "Format") String.of_json
    ; url = Aws.Util.option_map (Aws.Json.lookup j "Url") String.of_json
    ; user_bucket =
        Aws.Util.option_map (Aws.Json.lookup j "UserBucket") UserBucket.of_json
    }
end

module ImportSnapshotRequest = struct
  type t =
    { client_data : ClientData.t option
    ; client_token : String.t option
    ; description : String.t option
    ; disk_container : SnapshotDiskContainer.t option
    ; dry_run : Boolean.t option
    ; encrypted : Boolean.t option
    ; kms_key_id : String.t option
    ; role_name : String.t option
    ; tag_specifications : TagSpecificationList.t
    }

  let make
      ?client_data
      ?client_token
      ?description
      ?disk_container
      ?dry_run
      ?encrypted
      ?kms_key_id
      ?role_name
      ?(tag_specifications = [])
      () =
    { client_data
    ; client_token
    ; description
    ; disk_container
    ; dry_run
    ; encrypted
    ; kms_key_id
    ; role_name
    ; tag_specifications
    }

  let parse xml =
    Some
      { client_data =
          Aws.Util.option_bind (Aws.Xml.member "ClientData" xml) ClientData.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; disk_container =
          Aws.Util.option_bind
            (Aws.Xml.member "DiskContainer" xml)
            SnapshotDiskContainer.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; encrypted = Aws.Util.option_bind (Aws.Xml.member "Encrypted" xml) Boolean.parse
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "KmsKeyId" xml) String.parse
      ; role_name = Aws.Util.option_bind (Aws.Xml.member "RoleName" xml) String.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Aws.Util.option_map v.role_name (fun f ->
               Aws.Query.Pair ("RoleName", String.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Aws.Util.option_map v.encrypted (fun f ->
               Aws.Query.Pair ("Encrypted", Boolean.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.disk_container (fun f ->
               Aws.Query.Pair ("DiskContainer", SnapshotDiskContainer.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.client_data (fun f ->
               Aws.Query.Pair ("ClientData", ClientData.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Aws.Util.option_map v.role_name (fun f -> "RoleName", String.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "KmsKeyId", String.to_json f)
         ; Aws.Util.option_map v.encrypted (fun f -> "Encrypted", Boolean.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.disk_container (fun f ->
               "DiskContainer", SnapshotDiskContainer.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Aws.Util.option_map v.client_data (fun f -> "ClientData", ClientData.to_json f)
         ])

  let of_json j =
    { client_data =
        Aws.Util.option_map (Aws.Json.lookup j "ClientData") ClientData.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; disk_container =
        Aws.Util.option_map
          (Aws.Json.lookup j "DiskContainer")
          SnapshotDiskContainer.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; encrypted = Aws.Util.option_map (Aws.Json.lookup j "Encrypted") Boolean.of_json
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "KmsKeyId") String.of_json
    ; role_name = Aws.Util.option_map (Aws.Json.lookup j "RoleName") String.of_json
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    }
end

module DescribeRouteTablesRequest = struct
  type t =
    { filters : FilterList.t
    ; dry_run : Boolean.t option
    ; route_table_ids : RouteTableIdStringList.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    }

  let make ?(filters = []) ?dry_run ?(route_table_ids = []) ?next_token ?max_results () =
    { filters; dry_run; route_table_ids; next_token; max_results }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; route_table_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "RouteTableId" xml)
               RouteTableIdStringList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("RouteTableId", RouteTableIdStringList.to_query v.route_table_ids))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("RouteTableId", RouteTableIdStringList.to_json v.route_table_ids)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; route_table_ids =
        RouteTableIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "RouteTableId"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module RemovePrefixListEntry = struct
  type t = { cidr : String.t }

  let make ~cidr () = { cidr }

  let parse xml =
    Some
      { cidr =
          Aws.Xml.required
            "Cidr"
            (Aws.Util.option_bind (Aws.Xml.member "Cidr" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Cidr", String.to_query v.cidr)) ])

  let to_json v =
    `Assoc (Aws.Util.list_filter_opt [ Some ("Cidr", String.to_json v.cidr) ])

  let of_json j =
    { cidr = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Cidr")) }
end

module RemovePrefixListEntries = struct
  type t = RemovePrefixListEntry.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map RemovePrefixListEntry.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list RemovePrefixListEntry.to_query v

  let to_json v = `List (List.map RemovePrefixListEntry.to_json v)

  let of_json j = Aws.Json.to_list RemovePrefixListEntry.of_json j
end

module AddPrefixListEntry = struct
  type t =
    { cidr : String.t
    ; description : String.t option
    }

  let make ~cidr ?description () = { cidr; description }

  let parse xml =
    Some
      { cidr =
          Aws.Xml.required
            "Cidr"
            (Aws.Util.option_bind (Aws.Xml.member "Cidr" xml) String.parse)
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Some (Aws.Query.Pair ("Cidr", String.to_query v.cidr))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Some ("Cidr", String.to_json v.cidr)
         ])

  let of_json j =
    { cidr = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Cidr"))
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    }
end

module AddPrefixListEntries = struct
  type t = AddPrefixListEntry.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map AddPrefixListEntry.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list AddPrefixListEntry.to_query v

  let to_json v = `List (List.map AddPrefixListEntry.to_json v)

  let of_json j = Aws.Json.to_list AddPrefixListEntry.of_json j
end

module ModifyManagedPrefixListRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; prefix_list_id : String.t
    ; current_version : Long.t option
    ; prefix_list_name : String.t option
    ; add_entries : AddPrefixListEntries.t
    ; remove_entries : RemovePrefixListEntries.t
    }

  let make
      ?dry_run
      ~prefix_list_id
      ?current_version
      ?prefix_list_name
      ?(add_entries = [])
      ?(remove_entries = [])
      () =
    { dry_run
    ; prefix_list_id
    ; current_version
    ; prefix_list_name
    ; add_entries
    ; remove_entries
    }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; prefix_list_id =
          Aws.Xml.required
            "PrefixListId"
            (Aws.Util.option_bind (Aws.Xml.member "PrefixListId" xml) String.parse)
      ; current_version =
          Aws.Util.option_bind (Aws.Xml.member "CurrentVersion" xml) Long.parse
      ; prefix_list_name =
          Aws.Util.option_bind (Aws.Xml.member "PrefixListName" xml) String.parse
      ; add_entries =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AddEntry" xml)
               AddPrefixListEntries.parse)
      ; remove_entries =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "RemoveEntry" xml)
               RemovePrefixListEntries.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("RemoveEntry", RemovePrefixListEntries.to_query v.remove_entries))
         ; Some (Aws.Query.Pair ("AddEntry", AddPrefixListEntries.to_query v.add_entries))
         ; Aws.Util.option_map v.prefix_list_name (fun f ->
               Aws.Query.Pair ("PrefixListName", String.to_query f))
         ; Aws.Util.option_map v.current_version (fun f ->
               Aws.Query.Pair ("CurrentVersion", Long.to_query f))
         ; Some (Aws.Query.Pair ("PrefixListId", String.to_query v.prefix_list_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("RemoveEntry", RemovePrefixListEntries.to_json v.remove_entries)
         ; Some ("AddEntry", AddPrefixListEntries.to_json v.add_entries)
         ; Aws.Util.option_map v.prefix_list_name (fun f ->
               "PrefixListName", String.to_json f)
         ; Aws.Util.option_map v.current_version (fun f ->
               "CurrentVersion", Long.to_json f)
         ; Some ("PrefixListId", String.to_json v.prefix_list_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; prefix_list_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PrefixListId"))
    ; current_version =
        Aws.Util.option_map (Aws.Json.lookup j "CurrentVersion") Long.of_json
    ; prefix_list_name =
        Aws.Util.option_map (Aws.Json.lookup j "PrefixListName") String.of_json
    ; add_entries =
        AddPrefixListEntries.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AddEntry"))
    ; remove_entries =
        RemovePrefixListEntries.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "RemoveEntry"))
    }
end

module CreateVolumePermission = struct
  type t =
    { group : PermissionGroup.t option
    ; user_id : String.t option
    }

  let make ?group ?user_id () = { group; user_id }

  let parse xml =
    Some
      { group = Aws.Util.option_bind (Aws.Xml.member "group" xml) PermissionGroup.parse
      ; user_id = Aws.Util.option_bind (Aws.Xml.member "userId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.user_id (fun f ->
               Aws.Query.Pair ("UserId", String.to_query f))
         ; Aws.Util.option_map v.group (fun f ->
               Aws.Query.Pair ("Group", PermissionGroup.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.user_id (fun f -> "userId", String.to_json f)
         ; Aws.Util.option_map v.group (fun f -> "group", PermissionGroup.to_json f)
         ])

  let of_json j =
    { group = Aws.Util.option_map (Aws.Json.lookup j "group") PermissionGroup.of_json
    ; user_id = Aws.Util.option_map (Aws.Json.lookup j "userId") String.of_json
    }
end

module CreateVolumePermissionList = struct
  type t = CreateVolumePermission.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map CreateVolumePermission.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list CreateVolumePermission.to_query v

  let to_json v = `List (List.map CreateVolumePermission.to_json v)

  let of_json j = Aws.Json.to_list CreateVolumePermission.of_json j
end

module CreateVolumePermissionModifications = struct
  type t =
    { add : CreateVolumePermissionList.t
    ; remove : CreateVolumePermissionList.t
    }

  let make ?(add = []) ?(remove = []) () = { add; remove }

  let parse xml =
    Some
      { add =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Add" xml)
               CreateVolumePermissionList.parse)
      ; remove =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Remove" xml)
               CreateVolumePermissionList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Remove", CreateVolumePermissionList.to_query v.remove))
         ; Some (Aws.Query.Pair ("Add", CreateVolumePermissionList.to_query v.add))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Remove", CreateVolumePermissionList.to_json v.remove)
         ; Some ("Add", CreateVolumePermissionList.to_json v.add)
         ])

  let of_json j =
    { add =
        CreateVolumePermissionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Add"))
    ; remove =
        CreateVolumePermissionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Remove"))
    }
end

module ElasticGpuIdSet = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module TransitGatewayOptions = struct
  type t =
    { amazon_side_asn : Long.t option
    ; auto_accept_shared_attachments : AutoAcceptSharedAttachmentsValue.t option
    ; default_route_table_association : DefaultRouteTableAssociationValue.t option
    ; association_default_route_table_id : String.t option
    ; default_route_table_propagation : DefaultRouteTablePropagationValue.t option
    ; propagation_default_route_table_id : String.t option
    ; vpn_ecmp_support : VpnEcmpSupportValue.t option
    ; dns_support : DnsSupportValue.t option
    ; multicast_support : MulticastSupportValue.t option
    }

  let make
      ?amazon_side_asn
      ?auto_accept_shared_attachments
      ?default_route_table_association
      ?association_default_route_table_id
      ?default_route_table_propagation
      ?propagation_default_route_table_id
      ?vpn_ecmp_support
      ?dns_support
      ?multicast_support
      () =
    { amazon_side_asn
    ; auto_accept_shared_attachments
    ; default_route_table_association
    ; association_default_route_table_id
    ; default_route_table_propagation
    ; propagation_default_route_table_id
    ; vpn_ecmp_support
    ; dns_support
    ; multicast_support
    }

  let parse xml =
    Some
      { amazon_side_asn =
          Aws.Util.option_bind (Aws.Xml.member "amazonSideAsn" xml) Long.parse
      ; auto_accept_shared_attachments =
          Aws.Util.option_bind
            (Aws.Xml.member "autoAcceptSharedAttachments" xml)
            AutoAcceptSharedAttachmentsValue.parse
      ; default_route_table_association =
          Aws.Util.option_bind
            (Aws.Xml.member "defaultRouteTableAssociation" xml)
            DefaultRouteTableAssociationValue.parse
      ; association_default_route_table_id =
          Aws.Util.option_bind
            (Aws.Xml.member "associationDefaultRouteTableId" xml)
            String.parse
      ; default_route_table_propagation =
          Aws.Util.option_bind
            (Aws.Xml.member "defaultRouteTablePropagation" xml)
            DefaultRouteTablePropagationValue.parse
      ; propagation_default_route_table_id =
          Aws.Util.option_bind
            (Aws.Xml.member "propagationDefaultRouteTableId" xml)
            String.parse
      ; vpn_ecmp_support =
          Aws.Util.option_bind
            (Aws.Xml.member "vpnEcmpSupport" xml)
            VpnEcmpSupportValue.parse
      ; dns_support =
          Aws.Util.option_bind (Aws.Xml.member "dnsSupport" xml) DnsSupportValue.parse
      ; multicast_support =
          Aws.Util.option_bind
            (Aws.Xml.member "multicastSupport" xml)
            MulticastSupportValue.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.multicast_support (fun f ->
               Aws.Query.Pair ("MulticastSupport", MulticastSupportValue.to_query f))
         ; Aws.Util.option_map v.dns_support (fun f ->
               Aws.Query.Pair ("DnsSupport", DnsSupportValue.to_query f))
         ; Aws.Util.option_map v.vpn_ecmp_support (fun f ->
               Aws.Query.Pair ("VpnEcmpSupport", VpnEcmpSupportValue.to_query f))
         ; Aws.Util.option_map v.propagation_default_route_table_id (fun f ->
               Aws.Query.Pair ("PropagationDefaultRouteTableId", String.to_query f))
         ; Aws.Util.option_map v.default_route_table_propagation (fun f ->
               Aws.Query.Pair
                 ( "DefaultRouteTablePropagation"
                 , DefaultRouteTablePropagationValue.to_query f ))
         ; Aws.Util.option_map v.association_default_route_table_id (fun f ->
               Aws.Query.Pair ("AssociationDefaultRouteTableId", String.to_query f))
         ; Aws.Util.option_map v.default_route_table_association (fun f ->
               Aws.Query.Pair
                 ( "DefaultRouteTableAssociation"
                 , DefaultRouteTableAssociationValue.to_query f ))
         ; Aws.Util.option_map v.auto_accept_shared_attachments (fun f ->
               Aws.Query.Pair
                 ( "AutoAcceptSharedAttachments"
                 , AutoAcceptSharedAttachmentsValue.to_query f ))
         ; Aws.Util.option_map v.amazon_side_asn (fun f ->
               Aws.Query.Pair ("AmazonSideAsn", Long.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.multicast_support (fun f ->
               "multicastSupport", MulticastSupportValue.to_json f)
         ; Aws.Util.option_map v.dns_support (fun f ->
               "dnsSupport", DnsSupportValue.to_json f)
         ; Aws.Util.option_map v.vpn_ecmp_support (fun f ->
               "vpnEcmpSupport", VpnEcmpSupportValue.to_json f)
         ; Aws.Util.option_map v.propagation_default_route_table_id (fun f ->
               "propagationDefaultRouteTableId", String.to_json f)
         ; Aws.Util.option_map v.default_route_table_propagation (fun f ->
               "defaultRouteTablePropagation", DefaultRouteTablePropagationValue.to_json f)
         ; Aws.Util.option_map v.association_default_route_table_id (fun f ->
               "associationDefaultRouteTableId", String.to_json f)
         ; Aws.Util.option_map v.default_route_table_association (fun f ->
               "defaultRouteTableAssociation", DefaultRouteTableAssociationValue.to_json f)
         ; Aws.Util.option_map v.auto_accept_shared_attachments (fun f ->
               "autoAcceptSharedAttachments", AutoAcceptSharedAttachmentsValue.to_json f)
         ; Aws.Util.option_map v.amazon_side_asn (fun f ->
               "amazonSideAsn", Long.to_json f)
         ])

  let of_json j =
    { amazon_side_asn =
        Aws.Util.option_map (Aws.Json.lookup j "amazonSideAsn") Long.of_json
    ; auto_accept_shared_attachments =
        Aws.Util.option_map
          (Aws.Json.lookup j "autoAcceptSharedAttachments")
          AutoAcceptSharedAttachmentsValue.of_json
    ; default_route_table_association =
        Aws.Util.option_map
          (Aws.Json.lookup j "defaultRouteTableAssociation")
          DefaultRouteTableAssociationValue.of_json
    ; association_default_route_table_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "associationDefaultRouteTableId")
          String.of_json
    ; default_route_table_propagation =
        Aws.Util.option_map
          (Aws.Json.lookup j "defaultRouteTablePropagation")
          DefaultRouteTablePropagationValue.of_json
    ; propagation_default_route_table_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "propagationDefaultRouteTableId")
          String.of_json
    ; vpn_ecmp_support =
        Aws.Util.option_map
          (Aws.Json.lookup j "vpnEcmpSupport")
          VpnEcmpSupportValue.of_json
    ; dns_support =
        Aws.Util.option_map (Aws.Json.lookup j "dnsSupport") DnsSupportValue.of_json
    ; multicast_support =
        Aws.Util.option_map
          (Aws.Json.lookup j "multicastSupport")
          MulticastSupportValue.of_json
    }
end

module TransitGateway = struct
  type t =
    { transit_gateway_id : String.t option
    ; transit_gateway_arn : String.t option
    ; state : TransitGatewayState.t option
    ; owner_id : String.t option
    ; description : String.t option
    ; creation_time : DateTime.t option
    ; options : TransitGatewayOptions.t option
    ; tags : TagList.t
    }

  let make
      ?transit_gateway_id
      ?transit_gateway_arn
      ?state
      ?owner_id
      ?description
      ?creation_time
      ?options
      ?(tags = [])
      () =
    { transit_gateway_id
    ; transit_gateway_arn
    ; state
    ; owner_id
    ; description
    ; creation_time
    ; options
    ; tags
    }

  let parse xml =
    Some
      { transit_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "transitGatewayId" xml) String.parse
      ; transit_gateway_arn =
          Aws.Util.option_bind (Aws.Xml.member "transitGatewayArn" xml) String.parse
      ; state =
          Aws.Util.option_bind (Aws.Xml.member "state" xml) TransitGatewayState.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; creation_time =
          Aws.Util.option_bind (Aws.Xml.member "creationTime" xml) DateTime.parse
      ; options =
          Aws.Util.option_bind (Aws.Xml.member "options" xml) TransitGatewayOptions.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.options (fun f ->
               Aws.Query.Pair ("Options", TransitGatewayOptions.to_query f))
         ; Aws.Util.option_map v.creation_time (fun f ->
               Aws.Query.Pair ("CreationTime", DateTime.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", TransitGatewayState.to_query f))
         ; Aws.Util.option_map v.transit_gateway_arn (fun f ->
               Aws.Query.Pair ("TransitGatewayArn", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_id (fun f ->
               Aws.Query.Pair ("TransitGatewayId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.options (fun f ->
               "options", TransitGatewayOptions.to_json f)
         ; Aws.Util.option_map v.creation_time (fun f ->
               "creationTime", DateTime.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.state (fun f -> "state", TransitGatewayState.to_json f)
         ; Aws.Util.option_map v.transit_gateway_arn (fun f ->
               "transitGatewayArn", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_id (fun f ->
               "transitGatewayId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "transitGatewayId") String.of_json
    ; transit_gateway_arn =
        Aws.Util.option_map (Aws.Json.lookup j "transitGatewayArn") String.of_json
    ; state = Aws.Util.option_map (Aws.Json.lookup j "state") TransitGatewayState.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; creation_time =
        Aws.Util.option_map (Aws.Json.lookup j "creationTime") DateTime.of_json
    ; options =
        Aws.Util.option_map (Aws.Json.lookup j "options") TransitGatewayOptions.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module ModifyTransitGatewayResult = struct
  type t = { transit_gateway : TransitGateway.t option }

  let make ?transit_gateway () = { transit_gateway }

  let parse xml =
    Some
      { transit_gateway =
          Aws.Util.option_bind (Aws.Xml.member "transitGateway" xml) TransitGateway.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway (fun f ->
               Aws.Query.Pair ("TransitGateway", TransitGateway.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway (fun f ->
               "transitGateway", TransitGateway.to_json f)
         ])

  let of_json j =
    { transit_gateway =
        Aws.Util.option_map (Aws.Json.lookup j "transitGateway") TransitGateway.of_json
    }
end

module CreateEgressOnlyInternetGatewayRequest = struct
  type t =
    { client_token : String.t option
    ; dry_run : Boolean.t option
    ; vpc_id : String.t
    ; tag_specifications : TagSpecificationList.t
    }

  let make ?client_token ?dry_run ~vpc_id ?(tag_specifications = []) () =
    { client_token; dry_run; vpc_id; tag_specifications }

  let parse xml =
    Some
      { client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; vpc_id =
          Aws.Xml.required
            "VpcId"
            (Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) String.parse)
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Some ("VpcId", String.to_json v.vpc_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ])

  let of_json j =
    { client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcId"))
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    }
end

module InstanceMatchCriteria = struct
  type t =
    | Open
    | Targeted

  let str_to_t = [ "targeted", Targeted; "open", Open ]

  let t_to_str = [ Targeted, "targeted"; Open, "open" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ResetFpgaImageAttributeName = struct
  type t = LoadPermission

  let str_to_t = [ "loadPermission", LoadPermission ]

  let t_to_str = [ LoadPermission, "loadPermission" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module RequestSpotLaunchSpecificationSecurityGroupIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module ConversionIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module AttributeValue = struct
  type t = { value : String.t option }

  let make ?value () = { value }

  let parse xml =
    Some { value = Aws.Util.option_bind (Aws.Xml.member "value" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f -> "value", String.to_json f) ])

  let of_json j =
    { value = Aws.Util.option_map (Aws.Json.lookup j "value") String.of_json }
end

module InstanceAttribute = struct
  type t =
    { groups : GroupIdentifierList.t
    ; block_device_mappings : InstanceBlockDeviceMappingList.t
    ; disable_api_termination : AttributeBooleanValue.t option
    ; ena_support : AttributeBooleanValue.t option
    ; enclave_options : EnclaveOptions.t option
    ; ebs_optimized : AttributeBooleanValue.t option
    ; instance_id : String.t option
    ; instance_initiated_shutdown_behavior : AttributeValue.t option
    ; instance_type : AttributeValue.t option
    ; kernel_id : AttributeValue.t option
    ; product_codes : ProductCodeList.t
    ; ramdisk_id : AttributeValue.t option
    ; root_device_name : AttributeValue.t option
    ; source_dest_check : AttributeBooleanValue.t option
    ; sriov_net_support : AttributeValue.t option
    ; user_data : AttributeValue.t option
    }

  let make
      ?(groups = [])
      ?(block_device_mappings = [])
      ?disable_api_termination
      ?ena_support
      ?enclave_options
      ?ebs_optimized
      ?instance_id
      ?instance_initiated_shutdown_behavior
      ?instance_type
      ?kernel_id
      ?(product_codes = [])
      ?ramdisk_id
      ?root_device_name
      ?source_dest_check
      ?sriov_net_support
      ?user_data
      () =
    { groups
    ; block_device_mappings
    ; disable_api_termination
    ; ena_support
    ; enclave_options
    ; ebs_optimized
    ; instance_id
    ; instance_initiated_shutdown_behavior
    ; instance_type
    ; kernel_id
    ; product_codes
    ; ramdisk_id
    ; root_device_name
    ; source_dest_check
    ; sriov_net_support
    ; user_data
    }

  let parse xml =
    Some
      { groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "groupSet" xml)
               GroupIdentifierList.parse)
      ; block_device_mappings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "blockDeviceMapping" xml)
               InstanceBlockDeviceMappingList.parse)
      ; disable_api_termination =
          Aws.Util.option_bind
            (Aws.Xml.member "disableApiTermination" xml)
            AttributeBooleanValue.parse
      ; ena_support =
          Aws.Util.option_bind
            (Aws.Xml.member "enaSupport" xml)
            AttributeBooleanValue.parse
      ; enclave_options =
          Aws.Util.option_bind (Aws.Xml.member "enclaveOptions" xml) EnclaveOptions.parse
      ; ebs_optimized =
          Aws.Util.option_bind
            (Aws.Xml.member "ebsOptimized" xml)
            AttributeBooleanValue.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      ; instance_initiated_shutdown_behavior =
          Aws.Util.option_bind
            (Aws.Xml.member "instanceInitiatedShutdownBehavior" xml)
            AttributeValue.parse
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) AttributeValue.parse
      ; kernel_id =
          Aws.Util.option_bind (Aws.Xml.member "kernel" xml) AttributeValue.parse
      ; product_codes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "productCodes" xml)
               ProductCodeList.parse)
      ; ramdisk_id =
          Aws.Util.option_bind (Aws.Xml.member "ramdisk" xml) AttributeValue.parse
      ; root_device_name =
          Aws.Util.option_bind (Aws.Xml.member "rootDeviceName" xml) AttributeValue.parse
      ; source_dest_check =
          Aws.Util.option_bind
            (Aws.Xml.member "sourceDestCheck" xml)
            AttributeBooleanValue.parse
      ; sriov_net_support =
          Aws.Util.option_bind (Aws.Xml.member "sriovNetSupport" xml) AttributeValue.parse
      ; user_data =
          Aws.Util.option_bind (Aws.Xml.member "userData" xml) AttributeValue.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.user_data (fun f ->
               Aws.Query.Pair ("UserData", AttributeValue.to_query f))
         ; Aws.Util.option_map v.sriov_net_support (fun f ->
               Aws.Query.Pair ("SriovNetSupport", AttributeValue.to_query f))
         ; Aws.Util.option_map v.source_dest_check (fun f ->
               Aws.Query.Pair ("SourceDestCheck", AttributeBooleanValue.to_query f))
         ; Aws.Util.option_map v.root_device_name (fun f ->
               Aws.Query.Pair ("RootDeviceName", AttributeValue.to_query f))
         ; Aws.Util.option_map v.ramdisk_id (fun f ->
               Aws.Query.Pair ("Ramdisk", AttributeValue.to_query f))
         ; Some
             (Aws.Query.Pair ("ProductCodes", ProductCodeList.to_query v.product_codes))
         ; Aws.Util.option_map v.kernel_id (fun f ->
               Aws.Query.Pair ("Kernel", AttributeValue.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", AttributeValue.to_query f))
         ; Aws.Util.option_map v.instance_initiated_shutdown_behavior (fun f ->
               Aws.Query.Pair
                 ("InstanceInitiatedShutdownBehavior", AttributeValue.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.ebs_optimized (fun f ->
               Aws.Query.Pair ("EbsOptimized", AttributeBooleanValue.to_query f))
         ; Aws.Util.option_map v.enclave_options (fun f ->
               Aws.Query.Pair ("EnclaveOptions", EnclaveOptions.to_query f))
         ; Aws.Util.option_map v.ena_support (fun f ->
               Aws.Query.Pair ("EnaSupport", AttributeBooleanValue.to_query f))
         ; Aws.Util.option_map v.disable_api_termination (fun f ->
               Aws.Query.Pair ("DisableApiTermination", AttributeBooleanValue.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "BlockDeviceMapping"
                , InstanceBlockDeviceMappingList.to_query v.block_device_mappings ))
         ; Some (Aws.Query.Pair ("GroupSet", GroupIdentifierList.to_query v.groups))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.user_data (fun f -> "userData", AttributeValue.to_json f)
         ; Aws.Util.option_map v.sriov_net_support (fun f ->
               "sriovNetSupport", AttributeValue.to_json f)
         ; Aws.Util.option_map v.source_dest_check (fun f ->
               "sourceDestCheck", AttributeBooleanValue.to_json f)
         ; Aws.Util.option_map v.root_device_name (fun f ->
               "rootDeviceName", AttributeValue.to_json f)
         ; Aws.Util.option_map v.ramdisk_id (fun f -> "ramdisk", AttributeValue.to_json f)
         ; Some ("productCodes", ProductCodeList.to_json v.product_codes)
         ; Aws.Util.option_map v.kernel_id (fun f -> "kernel", AttributeValue.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f ->
               "instanceType", AttributeValue.to_json f)
         ; Aws.Util.option_map v.instance_initiated_shutdown_behavior (fun f ->
               "instanceInitiatedShutdownBehavior", AttributeValue.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ; Aws.Util.option_map v.ebs_optimized (fun f ->
               "ebsOptimized", AttributeBooleanValue.to_json f)
         ; Aws.Util.option_map v.enclave_options (fun f ->
               "enclaveOptions", EnclaveOptions.to_json f)
         ; Aws.Util.option_map v.ena_support (fun f ->
               "enaSupport", AttributeBooleanValue.to_json f)
         ; Aws.Util.option_map v.disable_api_termination (fun f ->
               "disableApiTermination", AttributeBooleanValue.to_json f)
         ; Some
             ( "blockDeviceMapping"
             , InstanceBlockDeviceMappingList.to_json v.block_device_mappings )
         ; Some ("groupSet", GroupIdentifierList.to_json v.groups)
         ])

  let of_json j =
    { groups =
        GroupIdentifierList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "groupSet"))
    ; block_device_mappings =
        InstanceBlockDeviceMappingList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "blockDeviceMapping"))
    ; disable_api_termination =
        Aws.Util.option_map
          (Aws.Json.lookup j "disableApiTermination")
          AttributeBooleanValue.of_json
    ; ena_support =
        Aws.Util.option_map (Aws.Json.lookup j "enaSupport") AttributeBooleanValue.of_json
    ; enclave_options =
        Aws.Util.option_map (Aws.Json.lookup j "enclaveOptions") EnclaveOptions.of_json
    ; ebs_optimized =
        Aws.Util.option_map
          (Aws.Json.lookup j "ebsOptimized")
          AttributeBooleanValue.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    ; instance_initiated_shutdown_behavior =
        Aws.Util.option_map
          (Aws.Json.lookup j "instanceInitiatedShutdownBehavior")
          AttributeValue.of_json
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") AttributeValue.of_json
    ; kernel_id = Aws.Util.option_map (Aws.Json.lookup j "kernel") AttributeValue.of_json
    ; product_codes =
        ProductCodeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "productCodes"))
    ; ramdisk_id =
        Aws.Util.option_map (Aws.Json.lookup j "ramdisk") AttributeValue.of_json
    ; root_device_name =
        Aws.Util.option_map (Aws.Json.lookup j "rootDeviceName") AttributeValue.of_json
    ; source_dest_check =
        Aws.Util.option_map
          (Aws.Json.lookup j "sourceDestCheck")
          AttributeBooleanValue.of_json
    ; sriov_net_support =
        Aws.Util.option_map (Aws.Json.lookup j "sriovNetSupport") AttributeValue.of_json
    ; user_data =
        Aws.Util.option_map (Aws.Json.lookup j "userData") AttributeValue.of_json
    }
end

module VpcIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "VpcId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module CreateRouteTableRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; vpc_id : String.t
    ; tag_specifications : TagSpecificationList.t
    }

  let make ?dry_run ~vpc_id ?(tag_specifications = []) () =
    { dry_run; vpc_id; tag_specifications }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; vpc_id =
          Aws.Xml.required
            "vpcId"
            (Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse)
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Some ("vpcId", String.to_json v.vpc_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "vpcId"))
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    }
end

module HostInstance = struct
  type t =
    { instance_id : String.t option
    ; instance_type : String.t option
    ; owner_id : String.t option
    }

  let make ?instance_id ?instance_type ?owner_id () =
    { instance_id; instance_type; owner_id }

  let parse xml =
    Some
      { instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) String.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", String.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f -> "instanceType", String.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ])

  let of_json j =
    { instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") String.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    }
end

module PrefixListEntry = struct
  type t =
    { cidr : String.t option
    ; description : String.t option
    }

  let make ?cidr ?description () = { cidr; description }

  let parse xml =
    Some
      { cidr = Aws.Util.option_bind (Aws.Xml.member "cidr" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.cidr (fun f ->
               Aws.Query.Pair ("Cidr", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Aws.Util.option_map v.cidr (fun f -> "cidr", String.to_json f)
         ])

  let of_json j =
    { cidr = Aws.Util.option_map (Aws.Json.lookup j "cidr") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    }
end

module AssociateSubnetCidrBlockResult = struct
  type t =
    { ipv6_cidr_block_association : SubnetIpv6CidrBlockAssociation.t option
    ; subnet_id : String.t option
    }

  let make ?ipv6_cidr_block_association ?subnet_id () =
    { ipv6_cidr_block_association; subnet_id }

  let parse xml =
    Some
      { ipv6_cidr_block_association =
          Aws.Util.option_bind
            (Aws.Xml.member "ipv6CidrBlockAssociation" xml)
            SubnetIpv6CidrBlockAssociation.parse
      ; subnet_id = Aws.Util.option_bind (Aws.Xml.member "subnetId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.subnet_id (fun f ->
               Aws.Query.Pair ("SubnetId", String.to_query f))
         ; Aws.Util.option_map v.ipv6_cidr_block_association (fun f ->
               Aws.Query.Pair
                 ("Ipv6CidrBlockAssociation", SubnetIpv6CidrBlockAssociation.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.subnet_id (fun f -> "subnetId", String.to_json f)
         ; Aws.Util.option_map v.ipv6_cidr_block_association (fun f ->
               "ipv6CidrBlockAssociation", SubnetIpv6CidrBlockAssociation.to_json f)
         ])

  let of_json j =
    { ipv6_cidr_block_association =
        Aws.Util.option_map
          (Aws.Json.lookup j "ipv6CidrBlockAssociation")
          SubnetIpv6CidrBlockAssociation.of_json
    ; subnet_id = Aws.Util.option_map (Aws.Json.lookup j "subnetId") String.of_json
    }
end

module DescribeTransitGatewayRouteTablesResult = struct
  type t =
    { transit_gateway_route_tables : TransitGatewayRouteTableList.t
    ; next_token : String.t option
    }

  let make ?(transit_gateway_route_tables = []) ?next_token () =
    { transit_gateway_route_tables; next_token }

  let parse xml =
    Some
      { transit_gateway_route_tables =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "transitGatewayRouteTables" xml)
               TransitGatewayRouteTableList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayRouteTables"
                , TransitGatewayRouteTableList.to_query v.transit_gateway_route_tables ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "transitGatewayRouteTables"
             , TransitGatewayRouteTableList.to_json v.transit_gateway_route_tables )
         ])

  let of_json j =
    { transit_gateway_route_tables =
        TransitGatewayRouteTableList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "transitGatewayRouteTables"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module BundleInstanceResult = struct
  type t = { bundle_task : BundleTask.t option }

  let make ?bundle_task () = { bundle_task }

  let parse xml =
    Some
      { bundle_task =
          Aws.Util.option_bind (Aws.Xml.member "bundleInstanceTask" xml) BundleTask.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.bundle_task (fun f ->
               Aws.Query.Pair ("BundleInstanceTask", BundleTask.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.bundle_task (fun f ->
               "bundleInstanceTask", BundleTask.to_json f)
         ])

  let of_json j =
    { bundle_task =
        Aws.Util.option_map (Aws.Json.lookup j "bundleInstanceTask") BundleTask.of_json
    }
end

module CreateTrafficMirrorSessionRequest = struct
  type t =
    { network_interface_id : String.t
    ; traffic_mirror_target_id : String.t
    ; traffic_mirror_filter_id : String.t
    ; packet_length : Integer.t option
    ; session_number : Integer.t
    ; virtual_network_id : Integer.t option
    ; description : String.t option
    ; tag_specifications : TagSpecificationList.t
    ; dry_run : Boolean.t option
    ; client_token : String.t option
    }

  let make
      ~network_interface_id
      ~traffic_mirror_target_id
      ~traffic_mirror_filter_id
      ?packet_length
      ~session_number
      ?virtual_network_id
      ?description
      ?(tag_specifications = [])
      ?dry_run
      ?client_token
      () =
    { network_interface_id
    ; traffic_mirror_target_id
    ; traffic_mirror_filter_id
    ; packet_length
    ; session_number
    ; virtual_network_id
    ; description
    ; tag_specifications
    ; dry_run
    ; client_token
    }

  let parse xml =
    Some
      { network_interface_id =
          Aws.Xml.required
            "NetworkInterfaceId"
            (Aws.Util.option_bind (Aws.Xml.member "NetworkInterfaceId" xml) String.parse)
      ; traffic_mirror_target_id =
          Aws.Xml.required
            "TrafficMirrorTargetId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TrafficMirrorTargetId" xml)
               String.parse)
      ; traffic_mirror_filter_id =
          Aws.Xml.required
            "TrafficMirrorFilterId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TrafficMirrorFilterId" xml)
               String.parse)
      ; packet_length =
          Aws.Util.option_bind (Aws.Xml.member "PacketLength" xml) Integer.parse
      ; session_number =
          Aws.Xml.required
            "SessionNumber"
            (Aws.Util.option_bind (Aws.Xml.member "SessionNumber" xml) Integer.parse)
      ; virtual_network_id =
          Aws.Util.option_bind (Aws.Xml.member "VirtualNetworkId" xml) Integer.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.virtual_network_id (fun f ->
               Aws.Query.Pair ("VirtualNetworkId", Integer.to_query f))
         ; Some (Aws.Query.Pair ("SessionNumber", Integer.to_query v.session_number))
         ; Aws.Util.option_map v.packet_length (fun f ->
               Aws.Query.Pair ("PacketLength", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TrafficMirrorFilterId", String.to_query v.traffic_mirror_filter_id))
         ; Some
             (Aws.Query.Pair
                ("TrafficMirrorTargetId", String.to_query v.traffic_mirror_target_id))
         ; Some
             (Aws.Query.Pair ("NetworkInterfaceId", String.to_query v.network_interface_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.virtual_network_id (fun f ->
               "VirtualNetworkId", Integer.to_json f)
         ; Some ("SessionNumber", Integer.to_json v.session_number)
         ; Aws.Util.option_map v.packet_length (fun f ->
               "PacketLength", Integer.to_json f)
         ; Some ("TrafficMirrorFilterId", String.to_json v.traffic_mirror_filter_id)
         ; Some ("TrafficMirrorTargetId", String.to_json v.traffic_mirror_target_id)
         ; Some ("NetworkInterfaceId", String.to_json v.network_interface_id)
         ])

  let of_json j =
    { network_interface_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "NetworkInterfaceId"))
    ; traffic_mirror_target_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TrafficMirrorTargetId"))
    ; traffic_mirror_filter_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TrafficMirrorFilterId"))
    ; packet_length =
        Aws.Util.option_map (Aws.Json.lookup j "PacketLength") Integer.of_json
    ; session_number =
        Integer.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SessionNumber"))
    ; virtual_network_id =
        Aws.Util.option_map (Aws.Json.lookup j "VirtualNetworkId") Integer.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    }
end

module DomainType = struct
  type t =
    | Vpc
    | Standard

  let str_to_t = [ "standard", Standard; "vpc", Vpc ]

  let t_to_str = [ Standard, "standard"; Vpc, "vpc" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module AllocateAddressRequest = struct
  type t =
    { domain : DomainType.t option
    ; address : String.t option
    ; public_ipv4_pool : String.t option
    ; network_border_group : String.t option
    ; customer_owned_ipv4_pool : String.t option
    ; dry_run : Boolean.t option
    }

  let make
      ?domain
      ?address
      ?public_ipv4_pool
      ?network_border_group
      ?customer_owned_ipv4_pool
      ?dry_run
      () =
    { domain
    ; address
    ; public_ipv4_pool
    ; network_border_group
    ; customer_owned_ipv4_pool
    ; dry_run
    }

  let parse xml =
    Some
      { domain = Aws.Util.option_bind (Aws.Xml.member "Domain" xml) DomainType.parse
      ; address = Aws.Util.option_bind (Aws.Xml.member "Address" xml) String.parse
      ; public_ipv4_pool =
          Aws.Util.option_bind (Aws.Xml.member "PublicIpv4Pool" xml) String.parse
      ; network_border_group =
          Aws.Util.option_bind (Aws.Xml.member "NetworkBorderGroup" xml) String.parse
      ; customer_owned_ipv4_pool =
          Aws.Util.option_bind (Aws.Xml.member "CustomerOwnedIpv4Pool" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.customer_owned_ipv4_pool (fun f ->
               Aws.Query.Pair ("CustomerOwnedIpv4Pool", String.to_query f))
         ; Aws.Util.option_map v.network_border_group (fun f ->
               Aws.Query.Pair ("NetworkBorderGroup", String.to_query f))
         ; Aws.Util.option_map v.public_ipv4_pool (fun f ->
               Aws.Query.Pair ("PublicIpv4Pool", String.to_query f))
         ; Aws.Util.option_map v.address (fun f ->
               Aws.Query.Pair ("Address", String.to_query f))
         ; Aws.Util.option_map v.domain (fun f ->
               Aws.Query.Pair ("Domain", DomainType.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.customer_owned_ipv4_pool (fun f ->
               "CustomerOwnedIpv4Pool", String.to_json f)
         ; Aws.Util.option_map v.network_border_group (fun f ->
               "NetworkBorderGroup", String.to_json f)
         ; Aws.Util.option_map v.public_ipv4_pool (fun f ->
               "PublicIpv4Pool", String.to_json f)
         ; Aws.Util.option_map v.address (fun f -> "Address", String.to_json f)
         ; Aws.Util.option_map v.domain (fun f -> "Domain", DomainType.to_json f)
         ])

  let of_json j =
    { domain = Aws.Util.option_map (Aws.Json.lookup j "Domain") DomainType.of_json
    ; address = Aws.Util.option_map (Aws.Json.lookup j "Address") String.of_json
    ; public_ipv4_pool =
        Aws.Util.option_map (Aws.Json.lookup j "PublicIpv4Pool") String.of_json
    ; network_border_group =
        Aws.Util.option_map (Aws.Json.lookup j "NetworkBorderGroup") String.of_json
    ; customer_owned_ipv4_pool =
        Aws.Util.option_map (Aws.Json.lookup j "CustomerOwnedIpv4Pool") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module RejectVpcPeeringConnectionRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; vpc_peering_connection_id : String.t
    }

  let make ?dry_run ~vpc_peering_connection_id () = { dry_run; vpc_peering_connection_id }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; vpc_peering_connection_id =
          Aws.Xml.required
            "vpcPeeringConnectionId"
            (Aws.Util.option_bind
               (Aws.Xml.member "vpcPeeringConnectionId" xml)
               String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("VpcPeeringConnectionId", String.to_query v.vpc_peering_connection_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("vpcPeeringConnectionId", String.to_json v.vpc_peering_connection_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; vpc_peering_connection_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "vpcPeeringConnectionId"))
    }
end

module ModifyVpnTunnelOptionsRequest = struct
  type t =
    { vpn_connection_id : String.t
    ; vpn_tunnel_outside_ip_address : String.t
    ; tunnel_options : ModifyVpnTunnelOptionsSpecification.t
    ; dry_run : Boolean.t option
    }

  let make ~vpn_connection_id ~vpn_tunnel_outside_ip_address ~tunnel_options ?dry_run () =
    { vpn_connection_id; vpn_tunnel_outside_ip_address; tunnel_options; dry_run }

  let parse xml =
    Some
      { vpn_connection_id =
          Aws.Xml.required
            "VpnConnectionId"
            (Aws.Util.option_bind (Aws.Xml.member "VpnConnectionId" xml) String.parse)
      ; vpn_tunnel_outside_ip_address =
          Aws.Xml.required
            "VpnTunnelOutsideIpAddress"
            (Aws.Util.option_bind
               (Aws.Xml.member "VpnTunnelOutsideIpAddress" xml)
               String.parse)
      ; tunnel_options =
          Aws.Xml.required
            "TunnelOptions"
            (Aws.Util.option_bind
               (Aws.Xml.member "TunnelOptions" xml)
               ModifyVpnTunnelOptionsSpecification.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TunnelOptions"
                , ModifyVpnTunnelOptionsSpecification.to_query v.tunnel_options ))
         ; Some
             (Aws.Query.Pair
                ( "VpnTunnelOutsideIpAddress"
                , String.to_query v.vpn_tunnel_outside_ip_address ))
         ; Some (Aws.Query.Pair ("VpnConnectionId", String.to_query v.vpn_connection_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ( "TunnelOptions"
             , ModifyVpnTunnelOptionsSpecification.to_json v.tunnel_options )
         ; Some
             ("VpnTunnelOutsideIpAddress", String.to_json v.vpn_tunnel_outside_ip_address)
         ; Some ("VpnConnectionId", String.to_json v.vpn_connection_id)
         ])

  let of_json j =
    { vpn_connection_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpnConnectionId"))
    ; vpn_tunnel_outside_ip_address =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpnTunnelOutsideIpAddress"))
    ; tunnel_options =
        ModifyVpnTunnelOptionsSpecification.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TunnelOptions"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module VpnStaticRouteSource = struct
  type t = Static

  let str_to_t = [ "Static", Static ]

  let t_to_str = [ Static, "Static" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module VpnState = struct
  type t =
    | Pending
    | Available
    | Deleting
    | Deleted

  let str_to_t =
    [ "deleted", Deleted
    ; "deleting", Deleting
    ; "available", Available
    ; "pending", Pending
    ]

  let t_to_str =
    [ Deleted, "deleted"
    ; Deleting, "deleting"
    ; Available, "available"
    ; Pending, "pending"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module VpnStaticRoute = struct
  type t =
    { destination_cidr_block : String.t option
    ; source : VpnStaticRouteSource.t option
    ; state : VpnState.t option
    }

  let make ?destination_cidr_block ?source ?state () =
    { destination_cidr_block; source; state }

  let parse xml =
    Some
      { destination_cidr_block =
          Aws.Util.option_bind (Aws.Xml.member "destinationCidrBlock" xml) String.parse
      ; source =
          Aws.Util.option_bind (Aws.Xml.member "source" xml) VpnStaticRouteSource.parse
      ; state = Aws.Util.option_bind (Aws.Xml.member "state" xml) VpnState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", VpnState.to_query f))
         ; Aws.Util.option_map v.source (fun f ->
               Aws.Query.Pair ("Source", VpnStaticRouteSource.to_query f))
         ; Aws.Util.option_map v.destination_cidr_block (fun f ->
               Aws.Query.Pair ("DestinationCidrBlock", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f -> "state", VpnState.to_json f)
         ; Aws.Util.option_map v.source (fun f ->
               "source", VpnStaticRouteSource.to_json f)
         ; Aws.Util.option_map v.destination_cidr_block (fun f ->
               "destinationCidrBlock", String.to_json f)
         ])

  let of_json j =
    { destination_cidr_block =
        Aws.Util.option_map (Aws.Json.lookup j "destinationCidrBlock") String.of_json
    ; source =
        Aws.Util.option_map (Aws.Json.lookup j "source") VpnStaticRouteSource.of_json
    ; state = Aws.Util.option_map (Aws.Json.lookup j "state") VpnState.of_json
    }
end

module VpnStaticRouteList = struct
  type t = VpnStaticRoute.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map VpnStaticRoute.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list VpnStaticRoute.to_query v

  let to_json v = `List (List.map VpnStaticRoute.to_json v)

  let of_json j = Aws.Json.to_list VpnStaticRoute.of_json j
end

module Phase2IntegrityAlgorithmsListValue = struct
  type t = { value : String.t option }

  let make ?value () = { value }

  let parse xml =
    Some { value = Aws.Util.option_bind (Aws.Xml.member "value" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f -> "value", String.to_json f) ])

  let of_json j =
    { value = Aws.Util.option_map (Aws.Json.lookup j "value") String.of_json }
end

module Phase2IntegrityAlgorithmsList = struct
  type t = Phase2IntegrityAlgorithmsListValue.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map Phase2IntegrityAlgorithmsListValue.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Phase2IntegrityAlgorithmsListValue.to_query v

  let to_json v = `List (List.map Phase2IntegrityAlgorithmsListValue.to_json v)

  let of_json j = Aws.Json.to_list Phase2IntegrityAlgorithmsListValue.of_json j
end

module Phase2EncryptionAlgorithmsListValue = struct
  type t = { value : String.t option }

  let make ?value () = { value }

  let parse xml =
    Some { value = Aws.Util.option_bind (Aws.Xml.member "value" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f -> "value", String.to_json f) ])

  let of_json j =
    { value = Aws.Util.option_map (Aws.Json.lookup j "value") String.of_json }
end

module Phase2EncryptionAlgorithmsList = struct
  type t = Phase2EncryptionAlgorithmsListValue.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map Phase2EncryptionAlgorithmsListValue.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Phase2EncryptionAlgorithmsListValue.to_query v

  let to_json v = `List (List.map Phase2EncryptionAlgorithmsListValue.to_json v)

  let of_json j = Aws.Json.to_list Phase2EncryptionAlgorithmsListValue.of_json j
end

module Phase1IntegrityAlgorithmsListValue = struct
  type t = { value : String.t option }

  let make ?value () = { value }

  let parse xml =
    Some { value = Aws.Util.option_bind (Aws.Xml.member "value" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f -> "value", String.to_json f) ])

  let of_json j =
    { value = Aws.Util.option_map (Aws.Json.lookup j "value") String.of_json }
end

module Phase1IntegrityAlgorithmsList = struct
  type t = Phase1IntegrityAlgorithmsListValue.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map Phase1IntegrityAlgorithmsListValue.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Phase1IntegrityAlgorithmsListValue.to_query v

  let to_json v = `List (List.map Phase1IntegrityAlgorithmsListValue.to_json v)

  let of_json j = Aws.Json.to_list Phase1IntegrityAlgorithmsListValue.of_json j
end

module Phase1DHGroupNumbersListValue = struct
  type t = { value : Integer.t option }

  let make ?value () = { value }

  let parse xml =
    Some { value = Aws.Util.option_bind (Aws.Xml.member "value" xml) Integer.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f -> "value", Integer.to_json f) ])

  let of_json j =
    { value = Aws.Util.option_map (Aws.Json.lookup j "value") Integer.of_json }
end

module Phase1DHGroupNumbersList = struct
  type t = Phase1DHGroupNumbersListValue.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map Phase1DHGroupNumbersListValue.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Phase1DHGroupNumbersListValue.to_query v

  let to_json v = `List (List.map Phase1DHGroupNumbersListValue.to_json v)

  let of_json j = Aws.Json.to_list Phase1DHGroupNumbersListValue.of_json j
end

module IKEVersionsListValue = struct
  type t = { value : String.t option }

  let make ?value () = { value }

  let parse xml =
    Some { value = Aws.Util.option_bind (Aws.Xml.member "value" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f -> "value", String.to_json f) ])

  let of_json j =
    { value = Aws.Util.option_map (Aws.Json.lookup j "value") String.of_json }
end

module IKEVersionsList = struct
  type t = IKEVersionsListValue.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map IKEVersionsListValue.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list IKEVersionsListValue.to_query v

  let to_json v = `List (List.map IKEVersionsListValue.to_json v)

  let of_json j = Aws.Json.to_list IKEVersionsListValue.of_json j
end

module TunnelOption = struct
  type t =
    { outside_ip_address : String.t option
    ; tunnel_inside_cidr : String.t option
    ; tunnel_inside_ipv6_cidr : String.t option
    ; pre_shared_key : String.t option
    ; phase1_lifetime_seconds : Integer.t option
    ; phase2_lifetime_seconds : Integer.t option
    ; rekey_margin_time_seconds : Integer.t option
    ; rekey_fuzz_percentage : Integer.t option
    ; replay_window_size : Integer.t option
    ; dpd_timeout_seconds : Integer.t option
    ; dpd_timeout_action : String.t option
    ; phase1_encryption_algorithms : Phase1EncryptionAlgorithmsList.t
    ; phase2_encryption_algorithms : Phase2EncryptionAlgorithmsList.t
    ; phase1_integrity_algorithms : Phase1IntegrityAlgorithmsList.t
    ; phase2_integrity_algorithms : Phase2IntegrityAlgorithmsList.t
    ; phase1_d_h_group_numbers : Phase1DHGroupNumbersList.t
    ; phase2_d_h_group_numbers : Phase2DHGroupNumbersList.t
    ; ike_versions : IKEVersionsList.t
    ; startup_action : String.t option
    }

  let make
      ?outside_ip_address
      ?tunnel_inside_cidr
      ?tunnel_inside_ipv6_cidr
      ?pre_shared_key
      ?phase1_lifetime_seconds
      ?phase2_lifetime_seconds
      ?rekey_margin_time_seconds
      ?rekey_fuzz_percentage
      ?replay_window_size
      ?dpd_timeout_seconds
      ?dpd_timeout_action
      ?(phase1_encryption_algorithms = [])
      ?(phase2_encryption_algorithms = [])
      ?(phase1_integrity_algorithms = [])
      ?(phase2_integrity_algorithms = [])
      ?(phase1_d_h_group_numbers = [])
      ?(phase2_d_h_group_numbers = [])
      ?(ike_versions = [])
      ?startup_action
      () =
    { outside_ip_address
    ; tunnel_inside_cidr
    ; tunnel_inside_ipv6_cidr
    ; pre_shared_key
    ; phase1_lifetime_seconds
    ; phase2_lifetime_seconds
    ; rekey_margin_time_seconds
    ; rekey_fuzz_percentage
    ; replay_window_size
    ; dpd_timeout_seconds
    ; dpd_timeout_action
    ; phase1_encryption_algorithms
    ; phase2_encryption_algorithms
    ; phase1_integrity_algorithms
    ; phase2_integrity_algorithms
    ; phase1_d_h_group_numbers
    ; phase2_d_h_group_numbers
    ; ike_versions
    ; startup_action
    }

  let parse xml =
    Some
      { outside_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "outsideIpAddress" xml) String.parse
      ; tunnel_inside_cidr =
          Aws.Util.option_bind (Aws.Xml.member "tunnelInsideCidr" xml) String.parse
      ; tunnel_inside_ipv6_cidr =
          Aws.Util.option_bind (Aws.Xml.member "tunnelInsideIpv6Cidr" xml) String.parse
      ; pre_shared_key =
          Aws.Util.option_bind (Aws.Xml.member "preSharedKey" xml) String.parse
      ; phase1_lifetime_seconds =
          Aws.Util.option_bind (Aws.Xml.member "phase1LifetimeSeconds" xml) Integer.parse
      ; phase2_lifetime_seconds =
          Aws.Util.option_bind (Aws.Xml.member "phase2LifetimeSeconds" xml) Integer.parse
      ; rekey_margin_time_seconds =
          Aws.Util.option_bind (Aws.Xml.member "rekeyMarginTimeSeconds" xml) Integer.parse
      ; rekey_fuzz_percentage =
          Aws.Util.option_bind (Aws.Xml.member "rekeyFuzzPercentage" xml) Integer.parse
      ; replay_window_size =
          Aws.Util.option_bind (Aws.Xml.member "replayWindowSize" xml) Integer.parse
      ; dpd_timeout_seconds =
          Aws.Util.option_bind (Aws.Xml.member "dpdTimeoutSeconds" xml) Integer.parse
      ; dpd_timeout_action =
          Aws.Util.option_bind (Aws.Xml.member "dpdTimeoutAction" xml) String.parse
      ; phase1_encryption_algorithms =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "phase1EncryptionAlgorithmSet" xml)
               Phase1EncryptionAlgorithmsList.parse)
      ; phase2_encryption_algorithms =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "phase2EncryptionAlgorithmSet" xml)
               Phase2EncryptionAlgorithmsList.parse)
      ; phase1_integrity_algorithms =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "phase1IntegrityAlgorithmSet" xml)
               Phase1IntegrityAlgorithmsList.parse)
      ; phase2_integrity_algorithms =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "phase2IntegrityAlgorithmSet" xml)
               Phase2IntegrityAlgorithmsList.parse)
      ; phase1_d_h_group_numbers =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "phase1DHGroupNumberSet" xml)
               Phase1DHGroupNumbersList.parse)
      ; phase2_d_h_group_numbers =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "phase2DHGroupNumberSet" xml)
               Phase2DHGroupNumbersList.parse)
      ; ike_versions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ikeVersionSet" xml)
               IKEVersionsList.parse)
      ; startup_action =
          Aws.Util.option_bind (Aws.Xml.member "startupAction" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.startup_action (fun f ->
               Aws.Query.Pair ("StartupAction", String.to_query f))
         ; Some
             (Aws.Query.Pair ("IkeVersionSet", IKEVersionsList.to_query v.ike_versions))
         ; Some
             (Aws.Query.Pair
                ( "Phase2DHGroupNumberSet"
                , Phase2DHGroupNumbersList.to_query v.phase2_d_h_group_numbers ))
         ; Some
             (Aws.Query.Pair
                ( "Phase1DHGroupNumberSet"
                , Phase1DHGroupNumbersList.to_query v.phase1_d_h_group_numbers ))
         ; Some
             (Aws.Query.Pair
                ( "Phase2IntegrityAlgorithmSet"
                , Phase2IntegrityAlgorithmsList.to_query v.phase2_integrity_algorithms ))
         ; Some
             (Aws.Query.Pair
                ( "Phase1IntegrityAlgorithmSet"
                , Phase1IntegrityAlgorithmsList.to_query v.phase1_integrity_algorithms ))
         ; Some
             (Aws.Query.Pair
                ( "Phase2EncryptionAlgorithmSet"
                , Phase2EncryptionAlgorithmsList.to_query v.phase2_encryption_algorithms
                ))
         ; Some
             (Aws.Query.Pair
                ( "Phase1EncryptionAlgorithmSet"
                , Phase1EncryptionAlgorithmsList.to_query v.phase1_encryption_algorithms
                ))
         ; Aws.Util.option_map v.dpd_timeout_action (fun f ->
               Aws.Query.Pair ("DpdTimeoutAction", String.to_query f))
         ; Aws.Util.option_map v.dpd_timeout_seconds (fun f ->
               Aws.Query.Pair ("DpdTimeoutSeconds", Integer.to_query f))
         ; Aws.Util.option_map v.replay_window_size (fun f ->
               Aws.Query.Pair ("ReplayWindowSize", Integer.to_query f))
         ; Aws.Util.option_map v.rekey_fuzz_percentage (fun f ->
               Aws.Query.Pair ("RekeyFuzzPercentage", Integer.to_query f))
         ; Aws.Util.option_map v.rekey_margin_time_seconds (fun f ->
               Aws.Query.Pair ("RekeyMarginTimeSeconds", Integer.to_query f))
         ; Aws.Util.option_map v.phase2_lifetime_seconds (fun f ->
               Aws.Query.Pair ("Phase2LifetimeSeconds", Integer.to_query f))
         ; Aws.Util.option_map v.phase1_lifetime_seconds (fun f ->
               Aws.Query.Pair ("Phase1LifetimeSeconds", Integer.to_query f))
         ; Aws.Util.option_map v.pre_shared_key (fun f ->
               Aws.Query.Pair ("PreSharedKey", String.to_query f))
         ; Aws.Util.option_map v.tunnel_inside_ipv6_cidr (fun f ->
               Aws.Query.Pair ("TunnelInsideIpv6Cidr", String.to_query f))
         ; Aws.Util.option_map v.tunnel_inside_cidr (fun f ->
               Aws.Query.Pair ("TunnelInsideCidr", String.to_query f))
         ; Aws.Util.option_map v.outside_ip_address (fun f ->
               Aws.Query.Pair ("OutsideIpAddress", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.startup_action (fun f ->
               "startupAction", String.to_json f)
         ; Some ("ikeVersionSet", IKEVersionsList.to_json v.ike_versions)
         ; Some
             ( "phase2DHGroupNumberSet"
             , Phase2DHGroupNumbersList.to_json v.phase2_d_h_group_numbers )
         ; Some
             ( "phase1DHGroupNumberSet"
             , Phase1DHGroupNumbersList.to_json v.phase1_d_h_group_numbers )
         ; Some
             ( "phase2IntegrityAlgorithmSet"
             , Phase2IntegrityAlgorithmsList.to_json v.phase2_integrity_algorithms )
         ; Some
             ( "phase1IntegrityAlgorithmSet"
             , Phase1IntegrityAlgorithmsList.to_json v.phase1_integrity_algorithms )
         ; Some
             ( "phase2EncryptionAlgorithmSet"
             , Phase2EncryptionAlgorithmsList.to_json v.phase2_encryption_algorithms )
         ; Some
             ( "phase1EncryptionAlgorithmSet"
             , Phase1EncryptionAlgorithmsList.to_json v.phase1_encryption_algorithms )
         ; Aws.Util.option_map v.dpd_timeout_action (fun f ->
               "dpdTimeoutAction", String.to_json f)
         ; Aws.Util.option_map v.dpd_timeout_seconds (fun f ->
               "dpdTimeoutSeconds", Integer.to_json f)
         ; Aws.Util.option_map v.replay_window_size (fun f ->
               "replayWindowSize", Integer.to_json f)
         ; Aws.Util.option_map v.rekey_fuzz_percentage (fun f ->
               "rekeyFuzzPercentage", Integer.to_json f)
         ; Aws.Util.option_map v.rekey_margin_time_seconds (fun f ->
               "rekeyMarginTimeSeconds", Integer.to_json f)
         ; Aws.Util.option_map v.phase2_lifetime_seconds (fun f ->
               "phase2LifetimeSeconds", Integer.to_json f)
         ; Aws.Util.option_map v.phase1_lifetime_seconds (fun f ->
               "phase1LifetimeSeconds", Integer.to_json f)
         ; Aws.Util.option_map v.pre_shared_key (fun f ->
               "preSharedKey", String.to_json f)
         ; Aws.Util.option_map v.tunnel_inside_ipv6_cidr (fun f ->
               "tunnelInsideIpv6Cidr", String.to_json f)
         ; Aws.Util.option_map v.tunnel_inside_cidr (fun f ->
               "tunnelInsideCidr", String.to_json f)
         ; Aws.Util.option_map v.outside_ip_address (fun f ->
               "outsideIpAddress", String.to_json f)
         ])

  let of_json j =
    { outside_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "outsideIpAddress") String.of_json
    ; tunnel_inside_cidr =
        Aws.Util.option_map (Aws.Json.lookup j "tunnelInsideCidr") String.of_json
    ; tunnel_inside_ipv6_cidr =
        Aws.Util.option_map (Aws.Json.lookup j "tunnelInsideIpv6Cidr") String.of_json
    ; pre_shared_key =
        Aws.Util.option_map (Aws.Json.lookup j "preSharedKey") String.of_json
    ; phase1_lifetime_seconds =
        Aws.Util.option_map (Aws.Json.lookup j "phase1LifetimeSeconds") Integer.of_json
    ; phase2_lifetime_seconds =
        Aws.Util.option_map (Aws.Json.lookup j "phase2LifetimeSeconds") Integer.of_json
    ; rekey_margin_time_seconds =
        Aws.Util.option_map (Aws.Json.lookup j "rekeyMarginTimeSeconds") Integer.of_json
    ; rekey_fuzz_percentage =
        Aws.Util.option_map (Aws.Json.lookup j "rekeyFuzzPercentage") Integer.of_json
    ; replay_window_size =
        Aws.Util.option_map (Aws.Json.lookup j "replayWindowSize") Integer.of_json
    ; dpd_timeout_seconds =
        Aws.Util.option_map (Aws.Json.lookup j "dpdTimeoutSeconds") Integer.of_json
    ; dpd_timeout_action =
        Aws.Util.option_map (Aws.Json.lookup j "dpdTimeoutAction") String.of_json
    ; phase1_encryption_algorithms =
        Phase1EncryptionAlgorithmsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "phase1EncryptionAlgorithmSet"))
    ; phase2_encryption_algorithms =
        Phase2EncryptionAlgorithmsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "phase2EncryptionAlgorithmSet"))
    ; phase1_integrity_algorithms =
        Phase1IntegrityAlgorithmsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "phase1IntegrityAlgorithmSet"))
    ; phase2_integrity_algorithms =
        Phase2IntegrityAlgorithmsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "phase2IntegrityAlgorithmSet"))
    ; phase1_d_h_group_numbers =
        Phase1DHGroupNumbersList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "phase1DHGroupNumberSet"))
    ; phase2_d_h_group_numbers =
        Phase2DHGroupNumbersList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "phase2DHGroupNumberSet"))
    ; ike_versions =
        IKEVersionsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ikeVersionSet"))
    ; startup_action =
        Aws.Util.option_map (Aws.Json.lookup j "startupAction") String.of_json
    }
end

module TunnelOptionsList = struct
  type t = TunnelOption.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map TunnelOption.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list TunnelOption.to_query v

  let to_json v = `List (List.map TunnelOption.to_json v)

  let of_json j = Aws.Json.to_list TunnelOption.of_json j
end

module VpnConnectionOptions = struct
  type t =
    { enable_acceleration : Boolean.t option
    ; static_routes_only : Boolean.t option
    ; local_ipv4_network_cidr : String.t option
    ; remote_ipv4_network_cidr : String.t option
    ; local_ipv6_network_cidr : String.t option
    ; remote_ipv6_network_cidr : String.t option
    ; tunnel_inside_ip_version : TunnelInsideIpVersion.t option
    ; tunnel_options : TunnelOptionsList.t
    }

  let make
      ?enable_acceleration
      ?static_routes_only
      ?local_ipv4_network_cidr
      ?remote_ipv4_network_cidr
      ?local_ipv6_network_cidr
      ?remote_ipv6_network_cidr
      ?tunnel_inside_ip_version
      ?(tunnel_options = [])
      () =
    { enable_acceleration
    ; static_routes_only
    ; local_ipv4_network_cidr
    ; remote_ipv4_network_cidr
    ; local_ipv6_network_cidr
    ; remote_ipv6_network_cidr
    ; tunnel_inside_ip_version
    ; tunnel_options
    }

  let parse xml =
    Some
      { enable_acceleration =
          Aws.Util.option_bind (Aws.Xml.member "enableAcceleration" xml) Boolean.parse
      ; static_routes_only =
          Aws.Util.option_bind (Aws.Xml.member "staticRoutesOnly" xml) Boolean.parse
      ; local_ipv4_network_cidr =
          Aws.Util.option_bind (Aws.Xml.member "localIpv4NetworkCidr" xml) String.parse
      ; remote_ipv4_network_cidr =
          Aws.Util.option_bind (Aws.Xml.member "remoteIpv4NetworkCidr" xml) String.parse
      ; local_ipv6_network_cidr =
          Aws.Util.option_bind (Aws.Xml.member "localIpv6NetworkCidr" xml) String.parse
      ; remote_ipv6_network_cidr =
          Aws.Util.option_bind (Aws.Xml.member "remoteIpv6NetworkCidr" xml) String.parse
      ; tunnel_inside_ip_version =
          Aws.Util.option_bind
            (Aws.Xml.member "tunnelInsideIpVersion" xml)
            TunnelInsideIpVersion.parse
      ; tunnel_options =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "tunnelOptionSet" xml)
               TunnelOptionsList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("TunnelOptionSet", TunnelOptionsList.to_query v.tunnel_options))
         ; Aws.Util.option_map v.tunnel_inside_ip_version (fun f ->
               Aws.Query.Pair ("TunnelInsideIpVersion", TunnelInsideIpVersion.to_query f))
         ; Aws.Util.option_map v.remote_ipv6_network_cidr (fun f ->
               Aws.Query.Pair ("RemoteIpv6NetworkCidr", String.to_query f))
         ; Aws.Util.option_map v.local_ipv6_network_cidr (fun f ->
               Aws.Query.Pair ("LocalIpv6NetworkCidr", String.to_query f))
         ; Aws.Util.option_map v.remote_ipv4_network_cidr (fun f ->
               Aws.Query.Pair ("RemoteIpv4NetworkCidr", String.to_query f))
         ; Aws.Util.option_map v.local_ipv4_network_cidr (fun f ->
               Aws.Query.Pair ("LocalIpv4NetworkCidr", String.to_query f))
         ; Aws.Util.option_map v.static_routes_only (fun f ->
               Aws.Query.Pair ("StaticRoutesOnly", Boolean.to_query f))
         ; Aws.Util.option_map v.enable_acceleration (fun f ->
               Aws.Query.Pair ("EnableAcceleration", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tunnelOptionSet", TunnelOptionsList.to_json v.tunnel_options)
         ; Aws.Util.option_map v.tunnel_inside_ip_version (fun f ->
               "tunnelInsideIpVersion", TunnelInsideIpVersion.to_json f)
         ; Aws.Util.option_map v.remote_ipv6_network_cidr (fun f ->
               "remoteIpv6NetworkCidr", String.to_json f)
         ; Aws.Util.option_map v.local_ipv6_network_cidr (fun f ->
               "localIpv6NetworkCidr", String.to_json f)
         ; Aws.Util.option_map v.remote_ipv4_network_cidr (fun f ->
               "remoteIpv4NetworkCidr", String.to_json f)
         ; Aws.Util.option_map v.local_ipv4_network_cidr (fun f ->
               "localIpv4NetworkCidr", String.to_json f)
         ; Aws.Util.option_map v.static_routes_only (fun f ->
               "staticRoutesOnly", Boolean.to_json f)
         ; Aws.Util.option_map v.enable_acceleration (fun f ->
               "enableAcceleration", Boolean.to_json f)
         ])

  let of_json j =
    { enable_acceleration =
        Aws.Util.option_map (Aws.Json.lookup j "enableAcceleration") Boolean.of_json
    ; static_routes_only =
        Aws.Util.option_map (Aws.Json.lookup j "staticRoutesOnly") Boolean.of_json
    ; local_ipv4_network_cidr =
        Aws.Util.option_map (Aws.Json.lookup j "localIpv4NetworkCidr") String.of_json
    ; remote_ipv4_network_cidr =
        Aws.Util.option_map (Aws.Json.lookup j "remoteIpv4NetworkCidr") String.of_json
    ; local_ipv6_network_cidr =
        Aws.Util.option_map (Aws.Json.lookup j "localIpv6NetworkCidr") String.of_json
    ; remote_ipv6_network_cidr =
        Aws.Util.option_map (Aws.Json.lookup j "remoteIpv6NetworkCidr") String.of_json
    ; tunnel_inside_ip_version =
        Aws.Util.option_map
          (Aws.Json.lookup j "tunnelInsideIpVersion")
          TunnelInsideIpVersion.of_json
    ; tunnel_options =
        TunnelOptionsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "tunnelOptionSet"))
    }
end

module GatewayType = struct
  type t = Ipsec_1

  let str_to_t = [ "ipsec.1", Ipsec_1 ]

  let t_to_str = [ Ipsec_1, "ipsec.1" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module VpnConnection = struct
  type t =
    { customer_gateway_configuration : String.t option
    ; customer_gateway_id : String.t
    ; category : String.t option
    ; state : VpnState.t
    ; type_ : GatewayType.t
    ; vpn_connection_id : String.t
    ; vpn_gateway_id : String.t option
    ; transit_gateway_id : String.t option
    ; options : VpnConnectionOptions.t option
    ; routes : VpnStaticRouteList.t
    ; tags : TagList.t
    ; vgw_telemetry : VgwTelemetryList.t
    }

  let make
      ?customer_gateway_configuration
      ~customer_gateway_id
      ?category
      ~state
      ~type_
      ~vpn_connection_id
      ?vpn_gateway_id
      ?transit_gateway_id
      ?options
      ?(routes = [])
      ?(tags = [])
      ?(vgw_telemetry = [])
      () =
    { customer_gateway_configuration
    ; customer_gateway_id
    ; category
    ; state
    ; type_
    ; vpn_connection_id
    ; vpn_gateway_id
    ; transit_gateway_id
    ; options
    ; routes
    ; tags
    ; vgw_telemetry
    }

  let parse xml =
    Some
      { customer_gateway_configuration =
          Aws.Util.option_bind
            (Aws.Xml.member "customerGatewayConfiguration" xml)
            String.parse
      ; customer_gateway_id =
          Aws.Xml.required
            "customerGatewayId"
            (Aws.Util.option_bind (Aws.Xml.member "customerGatewayId" xml) String.parse)
      ; category = Aws.Util.option_bind (Aws.Xml.member "category" xml) String.parse
      ; state =
          Aws.Xml.required
            "state"
            (Aws.Util.option_bind (Aws.Xml.member "state" xml) VpnState.parse)
      ; type_ =
          Aws.Xml.required
            "type"
            (Aws.Util.option_bind (Aws.Xml.member "type" xml) GatewayType.parse)
      ; vpn_connection_id =
          Aws.Xml.required
            "vpnConnectionId"
            (Aws.Util.option_bind (Aws.Xml.member "vpnConnectionId" xml) String.parse)
      ; vpn_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "vpnGatewayId" xml) String.parse
      ; transit_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "transitGatewayId" xml) String.parse
      ; options =
          Aws.Util.option_bind (Aws.Xml.member "options" xml) VpnConnectionOptions.parse
      ; routes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "routes" xml) VpnStaticRouteList.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      ; vgw_telemetry =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "vgwTelemetry" xml)
               VgwTelemetryList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("VgwTelemetry", VgwTelemetryList.to_query v.vgw_telemetry))
         ; Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Some (Aws.Query.Pair ("Routes", VpnStaticRouteList.to_query v.routes))
         ; Aws.Util.option_map v.options (fun f ->
               Aws.Query.Pair ("Options", VpnConnectionOptions.to_query f))
         ; Aws.Util.option_map v.transit_gateway_id (fun f ->
               Aws.Query.Pair ("TransitGatewayId", String.to_query f))
         ; Aws.Util.option_map v.vpn_gateway_id (fun f ->
               Aws.Query.Pair ("VpnGatewayId", String.to_query f))
         ; Some (Aws.Query.Pair ("VpnConnectionId", String.to_query v.vpn_connection_id))
         ; Some (Aws.Query.Pair ("Type", GatewayType.to_query v.type_))
         ; Some (Aws.Query.Pair ("State", VpnState.to_query v.state))
         ; Aws.Util.option_map v.category (fun f ->
               Aws.Query.Pair ("Category", String.to_query f))
         ; Some
             (Aws.Query.Pair ("CustomerGatewayId", String.to_query v.customer_gateway_id))
         ; Aws.Util.option_map v.customer_gateway_configuration (fun f ->
               Aws.Query.Pair ("CustomerGatewayConfiguration", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("vgwTelemetry", VgwTelemetryList.to_json v.vgw_telemetry)
         ; Some ("tagSet", TagList.to_json v.tags)
         ; Some ("routes", VpnStaticRouteList.to_json v.routes)
         ; Aws.Util.option_map v.options (fun f ->
               "options", VpnConnectionOptions.to_json f)
         ; Aws.Util.option_map v.transit_gateway_id (fun f ->
               "transitGatewayId", String.to_json f)
         ; Aws.Util.option_map v.vpn_gateway_id (fun f ->
               "vpnGatewayId", String.to_json f)
         ; Some ("vpnConnectionId", String.to_json v.vpn_connection_id)
         ; Some ("type", GatewayType.to_json v.type_)
         ; Some ("state", VpnState.to_json v.state)
         ; Aws.Util.option_map v.category (fun f -> "category", String.to_json f)
         ; Some ("customerGatewayId", String.to_json v.customer_gateway_id)
         ; Aws.Util.option_map v.customer_gateway_configuration (fun f ->
               "customerGatewayConfiguration", String.to_json f)
         ])

  let of_json j =
    { customer_gateway_configuration =
        Aws.Util.option_map
          (Aws.Json.lookup j "customerGatewayConfiguration")
          String.of_json
    ; customer_gateway_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "customerGatewayId"))
    ; category = Aws.Util.option_map (Aws.Json.lookup j "category") String.of_json
    ; state = VpnState.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "state"))
    ; type_ = GatewayType.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "type"))
    ; vpn_connection_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "vpnConnectionId"))
    ; vpn_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "vpnGatewayId") String.of_json
    ; transit_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "transitGatewayId") String.of_json
    ; options =
        Aws.Util.option_map (Aws.Json.lookup j "options") VpnConnectionOptions.of_json
    ; routes =
        VpnStaticRouteList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "routes"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    ; vgw_telemetry =
        VgwTelemetryList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "vgwTelemetry"))
    }
end

module ModifyVpnConnectionOptionsResult = struct
  type t = { vpn_connection : VpnConnection.t option }

  let make ?vpn_connection () = { vpn_connection }

  let parse xml =
    Some
      { vpn_connection =
          Aws.Util.option_bind (Aws.Xml.member "vpnConnection" xml) VpnConnection.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpn_connection (fun f ->
               Aws.Query.Pair ("VpnConnection", VpnConnection.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpn_connection (fun f ->
               "vpnConnection", VpnConnection.to_json f)
         ])

  let of_json j =
    { vpn_connection =
        Aws.Util.option_map (Aws.Json.lookup j "vpnConnection") VpnConnection.of_json
    }
end

module DeleteTrafficMirrorFilterRuleRequest = struct
  type t =
    { traffic_mirror_filter_rule_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~traffic_mirror_filter_rule_id ?dry_run () =
    { traffic_mirror_filter_rule_id; dry_run }

  let parse xml =
    Some
      { traffic_mirror_filter_rule_id =
          Aws.Xml.required
            "TrafficMirrorFilterRuleId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TrafficMirrorFilterRuleId" xml)
               String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TrafficMirrorFilterRuleId"
                , String.to_query v.traffic_mirror_filter_rule_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ("TrafficMirrorFilterRuleId", String.to_json v.traffic_mirror_filter_rule_id)
         ])

  let of_json j =
    { traffic_mirror_filter_rule_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TrafficMirrorFilterRuleId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module VpcAttachment = struct
  type t =
    { state : AttachmentStatus.t option
    ; vpc_id : String.t option
    }

  let make ?state ?vpc_id () = { state; vpc_id }

  let parse xml =
    Some
      { state = Aws.Util.option_bind (Aws.Xml.member "state" xml) AttachmentStatus.parse
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", AttachmentStatus.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_id (fun f -> "vpcId", String.to_json f)
         ; Aws.Util.option_map v.state (fun f -> "state", AttachmentStatus.to_json f)
         ])

  let of_json j =
    { state = Aws.Util.option_map (Aws.Json.lookup j "state") AttachmentStatus.of_json
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "vpcId") String.of_json
    }
end

module VpcAttachmentList = struct
  type t = VpcAttachment.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map VpcAttachment.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list VpcAttachment.to_query v

  let to_json v = `List (List.map VpcAttachment.to_json v)

  let of_json j = Aws.Json.to_list VpcAttachment.of_json j
end

module VpnGateway = struct
  type t =
    { availability_zone : String.t option
    ; state : VpnState.t option
    ; type_ : GatewayType.t option
    ; vpc_attachments : VpcAttachmentList.t
    ; vpn_gateway_id : String.t option
    ; amazon_side_asn : Long.t option
    ; tags : TagList.t
    }

  let make
      ?availability_zone
      ?state
      ?type_
      ?(vpc_attachments = [])
      ?vpn_gateway_id
      ?amazon_side_asn
      ?(tags = [])
      () =
    { availability_zone
    ; state
    ; type_
    ; vpc_attachments
    ; vpn_gateway_id
    ; amazon_side_asn
    ; tags
    }

  let parse xml =
    Some
      { availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; state = Aws.Util.option_bind (Aws.Xml.member "state" xml) VpnState.parse
      ; type_ = Aws.Util.option_bind (Aws.Xml.member "type" xml) GatewayType.parse
      ; vpc_attachments =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "attachments" xml)
               VpcAttachmentList.parse)
      ; vpn_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "vpnGatewayId" xml) String.parse
      ; amazon_side_asn =
          Aws.Util.option_bind (Aws.Xml.member "amazonSideAsn" xml) Long.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.amazon_side_asn (fun f ->
               Aws.Query.Pair ("AmazonSideAsn", Long.to_query f))
         ; Aws.Util.option_map v.vpn_gateway_id (fun f ->
               Aws.Query.Pair ("VpnGatewayId", String.to_query f))
         ; Some
             (Aws.Query.Pair ("Attachments", VpcAttachmentList.to_query v.vpc_attachments))
         ; Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", GatewayType.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", VpnState.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.amazon_side_asn (fun f ->
               "amazonSideAsn", Long.to_json f)
         ; Aws.Util.option_map v.vpn_gateway_id (fun f ->
               "vpnGatewayId", String.to_json f)
         ; Some ("attachments", VpcAttachmentList.to_json v.vpc_attachments)
         ; Aws.Util.option_map v.type_ (fun f -> "type", GatewayType.to_json f)
         ; Aws.Util.option_map v.state (fun f -> "state", VpnState.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ])

  let of_json j =
    { availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; state = Aws.Util.option_map (Aws.Json.lookup j "state") VpnState.of_json
    ; type_ = Aws.Util.option_map (Aws.Json.lookup j "type") GatewayType.of_json
    ; vpc_attachments =
        VpcAttachmentList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "attachments"))
    ; vpn_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "vpnGatewayId") String.of_json
    ; amazon_side_asn =
        Aws.Util.option_map (Aws.Json.lookup j "amazonSideAsn") Long.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module VpnGatewayList = struct
  type t = VpnGateway.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map VpnGateway.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list VpnGateway.to_query v

  let to_json v = `List (List.map VpnGateway.to_json v)

  let of_json j = Aws.Json.to_list VpnGateway.of_json j
end

module DeleteFleetErrorCode = struct
  type t =
    | FleetIdDoesNotExist
    | FleetIdMalformed
    | FleetNotInDeletableState
    | UnexpectedError

  let str_to_t =
    [ "unexpectedError", UnexpectedError
    ; "fleetNotInDeletableState", FleetNotInDeletableState
    ; "fleetIdMalformed", FleetIdMalformed
    ; "fleetIdDoesNotExist", FleetIdDoesNotExist
    ]

  let t_to_str =
    [ UnexpectedError, "unexpectedError"
    ; FleetNotInDeletableState, "fleetNotInDeletableState"
    ; FleetIdMalformed, "fleetIdMalformed"
    ; FleetIdDoesNotExist, "fleetIdDoesNotExist"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DeleteFleetError = struct
  type t =
    { code : DeleteFleetErrorCode.t option
    ; message : String.t option
    }

  let make ?code ?message () = { code; message }

  let parse xml =
    Some
      { code = Aws.Util.option_bind (Aws.Xml.member "code" xml) DeleteFleetErrorCode.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair ("Code", DeleteFleetErrorCode.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f)
         ; Aws.Util.option_map v.code (fun f -> "code", DeleteFleetErrorCode.to_json f)
         ])

  let of_json j =
    { code = Aws.Util.option_map (Aws.Json.lookup j "code") DeleteFleetErrorCode.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json
    }
end

module DeleteFleetErrorItem = struct
  type t =
    { error : DeleteFleetError.t option
    ; fleet_id : String.t option
    }

  let make ?error ?fleet_id () = { error; fleet_id }

  let parse xml =
    Some
      { error = Aws.Util.option_bind (Aws.Xml.member "error" xml) DeleteFleetError.parse
      ; fleet_id = Aws.Util.option_bind (Aws.Xml.member "fleetId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.fleet_id (fun f ->
               Aws.Query.Pair ("FleetId", String.to_query f))
         ; Aws.Util.option_map v.error (fun f ->
               Aws.Query.Pair ("Error", DeleteFleetError.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.fleet_id (fun f -> "fleetId", String.to_json f)
         ; Aws.Util.option_map v.error (fun f -> "error", DeleteFleetError.to_json f)
         ])

  let of_json j =
    { error = Aws.Util.option_map (Aws.Json.lookup j "error") DeleteFleetError.of_json
    ; fleet_id = Aws.Util.option_map (Aws.Json.lookup j "fleetId") String.of_json
    }
end

module DeleteFleetErrorSet = struct
  type t = DeleteFleetErrorItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map DeleteFleetErrorItem.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list DeleteFleetErrorItem.to_query v

  let to_json v = `List (List.map DeleteFleetErrorItem.to_json v)

  let of_json j = Aws.Json.to_list DeleteFleetErrorItem.of_json j
end

module AssociateAddressRequest = struct
  type t =
    { allocation_id : String.t option
    ; instance_id : String.t option
    ; public_ip : String.t option
    ; allow_reassociation : Boolean.t option
    ; dry_run : Boolean.t option
    ; network_interface_id : String.t option
    ; private_ip_address : String.t option
    }

  let make
      ?allocation_id
      ?instance_id
      ?public_ip
      ?allow_reassociation
      ?dry_run
      ?network_interface_id
      ?private_ip_address
      () =
    { allocation_id
    ; instance_id
    ; public_ip
    ; allow_reassociation
    ; dry_run
    ; network_interface_id
    ; private_ip_address
    }

  let parse xml =
    Some
      { allocation_id =
          Aws.Util.option_bind (Aws.Xml.member "AllocationId" xml) String.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse
      ; public_ip = Aws.Util.option_bind (Aws.Xml.member "PublicIp" xml) String.parse
      ; allow_reassociation =
          Aws.Util.option_bind (Aws.Xml.member "allowReassociation" xml) Boolean.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; network_interface_id =
          Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse
      ; private_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "privateIpAddress" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.private_ip_address (fun f ->
               Aws.Query.Pair ("PrivateIpAddress", String.to_query f))
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               Aws.Query.Pair ("NetworkInterfaceId", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.allow_reassociation (fun f ->
               Aws.Query.Pair ("AllowReassociation", Boolean.to_query f))
         ; Aws.Util.option_map v.public_ip (fun f ->
               Aws.Query.Pair ("PublicIp", String.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.allocation_id (fun f ->
               Aws.Query.Pair ("AllocationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.private_ip_address (fun f ->
               "privateIpAddress", String.to_json f)
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               "networkInterfaceId", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.allow_reassociation (fun f ->
               "allowReassociation", Boolean.to_json f)
         ; Aws.Util.option_map v.public_ip (fun f -> "PublicIp", String.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "InstanceId", String.to_json f)
         ; Aws.Util.option_map v.allocation_id (fun f -> "AllocationId", String.to_json f)
         ])

  let of_json j =
    { allocation_id =
        Aws.Util.option_map (Aws.Json.lookup j "AllocationId") String.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "InstanceId") String.of_json
    ; public_ip = Aws.Util.option_map (Aws.Json.lookup j "PublicIp") String.of_json
    ; allow_reassociation =
        Aws.Util.option_map (Aws.Json.lookup j "allowReassociation") Boolean.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; network_interface_id =
        Aws.Util.option_map (Aws.Json.lookup j "networkInterfaceId") String.of_json
    ; private_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "privateIpAddress") String.of_json
    }
end

module RejectTransitGatewayVpcAttachmentRequest = struct
  type t =
    { transit_gateway_attachment_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~transit_gateway_attachment_id ?dry_run () =
    { transit_gateway_attachment_id; dry_run }

  let parse xml =
    Some
      { transit_gateway_attachment_id =
          Aws.Xml.required
            "TransitGatewayAttachmentId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayAttachmentId" xml)
               String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayAttachmentId"
                , String.to_query v.transit_gateway_attachment_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ("TransitGatewayAttachmentId", String.to_json v.transit_gateway_attachment_id)
         ])

  let of_json j =
    { transit_gateway_attachment_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayAttachmentId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module PrincipalIdFormatList = struct
  type t = PrincipalIdFormat.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map PrincipalIdFormat.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list PrincipalIdFormat.to_query v

  let to_json v = `List (List.map PrincipalIdFormat.to_json v)

  let of_json j = Aws.Json.to_list PrincipalIdFormat.of_json j
end

module PciId = struct
  type t =
    { device_id : String.t option
    ; vendor_id : String.t option
    ; subsystem_id : String.t option
    ; subsystem_vendor_id : String.t option
    }

  let make ?device_id ?vendor_id ?subsystem_id ?subsystem_vendor_id () =
    { device_id; vendor_id; subsystem_id; subsystem_vendor_id }

  let parse xml =
    Some
      { device_id = Aws.Util.option_bind (Aws.Xml.member "DeviceId" xml) String.parse
      ; vendor_id = Aws.Util.option_bind (Aws.Xml.member "VendorId" xml) String.parse
      ; subsystem_id =
          Aws.Util.option_bind (Aws.Xml.member "SubsystemId" xml) String.parse
      ; subsystem_vendor_id =
          Aws.Util.option_bind (Aws.Xml.member "SubsystemVendorId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.subsystem_vendor_id (fun f ->
               Aws.Query.Pair ("SubsystemVendorId", String.to_query f))
         ; Aws.Util.option_map v.subsystem_id (fun f ->
               Aws.Query.Pair ("SubsystemId", String.to_query f))
         ; Aws.Util.option_map v.vendor_id (fun f ->
               Aws.Query.Pair ("VendorId", String.to_query f))
         ; Aws.Util.option_map v.device_id (fun f ->
               Aws.Query.Pair ("DeviceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.subsystem_vendor_id (fun f ->
               "SubsystemVendorId", String.to_json f)
         ; Aws.Util.option_map v.subsystem_id (fun f -> "SubsystemId", String.to_json f)
         ; Aws.Util.option_map v.vendor_id (fun f -> "VendorId", String.to_json f)
         ; Aws.Util.option_map v.device_id (fun f -> "DeviceId", String.to_json f)
         ])

  let of_json j =
    { device_id = Aws.Util.option_map (Aws.Json.lookup j "DeviceId") String.of_json
    ; vendor_id = Aws.Util.option_map (Aws.Json.lookup j "VendorId") String.of_json
    ; subsystem_id = Aws.Util.option_map (Aws.Json.lookup j "SubsystemId") String.of_json
    ; subsystem_vendor_id =
        Aws.Util.option_map (Aws.Json.lookup j "SubsystemVendorId") String.of_json
    }
end

module FpgaImageStateCode = struct
  type t =
    | Pending
    | Failed
    | Available
    | Unavailable

  let str_to_t =
    [ "unavailable", Unavailable
    ; "available", Available
    ; "failed", Failed
    ; "pending", Pending
    ]

  let t_to_str =
    [ Unavailable, "unavailable"
    ; Available, "available"
    ; Failed, "failed"
    ; Pending, "pending"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module FpgaImageState = struct
  type t =
    { code : FpgaImageStateCode.t option
    ; message : String.t option
    }

  let make ?code ?message () = { code; message }

  let parse xml =
    Some
      { code = Aws.Util.option_bind (Aws.Xml.member "code" xml) FpgaImageStateCode.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair ("Code", FpgaImageStateCode.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f)
         ; Aws.Util.option_map v.code (fun f -> "code", FpgaImageStateCode.to_json f)
         ])

  let of_json j =
    { code = Aws.Util.option_map (Aws.Json.lookup j "code") FpgaImageStateCode.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json
    }
end

module FpgaImage = struct
  type t =
    { fpga_image_id : String.t option
    ; fpga_image_global_id : String.t option
    ; name : String.t option
    ; description : String.t option
    ; shell_version : String.t option
    ; pci_id : PciId.t option
    ; state : FpgaImageState.t option
    ; create_time : DateTime.t option
    ; update_time : DateTime.t option
    ; owner_id : String.t option
    ; owner_alias : String.t option
    ; product_codes : ProductCodeList.t
    ; tags : TagList.t
    ; public : Boolean.t option
    ; data_retention_support : Boolean.t option
    }

  let make
      ?fpga_image_id
      ?fpga_image_global_id
      ?name
      ?description
      ?shell_version
      ?pci_id
      ?state
      ?create_time
      ?update_time
      ?owner_id
      ?owner_alias
      ?(product_codes = [])
      ?(tags = [])
      ?public
      ?data_retention_support
      () =
    { fpga_image_id
    ; fpga_image_global_id
    ; name
    ; description
    ; shell_version
    ; pci_id
    ; state
    ; create_time
    ; update_time
    ; owner_id
    ; owner_alias
    ; product_codes
    ; tags
    ; public
    ; data_retention_support
    }

  let parse xml =
    Some
      { fpga_image_id =
          Aws.Util.option_bind (Aws.Xml.member "fpgaImageId" xml) String.parse
      ; fpga_image_global_id =
          Aws.Util.option_bind (Aws.Xml.member "fpgaImageGlobalId" xml) String.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "name" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; shell_version =
          Aws.Util.option_bind (Aws.Xml.member "shellVersion" xml) String.parse
      ; pci_id = Aws.Util.option_bind (Aws.Xml.member "pciId" xml) PciId.parse
      ; state = Aws.Util.option_bind (Aws.Xml.member "state" xml) FpgaImageState.parse
      ; create_time =
          Aws.Util.option_bind (Aws.Xml.member "createTime" xml) DateTime.parse
      ; update_time =
          Aws.Util.option_bind (Aws.Xml.member "updateTime" xml) DateTime.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; owner_alias = Aws.Util.option_bind (Aws.Xml.member "ownerAlias" xml) String.parse
      ; product_codes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "productCodes" xml)
               ProductCodeList.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tags" xml) TagList.parse)
      ; public = Aws.Util.option_bind (Aws.Xml.member "public" xml) Boolean.parse
      ; data_retention_support =
          Aws.Util.option_bind (Aws.Xml.member "dataRetentionSupport" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.data_retention_support (fun f ->
               Aws.Query.Pair ("DataRetentionSupport", Boolean.to_query f))
         ; Aws.Util.option_map v.public (fun f ->
               Aws.Query.Pair ("Public", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Tags", TagList.to_query v.tags))
         ; Some
             (Aws.Query.Pair ("ProductCodes", ProductCodeList.to_query v.product_codes))
         ; Aws.Util.option_map v.owner_alias (fun f ->
               Aws.Query.Pair ("OwnerAlias", String.to_query f))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.update_time (fun f ->
               Aws.Query.Pair ("UpdateTime", DateTime.to_query f))
         ; Aws.Util.option_map v.create_time (fun f ->
               Aws.Query.Pair ("CreateTime", DateTime.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", FpgaImageState.to_query f))
         ; Aws.Util.option_map v.pci_id (fun f ->
               Aws.Query.Pair ("PciId", PciId.to_query f))
         ; Aws.Util.option_map v.shell_version (fun f ->
               Aws.Query.Pair ("ShellVersion", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.fpga_image_global_id (fun f ->
               Aws.Query.Pair ("FpgaImageGlobalId", String.to_query f))
         ; Aws.Util.option_map v.fpga_image_id (fun f ->
               Aws.Query.Pair ("FpgaImageId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.data_retention_support (fun f ->
               "dataRetentionSupport", Boolean.to_json f)
         ; Aws.Util.option_map v.public (fun f -> "public", Boolean.to_json f)
         ; Some ("tags", TagList.to_json v.tags)
         ; Some ("productCodes", ProductCodeList.to_json v.product_codes)
         ; Aws.Util.option_map v.owner_alias (fun f -> "ownerAlias", String.to_json f)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.update_time (fun f -> "updateTime", DateTime.to_json f)
         ; Aws.Util.option_map v.create_time (fun f -> "createTime", DateTime.to_json f)
         ; Aws.Util.option_map v.state (fun f -> "state", FpgaImageState.to_json f)
         ; Aws.Util.option_map v.pci_id (fun f -> "pciId", PciId.to_json f)
         ; Aws.Util.option_map v.shell_version (fun f -> "shellVersion", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "name", String.to_json f)
         ; Aws.Util.option_map v.fpga_image_global_id (fun f ->
               "fpgaImageGlobalId", String.to_json f)
         ; Aws.Util.option_map v.fpga_image_id (fun f -> "fpgaImageId", String.to_json f)
         ])

  let of_json j =
    { fpga_image_id = Aws.Util.option_map (Aws.Json.lookup j "fpgaImageId") String.of_json
    ; fpga_image_global_id =
        Aws.Util.option_map (Aws.Json.lookup j "fpgaImageGlobalId") String.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "name") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; shell_version =
        Aws.Util.option_map (Aws.Json.lookup j "shellVersion") String.of_json
    ; pci_id = Aws.Util.option_map (Aws.Json.lookup j "pciId") PciId.of_json
    ; state = Aws.Util.option_map (Aws.Json.lookup j "state") FpgaImageState.of_json
    ; create_time = Aws.Util.option_map (Aws.Json.lookup j "createTime") DateTime.of_json
    ; update_time = Aws.Util.option_map (Aws.Json.lookup j "updateTime") DateTime.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; owner_alias = Aws.Util.option_map (Aws.Json.lookup j "ownerAlias") String.of_json
    ; product_codes =
        ProductCodeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "productCodes"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tags"))
    ; public = Aws.Util.option_map (Aws.Json.lookup j "public") Boolean.of_json
    ; data_retention_support =
        Aws.Util.option_map (Aws.Json.lookup j "dataRetentionSupport") Boolean.of_json
    }
end

module FpgaImageList = struct
  type t = FpgaImage.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map FpgaImage.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list FpgaImage.to_query v

  let to_json v = `List (List.map FpgaImage.to_json v)

  let of_json j = Aws.Json.to_list FpgaImage.of_json j
end

module DeregisterInstanceTagAttributeRequest = struct
  type t =
    { include_all_tags_of_instance : Boolean.t option
    ; instance_tag_keys : InstanceTagKeySet.t
    }

  let make ?include_all_tags_of_instance ?(instance_tag_keys = []) () =
    { include_all_tags_of_instance; instance_tag_keys }

  let parse xml =
    Some
      { include_all_tags_of_instance =
          Aws.Util.option_bind
            (Aws.Xml.member "IncludeAllTagsOfInstance" xml)
            Boolean.parse
      ; instance_tag_keys =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "InstanceTagKey" xml)
               InstanceTagKeySet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("InstanceTagKey", InstanceTagKeySet.to_query v.instance_tag_keys))
         ; Aws.Util.option_map v.include_all_tags_of_instance (fun f ->
               Aws.Query.Pair ("IncludeAllTagsOfInstance", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("InstanceTagKey", InstanceTagKeySet.to_json v.instance_tag_keys)
         ; Aws.Util.option_map v.include_all_tags_of_instance (fun f ->
               "IncludeAllTagsOfInstance", Boolean.to_json f)
         ])

  let of_json j =
    { include_all_tags_of_instance =
        Aws.Util.option_map (Aws.Json.lookup j "IncludeAllTagsOfInstance") Boolean.of_json
    ; instance_tag_keys =
        InstanceTagKeySet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceTagKey"))
    }
end

module PlacementStrategy = struct
  type t =
    | Cluster
    | Spread
    | Partition

  let str_to_t = [ "partition", Partition; "spread", Spread; "cluster", Cluster ]

  let t_to_str = [ Partition, "partition"; Spread, "spread"; Cluster, "cluster" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module CreatePlacementGroupRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; group_name : String.t option
    ; strategy : PlacementStrategy.t option
    ; partition_count : Integer.t option
    ; tag_specifications : TagSpecificationList.t
    }

  let make ?dry_run ?group_name ?strategy ?partition_count ?(tag_specifications = []) () =
    { dry_run; group_name; strategy; partition_count; tag_specifications }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; group_name = Aws.Util.option_bind (Aws.Xml.member "groupName" xml) String.parse
      ; strategy =
          Aws.Util.option_bind (Aws.Xml.member "strategy" xml) PlacementStrategy.parse
      ; partition_count =
          Aws.Util.option_bind (Aws.Xml.member "PartitionCount" xml) Integer.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Aws.Util.option_map v.partition_count (fun f ->
               Aws.Query.Pair ("PartitionCount", Integer.to_query f))
         ; Aws.Util.option_map v.strategy (fun f ->
               Aws.Query.Pair ("Strategy", PlacementStrategy.to_query f))
         ; Aws.Util.option_map v.group_name (fun f ->
               Aws.Query.Pair ("GroupName", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Aws.Util.option_map v.partition_count (fun f ->
               "PartitionCount", Integer.to_json f)
         ; Aws.Util.option_map v.strategy (fun f ->
               "strategy", PlacementStrategy.to_json f)
         ; Aws.Util.option_map v.group_name (fun f -> "groupName", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; group_name = Aws.Util.option_map (Aws.Json.lookup j "groupName") String.of_json
    ; strategy =
        Aws.Util.option_map (Aws.Json.lookup j "strategy") PlacementStrategy.of_json
    ; partition_count =
        Aws.Util.option_map (Aws.Json.lookup j "PartitionCount") Integer.of_json
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    }
end

module TransitGatewayMulticastRegisteredGroupMembers = struct
  type t =
    { transit_gateway_multicast_domain_id : String.t option
    ; registered_network_interface_ids : ValueStringList.t
    ; group_ip_address : String.t option
    }

  let make
      ?transit_gateway_multicast_domain_id
      ?(registered_network_interface_ids = [])
      ?group_ip_address
      () =
    { transit_gateway_multicast_domain_id
    ; registered_network_interface_ids
    ; group_ip_address
    }

  let parse xml =
    Some
      { transit_gateway_multicast_domain_id =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayMulticastDomainId" xml)
            String.parse
      ; registered_network_interface_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "registeredNetworkInterfaceIds" xml)
               ValueStringList.parse)
      ; group_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "groupIpAddress" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.group_ip_address (fun f ->
               Aws.Query.Pair ("GroupIpAddress", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "RegisteredNetworkInterfaceIds"
                , ValueStringList.to_query v.registered_network_interface_ids ))
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               Aws.Query.Pair ("TransitGatewayMulticastDomainId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.group_ip_address (fun f ->
               "groupIpAddress", String.to_json f)
         ; Some
             ( "registeredNetworkInterfaceIds"
             , ValueStringList.to_json v.registered_network_interface_ids )
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               "transitGatewayMulticastDomainId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_multicast_domain_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayMulticastDomainId")
          String.of_json
    ; registered_network_interface_ids =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "registeredNetworkInterfaceIds"))
    ; group_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "groupIpAddress") String.of_json
    }
end

module RegisterTransitGatewayMulticastGroupMembersRequest = struct
  type t =
    { transit_gateway_multicast_domain_id : String.t option
    ; group_ip_address : String.t option
    ; network_interface_ids : TransitGatewayNetworkInterfaceIdList.t
    ; dry_run : Boolean.t option
    }

  let make
      ?transit_gateway_multicast_domain_id
      ?group_ip_address
      ?(network_interface_ids = [])
      ?dry_run
      () =
    { transit_gateway_multicast_domain_id
    ; group_ip_address
    ; network_interface_ids
    ; dry_run
    }

  let parse xml =
    Some
      { transit_gateway_multicast_domain_id =
          Aws.Util.option_bind
            (Aws.Xml.member "TransitGatewayMulticastDomainId" xml)
            String.parse
      ; group_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "GroupIpAddress" xml) String.parse
      ; network_interface_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "NetworkInterfaceIds" xml)
               TransitGatewayNetworkInterfaceIdList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "NetworkInterfaceIds"
                , TransitGatewayNetworkInterfaceIdList.to_query v.network_interface_ids ))
         ; Aws.Util.option_map v.group_ip_address (fun f ->
               Aws.Query.Pair ("GroupIpAddress", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               Aws.Query.Pair ("TransitGatewayMulticastDomainId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ( "NetworkInterfaceIds"
             , TransitGatewayNetworkInterfaceIdList.to_json v.network_interface_ids )
         ; Aws.Util.option_map v.group_ip_address (fun f ->
               "GroupIpAddress", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               "TransitGatewayMulticastDomainId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_multicast_domain_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "TransitGatewayMulticastDomainId")
          String.of_json
    ; group_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "GroupIpAddress") String.of_json
    ; network_interface_ids =
        TransitGatewayNetworkInterfaceIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "NetworkInterfaceIds"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module InstanceCreditSpecification = struct
  type t =
    { instance_id : String.t option
    ; cpu_credits : String.t option
    }

  let make ?instance_id ?cpu_credits () = { instance_id; cpu_credits }

  let parse xml =
    Some
      { instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      ; cpu_credits = Aws.Util.option_bind (Aws.Xml.member "cpuCredits" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cpu_credits (fun f ->
               Aws.Query.Pair ("CpuCredits", String.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cpu_credits (fun f -> "cpuCredits", String.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ])

  let of_json j =
    { instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    ; cpu_credits = Aws.Util.option_map (Aws.Json.lookup j "cpuCredits") String.of_json
    }
end

module InstanceCreditSpecificationList = struct
  type t = InstanceCreditSpecification.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map InstanceCreditSpecification.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list InstanceCreditSpecification.to_query v

  let to_json v = `List (List.map InstanceCreditSpecification.to_json v)

  let of_json j = Aws.Json.to_list InstanceCreditSpecification.of_json j
end

module ResourceIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module CreateTagsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; resources : ResourceIdList.t
    ; tags : TagList.t
    }

  let make ?dry_run ~resources ~tags () = { dry_run; resources; tags }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; resources =
          Aws.Xml.required
            "ResourceId"
            (Aws.Util.option_bind (Aws.Xml.member "ResourceId" xml) ResourceIdList.parse)
      ; tags =
          Aws.Xml.required
            "Tag"
            (Aws.Util.option_bind (Aws.Xml.member "Tag" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tag", TagList.to_query v.tags))
         ; Some (Aws.Query.Pair ("ResourceId", ResourceIdList.to_query v.resources))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tag", TagList.to_json v.tags)
         ; Some ("ResourceId", ResourceIdList.to_json v.resources)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; resources =
        ResourceIdList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ResourceId"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tag"))
    }
end

module ReservedInstancesListingList = struct
  type t = ReservedInstancesListing.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ReservedInstancesListing.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ReservedInstancesListing.to_query v

  let to_json v = `List (List.map ReservedInstancesListing.to_json v)

  let of_json j = Aws.Json.to_list ReservedInstancesListing.of_json j
end

module CancelReservedInstancesListingResult = struct
  type t = { reserved_instances_listings : ReservedInstancesListingList.t }

  let make ?(reserved_instances_listings = []) () = { reserved_instances_listings }

  let parse xml =
    Some
      { reserved_instances_listings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "reservedInstancesListingsSet" xml)
               ReservedInstancesListingList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "ReservedInstancesListingsSet"
                , ReservedInstancesListingList.to_query v.reserved_instances_listings ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "reservedInstancesListingsSet"
             , ReservedInstancesListingList.to_json v.reserved_instances_listings )
         ])

  let of_json j =
    { reserved_instances_listings =
        ReservedInstancesListingList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "reservedInstancesListingsSet"))
    }
end

module DeleteLocalGatewayRouteResult = struct
  type t = { route : LocalGatewayRoute.t option }

  let make ?route () = { route }

  let parse xml =
    Some
      { route = Aws.Util.option_bind (Aws.Xml.member "route" xml) LocalGatewayRoute.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.route (fun f ->
               Aws.Query.Pair ("Route", LocalGatewayRoute.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.route (fun f -> "route", LocalGatewayRoute.to_json f) ])

  let of_json j =
    { route = Aws.Util.option_map (Aws.Json.lookup j "route") LocalGatewayRoute.of_json }
end

module AttachVolumeRequest = struct
  type t =
    { device : String.t
    ; instance_id : String.t
    ; volume_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~device ~instance_id ~volume_id ?dry_run () =
    { device; instance_id; volume_id; dry_run }

  let parse xml =
    Some
      { device =
          Aws.Xml.required
            "Device"
            (Aws.Util.option_bind (Aws.Xml.member "Device" xml) String.parse)
      ; instance_id =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse)
      ; volume_id =
          Aws.Xml.required
            "VolumeId"
            (Aws.Util.option_bind (Aws.Xml.member "VolumeId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("VolumeId", String.to_query v.volume_id))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ; Some (Aws.Query.Pair ("Device", String.to_query v.device))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("VolumeId", String.to_json v.volume_id)
         ; Some ("InstanceId", String.to_json v.instance_id)
         ; Some ("Device", String.to_json v.device)
         ])

  let of_json j =
    { device = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Device"))
    ; instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; volume_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VolumeId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module RegisterImageResult = struct
  type t = { image_id : String.t option }

  let make ?image_id () = { image_id }

  let parse xml =
    Some { image_id = Aws.Util.option_bind (Aws.Xml.member "imageId" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.image_id (fun f ->
               Aws.Query.Pair ("ImageId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.image_id (fun f -> "imageId", String.to_json f) ])

  let of_json j =
    { image_id = Aws.Util.option_map (Aws.Json.lookup j "imageId") String.of_json }
end

module DiskImageDetail = struct
  type t =
    { bytes : Long.t
    ; format : DiskImageFormat.t
    ; import_manifest_url : String.t
    }

  let make ~bytes ~format ~import_manifest_url () = { bytes; format; import_manifest_url }

  let parse xml =
    Some
      { bytes =
          Aws.Xml.required
            "bytes"
            (Aws.Util.option_bind (Aws.Xml.member "bytes" xml) Long.parse)
      ; format =
          Aws.Xml.required
            "format"
            (Aws.Util.option_bind (Aws.Xml.member "format" xml) DiskImageFormat.parse)
      ; import_manifest_url =
          Aws.Xml.required
            "importManifestUrl"
            (Aws.Util.option_bind (Aws.Xml.member "importManifestUrl" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("ImportManifestUrl", String.to_query v.import_manifest_url))
         ; Some (Aws.Query.Pair ("Format", DiskImageFormat.to_query v.format))
         ; Some (Aws.Query.Pair ("Bytes", Long.to_query v.bytes))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("importManifestUrl", String.to_json v.import_manifest_url)
         ; Some ("format", DiskImageFormat.to_json v.format)
         ; Some ("bytes", Long.to_json v.bytes)
         ])

  let of_json j =
    { bytes = Long.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "bytes"))
    ; format =
        DiskImageFormat.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "format"))
    ; import_manifest_url =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "importManifestUrl"))
    }
end

module DisableVpcClassicLinkDnsSupportResult = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module ModifyTrafficMirrorSessionResult = struct
  type t = { traffic_mirror_session : TrafficMirrorSession.t option }

  let make ?traffic_mirror_session () = { traffic_mirror_session }

  let parse xml =
    Some
      { traffic_mirror_session =
          Aws.Util.option_bind
            (Aws.Xml.member "trafficMirrorSession" xml)
            TrafficMirrorSession.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.traffic_mirror_session (fun f ->
               Aws.Query.Pair ("TrafficMirrorSession", TrafficMirrorSession.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.traffic_mirror_session (fun f ->
               "trafficMirrorSession", TrafficMirrorSession.to_json f)
         ])

  let of_json j =
    { traffic_mirror_session =
        Aws.Util.option_map
          (Aws.Json.lookup j "trafficMirrorSession")
          TrafficMirrorSession.of_json
    }
end

module GetManagedPrefixListEntriesRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; prefix_list_id : String.t
    ; target_version : Long.t option
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?dry_run ~prefix_list_id ?target_version ?max_results ?next_token () =
    { dry_run; prefix_list_id; target_version; max_results; next_token }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; prefix_list_id =
          Aws.Xml.required
            "PrefixListId"
            (Aws.Util.option_bind (Aws.Xml.member "PrefixListId" xml) String.parse)
      ; target_version =
          Aws.Util.option_bind (Aws.Xml.member "TargetVersion" xml) Long.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.target_version (fun f ->
               Aws.Query.Pair ("TargetVersion", Long.to_query f))
         ; Some (Aws.Query.Pair ("PrefixListId", String.to_query v.prefix_list_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.target_version (fun f -> "TargetVersion", Long.to_json f)
         ; Some ("PrefixListId", String.to_json v.prefix_list_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; prefix_list_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PrefixListId"))
    ; target_version =
        Aws.Util.option_map (Aws.Json.lookup j "TargetVersion") Long.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module CreateVpnGatewayRequest = struct
  type t =
    { availability_zone : String.t option
    ; type_ : GatewayType.t
    ; tag_specifications : TagSpecificationList.t
    ; amazon_side_asn : Long.t option
    ; dry_run : Boolean.t option
    }

  let make
      ?availability_zone
      ~type_
      ?(tag_specifications = [])
      ?amazon_side_asn
      ?dry_run
      () =
    { availability_zone; type_; tag_specifications; amazon_side_asn; dry_run }

  let parse xml =
    Some
      { availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "AvailabilityZone" xml) String.parse
      ; type_ =
          Aws.Xml.required
            "Type"
            (Aws.Util.option_bind (Aws.Xml.member "Type" xml) GatewayType.parse)
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      ; amazon_side_asn =
          Aws.Util.option_bind (Aws.Xml.member "AmazonSideAsn" xml) Long.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.amazon_side_asn (fun f ->
               Aws.Query.Pair ("AmazonSideAsn", Long.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Some (Aws.Query.Pair ("Type", GatewayType.to_query v.type_))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.amazon_side_asn (fun f ->
               "AmazonSideAsn", Long.to_json f)
         ; Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Some ("Type", GatewayType.to_json v.type_)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "AvailabilityZone", String.to_json f)
         ])

  let of_json j =
    { availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "AvailabilityZone") String.of_json
    ; type_ = GatewayType.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Type"))
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    ; amazon_side_asn =
        Aws.Util.option_map (Aws.Json.lookup j "AmazonSideAsn") Long.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module ReplaceTransitGatewayRouteRequest = struct
  type t =
    { destination_cidr_block : String.t
    ; transit_gateway_route_table_id : String.t
    ; transit_gateway_attachment_id : String.t option
    ; blackhole : Boolean.t option
    ; dry_run : Boolean.t option
    }

  let make
      ~destination_cidr_block
      ~transit_gateway_route_table_id
      ?transit_gateway_attachment_id
      ?blackhole
      ?dry_run
      () =
    { destination_cidr_block
    ; transit_gateway_route_table_id
    ; transit_gateway_attachment_id
    ; blackhole
    ; dry_run
    }

  let parse xml =
    Some
      { destination_cidr_block =
          Aws.Xml.required
            "DestinationCidrBlock"
            (Aws.Util.option_bind
               (Aws.Xml.member "DestinationCidrBlock" xml)
               String.parse)
      ; transit_gateway_route_table_id =
          Aws.Xml.required
            "TransitGatewayRouteTableId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayRouteTableId" xml)
               String.parse)
      ; transit_gateway_attachment_id =
          Aws.Util.option_bind
            (Aws.Xml.member "TransitGatewayAttachmentId" xml)
            String.parse
      ; blackhole = Aws.Util.option_bind (Aws.Xml.member "Blackhole" xml) Boolean.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.blackhole (fun f ->
               Aws.Query.Pair ("Blackhole", Boolean.to_query f))
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               Aws.Query.Pair ("TransitGatewayAttachmentId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayRouteTableId"
                , String.to_query v.transit_gateway_route_table_id ))
         ; Some
             (Aws.Query.Pair
                ("DestinationCidrBlock", String.to_query v.destination_cidr_block))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.blackhole (fun f -> "Blackhole", Boolean.to_json f)
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               "TransitGatewayAttachmentId", String.to_json f)
         ; Some
             ( "TransitGatewayRouteTableId"
             , String.to_json v.transit_gateway_route_table_id )
         ; Some ("DestinationCidrBlock", String.to_json v.destination_cidr_block)
         ])

  let of_json j =
    { destination_cidr_block =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DestinationCidrBlock"))
    ; transit_gateway_route_table_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayRouteTableId"))
    ; transit_gateway_attachment_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "TransitGatewayAttachmentId")
          String.of_json
    ; blackhole = Aws.Util.option_map (Aws.Json.lookup j "Blackhole") Boolean.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module TrafficMirrorFilterIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeTrafficMirrorFiltersRequest = struct
  type t =
    { traffic_mirror_filter_ids : TrafficMirrorFilterIdList.t
    ; dry_run : Boolean.t option
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make
      ?(traffic_mirror_filter_ids = [])
      ?dry_run
      ?(filters = [])
      ?max_results
      ?next_token
      () =
    { traffic_mirror_filter_ids; dry_run; filters; max_results; next_token }

  let parse xml =
    Some
      { traffic_mirror_filter_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TrafficMirrorFilterId" xml)
               TrafficMirrorFilterIdList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TrafficMirrorFilterId"
                , TrafficMirrorFilterIdList.to_query v.traffic_mirror_filter_ids ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ( "TrafficMirrorFilterId"
             , TrafficMirrorFilterIdList.to_json v.traffic_mirror_filter_ids )
         ])

  let of_json j =
    { traffic_mirror_filter_ids =
        TrafficMirrorFilterIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TrafficMirrorFilterId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module TrafficMirrorTargetIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module TrafficMirrorRuleAction = struct
  type t =
    | Accept
    | Reject

  let str_to_t = [ "reject", Reject; "accept", Accept ]

  let t_to_str = [ Reject, "reject"; Accept, "accept" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module TrafficMirrorPortRange = struct
  type t =
    { from_port : Integer.t option
    ; to_port : Integer.t option
    }

  let make ?from_port ?to_port () = { from_port; to_port }

  let parse xml =
    Some
      { from_port = Aws.Util.option_bind (Aws.Xml.member "fromPort" xml) Integer.parse
      ; to_port = Aws.Util.option_bind (Aws.Xml.member "toPort" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.to_port (fun f ->
               Aws.Query.Pair ("ToPort", Integer.to_query f))
         ; Aws.Util.option_map v.from_port (fun f ->
               Aws.Query.Pair ("FromPort", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.to_port (fun f -> "toPort", Integer.to_json f)
         ; Aws.Util.option_map v.from_port (fun f -> "fromPort", Integer.to_json f)
         ])

  let of_json j =
    { from_port = Aws.Util.option_map (Aws.Json.lookup j "fromPort") Integer.of_json
    ; to_port = Aws.Util.option_map (Aws.Json.lookup j "toPort") Integer.of_json
    }
end

module TrafficMirrorFilterRule = struct
  type t =
    { traffic_mirror_filter_rule_id : String.t option
    ; traffic_mirror_filter_id : String.t option
    ; traffic_direction : TrafficDirection.t option
    ; rule_number : Integer.t option
    ; rule_action : TrafficMirrorRuleAction.t option
    ; protocol : Integer.t option
    ; destination_port_range : TrafficMirrorPortRange.t option
    ; source_port_range : TrafficMirrorPortRange.t option
    ; destination_cidr_block : String.t option
    ; source_cidr_block : String.t option
    ; description : String.t option
    }

  let make
      ?traffic_mirror_filter_rule_id
      ?traffic_mirror_filter_id
      ?traffic_direction
      ?rule_number
      ?rule_action
      ?protocol
      ?destination_port_range
      ?source_port_range
      ?destination_cidr_block
      ?source_cidr_block
      ?description
      () =
    { traffic_mirror_filter_rule_id
    ; traffic_mirror_filter_id
    ; traffic_direction
    ; rule_number
    ; rule_action
    ; protocol
    ; destination_port_range
    ; source_port_range
    ; destination_cidr_block
    ; source_cidr_block
    ; description
    }

  let parse xml =
    Some
      { traffic_mirror_filter_rule_id =
          Aws.Util.option_bind
            (Aws.Xml.member "trafficMirrorFilterRuleId" xml)
            String.parse
      ; traffic_mirror_filter_id =
          Aws.Util.option_bind (Aws.Xml.member "trafficMirrorFilterId" xml) String.parse
      ; traffic_direction =
          Aws.Util.option_bind
            (Aws.Xml.member "trafficDirection" xml)
            TrafficDirection.parse
      ; rule_number = Aws.Util.option_bind (Aws.Xml.member "ruleNumber" xml) Integer.parse
      ; rule_action =
          Aws.Util.option_bind
            (Aws.Xml.member "ruleAction" xml)
            TrafficMirrorRuleAction.parse
      ; protocol = Aws.Util.option_bind (Aws.Xml.member "protocol" xml) Integer.parse
      ; destination_port_range =
          Aws.Util.option_bind
            (Aws.Xml.member "destinationPortRange" xml)
            TrafficMirrorPortRange.parse
      ; source_port_range =
          Aws.Util.option_bind
            (Aws.Xml.member "sourcePortRange" xml)
            TrafficMirrorPortRange.parse
      ; destination_cidr_block =
          Aws.Util.option_bind (Aws.Xml.member "destinationCidrBlock" xml) String.parse
      ; source_cidr_block =
          Aws.Util.option_bind (Aws.Xml.member "sourceCidrBlock" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.source_cidr_block (fun f ->
               Aws.Query.Pair ("SourceCidrBlock", String.to_query f))
         ; Aws.Util.option_map v.destination_cidr_block (fun f ->
               Aws.Query.Pair ("DestinationCidrBlock", String.to_query f))
         ; Aws.Util.option_map v.source_port_range (fun f ->
               Aws.Query.Pair ("SourcePortRange", TrafficMirrorPortRange.to_query f))
         ; Aws.Util.option_map v.destination_port_range (fun f ->
               Aws.Query.Pair ("DestinationPortRange", TrafficMirrorPortRange.to_query f))
         ; Aws.Util.option_map v.protocol (fun f ->
               Aws.Query.Pair ("Protocol", Integer.to_query f))
         ; Aws.Util.option_map v.rule_action (fun f ->
               Aws.Query.Pair ("RuleAction", TrafficMirrorRuleAction.to_query f))
         ; Aws.Util.option_map v.rule_number (fun f ->
               Aws.Query.Pair ("RuleNumber", Integer.to_query f))
         ; Aws.Util.option_map v.traffic_direction (fun f ->
               Aws.Query.Pair ("TrafficDirection", TrafficDirection.to_query f))
         ; Aws.Util.option_map v.traffic_mirror_filter_id (fun f ->
               Aws.Query.Pair ("TrafficMirrorFilterId", String.to_query f))
         ; Aws.Util.option_map v.traffic_mirror_filter_rule_id (fun f ->
               Aws.Query.Pair ("TrafficMirrorFilterRuleId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Aws.Util.option_map v.source_cidr_block (fun f ->
               "sourceCidrBlock", String.to_json f)
         ; Aws.Util.option_map v.destination_cidr_block (fun f ->
               "destinationCidrBlock", String.to_json f)
         ; Aws.Util.option_map v.source_port_range (fun f ->
               "sourcePortRange", TrafficMirrorPortRange.to_json f)
         ; Aws.Util.option_map v.destination_port_range (fun f ->
               "destinationPortRange", TrafficMirrorPortRange.to_json f)
         ; Aws.Util.option_map v.protocol (fun f -> "protocol", Integer.to_json f)
         ; Aws.Util.option_map v.rule_action (fun f ->
               "ruleAction", TrafficMirrorRuleAction.to_json f)
         ; Aws.Util.option_map v.rule_number (fun f -> "ruleNumber", Integer.to_json f)
         ; Aws.Util.option_map v.traffic_direction (fun f ->
               "trafficDirection", TrafficDirection.to_json f)
         ; Aws.Util.option_map v.traffic_mirror_filter_id (fun f ->
               "trafficMirrorFilterId", String.to_json f)
         ; Aws.Util.option_map v.traffic_mirror_filter_rule_id (fun f ->
               "trafficMirrorFilterRuleId", String.to_json f)
         ])

  let of_json j =
    { traffic_mirror_filter_rule_id =
        Aws.Util.option_map (Aws.Json.lookup j "trafficMirrorFilterRuleId") String.of_json
    ; traffic_mirror_filter_id =
        Aws.Util.option_map (Aws.Json.lookup j "trafficMirrorFilterId") String.of_json
    ; traffic_direction =
        Aws.Util.option_map
          (Aws.Json.lookup j "trafficDirection")
          TrafficDirection.of_json
    ; rule_number = Aws.Util.option_map (Aws.Json.lookup j "ruleNumber") Integer.of_json
    ; rule_action =
        Aws.Util.option_map
          (Aws.Json.lookup j "ruleAction")
          TrafficMirrorRuleAction.of_json
    ; protocol = Aws.Util.option_map (Aws.Json.lookup j "protocol") Integer.of_json
    ; destination_port_range =
        Aws.Util.option_map
          (Aws.Json.lookup j "destinationPortRange")
          TrafficMirrorPortRange.of_json
    ; source_port_range =
        Aws.Util.option_map
          (Aws.Json.lookup j "sourcePortRange")
          TrafficMirrorPortRange.of_json
    ; destination_cidr_block =
        Aws.Util.option_map (Aws.Json.lookup j "destinationCidrBlock") String.of_json
    ; source_cidr_block =
        Aws.Util.option_map (Aws.Json.lookup j "sourceCidrBlock") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    }
end

module TrafficMirrorFilterRuleList = struct
  type t = TrafficMirrorFilterRule.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map TrafficMirrorFilterRule.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list TrafficMirrorFilterRule.to_query v

  let to_json v = `List (List.map TrafficMirrorFilterRule.to_json v)

  let of_json j = Aws.Json.to_list TrafficMirrorFilterRule.of_json j
end

module OnDemandAllocationStrategy = struct
  type t =
    | LowestPrice
    | Prioritized

  let str_to_t = [ "prioritized", Prioritized; "lowestPrice", LowestPrice ]

  let t_to_str = [ Prioritized, "prioritized"; LowestPrice, "lowestPrice" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module NetworkInterfacePermissionIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeNetworkInterfacePermissionsRequest = struct
  type t =
    { network_interface_permission_ids : NetworkInterfacePermissionIdList.t
    ; filters : FilterList.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    }

  let make
      ?(network_interface_permission_ids = [])
      ?(filters = [])
      ?next_token
      ?max_results
      () =
    { network_interface_permission_ids; filters; next_token; max_results }

  let parse xml =
    Some
      { network_interface_permission_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "NetworkInterfacePermissionId" xml)
               NetworkInterfacePermissionIdList.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ( "NetworkInterfacePermissionId"
                , NetworkInterfacePermissionIdList.to_query
                    v.network_interface_permission_ids ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some
             ( "NetworkInterfacePermissionId"
             , NetworkInterfacePermissionIdList.to_json v.network_interface_permission_ids
             )
         ])

  let of_json j =
    { network_interface_permission_ids =
        NetworkInterfacePermissionIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "NetworkInterfacePermissionId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module SnapshotState = struct
  type t =
    | Pending
    | Completed
    | Error

  let str_to_t = [ "error", Error; "completed", Completed; "pending", Pending ]

  let t_to_str = [ Error, "error"; Completed, "completed"; Pending, "pending" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module SnapshotInfo = struct
  type t =
    { description : String.t option
    ; tags : TagList.t
    ; encrypted : Boolean.t option
    ; volume_id : String.t option
    ; state : SnapshotState.t option
    ; volume_size : Integer.t option
    ; start_time : DateTime.t option
    ; progress : String.t option
    ; owner_id : String.t option
    ; snapshot_id : String.t option
    }

  let make
      ?description
      ?(tags = [])
      ?encrypted
      ?volume_id
      ?state
      ?volume_size
      ?start_time
      ?progress
      ?owner_id
      ?snapshot_id
      () =
    { description
    ; tags
    ; encrypted
    ; volume_id
    ; state
    ; volume_size
    ; start_time
    ; progress
    ; owner_id
    ; snapshot_id
    }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      ; encrypted = Aws.Util.option_bind (Aws.Xml.member "encrypted" xml) Boolean.parse
      ; volume_id = Aws.Util.option_bind (Aws.Xml.member "volumeId" xml) String.parse
      ; state = Aws.Util.option_bind (Aws.Xml.member "state" xml) SnapshotState.parse
      ; volume_size = Aws.Util.option_bind (Aws.Xml.member "volumeSize" xml) Integer.parse
      ; start_time = Aws.Util.option_bind (Aws.Xml.member "startTime" xml) DateTime.parse
      ; progress = Aws.Util.option_bind (Aws.Xml.member "progress" xml) String.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; snapshot_id = Aws.Util.option_bind (Aws.Xml.member "snapshotId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.snapshot_id (fun f ->
               Aws.Query.Pair ("SnapshotId", String.to_query f))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.progress (fun f ->
               Aws.Query.Pair ("Progress", String.to_query f))
         ; Aws.Util.option_map v.start_time (fun f ->
               Aws.Query.Pair ("StartTime", DateTime.to_query f))
         ; Aws.Util.option_map v.volume_size (fun f ->
               Aws.Query.Pair ("VolumeSize", Integer.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", SnapshotState.to_query f))
         ; Aws.Util.option_map v.volume_id (fun f ->
               Aws.Query.Pair ("VolumeId", String.to_query f))
         ; Aws.Util.option_map v.encrypted (fun f ->
               Aws.Query.Pair ("Encrypted", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.snapshot_id (fun f -> "snapshotId", String.to_json f)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.progress (fun f -> "progress", String.to_json f)
         ; Aws.Util.option_map v.start_time (fun f -> "startTime", DateTime.to_json f)
         ; Aws.Util.option_map v.volume_size (fun f -> "volumeSize", Integer.to_json f)
         ; Aws.Util.option_map v.state (fun f -> "state", SnapshotState.to_json f)
         ; Aws.Util.option_map v.volume_id (fun f -> "volumeId", String.to_json f)
         ; Aws.Util.option_map v.encrypted (fun f -> "encrypted", Boolean.to_json f)
         ; Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    ; encrypted = Aws.Util.option_map (Aws.Json.lookup j "encrypted") Boolean.of_json
    ; volume_id = Aws.Util.option_map (Aws.Json.lookup j "volumeId") String.of_json
    ; state = Aws.Util.option_map (Aws.Json.lookup j "state") SnapshotState.of_json
    ; volume_size = Aws.Util.option_map (Aws.Json.lookup j "volumeSize") Integer.of_json
    ; start_time = Aws.Util.option_map (Aws.Json.lookup j "startTime") DateTime.of_json
    ; progress = Aws.Util.option_map (Aws.Json.lookup j "progress") String.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; snapshot_id = Aws.Util.option_map (Aws.Json.lookup j "snapshotId") String.of_json
    }
end

module AuthorizeClientVpnIngressRequest = struct
  type t =
    { client_vpn_endpoint_id : String.t
    ; target_network_cidr : String.t
    ; access_group_id : String.t option
    ; authorize_all_groups : Boolean.t option
    ; description : String.t option
    ; client_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make
      ~client_vpn_endpoint_id
      ~target_network_cidr
      ?access_group_id
      ?authorize_all_groups
      ?description
      ?client_token
      ?dry_run
      () =
    { client_vpn_endpoint_id
    ; target_network_cidr
    ; access_group_id
    ; authorize_all_groups
    ; description
    ; client_token
    ; dry_run
    }

  let parse xml =
    Some
      { client_vpn_endpoint_id =
          Aws.Xml.required
            "ClientVpnEndpointId"
            (Aws.Util.option_bind (Aws.Xml.member "ClientVpnEndpointId" xml) String.parse)
      ; target_network_cidr =
          Aws.Xml.required
            "TargetNetworkCidr"
            (Aws.Util.option_bind (Aws.Xml.member "TargetNetworkCidr" xml) String.parse)
      ; access_group_id =
          Aws.Util.option_bind (Aws.Xml.member "AccessGroupId" xml) String.parse
      ; authorize_all_groups =
          Aws.Util.option_bind (Aws.Xml.member "AuthorizeAllGroups" xml) Boolean.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.authorize_all_groups (fun f ->
               Aws.Query.Pair ("AuthorizeAllGroups", Boolean.to_query f))
         ; Aws.Util.option_map v.access_group_id (fun f ->
               Aws.Query.Pair ("AccessGroupId", String.to_query f))
         ; Some
             (Aws.Query.Pair ("TargetNetworkCidr", String.to_query v.target_network_cidr))
         ; Some
             (Aws.Query.Pair
                ("ClientVpnEndpointId", String.to_query v.client_vpn_endpoint_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.authorize_all_groups (fun f ->
               "AuthorizeAllGroups", Boolean.to_json f)
         ; Aws.Util.option_map v.access_group_id (fun f ->
               "AccessGroupId", String.to_json f)
         ; Some ("TargetNetworkCidr", String.to_json v.target_network_cidr)
         ; Some ("ClientVpnEndpointId", String.to_json v.client_vpn_endpoint_id)
         ])

  let of_json j =
    { client_vpn_endpoint_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ClientVpnEndpointId"))
    ; target_network_cidr =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TargetNetworkCidr"))
    ; access_group_id =
        Aws.Util.option_map (Aws.Json.lookup j "AccessGroupId") String.of_json
    ; authorize_all_groups =
        Aws.Util.option_map (Aws.Json.lookup j "AuthorizeAllGroups") Boolean.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module SnapshotAttributeName = struct
  type t =
    | ProductCodes
    | CreateVolumePermission

  let str_to_t =
    [ "createVolumePermission", CreateVolumePermission; "productCodes", ProductCodes ]

  let t_to_str =
    [ CreateVolumePermission, "createVolumePermission"; ProductCodes, "productCodes" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module NetworkInterfacePermissionState = struct
  type t =
    { state : NetworkInterfacePermissionStateCode.t option
    ; status_message : String.t option
    }

  let make ?state ?status_message () = { state; status_message }

  let parse xml =
    Some
      { state =
          Aws.Util.option_bind
            (Aws.Xml.member "state" xml)
            NetworkInterfacePermissionStateCode.parse
      ; status_message =
          Aws.Util.option_bind (Aws.Xml.member "statusMessage" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status_message (fun f ->
               Aws.Query.Pair ("StatusMessage", String.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", NetworkInterfacePermissionStateCode.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status_message (fun f ->
               "statusMessage", String.to_json f)
         ; Aws.Util.option_map v.state (fun f ->
               "state", NetworkInterfacePermissionStateCode.to_json f)
         ])

  let of_json j =
    { state =
        Aws.Util.option_map
          (Aws.Json.lookup j "state")
          NetworkInterfacePermissionStateCode.of_json
    ; status_message =
        Aws.Util.option_map (Aws.Json.lookup j "statusMessage") String.of_json
    }
end

module NetworkInterfacePermission = struct
  type t =
    { network_interface_permission_id : String.t option
    ; network_interface_id : String.t option
    ; aws_account_id : String.t option
    ; aws_service : String.t option
    ; permission : InterfacePermissionType.t option
    ; permission_state : NetworkInterfacePermissionState.t option
    }

  let make
      ?network_interface_permission_id
      ?network_interface_id
      ?aws_account_id
      ?aws_service
      ?permission
      ?permission_state
      () =
    { network_interface_permission_id
    ; network_interface_id
    ; aws_account_id
    ; aws_service
    ; permission
    ; permission_state
    }

  let parse xml =
    Some
      { network_interface_permission_id =
          Aws.Util.option_bind
            (Aws.Xml.member "networkInterfacePermissionId" xml)
            String.parse
      ; network_interface_id =
          Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse
      ; aws_account_id =
          Aws.Util.option_bind (Aws.Xml.member "awsAccountId" xml) String.parse
      ; aws_service = Aws.Util.option_bind (Aws.Xml.member "awsService" xml) String.parse
      ; permission =
          Aws.Util.option_bind
            (Aws.Xml.member "permission" xml)
            InterfacePermissionType.parse
      ; permission_state =
          Aws.Util.option_bind
            (Aws.Xml.member "permissionState" xml)
            NetworkInterfacePermissionState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.permission_state (fun f ->
               Aws.Query.Pair
                 ("PermissionState", NetworkInterfacePermissionState.to_query f))
         ; Aws.Util.option_map v.permission (fun f ->
               Aws.Query.Pair ("Permission", InterfacePermissionType.to_query f))
         ; Aws.Util.option_map v.aws_service (fun f ->
               Aws.Query.Pair ("AwsService", String.to_query f))
         ; Aws.Util.option_map v.aws_account_id (fun f ->
               Aws.Query.Pair ("AwsAccountId", String.to_query f))
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               Aws.Query.Pair ("NetworkInterfaceId", String.to_query f))
         ; Aws.Util.option_map v.network_interface_permission_id (fun f ->
               Aws.Query.Pair ("NetworkInterfacePermissionId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.permission_state (fun f ->
               "permissionState", NetworkInterfacePermissionState.to_json f)
         ; Aws.Util.option_map v.permission (fun f ->
               "permission", InterfacePermissionType.to_json f)
         ; Aws.Util.option_map v.aws_service (fun f -> "awsService", String.to_json f)
         ; Aws.Util.option_map v.aws_account_id (fun f ->
               "awsAccountId", String.to_json f)
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               "networkInterfaceId", String.to_json f)
         ; Aws.Util.option_map v.network_interface_permission_id (fun f ->
               "networkInterfacePermissionId", String.to_json f)
         ])

  let of_json j =
    { network_interface_permission_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "networkInterfacePermissionId")
          String.of_json
    ; network_interface_id =
        Aws.Util.option_map (Aws.Json.lookup j "networkInterfaceId") String.of_json
    ; aws_account_id =
        Aws.Util.option_map (Aws.Json.lookup j "awsAccountId") String.of_json
    ; aws_service = Aws.Util.option_map (Aws.Json.lookup j "awsService") String.of_json
    ; permission =
        Aws.Util.option_map
          (Aws.Json.lookup j "permission")
          InterfacePermissionType.of_json
    ; permission_state =
        Aws.Util.option_map
          (Aws.Json.lookup j "permissionState")
          NetworkInterfacePermissionState.of_json
    }
end

module CreateNetworkInterfacePermissionResult = struct
  type t = { interface_permission : NetworkInterfacePermission.t option }

  let make ?interface_permission () = { interface_permission }

  let parse xml =
    Some
      { interface_permission =
          Aws.Util.option_bind
            (Aws.Xml.member "interfacePermission" xml)
            NetworkInterfacePermission.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.interface_permission (fun f ->
               Aws.Query.Pair
                 ("InterfacePermission", NetworkInterfacePermission.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.interface_permission (fun f ->
               "interfacePermission", NetworkInterfacePermission.to_json f)
         ])

  let of_json j =
    { interface_permission =
        Aws.Util.option_map
          (Aws.Json.lookup j "interfacePermission")
          NetworkInterfacePermission.of_json
    }
end

module GetTransitGatewayRouteTablePropagationsRequest = struct
  type t =
    { transit_gateway_route_table_id : String.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make
      ~transit_gateway_route_table_id
      ?(filters = [])
      ?max_results
      ?next_token
      ?dry_run
      () =
    { transit_gateway_route_table_id; filters; max_results; next_token; dry_run }

  let parse xml =
    Some
      { transit_gateway_route_table_id =
          Aws.Xml.required
            "TransitGatewayRouteTableId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayRouteTableId" xml)
               String.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayRouteTableId"
                , String.to_query v.transit_gateway_route_table_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some
             ( "TransitGatewayRouteTableId"
             , String.to_json v.transit_gateway_route_table_id )
         ])

  let of_json j =
    { transit_gateway_route_table_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayRouteTableId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module NatGatewayIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module VpcPeeringConnectionStateReason = struct
  type t =
    { code : VpcPeeringConnectionStateReasonCode.t option
    ; message : String.t option
    }

  let make ?code ?message () = { code; message }

  let parse xml =
    Some
      { code =
          Aws.Util.option_bind
            (Aws.Xml.member "code" xml)
            VpcPeeringConnectionStateReasonCode.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair ("Code", VpcPeeringConnectionStateReasonCode.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f)
         ; Aws.Util.option_map v.code (fun f ->
               "code", VpcPeeringConnectionStateReasonCode.to_json f)
         ])

  let of_json j =
    { code =
        Aws.Util.option_map
          (Aws.Json.lookup j "code")
          VpcPeeringConnectionStateReasonCode.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json
    }
end

module VpcPeeringConnection = struct
  type t =
    { accepter_vpc_info : VpcPeeringConnectionVpcInfo.t option
    ; expiration_time : DateTime.t option
    ; requester_vpc_info : VpcPeeringConnectionVpcInfo.t option
    ; status : VpcPeeringConnectionStateReason.t option
    ; tags : TagList.t
    ; vpc_peering_connection_id : String.t option
    }

  let make
      ?accepter_vpc_info
      ?expiration_time
      ?requester_vpc_info
      ?status
      ?(tags = [])
      ?vpc_peering_connection_id
      () =
    { accepter_vpc_info
    ; expiration_time
    ; requester_vpc_info
    ; status
    ; tags
    ; vpc_peering_connection_id
    }

  let parse xml =
    Some
      { accepter_vpc_info =
          Aws.Util.option_bind
            (Aws.Xml.member "accepterVpcInfo" xml)
            VpcPeeringConnectionVpcInfo.parse
      ; expiration_time =
          Aws.Util.option_bind (Aws.Xml.member "expirationTime" xml) DateTime.parse
      ; requester_vpc_info =
          Aws.Util.option_bind
            (Aws.Xml.member "requesterVpcInfo" xml)
            VpcPeeringConnectionVpcInfo.parse
      ; status =
          Aws.Util.option_bind
            (Aws.Xml.member "status" xml)
            VpcPeeringConnectionStateReason.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      ; vpc_peering_connection_id =
          Aws.Util.option_bind (Aws.Xml.member "vpcPeeringConnectionId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_peering_connection_id (fun f ->
               Aws.Query.Pair ("VpcPeeringConnectionId", String.to_query f))
         ; Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", VpcPeeringConnectionStateReason.to_query f))
         ; Aws.Util.option_map v.requester_vpc_info (fun f ->
               Aws.Query.Pair ("RequesterVpcInfo", VpcPeeringConnectionVpcInfo.to_query f))
         ; Aws.Util.option_map v.expiration_time (fun f ->
               Aws.Query.Pair ("ExpirationTime", DateTime.to_query f))
         ; Aws.Util.option_map v.accepter_vpc_info (fun f ->
               Aws.Query.Pair ("AccepterVpcInfo", VpcPeeringConnectionVpcInfo.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_peering_connection_id (fun f ->
               "vpcPeeringConnectionId", String.to_json f)
         ; Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.status (fun f ->
               "status", VpcPeeringConnectionStateReason.to_json f)
         ; Aws.Util.option_map v.requester_vpc_info (fun f ->
               "requesterVpcInfo", VpcPeeringConnectionVpcInfo.to_json f)
         ; Aws.Util.option_map v.expiration_time (fun f ->
               "expirationTime", DateTime.to_json f)
         ; Aws.Util.option_map v.accepter_vpc_info (fun f ->
               "accepterVpcInfo", VpcPeeringConnectionVpcInfo.to_json f)
         ])

  let of_json j =
    { accepter_vpc_info =
        Aws.Util.option_map
          (Aws.Json.lookup j "accepterVpcInfo")
          VpcPeeringConnectionVpcInfo.of_json
    ; expiration_time =
        Aws.Util.option_map (Aws.Json.lookup j "expirationTime") DateTime.of_json
    ; requester_vpc_info =
        Aws.Util.option_map
          (Aws.Json.lookup j "requesterVpcInfo")
          VpcPeeringConnectionVpcInfo.of_json
    ; status =
        Aws.Util.option_map
          (Aws.Json.lookup j "status")
          VpcPeeringConnectionStateReason.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    ; vpc_peering_connection_id =
        Aws.Util.option_map (Aws.Json.lookup j "vpcPeeringConnectionId") String.of_json
    }
end

module AcceptVpcPeeringConnectionResult = struct
  type t = { vpc_peering_connection : VpcPeeringConnection.t option }

  let make ?vpc_peering_connection () = { vpc_peering_connection }

  let parse xml =
    Some
      { vpc_peering_connection =
          Aws.Util.option_bind
            (Aws.Xml.member "vpcPeeringConnection" xml)
            VpcPeeringConnection.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_peering_connection (fun f ->
               Aws.Query.Pair ("VpcPeeringConnection", VpcPeeringConnection.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_peering_connection (fun f ->
               "vpcPeeringConnection", VpcPeeringConnection.to_json f)
         ])

  let of_json j =
    { vpc_peering_connection =
        Aws.Util.option_map
          (Aws.Json.lookup j "vpcPeeringConnection")
          VpcPeeringConnection.of_json
    }
end

module DescribeFastSnapshotRestoresRequest = struct
  type t =
    { filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make ?(filters = []) ?max_results ?next_token ?dry_run () =
    { filters; max_results; next_token; dry_run }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module PeeringConnectionOptions = struct
  type t =
    { allow_dns_resolution_from_remote_vpc : Boolean.t option
    ; allow_egress_from_local_classic_link_to_remote_vpc : Boolean.t option
    ; allow_egress_from_local_vpc_to_remote_classic_link : Boolean.t option
    }

  let make
      ?allow_dns_resolution_from_remote_vpc
      ?allow_egress_from_local_classic_link_to_remote_vpc
      ?allow_egress_from_local_vpc_to_remote_classic_link
      () =
    { allow_dns_resolution_from_remote_vpc
    ; allow_egress_from_local_classic_link_to_remote_vpc
    ; allow_egress_from_local_vpc_to_remote_classic_link
    }

  let parse xml =
    Some
      { allow_dns_resolution_from_remote_vpc =
          Aws.Util.option_bind
            (Aws.Xml.member "allowDnsResolutionFromRemoteVpc" xml)
            Boolean.parse
      ; allow_egress_from_local_classic_link_to_remote_vpc =
          Aws.Util.option_bind
            (Aws.Xml.member "allowEgressFromLocalClassicLinkToRemoteVpc" xml)
            Boolean.parse
      ; allow_egress_from_local_vpc_to_remote_classic_link =
          Aws.Util.option_bind
            (Aws.Xml.member "allowEgressFromLocalVpcToRemoteClassicLink" xml)
            Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map
             v.allow_egress_from_local_vpc_to_remote_classic_link
             (fun f ->
               Aws.Query.Pair
                 ("AllowEgressFromLocalVpcToRemoteClassicLink", Boolean.to_query f))
         ; Aws.Util.option_map
             v.allow_egress_from_local_classic_link_to_remote_vpc
             (fun f ->
               Aws.Query.Pair
                 ("AllowEgressFromLocalClassicLinkToRemoteVpc", Boolean.to_query f))
         ; Aws.Util.option_map v.allow_dns_resolution_from_remote_vpc (fun f ->
               Aws.Query.Pair ("AllowDnsResolutionFromRemoteVpc", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map
             v.allow_egress_from_local_vpc_to_remote_classic_link
             (fun f -> "allowEgressFromLocalVpcToRemoteClassicLink", Boolean.to_json f)
         ; Aws.Util.option_map
             v.allow_egress_from_local_classic_link_to_remote_vpc
             (fun f -> "allowEgressFromLocalClassicLinkToRemoteVpc", Boolean.to_json f)
         ; Aws.Util.option_map v.allow_dns_resolution_from_remote_vpc (fun f ->
               "allowDnsResolutionFromRemoteVpc", Boolean.to_json f)
         ])

  let of_json j =
    { allow_dns_resolution_from_remote_vpc =
        Aws.Util.option_map
          (Aws.Json.lookup j "allowDnsResolutionFromRemoteVpc")
          Boolean.of_json
    ; allow_egress_from_local_classic_link_to_remote_vpc =
        Aws.Util.option_map
          (Aws.Json.lookup j "allowEgressFromLocalClassicLinkToRemoteVpc")
          Boolean.of_json
    ; allow_egress_from_local_vpc_to_remote_classic_link =
        Aws.Util.option_map
          (Aws.Json.lookup j "allowEgressFromLocalVpcToRemoteClassicLink")
          Boolean.of_json
    }
end

module StatusType = struct
  type t =
    | Passed
    | Failed
    | Insufficient_data
    | Initializing

  let str_to_t =
    [ "initializing", Initializing
    ; "insufficient-data", Insufficient_data
    ; "failed", Failed
    ; "passed", Passed
    ]

  let t_to_str =
    [ Initializing, "initializing"
    ; Insufficient_data, "insufficient-data"
    ; Failed, "failed"
    ; Passed, "passed"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module StatusName = struct
  type t = Reachability

  let str_to_t = [ "reachability", Reachability ]

  let t_to_str = [ Reachability, "reachability" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module InstanceStatusDetails = struct
  type t =
    { impaired_since : DateTime.t option
    ; name : StatusName.t option
    ; status : StatusType.t option
    }

  let make ?impaired_since ?name ?status () = { impaired_since; name; status }

  let parse xml =
    Some
      { impaired_since =
          Aws.Util.option_bind (Aws.Xml.member "impairedSince" xml) DateTime.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "name" xml) StatusName.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "status" xml) StatusType.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", StatusType.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", StatusName.to_query f))
         ; Aws.Util.option_map v.impaired_since (fun f ->
               Aws.Query.Pair ("ImpairedSince", DateTime.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f -> "status", StatusType.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "name", StatusName.to_json f)
         ; Aws.Util.option_map v.impaired_since (fun f ->
               "impairedSince", DateTime.to_json f)
         ])

  let of_json j =
    { impaired_since =
        Aws.Util.option_map (Aws.Json.lookup j "impairedSince") DateTime.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "name") StatusName.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "status") StatusType.of_json
    }
end

module InstanceStatusDetailsList = struct
  type t = InstanceStatusDetails.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map InstanceStatusDetails.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list InstanceStatusDetails.to_query v

  let to_json v = `List (List.map InstanceStatusDetails.to_json v)

  let of_json j = Aws.Json.to_list InstanceStatusDetails.of_json j
end

module VpcEndpointSubnetIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module GetManagedPrefixListAssociationsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; prefix_list_id : String.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?dry_run ~prefix_list_id ?max_results ?next_token () =
    { dry_run; prefix_list_id; max_results; next_token }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; prefix_list_id =
          Aws.Xml.required
            "PrefixListId"
            (Aws.Util.option_bind (Aws.Xml.member "PrefixListId" xml) String.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("PrefixListId", String.to_query v.prefix_list_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("PrefixListId", String.to_json v.prefix_list_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; prefix_list_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PrefixListId"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module DeleteFpgaImageRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; fpga_image_id : String.t
    }

  let make ?dry_run ~fpga_image_id () = { dry_run; fpga_image_id }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; fpga_image_id =
          Aws.Xml.required
            "FpgaImageId"
            (Aws.Util.option_bind (Aws.Xml.member "FpgaImageId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("FpgaImageId", String.to_query v.fpga_image_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("FpgaImageId", String.to_json v.fpga_image_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; fpga_image_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "FpgaImageId"))
    }
end

module LoadPermission = struct
  type t =
    { user_id : String.t option
    ; group : PermissionGroup.t option
    }

  let make ?user_id ?group () = { user_id; group }

  let parse xml =
    Some
      { user_id = Aws.Util.option_bind (Aws.Xml.member "userId" xml) String.parse
      ; group = Aws.Util.option_bind (Aws.Xml.member "group" xml) PermissionGroup.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.group (fun f ->
               Aws.Query.Pair ("Group", PermissionGroup.to_query f))
         ; Aws.Util.option_map v.user_id (fun f ->
               Aws.Query.Pair ("UserId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.group (fun f -> "group", PermissionGroup.to_json f)
         ; Aws.Util.option_map v.user_id (fun f -> "userId", String.to_json f)
         ])

  let of_json j =
    { user_id = Aws.Util.option_map (Aws.Json.lookup j "userId") String.of_json
    ; group = Aws.Util.option_map (Aws.Json.lookup j "group") PermissionGroup.of_json
    }
end

module LoadPermissionList = struct
  type t = LoadPermission.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map LoadPermission.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list LoadPermission.to_query v

  let to_json v = `List (List.map LoadPermission.to_json v)

  let of_json j = Aws.Json.to_list LoadPermission.of_json j
end

module FpgaImageAttribute = struct
  type t =
    { fpga_image_id : String.t option
    ; name : String.t option
    ; description : String.t option
    ; load_permissions : LoadPermissionList.t
    ; product_codes : ProductCodeList.t
    }

  let make
      ?fpga_image_id
      ?name
      ?description
      ?(load_permissions = [])
      ?(product_codes = [])
      () =
    { fpga_image_id; name; description; load_permissions; product_codes }

  let parse xml =
    Some
      { fpga_image_id =
          Aws.Util.option_bind (Aws.Xml.member "fpgaImageId" xml) String.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "name" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; load_permissions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "loadPermissions" xml)
               LoadPermissionList.parse)
      ; product_codes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "productCodes" xml)
               ProductCodeList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("ProductCodes", ProductCodeList.to_query v.product_codes))
         ; Some
             (Aws.Query.Pair
                ("LoadPermissions", LoadPermissionList.to_query v.load_permissions))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.fpga_image_id (fun f ->
               Aws.Query.Pair ("FpgaImageId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("productCodes", ProductCodeList.to_json v.product_codes)
         ; Some ("loadPermissions", LoadPermissionList.to_json v.load_permissions)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "name", String.to_json f)
         ; Aws.Util.option_map v.fpga_image_id (fun f -> "fpgaImageId", String.to_json f)
         ])

  let of_json j =
    { fpga_image_id = Aws.Util.option_map (Aws.Json.lookup j "fpgaImageId") String.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "name") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; load_permissions =
        LoadPermissionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "loadPermissions"))
    ; product_codes =
        ProductCodeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "productCodes"))
    }
end

module ModifyFpgaImageAttributeResult = struct
  type t = { fpga_image_attribute : FpgaImageAttribute.t option }

  let make ?fpga_image_attribute () = { fpga_image_attribute }

  let parse xml =
    Some
      { fpga_image_attribute =
          Aws.Util.option_bind
            (Aws.Xml.member "fpgaImageAttribute" xml)
            FpgaImageAttribute.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.fpga_image_attribute (fun f ->
               Aws.Query.Pair ("FpgaImageAttribute", FpgaImageAttribute.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.fpga_image_attribute (fun f ->
               "fpgaImageAttribute", FpgaImageAttribute.to_json f)
         ])

  let of_json j =
    { fpga_image_attribute =
        Aws.Util.option_map
          (Aws.Json.lookup j "fpgaImageAttribute")
          FpgaImageAttribute.of_json
    }
end

module Address = struct
  type t =
    { instance_id : String.t option
    ; public_ip : String.t option
    ; allocation_id : String.t option
    ; association_id : String.t option
    ; domain : DomainType.t option
    ; network_interface_id : String.t option
    ; network_interface_owner_id : String.t option
    ; private_ip_address : String.t option
    ; tags : TagList.t
    ; public_ipv4_pool : String.t option
    ; network_border_group : String.t option
    ; customer_owned_ip : String.t option
    ; customer_owned_ipv4_pool : String.t option
    ; carrier_ip : String.t option
    }

  let make
      ?instance_id
      ?public_ip
      ?allocation_id
      ?association_id
      ?domain
      ?network_interface_id
      ?network_interface_owner_id
      ?private_ip_address
      ?(tags = [])
      ?public_ipv4_pool
      ?network_border_group
      ?customer_owned_ip
      ?customer_owned_ipv4_pool
      ?carrier_ip
      () =
    { instance_id
    ; public_ip
    ; allocation_id
    ; association_id
    ; domain
    ; network_interface_id
    ; network_interface_owner_id
    ; private_ip_address
    ; tags
    ; public_ipv4_pool
    ; network_border_group
    ; customer_owned_ip
    ; customer_owned_ipv4_pool
    ; carrier_ip
    }

  let parse xml =
    Some
      { instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      ; public_ip = Aws.Util.option_bind (Aws.Xml.member "publicIp" xml) String.parse
      ; allocation_id =
          Aws.Util.option_bind (Aws.Xml.member "allocationId" xml) String.parse
      ; association_id =
          Aws.Util.option_bind (Aws.Xml.member "associationId" xml) String.parse
      ; domain = Aws.Util.option_bind (Aws.Xml.member "domain" xml) DomainType.parse
      ; network_interface_id =
          Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse
      ; network_interface_owner_id =
          Aws.Util.option_bind (Aws.Xml.member "networkInterfaceOwnerId" xml) String.parse
      ; private_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "privateIpAddress" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      ; public_ipv4_pool =
          Aws.Util.option_bind (Aws.Xml.member "publicIpv4Pool" xml) String.parse
      ; network_border_group =
          Aws.Util.option_bind (Aws.Xml.member "networkBorderGroup" xml) String.parse
      ; customer_owned_ip =
          Aws.Util.option_bind (Aws.Xml.member "customerOwnedIp" xml) String.parse
      ; customer_owned_ipv4_pool =
          Aws.Util.option_bind (Aws.Xml.member "customerOwnedIpv4Pool" xml) String.parse
      ; carrier_ip = Aws.Util.option_bind (Aws.Xml.member "carrierIp" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.carrier_ip (fun f ->
               Aws.Query.Pair ("CarrierIp", String.to_query f))
         ; Aws.Util.option_map v.customer_owned_ipv4_pool (fun f ->
               Aws.Query.Pair ("CustomerOwnedIpv4Pool", String.to_query f))
         ; Aws.Util.option_map v.customer_owned_ip (fun f ->
               Aws.Query.Pair ("CustomerOwnedIp", String.to_query f))
         ; Aws.Util.option_map v.network_border_group (fun f ->
               Aws.Query.Pair ("NetworkBorderGroup", String.to_query f))
         ; Aws.Util.option_map v.public_ipv4_pool (fun f ->
               Aws.Query.Pair ("PublicIpv4Pool", String.to_query f))
         ; Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.private_ip_address (fun f ->
               Aws.Query.Pair ("PrivateIpAddress", String.to_query f))
         ; Aws.Util.option_map v.network_interface_owner_id (fun f ->
               Aws.Query.Pair ("NetworkInterfaceOwnerId", String.to_query f))
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               Aws.Query.Pair ("NetworkInterfaceId", String.to_query f))
         ; Aws.Util.option_map v.domain (fun f ->
               Aws.Query.Pair ("Domain", DomainType.to_query f))
         ; Aws.Util.option_map v.association_id (fun f ->
               Aws.Query.Pair ("AssociationId", String.to_query f))
         ; Aws.Util.option_map v.allocation_id (fun f ->
               Aws.Query.Pair ("AllocationId", String.to_query f))
         ; Aws.Util.option_map v.public_ip (fun f ->
               Aws.Query.Pair ("PublicIp", String.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.carrier_ip (fun f -> "carrierIp", String.to_json f)
         ; Aws.Util.option_map v.customer_owned_ipv4_pool (fun f ->
               "customerOwnedIpv4Pool", String.to_json f)
         ; Aws.Util.option_map v.customer_owned_ip (fun f ->
               "customerOwnedIp", String.to_json f)
         ; Aws.Util.option_map v.network_border_group (fun f ->
               "networkBorderGroup", String.to_json f)
         ; Aws.Util.option_map v.public_ipv4_pool (fun f ->
               "publicIpv4Pool", String.to_json f)
         ; Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.private_ip_address (fun f ->
               "privateIpAddress", String.to_json f)
         ; Aws.Util.option_map v.network_interface_owner_id (fun f ->
               "networkInterfaceOwnerId", String.to_json f)
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               "networkInterfaceId", String.to_json f)
         ; Aws.Util.option_map v.domain (fun f -> "domain", DomainType.to_json f)
         ; Aws.Util.option_map v.association_id (fun f ->
               "associationId", String.to_json f)
         ; Aws.Util.option_map v.allocation_id (fun f -> "allocationId", String.to_json f)
         ; Aws.Util.option_map v.public_ip (fun f -> "publicIp", String.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ])

  let of_json j =
    { instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    ; public_ip = Aws.Util.option_map (Aws.Json.lookup j "publicIp") String.of_json
    ; allocation_id =
        Aws.Util.option_map (Aws.Json.lookup j "allocationId") String.of_json
    ; association_id =
        Aws.Util.option_map (Aws.Json.lookup j "associationId") String.of_json
    ; domain = Aws.Util.option_map (Aws.Json.lookup j "domain") DomainType.of_json
    ; network_interface_id =
        Aws.Util.option_map (Aws.Json.lookup j "networkInterfaceId") String.of_json
    ; network_interface_owner_id =
        Aws.Util.option_map (Aws.Json.lookup j "networkInterfaceOwnerId") String.of_json
    ; private_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "privateIpAddress") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    ; public_ipv4_pool =
        Aws.Util.option_map (Aws.Json.lookup j "publicIpv4Pool") String.of_json
    ; network_border_group =
        Aws.Util.option_map (Aws.Json.lookup j "networkBorderGroup") String.of_json
    ; customer_owned_ip =
        Aws.Util.option_map (Aws.Json.lookup j "customerOwnedIp") String.of_json
    ; customer_owned_ipv4_pool =
        Aws.Util.option_map (Aws.Json.lookup j "customerOwnedIpv4Pool") String.of_json
    ; carrier_ip = Aws.Util.option_map (Aws.Json.lookup j "carrierIp") String.of_json
    }
end

module AddressList = struct
  type t = Address.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Address.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Address.to_query v

  let to_json v = `List (List.map Address.to_json v)

  let of_json j = Aws.Json.to_list Address.of_json j
end

module ResourceList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module ModifyTransitGatewayVpcAttachmentResult = struct
  type t = { transit_gateway_vpc_attachment : TransitGatewayVpcAttachment.t option }

  let make ?transit_gateway_vpc_attachment () = { transit_gateway_vpc_attachment }

  let parse xml =
    Some
      { transit_gateway_vpc_attachment =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayVpcAttachment" xml)
            TransitGatewayVpcAttachment.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_vpc_attachment (fun f ->
               Aws.Query.Pair
                 ("TransitGatewayVpcAttachment", TransitGatewayVpcAttachment.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_vpc_attachment (fun f ->
               "transitGatewayVpcAttachment", TransitGatewayVpcAttachment.to_json f)
         ])

  let of_json j =
    { transit_gateway_vpc_attachment =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayVpcAttachment")
          TransitGatewayVpcAttachment.of_json
    }
end

module DescribeSpotInstanceRequestsResult = struct
  type t =
    { spot_instance_requests : SpotInstanceRequestList.t
    ; next_token : String.t option
    }

  let make ?(spot_instance_requests = []) ?next_token () =
    { spot_instance_requests; next_token }

  let parse xml =
    Some
      { spot_instance_requests =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "spotInstanceRequestSet" xml)
               SpotInstanceRequestList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "SpotInstanceRequestSet"
                , SpotInstanceRequestList.to_query v.spot_instance_requests ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "spotInstanceRequestSet"
             , SpotInstanceRequestList.to_json v.spot_instance_requests )
         ])

  let of_json j =
    { spot_instance_requests =
        SpotInstanceRequestList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "spotInstanceRequestSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DescribeEgressOnlyInternetGatewaysRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; egress_only_internet_gateway_ids : EgressOnlyInternetGatewayIdList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; filters : FilterList.t
    }

  let make
      ?dry_run
      ?(egress_only_internet_gateway_ids = [])
      ?max_results
      ?next_token
      ?(filters = [])
      () =
    { dry_run; egress_only_internet_gateway_ids; max_results; next_token; filters }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; egress_only_internet_gateway_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "EgressOnlyInternetGatewayId" xml)
               EgressOnlyInternetGatewayIdList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "EgressOnlyInternetGatewayId"
                , EgressOnlyInternetGatewayIdList.to_query
                    v.egress_only_internet_gateway_ids ))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Filter", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some
             ( "EgressOnlyInternetGatewayId"
             , EgressOnlyInternetGatewayIdList.to_json v.egress_only_internet_gateway_ids
             )
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; egress_only_internet_gateway_ids =
        EgressOnlyInternetGatewayIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "EgressOnlyInternetGatewayId"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    }
end

module DescribeNatGatewaysRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; filter : FilterList.t
    ; max_results : Integer.t option
    ; nat_gateway_ids : NatGatewayIdStringList.t
    ; next_token : String.t option
    }

  let make ?dry_run ?(filter = []) ?max_results ?(nat_gateway_ids = []) ?next_token () =
    { dry_run; filter; max_results; nat_gateway_ids; next_token }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; filter =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; nat_gateway_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "NatGatewayId" xml)
               NatGatewayIdStringList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("NatGatewayId", NatGatewayIdStringList.to_query v.nat_gateway_ids))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filter))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("NatGatewayId", NatGatewayIdStringList.to_json v.nat_gateway_ids)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filter)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; filter = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; nat_gateway_ids =
        NatGatewayIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "NatGatewayId"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module Affinity = struct
  type t =
    | Default
    | Host

  let str_to_t = [ "host", Host; "default", Default ]

  let t_to_str = [ Host, "host"; Default, "default" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ModifyInstancePlacementRequest = struct
  type t =
    { affinity : Affinity.t option
    ; group_name : String.t option
    ; host_id : String.t option
    ; instance_id : String.t
    ; tenancy : HostTenancy.t option
    ; partition_number : Integer.t option
    ; host_resource_group_arn : String.t option
    }

  let make
      ?affinity
      ?group_name
      ?host_id
      ~instance_id
      ?tenancy
      ?partition_number
      ?host_resource_group_arn
      () =
    { affinity
    ; group_name
    ; host_id
    ; instance_id
    ; tenancy
    ; partition_number
    ; host_resource_group_arn
    }

  let parse xml =
    Some
      { affinity = Aws.Util.option_bind (Aws.Xml.member "affinity" xml) Affinity.parse
      ; group_name = Aws.Util.option_bind (Aws.Xml.member "GroupName" xml) String.parse
      ; host_id = Aws.Util.option_bind (Aws.Xml.member "hostId" xml) String.parse
      ; instance_id =
          Aws.Xml.required
            "instanceId"
            (Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse)
      ; tenancy = Aws.Util.option_bind (Aws.Xml.member "tenancy" xml) HostTenancy.parse
      ; partition_number =
          Aws.Util.option_bind (Aws.Xml.member "PartitionNumber" xml) Integer.parse
      ; host_resource_group_arn =
          Aws.Util.option_bind (Aws.Xml.member "HostResourceGroupArn" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.host_resource_group_arn (fun f ->
               Aws.Query.Pair ("HostResourceGroupArn", String.to_query f))
         ; Aws.Util.option_map v.partition_number (fun f ->
               Aws.Query.Pair ("PartitionNumber", Integer.to_query f))
         ; Aws.Util.option_map v.tenancy (fun f ->
               Aws.Query.Pair ("Tenancy", HostTenancy.to_query f))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ; Aws.Util.option_map v.host_id (fun f ->
               Aws.Query.Pair ("HostId", String.to_query f))
         ; Aws.Util.option_map v.group_name (fun f ->
               Aws.Query.Pair ("GroupName", String.to_query f))
         ; Aws.Util.option_map v.affinity (fun f ->
               Aws.Query.Pair ("Affinity", Affinity.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.host_resource_group_arn (fun f ->
               "HostResourceGroupArn", String.to_json f)
         ; Aws.Util.option_map v.partition_number (fun f ->
               "PartitionNumber", Integer.to_json f)
         ; Aws.Util.option_map v.tenancy (fun f -> "tenancy", HostTenancy.to_json f)
         ; Some ("instanceId", String.to_json v.instance_id)
         ; Aws.Util.option_map v.host_id (fun f -> "hostId", String.to_json f)
         ; Aws.Util.option_map v.group_name (fun f -> "GroupName", String.to_json f)
         ; Aws.Util.option_map v.affinity (fun f -> "affinity", Affinity.to_json f)
         ])

  let of_json j =
    { affinity = Aws.Util.option_map (Aws.Json.lookup j "affinity") Affinity.of_json
    ; group_name = Aws.Util.option_map (Aws.Json.lookup j "GroupName") String.of_json
    ; host_id = Aws.Util.option_map (Aws.Json.lookup j "hostId") String.of_json
    ; instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceId"))
    ; tenancy = Aws.Util.option_map (Aws.Json.lookup j "tenancy") HostTenancy.of_json
    ; partition_number =
        Aws.Util.option_map (Aws.Json.lookup j "PartitionNumber") Integer.of_json
    ; host_resource_group_arn =
        Aws.Util.option_map (Aws.Json.lookup j "HostResourceGroupArn") String.of_json
    }
end

module EnclaveOptionsRequest = struct
  type t = { enabled : Boolean.t option }

  let make ?enabled () = { enabled }

  let parse xml =
    Some { enabled = Aws.Util.option_bind (Aws.Xml.member "Enabled" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enabled (fun f ->
               Aws.Query.Pair ("Enabled", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enabled (fun f -> "Enabled", Boolean.to_json f) ])

  let of_json j =
    { enabled = Aws.Util.option_map (Aws.Json.lookup j "Enabled") Boolean.of_json }
end

module TransitGatewayIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeTransitGatewaysRequest = struct
  type t =
    { transit_gateway_ids : TransitGatewayIdStringList.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make
      ?(transit_gateway_ids = [])
      ?(filters = [])
      ?max_results
      ?next_token
      ?dry_run
      () =
    { transit_gateway_ids; filters; max_results; next_token; dry_run }

  let parse xml =
    Some
      { transit_gateway_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayIds" xml)
               TransitGatewayIdStringList.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayIds"
                , TransitGatewayIdStringList.to_query v.transit_gateway_ids ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some
             ( "TransitGatewayIds"
             , TransitGatewayIdStringList.to_json v.transit_gateway_ids )
         ])

  let of_json j =
    { transit_gateway_ids =
        TransitGatewayIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayIds"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DescribeHostReservationOfferingsResult = struct
  type t =
    { next_token : String.t option
    ; offering_set : HostOfferingSet.t
    }

  let make ?next_token ?(offering_set = []) () = { next_token; offering_set }

  let parse xml =
    Some
      { next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; offering_set =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "offeringSet" xml)
               HostOfferingSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("OfferingSet", HostOfferingSet.to_query v.offering_set))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("offeringSet", HostOfferingSet.to_json v.offering_set)
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ])

  let of_json j =
    { next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; offering_set =
        HostOfferingSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "offeringSet"))
    }
end

module GetAssociatedEnclaveCertificateIamRolesRequest = struct
  type t =
    { certificate_arn : String.t option
    ; dry_run : Boolean.t option
    }

  let make ?certificate_arn ?dry_run () = { certificate_arn; dry_run }

  let parse xml =
    Some
      { certificate_arn =
          Aws.Util.option_bind (Aws.Xml.member "CertificateArn" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.certificate_arn (fun f ->
               Aws.Query.Pair ("CertificateArn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.certificate_arn (fun f ->
               "CertificateArn", String.to_json f)
         ])

  let of_json j =
    { certificate_arn =
        Aws.Util.option_map (Aws.Json.lookup j "CertificateArn") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module ImageIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "ImageId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module VpcPeeringConnectionIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DisassociateEnclaveCertificateIamRoleRequest = struct
  type t =
    { certificate_arn : String.t option
    ; role_arn : String.t option
    ; dry_run : Boolean.t option
    }

  let make ?certificate_arn ?role_arn ?dry_run () = { certificate_arn; role_arn; dry_run }

  let parse xml =
    Some
      { certificate_arn =
          Aws.Util.option_bind (Aws.Xml.member "CertificateArn" xml) String.parse
      ; role_arn = Aws.Util.option_bind (Aws.Xml.member "RoleArn" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.role_arn (fun f ->
               Aws.Query.Pair ("RoleArn", String.to_query f))
         ; Aws.Util.option_map v.certificate_arn (fun f ->
               Aws.Query.Pair ("CertificateArn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.role_arn (fun f -> "RoleArn", String.to_json f)
         ; Aws.Util.option_map v.certificate_arn (fun f ->
               "CertificateArn", String.to_json f)
         ])

  let of_json j =
    { certificate_arn =
        Aws.Util.option_map (Aws.Json.lookup j "CertificateArn") String.of_json
    ; role_arn = Aws.Util.option_map (Aws.Json.lookup j "RoleArn") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module ReplaceIamInstanceProfileAssociationRequest = struct
  type t =
    { iam_instance_profile : IamInstanceProfileSpecification.t
    ; association_id : String.t
    }

  let make ~iam_instance_profile ~association_id () =
    { iam_instance_profile; association_id }

  let parse xml =
    Some
      { iam_instance_profile =
          Aws.Xml.required
            "IamInstanceProfile"
            (Aws.Util.option_bind
               (Aws.Xml.member "IamInstanceProfile" xml)
               IamInstanceProfileSpecification.parse)
      ; association_id =
          Aws.Xml.required
            "AssociationId"
            (Aws.Util.option_bind (Aws.Xml.member "AssociationId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("AssociationId", String.to_query v.association_id))
         ; Some
             (Aws.Query.Pair
                ( "IamInstanceProfile"
                , IamInstanceProfileSpecification.to_query v.iam_instance_profile ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("AssociationId", String.to_json v.association_id)
         ; Some
             ( "IamInstanceProfile"
             , IamInstanceProfileSpecification.to_json v.iam_instance_profile )
         ])

  let of_json j =
    { iam_instance_profile =
        IamInstanceProfileSpecification.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "IamInstanceProfile"))
    ; association_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "AssociationId"))
    }
end

module EventCode = struct
  type t =
    | Instance_reboot
    | System_reboot
    | System_maintenance
    | Instance_retirement
    | Instance_stop

  let str_to_t =
    [ "instance-stop", Instance_stop
    ; "instance-retirement", Instance_retirement
    ; "system-maintenance", System_maintenance
    ; "system-reboot", System_reboot
    ; "instance-reboot", Instance_reboot
    ]

  let t_to_str =
    [ Instance_stop, "instance-stop"
    ; Instance_retirement, "instance-retirement"
    ; System_maintenance, "system-maintenance"
    ; System_reboot, "system-reboot"
    ; Instance_reboot, "instance-reboot"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DeleteSnapshotRequest = struct
  type t =
    { snapshot_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~snapshot_id ?dry_run () = { snapshot_id; dry_run }

  let parse xml =
    Some
      { snapshot_id =
          Aws.Xml.required
            "SnapshotId"
            (Aws.Util.option_bind (Aws.Xml.member "SnapshotId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("SnapshotId", String.to_query v.snapshot_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("SnapshotId", String.to_json v.snapshot_id)
         ])

  let of_json j =
    { snapshot_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SnapshotId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module AllowsMultipleInstanceTypes = struct
  type t =
    | On
    | Off

  let str_to_t = [ "off", Off; "on", On ]

  let t_to_str = [ Off, "off"; On, "on" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ModifyInstanceEventStartTimeRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; instance_id : String.t
    ; instance_event_id : String.t
    ; not_before : DateTime.t
    }

  let make ?dry_run ~instance_id ~instance_event_id ~not_before () =
    { dry_run; instance_id; instance_event_id; not_before }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; instance_id =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse)
      ; instance_event_id =
          Aws.Xml.required
            "InstanceEventId"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceEventId" xml) String.parse)
      ; not_before =
          Aws.Xml.required
            "NotBefore"
            (Aws.Util.option_bind (Aws.Xml.member "NotBefore" xml) DateTime.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("NotBefore", DateTime.to_query v.not_before))
         ; Some (Aws.Query.Pair ("InstanceEventId", String.to_query v.instance_event_id))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("NotBefore", DateTime.to_json v.not_before)
         ; Some ("InstanceEventId", String.to_json v.instance_event_id)
         ; Some ("InstanceId", String.to_json v.instance_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; instance_event_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceEventId"))
    ; not_before =
        DateTime.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "NotBefore"))
    }
end

module GetTransitGatewayRouteTableAssociationsResult = struct
  type t =
    { associations : TransitGatewayRouteTableAssociationList.t
    ; next_token : String.t option
    }

  let make ?(associations = []) ?next_token () = { associations; next_token }

  let parse xml =
    Some
      { associations =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "associations" xml)
               TransitGatewayRouteTableAssociationList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "Associations"
                , TransitGatewayRouteTableAssociationList.to_query v.associations ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "associations"
             , TransitGatewayRouteTableAssociationList.to_json v.associations )
         ])

  let of_json j =
    { associations =
        TransitGatewayRouteTableAssociationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "associations"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module UserIdGroupPairSet = struct
  type t = UserIdGroupPair.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map UserIdGroupPair.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list UserIdGroupPair.to_query v

  let to_json v = `List (List.map UserIdGroupPair.to_json v)

  let of_json j = Aws.Json.to_list UserIdGroupPair.of_json j
end

module PrefixListIdSet = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module StaleIpPermission = struct
  type t =
    { from_port : Integer.t option
    ; ip_protocol : String.t option
    ; ip_ranges : IpRanges.t
    ; prefix_list_ids : PrefixListIdSet.t
    ; to_port : Integer.t option
    ; user_id_group_pairs : UserIdGroupPairSet.t
    }

  let make
      ?from_port
      ?ip_protocol
      ?(ip_ranges = [])
      ?(prefix_list_ids = [])
      ?to_port
      ?(user_id_group_pairs = [])
      () =
    { from_port; ip_protocol; ip_ranges; prefix_list_ids; to_port; user_id_group_pairs }

  let parse xml =
    Some
      { from_port = Aws.Util.option_bind (Aws.Xml.member "fromPort" xml) Integer.parse
      ; ip_protocol = Aws.Util.option_bind (Aws.Xml.member "ipProtocol" xml) String.parse
      ; ip_ranges =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "ipRanges" xml) IpRanges.parse)
      ; prefix_list_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "prefixListIds" xml)
               PrefixListIdSet.parse)
      ; to_port = Aws.Util.option_bind (Aws.Xml.member "toPort" xml) Integer.parse
      ; user_id_group_pairs =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "groups" xml) UserIdGroupPairSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("Groups", UserIdGroupPairSet.to_query v.user_id_group_pairs))
         ; Aws.Util.option_map v.to_port (fun f ->
               Aws.Query.Pair ("ToPort", Integer.to_query f))
         ; Some
             (Aws.Query.Pair ("PrefixListIds", PrefixListIdSet.to_query v.prefix_list_ids))
         ; Some (Aws.Query.Pair ("IpRanges", IpRanges.to_query v.ip_ranges))
         ; Aws.Util.option_map v.ip_protocol (fun f ->
               Aws.Query.Pair ("IpProtocol", String.to_query f))
         ; Aws.Util.option_map v.from_port (fun f ->
               Aws.Query.Pair ("FromPort", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("groups", UserIdGroupPairSet.to_json v.user_id_group_pairs)
         ; Aws.Util.option_map v.to_port (fun f -> "toPort", Integer.to_json f)
         ; Some ("prefixListIds", PrefixListIdSet.to_json v.prefix_list_ids)
         ; Some ("ipRanges", IpRanges.to_json v.ip_ranges)
         ; Aws.Util.option_map v.ip_protocol (fun f -> "ipProtocol", String.to_json f)
         ; Aws.Util.option_map v.from_port (fun f -> "fromPort", Integer.to_json f)
         ])

  let of_json j =
    { from_port = Aws.Util.option_map (Aws.Json.lookup j "fromPort") Integer.of_json
    ; ip_protocol = Aws.Util.option_map (Aws.Json.lookup j "ipProtocol") String.of_json
    ; ip_ranges = IpRanges.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ipRanges"))
    ; prefix_list_ids =
        PrefixListIdSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "prefixListIds"))
    ; to_port = Aws.Util.option_map (Aws.Json.lookup j "toPort") Integer.of_json
    ; user_id_group_pairs =
        UserIdGroupPairSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "groups"))
    }
end

module StaleIpPermissionSet = struct
  type t = StaleIpPermission.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map StaleIpPermission.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list StaleIpPermission.to_query v

  let to_json v = `List (List.map StaleIpPermission.to_json v)

  let of_json j = Aws.Json.to_list StaleIpPermission.of_json j
end

module StaleSecurityGroup = struct
  type t =
    { description : String.t option
    ; group_id : String.t option
    ; group_name : String.t option
    ; stale_ip_permissions : StaleIpPermissionSet.t
    ; stale_ip_permissions_egress : StaleIpPermissionSet.t
    ; vpc_id : String.t option
    }

  let make
      ?description
      ?group_id
      ?group_name
      ?(stale_ip_permissions = [])
      ?(stale_ip_permissions_egress = [])
      ?vpc_id
      () =
    { description
    ; group_id
    ; group_name
    ; stale_ip_permissions
    ; stale_ip_permissions_egress
    ; vpc_id
    }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; group_id = Aws.Util.option_bind (Aws.Xml.member "groupId" xml) String.parse
      ; group_name = Aws.Util.option_bind (Aws.Xml.member "groupName" xml) String.parse
      ; stale_ip_permissions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "staleIpPermissions" xml)
               StaleIpPermissionSet.parse)
      ; stale_ip_permissions_egress =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "staleIpPermissionsEgress" xml)
               StaleIpPermissionSet.parse)
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "StaleIpPermissionsEgress"
                , StaleIpPermissionSet.to_query v.stale_ip_permissions_egress ))
         ; Some
             (Aws.Query.Pair
                ( "StaleIpPermissions"
                , StaleIpPermissionSet.to_query v.stale_ip_permissions ))
         ; Aws.Util.option_map v.group_name (fun f ->
               Aws.Query.Pair ("GroupName", String.to_query f))
         ; Aws.Util.option_map v.group_id (fun f ->
               Aws.Query.Pair ("GroupId", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_id (fun f -> "vpcId", String.to_json f)
         ; Some
             ( "staleIpPermissionsEgress"
             , StaleIpPermissionSet.to_json v.stale_ip_permissions_egress )
         ; Some ("staleIpPermissions", StaleIpPermissionSet.to_json v.stale_ip_permissions)
         ; Aws.Util.option_map v.group_name (fun f -> "groupName", String.to_json f)
         ; Aws.Util.option_map v.group_id (fun f -> "groupId", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; group_id = Aws.Util.option_map (Aws.Json.lookup j "groupId") String.of_json
    ; group_name = Aws.Util.option_map (Aws.Json.lookup j "groupName") String.of_json
    ; stale_ip_permissions =
        StaleIpPermissionSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "staleIpPermissions"))
    ; stale_ip_permissions_egress =
        StaleIpPermissionSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "staleIpPermissionsEgress"))
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "vpcId") String.of_json
    }
end

module DetachClassicLinkVpcResult = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module LaunchPermission = struct
  type t =
    { group : PermissionGroup.t option
    ; user_id : String.t option
    }

  let make ?group ?user_id () = { group; user_id }

  let parse xml =
    Some
      { group = Aws.Util.option_bind (Aws.Xml.member "group" xml) PermissionGroup.parse
      ; user_id = Aws.Util.option_bind (Aws.Xml.member "userId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.user_id (fun f ->
               Aws.Query.Pair ("UserId", String.to_query f))
         ; Aws.Util.option_map v.group (fun f ->
               Aws.Query.Pair ("Group", PermissionGroup.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.user_id (fun f -> "userId", String.to_json f)
         ; Aws.Util.option_map v.group (fun f -> "group", PermissionGroup.to_json f)
         ])

  let of_json j =
    { group = Aws.Util.option_map (Aws.Json.lookup j "group") PermissionGroup.of_json
    ; user_id = Aws.Util.option_map (Aws.Json.lookup j "userId") String.of_json
    }
end

module LaunchPermissionList = struct
  type t = LaunchPermission.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map LaunchPermission.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list LaunchPermission.to_query v

  let to_json v = `List (List.map LaunchPermission.to_json v)

  let of_json j = Aws.Json.to_list LaunchPermission.of_json j
end

module ImageAttribute = struct
  type t =
    { block_device_mappings : BlockDeviceMappingList.t
    ; image_id : String.t option
    ; launch_permissions : LaunchPermissionList.t
    ; product_codes : ProductCodeList.t
    ; description : AttributeValue.t option
    ; kernel_id : AttributeValue.t option
    ; ramdisk_id : AttributeValue.t option
    ; sriov_net_support : AttributeValue.t option
    }

  let make
      ?(block_device_mappings = [])
      ?image_id
      ?(launch_permissions = [])
      ?(product_codes = [])
      ?description
      ?kernel_id
      ?ramdisk_id
      ?sriov_net_support
      () =
    { block_device_mappings
    ; image_id
    ; launch_permissions
    ; product_codes
    ; description
    ; kernel_id
    ; ramdisk_id
    ; sriov_net_support
    }

  let parse xml =
    Some
      { block_device_mappings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "blockDeviceMapping" xml)
               BlockDeviceMappingList.parse)
      ; image_id = Aws.Util.option_bind (Aws.Xml.member "imageId" xml) String.parse
      ; launch_permissions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "launchPermission" xml)
               LaunchPermissionList.parse)
      ; product_codes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "productCodes" xml)
               ProductCodeList.parse)
      ; description =
          Aws.Util.option_bind (Aws.Xml.member "description" xml) AttributeValue.parse
      ; kernel_id =
          Aws.Util.option_bind (Aws.Xml.member "kernel" xml) AttributeValue.parse
      ; ramdisk_id =
          Aws.Util.option_bind (Aws.Xml.member "ramdisk" xml) AttributeValue.parse
      ; sriov_net_support =
          Aws.Util.option_bind (Aws.Xml.member "sriovNetSupport" xml) AttributeValue.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.sriov_net_support (fun f ->
               Aws.Query.Pair ("SriovNetSupport", AttributeValue.to_query f))
         ; Aws.Util.option_map v.ramdisk_id (fun f ->
               Aws.Query.Pair ("Ramdisk", AttributeValue.to_query f))
         ; Aws.Util.option_map v.kernel_id (fun f ->
               Aws.Query.Pair ("Kernel", AttributeValue.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", AttributeValue.to_query f))
         ; Some
             (Aws.Query.Pair ("ProductCodes", ProductCodeList.to_query v.product_codes))
         ; Some
             (Aws.Query.Pair
                ("LaunchPermission", LaunchPermissionList.to_query v.launch_permissions))
         ; Aws.Util.option_map v.image_id (fun f ->
               Aws.Query.Pair ("ImageId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "BlockDeviceMapping"
                , BlockDeviceMappingList.to_query v.block_device_mappings ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.sriov_net_support (fun f ->
               "sriovNetSupport", AttributeValue.to_json f)
         ; Aws.Util.option_map v.ramdisk_id (fun f -> "ramdisk", AttributeValue.to_json f)
         ; Aws.Util.option_map v.kernel_id (fun f -> "kernel", AttributeValue.to_json f)
         ; Aws.Util.option_map v.description (fun f ->
               "description", AttributeValue.to_json f)
         ; Some ("productCodes", ProductCodeList.to_json v.product_codes)
         ; Some ("launchPermission", LaunchPermissionList.to_json v.launch_permissions)
         ; Aws.Util.option_map v.image_id (fun f -> "imageId", String.to_json f)
         ; Some
             ("blockDeviceMapping", BlockDeviceMappingList.to_json v.block_device_mappings)
         ])

  let of_json j =
    { block_device_mappings =
        BlockDeviceMappingList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "blockDeviceMapping"))
    ; image_id = Aws.Util.option_map (Aws.Json.lookup j "imageId") String.of_json
    ; launch_permissions =
        LaunchPermissionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "launchPermission"))
    ; product_codes =
        ProductCodeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "productCodes"))
    ; description =
        Aws.Util.option_map (Aws.Json.lookup j "description") AttributeValue.of_json
    ; kernel_id = Aws.Util.option_map (Aws.Json.lookup j "kernel") AttributeValue.of_json
    ; ramdisk_id =
        Aws.Util.option_map (Aws.Json.lookup j "ramdisk") AttributeValue.of_json
    ; sriov_net_support =
        Aws.Util.option_map (Aws.Json.lookup j "sriovNetSupport") AttributeValue.of_json
    }
end

module VpcEndpointRouteTableIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module TransitGatewayRequestOptions = struct
  type t =
    { amazon_side_asn : Long.t option
    ; auto_accept_shared_attachments : AutoAcceptSharedAttachmentsValue.t option
    ; default_route_table_association : DefaultRouteTableAssociationValue.t option
    ; default_route_table_propagation : DefaultRouteTablePropagationValue.t option
    ; vpn_ecmp_support : VpnEcmpSupportValue.t option
    ; dns_support : DnsSupportValue.t option
    ; multicast_support : MulticastSupportValue.t option
    }

  let make
      ?amazon_side_asn
      ?auto_accept_shared_attachments
      ?default_route_table_association
      ?default_route_table_propagation
      ?vpn_ecmp_support
      ?dns_support
      ?multicast_support
      () =
    { amazon_side_asn
    ; auto_accept_shared_attachments
    ; default_route_table_association
    ; default_route_table_propagation
    ; vpn_ecmp_support
    ; dns_support
    ; multicast_support
    }

  let parse xml =
    Some
      { amazon_side_asn =
          Aws.Util.option_bind (Aws.Xml.member "AmazonSideAsn" xml) Long.parse
      ; auto_accept_shared_attachments =
          Aws.Util.option_bind
            (Aws.Xml.member "AutoAcceptSharedAttachments" xml)
            AutoAcceptSharedAttachmentsValue.parse
      ; default_route_table_association =
          Aws.Util.option_bind
            (Aws.Xml.member "DefaultRouteTableAssociation" xml)
            DefaultRouteTableAssociationValue.parse
      ; default_route_table_propagation =
          Aws.Util.option_bind
            (Aws.Xml.member "DefaultRouteTablePropagation" xml)
            DefaultRouteTablePropagationValue.parse
      ; vpn_ecmp_support =
          Aws.Util.option_bind
            (Aws.Xml.member "VpnEcmpSupport" xml)
            VpnEcmpSupportValue.parse
      ; dns_support =
          Aws.Util.option_bind (Aws.Xml.member "DnsSupport" xml) DnsSupportValue.parse
      ; multicast_support =
          Aws.Util.option_bind
            (Aws.Xml.member "MulticastSupport" xml)
            MulticastSupportValue.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.multicast_support (fun f ->
               Aws.Query.Pair ("MulticastSupport", MulticastSupportValue.to_query f))
         ; Aws.Util.option_map v.dns_support (fun f ->
               Aws.Query.Pair ("DnsSupport", DnsSupportValue.to_query f))
         ; Aws.Util.option_map v.vpn_ecmp_support (fun f ->
               Aws.Query.Pair ("VpnEcmpSupport", VpnEcmpSupportValue.to_query f))
         ; Aws.Util.option_map v.default_route_table_propagation (fun f ->
               Aws.Query.Pair
                 ( "DefaultRouteTablePropagation"
                 , DefaultRouteTablePropagationValue.to_query f ))
         ; Aws.Util.option_map v.default_route_table_association (fun f ->
               Aws.Query.Pair
                 ( "DefaultRouteTableAssociation"
                 , DefaultRouteTableAssociationValue.to_query f ))
         ; Aws.Util.option_map v.auto_accept_shared_attachments (fun f ->
               Aws.Query.Pair
                 ( "AutoAcceptSharedAttachments"
                 , AutoAcceptSharedAttachmentsValue.to_query f ))
         ; Aws.Util.option_map v.amazon_side_asn (fun f ->
               Aws.Query.Pair ("AmazonSideAsn", Long.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.multicast_support (fun f ->
               "MulticastSupport", MulticastSupportValue.to_json f)
         ; Aws.Util.option_map v.dns_support (fun f ->
               "DnsSupport", DnsSupportValue.to_json f)
         ; Aws.Util.option_map v.vpn_ecmp_support (fun f ->
               "VpnEcmpSupport", VpnEcmpSupportValue.to_json f)
         ; Aws.Util.option_map v.default_route_table_propagation (fun f ->
               "DefaultRouteTablePropagation", DefaultRouteTablePropagationValue.to_json f)
         ; Aws.Util.option_map v.default_route_table_association (fun f ->
               "DefaultRouteTableAssociation", DefaultRouteTableAssociationValue.to_json f)
         ; Aws.Util.option_map v.auto_accept_shared_attachments (fun f ->
               "AutoAcceptSharedAttachments", AutoAcceptSharedAttachmentsValue.to_json f)
         ; Aws.Util.option_map v.amazon_side_asn (fun f ->
               "AmazonSideAsn", Long.to_json f)
         ])

  let of_json j =
    { amazon_side_asn =
        Aws.Util.option_map (Aws.Json.lookup j "AmazonSideAsn") Long.of_json
    ; auto_accept_shared_attachments =
        Aws.Util.option_map
          (Aws.Json.lookup j "AutoAcceptSharedAttachments")
          AutoAcceptSharedAttachmentsValue.of_json
    ; default_route_table_association =
        Aws.Util.option_map
          (Aws.Json.lookup j "DefaultRouteTableAssociation")
          DefaultRouteTableAssociationValue.of_json
    ; default_route_table_propagation =
        Aws.Util.option_map
          (Aws.Json.lookup j "DefaultRouteTablePropagation")
          DefaultRouteTablePropagationValue.of_json
    ; vpn_ecmp_support =
        Aws.Util.option_map
          (Aws.Json.lookup j "VpnEcmpSupport")
          VpnEcmpSupportValue.of_json
    ; dns_support =
        Aws.Util.option_map (Aws.Json.lookup j "DnsSupport") DnsSupportValue.of_json
    ; multicast_support =
        Aws.Util.option_map
          (Aws.Json.lookup j "MulticastSupport")
          MulticastSupportValue.of_json
    }
end

module CreateTransitGatewayRequest = struct
  type t =
    { description : String.t option
    ; options : TransitGatewayRequestOptions.t option
    ; tag_specifications : TagSpecificationList.t
    ; dry_run : Boolean.t option
    }

  let make ?description ?options ?(tag_specifications = []) ?dry_run () =
    { description; options; tag_specifications; dry_run }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; options =
          Aws.Util.option_bind
            (Aws.Xml.member "Options" xml)
            TransitGatewayRequestOptions.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Aws.Util.option_map v.options (fun f ->
               Aws.Query.Pair ("Options", TransitGatewayRequestOptions.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Aws.Util.option_map v.options (fun f ->
               "Options", TransitGatewayRequestOptions.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; options =
        Aws.Util.option_map
          (Aws.Json.lookup j "Options")
          TransitGatewayRequestOptions.of_json
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module AttachVpnGatewayResult = struct
  type t = { vpc_attachment : VpcAttachment.t option }

  let make ?vpc_attachment () = { vpc_attachment }

  let parse xml =
    Some
      { vpc_attachment =
          Aws.Util.option_bind (Aws.Xml.member "attachment" xml) VpcAttachment.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_attachment (fun f ->
               Aws.Query.Pair ("Attachment", VpcAttachment.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_attachment (fun f ->
               "attachment", VpcAttachment.to_json f)
         ])

  let of_json j =
    { vpc_attachment =
        Aws.Util.option_map (Aws.Json.lookup j "attachment") VpcAttachment.of_json
    }
end

module TrafficMirrorNetworkService = struct
  type t = Amazon_dns

  let str_to_t = [ "amazon-dns", Amazon_dns ]

  let t_to_str = [ Amazon_dns, "amazon-dns" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module TrafficMirrorNetworkServiceList = struct
  type t = TrafficMirrorNetworkService.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map TrafficMirrorNetworkService.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list TrafficMirrorNetworkService.to_query v

  let to_json v = `List (List.map TrafficMirrorNetworkService.to_json v)

  let of_json j = Aws.Json.to_list TrafficMirrorNetworkService.of_json j
end

module TrafficMirrorFilter = struct
  type t =
    { traffic_mirror_filter_id : String.t option
    ; ingress_filter_rules : TrafficMirrorFilterRuleList.t
    ; egress_filter_rules : TrafficMirrorFilterRuleList.t
    ; network_services : TrafficMirrorNetworkServiceList.t
    ; description : String.t option
    ; tags : TagList.t
    }

  let make
      ?traffic_mirror_filter_id
      ?(ingress_filter_rules = [])
      ?(egress_filter_rules = [])
      ?(network_services = [])
      ?description
      ?(tags = [])
      () =
    { traffic_mirror_filter_id
    ; ingress_filter_rules
    ; egress_filter_rules
    ; network_services
    ; description
    ; tags
    }

  let parse xml =
    Some
      { traffic_mirror_filter_id =
          Aws.Util.option_bind (Aws.Xml.member "trafficMirrorFilterId" xml) String.parse
      ; ingress_filter_rules =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ingressFilterRuleSet" xml)
               TrafficMirrorFilterRuleList.parse)
      ; egress_filter_rules =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "egressFilterRuleSet" xml)
               TrafficMirrorFilterRuleList.parse)
      ; network_services =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "networkServiceSet" xml)
               TrafficMirrorNetworkServiceList.parse)
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "NetworkServiceSet"
                , TrafficMirrorNetworkServiceList.to_query v.network_services ))
         ; Some
             (Aws.Query.Pair
                ( "EgressFilterRuleSet"
                , TrafficMirrorFilterRuleList.to_query v.egress_filter_rules ))
         ; Some
             (Aws.Query.Pair
                ( "IngressFilterRuleSet"
                , TrafficMirrorFilterRuleList.to_query v.ingress_filter_rules ))
         ; Aws.Util.option_map v.traffic_mirror_filter_id (fun f ->
               Aws.Query.Pair ("TrafficMirrorFilterId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Some
             ( "networkServiceSet"
             , TrafficMirrorNetworkServiceList.to_json v.network_services )
         ; Some
             ( "egressFilterRuleSet"
             , TrafficMirrorFilterRuleList.to_json v.egress_filter_rules )
         ; Some
             ( "ingressFilterRuleSet"
             , TrafficMirrorFilterRuleList.to_json v.ingress_filter_rules )
         ; Aws.Util.option_map v.traffic_mirror_filter_id (fun f ->
               "trafficMirrorFilterId", String.to_json f)
         ])

  let of_json j =
    { traffic_mirror_filter_id =
        Aws.Util.option_map (Aws.Json.lookup j "trafficMirrorFilterId") String.of_json
    ; ingress_filter_rules =
        TrafficMirrorFilterRuleList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ingressFilterRuleSet"))
    ; egress_filter_rules =
        TrafficMirrorFilterRuleList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "egressFilterRuleSet"))
    ; network_services =
        TrafficMirrorNetworkServiceList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "networkServiceSet"))
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module FederatedAuthentication = struct
  type t =
    { saml_provider_arn : String.t option
    ; self_service_saml_provider_arn : String.t option
    }

  let make ?saml_provider_arn ?self_service_saml_provider_arn () =
    { saml_provider_arn; self_service_saml_provider_arn }

  let parse xml =
    Some
      { saml_provider_arn =
          Aws.Util.option_bind (Aws.Xml.member "samlProviderArn" xml) String.parse
      ; self_service_saml_provider_arn =
          Aws.Util.option_bind
            (Aws.Xml.member "selfServiceSamlProviderArn" xml)
            String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.self_service_saml_provider_arn (fun f ->
               Aws.Query.Pair ("SelfServiceSamlProviderArn", String.to_query f))
         ; Aws.Util.option_map v.saml_provider_arn (fun f ->
               Aws.Query.Pair ("SamlProviderArn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.self_service_saml_provider_arn (fun f ->
               "selfServiceSamlProviderArn", String.to_json f)
         ; Aws.Util.option_map v.saml_provider_arn (fun f ->
               "samlProviderArn", String.to_json f)
         ])

  let of_json j =
    { saml_provider_arn =
        Aws.Util.option_map (Aws.Json.lookup j "samlProviderArn") String.of_json
    ; self_service_saml_provider_arn =
        Aws.Util.option_map
          (Aws.Json.lookup j "selfServiceSamlProviderArn")
          String.of_json
    }
end

module CertificateAuthentication = struct
  type t = { client_root_certificate_chain : String.t option }

  let make ?client_root_certificate_chain () = { client_root_certificate_chain }

  let parse xml =
    Some
      { client_root_certificate_chain =
          Aws.Util.option_bind
            (Aws.Xml.member "clientRootCertificateChain" xml)
            String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_root_certificate_chain (fun f ->
               Aws.Query.Pair ("ClientRootCertificateChain", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_root_certificate_chain (fun f ->
               "clientRootCertificateChain", String.to_json f)
         ])

  let of_json j =
    { client_root_certificate_chain =
        Aws.Util.option_map
          (Aws.Json.lookup j "clientRootCertificateChain")
          String.of_json
    }
end

module ClientVpnAuthentication = struct
  type t =
    { type_ : ClientVpnAuthenticationType.t option
    ; active_directory : DirectoryServiceAuthentication.t option
    ; mutual_authentication : CertificateAuthentication.t option
    ; federated_authentication : FederatedAuthentication.t option
    }

  let make ?type_ ?active_directory ?mutual_authentication ?federated_authentication () =
    { type_; active_directory; mutual_authentication; federated_authentication }

  let parse xml =
    Some
      { type_ =
          Aws.Util.option_bind
            (Aws.Xml.member "type" xml)
            ClientVpnAuthenticationType.parse
      ; active_directory =
          Aws.Util.option_bind
            (Aws.Xml.member "activeDirectory" xml)
            DirectoryServiceAuthentication.parse
      ; mutual_authentication =
          Aws.Util.option_bind
            (Aws.Xml.member "mutualAuthentication" xml)
            CertificateAuthentication.parse
      ; federated_authentication =
          Aws.Util.option_bind
            (Aws.Xml.member "federatedAuthentication" xml)
            FederatedAuthentication.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.federated_authentication (fun f ->
               Aws.Query.Pair
                 ("FederatedAuthentication", FederatedAuthentication.to_query f))
         ; Aws.Util.option_map v.mutual_authentication (fun f ->
               Aws.Query.Pair
                 ("MutualAuthentication", CertificateAuthentication.to_query f))
         ; Aws.Util.option_map v.active_directory (fun f ->
               Aws.Query.Pair
                 ("ActiveDirectory", DirectoryServiceAuthentication.to_query f))
         ; Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", ClientVpnAuthenticationType.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.federated_authentication (fun f ->
               "federatedAuthentication", FederatedAuthentication.to_json f)
         ; Aws.Util.option_map v.mutual_authentication (fun f ->
               "mutualAuthentication", CertificateAuthentication.to_json f)
         ; Aws.Util.option_map v.active_directory (fun f ->
               "activeDirectory", DirectoryServiceAuthentication.to_json f)
         ; Aws.Util.option_map v.type_ (fun f ->
               "type", ClientVpnAuthenticationType.to_json f)
         ])

  let of_json j =
    { type_ =
        Aws.Util.option_map (Aws.Json.lookup j "type") ClientVpnAuthenticationType.of_json
    ; active_directory =
        Aws.Util.option_map
          (Aws.Json.lookup j "activeDirectory")
          DirectoryServiceAuthentication.of_json
    ; mutual_authentication =
        Aws.Util.option_map
          (Aws.Json.lookup j "mutualAuthentication")
          CertificateAuthentication.of_json
    ; federated_authentication =
        Aws.Util.option_map
          (Aws.Json.lookup j "federatedAuthentication")
          FederatedAuthentication.of_json
    }
end

module UnsuccessfulItemSet = struct
  type t = UnsuccessfulItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map UnsuccessfulItem.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list UnsuccessfulItem.to_query v

  let to_json v = `List (List.map UnsuccessfulItem.to_json v)

  let of_json j = Aws.Json.to_list UnsuccessfulItem.of_json j
end

module DeleteFlowLogsResult = struct
  type t = { unsuccessful : UnsuccessfulItemSet.t }

  let make ?(unsuccessful = []) () = { unsuccessful }

  let parse xml =
    Some
      { unsuccessful =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "unsuccessful" xml)
               UnsuccessfulItemSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("Unsuccessful", UnsuccessfulItemSet.to_query v.unsuccessful))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("unsuccessful", UnsuccessfulItemSet.to_json v.unsuccessful) ])

  let of_json j =
    { unsuccessful =
        UnsuccessfulItemSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "unsuccessful"))
    }
end

module EnableFastSnapshotRestoreErrorItem = struct
  type t =
    { snapshot_id : String.t option
    ; fast_snapshot_restore_state_errors : EnableFastSnapshotRestoreStateErrorSet.t
    }

  let make ?snapshot_id ?(fast_snapshot_restore_state_errors = []) () =
    { snapshot_id; fast_snapshot_restore_state_errors }

  let parse xml =
    Some
      { snapshot_id = Aws.Util.option_bind (Aws.Xml.member "snapshotId" xml) String.parse
      ; fast_snapshot_restore_state_errors =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "fastSnapshotRestoreStateErrorSet" xml)
               EnableFastSnapshotRestoreStateErrorSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "FastSnapshotRestoreStateErrorSet"
                , EnableFastSnapshotRestoreStateErrorSet.to_query
                    v.fast_snapshot_restore_state_errors ))
         ; Aws.Util.option_map v.snapshot_id (fun f ->
               Aws.Query.Pair ("SnapshotId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "fastSnapshotRestoreStateErrorSet"
             , EnableFastSnapshotRestoreStateErrorSet.to_json
                 v.fast_snapshot_restore_state_errors )
         ; Aws.Util.option_map v.snapshot_id (fun f -> "snapshotId", String.to_json f)
         ])

  let of_json j =
    { snapshot_id = Aws.Util.option_map (Aws.Json.lookup j "snapshotId") String.of_json
    ; fast_snapshot_restore_state_errors =
        EnableFastSnapshotRestoreStateErrorSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "fastSnapshotRestoreStateErrorSet"))
    }
end

module DisableVpcClassicLinkResult = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module ModifyEbsDefaultKmsKeyIdResult = struct
  type t = { kms_key_id : String.t option }

  let make ?kms_key_id () = { kms_key_id }

  let parse xml =
    Some
      { kms_key_id = Aws.Util.option_bind (Aws.Xml.member "kmsKeyId" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.kms_key_id (fun f -> "kmsKeyId", String.to_json f) ])

  let of_json j =
    { kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "kmsKeyId") String.of_json }
end

module LaunchTemplateErrorCode = struct
  type t =
    | LaunchTemplateIdDoesNotExist
    | LaunchTemplateIdMalformed
    | LaunchTemplateNameDoesNotExist
    | LaunchTemplateNameMalformed
    | LaunchTemplateVersionDoesNotExist
    | UnexpectedError

  let str_to_t =
    [ "unexpectedError", UnexpectedError
    ; "launchTemplateVersionDoesNotExist", LaunchTemplateVersionDoesNotExist
    ; "launchTemplateNameMalformed", LaunchTemplateNameMalformed
    ; "launchTemplateNameDoesNotExist", LaunchTemplateNameDoesNotExist
    ; "launchTemplateIdMalformed", LaunchTemplateIdMalformed
    ; "launchTemplateIdDoesNotExist", LaunchTemplateIdDoesNotExist
    ]

  let t_to_str =
    [ UnexpectedError, "unexpectedError"
    ; LaunchTemplateVersionDoesNotExist, "launchTemplateVersionDoesNotExist"
    ; LaunchTemplateNameMalformed, "launchTemplateNameMalformed"
    ; LaunchTemplateNameDoesNotExist, "launchTemplateNameDoesNotExist"
    ; LaunchTemplateIdMalformed, "launchTemplateIdMalformed"
    ; LaunchTemplateIdDoesNotExist, "launchTemplateIdDoesNotExist"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ResponseError = struct
  type t =
    { code : LaunchTemplateErrorCode.t option
    ; message : String.t option
    }

  let make ?code ?message () = { code; message }

  let parse xml =
    Some
      { code =
          Aws.Util.option_bind (Aws.Xml.member "code" xml) LaunchTemplateErrorCode.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair ("Code", LaunchTemplateErrorCode.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f)
         ; Aws.Util.option_map v.code (fun f -> "code", LaunchTemplateErrorCode.to_json f)
         ])

  let of_json j =
    { code =
        Aws.Util.option_map (Aws.Json.lookup j "code") LaunchTemplateErrorCode.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json
    }
end

module CapacityReservationInstancePlatform = struct
  type t =
    | Linux_UNIX
    | Red_Hat_Enterprise_Linux
    | SUSE_Linux
    | Windows
    | Windows_with_SQL_Server
    | Windows_with_SQL_Server_Enterprise
    | Windows_with_SQL_Server_Standard
    | Windows_with_SQL_Server_Web
    | Linux_with_SQL_Server_Standard
    | Linux_with_SQL_Server_Web
    | Linux_with_SQL_Server_Enterprise

  let str_to_t =
    [ "Linux with SQL Server Enterprise", Linux_with_SQL_Server_Enterprise
    ; "Linux with SQL Server Web", Linux_with_SQL_Server_Web
    ; "Linux with SQL Server Standard", Linux_with_SQL_Server_Standard
    ; "Windows with SQL Server Web", Windows_with_SQL_Server_Web
    ; "Windows with SQL Server Standard", Windows_with_SQL_Server_Standard
    ; "Windows with SQL Server Enterprise", Windows_with_SQL_Server_Enterprise
    ; "Windows with SQL Server", Windows_with_SQL_Server
    ; "Windows", Windows
    ; "SUSE Linux", SUSE_Linux
    ; "Red Hat Enterprise Linux", Red_Hat_Enterprise_Linux
    ; "Linux/UNIX", Linux_UNIX
    ]

  let t_to_str =
    [ Linux_with_SQL_Server_Enterprise, "Linux with SQL Server Enterprise"
    ; Linux_with_SQL_Server_Web, "Linux with SQL Server Web"
    ; Linux_with_SQL_Server_Standard, "Linux with SQL Server Standard"
    ; Windows_with_SQL_Server_Web, "Windows with SQL Server Web"
    ; Windows_with_SQL_Server_Standard, "Windows with SQL Server Standard"
    ; Windows_with_SQL_Server_Enterprise, "Windows with SQL Server Enterprise"
    ; Windows_with_SQL_Server, "Windows with SQL Server"
    ; Windows, "Windows"
    ; SUSE_Linux, "SUSE Linux"
    ; Red_Hat_Enterprise_Linux, "Red Hat Enterprise Linux"
    ; Linux_UNIX, "Linux/UNIX"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module PoolCidrBlocksSet = struct
  type t = PoolCidrBlock.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map PoolCidrBlock.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list PoolCidrBlock.to_query v

  let to_json v = `List (List.map PoolCidrBlock.to_json v)

  let of_json j = Aws.Json.to_list PoolCidrBlock.of_json j
end

module Ipv6Pool = struct
  type t =
    { pool_id : String.t option
    ; description : String.t option
    ; pool_cidr_blocks : PoolCidrBlocksSet.t
    ; tags : TagList.t
    }

  let make ?pool_id ?description ?(pool_cidr_blocks = []) ?(tags = []) () =
    { pool_id; description; pool_cidr_blocks; tags }

  let parse xml =
    Some
      { pool_id = Aws.Util.option_bind (Aws.Xml.member "poolId" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; pool_cidr_blocks =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "poolCidrBlockSet" xml)
               PoolCidrBlocksSet.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Some
             (Aws.Query.Pair
                ("PoolCidrBlockSet", PoolCidrBlocksSet.to_query v.pool_cidr_blocks))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.pool_id (fun f ->
               Aws.Query.Pair ("PoolId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Some ("poolCidrBlockSet", PoolCidrBlocksSet.to_json v.pool_cidr_blocks)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Aws.Util.option_map v.pool_id (fun f -> "poolId", String.to_json f)
         ])

  let of_json j =
    { pool_id = Aws.Util.option_map (Aws.Json.lookup j "poolId") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; pool_cidr_blocks =
        PoolCidrBlocksSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "poolCidrBlockSet"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module DeleteVpcEndpointServiceConfigurationsResult = struct
  type t = { unsuccessful : UnsuccessfulItemSet.t }

  let make ?(unsuccessful = []) () = { unsuccessful }

  let parse xml =
    Some
      { unsuccessful =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "unsuccessful" xml)
               UnsuccessfulItemSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("Unsuccessful", UnsuccessfulItemSet.to_query v.unsuccessful))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("unsuccessful", UnsuccessfulItemSet.to_json v.unsuccessful) ])

  let of_json j =
    { unsuccessful =
        UnsuccessfulItemSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "unsuccessful"))
    }
end

module ReplaceTransitGatewayRouteResult = struct
  type t = { route : TransitGatewayRoute.t option }

  let make ?route () = { route }

  let parse xml =
    Some
      { route =
          Aws.Util.option_bind (Aws.Xml.member "route" xml) TransitGatewayRoute.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.route (fun f ->
               Aws.Query.Pair ("Route", TransitGatewayRoute.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.route (fun f -> "route", TransitGatewayRoute.to_json f) ])

  let of_json j =
    { route = Aws.Util.option_map (Aws.Json.lookup j "route") TransitGatewayRoute.of_json
    }
end

module TargetCapacitySpecification = struct
  type t =
    { total_target_capacity : Integer.t option
    ; on_demand_target_capacity : Integer.t option
    ; spot_target_capacity : Integer.t option
    ; default_target_capacity_type : DefaultTargetCapacityType.t option
    }

  let make
      ?total_target_capacity
      ?on_demand_target_capacity
      ?spot_target_capacity
      ?default_target_capacity_type
      () =
    { total_target_capacity
    ; on_demand_target_capacity
    ; spot_target_capacity
    ; default_target_capacity_type
    }

  let parse xml =
    Some
      { total_target_capacity =
          Aws.Util.option_bind (Aws.Xml.member "totalTargetCapacity" xml) Integer.parse
      ; on_demand_target_capacity =
          Aws.Util.option_bind (Aws.Xml.member "onDemandTargetCapacity" xml) Integer.parse
      ; spot_target_capacity =
          Aws.Util.option_bind (Aws.Xml.member "spotTargetCapacity" xml) Integer.parse
      ; default_target_capacity_type =
          Aws.Util.option_bind
            (Aws.Xml.member "defaultTargetCapacityType" xml)
            DefaultTargetCapacityType.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.default_target_capacity_type (fun f ->
               Aws.Query.Pair
                 ("DefaultTargetCapacityType", DefaultTargetCapacityType.to_query f))
         ; Aws.Util.option_map v.spot_target_capacity (fun f ->
               Aws.Query.Pair ("SpotTargetCapacity", Integer.to_query f))
         ; Aws.Util.option_map v.on_demand_target_capacity (fun f ->
               Aws.Query.Pair ("OnDemandTargetCapacity", Integer.to_query f))
         ; Aws.Util.option_map v.total_target_capacity (fun f ->
               Aws.Query.Pair ("TotalTargetCapacity", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.default_target_capacity_type (fun f ->
               "defaultTargetCapacityType", DefaultTargetCapacityType.to_json f)
         ; Aws.Util.option_map v.spot_target_capacity (fun f ->
               "spotTargetCapacity", Integer.to_json f)
         ; Aws.Util.option_map v.on_demand_target_capacity (fun f ->
               "onDemandTargetCapacity", Integer.to_json f)
         ; Aws.Util.option_map v.total_target_capacity (fun f ->
               "totalTargetCapacity", Integer.to_json f)
         ])

  let of_json j =
    { total_target_capacity =
        Aws.Util.option_map (Aws.Json.lookup j "totalTargetCapacity") Integer.of_json
    ; on_demand_target_capacity =
        Aws.Util.option_map (Aws.Json.lookup j "onDemandTargetCapacity") Integer.of_json
    ; spot_target_capacity =
        Aws.Util.option_map (Aws.Json.lookup j "spotTargetCapacity") Integer.of_json
    ; default_target_capacity_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "defaultTargetCapacityType")
          DefaultTargetCapacityType.of_json
    }
end

module ImportSnapshotTask = struct
  type t =
    { description : String.t option
    ; import_task_id : String.t option
    ; snapshot_task_detail : SnapshotTaskDetail.t option
    ; tags : TagList.t
    }

  let make ?description ?import_task_id ?snapshot_task_detail ?(tags = []) () =
    { description; import_task_id; snapshot_task_detail; tags }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; import_task_id =
          Aws.Util.option_bind (Aws.Xml.member "importTaskId" xml) String.parse
      ; snapshot_task_detail =
          Aws.Util.option_bind
            (Aws.Xml.member "snapshotTaskDetail" xml)
            SnapshotTaskDetail.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.snapshot_task_detail (fun f ->
               Aws.Query.Pair ("SnapshotTaskDetail", SnapshotTaskDetail.to_query f))
         ; Aws.Util.option_map v.import_task_id (fun f ->
               Aws.Query.Pair ("ImportTaskId", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.snapshot_task_detail (fun f ->
               "snapshotTaskDetail", SnapshotTaskDetail.to_json f)
         ; Aws.Util.option_map v.import_task_id (fun f ->
               "importTaskId", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; import_task_id =
        Aws.Util.option_map (Aws.Json.lookup j "importTaskId") String.of_json
    ; snapshot_task_detail =
        Aws.Util.option_map
          (Aws.Json.lookup j "snapshotTaskDetail")
          SnapshotTaskDetail.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module ImportSnapshotTaskList = struct
  type t = ImportSnapshotTask.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ImportSnapshotTask.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ImportSnapshotTask.to_query v

  let to_json v = `List (List.map ImportSnapshotTask.to_json v)

  let of_json j = Aws.Json.to_list ImportSnapshotTask.of_json j
end

module LocalGatewayVirtualInterfaceGroup = struct
  type t =
    { local_gateway_virtual_interface_group_id : String.t option
    ; local_gateway_virtual_interface_ids : LocalGatewayVirtualInterfaceIdSet.t
    ; local_gateway_id : String.t option
    ; owner_id : String.t option
    ; tags : TagList.t
    }

  let make
      ?local_gateway_virtual_interface_group_id
      ?(local_gateway_virtual_interface_ids = [])
      ?local_gateway_id
      ?owner_id
      ?(tags = [])
      () =
    { local_gateway_virtual_interface_group_id
    ; local_gateway_virtual_interface_ids
    ; local_gateway_id
    ; owner_id
    ; tags
    }

  let parse xml =
    Some
      { local_gateway_virtual_interface_group_id =
          Aws.Util.option_bind
            (Aws.Xml.member "localGatewayVirtualInterfaceGroupId" xml)
            String.parse
      ; local_gateway_virtual_interface_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "localGatewayVirtualInterfaceIdSet" xml)
               LocalGatewayVirtualInterfaceIdSet.parse)
      ; local_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "localGatewayId" xml) String.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.local_gateway_id (fun f ->
               Aws.Query.Pair ("LocalGatewayId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "LocalGatewayVirtualInterfaceIdSet"
                , LocalGatewayVirtualInterfaceIdSet.to_query
                    v.local_gateway_virtual_interface_ids ))
         ; Aws.Util.option_map v.local_gateway_virtual_interface_group_id (fun f ->
               Aws.Query.Pair ("LocalGatewayVirtualInterfaceGroupId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.local_gateway_id (fun f ->
               "localGatewayId", String.to_json f)
         ; Some
             ( "localGatewayVirtualInterfaceIdSet"
             , LocalGatewayVirtualInterfaceIdSet.to_json
                 v.local_gateway_virtual_interface_ids )
         ; Aws.Util.option_map v.local_gateway_virtual_interface_group_id (fun f ->
               "localGatewayVirtualInterfaceGroupId", String.to_json f)
         ])

  let of_json j =
    { local_gateway_virtual_interface_group_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "localGatewayVirtualInterfaceGroupId")
          String.of_json
    ; local_gateway_virtual_interface_ids =
        LocalGatewayVirtualInterfaceIdSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "localGatewayVirtualInterfaceIdSet"))
    ; local_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "localGatewayId") String.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module DhcpConfigurationValueList = struct
  type t = AttributeValue.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map AttributeValue.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list AttributeValue.to_query v

  let to_json v = `List (List.map AttributeValue.to_json v)

  let of_json j = Aws.Json.to_list AttributeValue.of_json j
end

module AssociateClientVpnTargetNetworkResult = struct
  type t =
    { association_id : String.t option
    ; status : AssociationStatus.t option
    }

  let make ?association_id ?status () = { association_id; status }

  let parse xml =
    Some
      { association_id =
          Aws.Util.option_bind (Aws.Xml.member "associationId" xml) String.parse
      ; status =
          Aws.Util.option_bind (Aws.Xml.member "status" xml) AssociationStatus.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", AssociationStatus.to_query f))
         ; Aws.Util.option_map v.association_id (fun f ->
               Aws.Query.Pair ("AssociationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f -> "status", AssociationStatus.to_json f)
         ; Aws.Util.option_map v.association_id (fun f ->
               "associationId", String.to_json f)
         ])

  let of_json j =
    { association_id =
        Aws.Util.option_map (Aws.Json.lookup j "associationId") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "status") AssociationStatus.of_json
    }
end

module DisableFastSnapshotRestoreErrorItem = struct
  type t =
    { snapshot_id : String.t option
    ; fast_snapshot_restore_state_errors : DisableFastSnapshotRestoreStateErrorSet.t
    }

  let make ?snapshot_id ?(fast_snapshot_restore_state_errors = []) () =
    { snapshot_id; fast_snapshot_restore_state_errors }

  let parse xml =
    Some
      { snapshot_id = Aws.Util.option_bind (Aws.Xml.member "snapshotId" xml) String.parse
      ; fast_snapshot_restore_state_errors =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "fastSnapshotRestoreStateErrorSet" xml)
               DisableFastSnapshotRestoreStateErrorSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "FastSnapshotRestoreStateErrorSet"
                , DisableFastSnapshotRestoreStateErrorSet.to_query
                    v.fast_snapshot_restore_state_errors ))
         ; Aws.Util.option_map v.snapshot_id (fun f ->
               Aws.Query.Pair ("SnapshotId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "fastSnapshotRestoreStateErrorSet"
             , DisableFastSnapshotRestoreStateErrorSet.to_json
                 v.fast_snapshot_restore_state_errors )
         ; Aws.Util.option_map v.snapshot_id (fun f -> "snapshotId", String.to_json f)
         ])

  let of_json j =
    { snapshot_id = Aws.Util.option_map (Aws.Json.lookup j "snapshotId") String.of_json
    ; fast_snapshot_restore_state_errors =
        DisableFastSnapshotRestoreStateErrorSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "fastSnapshotRestoreStateErrorSet"))
    }
end

module VolumeStatusInfoStatus = struct
  type t =
    | Ok
    | Impaired
    | Insufficient_data

  let str_to_t =
    [ "insufficient-data", Insufficient_data; "impaired", Impaired; "ok", Ok ]

  let t_to_str =
    [ Insufficient_data, "insufficient-data"; Impaired, "impaired"; Ok, "ok" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module VolumeStatusName = struct
  type t =
    | Io_enabled
    | Io_performance

  let str_to_t = [ "io-performance", Io_performance; "io-enabled", Io_enabled ]

  let t_to_str = [ Io_performance, "io-performance"; Io_enabled, "io-enabled" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module VolumeStatusDetails = struct
  type t =
    { name : VolumeStatusName.t option
    ; status : String.t option
    }

  let make ?name ?status () = { name; status }

  let parse xml =
    Some
      { name = Aws.Util.option_bind (Aws.Xml.member "name" xml) VolumeStatusName.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "status" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", VolumeStatusName.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f -> "status", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "name", VolumeStatusName.to_json f)
         ])

  let of_json j =
    { name = Aws.Util.option_map (Aws.Json.lookup j "name") VolumeStatusName.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "status") String.of_json
    }
end

module VolumeStatusDetailsList = struct
  type t = VolumeStatusDetails.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map VolumeStatusDetails.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list VolumeStatusDetails.to_query v

  let to_json v = `List (List.map VolumeStatusDetails.to_json v)

  let of_json j = Aws.Json.to_list VolumeStatusDetails.of_json j
end

module VolumeStatusInfo = struct
  type t =
    { details : VolumeStatusDetailsList.t
    ; status : VolumeStatusInfoStatus.t option
    }

  let make ?(details = []) ?status () = { details; status }

  let parse xml =
    Some
      { details =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "details" xml)
               VolumeStatusDetailsList.parse)
      ; status =
          Aws.Util.option_bind (Aws.Xml.member "status" xml) VolumeStatusInfoStatus.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", VolumeStatusInfoStatus.to_query f))
         ; Some (Aws.Query.Pair ("Details", VolumeStatusDetailsList.to_query v.details))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               "status", VolumeStatusInfoStatus.to_json f)
         ; Some ("details", VolumeStatusDetailsList.to_json v.details)
         ])

  let of_json j =
    { details =
        VolumeStatusDetailsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "details"))
    ; status =
        Aws.Util.option_map (Aws.Json.lookup j "status") VolumeStatusInfoStatus.of_json
    }
end

module VolumeStatusEvent = struct
  type t =
    { description : String.t option
    ; event_id : String.t option
    ; event_type : String.t option
    ; not_after : DateTime.t option
    ; not_before : DateTime.t option
    ; instance_id : String.t option
    }

  let make ?description ?event_id ?event_type ?not_after ?not_before ?instance_id () =
    { description; event_id; event_type; not_after; not_before; instance_id }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; event_id = Aws.Util.option_bind (Aws.Xml.member "eventId" xml) String.parse
      ; event_type = Aws.Util.option_bind (Aws.Xml.member "eventType" xml) String.parse
      ; not_after = Aws.Util.option_bind (Aws.Xml.member "notAfter" xml) DateTime.parse
      ; not_before = Aws.Util.option_bind (Aws.Xml.member "notBefore" xml) DateTime.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.not_before (fun f ->
               Aws.Query.Pair ("NotBefore", DateTime.to_query f))
         ; Aws.Util.option_map v.not_after (fun f ->
               Aws.Query.Pair ("NotAfter", DateTime.to_query f))
         ; Aws.Util.option_map v.event_type (fun f ->
               Aws.Query.Pair ("EventType", String.to_query f))
         ; Aws.Util.option_map v.event_id (fun f ->
               Aws.Query.Pair ("EventId", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ; Aws.Util.option_map v.not_before (fun f -> "notBefore", DateTime.to_json f)
         ; Aws.Util.option_map v.not_after (fun f -> "notAfter", DateTime.to_json f)
         ; Aws.Util.option_map v.event_type (fun f -> "eventType", String.to_json f)
         ; Aws.Util.option_map v.event_id (fun f -> "eventId", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; event_id = Aws.Util.option_map (Aws.Json.lookup j "eventId") String.of_json
    ; event_type = Aws.Util.option_map (Aws.Json.lookup j "eventType") String.of_json
    ; not_after = Aws.Util.option_map (Aws.Json.lookup j "notAfter") DateTime.of_json
    ; not_before = Aws.Util.option_map (Aws.Json.lookup j "notBefore") DateTime.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    }
end

module VolumeStatusEventsList = struct
  type t = VolumeStatusEvent.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map VolumeStatusEvent.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list VolumeStatusEvent.to_query v

  let to_json v = `List (List.map VolumeStatusEvent.to_json v)

  let of_json j = Aws.Json.to_list VolumeStatusEvent.of_json j
end

module VolumeStatusAttachmentStatus = struct
  type t =
    { io_performance : String.t option
    ; instance_id : String.t option
    }

  let make ?io_performance ?instance_id () = { io_performance; instance_id }

  let parse xml =
    Some
      { io_performance =
          Aws.Util.option_bind (Aws.Xml.member "ioPerformance" xml) String.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.io_performance (fun f ->
               Aws.Query.Pair ("IoPerformance", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ; Aws.Util.option_map v.io_performance (fun f ->
               "ioPerformance", String.to_json f)
         ])

  let of_json j =
    { io_performance =
        Aws.Util.option_map (Aws.Json.lookup j "ioPerformance") String.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    }
end

module VolumeStatusAttachmentStatusList = struct
  type t = VolumeStatusAttachmentStatus.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map VolumeStatusAttachmentStatus.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list VolumeStatusAttachmentStatus.to_query v

  let to_json v = `List (List.map VolumeStatusAttachmentStatus.to_json v)

  let of_json j = Aws.Json.to_list VolumeStatusAttachmentStatus.of_json j
end

module VolumeStatusAction = struct
  type t =
    { code : String.t option
    ; description : String.t option
    ; event_id : String.t option
    ; event_type : String.t option
    }

  let make ?code ?description ?event_id ?event_type () =
    { code; description; event_id; event_type }

  let parse xml =
    Some
      { code = Aws.Util.option_bind (Aws.Xml.member "code" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; event_id = Aws.Util.option_bind (Aws.Xml.member "eventId" xml) String.parse
      ; event_type = Aws.Util.option_bind (Aws.Xml.member "eventType" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.event_type (fun f ->
               Aws.Query.Pair ("EventType", String.to_query f))
         ; Aws.Util.option_map v.event_id (fun f ->
               Aws.Query.Pair ("EventId", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair ("Code", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.event_type (fun f -> "eventType", String.to_json f)
         ; Aws.Util.option_map v.event_id (fun f -> "eventId", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Aws.Util.option_map v.code (fun f -> "code", String.to_json f)
         ])

  let of_json j =
    { code = Aws.Util.option_map (Aws.Json.lookup j "code") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; event_id = Aws.Util.option_map (Aws.Json.lookup j "eventId") String.of_json
    ; event_type = Aws.Util.option_map (Aws.Json.lookup j "eventType") String.of_json
    }
end

module VolumeStatusActionsList = struct
  type t = VolumeStatusAction.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map VolumeStatusAction.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list VolumeStatusAction.to_query v

  let to_json v = `List (List.map VolumeStatusAction.to_json v)

  let of_json j = Aws.Json.to_list VolumeStatusAction.of_json j
end

module VolumeStatusItem = struct
  type t =
    { actions : VolumeStatusActionsList.t
    ; availability_zone : String.t option
    ; outpost_arn : String.t option
    ; events : VolumeStatusEventsList.t
    ; volume_id : String.t option
    ; volume_status : VolumeStatusInfo.t option
    ; attachment_statuses : VolumeStatusAttachmentStatusList.t
    }

  let make
      ?(actions = [])
      ?availability_zone
      ?outpost_arn
      ?(events = [])
      ?volume_id
      ?volume_status
      ?(attachment_statuses = [])
      () =
    { actions
    ; availability_zone
    ; outpost_arn
    ; events
    ; volume_id
    ; volume_status
    ; attachment_statuses
    }

  let parse xml =
    Some
      { actions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "actionsSet" xml)
               VolumeStatusActionsList.parse)
      ; availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; outpost_arn = Aws.Util.option_bind (Aws.Xml.member "outpostArn" xml) String.parse
      ; events =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "eventsSet" xml)
               VolumeStatusEventsList.parse)
      ; volume_id = Aws.Util.option_bind (Aws.Xml.member "volumeId" xml) String.parse
      ; volume_status =
          Aws.Util.option_bind (Aws.Xml.member "volumeStatus" xml) VolumeStatusInfo.parse
      ; attachment_statuses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "attachmentStatuses" xml)
               VolumeStatusAttachmentStatusList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "AttachmentStatuses"
                , VolumeStatusAttachmentStatusList.to_query v.attachment_statuses ))
         ; Aws.Util.option_map v.volume_status (fun f ->
               Aws.Query.Pair ("VolumeStatus", VolumeStatusInfo.to_query f))
         ; Aws.Util.option_map v.volume_id (fun f ->
               Aws.Query.Pair ("VolumeId", String.to_query f))
         ; Some (Aws.Query.Pair ("EventsSet", VolumeStatusEventsList.to_query v.events))
         ; Aws.Util.option_map v.outpost_arn (fun f ->
               Aws.Query.Pair ("OutpostArn", String.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ; Some
             (Aws.Query.Pair ("ActionsSet", VolumeStatusActionsList.to_query v.actions))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "attachmentStatuses"
             , VolumeStatusAttachmentStatusList.to_json v.attachment_statuses )
         ; Aws.Util.option_map v.volume_status (fun f ->
               "volumeStatus", VolumeStatusInfo.to_json f)
         ; Aws.Util.option_map v.volume_id (fun f -> "volumeId", String.to_json f)
         ; Some ("eventsSet", VolumeStatusEventsList.to_json v.events)
         ; Aws.Util.option_map v.outpost_arn (fun f -> "outpostArn", String.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ; Some ("actionsSet", VolumeStatusActionsList.to_json v.actions)
         ])

  let of_json j =
    { actions =
        VolumeStatusActionsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "actionsSet"))
    ; availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; outpost_arn = Aws.Util.option_map (Aws.Json.lookup j "outpostArn") String.of_json
    ; events =
        VolumeStatusEventsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "eventsSet"))
    ; volume_id = Aws.Util.option_map (Aws.Json.lookup j "volumeId") String.of_json
    ; volume_status =
        Aws.Util.option_map (Aws.Json.lookup j "volumeStatus") VolumeStatusInfo.of_json
    ; attachment_statuses =
        VolumeStatusAttachmentStatusList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "attachmentStatuses"))
    }
end

module VolumeStatusList = struct
  type t = VolumeStatusItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map VolumeStatusItem.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list VolumeStatusItem.to_query v

  let to_json v = `List (List.map VolumeStatusItem.to_json v)

  let of_json j = Aws.Json.to_list VolumeStatusItem.of_json j
end

module DescribeVolumeStatusResult = struct
  type t =
    { next_token : String.t option
    ; volume_statuses : VolumeStatusList.t
    }

  let make ?next_token ?(volume_statuses = []) () = { next_token; volume_statuses }

  let parse xml =
    Some
      { next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; volume_statuses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "volumeStatusSet" xml)
               VolumeStatusList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("VolumeStatusSet", VolumeStatusList.to_query v.volume_statuses))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("volumeStatusSet", VolumeStatusList.to_json v.volume_statuses)
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ])

  let of_json j =
    { next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; volume_statuses =
        VolumeStatusList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "volumeStatusSet"))
    }
end

module DescribeByoipCidrsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; max_results : Integer.t
    ; next_token : String.t option
    }

  let make ?dry_run ~max_results ?next_token () = { dry_run; max_results; next_token }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; max_results =
          Aws.Xml.required
            "MaxResults"
            (Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("MaxResults", Integer.to_query v.max_results))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("MaxResults", Integer.to_json v.max_results)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; max_results =
        Integer.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "MaxResults"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module IamInstanceProfileAssociationState = struct
  type t =
    | Associating
    | Associated
    | Disassociating
    | Disassociated

  let str_to_t =
    [ "disassociated", Disassociated
    ; "disassociating", Disassociating
    ; "associated", Associated
    ; "associating", Associating
    ]

  let t_to_str =
    [ Disassociated, "disassociated"
    ; Disassociating, "disassociating"
    ; Associated, "associated"
    ; Associating, "associating"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module IamInstanceProfileAssociation = struct
  type t =
    { association_id : String.t option
    ; instance_id : String.t option
    ; iam_instance_profile : IamInstanceProfile.t option
    ; state : IamInstanceProfileAssociationState.t option
    ; timestamp : DateTime.t option
    }

  let make ?association_id ?instance_id ?iam_instance_profile ?state ?timestamp () =
    { association_id; instance_id; iam_instance_profile; state; timestamp }

  let parse xml =
    Some
      { association_id =
          Aws.Util.option_bind (Aws.Xml.member "associationId" xml) String.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      ; iam_instance_profile =
          Aws.Util.option_bind
            (Aws.Xml.member "iamInstanceProfile" xml)
            IamInstanceProfile.parse
      ; state =
          Aws.Util.option_bind
            (Aws.Xml.member "state" xml)
            IamInstanceProfileAssociationState.parse
      ; timestamp = Aws.Util.option_bind (Aws.Xml.member "timestamp" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timestamp (fun f ->
               Aws.Query.Pair ("Timestamp", DateTime.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", IamInstanceProfileAssociationState.to_query f))
         ; Aws.Util.option_map v.iam_instance_profile (fun f ->
               Aws.Query.Pair ("IamInstanceProfile", IamInstanceProfile.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.association_id (fun f ->
               Aws.Query.Pair ("AssociationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timestamp (fun f -> "timestamp", DateTime.to_json f)
         ; Aws.Util.option_map v.state (fun f ->
               "state", IamInstanceProfileAssociationState.to_json f)
         ; Aws.Util.option_map v.iam_instance_profile (fun f ->
               "iamInstanceProfile", IamInstanceProfile.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ; Aws.Util.option_map v.association_id (fun f ->
               "associationId", String.to_json f)
         ])

  let of_json j =
    { association_id =
        Aws.Util.option_map (Aws.Json.lookup j "associationId") String.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    ; iam_instance_profile =
        Aws.Util.option_map
          (Aws.Json.lookup j "iamInstanceProfile")
          IamInstanceProfile.of_json
    ; state =
        Aws.Util.option_map
          (Aws.Json.lookup j "state")
          IamInstanceProfileAssociationState.of_json
    ; timestamp = Aws.Util.option_map (Aws.Json.lookup j "timestamp") DateTime.of_json
    }
end

module ReplaceIamInstanceProfileAssociationResult = struct
  type t = { iam_instance_profile_association : IamInstanceProfileAssociation.t option }

  let make ?iam_instance_profile_association () = { iam_instance_profile_association }

  let parse xml =
    Some
      { iam_instance_profile_association =
          Aws.Util.option_bind
            (Aws.Xml.member "iamInstanceProfileAssociation" xml)
            IamInstanceProfileAssociation.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.iam_instance_profile_association (fun f ->
               Aws.Query.Pair
                 ( "IamInstanceProfileAssociation"
                 , IamInstanceProfileAssociation.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.iam_instance_profile_association (fun f ->
               "iamInstanceProfileAssociation", IamInstanceProfileAssociation.to_json f)
         ])

  let of_json j =
    { iam_instance_profile_association =
        Aws.Util.option_map
          (Aws.Json.lookup j "iamInstanceProfileAssociation")
          IamInstanceProfileAssociation.of_json
    }
end

module DeleteVolumeRequest = struct
  type t =
    { volume_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~volume_id ?dry_run () = { volume_id; dry_run }

  let parse xml =
    Some
      { volume_id =
          Aws.Xml.required
            "VolumeId"
            (Aws.Util.option_bind (Aws.Xml.member "VolumeId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("VolumeId", String.to_query v.volume_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("VolumeId", String.to_json v.volume_id)
         ])

  let of_json j =
    { volume_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VolumeId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module CapacityReservationTarget = struct
  type t =
    { capacity_reservation_id : String.t option
    ; capacity_reservation_resource_group_arn : String.t option
    }

  let make ?capacity_reservation_id ?capacity_reservation_resource_group_arn () =
    { capacity_reservation_id; capacity_reservation_resource_group_arn }

  let parse xml =
    Some
      { capacity_reservation_id =
          Aws.Util.option_bind (Aws.Xml.member "CapacityReservationId" xml) String.parse
      ; capacity_reservation_resource_group_arn =
          Aws.Util.option_bind
            (Aws.Xml.member "CapacityReservationResourceGroupArn" xml)
            String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.capacity_reservation_resource_group_arn (fun f ->
               Aws.Query.Pair ("CapacityReservationResourceGroupArn", String.to_query f))
         ; Aws.Util.option_map v.capacity_reservation_id (fun f ->
               Aws.Query.Pair ("CapacityReservationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.capacity_reservation_resource_group_arn (fun f ->
               "CapacityReservationResourceGroupArn", String.to_json f)
         ; Aws.Util.option_map v.capacity_reservation_id (fun f ->
               "CapacityReservationId", String.to_json f)
         ])

  let of_json j =
    { capacity_reservation_id =
        Aws.Util.option_map (Aws.Json.lookup j "CapacityReservationId") String.of_json
    ; capacity_reservation_resource_group_arn =
        Aws.Util.option_map
          (Aws.Json.lookup j "CapacityReservationResourceGroupArn")
          String.of_json
    }
end

module ModifyVpnConnectionResult = struct
  type t = { vpn_connection : VpnConnection.t option }

  let make ?vpn_connection () = { vpn_connection }

  let parse xml =
    Some
      { vpn_connection =
          Aws.Util.option_bind (Aws.Xml.member "vpnConnection" xml) VpnConnection.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpn_connection (fun f ->
               Aws.Query.Pair ("VpnConnection", VpnConnection.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpn_connection (fun f ->
               "vpnConnection", VpnConnection.to_json f)
         ])

  let of_json j =
    { vpn_connection =
        Aws.Util.option_map (Aws.Json.lookup j "vpnConnection") VpnConnection.of_json
    }
end

module EventType = struct
  type t =
    | InstanceChange
    | FleetRequestChange
    | Error
    | Information

  let str_to_t =
    [ "information", Information
    ; "error", Error
    ; "fleetRequestChange", FleetRequestChange
    ; "instanceChange", InstanceChange
    ]

  let t_to_str =
    [ Information, "information"
    ; Error, "error"
    ; FleetRequestChange, "fleetRequestChange"
    ; InstanceChange, "instanceChange"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DescribeSpotFleetRequestHistoryRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; event_type : EventType.t option
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; spot_fleet_request_id : String.t
    ; start_time : DateTime.t
    }

  let make
      ?dry_run
      ?event_type
      ?max_results
      ?next_token
      ~spot_fleet_request_id
      ~start_time
      () =
    { dry_run; event_type; max_results; next_token; spot_fleet_request_id; start_time }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; event_type = Aws.Util.option_bind (Aws.Xml.member "eventType" xml) EventType.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "maxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; spot_fleet_request_id =
          Aws.Xml.required
            "spotFleetRequestId"
            (Aws.Util.option_bind (Aws.Xml.member "spotFleetRequestId" xml) String.parse)
      ; start_time =
          Aws.Xml.required
            "startTime"
            (Aws.Util.option_bind (Aws.Xml.member "startTime" xml) DateTime.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("StartTime", DateTime.to_query v.start_time))
         ; Some
             (Aws.Query.Pair
                ("SpotFleetRequestId", String.to_query v.spot_fleet_request_id))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.event_type (fun f ->
               Aws.Query.Pair ("EventType", EventType.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("startTime", DateTime.to_json v.start_time)
         ; Some ("spotFleetRequestId", String.to_json v.spot_fleet_request_id)
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "maxResults", Integer.to_json f)
         ; Aws.Util.option_map v.event_type (fun f -> "eventType", EventType.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; event_type = Aws.Util.option_map (Aws.Json.lookup j "eventType") EventType.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "maxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; spot_fleet_request_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "spotFleetRequestId"))
    ; start_time =
        DateTime.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "startTime"))
    }
end

module DisableFastSnapshotRestoreSuccessItem = struct
  type t =
    { snapshot_id : String.t option
    ; availability_zone : String.t option
    ; state : FastSnapshotRestoreStateCode.t option
    ; state_transition_reason : String.t option
    ; owner_id : String.t option
    ; owner_alias : String.t option
    ; enabling_time : DateTime.t option
    ; optimizing_time : DateTime.t option
    ; enabled_time : DateTime.t option
    ; disabling_time : DateTime.t option
    ; disabled_time : DateTime.t option
    }

  let make
      ?snapshot_id
      ?availability_zone
      ?state
      ?state_transition_reason
      ?owner_id
      ?owner_alias
      ?enabling_time
      ?optimizing_time
      ?enabled_time
      ?disabling_time
      ?disabled_time
      () =
    { snapshot_id
    ; availability_zone
    ; state
    ; state_transition_reason
    ; owner_id
    ; owner_alias
    ; enabling_time
    ; optimizing_time
    ; enabled_time
    ; disabling_time
    ; disabled_time
    }

  let parse xml =
    Some
      { snapshot_id = Aws.Util.option_bind (Aws.Xml.member "snapshotId" xml) String.parse
      ; availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; state =
          Aws.Util.option_bind
            (Aws.Xml.member "state" xml)
            FastSnapshotRestoreStateCode.parse
      ; state_transition_reason =
          Aws.Util.option_bind (Aws.Xml.member "stateTransitionReason" xml) String.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; owner_alias = Aws.Util.option_bind (Aws.Xml.member "ownerAlias" xml) String.parse
      ; enabling_time =
          Aws.Util.option_bind (Aws.Xml.member "enablingTime" xml) DateTime.parse
      ; optimizing_time =
          Aws.Util.option_bind (Aws.Xml.member "optimizingTime" xml) DateTime.parse
      ; enabled_time =
          Aws.Util.option_bind (Aws.Xml.member "enabledTime" xml) DateTime.parse
      ; disabling_time =
          Aws.Util.option_bind (Aws.Xml.member "disablingTime" xml) DateTime.parse
      ; disabled_time =
          Aws.Util.option_bind (Aws.Xml.member "disabledTime" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.disabled_time (fun f ->
               Aws.Query.Pair ("DisabledTime", DateTime.to_query f))
         ; Aws.Util.option_map v.disabling_time (fun f ->
               Aws.Query.Pair ("DisablingTime", DateTime.to_query f))
         ; Aws.Util.option_map v.enabled_time (fun f ->
               Aws.Query.Pair ("EnabledTime", DateTime.to_query f))
         ; Aws.Util.option_map v.optimizing_time (fun f ->
               Aws.Query.Pair ("OptimizingTime", DateTime.to_query f))
         ; Aws.Util.option_map v.enabling_time (fun f ->
               Aws.Query.Pair ("EnablingTime", DateTime.to_query f))
         ; Aws.Util.option_map v.owner_alias (fun f ->
               Aws.Query.Pair ("OwnerAlias", String.to_query f))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.state_transition_reason (fun f ->
               Aws.Query.Pair ("StateTransitionReason", String.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", FastSnapshotRestoreStateCode.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ; Aws.Util.option_map v.snapshot_id (fun f ->
               Aws.Query.Pair ("SnapshotId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.disabled_time (fun f ->
               "disabledTime", DateTime.to_json f)
         ; Aws.Util.option_map v.disabling_time (fun f ->
               "disablingTime", DateTime.to_json f)
         ; Aws.Util.option_map v.enabled_time (fun f -> "enabledTime", DateTime.to_json f)
         ; Aws.Util.option_map v.optimizing_time (fun f ->
               "optimizingTime", DateTime.to_json f)
         ; Aws.Util.option_map v.enabling_time (fun f ->
               "enablingTime", DateTime.to_json f)
         ; Aws.Util.option_map v.owner_alias (fun f -> "ownerAlias", String.to_json f)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.state_transition_reason (fun f ->
               "stateTransitionReason", String.to_json f)
         ; Aws.Util.option_map v.state (fun f ->
               "state", FastSnapshotRestoreStateCode.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ; Aws.Util.option_map v.snapshot_id (fun f -> "snapshotId", String.to_json f)
         ])

  let of_json j =
    { snapshot_id = Aws.Util.option_map (Aws.Json.lookup j "snapshotId") String.of_json
    ; availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; state =
        Aws.Util.option_map
          (Aws.Json.lookup j "state")
          FastSnapshotRestoreStateCode.of_json
    ; state_transition_reason =
        Aws.Util.option_map (Aws.Json.lookup j "stateTransitionReason") String.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; owner_alias = Aws.Util.option_map (Aws.Json.lookup j "ownerAlias") String.of_json
    ; enabling_time =
        Aws.Util.option_map (Aws.Json.lookup j "enablingTime") DateTime.of_json
    ; optimizing_time =
        Aws.Util.option_map (Aws.Json.lookup j "optimizingTime") DateTime.of_json
    ; enabled_time =
        Aws.Util.option_map (Aws.Json.lookup j "enabledTime") DateTime.of_json
    ; disabling_time =
        Aws.Util.option_map (Aws.Json.lookup j "disablingTime") DateTime.of_json
    ; disabled_time =
        Aws.Util.option_map (Aws.Json.lookup j "disabledTime") DateTime.of_json
    }
end

module DescribeCustomerGatewaysResult = struct
  type t = { customer_gateways : CustomerGatewayList.t }

  let make ?(customer_gateways = []) () = { customer_gateways }

  let parse xml =
    Some
      { customer_gateways =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "customerGatewaySet" xml)
               CustomerGatewayList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("CustomerGatewaySet", CustomerGatewayList.to_query v.customer_gateways))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("customerGatewaySet", CustomerGatewayList.to_json v.customer_gateways) ])

  let of_json j =
    { customer_gateways =
        CustomerGatewayList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "customerGatewaySet"))
    }
end

module StorageLocation = struct
  type t =
    { bucket : String.t option
    ; key : String.t option
    }

  let make ?bucket ?key () = { bucket; key }

  let parse xml =
    Some
      { bucket = Aws.Util.option_bind (Aws.Xml.member "Bucket" xml) String.parse
      ; key = Aws.Util.option_bind (Aws.Xml.member "Key" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.key (fun f -> Aws.Query.Pair ("Key", String.to_query f))
         ; Aws.Util.option_map v.bucket (fun f ->
               Aws.Query.Pair ("Bucket", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.key (fun f -> "Key", String.to_json f)
         ; Aws.Util.option_map v.bucket (fun f -> "Bucket", String.to_json f)
         ])

  let of_json j =
    { bucket = Aws.Util.option_map (Aws.Json.lookup j "Bucket") String.of_json
    ; key = Aws.Util.option_map (Aws.Json.lookup j "Key") String.of_json
    }
end

module ImportImageResult = struct
  type t =
    { architecture : String.t option
    ; description : String.t option
    ; encrypted : Boolean.t option
    ; hypervisor : String.t option
    ; image_id : String.t option
    ; import_task_id : String.t option
    ; kms_key_id : String.t option
    ; license_type : String.t option
    ; platform : String.t option
    ; progress : String.t option
    ; snapshot_details : SnapshotDetailList.t
    ; status : String.t option
    ; status_message : String.t option
    ; license_specifications : ImportImageLicenseSpecificationListResponse.t
    ; tags : TagList.t
    }

  let make
      ?architecture
      ?description
      ?encrypted
      ?hypervisor
      ?image_id
      ?import_task_id
      ?kms_key_id
      ?license_type
      ?platform
      ?progress
      ?(snapshot_details = [])
      ?status
      ?status_message
      ?(license_specifications = [])
      ?(tags = [])
      () =
    { architecture
    ; description
    ; encrypted
    ; hypervisor
    ; image_id
    ; import_task_id
    ; kms_key_id
    ; license_type
    ; platform
    ; progress
    ; snapshot_details
    ; status
    ; status_message
    ; license_specifications
    ; tags
    }

  let parse xml =
    Some
      { architecture =
          Aws.Util.option_bind (Aws.Xml.member "architecture" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; encrypted = Aws.Util.option_bind (Aws.Xml.member "encrypted" xml) Boolean.parse
      ; hypervisor = Aws.Util.option_bind (Aws.Xml.member "hypervisor" xml) String.parse
      ; image_id = Aws.Util.option_bind (Aws.Xml.member "imageId" xml) String.parse
      ; import_task_id =
          Aws.Util.option_bind (Aws.Xml.member "importTaskId" xml) String.parse
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "kmsKeyId" xml) String.parse
      ; license_type =
          Aws.Util.option_bind (Aws.Xml.member "licenseType" xml) String.parse
      ; platform = Aws.Util.option_bind (Aws.Xml.member "platform" xml) String.parse
      ; progress = Aws.Util.option_bind (Aws.Xml.member "progress" xml) String.parse
      ; snapshot_details =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "snapshotDetailSet" xml)
               SnapshotDetailList.parse)
      ; status = Aws.Util.option_bind (Aws.Xml.member "status" xml) String.parse
      ; status_message =
          Aws.Util.option_bind (Aws.Xml.member "statusMessage" xml) String.parse
      ; license_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "licenseSpecifications" xml)
               ImportImageLicenseSpecificationListResponse.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Some
             (Aws.Query.Pair
                ( "LicenseSpecifications"
                , ImportImageLicenseSpecificationListResponse.to_query
                    v.license_specifications ))
         ; Aws.Util.option_map v.status_message (fun f ->
               Aws.Query.Pair ("StatusMessage", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("SnapshotDetailSet", SnapshotDetailList.to_query v.snapshot_details))
         ; Aws.Util.option_map v.progress (fun f ->
               Aws.Query.Pair ("Progress", String.to_query f))
         ; Aws.Util.option_map v.platform (fun f ->
               Aws.Query.Pair ("Platform", String.to_query f))
         ; Aws.Util.option_map v.license_type (fun f ->
               Aws.Query.Pair ("LicenseType", String.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Aws.Util.option_map v.import_task_id (fun f ->
               Aws.Query.Pair ("ImportTaskId", String.to_query f))
         ; Aws.Util.option_map v.image_id (fun f ->
               Aws.Query.Pair ("ImageId", String.to_query f))
         ; Aws.Util.option_map v.hypervisor (fun f ->
               Aws.Query.Pair ("Hypervisor", String.to_query f))
         ; Aws.Util.option_map v.encrypted (fun f ->
               Aws.Query.Pair ("Encrypted", Boolean.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.architecture (fun f ->
               Aws.Query.Pair ("Architecture", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Some
             ( "licenseSpecifications"
             , ImportImageLicenseSpecificationListResponse.to_json
                 v.license_specifications )
         ; Aws.Util.option_map v.status_message (fun f ->
               "statusMessage", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "status", String.to_json f)
         ; Some ("snapshotDetailSet", SnapshotDetailList.to_json v.snapshot_details)
         ; Aws.Util.option_map v.progress (fun f -> "progress", String.to_json f)
         ; Aws.Util.option_map v.platform (fun f -> "platform", String.to_json f)
         ; Aws.Util.option_map v.license_type (fun f -> "licenseType", String.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "kmsKeyId", String.to_json f)
         ; Aws.Util.option_map v.import_task_id (fun f ->
               "importTaskId", String.to_json f)
         ; Aws.Util.option_map v.image_id (fun f -> "imageId", String.to_json f)
         ; Aws.Util.option_map v.hypervisor (fun f -> "hypervisor", String.to_json f)
         ; Aws.Util.option_map v.encrypted (fun f -> "encrypted", Boolean.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Aws.Util.option_map v.architecture (fun f -> "architecture", String.to_json f)
         ])

  let of_json j =
    { architecture = Aws.Util.option_map (Aws.Json.lookup j "architecture") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; encrypted = Aws.Util.option_map (Aws.Json.lookup j "encrypted") Boolean.of_json
    ; hypervisor = Aws.Util.option_map (Aws.Json.lookup j "hypervisor") String.of_json
    ; image_id = Aws.Util.option_map (Aws.Json.lookup j "imageId") String.of_json
    ; import_task_id =
        Aws.Util.option_map (Aws.Json.lookup j "importTaskId") String.of_json
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "kmsKeyId") String.of_json
    ; license_type = Aws.Util.option_map (Aws.Json.lookup j "licenseType") String.of_json
    ; platform = Aws.Util.option_map (Aws.Json.lookup j "platform") String.of_json
    ; progress = Aws.Util.option_map (Aws.Json.lookup j "progress") String.of_json
    ; snapshot_details =
        SnapshotDetailList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "snapshotDetailSet"))
    ; status = Aws.Util.option_map (Aws.Json.lookup j "status") String.of_json
    ; status_message =
        Aws.Util.option_map (Aws.Json.lookup j "statusMessage") String.of_json
    ; license_specifications =
        ImportImageLicenseSpecificationListResponse.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "licenseSpecifications"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module StartInstancesRequest = struct
  type t =
    { instance_ids : InstanceIdStringList.t
    ; additional_info : String.t option
    ; dry_run : Boolean.t option
    }

  let make ~instance_ids ?additional_info ?dry_run () =
    { instance_ids; additional_info; dry_run }

  let parse xml =
    Some
      { instance_ids =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind
               (Aws.Xml.member "InstanceId" xml)
               InstanceIdStringList.parse)
      ; additional_info =
          Aws.Util.option_bind (Aws.Xml.member "additionalInfo" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.additional_info (fun f ->
               Aws.Query.Pair ("AdditionalInfo", String.to_query f))
         ; Some
             (Aws.Query.Pair ("InstanceId", InstanceIdStringList.to_query v.instance_ids))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.additional_info (fun f ->
               "additionalInfo", String.to_json f)
         ; Some ("InstanceId", InstanceIdStringList.to_json v.instance_ids)
         ])

  let of_json j =
    { instance_ids =
        InstanceIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; additional_info =
        Aws.Util.option_map (Aws.Json.lookup j "additionalInfo") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module ServiceType = struct
  type t =
    | Interface
    | Gateway
    | GatewayLoadBalancer

  let str_to_t =
    [ "GatewayLoadBalancer", GatewayLoadBalancer
    ; "Gateway", Gateway
    ; "Interface", Interface
    ]

  let t_to_str =
    [ GatewayLoadBalancer, "GatewayLoadBalancer"
    ; Gateway, "Gateway"
    ; Interface, "Interface"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ServiceTypeDetail = struct
  type t = { service_type : ServiceType.t option }

  let make ?service_type () = { service_type }

  let parse xml =
    Some
      { service_type =
          Aws.Util.option_bind (Aws.Xml.member "serviceType" xml) ServiceType.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.service_type (fun f ->
               Aws.Query.Pair ("ServiceType", ServiceType.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.service_type (fun f ->
               "serviceType", ServiceType.to_json f)
         ])

  let of_json j =
    { service_type =
        Aws.Util.option_map (Aws.Json.lookup j "serviceType") ServiceType.of_json
    }
end

module DescribeCoipPoolsRequest = struct
  type t =
    { pool_ids : CoipPoolIdSet.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make ?(pool_ids = []) ?(filters = []) ?max_results ?next_token ?dry_run () =
    { pool_ids; filters; max_results; next_token; dry_run }

  let parse xml =
    Some
      { pool_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "PoolId" xml) CoipPoolIdSet.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some (Aws.Query.Pair ("PoolId", CoipPoolIdSet.to_query v.pool_ids))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some ("PoolId", CoipPoolIdSet.to_json v.pool_ids)
         ])

  let of_json j =
    { pool_ids =
        CoipPoolIdSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PoolId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module AvailabilityZoneState = struct
  type t =
    | Available
    | Information
    | Impaired
    | Unavailable

  let str_to_t =
    [ "unavailable", Unavailable
    ; "impaired", Impaired
    ; "information", Information
    ; "available", Available
    ]

  let t_to_str =
    [ Unavailable, "unavailable"
    ; Impaired, "impaired"
    ; Information, "information"
    ; Available, "available"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module AvailabilityZoneMessage = struct
  type t = { message : String.t option }

  let make ?message () = { message }

  let parse xml =
    Some { message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f) ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json }
end

module AvailabilityZoneMessageList = struct
  type t = AvailabilityZoneMessage.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map AvailabilityZoneMessage.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list AvailabilityZoneMessage.to_query v

  let to_json v = `List (List.map AvailabilityZoneMessage.to_json v)

  let of_json j = Aws.Json.to_list AvailabilityZoneMessage.of_json j
end

module AvailabilityZone = struct
  type t =
    { state : AvailabilityZoneState.t option
    ; opt_in_status : AvailabilityZoneOptInStatus.t option
    ; messages : AvailabilityZoneMessageList.t
    ; region_name : String.t option
    ; zone_name : String.t option
    ; zone_id : String.t option
    ; group_name : String.t option
    ; network_border_group : String.t option
    ; zone_type : String.t option
    ; parent_zone_name : String.t option
    ; parent_zone_id : String.t option
    }

  let make
      ?state
      ?opt_in_status
      ?(messages = [])
      ?region_name
      ?zone_name
      ?zone_id
      ?group_name
      ?network_border_group
      ?zone_type
      ?parent_zone_name
      ?parent_zone_id
      () =
    { state
    ; opt_in_status
    ; messages
    ; region_name
    ; zone_name
    ; zone_id
    ; group_name
    ; network_border_group
    ; zone_type
    ; parent_zone_name
    ; parent_zone_id
    }

  let parse xml =
    Some
      { state =
          Aws.Util.option_bind
            (Aws.Xml.member "zoneState" xml)
            AvailabilityZoneState.parse
      ; opt_in_status =
          Aws.Util.option_bind
            (Aws.Xml.member "optInStatus" xml)
            AvailabilityZoneOptInStatus.parse
      ; messages =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "messageSet" xml)
               AvailabilityZoneMessageList.parse)
      ; region_name = Aws.Util.option_bind (Aws.Xml.member "regionName" xml) String.parse
      ; zone_name = Aws.Util.option_bind (Aws.Xml.member "zoneName" xml) String.parse
      ; zone_id = Aws.Util.option_bind (Aws.Xml.member "zoneId" xml) String.parse
      ; group_name = Aws.Util.option_bind (Aws.Xml.member "groupName" xml) String.parse
      ; network_border_group =
          Aws.Util.option_bind (Aws.Xml.member "networkBorderGroup" xml) String.parse
      ; zone_type = Aws.Util.option_bind (Aws.Xml.member "zoneType" xml) String.parse
      ; parent_zone_name =
          Aws.Util.option_bind (Aws.Xml.member "parentZoneName" xml) String.parse
      ; parent_zone_id =
          Aws.Util.option_bind (Aws.Xml.member "parentZoneId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.parent_zone_id (fun f ->
               Aws.Query.Pair ("ParentZoneId", String.to_query f))
         ; Aws.Util.option_map v.parent_zone_name (fun f ->
               Aws.Query.Pair ("ParentZoneName", String.to_query f))
         ; Aws.Util.option_map v.zone_type (fun f ->
               Aws.Query.Pair ("ZoneType", String.to_query f))
         ; Aws.Util.option_map v.network_border_group (fun f ->
               Aws.Query.Pair ("NetworkBorderGroup", String.to_query f))
         ; Aws.Util.option_map v.group_name (fun f ->
               Aws.Query.Pair ("GroupName", String.to_query f))
         ; Aws.Util.option_map v.zone_id (fun f ->
               Aws.Query.Pair ("ZoneId", String.to_query f))
         ; Aws.Util.option_map v.zone_name (fun f ->
               Aws.Query.Pair ("ZoneName", String.to_query f))
         ; Aws.Util.option_map v.region_name (fun f ->
               Aws.Query.Pair ("RegionName", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("MessageSet", AvailabilityZoneMessageList.to_query v.messages))
         ; Aws.Util.option_map v.opt_in_status (fun f ->
               Aws.Query.Pair ("OptInStatus", AvailabilityZoneOptInStatus.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("ZoneState", AvailabilityZoneState.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.parent_zone_id (fun f ->
               "parentZoneId", String.to_json f)
         ; Aws.Util.option_map v.parent_zone_name (fun f ->
               "parentZoneName", String.to_json f)
         ; Aws.Util.option_map v.zone_type (fun f -> "zoneType", String.to_json f)
         ; Aws.Util.option_map v.network_border_group (fun f ->
               "networkBorderGroup", String.to_json f)
         ; Aws.Util.option_map v.group_name (fun f -> "groupName", String.to_json f)
         ; Aws.Util.option_map v.zone_id (fun f -> "zoneId", String.to_json f)
         ; Aws.Util.option_map v.zone_name (fun f -> "zoneName", String.to_json f)
         ; Aws.Util.option_map v.region_name (fun f -> "regionName", String.to_json f)
         ; Some ("messageSet", AvailabilityZoneMessageList.to_json v.messages)
         ; Aws.Util.option_map v.opt_in_status (fun f ->
               "optInStatus", AvailabilityZoneOptInStatus.to_json f)
         ; Aws.Util.option_map v.state (fun f ->
               "zoneState", AvailabilityZoneState.to_json f)
         ])

  let of_json j =
    { state =
        Aws.Util.option_map (Aws.Json.lookup j "zoneState") AvailabilityZoneState.of_json
    ; opt_in_status =
        Aws.Util.option_map
          (Aws.Json.lookup j "optInStatus")
          AvailabilityZoneOptInStatus.of_json
    ; messages =
        AvailabilityZoneMessageList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "messageSet"))
    ; region_name = Aws.Util.option_map (Aws.Json.lookup j "regionName") String.of_json
    ; zone_name = Aws.Util.option_map (Aws.Json.lookup j "zoneName") String.of_json
    ; zone_id = Aws.Util.option_map (Aws.Json.lookup j "zoneId") String.of_json
    ; group_name = Aws.Util.option_map (Aws.Json.lookup j "groupName") String.of_json
    ; network_border_group =
        Aws.Util.option_map (Aws.Json.lookup j "networkBorderGroup") String.of_json
    ; zone_type = Aws.Util.option_map (Aws.Json.lookup j "zoneType") String.of_json
    ; parent_zone_name =
        Aws.Util.option_map (Aws.Json.lookup j "parentZoneName") String.of_json
    ; parent_zone_id =
        Aws.Util.option_map (Aws.Json.lookup j "parentZoneId") String.of_json
    }
end

module AvailabilityZoneList = struct
  type t = AvailabilityZone.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map AvailabilityZone.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list AvailabilityZone.to_query v

  let to_json v = `List (List.map AvailabilityZone.to_json v)

  let of_json j = Aws.Json.to_list AvailabilityZone.of_json j
end

module DescribeAvailabilityZonesResult = struct
  type t = { availability_zones : AvailabilityZoneList.t }

  let make ?(availability_zones = []) () = { availability_zones }

  let parse xml =
    Some
      { availability_zones =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "availabilityZoneInfo" xml)
               AvailabilityZoneList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "AvailabilityZoneInfo"
                , AvailabilityZoneList.to_query v.availability_zones ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("availabilityZoneInfo", AvailabilityZoneList.to_json v.availability_zones)
         ])

  let of_json j =
    { availability_zones =
        AvailabilityZoneList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "availabilityZoneInfo"))
    }
end

module EnableEbsEncryptionByDefaultRequest = struct
  type t = { dry_run : Boolean.t option }

  let make ?dry_run () = { dry_run }

  let parse xml =
    Some { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f) ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json }
end

module InstanceAttributeName = struct
  type t =
    | InstanceType
    | Kernel
    | Ramdisk
    | UserData
    | DisableApiTermination
    | InstanceInitiatedShutdownBehavior
    | RootDeviceName
    | BlockDeviceMapping
    | ProductCodes
    | SourceDestCheck
    | GroupSet
    | EbsOptimized
    | SriovNetSupport
    | EnaSupport
    | EnclaveOptions

  let str_to_t =
    [ "enclaveOptions", EnclaveOptions
    ; "enaSupport", EnaSupport
    ; "sriovNetSupport", SriovNetSupport
    ; "ebsOptimized", EbsOptimized
    ; "groupSet", GroupSet
    ; "sourceDestCheck", SourceDestCheck
    ; "productCodes", ProductCodes
    ; "blockDeviceMapping", BlockDeviceMapping
    ; "rootDeviceName", RootDeviceName
    ; "instanceInitiatedShutdownBehavior", InstanceInitiatedShutdownBehavior
    ; "disableApiTermination", DisableApiTermination
    ; "userData", UserData
    ; "ramdisk", Ramdisk
    ; "kernel", Kernel
    ; "instanceType", InstanceType
    ]

  let t_to_str =
    [ EnclaveOptions, "enclaveOptions"
    ; EnaSupport, "enaSupport"
    ; SriovNetSupport, "sriovNetSupport"
    ; EbsOptimized, "ebsOptimized"
    ; GroupSet, "groupSet"
    ; SourceDestCheck, "sourceDestCheck"
    ; ProductCodes, "productCodes"
    ; BlockDeviceMapping, "blockDeviceMapping"
    ; RootDeviceName, "rootDeviceName"
    ; InstanceInitiatedShutdownBehavior, "instanceInitiatedShutdownBehavior"
    ; DisableApiTermination, "disableApiTermination"
    ; UserData, "userData"
    ; Ramdisk, "ramdisk"
    ; Kernel, "kernel"
    ; InstanceType, "instanceType"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DeleteNetworkInterfaceRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; network_interface_id : String.t
    }

  let make ?dry_run ~network_interface_id () = { dry_run; network_interface_id }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; network_interface_id =
          Aws.Xml.required
            "networkInterfaceId"
            (Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("NetworkInterfaceId", String.to_query v.network_interface_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("networkInterfaceId", String.to_json v.network_interface_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; network_interface_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "networkInterfaceId"))
    }
end

module CapacityReservationSpecification = struct
  type t =
    { capacity_reservation_preference : CapacityReservationPreference.t option
    ; capacity_reservation_target : CapacityReservationTarget.t option
    }

  let make ?capacity_reservation_preference ?capacity_reservation_target () =
    { capacity_reservation_preference; capacity_reservation_target }

  let parse xml =
    Some
      { capacity_reservation_preference =
          Aws.Util.option_bind
            (Aws.Xml.member "CapacityReservationPreference" xml)
            CapacityReservationPreference.parse
      ; capacity_reservation_target =
          Aws.Util.option_bind
            (Aws.Xml.member "CapacityReservationTarget" xml)
            CapacityReservationTarget.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.capacity_reservation_target (fun f ->
               Aws.Query.Pair
                 ("CapacityReservationTarget", CapacityReservationTarget.to_query f))
         ; Aws.Util.option_map v.capacity_reservation_preference (fun f ->
               Aws.Query.Pair
                 ( "CapacityReservationPreference"
                 , CapacityReservationPreference.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.capacity_reservation_target (fun f ->
               "CapacityReservationTarget", CapacityReservationTarget.to_json f)
         ; Aws.Util.option_map v.capacity_reservation_preference (fun f ->
               "CapacityReservationPreference", CapacityReservationPreference.to_json f)
         ])

  let of_json j =
    { capacity_reservation_preference =
        Aws.Util.option_map
          (Aws.Json.lookup j "CapacityReservationPreference")
          CapacityReservationPreference.of_json
    ; capacity_reservation_target =
        Aws.Util.option_map
          (Aws.Json.lookup j "CapacityReservationTarget")
          CapacityReservationTarget.of_json
    }
end

module CapacityReservationTenancy = struct
  type t =
    | Default
    | Dedicated

  let str_to_t = [ "dedicated", Dedicated; "default", Default ]

  let t_to_str = [ Dedicated, "dedicated"; Default, "default" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module CreateRouteTableResult = struct
  type t = { route_table : RouteTable.t option }

  let make ?route_table () = { route_table }

  let parse xml =
    Some
      { route_table =
          Aws.Util.option_bind (Aws.Xml.member "routeTable" xml) RouteTable.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.route_table (fun f ->
               Aws.Query.Pair ("RouteTable", RouteTable.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.route_table (fun f -> "routeTable", RouteTable.to_json f)
         ])

  let of_json j =
    { route_table =
        Aws.Util.option_map (Aws.Json.lookup j "routeTable") RouteTable.of_json
    }
end

module DisassociateIamInstanceProfileResult = struct
  type t = { iam_instance_profile_association : IamInstanceProfileAssociation.t option }

  let make ?iam_instance_profile_association () = { iam_instance_profile_association }

  let parse xml =
    Some
      { iam_instance_profile_association =
          Aws.Util.option_bind
            (Aws.Xml.member "iamInstanceProfileAssociation" xml)
            IamInstanceProfileAssociation.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.iam_instance_profile_association (fun f ->
               Aws.Query.Pair
                 ( "IamInstanceProfileAssociation"
                 , IamInstanceProfileAssociation.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.iam_instance_profile_association (fun f ->
               "iamInstanceProfileAssociation", IamInstanceProfileAssociation.to_json f)
         ])

  let of_json j =
    { iam_instance_profile_association =
        Aws.Util.option_map
          (Aws.Json.lookup j "iamInstanceProfileAssociation")
          IamInstanceProfileAssociation.of_json
    }
end

module NetworkAclAssociation = struct
  type t =
    { network_acl_association_id : String.t option
    ; network_acl_id : String.t option
    ; subnet_id : String.t option
    }

  let make ?network_acl_association_id ?network_acl_id ?subnet_id () =
    { network_acl_association_id; network_acl_id; subnet_id }

  let parse xml =
    Some
      { network_acl_association_id =
          Aws.Util.option_bind (Aws.Xml.member "networkAclAssociationId" xml) String.parse
      ; network_acl_id =
          Aws.Util.option_bind (Aws.Xml.member "networkAclId" xml) String.parse
      ; subnet_id = Aws.Util.option_bind (Aws.Xml.member "subnetId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.subnet_id (fun f ->
               Aws.Query.Pair ("SubnetId", String.to_query f))
         ; Aws.Util.option_map v.network_acl_id (fun f ->
               Aws.Query.Pair ("NetworkAclId", String.to_query f))
         ; Aws.Util.option_map v.network_acl_association_id (fun f ->
               Aws.Query.Pair ("NetworkAclAssociationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.subnet_id (fun f -> "subnetId", String.to_json f)
         ; Aws.Util.option_map v.network_acl_id (fun f ->
               "networkAclId", String.to_json f)
         ; Aws.Util.option_map v.network_acl_association_id (fun f ->
               "networkAclAssociationId", String.to_json f)
         ])

  let of_json j =
    { network_acl_association_id =
        Aws.Util.option_map (Aws.Json.lookup j "networkAclAssociationId") String.of_json
    ; network_acl_id =
        Aws.Util.option_map (Aws.Json.lookup j "networkAclId") String.of_json
    ; subnet_id = Aws.Util.option_map (Aws.Json.lookup j "subnetId") String.of_json
    }
end

module NetworkAclAssociationList = struct
  type t = NetworkAclAssociation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map NetworkAclAssociation.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list NetworkAclAssociation.to_query v

  let to_json v = `List (List.map NetworkAclAssociation.to_json v)

  let of_json j = Aws.Json.to_list NetworkAclAssociation.of_json j
end

module NetworkAcl = struct
  type t =
    { associations : NetworkAclAssociationList.t
    ; entries : NetworkAclEntryList.t
    ; is_default : Boolean.t option
    ; network_acl_id : String.t option
    ; tags : TagList.t
    ; vpc_id : String.t option
    ; owner_id : String.t option
    }

  let make
      ?(associations = [])
      ?(entries = [])
      ?is_default
      ?network_acl_id
      ?(tags = [])
      ?vpc_id
      ?owner_id
      () =
    { associations; entries; is_default; network_acl_id; tags; vpc_id; owner_id }

  let parse xml =
    Some
      { associations =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "associationSet" xml)
               NetworkAclAssociationList.parse)
      ; entries =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "entrySet" xml)
               NetworkAclEntryList.parse)
      ; is_default = Aws.Util.option_bind (Aws.Xml.member "default" xml) Boolean.parse
      ; network_acl_id =
          Aws.Util.option_bind (Aws.Xml.member "networkAclId" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.network_acl_id (fun f ->
               Aws.Query.Pair ("NetworkAclId", String.to_query f))
         ; Aws.Util.option_map v.is_default (fun f ->
               Aws.Query.Pair ("Default", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("EntrySet", NetworkAclEntryList.to_query v.entries))
         ; Some
             (Aws.Query.Pair
                ("AssociationSet", NetworkAclAssociationList.to_query v.associations))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.vpc_id (fun f -> "vpcId", String.to_json f)
         ; Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.network_acl_id (fun f ->
               "networkAclId", String.to_json f)
         ; Aws.Util.option_map v.is_default (fun f -> "default", Boolean.to_json f)
         ; Some ("entrySet", NetworkAclEntryList.to_json v.entries)
         ; Some ("associationSet", NetworkAclAssociationList.to_json v.associations)
         ])

  let of_json j =
    { associations =
        NetworkAclAssociationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "associationSet"))
    ; entries =
        NetworkAclEntryList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "entrySet"))
    ; is_default = Aws.Util.option_map (Aws.Json.lookup j "default") Boolean.of_json
    ; network_acl_id =
        Aws.Util.option_map (Aws.Json.lookup j "networkAclId") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "vpcId") String.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    }
end

module CreateNetworkAclResult = struct
  type t = { network_acl : NetworkAcl.t option }

  let make ?network_acl () = { network_acl }

  let parse xml =
    Some
      { network_acl =
          Aws.Util.option_bind (Aws.Xml.member "networkAcl" xml) NetworkAcl.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.network_acl (fun f ->
               Aws.Query.Pair ("NetworkAcl", NetworkAcl.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.network_acl (fun f -> "networkAcl", NetworkAcl.to_json f)
         ])

  let of_json j =
    { network_acl =
        Aws.Util.option_map (Aws.Json.lookup j "networkAcl") NetworkAcl.of_json
    }
end

module ClientVpnConnection = struct
  type t =
    { client_vpn_endpoint_id : String.t option
    ; timestamp : String.t option
    ; connection_id : String.t option
    ; username : String.t option
    ; connection_established_time : String.t option
    ; ingress_bytes : String.t option
    ; egress_bytes : String.t option
    ; ingress_packets : String.t option
    ; egress_packets : String.t option
    ; client_ip : String.t option
    ; common_name : String.t option
    ; status : ClientVpnConnectionStatus.t option
    ; connection_end_time : String.t option
    ; posture_compliance_statuses : ValueStringList.t
    }

  let make
      ?client_vpn_endpoint_id
      ?timestamp
      ?connection_id
      ?username
      ?connection_established_time
      ?ingress_bytes
      ?egress_bytes
      ?ingress_packets
      ?egress_packets
      ?client_ip
      ?common_name
      ?status
      ?connection_end_time
      ?(posture_compliance_statuses = [])
      () =
    { client_vpn_endpoint_id
    ; timestamp
    ; connection_id
    ; username
    ; connection_established_time
    ; ingress_bytes
    ; egress_bytes
    ; ingress_packets
    ; egress_packets
    ; client_ip
    ; common_name
    ; status
    ; connection_end_time
    ; posture_compliance_statuses
    }

  let parse xml =
    Some
      { client_vpn_endpoint_id =
          Aws.Util.option_bind (Aws.Xml.member "clientVpnEndpointId" xml) String.parse
      ; timestamp = Aws.Util.option_bind (Aws.Xml.member "timestamp" xml) String.parse
      ; connection_id =
          Aws.Util.option_bind (Aws.Xml.member "connectionId" xml) String.parse
      ; username = Aws.Util.option_bind (Aws.Xml.member "username" xml) String.parse
      ; connection_established_time =
          Aws.Util.option_bind
            (Aws.Xml.member "connectionEstablishedTime" xml)
            String.parse
      ; ingress_bytes =
          Aws.Util.option_bind (Aws.Xml.member "ingressBytes" xml) String.parse
      ; egress_bytes =
          Aws.Util.option_bind (Aws.Xml.member "egressBytes" xml) String.parse
      ; ingress_packets =
          Aws.Util.option_bind (Aws.Xml.member "ingressPackets" xml) String.parse
      ; egress_packets =
          Aws.Util.option_bind (Aws.Xml.member "egressPackets" xml) String.parse
      ; client_ip = Aws.Util.option_bind (Aws.Xml.member "clientIp" xml) String.parse
      ; common_name = Aws.Util.option_bind (Aws.Xml.member "commonName" xml) String.parse
      ; status =
          Aws.Util.option_bind
            (Aws.Xml.member "status" xml)
            ClientVpnConnectionStatus.parse
      ; connection_end_time =
          Aws.Util.option_bind (Aws.Xml.member "connectionEndTime" xml) String.parse
      ; posture_compliance_statuses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "postureComplianceStatusSet" xml)
               ValueStringList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "PostureComplianceStatusSet"
                , ValueStringList.to_query v.posture_compliance_statuses ))
         ; Aws.Util.option_map v.connection_end_time (fun f ->
               Aws.Query.Pair ("ConnectionEndTime", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", ClientVpnConnectionStatus.to_query f))
         ; Aws.Util.option_map v.common_name (fun f ->
               Aws.Query.Pair ("CommonName", String.to_query f))
         ; Aws.Util.option_map v.client_ip (fun f ->
               Aws.Query.Pair ("ClientIp", String.to_query f))
         ; Aws.Util.option_map v.egress_packets (fun f ->
               Aws.Query.Pair ("EgressPackets", String.to_query f))
         ; Aws.Util.option_map v.ingress_packets (fun f ->
               Aws.Query.Pair ("IngressPackets", String.to_query f))
         ; Aws.Util.option_map v.egress_bytes (fun f ->
               Aws.Query.Pair ("EgressBytes", String.to_query f))
         ; Aws.Util.option_map v.ingress_bytes (fun f ->
               Aws.Query.Pair ("IngressBytes", String.to_query f))
         ; Aws.Util.option_map v.connection_established_time (fun f ->
               Aws.Query.Pair ("ConnectionEstablishedTime", String.to_query f))
         ; Aws.Util.option_map v.username (fun f ->
               Aws.Query.Pair ("Username", String.to_query f))
         ; Aws.Util.option_map v.connection_id (fun f ->
               Aws.Query.Pair ("ConnectionId", String.to_query f))
         ; Aws.Util.option_map v.timestamp (fun f ->
               Aws.Query.Pair ("Timestamp", String.to_query f))
         ; Aws.Util.option_map v.client_vpn_endpoint_id (fun f ->
               Aws.Query.Pair ("ClientVpnEndpointId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "postureComplianceStatusSet"
             , ValueStringList.to_json v.posture_compliance_statuses )
         ; Aws.Util.option_map v.connection_end_time (fun f ->
               "connectionEndTime", String.to_json f)
         ; Aws.Util.option_map v.status (fun f ->
               "status", ClientVpnConnectionStatus.to_json f)
         ; Aws.Util.option_map v.common_name (fun f -> "commonName", String.to_json f)
         ; Aws.Util.option_map v.client_ip (fun f -> "clientIp", String.to_json f)
         ; Aws.Util.option_map v.egress_packets (fun f ->
               "egressPackets", String.to_json f)
         ; Aws.Util.option_map v.ingress_packets (fun f ->
               "ingressPackets", String.to_json f)
         ; Aws.Util.option_map v.egress_bytes (fun f -> "egressBytes", String.to_json f)
         ; Aws.Util.option_map v.ingress_bytes (fun f -> "ingressBytes", String.to_json f)
         ; Aws.Util.option_map v.connection_established_time (fun f ->
               "connectionEstablishedTime", String.to_json f)
         ; Aws.Util.option_map v.username (fun f -> "username", String.to_json f)
         ; Aws.Util.option_map v.connection_id (fun f -> "connectionId", String.to_json f)
         ; Aws.Util.option_map v.timestamp (fun f -> "timestamp", String.to_json f)
         ; Aws.Util.option_map v.client_vpn_endpoint_id (fun f ->
               "clientVpnEndpointId", String.to_json f)
         ])

  let of_json j =
    { client_vpn_endpoint_id =
        Aws.Util.option_map (Aws.Json.lookup j "clientVpnEndpointId") String.of_json
    ; timestamp = Aws.Util.option_map (Aws.Json.lookup j "timestamp") String.of_json
    ; connection_id =
        Aws.Util.option_map (Aws.Json.lookup j "connectionId") String.of_json
    ; username = Aws.Util.option_map (Aws.Json.lookup j "username") String.of_json
    ; connection_established_time =
        Aws.Util.option_map (Aws.Json.lookup j "connectionEstablishedTime") String.of_json
    ; ingress_bytes =
        Aws.Util.option_map (Aws.Json.lookup j "ingressBytes") String.of_json
    ; egress_bytes = Aws.Util.option_map (Aws.Json.lookup j "egressBytes") String.of_json
    ; ingress_packets =
        Aws.Util.option_map (Aws.Json.lookup j "ingressPackets") String.of_json
    ; egress_packets =
        Aws.Util.option_map (Aws.Json.lookup j "egressPackets") String.of_json
    ; client_ip = Aws.Util.option_map (Aws.Json.lookup j "clientIp") String.of_json
    ; common_name = Aws.Util.option_map (Aws.Json.lookup j "commonName") String.of_json
    ; status =
        Aws.Util.option_map (Aws.Json.lookup j "status") ClientVpnConnectionStatus.of_json
    ; connection_end_time =
        Aws.Util.option_map (Aws.Json.lookup j "connectionEndTime") String.of_json
    ; posture_compliance_statuses =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "postureComplianceStatusSet"))
    }
end

module PurchaseRequest = struct
  type t =
    { instance_count : Integer.t
    ; purchase_token : String.t
    }

  let make ~instance_count ~purchase_token () = { instance_count; purchase_token }

  let parse xml =
    Some
      { instance_count =
          Aws.Xml.required
            "InstanceCount"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceCount" xml) Integer.parse)
      ; purchase_token =
          Aws.Xml.required
            "PurchaseToken"
            (Aws.Util.option_bind (Aws.Xml.member "PurchaseToken" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("PurchaseToken", String.to_query v.purchase_token))
         ; Some (Aws.Query.Pair ("InstanceCount", Integer.to_query v.instance_count))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("PurchaseToken", String.to_json v.purchase_token)
         ; Some ("InstanceCount", Integer.to_json v.instance_count)
         ])

  let of_json j =
    { instance_count =
        Integer.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceCount"))
    ; purchase_token =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PurchaseToken"))
    }
end

module PurchaseRequestSet = struct
  type t = PurchaseRequest.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map PurchaseRequest.parse (Aws.Xml.members "PurchaseRequest" xml))

  let to_query v = Aws.Query.to_query_list PurchaseRequest.to_query v

  let to_json v = `List (List.map PurchaseRequest.to_json v)

  let of_json j = Aws.Json.to_list PurchaseRequest.of_json j
end

module PurchaseScheduledInstancesRequest = struct
  type t =
    { client_token : String.t option
    ; dry_run : Boolean.t option
    ; purchase_requests : PurchaseRequestSet.t
    }

  let make ?client_token ?dry_run ~purchase_requests () =
    { client_token; dry_run; purchase_requests }

  let parse xml =
    Some
      { client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; purchase_requests =
          Aws.Xml.required
            "PurchaseRequest"
            (Aws.Util.option_bind
               (Aws.Xml.member "PurchaseRequest" xml)
               PurchaseRequestSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("PurchaseRequest", PurchaseRequestSet.to_query v.purchase_requests))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("PurchaseRequest", PurchaseRequestSet.to_json v.purchase_requests)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ])

  let of_json j =
    { client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; purchase_requests =
        PurchaseRequestSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "PurchaseRequest"))
    }
end

module VolumeAttributeName = struct
  type t =
    | AutoEnableIO
    | ProductCodes

  let str_to_t = [ "productCodes", ProductCodes; "autoEnableIO", AutoEnableIO ]

  let t_to_str = [ ProductCodes, "productCodes"; AutoEnableIO, "autoEnableIO" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DescribeVolumeAttributeRequest = struct
  type t =
    { attribute : VolumeAttributeName.t
    ; volume_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~attribute ~volume_id ?dry_run () = { attribute; volume_id; dry_run }

  let parse xml =
    Some
      { attribute =
          Aws.Xml.required
            "Attribute"
            (Aws.Util.option_bind
               (Aws.Xml.member "Attribute" xml)
               VolumeAttributeName.parse)
      ; volume_id =
          Aws.Xml.required
            "VolumeId"
            (Aws.Util.option_bind (Aws.Xml.member "VolumeId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("VolumeId", String.to_query v.volume_id))
         ; Some (Aws.Query.Pair ("Attribute", VolumeAttributeName.to_query v.attribute))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("VolumeId", String.to_json v.volume_id)
         ; Some ("Attribute", VolumeAttributeName.to_json v.attribute)
         ])

  let of_json j =
    { attribute =
        VolumeAttributeName.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Attribute"))
    ; volume_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VolumeId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module VolumeModification = struct
  type t =
    { volume_id : String.t option
    ; modification_state : VolumeModificationState.t option
    ; status_message : String.t option
    ; target_size : Integer.t option
    ; target_iops : Integer.t option
    ; target_volume_type : VolumeType.t option
    ; original_size : Integer.t option
    ; original_iops : Integer.t option
    ; original_volume_type : VolumeType.t option
    ; progress : Long.t option
    ; start_time : DateTime.t option
    ; end_time : DateTime.t option
    }

  let make
      ?volume_id
      ?modification_state
      ?status_message
      ?target_size
      ?target_iops
      ?target_volume_type
      ?original_size
      ?original_iops
      ?original_volume_type
      ?progress
      ?start_time
      ?end_time
      () =
    { volume_id
    ; modification_state
    ; status_message
    ; target_size
    ; target_iops
    ; target_volume_type
    ; original_size
    ; original_iops
    ; original_volume_type
    ; progress
    ; start_time
    ; end_time
    }

  let parse xml =
    Some
      { volume_id = Aws.Util.option_bind (Aws.Xml.member "volumeId" xml) String.parse
      ; modification_state =
          Aws.Util.option_bind
            (Aws.Xml.member "modificationState" xml)
            VolumeModificationState.parse
      ; status_message =
          Aws.Util.option_bind (Aws.Xml.member "statusMessage" xml) String.parse
      ; target_size = Aws.Util.option_bind (Aws.Xml.member "targetSize" xml) Integer.parse
      ; target_iops = Aws.Util.option_bind (Aws.Xml.member "targetIops" xml) Integer.parse
      ; target_volume_type =
          Aws.Util.option_bind (Aws.Xml.member "targetVolumeType" xml) VolumeType.parse
      ; original_size =
          Aws.Util.option_bind (Aws.Xml.member "originalSize" xml) Integer.parse
      ; original_iops =
          Aws.Util.option_bind (Aws.Xml.member "originalIops" xml) Integer.parse
      ; original_volume_type =
          Aws.Util.option_bind (Aws.Xml.member "originalVolumeType" xml) VolumeType.parse
      ; progress = Aws.Util.option_bind (Aws.Xml.member "progress" xml) Long.parse
      ; start_time = Aws.Util.option_bind (Aws.Xml.member "startTime" xml) DateTime.parse
      ; end_time = Aws.Util.option_bind (Aws.Xml.member "endTime" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.end_time (fun f ->
               Aws.Query.Pair ("EndTime", DateTime.to_query f))
         ; Aws.Util.option_map v.start_time (fun f ->
               Aws.Query.Pair ("StartTime", DateTime.to_query f))
         ; Aws.Util.option_map v.progress (fun f ->
               Aws.Query.Pair ("Progress", Long.to_query f))
         ; Aws.Util.option_map v.original_volume_type (fun f ->
               Aws.Query.Pair ("OriginalVolumeType", VolumeType.to_query f))
         ; Aws.Util.option_map v.original_iops (fun f ->
               Aws.Query.Pair ("OriginalIops", Integer.to_query f))
         ; Aws.Util.option_map v.original_size (fun f ->
               Aws.Query.Pair ("OriginalSize", Integer.to_query f))
         ; Aws.Util.option_map v.target_volume_type (fun f ->
               Aws.Query.Pair ("TargetVolumeType", VolumeType.to_query f))
         ; Aws.Util.option_map v.target_iops (fun f ->
               Aws.Query.Pair ("TargetIops", Integer.to_query f))
         ; Aws.Util.option_map v.target_size (fun f ->
               Aws.Query.Pair ("TargetSize", Integer.to_query f))
         ; Aws.Util.option_map v.status_message (fun f ->
               Aws.Query.Pair ("StatusMessage", String.to_query f))
         ; Aws.Util.option_map v.modification_state (fun f ->
               Aws.Query.Pair ("ModificationState", VolumeModificationState.to_query f))
         ; Aws.Util.option_map v.volume_id (fun f ->
               Aws.Query.Pair ("VolumeId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.end_time (fun f -> "endTime", DateTime.to_json f)
         ; Aws.Util.option_map v.start_time (fun f -> "startTime", DateTime.to_json f)
         ; Aws.Util.option_map v.progress (fun f -> "progress", Long.to_json f)
         ; Aws.Util.option_map v.original_volume_type (fun f ->
               "originalVolumeType", VolumeType.to_json f)
         ; Aws.Util.option_map v.original_iops (fun f ->
               "originalIops", Integer.to_json f)
         ; Aws.Util.option_map v.original_size (fun f ->
               "originalSize", Integer.to_json f)
         ; Aws.Util.option_map v.target_volume_type (fun f ->
               "targetVolumeType", VolumeType.to_json f)
         ; Aws.Util.option_map v.target_iops (fun f -> "targetIops", Integer.to_json f)
         ; Aws.Util.option_map v.target_size (fun f -> "targetSize", Integer.to_json f)
         ; Aws.Util.option_map v.status_message (fun f ->
               "statusMessage", String.to_json f)
         ; Aws.Util.option_map v.modification_state (fun f ->
               "modificationState", VolumeModificationState.to_json f)
         ; Aws.Util.option_map v.volume_id (fun f -> "volumeId", String.to_json f)
         ])

  let of_json j =
    { volume_id = Aws.Util.option_map (Aws.Json.lookup j "volumeId") String.of_json
    ; modification_state =
        Aws.Util.option_map
          (Aws.Json.lookup j "modificationState")
          VolumeModificationState.of_json
    ; status_message =
        Aws.Util.option_map (Aws.Json.lookup j "statusMessage") String.of_json
    ; target_size = Aws.Util.option_map (Aws.Json.lookup j "targetSize") Integer.of_json
    ; target_iops = Aws.Util.option_map (Aws.Json.lookup j "targetIops") Integer.of_json
    ; target_volume_type =
        Aws.Util.option_map (Aws.Json.lookup j "targetVolumeType") VolumeType.of_json
    ; original_size =
        Aws.Util.option_map (Aws.Json.lookup j "originalSize") Integer.of_json
    ; original_iops =
        Aws.Util.option_map (Aws.Json.lookup j "originalIops") Integer.of_json
    ; original_volume_type =
        Aws.Util.option_map (Aws.Json.lookup j "originalVolumeType") VolumeType.of_json
    ; progress = Aws.Util.option_map (Aws.Json.lookup j "progress") Long.of_json
    ; start_time = Aws.Util.option_map (Aws.Json.lookup j "startTime") DateTime.of_json
    ; end_time = Aws.Util.option_map (Aws.Json.lookup j "endTime") DateTime.of_json
    }
end

module DescribeFpgaImageAttributeRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; fpga_image_id : String.t
    ; attribute : FpgaImageAttributeName.t
    }

  let make ?dry_run ~fpga_image_id ~attribute () = { dry_run; fpga_image_id; attribute }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; fpga_image_id =
          Aws.Xml.required
            "FpgaImageId"
            (Aws.Util.option_bind (Aws.Xml.member "FpgaImageId" xml) String.parse)
      ; attribute =
          Aws.Xml.required
            "Attribute"
            (Aws.Util.option_bind
               (Aws.Xml.member "Attribute" xml)
               FpgaImageAttributeName.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("Attribute", FpgaImageAttributeName.to_query v.attribute))
         ; Some (Aws.Query.Pair ("FpgaImageId", String.to_query v.fpga_image_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Attribute", FpgaImageAttributeName.to_json v.attribute)
         ; Some ("FpgaImageId", String.to_json v.fpga_image_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; fpga_image_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "FpgaImageId"))
    ; attribute =
        FpgaImageAttributeName.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Attribute"))
    }
end

module ImportVolumeResult = struct
  type t = { conversion_task : ConversionTask.t option }

  let make ?conversion_task () = { conversion_task }

  let parse xml =
    Some
      { conversion_task =
          Aws.Util.option_bind (Aws.Xml.member "conversionTask" xml) ConversionTask.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.conversion_task (fun f ->
               Aws.Query.Pair ("ConversionTask", ConversionTask.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.conversion_task (fun f ->
               "conversionTask", ConversionTask.to_json f)
         ])

  let of_json j =
    { conversion_task =
        Aws.Util.option_map (Aws.Json.lookup j "conversionTask") ConversionTask.of_json
    }
end

module SpotMaintenanceStrategies = struct
  type t = { capacity_rebalance : SpotCapacityRebalance.t option }

  let make ?capacity_rebalance () = { capacity_rebalance }

  let parse xml =
    Some
      { capacity_rebalance =
          Aws.Util.option_bind
            (Aws.Xml.member "capacityRebalance" xml)
            SpotCapacityRebalance.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.capacity_rebalance (fun f ->
               Aws.Query.Pair ("CapacityRebalance", SpotCapacityRebalance.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.capacity_rebalance (fun f ->
               "capacityRebalance", SpotCapacityRebalance.to_json f)
         ])

  let of_json j =
    { capacity_rebalance =
        Aws.Util.option_map
          (Aws.Json.lookup j "capacityRebalance")
          SpotCapacityRebalance.of_json
    }
end

module TargetGroup = struct
  type t = { arn : String.t option }

  let make ?arn () = { arn }

  let parse xml =
    Some { arn = Aws.Util.option_bind (Aws.Xml.member "arn" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.arn (fun f -> Aws.Query.Pair ("Arn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.arn (fun f -> "arn", String.to_json f) ])

  let of_json j = { arn = Aws.Util.option_map (Aws.Json.lookup j "arn") String.of_json }
end

module TargetGroups = struct
  type t = TargetGroup.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map TargetGroup.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list TargetGroup.to_query v

  let to_json v = `List (List.map TargetGroup.to_json v)

  let of_json j = Aws.Json.to_list TargetGroup.of_json j
end

module TargetGroupsConfig = struct
  type t = { target_groups : TargetGroups.t }

  let make ?(target_groups = []) () = { target_groups }

  let parse xml =
    Some
      { target_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "targetGroups" xml) TargetGroups.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TargetGroups", TargetGroups.to_query v.target_groups)) ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("targetGroups", TargetGroups.to_json v.target_groups) ])

  let of_json j =
    { target_groups =
        TargetGroups.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "targetGroups"))
    }
end

module ClassicLoadBalancer = struct
  type t = { name : String.t option }

  let make ?name () = { name }

  let parse xml =
    Some { name = Aws.Util.option_bind (Aws.Xml.member "name" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.name (fun f -> "name", String.to_json f) ])

  let of_json j = { name = Aws.Util.option_map (Aws.Json.lookup j "name") String.of_json }
end

module ClassicLoadBalancers = struct
  type t = ClassicLoadBalancer.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ClassicLoadBalancer.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ClassicLoadBalancer.to_query v

  let to_json v = `List (List.map ClassicLoadBalancer.to_json v)

  let of_json j = Aws.Json.to_list ClassicLoadBalancer.of_json j
end

module ClassicLoadBalancersConfig = struct
  type t = { classic_load_balancers : ClassicLoadBalancers.t }

  let make ?(classic_load_balancers = []) () = { classic_load_balancers }

  let parse xml =
    Some
      { classic_load_balancers =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "classicLoadBalancers" xml)
               ClassicLoadBalancers.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "ClassicLoadBalancers"
                , ClassicLoadBalancers.to_query v.classic_load_balancers ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "classicLoadBalancers"
             , ClassicLoadBalancers.to_json v.classic_load_balancers )
         ])

  let of_json j =
    { classic_load_balancers =
        ClassicLoadBalancers.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "classicLoadBalancers"))
    }
end

module LoadBalancersConfig = struct
  type t =
    { classic_load_balancers_config : ClassicLoadBalancersConfig.t option
    ; target_groups_config : TargetGroupsConfig.t option
    }

  let make ?classic_load_balancers_config ?target_groups_config () =
    { classic_load_balancers_config; target_groups_config }

  let parse xml =
    Some
      { classic_load_balancers_config =
          Aws.Util.option_bind
            (Aws.Xml.member "classicLoadBalancersConfig" xml)
            ClassicLoadBalancersConfig.parse
      ; target_groups_config =
          Aws.Util.option_bind
            (Aws.Xml.member "targetGroupsConfig" xml)
            TargetGroupsConfig.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.target_groups_config (fun f ->
               Aws.Query.Pair ("TargetGroupsConfig", TargetGroupsConfig.to_query f))
         ; Aws.Util.option_map v.classic_load_balancers_config (fun f ->
               Aws.Query.Pair
                 ("ClassicLoadBalancersConfig", ClassicLoadBalancersConfig.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.target_groups_config (fun f ->
               "targetGroupsConfig", TargetGroupsConfig.to_json f)
         ; Aws.Util.option_map v.classic_load_balancers_config (fun f ->
               "classicLoadBalancersConfig", ClassicLoadBalancersConfig.to_json f)
         ])

  let of_json j =
    { classic_load_balancers_config =
        Aws.Util.option_map
          (Aws.Json.lookup j "classicLoadBalancersConfig")
          ClassicLoadBalancersConfig.of_json
    ; target_groups_config =
        Aws.Util.option_map
          (Aws.Json.lookup j "targetGroupsConfig")
          TargetGroupsConfig.of_json
    }
end

module LaunchSpecsList = struct
  type t = SpotFleetLaunchSpecification.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map SpotFleetLaunchSpecification.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list SpotFleetLaunchSpecification.to_query v

  let to_json v = `List (List.map SpotFleetLaunchSpecification.to_json v)

  let of_json j = Aws.Json.to_list SpotFleetLaunchSpecification.of_json j
end

module FleetType = struct
  type t =
    | Request
    | Maintain
    | Instant

  let str_to_t = [ "instant", Instant; "maintain", Maintain; "request", Request ]

  let t_to_str = [ Instant, "instant"; Maintain, "maintain"; Request, "request" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module AllocationStrategy = struct
  type t =
    | LowestPrice
    | Diversified
    | CapacityOptimized

  let str_to_t =
    [ "capacityOptimized", CapacityOptimized
    ; "diversified", Diversified
    ; "lowestPrice", LowestPrice
    ]

  let t_to_str =
    [ CapacityOptimized, "capacityOptimized"
    ; Diversified, "diversified"
    ; LowestPrice, "lowestPrice"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module SpotFleetRequestConfigData = struct
  type t =
    { allocation_strategy : AllocationStrategy.t option
    ; on_demand_allocation_strategy : OnDemandAllocationStrategy.t option
    ; spot_maintenance_strategies : SpotMaintenanceStrategies.t option
    ; client_token : String.t option
    ; excess_capacity_termination_policy : ExcessCapacityTerminationPolicy.t option
    ; fulfilled_capacity : Double.t option
    ; on_demand_fulfilled_capacity : Double.t option
    ; iam_fleet_role : String.t
    ; launch_specifications : LaunchSpecsList.t
    ; launch_template_configs : LaunchTemplateConfigList.t
    ; spot_price : String.t option
    ; target_capacity : Integer.t
    ; on_demand_target_capacity : Integer.t option
    ; on_demand_max_total_price : String.t option
    ; spot_max_total_price : String.t option
    ; terminate_instances_with_expiration : Boolean.t option
    ; type_ : FleetType.t option
    ; valid_from : DateTime.t option
    ; valid_until : DateTime.t option
    ; replace_unhealthy_instances : Boolean.t option
    ; instance_interruption_behavior : InstanceInterruptionBehavior.t option
    ; load_balancers_config : LoadBalancersConfig.t option
    ; instance_pools_to_use_count : Integer.t option
    ; tag_specifications : TagSpecificationList.t
    }

  let make
      ?allocation_strategy
      ?on_demand_allocation_strategy
      ?spot_maintenance_strategies
      ?client_token
      ?excess_capacity_termination_policy
      ?fulfilled_capacity
      ?on_demand_fulfilled_capacity
      ~iam_fleet_role
      ?(launch_specifications = [])
      ?(launch_template_configs = [])
      ?spot_price
      ~target_capacity
      ?on_demand_target_capacity
      ?on_demand_max_total_price
      ?spot_max_total_price
      ?terminate_instances_with_expiration
      ?type_
      ?valid_from
      ?valid_until
      ?replace_unhealthy_instances
      ?instance_interruption_behavior
      ?load_balancers_config
      ?instance_pools_to_use_count
      ?(tag_specifications = [])
      () =
    { allocation_strategy
    ; on_demand_allocation_strategy
    ; spot_maintenance_strategies
    ; client_token
    ; excess_capacity_termination_policy
    ; fulfilled_capacity
    ; on_demand_fulfilled_capacity
    ; iam_fleet_role
    ; launch_specifications
    ; launch_template_configs
    ; spot_price
    ; target_capacity
    ; on_demand_target_capacity
    ; on_demand_max_total_price
    ; spot_max_total_price
    ; terminate_instances_with_expiration
    ; type_
    ; valid_from
    ; valid_until
    ; replace_unhealthy_instances
    ; instance_interruption_behavior
    ; load_balancers_config
    ; instance_pools_to_use_count
    ; tag_specifications
    }

  let parse xml =
    Some
      { allocation_strategy =
          Aws.Util.option_bind
            (Aws.Xml.member "allocationStrategy" xml)
            AllocationStrategy.parse
      ; on_demand_allocation_strategy =
          Aws.Util.option_bind
            (Aws.Xml.member "onDemandAllocationStrategy" xml)
            OnDemandAllocationStrategy.parse
      ; spot_maintenance_strategies =
          Aws.Util.option_bind
            (Aws.Xml.member "spotMaintenanceStrategies" xml)
            SpotMaintenanceStrategies.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "clientToken" xml) String.parse
      ; excess_capacity_termination_policy =
          Aws.Util.option_bind
            (Aws.Xml.member "excessCapacityTerminationPolicy" xml)
            ExcessCapacityTerminationPolicy.parse
      ; fulfilled_capacity =
          Aws.Util.option_bind (Aws.Xml.member "fulfilledCapacity" xml) Double.parse
      ; on_demand_fulfilled_capacity =
          Aws.Util.option_bind
            (Aws.Xml.member "onDemandFulfilledCapacity" xml)
            Double.parse
      ; iam_fleet_role =
          Aws.Xml.required
            "iamFleetRole"
            (Aws.Util.option_bind (Aws.Xml.member "iamFleetRole" xml) String.parse)
      ; launch_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "launchSpecifications" xml)
               LaunchSpecsList.parse)
      ; launch_template_configs =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "launchTemplateConfigs" xml)
               LaunchTemplateConfigList.parse)
      ; spot_price = Aws.Util.option_bind (Aws.Xml.member "spotPrice" xml) String.parse
      ; target_capacity =
          Aws.Xml.required
            "targetCapacity"
            (Aws.Util.option_bind (Aws.Xml.member "targetCapacity" xml) Integer.parse)
      ; on_demand_target_capacity =
          Aws.Util.option_bind (Aws.Xml.member "onDemandTargetCapacity" xml) Integer.parse
      ; on_demand_max_total_price =
          Aws.Util.option_bind (Aws.Xml.member "onDemandMaxTotalPrice" xml) String.parse
      ; spot_max_total_price =
          Aws.Util.option_bind (Aws.Xml.member "spotMaxTotalPrice" xml) String.parse
      ; terminate_instances_with_expiration =
          Aws.Util.option_bind
            (Aws.Xml.member "terminateInstancesWithExpiration" xml)
            Boolean.parse
      ; type_ = Aws.Util.option_bind (Aws.Xml.member "type" xml) FleetType.parse
      ; valid_from = Aws.Util.option_bind (Aws.Xml.member "validFrom" xml) DateTime.parse
      ; valid_until =
          Aws.Util.option_bind (Aws.Xml.member "validUntil" xml) DateTime.parse
      ; replace_unhealthy_instances =
          Aws.Util.option_bind
            (Aws.Xml.member "replaceUnhealthyInstances" xml)
            Boolean.parse
      ; instance_interruption_behavior =
          Aws.Util.option_bind
            (Aws.Xml.member "instanceInterruptionBehavior" xml)
            InstanceInterruptionBehavior.parse
      ; load_balancers_config =
          Aws.Util.option_bind
            (Aws.Xml.member "loadBalancersConfig" xml)
            LoadBalancersConfig.parse
      ; instance_pools_to_use_count =
          Aws.Util.option_bind
            (Aws.Xml.member "instancePoolsToUseCount" xml)
            Integer.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Aws.Util.option_map v.instance_pools_to_use_count (fun f ->
               Aws.Query.Pair ("InstancePoolsToUseCount", Integer.to_query f))
         ; Aws.Util.option_map v.load_balancers_config (fun f ->
               Aws.Query.Pair ("LoadBalancersConfig", LoadBalancersConfig.to_query f))
         ; Aws.Util.option_map v.instance_interruption_behavior (fun f ->
               Aws.Query.Pair
                 ("InstanceInterruptionBehavior", InstanceInterruptionBehavior.to_query f))
         ; Aws.Util.option_map v.replace_unhealthy_instances (fun f ->
               Aws.Query.Pair ("ReplaceUnhealthyInstances", Boolean.to_query f))
         ; Aws.Util.option_map v.valid_until (fun f ->
               Aws.Query.Pair ("ValidUntil", DateTime.to_query f))
         ; Aws.Util.option_map v.valid_from (fun f ->
               Aws.Query.Pair ("ValidFrom", DateTime.to_query f))
         ; Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", FleetType.to_query f))
         ; Aws.Util.option_map v.terminate_instances_with_expiration (fun f ->
               Aws.Query.Pair ("TerminateInstancesWithExpiration", Boolean.to_query f))
         ; Aws.Util.option_map v.spot_max_total_price (fun f ->
               Aws.Query.Pair ("SpotMaxTotalPrice", String.to_query f))
         ; Aws.Util.option_map v.on_demand_max_total_price (fun f ->
               Aws.Query.Pair ("OnDemandMaxTotalPrice", String.to_query f))
         ; Aws.Util.option_map v.on_demand_target_capacity (fun f ->
               Aws.Query.Pair ("OnDemandTargetCapacity", Integer.to_query f))
         ; Some (Aws.Query.Pair ("TargetCapacity", Integer.to_query v.target_capacity))
         ; Aws.Util.option_map v.spot_price (fun f ->
               Aws.Query.Pair ("SpotPrice", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "LaunchTemplateConfigs"
                , LaunchTemplateConfigList.to_query v.launch_template_configs ))
         ; Some
             (Aws.Query.Pair
                ("LaunchSpecifications", LaunchSpecsList.to_query v.launch_specifications))
         ; Some (Aws.Query.Pair ("IamFleetRole", String.to_query v.iam_fleet_role))
         ; Aws.Util.option_map v.on_demand_fulfilled_capacity (fun f ->
               Aws.Query.Pair ("OnDemandFulfilledCapacity", Double.to_query f))
         ; Aws.Util.option_map v.fulfilled_capacity (fun f ->
               Aws.Query.Pair ("FulfilledCapacity", Double.to_query f))
         ; Aws.Util.option_map v.excess_capacity_termination_policy (fun f ->
               Aws.Query.Pair
                 ( "ExcessCapacityTerminationPolicy"
                 , ExcessCapacityTerminationPolicy.to_query f ))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.spot_maintenance_strategies (fun f ->
               Aws.Query.Pair
                 ("SpotMaintenanceStrategies", SpotMaintenanceStrategies.to_query f))
         ; Aws.Util.option_map v.on_demand_allocation_strategy (fun f ->
               Aws.Query.Pair
                 ("OnDemandAllocationStrategy", OnDemandAllocationStrategy.to_query f))
         ; Aws.Util.option_map v.allocation_strategy (fun f ->
               Aws.Query.Pair ("AllocationStrategy", AllocationStrategy.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Aws.Util.option_map v.instance_pools_to_use_count (fun f ->
               "instancePoolsToUseCount", Integer.to_json f)
         ; Aws.Util.option_map v.load_balancers_config (fun f ->
               "loadBalancersConfig", LoadBalancersConfig.to_json f)
         ; Aws.Util.option_map v.instance_interruption_behavior (fun f ->
               "instanceInterruptionBehavior", InstanceInterruptionBehavior.to_json f)
         ; Aws.Util.option_map v.replace_unhealthy_instances (fun f ->
               "replaceUnhealthyInstances", Boolean.to_json f)
         ; Aws.Util.option_map v.valid_until (fun f -> "validUntil", DateTime.to_json f)
         ; Aws.Util.option_map v.valid_from (fun f -> "validFrom", DateTime.to_json f)
         ; Aws.Util.option_map v.type_ (fun f -> "type", FleetType.to_json f)
         ; Aws.Util.option_map v.terminate_instances_with_expiration (fun f ->
               "terminateInstancesWithExpiration", Boolean.to_json f)
         ; Aws.Util.option_map v.spot_max_total_price (fun f ->
               "spotMaxTotalPrice", String.to_json f)
         ; Aws.Util.option_map v.on_demand_max_total_price (fun f ->
               "onDemandMaxTotalPrice", String.to_json f)
         ; Aws.Util.option_map v.on_demand_target_capacity (fun f ->
               "onDemandTargetCapacity", Integer.to_json f)
         ; Some ("targetCapacity", Integer.to_json v.target_capacity)
         ; Aws.Util.option_map v.spot_price (fun f -> "spotPrice", String.to_json f)
         ; Some
             ( "launchTemplateConfigs"
             , LaunchTemplateConfigList.to_json v.launch_template_configs )
         ; Some ("launchSpecifications", LaunchSpecsList.to_json v.launch_specifications)
         ; Some ("iamFleetRole", String.to_json v.iam_fleet_role)
         ; Aws.Util.option_map v.on_demand_fulfilled_capacity (fun f ->
               "onDemandFulfilledCapacity", Double.to_json f)
         ; Aws.Util.option_map v.fulfilled_capacity (fun f ->
               "fulfilledCapacity", Double.to_json f)
         ; Aws.Util.option_map v.excess_capacity_termination_policy (fun f ->
               ( "excessCapacityTerminationPolicy"
               , ExcessCapacityTerminationPolicy.to_json f ))
         ; Aws.Util.option_map v.client_token (fun f -> "clientToken", String.to_json f)
         ; Aws.Util.option_map v.spot_maintenance_strategies (fun f ->
               "spotMaintenanceStrategies", SpotMaintenanceStrategies.to_json f)
         ; Aws.Util.option_map v.on_demand_allocation_strategy (fun f ->
               "onDemandAllocationStrategy", OnDemandAllocationStrategy.to_json f)
         ; Aws.Util.option_map v.allocation_strategy (fun f ->
               "allocationStrategy", AllocationStrategy.to_json f)
         ])

  let of_json j =
    { allocation_strategy =
        Aws.Util.option_map
          (Aws.Json.lookup j "allocationStrategy")
          AllocationStrategy.of_json
    ; on_demand_allocation_strategy =
        Aws.Util.option_map
          (Aws.Json.lookup j "onDemandAllocationStrategy")
          OnDemandAllocationStrategy.of_json
    ; spot_maintenance_strategies =
        Aws.Util.option_map
          (Aws.Json.lookup j "spotMaintenanceStrategies")
          SpotMaintenanceStrategies.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "clientToken") String.of_json
    ; excess_capacity_termination_policy =
        Aws.Util.option_map
          (Aws.Json.lookup j "excessCapacityTerminationPolicy")
          ExcessCapacityTerminationPolicy.of_json
    ; fulfilled_capacity =
        Aws.Util.option_map (Aws.Json.lookup j "fulfilledCapacity") Double.of_json
    ; on_demand_fulfilled_capacity =
        Aws.Util.option_map (Aws.Json.lookup j "onDemandFulfilledCapacity") Double.of_json
    ; iam_fleet_role =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "iamFleetRole"))
    ; launch_specifications =
        LaunchSpecsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "launchSpecifications"))
    ; launch_template_configs =
        LaunchTemplateConfigList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "launchTemplateConfigs"))
    ; spot_price = Aws.Util.option_map (Aws.Json.lookup j "spotPrice") String.of_json
    ; target_capacity =
        Integer.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "targetCapacity"))
    ; on_demand_target_capacity =
        Aws.Util.option_map (Aws.Json.lookup j "onDemandTargetCapacity") Integer.of_json
    ; on_demand_max_total_price =
        Aws.Util.option_map (Aws.Json.lookup j "onDemandMaxTotalPrice") String.of_json
    ; spot_max_total_price =
        Aws.Util.option_map (Aws.Json.lookup j "spotMaxTotalPrice") String.of_json
    ; terminate_instances_with_expiration =
        Aws.Util.option_map
          (Aws.Json.lookup j "terminateInstancesWithExpiration")
          Boolean.of_json
    ; type_ = Aws.Util.option_map (Aws.Json.lookup j "type") FleetType.of_json
    ; valid_from = Aws.Util.option_map (Aws.Json.lookup j "validFrom") DateTime.of_json
    ; valid_until = Aws.Util.option_map (Aws.Json.lookup j "validUntil") DateTime.of_json
    ; replace_unhealthy_instances =
        Aws.Util.option_map
          (Aws.Json.lookup j "replaceUnhealthyInstances")
          Boolean.of_json
    ; instance_interruption_behavior =
        Aws.Util.option_map
          (Aws.Json.lookup j "instanceInterruptionBehavior")
          InstanceInterruptionBehavior.of_json
    ; load_balancers_config =
        Aws.Util.option_map
          (Aws.Json.lookup j "loadBalancersConfig")
          LoadBalancersConfig.of_json
    ; instance_pools_to_use_count =
        Aws.Util.option_map (Aws.Json.lookup j "instancePoolsToUseCount") Integer.of_json
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    }
end

module ActivityStatus = struct
  type t =
    | Error
    | Pending_fulfillment
    | Pending_termination
    | Fulfilled

  let str_to_t =
    [ "fulfilled", Fulfilled
    ; "pending_termination", Pending_termination
    ; "pending_fulfillment", Pending_fulfillment
    ; "error", Error
    ]

  let t_to_str =
    [ Fulfilled, "fulfilled"
    ; Pending_termination, "pending_termination"
    ; Pending_fulfillment, "pending_fulfillment"
    ; Error, "error"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module SpotFleetRequestConfig = struct
  type t =
    { activity_status : ActivityStatus.t option
    ; create_time : DateTime.t option
    ; spot_fleet_request_config : SpotFleetRequestConfigData.t option
    ; spot_fleet_request_id : String.t option
    ; spot_fleet_request_state : BatchState.t option
    ; tags : TagList.t
    }

  let make
      ?activity_status
      ?create_time
      ?spot_fleet_request_config
      ?spot_fleet_request_id
      ?spot_fleet_request_state
      ?(tags = [])
      () =
    { activity_status
    ; create_time
    ; spot_fleet_request_config
    ; spot_fleet_request_id
    ; spot_fleet_request_state
    ; tags
    }

  let parse xml =
    Some
      { activity_status =
          Aws.Util.option_bind (Aws.Xml.member "activityStatus" xml) ActivityStatus.parse
      ; create_time =
          Aws.Util.option_bind (Aws.Xml.member "createTime" xml) DateTime.parse
      ; spot_fleet_request_config =
          Aws.Util.option_bind
            (Aws.Xml.member "spotFleetRequestConfig" xml)
            SpotFleetRequestConfigData.parse
      ; spot_fleet_request_id =
          Aws.Util.option_bind (Aws.Xml.member "spotFleetRequestId" xml) String.parse
      ; spot_fleet_request_state =
          Aws.Util.option_bind
            (Aws.Xml.member "spotFleetRequestState" xml)
            BatchState.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.spot_fleet_request_state (fun f ->
               Aws.Query.Pair ("SpotFleetRequestState", BatchState.to_query f))
         ; Aws.Util.option_map v.spot_fleet_request_id (fun f ->
               Aws.Query.Pair ("SpotFleetRequestId", String.to_query f))
         ; Aws.Util.option_map v.spot_fleet_request_config (fun f ->
               Aws.Query.Pair
                 ("SpotFleetRequestConfig", SpotFleetRequestConfigData.to_query f))
         ; Aws.Util.option_map v.create_time (fun f ->
               Aws.Query.Pair ("CreateTime", DateTime.to_query f))
         ; Aws.Util.option_map v.activity_status (fun f ->
               Aws.Query.Pair ("ActivityStatus", ActivityStatus.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.spot_fleet_request_state (fun f ->
               "spotFleetRequestState", BatchState.to_json f)
         ; Aws.Util.option_map v.spot_fleet_request_id (fun f ->
               "spotFleetRequestId", String.to_json f)
         ; Aws.Util.option_map v.spot_fleet_request_config (fun f ->
               "spotFleetRequestConfig", SpotFleetRequestConfigData.to_json f)
         ; Aws.Util.option_map v.create_time (fun f -> "createTime", DateTime.to_json f)
         ; Aws.Util.option_map v.activity_status (fun f ->
               "activityStatus", ActivityStatus.to_json f)
         ])

  let of_json j =
    { activity_status =
        Aws.Util.option_map (Aws.Json.lookup j "activityStatus") ActivityStatus.of_json
    ; create_time = Aws.Util.option_map (Aws.Json.lookup j "createTime") DateTime.of_json
    ; spot_fleet_request_config =
        Aws.Util.option_map
          (Aws.Json.lookup j "spotFleetRequestConfig")
          SpotFleetRequestConfigData.of_json
    ; spot_fleet_request_id =
        Aws.Util.option_map (Aws.Json.lookup j "spotFleetRequestId") String.of_json
    ; spot_fleet_request_state =
        Aws.Util.option_map (Aws.Json.lookup j "spotFleetRequestState") BatchState.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module SpotFleetRequestConfigSet = struct
  type t = SpotFleetRequestConfig.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map SpotFleetRequestConfig.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list SpotFleetRequestConfig.to_query v

  let to_json v = `List (List.map SpotFleetRequestConfig.to_json v)

  let of_json j = Aws.Json.to_list SpotFleetRequestConfig.of_json j
end

module DescribeSpotFleetRequestsResponse = struct
  type t =
    { next_token : String.t option
    ; spot_fleet_request_configs : SpotFleetRequestConfigSet.t
    }

  let make ?next_token ?(spot_fleet_request_configs = []) () =
    { next_token; spot_fleet_request_configs }

  let parse xml =
    Some
      { next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; spot_fleet_request_configs =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "spotFleetRequestConfigSet" xml)
               SpotFleetRequestConfigSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "SpotFleetRequestConfigSet"
                , SpotFleetRequestConfigSet.to_query v.spot_fleet_request_configs ))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "spotFleetRequestConfigSet"
             , SpotFleetRequestConfigSet.to_json v.spot_fleet_request_configs )
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ])

  let of_json j =
    { next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; spot_fleet_request_configs =
        SpotFleetRequestConfigSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "spotFleetRequestConfigSet"))
    }
end

module WithdrawByoipCidrRequest = struct
  type t =
    { cidr : String.t
    ; dry_run : Boolean.t option
    }

  let make ~cidr ?dry_run () = { cidr; dry_run }

  let parse xml =
    Some
      { cidr =
          Aws.Xml.required
            "Cidr"
            (Aws.Util.option_bind (Aws.Xml.member "Cidr" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Cidr", String.to_query v.cidr))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("Cidr", String.to_json v.cidr)
         ])

  let of_json j =
    { cidr = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Cidr"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module VolumeAttachmentState = struct
  type t =
    | Attaching
    | Attached
    | Detaching
    | Detached
    | Busy

  let str_to_t =
    [ "busy", Busy
    ; "detached", Detached
    ; "detaching", Detaching
    ; "attached", Attached
    ; "attaching", Attaching
    ]

  let t_to_str =
    [ Busy, "busy"
    ; Detached, "detached"
    ; Detaching, "detaching"
    ; Attached, "attached"
    ; Attaching, "attaching"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module VolumeAttachment = struct
  type t =
    { attach_time : DateTime.t option
    ; device : String.t option
    ; instance_id : String.t option
    ; state : VolumeAttachmentState.t option
    ; volume_id : String.t option
    ; delete_on_termination : Boolean.t option
    }

  let make ?attach_time ?device ?instance_id ?state ?volume_id ?delete_on_termination () =
    { attach_time; device; instance_id; state; volume_id; delete_on_termination }

  let parse xml =
    Some
      { attach_time =
          Aws.Util.option_bind (Aws.Xml.member "attachTime" xml) DateTime.parse
      ; device = Aws.Util.option_bind (Aws.Xml.member "device" xml) String.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      ; state =
          Aws.Util.option_bind (Aws.Xml.member "status" xml) VolumeAttachmentState.parse
      ; volume_id = Aws.Util.option_bind (Aws.Xml.member "volumeId" xml) String.parse
      ; delete_on_termination =
          Aws.Util.option_bind (Aws.Xml.member "deleteOnTermination" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.delete_on_termination (fun f ->
               Aws.Query.Pair ("DeleteOnTermination", Boolean.to_query f))
         ; Aws.Util.option_map v.volume_id (fun f ->
               Aws.Query.Pair ("VolumeId", String.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("Status", VolumeAttachmentState.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.device (fun f ->
               Aws.Query.Pair ("Device", String.to_query f))
         ; Aws.Util.option_map v.attach_time (fun f ->
               Aws.Query.Pair ("AttachTime", DateTime.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.delete_on_termination (fun f ->
               "deleteOnTermination", Boolean.to_json f)
         ; Aws.Util.option_map v.volume_id (fun f -> "volumeId", String.to_json f)
         ; Aws.Util.option_map v.state (fun f ->
               "status", VolumeAttachmentState.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ; Aws.Util.option_map v.device (fun f -> "device", String.to_json f)
         ; Aws.Util.option_map v.attach_time (fun f -> "attachTime", DateTime.to_json f)
         ])

  let of_json j =
    { attach_time = Aws.Util.option_map (Aws.Json.lookup j "attachTime") DateTime.of_json
    ; device = Aws.Util.option_map (Aws.Json.lookup j "device") String.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    ; state =
        Aws.Util.option_map (Aws.Json.lookup j "status") VolumeAttachmentState.of_json
    ; volume_id = Aws.Util.option_map (Aws.Json.lookup j "volumeId") String.of_json
    ; delete_on_termination =
        Aws.Util.option_map (Aws.Json.lookup j "deleteOnTermination") Boolean.of_json
    }
end

module VolumeAttachmentList = struct
  type t = VolumeAttachment.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map VolumeAttachment.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list VolumeAttachment.to_query v

  let to_json v = `List (List.map VolumeAttachment.to_json v)

  let of_json j = Aws.Json.to_list VolumeAttachment.of_json j
end

module DeleteQueuedReservedInstancesIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DeleteQueuedReservedInstancesRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; reserved_instances_ids : DeleteQueuedReservedInstancesIdList.t
    }

  let make ?dry_run ~reserved_instances_ids () = { dry_run; reserved_instances_ids }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; reserved_instances_ids =
          Aws.Xml.required
            "ReservedInstancesId"
            (Aws.Util.option_bind
               (Aws.Xml.member "ReservedInstancesId" xml)
               DeleteQueuedReservedInstancesIdList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "ReservedInstancesId"
                , DeleteQueuedReservedInstancesIdList.to_query v.reserved_instances_ids ))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "ReservedInstancesId"
             , DeleteQueuedReservedInstancesIdList.to_json v.reserved_instances_ids )
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; reserved_instances_ids =
        DeleteQueuedReservedInstancesIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ReservedInstancesId"))
    }
end

module DeleteVpcPeeringConnectionResult = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module VpcPeeringConnectionList = struct
  type t = VpcPeeringConnection.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map VpcPeeringConnection.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list VpcPeeringConnection.to_query v

  let to_json v = `List (List.map VpcPeeringConnection.to_json v)

  let of_json j = Aws.Json.to_list VpcPeeringConnection.of_json j
end

module CancelSpotFleetRequestsError = struct
  type t =
    { code : CancelBatchErrorCode.t option
    ; message : String.t option
    }

  let make ?code ?message () = { code; message }

  let parse xml =
    Some
      { code = Aws.Util.option_bind (Aws.Xml.member "code" xml) CancelBatchErrorCode.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair ("Code", CancelBatchErrorCode.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f)
         ; Aws.Util.option_map v.code (fun f -> "code", CancelBatchErrorCode.to_json f)
         ])

  let of_json j =
    { code = Aws.Util.option_map (Aws.Json.lookup j "code") CancelBatchErrorCode.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json
    }
end

module InstanceIpv6AddressRequest = struct
  type t = { ipv6_address : String.t option }

  let make ?ipv6_address () = { ipv6_address }

  let parse xml =
    Some
      { ipv6_address =
          Aws.Util.option_bind (Aws.Xml.member "Ipv6Address" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ipv6_address (fun f ->
               Aws.Query.Pair ("Ipv6Address", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ipv6_address (fun f -> "Ipv6Address", String.to_json f) ])

  let of_json j =
    { ipv6_address = Aws.Util.option_map (Aws.Json.lookup j "Ipv6Address") String.of_json
    }
end

module InstanceIpv6AddressListRequest = struct
  type t = InstanceIpv6AddressRequest.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         InstanceIpv6AddressRequest.parse
         (Aws.Xml.members "InstanceIpv6Address" xml))

  let to_query v = Aws.Query.to_query_list InstanceIpv6AddressRequest.to_query v

  let to_json v = `List (List.map InstanceIpv6AddressRequest.to_json v)

  let of_json j = Aws.Json.to_list InstanceIpv6AddressRequest.of_json j
end

module InternetGatewayIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeInternetGatewaysRequest = struct
  type t =
    { filters : FilterList.t
    ; dry_run : Boolean.t option
    ; internet_gateway_ids : InternetGatewayIdList.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    }

  let make
      ?(filters = [])
      ?dry_run
      ?(internet_gateway_ids = [])
      ?next_token
      ?max_results
      () =
    { filters; dry_run; internet_gateway_ids; next_token; max_results }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; internet_gateway_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "internetGatewayId" xml)
               InternetGatewayIdList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "InternetGatewayId"
                , InternetGatewayIdList.to_query v.internet_gateway_ids ))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("internetGatewayId", InternetGatewayIdList.to_json v.internet_gateway_ids)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; internet_gateway_ids =
        InternetGatewayIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "internetGatewayId"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module PrefixList = struct
  type t =
    { cidrs : ValueStringList.t
    ; prefix_list_id : String.t option
    ; prefix_list_name : String.t option
    }

  let make ?(cidrs = []) ?prefix_list_id ?prefix_list_name () =
    { cidrs; prefix_list_id; prefix_list_name }

  let parse xml =
    Some
      { cidrs =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "cidrSet" xml) ValueStringList.parse)
      ; prefix_list_id =
          Aws.Util.option_bind (Aws.Xml.member "prefixListId" xml) String.parse
      ; prefix_list_name =
          Aws.Util.option_bind (Aws.Xml.member "prefixListName" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.prefix_list_name (fun f ->
               Aws.Query.Pair ("PrefixListName", String.to_query f))
         ; Aws.Util.option_map v.prefix_list_id (fun f ->
               Aws.Query.Pair ("PrefixListId", String.to_query f))
         ; Some (Aws.Query.Pair ("CidrSet", ValueStringList.to_query v.cidrs))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.prefix_list_name (fun f ->
               "prefixListName", String.to_json f)
         ; Aws.Util.option_map v.prefix_list_id (fun f ->
               "prefixListId", String.to_json f)
         ; Some ("cidrSet", ValueStringList.to_json v.cidrs)
         ])

  let of_json j =
    { cidrs =
        ValueStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "cidrSet"))
    ; prefix_list_id =
        Aws.Util.option_map (Aws.Json.lookup j "prefixListId") String.of_json
    ; prefix_list_name =
        Aws.Util.option_map (Aws.Json.lookup j "prefixListName") String.of_json
    }
end

module GetEbsEncryptionByDefaultRequest = struct
  type t = { dry_run : Boolean.t option }

  let make ?dry_run () = { dry_run }

  let parse xml =
    Some { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f) ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json }
end

module DeleteTrafficMirrorSessionResult = struct
  type t = { traffic_mirror_session_id : String.t option }

  let make ?traffic_mirror_session_id () = { traffic_mirror_session_id }

  let parse xml =
    Some
      { traffic_mirror_session_id =
          Aws.Util.option_bind (Aws.Xml.member "trafficMirrorSessionId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.traffic_mirror_session_id (fun f ->
               Aws.Query.Pair ("TrafficMirrorSessionId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.traffic_mirror_session_id (fun f ->
               "trafficMirrorSessionId", String.to_json f)
         ])

  let of_json j =
    { traffic_mirror_session_id =
        Aws.Util.option_map (Aws.Json.lookup j "trafficMirrorSessionId") String.of_json
    }
end

module Ipv6CidrAssociation = struct
  type t =
    { ipv6_cidr : String.t option
    ; associated_resource : String.t option
    }

  let make ?ipv6_cidr ?associated_resource () = { ipv6_cidr; associated_resource }

  let parse xml =
    Some
      { ipv6_cidr = Aws.Util.option_bind (Aws.Xml.member "ipv6Cidr" xml) String.parse
      ; associated_resource =
          Aws.Util.option_bind (Aws.Xml.member "associatedResource" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.associated_resource (fun f ->
               Aws.Query.Pair ("AssociatedResource", String.to_query f))
         ; Aws.Util.option_map v.ipv6_cidr (fun f ->
               Aws.Query.Pair ("Ipv6Cidr", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.associated_resource (fun f ->
               "associatedResource", String.to_json f)
         ; Aws.Util.option_map v.ipv6_cidr (fun f -> "ipv6Cidr", String.to_json f)
         ])

  let of_json j =
    { ipv6_cidr = Aws.Util.option_map (Aws.Json.lookup j "ipv6Cidr") String.of_json
    ; associated_resource =
        Aws.Util.option_map (Aws.Json.lookup j "associatedResource") String.of_json
    }
end

module ImportKeyPairRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; key_name : String.t
    ; public_key_material : Blob.t
    ; tag_specifications : TagSpecificationList.t
    }

  let make ?dry_run ~key_name ~public_key_material ?(tag_specifications = []) () =
    { dry_run; key_name; public_key_material; tag_specifications }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; key_name =
          Aws.Xml.required
            "keyName"
            (Aws.Util.option_bind (Aws.Xml.member "keyName" xml) String.parse)
      ; public_key_material =
          Aws.Xml.required
            "publicKeyMaterial"
            (Aws.Util.option_bind (Aws.Xml.member "publicKeyMaterial" xml) Blob.parse)
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Some
             (Aws.Query.Pair ("PublicKeyMaterial", Blob.to_query v.public_key_material))
         ; Some (Aws.Query.Pair ("KeyName", String.to_query v.key_name))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Some ("publicKeyMaterial", Blob.to_json v.public_key_material)
         ; Some ("keyName", String.to_json v.key_name)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; key_name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "keyName"))
    ; public_key_material =
        Blob.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "publicKeyMaterial"))
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    }
end

module UnmonitorInstancesRequest = struct
  type t =
    { instance_ids : InstanceIdStringList.t
    ; dry_run : Boolean.t option
    }

  let make ~instance_ids ?dry_run () = { instance_ids; dry_run }

  let parse xml =
    Some
      { instance_ids =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind
               (Aws.Xml.member "InstanceId" xml)
               InstanceIdStringList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair ("InstanceId", InstanceIdStringList.to_query v.instance_ids))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("InstanceId", InstanceIdStringList.to_json v.instance_ids)
         ])

  let of_json j =
    { instance_ids =
        InstanceIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module ImportTaskIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "ImportTaskId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeImportImageTasksRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; filters : FilterList.t
    ; import_task_ids : ImportTaskIdList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?dry_run ?(filters = []) ?(import_task_ids = []) ?max_results ?next_token () =
    { dry_run; filters; import_task_ids; max_results; next_token }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; import_task_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ImportTaskId" xml)
               ImportTaskIdList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair ("ImportTaskId", ImportTaskIdList.to_query v.import_task_ids))
         ; Some (Aws.Query.Pair ("Filters", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("ImportTaskId", ImportTaskIdList.to_json v.import_task_ids)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; import_task_ids =
        ImportTaskIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ImportTaskId"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module SpotInstanceInterruptionBehavior = struct
  type t =
    | Hibernate
    | Stop
    | Terminate

  let str_to_t = [ "terminate", Terminate; "stop", Stop; "hibernate", Hibernate ]

  let t_to_str = [ Terminate, "terminate"; Stop, "stop"; Hibernate, "hibernate" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module SpotAllocationStrategy = struct
  type t =
    | Lowest_price
    | Diversified
    | Capacity_optimized

  let str_to_t =
    [ "capacity-optimized", Capacity_optimized
    ; "diversified", Diversified
    ; "lowest-price", Lowest_price
    ]

  let t_to_str =
    [ Capacity_optimized, "capacity-optimized"
    ; Diversified, "diversified"
    ; Lowest_price, "lowest-price"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module FleetSpotCapacityRebalance = struct
  type t = { replacement_strategy : FleetReplacementStrategy.t option }

  let make ?replacement_strategy () = { replacement_strategy }

  let parse xml =
    Some
      { replacement_strategy =
          Aws.Util.option_bind
            (Aws.Xml.member "replacementStrategy" xml)
            FleetReplacementStrategy.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.replacement_strategy (fun f ->
               Aws.Query.Pair ("ReplacementStrategy", FleetReplacementStrategy.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.replacement_strategy (fun f ->
               "replacementStrategy", FleetReplacementStrategy.to_json f)
         ])

  let of_json j =
    { replacement_strategy =
        Aws.Util.option_map
          (Aws.Json.lookup j "replacementStrategy")
          FleetReplacementStrategy.of_json
    }
end

module FleetSpotMaintenanceStrategies = struct
  type t = { capacity_rebalance : FleetSpotCapacityRebalance.t option }

  let make ?capacity_rebalance () = { capacity_rebalance }

  let parse xml =
    Some
      { capacity_rebalance =
          Aws.Util.option_bind
            (Aws.Xml.member "capacityRebalance" xml)
            FleetSpotCapacityRebalance.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.capacity_rebalance (fun f ->
               Aws.Query.Pair ("CapacityRebalance", FleetSpotCapacityRebalance.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.capacity_rebalance (fun f ->
               "capacityRebalance", FleetSpotCapacityRebalance.to_json f)
         ])

  let of_json j =
    { capacity_rebalance =
        Aws.Util.option_map
          (Aws.Json.lookup j "capacityRebalance")
          FleetSpotCapacityRebalance.of_json
    }
end

module SpotOptions = struct
  type t =
    { allocation_strategy : SpotAllocationStrategy.t option
    ; maintenance_strategies : FleetSpotMaintenanceStrategies.t option
    ; instance_interruption_behavior : SpotInstanceInterruptionBehavior.t option
    ; instance_pools_to_use_count : Integer.t option
    ; single_instance_type : Boolean.t option
    ; single_availability_zone : Boolean.t option
    ; min_target_capacity : Integer.t option
    ; max_total_price : String.t option
    }

  let make
      ?allocation_strategy
      ?maintenance_strategies
      ?instance_interruption_behavior
      ?instance_pools_to_use_count
      ?single_instance_type
      ?single_availability_zone
      ?min_target_capacity
      ?max_total_price
      () =
    { allocation_strategy
    ; maintenance_strategies
    ; instance_interruption_behavior
    ; instance_pools_to_use_count
    ; single_instance_type
    ; single_availability_zone
    ; min_target_capacity
    ; max_total_price
    }

  let parse xml =
    Some
      { allocation_strategy =
          Aws.Util.option_bind
            (Aws.Xml.member "allocationStrategy" xml)
            SpotAllocationStrategy.parse
      ; maintenance_strategies =
          Aws.Util.option_bind
            (Aws.Xml.member "maintenanceStrategies" xml)
            FleetSpotMaintenanceStrategies.parse
      ; instance_interruption_behavior =
          Aws.Util.option_bind
            (Aws.Xml.member "instanceInterruptionBehavior" xml)
            SpotInstanceInterruptionBehavior.parse
      ; instance_pools_to_use_count =
          Aws.Util.option_bind
            (Aws.Xml.member "instancePoolsToUseCount" xml)
            Integer.parse
      ; single_instance_type =
          Aws.Util.option_bind (Aws.Xml.member "singleInstanceType" xml) Boolean.parse
      ; single_availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "singleAvailabilityZone" xml) Boolean.parse
      ; min_target_capacity =
          Aws.Util.option_bind (Aws.Xml.member "minTargetCapacity" xml) Integer.parse
      ; max_total_price =
          Aws.Util.option_bind (Aws.Xml.member "maxTotalPrice" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_total_price (fun f ->
               Aws.Query.Pair ("MaxTotalPrice", String.to_query f))
         ; Aws.Util.option_map v.min_target_capacity (fun f ->
               Aws.Query.Pair ("MinTargetCapacity", Integer.to_query f))
         ; Aws.Util.option_map v.single_availability_zone (fun f ->
               Aws.Query.Pair ("SingleAvailabilityZone", Boolean.to_query f))
         ; Aws.Util.option_map v.single_instance_type (fun f ->
               Aws.Query.Pair ("SingleInstanceType", Boolean.to_query f))
         ; Aws.Util.option_map v.instance_pools_to_use_count (fun f ->
               Aws.Query.Pair ("InstancePoolsToUseCount", Integer.to_query f))
         ; Aws.Util.option_map v.instance_interruption_behavior (fun f ->
               Aws.Query.Pair
                 ( "InstanceInterruptionBehavior"
                 , SpotInstanceInterruptionBehavior.to_query f ))
         ; Aws.Util.option_map v.maintenance_strategies (fun f ->
               Aws.Query.Pair
                 ("MaintenanceStrategies", FleetSpotMaintenanceStrategies.to_query f))
         ; Aws.Util.option_map v.allocation_strategy (fun f ->
               Aws.Query.Pair ("AllocationStrategy", SpotAllocationStrategy.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_total_price (fun f ->
               "maxTotalPrice", String.to_json f)
         ; Aws.Util.option_map v.min_target_capacity (fun f ->
               "minTargetCapacity", Integer.to_json f)
         ; Aws.Util.option_map v.single_availability_zone (fun f ->
               "singleAvailabilityZone", Boolean.to_json f)
         ; Aws.Util.option_map v.single_instance_type (fun f ->
               "singleInstanceType", Boolean.to_json f)
         ; Aws.Util.option_map v.instance_pools_to_use_count (fun f ->
               "instancePoolsToUseCount", Integer.to_json f)
         ; Aws.Util.option_map v.instance_interruption_behavior (fun f ->
               "instanceInterruptionBehavior", SpotInstanceInterruptionBehavior.to_json f)
         ; Aws.Util.option_map v.maintenance_strategies (fun f ->
               "maintenanceStrategies", FleetSpotMaintenanceStrategies.to_json f)
         ; Aws.Util.option_map v.allocation_strategy (fun f ->
               "allocationStrategy", SpotAllocationStrategy.to_json f)
         ])

  let of_json j =
    { allocation_strategy =
        Aws.Util.option_map
          (Aws.Json.lookup j "allocationStrategy")
          SpotAllocationStrategy.of_json
    ; maintenance_strategies =
        Aws.Util.option_map
          (Aws.Json.lookup j "maintenanceStrategies")
          FleetSpotMaintenanceStrategies.of_json
    ; instance_interruption_behavior =
        Aws.Util.option_map
          (Aws.Json.lookup j "instanceInterruptionBehavior")
          SpotInstanceInterruptionBehavior.of_json
    ; instance_pools_to_use_count =
        Aws.Util.option_map (Aws.Json.lookup j "instancePoolsToUseCount") Integer.of_json
    ; single_instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "singleInstanceType") Boolean.of_json
    ; single_availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "singleAvailabilityZone") Boolean.of_json
    ; min_target_capacity =
        Aws.Util.option_map (Aws.Json.lookup j "minTargetCapacity") Integer.of_json
    ; max_total_price =
        Aws.Util.option_map (Aws.Json.lookup j "maxTotalPrice") String.of_json
    }
end

module FleetOnDemandAllocationStrategy = struct
  type t =
    | Lowest_price
    | Prioritized

  let str_to_t = [ "prioritized", Prioritized; "lowest-price", Lowest_price ]

  let t_to_str = [ Prioritized, "prioritized"; Lowest_price, "lowest-price" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module FleetCapacityReservationUsageStrategy = struct
  type t = Use_capacity_reservations_first

  let str_to_t = [ "use-capacity-reservations-first", Use_capacity_reservations_first ]

  let t_to_str = [ Use_capacity_reservations_first, "use-capacity-reservations-first" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module CapacityReservationOptions = struct
  type t = { usage_strategy : FleetCapacityReservationUsageStrategy.t option }

  let make ?usage_strategy () = { usage_strategy }

  let parse xml =
    Some
      { usage_strategy =
          Aws.Util.option_bind
            (Aws.Xml.member "usageStrategy" xml)
            FleetCapacityReservationUsageStrategy.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.usage_strategy (fun f ->
               Aws.Query.Pair
                 ("UsageStrategy", FleetCapacityReservationUsageStrategy.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.usage_strategy (fun f ->
               "usageStrategy", FleetCapacityReservationUsageStrategy.to_json f)
         ])

  let of_json j =
    { usage_strategy =
        Aws.Util.option_map
          (Aws.Json.lookup j "usageStrategy")
          FleetCapacityReservationUsageStrategy.of_json
    }
end

module OnDemandOptions = struct
  type t =
    { allocation_strategy : FleetOnDemandAllocationStrategy.t option
    ; capacity_reservation_options : CapacityReservationOptions.t option
    ; single_instance_type : Boolean.t option
    ; single_availability_zone : Boolean.t option
    ; min_target_capacity : Integer.t option
    ; max_total_price : String.t option
    }

  let make
      ?allocation_strategy
      ?capacity_reservation_options
      ?single_instance_type
      ?single_availability_zone
      ?min_target_capacity
      ?max_total_price
      () =
    { allocation_strategy
    ; capacity_reservation_options
    ; single_instance_type
    ; single_availability_zone
    ; min_target_capacity
    ; max_total_price
    }

  let parse xml =
    Some
      { allocation_strategy =
          Aws.Util.option_bind
            (Aws.Xml.member "allocationStrategy" xml)
            FleetOnDemandAllocationStrategy.parse
      ; capacity_reservation_options =
          Aws.Util.option_bind
            (Aws.Xml.member "capacityReservationOptions" xml)
            CapacityReservationOptions.parse
      ; single_instance_type =
          Aws.Util.option_bind (Aws.Xml.member "singleInstanceType" xml) Boolean.parse
      ; single_availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "singleAvailabilityZone" xml) Boolean.parse
      ; min_target_capacity =
          Aws.Util.option_bind (Aws.Xml.member "minTargetCapacity" xml) Integer.parse
      ; max_total_price =
          Aws.Util.option_bind (Aws.Xml.member "maxTotalPrice" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_total_price (fun f ->
               Aws.Query.Pair ("MaxTotalPrice", String.to_query f))
         ; Aws.Util.option_map v.min_target_capacity (fun f ->
               Aws.Query.Pair ("MinTargetCapacity", Integer.to_query f))
         ; Aws.Util.option_map v.single_availability_zone (fun f ->
               Aws.Query.Pair ("SingleAvailabilityZone", Boolean.to_query f))
         ; Aws.Util.option_map v.single_instance_type (fun f ->
               Aws.Query.Pair ("SingleInstanceType", Boolean.to_query f))
         ; Aws.Util.option_map v.capacity_reservation_options (fun f ->
               Aws.Query.Pair
                 ("CapacityReservationOptions", CapacityReservationOptions.to_query f))
         ; Aws.Util.option_map v.allocation_strategy (fun f ->
               Aws.Query.Pair
                 ("AllocationStrategy", FleetOnDemandAllocationStrategy.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_total_price (fun f ->
               "maxTotalPrice", String.to_json f)
         ; Aws.Util.option_map v.min_target_capacity (fun f ->
               "minTargetCapacity", Integer.to_json f)
         ; Aws.Util.option_map v.single_availability_zone (fun f ->
               "singleAvailabilityZone", Boolean.to_json f)
         ; Aws.Util.option_map v.single_instance_type (fun f ->
               "singleInstanceType", Boolean.to_json f)
         ; Aws.Util.option_map v.capacity_reservation_options (fun f ->
               "capacityReservationOptions", CapacityReservationOptions.to_json f)
         ; Aws.Util.option_map v.allocation_strategy (fun f ->
               "allocationStrategy", FleetOnDemandAllocationStrategy.to_json f)
         ])

  let of_json j =
    { allocation_strategy =
        Aws.Util.option_map
          (Aws.Json.lookup j "allocationStrategy")
          FleetOnDemandAllocationStrategy.of_json
    ; capacity_reservation_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "capacityReservationOptions")
          CapacityReservationOptions.of_json
    ; single_instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "singleInstanceType") Boolean.of_json
    ; single_availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "singleAvailabilityZone") Boolean.of_json
    ; min_target_capacity =
        Aws.Util.option_map (Aws.Json.lookup j "minTargetCapacity") Integer.of_json
    ; max_total_price =
        Aws.Util.option_map (Aws.Json.lookup j "maxTotalPrice") String.of_json
    }
end

module FleetActivityStatus = struct
  type t =
    | Error
    | Pending_fulfillment
    | Pending_termination
    | Fulfilled

  let str_to_t =
    [ "fulfilled", Fulfilled
    ; "pending_termination", Pending_termination
    ; "pending_fulfillment", Pending_fulfillment
    ; "error", Error
    ]

  let t_to_str =
    [ Fulfilled, "fulfilled"
    ; Pending_termination, "pending_termination"
    ; Pending_fulfillment, "pending_fulfillment"
    ; Error, "error"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module InstanceIdsSet = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeFleetsInstances = struct
  type t =
    { launch_template_and_overrides : LaunchTemplateAndOverridesResponse.t option
    ; lifecycle : InstanceLifecycle.t option
    ; instance_ids : InstanceIdsSet.t
    ; instance_type : InstanceType.t option
    ; platform : PlatformValues.t option
    }

  let make
      ?launch_template_and_overrides
      ?lifecycle
      ?(instance_ids = [])
      ?instance_type
      ?platform
      () =
    { launch_template_and_overrides; lifecycle; instance_ids; instance_type; platform }

  let parse xml =
    Some
      { launch_template_and_overrides =
          Aws.Util.option_bind
            (Aws.Xml.member "launchTemplateAndOverrides" xml)
            LaunchTemplateAndOverridesResponse.parse
      ; lifecycle =
          Aws.Util.option_bind (Aws.Xml.member "lifecycle" xml) InstanceLifecycle.parse
      ; instance_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "instanceIds" xml) InstanceIdsSet.parse)
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) InstanceType.parse
      ; platform =
          Aws.Util.option_bind (Aws.Xml.member "platform" xml) PlatformValues.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.platform (fun f ->
               Aws.Query.Pair ("Platform", PlatformValues.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", InstanceType.to_query f))
         ; Some (Aws.Query.Pair ("InstanceIds", InstanceIdsSet.to_query v.instance_ids))
         ; Aws.Util.option_map v.lifecycle (fun f ->
               Aws.Query.Pair ("Lifecycle", InstanceLifecycle.to_query f))
         ; Aws.Util.option_map v.launch_template_and_overrides (fun f ->
               Aws.Query.Pair
                 ( "LaunchTemplateAndOverrides"
                 , LaunchTemplateAndOverridesResponse.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.platform (fun f -> "platform", PlatformValues.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f ->
               "instanceType", InstanceType.to_json f)
         ; Some ("instanceIds", InstanceIdsSet.to_json v.instance_ids)
         ; Aws.Util.option_map v.lifecycle (fun f ->
               "lifecycle", InstanceLifecycle.to_json f)
         ; Aws.Util.option_map v.launch_template_and_overrides (fun f ->
               "launchTemplateAndOverrides", LaunchTemplateAndOverridesResponse.to_json f)
         ])

  let of_json j =
    { launch_template_and_overrides =
        Aws.Util.option_map
          (Aws.Json.lookup j "launchTemplateAndOverrides")
          LaunchTemplateAndOverridesResponse.of_json
    ; lifecycle =
        Aws.Util.option_map (Aws.Json.lookup j "lifecycle") InstanceLifecycle.of_json
    ; instance_ids =
        InstanceIdsSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceIds"))
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") InstanceType.of_json
    ; platform = Aws.Util.option_map (Aws.Json.lookup j "platform") PlatformValues.of_json
    }
end

module DescribeFleetsInstancesSet = struct
  type t = DescribeFleetsInstances.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map DescribeFleetsInstances.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list DescribeFleetsInstances.to_query v

  let to_json v = `List (List.map DescribeFleetsInstances.to_json v)

  let of_json j = Aws.Json.to_list DescribeFleetsInstances.of_json j
end

module DescribeFleetError = struct
  type t =
    { launch_template_and_overrides : LaunchTemplateAndOverridesResponse.t option
    ; lifecycle : InstanceLifecycle.t option
    ; error_code : String.t option
    ; error_message : String.t option
    }

  let make ?launch_template_and_overrides ?lifecycle ?error_code ?error_message () =
    { launch_template_and_overrides; lifecycle; error_code; error_message }

  let parse xml =
    Some
      { launch_template_and_overrides =
          Aws.Util.option_bind
            (Aws.Xml.member "launchTemplateAndOverrides" xml)
            LaunchTemplateAndOverridesResponse.parse
      ; lifecycle =
          Aws.Util.option_bind (Aws.Xml.member "lifecycle" xml) InstanceLifecycle.parse
      ; error_code = Aws.Util.option_bind (Aws.Xml.member "errorCode" xml) String.parse
      ; error_message =
          Aws.Util.option_bind (Aws.Xml.member "errorMessage" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.error_message (fun f ->
               Aws.Query.Pair ("ErrorMessage", String.to_query f))
         ; Aws.Util.option_map v.error_code (fun f ->
               Aws.Query.Pair ("ErrorCode", String.to_query f))
         ; Aws.Util.option_map v.lifecycle (fun f ->
               Aws.Query.Pair ("Lifecycle", InstanceLifecycle.to_query f))
         ; Aws.Util.option_map v.launch_template_and_overrides (fun f ->
               Aws.Query.Pair
                 ( "LaunchTemplateAndOverrides"
                 , LaunchTemplateAndOverridesResponse.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.error_message (fun f -> "errorMessage", String.to_json f)
         ; Aws.Util.option_map v.error_code (fun f -> "errorCode", String.to_json f)
         ; Aws.Util.option_map v.lifecycle (fun f ->
               "lifecycle", InstanceLifecycle.to_json f)
         ; Aws.Util.option_map v.launch_template_and_overrides (fun f ->
               "launchTemplateAndOverrides", LaunchTemplateAndOverridesResponse.to_json f)
         ])

  let of_json j =
    { launch_template_and_overrides =
        Aws.Util.option_map
          (Aws.Json.lookup j "launchTemplateAndOverrides")
          LaunchTemplateAndOverridesResponse.of_json
    ; lifecycle =
        Aws.Util.option_map (Aws.Json.lookup j "lifecycle") InstanceLifecycle.of_json
    ; error_code = Aws.Util.option_map (Aws.Json.lookup j "errorCode") String.of_json
    ; error_message =
        Aws.Util.option_map (Aws.Json.lookup j "errorMessage") String.of_json
    }
end

module DescribeFleetsErrorSet = struct
  type t = DescribeFleetError.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map DescribeFleetError.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list DescribeFleetError.to_query v

  let to_json v = `List (List.map DescribeFleetError.to_json v)

  let of_json j = Aws.Json.to_list DescribeFleetError.of_json j
end

module FleetData = struct
  type t =
    { activity_status : FleetActivityStatus.t option
    ; create_time : DateTime.t option
    ; fleet_id : String.t option
    ; fleet_state : FleetStateCode.t option
    ; client_token : String.t option
    ; excess_capacity_termination_policy : FleetExcessCapacityTerminationPolicy.t option
    ; fulfilled_capacity : Double.t option
    ; fulfilled_on_demand_capacity : Double.t option
    ; launch_template_configs : FleetLaunchTemplateConfigList.t
    ; target_capacity_specification : TargetCapacitySpecification.t option
    ; terminate_instances_with_expiration : Boolean.t option
    ; type_ : FleetType.t option
    ; valid_from : DateTime.t option
    ; valid_until : DateTime.t option
    ; replace_unhealthy_instances : Boolean.t option
    ; spot_options : SpotOptions.t option
    ; on_demand_options : OnDemandOptions.t option
    ; tags : TagList.t
    ; errors : DescribeFleetsErrorSet.t
    ; instances : DescribeFleetsInstancesSet.t
    }

  let make
      ?activity_status
      ?create_time
      ?fleet_id
      ?fleet_state
      ?client_token
      ?excess_capacity_termination_policy
      ?fulfilled_capacity
      ?fulfilled_on_demand_capacity
      ?(launch_template_configs = [])
      ?target_capacity_specification
      ?terminate_instances_with_expiration
      ?type_
      ?valid_from
      ?valid_until
      ?replace_unhealthy_instances
      ?spot_options
      ?on_demand_options
      ?(tags = [])
      ?(errors = [])
      ?(instances = [])
      () =
    { activity_status
    ; create_time
    ; fleet_id
    ; fleet_state
    ; client_token
    ; excess_capacity_termination_policy
    ; fulfilled_capacity
    ; fulfilled_on_demand_capacity
    ; launch_template_configs
    ; target_capacity_specification
    ; terminate_instances_with_expiration
    ; type_
    ; valid_from
    ; valid_until
    ; replace_unhealthy_instances
    ; spot_options
    ; on_demand_options
    ; tags
    ; errors
    ; instances
    }

  let parse xml =
    Some
      { activity_status =
          Aws.Util.option_bind
            (Aws.Xml.member "activityStatus" xml)
            FleetActivityStatus.parse
      ; create_time =
          Aws.Util.option_bind (Aws.Xml.member "createTime" xml) DateTime.parse
      ; fleet_id = Aws.Util.option_bind (Aws.Xml.member "fleetId" xml) String.parse
      ; fleet_state =
          Aws.Util.option_bind (Aws.Xml.member "fleetState" xml) FleetStateCode.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "clientToken" xml) String.parse
      ; excess_capacity_termination_policy =
          Aws.Util.option_bind
            (Aws.Xml.member "excessCapacityTerminationPolicy" xml)
            FleetExcessCapacityTerminationPolicy.parse
      ; fulfilled_capacity =
          Aws.Util.option_bind (Aws.Xml.member "fulfilledCapacity" xml) Double.parse
      ; fulfilled_on_demand_capacity =
          Aws.Util.option_bind
            (Aws.Xml.member "fulfilledOnDemandCapacity" xml)
            Double.parse
      ; launch_template_configs =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "launchTemplateConfigs" xml)
               FleetLaunchTemplateConfigList.parse)
      ; target_capacity_specification =
          Aws.Util.option_bind
            (Aws.Xml.member "targetCapacitySpecification" xml)
            TargetCapacitySpecification.parse
      ; terminate_instances_with_expiration =
          Aws.Util.option_bind
            (Aws.Xml.member "terminateInstancesWithExpiration" xml)
            Boolean.parse
      ; type_ = Aws.Util.option_bind (Aws.Xml.member "type" xml) FleetType.parse
      ; valid_from = Aws.Util.option_bind (Aws.Xml.member "validFrom" xml) DateTime.parse
      ; valid_until =
          Aws.Util.option_bind (Aws.Xml.member "validUntil" xml) DateTime.parse
      ; replace_unhealthy_instances =
          Aws.Util.option_bind
            (Aws.Xml.member "replaceUnhealthyInstances" xml)
            Boolean.parse
      ; spot_options =
          Aws.Util.option_bind (Aws.Xml.member "spotOptions" xml) SpotOptions.parse
      ; on_demand_options =
          Aws.Util.option_bind
            (Aws.Xml.member "onDemandOptions" xml)
            OnDemandOptions.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      ; errors =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "errorSet" xml)
               DescribeFleetsErrorSet.parse)
      ; instances =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "fleetInstanceSet" xml)
               DescribeFleetsInstancesSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("FleetInstanceSet", DescribeFleetsInstancesSet.to_query v.instances))
         ; Some (Aws.Query.Pair ("ErrorSet", DescribeFleetsErrorSet.to_query v.errors))
         ; Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.on_demand_options (fun f ->
               Aws.Query.Pair ("OnDemandOptions", OnDemandOptions.to_query f))
         ; Aws.Util.option_map v.spot_options (fun f ->
               Aws.Query.Pair ("SpotOptions", SpotOptions.to_query f))
         ; Aws.Util.option_map v.replace_unhealthy_instances (fun f ->
               Aws.Query.Pair ("ReplaceUnhealthyInstances", Boolean.to_query f))
         ; Aws.Util.option_map v.valid_until (fun f ->
               Aws.Query.Pair ("ValidUntil", DateTime.to_query f))
         ; Aws.Util.option_map v.valid_from (fun f ->
               Aws.Query.Pair ("ValidFrom", DateTime.to_query f))
         ; Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", FleetType.to_query f))
         ; Aws.Util.option_map v.terminate_instances_with_expiration (fun f ->
               Aws.Query.Pair ("TerminateInstancesWithExpiration", Boolean.to_query f))
         ; Aws.Util.option_map v.target_capacity_specification (fun f ->
               Aws.Query.Pair
                 ("TargetCapacitySpecification", TargetCapacitySpecification.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "LaunchTemplateConfigs"
                , FleetLaunchTemplateConfigList.to_query v.launch_template_configs ))
         ; Aws.Util.option_map v.fulfilled_on_demand_capacity (fun f ->
               Aws.Query.Pair ("FulfilledOnDemandCapacity", Double.to_query f))
         ; Aws.Util.option_map v.fulfilled_capacity (fun f ->
               Aws.Query.Pair ("FulfilledCapacity", Double.to_query f))
         ; Aws.Util.option_map v.excess_capacity_termination_policy (fun f ->
               Aws.Query.Pair
                 ( "ExcessCapacityTerminationPolicy"
                 , FleetExcessCapacityTerminationPolicy.to_query f ))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.fleet_state (fun f ->
               Aws.Query.Pair ("FleetState", FleetStateCode.to_query f))
         ; Aws.Util.option_map v.fleet_id (fun f ->
               Aws.Query.Pair ("FleetId", String.to_query f))
         ; Aws.Util.option_map v.create_time (fun f ->
               Aws.Query.Pair ("CreateTime", DateTime.to_query f))
         ; Aws.Util.option_map v.activity_status (fun f ->
               Aws.Query.Pair ("ActivityStatus", FleetActivityStatus.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("fleetInstanceSet", DescribeFleetsInstancesSet.to_json v.instances)
         ; Some ("errorSet", DescribeFleetsErrorSet.to_json v.errors)
         ; Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.on_demand_options (fun f ->
               "onDemandOptions", OnDemandOptions.to_json f)
         ; Aws.Util.option_map v.spot_options (fun f ->
               "spotOptions", SpotOptions.to_json f)
         ; Aws.Util.option_map v.replace_unhealthy_instances (fun f ->
               "replaceUnhealthyInstances", Boolean.to_json f)
         ; Aws.Util.option_map v.valid_until (fun f -> "validUntil", DateTime.to_json f)
         ; Aws.Util.option_map v.valid_from (fun f -> "validFrom", DateTime.to_json f)
         ; Aws.Util.option_map v.type_ (fun f -> "type", FleetType.to_json f)
         ; Aws.Util.option_map v.terminate_instances_with_expiration (fun f ->
               "terminateInstancesWithExpiration", Boolean.to_json f)
         ; Aws.Util.option_map v.target_capacity_specification (fun f ->
               "targetCapacitySpecification", TargetCapacitySpecification.to_json f)
         ; Some
             ( "launchTemplateConfigs"
             , FleetLaunchTemplateConfigList.to_json v.launch_template_configs )
         ; Aws.Util.option_map v.fulfilled_on_demand_capacity (fun f ->
               "fulfilledOnDemandCapacity", Double.to_json f)
         ; Aws.Util.option_map v.fulfilled_capacity (fun f ->
               "fulfilledCapacity", Double.to_json f)
         ; Aws.Util.option_map v.excess_capacity_termination_policy (fun f ->
               ( "excessCapacityTerminationPolicy"
               , FleetExcessCapacityTerminationPolicy.to_json f ))
         ; Aws.Util.option_map v.client_token (fun f -> "clientToken", String.to_json f)
         ; Aws.Util.option_map v.fleet_state (fun f ->
               "fleetState", FleetStateCode.to_json f)
         ; Aws.Util.option_map v.fleet_id (fun f -> "fleetId", String.to_json f)
         ; Aws.Util.option_map v.create_time (fun f -> "createTime", DateTime.to_json f)
         ; Aws.Util.option_map v.activity_status (fun f ->
               "activityStatus", FleetActivityStatus.to_json f)
         ])

  let of_json j =
    { activity_status =
        Aws.Util.option_map
          (Aws.Json.lookup j "activityStatus")
          FleetActivityStatus.of_json
    ; create_time = Aws.Util.option_map (Aws.Json.lookup j "createTime") DateTime.of_json
    ; fleet_id = Aws.Util.option_map (Aws.Json.lookup j "fleetId") String.of_json
    ; fleet_state =
        Aws.Util.option_map (Aws.Json.lookup j "fleetState") FleetStateCode.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "clientToken") String.of_json
    ; excess_capacity_termination_policy =
        Aws.Util.option_map
          (Aws.Json.lookup j "excessCapacityTerminationPolicy")
          FleetExcessCapacityTerminationPolicy.of_json
    ; fulfilled_capacity =
        Aws.Util.option_map (Aws.Json.lookup j "fulfilledCapacity") Double.of_json
    ; fulfilled_on_demand_capacity =
        Aws.Util.option_map (Aws.Json.lookup j "fulfilledOnDemandCapacity") Double.of_json
    ; launch_template_configs =
        FleetLaunchTemplateConfigList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "launchTemplateConfigs"))
    ; target_capacity_specification =
        Aws.Util.option_map
          (Aws.Json.lookup j "targetCapacitySpecification")
          TargetCapacitySpecification.of_json
    ; terminate_instances_with_expiration =
        Aws.Util.option_map
          (Aws.Json.lookup j "terminateInstancesWithExpiration")
          Boolean.of_json
    ; type_ = Aws.Util.option_map (Aws.Json.lookup j "type") FleetType.of_json
    ; valid_from = Aws.Util.option_map (Aws.Json.lookup j "validFrom") DateTime.of_json
    ; valid_until = Aws.Util.option_map (Aws.Json.lookup j "validUntil") DateTime.of_json
    ; replace_unhealthy_instances =
        Aws.Util.option_map
          (Aws.Json.lookup j "replaceUnhealthyInstances")
          Boolean.of_json
    ; spot_options =
        Aws.Util.option_map (Aws.Json.lookup j "spotOptions") SpotOptions.of_json
    ; on_demand_options =
        Aws.Util.option_map (Aws.Json.lookup j "onDemandOptions") OnDemandOptions.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    ; errors =
        DescribeFleetsErrorSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "errorSet"))
    ; instances =
        DescribeFleetsInstancesSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "fleetInstanceSet"))
    }
end

module FleetSet = struct
  type t = FleetData.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map FleetData.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list FleetData.to_query v

  let to_json v = `List (List.map FleetData.to_json v)

  let of_json j = Aws.Json.to_list FleetData.of_json j
end

module DescribeFleetsResult = struct
  type t =
    { next_token : String.t option
    ; fleets : FleetSet.t
    }

  let make ?next_token ?(fleets = []) () = { next_token; fleets }

  let parse xml =
    Some
      { next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; fleets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "fleetSet" xml) FleetSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("FleetSet", FleetSet.to_query v.fleets))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("fleetSet", FleetSet.to_json v.fleets)
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ])

  let of_json j =
    { next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; fleets = FleetSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "fleetSet"))
    }
end

module CarrierGatewayIdSet = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeCarrierGatewaysRequest = struct
  type t =
    { carrier_gateway_ids : CarrierGatewayIdSet.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make
      ?(carrier_gateway_ids = [])
      ?(filters = [])
      ?max_results
      ?next_token
      ?dry_run
      () =
    { carrier_gateway_ids; filters; max_results; next_token; dry_run }

  let parse xml =
    Some
      { carrier_gateway_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "CarrierGatewayId" xml)
               CarrierGatewayIdSet.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ("CarrierGatewayId", CarrierGatewayIdSet.to_query v.carrier_gateway_ids))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some ("CarrierGatewayId", CarrierGatewayIdSet.to_json v.carrier_gateway_ids)
         ])

  let of_json j =
    { carrier_gateway_ids =
        CarrierGatewayIdSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "CarrierGatewayId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module CreateTrafficMirrorSessionResult = struct
  type t =
    { traffic_mirror_session : TrafficMirrorSession.t option
    ; client_token : String.t option
    }

  let make ?traffic_mirror_session ?client_token () =
    { traffic_mirror_session; client_token }

  let parse xml =
    Some
      { traffic_mirror_session =
          Aws.Util.option_bind
            (Aws.Xml.member "trafficMirrorSession" xml)
            TrafficMirrorSession.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "clientToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.traffic_mirror_session (fun f ->
               Aws.Query.Pair ("TrafficMirrorSession", TrafficMirrorSession.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f -> "clientToken", String.to_json f)
         ; Aws.Util.option_map v.traffic_mirror_session (fun f ->
               "trafficMirrorSession", TrafficMirrorSession.to_json f)
         ])

  let of_json j =
    { traffic_mirror_session =
        Aws.Util.option_map
          (Aws.Json.lookup j "trafficMirrorSession")
          TrafficMirrorSession.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "clientToken") String.of_json
    }
end

module VolumeState = struct
  type t =
    | Creating
    | Available
    | In_use
    | Deleting
    | Deleted
    | Error

  let str_to_t =
    [ "error", Error
    ; "deleted", Deleted
    ; "deleting", Deleting
    ; "in-use", In_use
    ; "available", Available
    ; "creating", Creating
    ]

  let t_to_str =
    [ Error, "error"
    ; Deleted, "deleted"
    ; Deleting, "deleting"
    ; In_use, "in-use"
    ; Available, "available"
    ; Creating, "creating"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module Volume = struct
  type t =
    { attachments : VolumeAttachmentList.t
    ; availability_zone : String.t
    ; create_time : DateTime.t
    ; encrypted : Boolean.t
    ; kms_key_id : String.t option
    ; outpost_arn : String.t option
    ; size : Integer.t
    ; snapshot_id : String.t
    ; state : VolumeState.t
    ; volume_id : String.t
    ; iops : Integer.t option
    ; tags : TagList.t
    ; volume_type : VolumeType.t
    ; fast_restored : Boolean.t option
    ; multi_attach_enabled : Boolean.t option
    }

  let make
      ?(attachments = [])
      ~availability_zone
      ~create_time
      ~encrypted
      ?kms_key_id
      ?outpost_arn
      ~size
      ~snapshot_id
      ~state
      ~volume_id
      ?iops
      ?(tags = [])
      ~volume_type
      ?fast_restored
      ?multi_attach_enabled
      () =
    { attachments
    ; availability_zone
    ; create_time
    ; encrypted
    ; kms_key_id
    ; outpost_arn
    ; size
    ; snapshot_id
    ; state
    ; volume_id
    ; iops
    ; tags
    ; volume_type
    ; fast_restored
    ; multi_attach_enabled
    }

  let parse xml =
    Some
      { attachments =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "attachmentSet" xml)
               VolumeAttachmentList.parse)
      ; availability_zone =
          Aws.Xml.required
            "availabilityZone"
            (Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse)
      ; create_time =
          Aws.Xml.required
            "createTime"
            (Aws.Util.option_bind (Aws.Xml.member "createTime" xml) DateTime.parse)
      ; encrypted =
          Aws.Xml.required
            "encrypted"
            (Aws.Util.option_bind (Aws.Xml.member "encrypted" xml) Boolean.parse)
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "kmsKeyId" xml) String.parse
      ; outpost_arn = Aws.Util.option_bind (Aws.Xml.member "outpostArn" xml) String.parse
      ; size =
          Aws.Xml.required
            "size"
            (Aws.Util.option_bind (Aws.Xml.member "size" xml) Integer.parse)
      ; snapshot_id =
          Aws.Xml.required
            "snapshotId"
            (Aws.Util.option_bind (Aws.Xml.member "snapshotId" xml) String.parse)
      ; state =
          Aws.Xml.required
            "status"
            (Aws.Util.option_bind (Aws.Xml.member "status" xml) VolumeState.parse)
      ; volume_id =
          Aws.Xml.required
            "volumeId"
            (Aws.Util.option_bind (Aws.Xml.member "volumeId" xml) String.parse)
      ; iops = Aws.Util.option_bind (Aws.Xml.member "iops" xml) Integer.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      ; volume_type =
          Aws.Xml.required
            "volumeType"
            (Aws.Util.option_bind (Aws.Xml.member "volumeType" xml) VolumeType.parse)
      ; fast_restored =
          Aws.Util.option_bind (Aws.Xml.member "fastRestored" xml) Boolean.parse
      ; multi_attach_enabled =
          Aws.Util.option_bind (Aws.Xml.member "multiAttachEnabled" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.multi_attach_enabled (fun f ->
               Aws.Query.Pair ("MultiAttachEnabled", Boolean.to_query f))
         ; Aws.Util.option_map v.fast_restored (fun f ->
               Aws.Query.Pair ("FastRestored", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("VolumeType", VolumeType.to_query v.volume_type))
         ; Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.iops (fun f ->
               Aws.Query.Pair ("Iops", Integer.to_query f))
         ; Some (Aws.Query.Pair ("VolumeId", String.to_query v.volume_id))
         ; Some (Aws.Query.Pair ("Status", VolumeState.to_query v.state))
         ; Some (Aws.Query.Pair ("SnapshotId", String.to_query v.snapshot_id))
         ; Some (Aws.Query.Pair ("Size", Integer.to_query v.size))
         ; Aws.Util.option_map v.outpost_arn (fun f ->
               Aws.Query.Pair ("OutpostArn", String.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Some (Aws.Query.Pair ("Encrypted", Boolean.to_query v.encrypted))
         ; Some (Aws.Query.Pair ("CreateTime", DateTime.to_query v.create_time))
         ; Some (Aws.Query.Pair ("AvailabilityZone", String.to_query v.availability_zone))
         ; Some
             (Aws.Query.Pair ("AttachmentSet", VolumeAttachmentList.to_query v.attachments))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.multi_attach_enabled (fun f ->
               "multiAttachEnabled", Boolean.to_json f)
         ; Aws.Util.option_map v.fast_restored (fun f ->
               "fastRestored", Boolean.to_json f)
         ; Some ("volumeType", VolumeType.to_json v.volume_type)
         ; Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.iops (fun f -> "iops", Integer.to_json f)
         ; Some ("volumeId", String.to_json v.volume_id)
         ; Some ("status", VolumeState.to_json v.state)
         ; Some ("snapshotId", String.to_json v.snapshot_id)
         ; Some ("size", Integer.to_json v.size)
         ; Aws.Util.option_map v.outpost_arn (fun f -> "outpostArn", String.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "kmsKeyId", String.to_json f)
         ; Some ("encrypted", Boolean.to_json v.encrypted)
         ; Some ("createTime", DateTime.to_json v.create_time)
         ; Some ("availabilityZone", String.to_json v.availability_zone)
         ; Some ("attachmentSet", VolumeAttachmentList.to_json v.attachments)
         ])

  let of_json j =
    { attachments =
        VolumeAttachmentList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "attachmentSet"))
    ; availability_zone =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "availabilityZone"))
    ; create_time =
        DateTime.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "createTime"))
    ; encrypted = Boolean.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "encrypted"))
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "kmsKeyId") String.of_json
    ; outpost_arn = Aws.Util.option_map (Aws.Json.lookup j "outpostArn") String.of_json
    ; size = Integer.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "size"))
    ; snapshot_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "snapshotId"))
    ; state = VolumeState.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "status"))
    ; volume_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "volumeId"))
    ; iops = Aws.Util.option_map (Aws.Json.lookup j "iops") Integer.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    ; volume_type =
        VolumeType.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "volumeType"))
    ; fast_restored =
        Aws.Util.option_map (Aws.Json.lookup j "fastRestored") Boolean.of_json
    ; multi_attach_enabled =
        Aws.Util.option_map (Aws.Json.lookup j "multiAttachEnabled") Boolean.of_json
    }
end

module FleetEventType = struct
  type t =
    | Instance_change
    | Fleet_change
    | Service_error

  let str_to_t =
    [ "service-error", Service_error
    ; "fleet-change", Fleet_change
    ; "instance-change", Instance_change
    ]

  let t_to_str =
    [ Service_error, "service-error"
    ; Fleet_change, "fleet-change"
    ; Instance_change, "instance-change"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module RevokeSecurityGroupIngressResult = struct
  type t =
    { return : Boolean.t option
    ; unknown_ip_permissions : IpPermissionList.t
    }

  let make ?return ?(unknown_ip_permissions = []) () = { return; unknown_ip_permissions }

  let parse xml =
    Some
      { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse
      ; unknown_ip_permissions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "unknownIpPermissionSet" xml)
               IpPermissionList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "UnknownIpPermissionSet"
                , IpPermissionList.to_query v.unknown_ip_permissions ))
         ; Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ("unknownIpPermissionSet", IpPermissionList.to_json v.unknown_ip_permissions)
         ; Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f)
         ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json
    ; unknown_ip_permissions =
        IpPermissionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "unknownIpPermissionSet"))
    }
end

module LaunchTemplateLicenseConfigurationRequest = struct
  type t = { license_configuration_arn : String.t option }

  let make ?license_configuration_arn () = { license_configuration_arn }

  let parse xml =
    Some
      { license_configuration_arn =
          Aws.Util.option_bind (Aws.Xml.member "LicenseConfigurationArn" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.license_configuration_arn (fun f ->
               Aws.Query.Pair ("LicenseConfigurationArn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.license_configuration_arn (fun f ->
               "LicenseConfigurationArn", String.to_json f)
         ])

  let of_json j =
    { license_configuration_arn =
        Aws.Util.option_map (Aws.Json.lookup j "LicenseConfigurationArn") String.of_json
    }
end

module LaunchTemplateLicenseSpecificationListRequest = struct
  type t = LaunchTemplateLicenseConfigurationRequest.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         LaunchTemplateLicenseConfigurationRequest.parse
         (Aws.Xml.members "item" xml))

  let to_query v =
    Aws.Query.to_query_list LaunchTemplateLicenseConfigurationRequest.to_query v

  let to_json v = `List (List.map LaunchTemplateLicenseConfigurationRequest.to_json v)

  let of_json j = Aws.Json.to_list LaunchTemplateLicenseConfigurationRequest.of_json j
end

module SpotMarketOptions = struct
  type t =
    { max_price : String.t option
    ; spot_instance_type : SpotInstanceType.t option
    ; block_duration_minutes : Integer.t option
    ; valid_until : DateTime.t option
    ; instance_interruption_behavior : InstanceInterruptionBehavior.t option
    }

  let make
      ?max_price
      ?spot_instance_type
      ?block_duration_minutes
      ?valid_until
      ?instance_interruption_behavior
      () =
    { max_price
    ; spot_instance_type
    ; block_duration_minutes
    ; valid_until
    ; instance_interruption_behavior
    }

  let parse xml =
    Some
      { max_price = Aws.Util.option_bind (Aws.Xml.member "MaxPrice" xml) String.parse
      ; spot_instance_type =
          Aws.Util.option_bind
            (Aws.Xml.member "SpotInstanceType" xml)
            SpotInstanceType.parse
      ; block_duration_minutes =
          Aws.Util.option_bind (Aws.Xml.member "BlockDurationMinutes" xml) Integer.parse
      ; valid_until =
          Aws.Util.option_bind (Aws.Xml.member "ValidUntil" xml) DateTime.parse
      ; instance_interruption_behavior =
          Aws.Util.option_bind
            (Aws.Xml.member "InstanceInterruptionBehavior" xml)
            InstanceInterruptionBehavior.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_interruption_behavior (fun f ->
               Aws.Query.Pair
                 ("InstanceInterruptionBehavior", InstanceInterruptionBehavior.to_query f))
         ; Aws.Util.option_map v.valid_until (fun f ->
               Aws.Query.Pair ("ValidUntil", DateTime.to_query f))
         ; Aws.Util.option_map v.block_duration_minutes (fun f ->
               Aws.Query.Pair ("BlockDurationMinutes", Integer.to_query f))
         ; Aws.Util.option_map v.spot_instance_type (fun f ->
               Aws.Query.Pair ("SpotInstanceType", SpotInstanceType.to_query f))
         ; Aws.Util.option_map v.max_price (fun f ->
               Aws.Query.Pair ("MaxPrice", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_interruption_behavior (fun f ->
               "InstanceInterruptionBehavior", InstanceInterruptionBehavior.to_json f)
         ; Aws.Util.option_map v.valid_until (fun f -> "ValidUntil", DateTime.to_json f)
         ; Aws.Util.option_map v.block_duration_minutes (fun f ->
               "BlockDurationMinutes", Integer.to_json f)
         ; Aws.Util.option_map v.spot_instance_type (fun f ->
               "SpotInstanceType", SpotInstanceType.to_json f)
         ; Aws.Util.option_map v.max_price (fun f -> "MaxPrice", String.to_json f)
         ])

  let of_json j =
    { max_price = Aws.Util.option_map (Aws.Json.lookup j "MaxPrice") String.of_json
    ; spot_instance_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "SpotInstanceType")
          SpotInstanceType.of_json
    ; block_duration_minutes =
        Aws.Util.option_map (Aws.Json.lookup j "BlockDurationMinutes") Integer.of_json
    ; valid_until = Aws.Util.option_map (Aws.Json.lookup j "ValidUntil") DateTime.of_json
    ; instance_interruption_behavior =
        Aws.Util.option_map
          (Aws.Json.lookup j "InstanceInterruptionBehavior")
          InstanceInterruptionBehavior.of_json
    }
end

module InstanceMarketOptionsRequest = struct
  type t =
    { market_type : MarketType.t option
    ; spot_options : SpotMarketOptions.t option
    }

  let make ?market_type ?spot_options () = { market_type; spot_options }

  let parse xml =
    Some
      { market_type =
          Aws.Util.option_bind (Aws.Xml.member "MarketType" xml) MarketType.parse
      ; spot_options =
          Aws.Util.option_bind (Aws.Xml.member "SpotOptions" xml) SpotMarketOptions.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.spot_options (fun f ->
               Aws.Query.Pair ("SpotOptions", SpotMarketOptions.to_query f))
         ; Aws.Util.option_map v.market_type (fun f ->
               Aws.Query.Pair ("MarketType", MarketType.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.spot_options (fun f ->
               "SpotOptions", SpotMarketOptions.to_json f)
         ; Aws.Util.option_map v.market_type (fun f -> "MarketType", MarketType.to_json f)
         ])

  let of_json j =
    { market_type =
        Aws.Util.option_map (Aws.Json.lookup j "MarketType") MarketType.of_json
    ; spot_options =
        Aws.Util.option_map (Aws.Json.lookup j "SpotOptions") SpotMarketOptions.of_json
    }
end

module ServiceTypeDetailSet = struct
  type t = ServiceTypeDetail.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ServiceTypeDetail.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ServiceTypeDetail.to_query v

  let to_json v = `List (List.map ServiceTypeDetail.to_json v)

  let of_json j = Aws.Json.to_list ServiceTypeDetail.of_json j
end

module DnsNameState = struct
  type t =
    | PendingVerification
    | Verified
    | Failed

  let str_to_t =
    [ "failed", Failed; "verified", Verified; "pendingVerification", PendingVerification ]

  let t_to_str =
    [ Failed, "failed"; Verified, "verified"; PendingVerification, "pendingVerification" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ServiceDetail = struct
  type t =
    { service_name : String.t option
    ; service_id : String.t option
    ; service_type : ServiceTypeDetailSet.t
    ; availability_zones : ValueStringList.t
    ; owner : String.t option
    ; base_endpoint_dns_names : ValueStringList.t
    ; private_dns_name : String.t option
    ; vpc_endpoint_policy_supported : Boolean.t option
    ; acceptance_required : Boolean.t option
    ; manages_vpc_endpoints : Boolean.t option
    ; tags : TagList.t
    ; private_dns_name_verification_state : DnsNameState.t option
    }

  let make
      ?service_name
      ?service_id
      ?(service_type = [])
      ?(availability_zones = [])
      ?owner
      ?(base_endpoint_dns_names = [])
      ?private_dns_name
      ?vpc_endpoint_policy_supported
      ?acceptance_required
      ?manages_vpc_endpoints
      ?(tags = [])
      ?private_dns_name_verification_state
      () =
    { service_name
    ; service_id
    ; service_type
    ; availability_zones
    ; owner
    ; base_endpoint_dns_names
    ; private_dns_name
    ; vpc_endpoint_policy_supported
    ; acceptance_required
    ; manages_vpc_endpoints
    ; tags
    ; private_dns_name_verification_state
    }

  let parse xml =
    Some
      { service_name =
          Aws.Util.option_bind (Aws.Xml.member "serviceName" xml) String.parse
      ; service_id = Aws.Util.option_bind (Aws.Xml.member "serviceId" xml) String.parse
      ; service_type =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "serviceType" xml)
               ServiceTypeDetailSet.parse)
      ; availability_zones =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "availabilityZoneSet" xml)
               ValueStringList.parse)
      ; owner = Aws.Util.option_bind (Aws.Xml.member "owner" xml) String.parse
      ; base_endpoint_dns_names =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "baseEndpointDnsNameSet" xml)
               ValueStringList.parse)
      ; private_dns_name =
          Aws.Util.option_bind (Aws.Xml.member "privateDnsName" xml) String.parse
      ; vpc_endpoint_policy_supported =
          Aws.Util.option_bind
            (Aws.Xml.member "vpcEndpointPolicySupported" xml)
            Boolean.parse
      ; acceptance_required =
          Aws.Util.option_bind (Aws.Xml.member "acceptanceRequired" xml) Boolean.parse
      ; manages_vpc_endpoints =
          Aws.Util.option_bind (Aws.Xml.member "managesVpcEndpoints" xml) Boolean.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      ; private_dns_name_verification_state =
          Aws.Util.option_bind
            (Aws.Xml.member "privateDnsNameVerificationState" xml)
            DnsNameState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.private_dns_name_verification_state (fun f ->
               Aws.Query.Pair ("PrivateDnsNameVerificationState", DnsNameState.to_query f))
         ; Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.manages_vpc_endpoints (fun f ->
               Aws.Query.Pair ("ManagesVpcEndpoints", Boolean.to_query f))
         ; Aws.Util.option_map v.acceptance_required (fun f ->
               Aws.Query.Pair ("AcceptanceRequired", Boolean.to_query f))
         ; Aws.Util.option_map v.vpc_endpoint_policy_supported (fun f ->
               Aws.Query.Pair ("VpcEndpointPolicySupported", Boolean.to_query f))
         ; Aws.Util.option_map v.private_dns_name (fun f ->
               Aws.Query.Pair ("PrivateDnsName", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "BaseEndpointDnsNameSet"
                , ValueStringList.to_query v.base_endpoint_dns_names ))
         ; Aws.Util.option_map v.owner (fun f ->
               Aws.Query.Pair ("Owner", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("AvailabilityZoneSet", ValueStringList.to_query v.availability_zones))
         ; Some
             (Aws.Query.Pair ("ServiceType", ServiceTypeDetailSet.to_query v.service_type))
         ; Aws.Util.option_map v.service_id (fun f ->
               Aws.Query.Pair ("ServiceId", String.to_query f))
         ; Aws.Util.option_map v.service_name (fun f ->
               Aws.Query.Pair ("ServiceName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.private_dns_name_verification_state (fun f ->
               "privateDnsNameVerificationState", DnsNameState.to_json f)
         ; Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.manages_vpc_endpoints (fun f ->
               "managesVpcEndpoints", Boolean.to_json f)
         ; Aws.Util.option_map v.acceptance_required (fun f ->
               "acceptanceRequired", Boolean.to_json f)
         ; Aws.Util.option_map v.vpc_endpoint_policy_supported (fun f ->
               "vpcEndpointPolicySupported", Boolean.to_json f)
         ; Aws.Util.option_map v.private_dns_name (fun f ->
               "privateDnsName", String.to_json f)
         ; Some
             ("baseEndpointDnsNameSet", ValueStringList.to_json v.base_endpoint_dns_names)
         ; Aws.Util.option_map v.owner (fun f -> "owner", String.to_json f)
         ; Some ("availabilityZoneSet", ValueStringList.to_json v.availability_zones)
         ; Some ("serviceType", ServiceTypeDetailSet.to_json v.service_type)
         ; Aws.Util.option_map v.service_id (fun f -> "serviceId", String.to_json f)
         ; Aws.Util.option_map v.service_name (fun f -> "serviceName", String.to_json f)
         ])

  let of_json j =
    { service_name = Aws.Util.option_map (Aws.Json.lookup j "serviceName") String.of_json
    ; service_id = Aws.Util.option_map (Aws.Json.lookup j "serviceId") String.of_json
    ; service_type =
        ServiceTypeDetailSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "serviceType"))
    ; availability_zones =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "availabilityZoneSet"))
    ; owner = Aws.Util.option_map (Aws.Json.lookup j "owner") String.of_json
    ; base_endpoint_dns_names =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "baseEndpointDnsNameSet"))
    ; private_dns_name =
        Aws.Util.option_map (Aws.Json.lookup j "privateDnsName") String.of_json
    ; vpc_endpoint_policy_supported =
        Aws.Util.option_map
          (Aws.Json.lookup j "vpcEndpointPolicySupported")
          Boolean.of_json
    ; acceptance_required =
        Aws.Util.option_map (Aws.Json.lookup j "acceptanceRequired") Boolean.of_json
    ; manages_vpc_endpoints =
        Aws.Util.option_map (Aws.Json.lookup j "managesVpcEndpoints") Boolean.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    ; private_dns_name_verification_state =
        Aws.Util.option_map
          (Aws.Json.lookup j "privateDnsNameVerificationState")
          DnsNameState.of_json
    }
end

module ServiceDetailSet = struct
  type t = ServiceDetail.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ServiceDetail.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ServiceDetail.to_query v

  let to_json v = `List (List.map ServiceDetail.to_json v)

  let of_json j = Aws.Json.to_list ServiceDetail.of_json j
end

module AcceptVpcPeeringConnectionRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; vpc_peering_connection_id : String.t option
    }

  let make ?dry_run ?vpc_peering_connection_id () = { dry_run; vpc_peering_connection_id }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; vpc_peering_connection_id =
          Aws.Util.option_bind (Aws.Xml.member "vpcPeeringConnectionId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_peering_connection_id (fun f ->
               Aws.Query.Pair ("VpcPeeringConnectionId", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_peering_connection_id (fun f ->
               "vpcPeeringConnectionId", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; vpc_peering_connection_id =
        Aws.Util.option_map (Aws.Json.lookup j "vpcPeeringConnectionId") String.of_json
    }
end

module DisableTransitGatewayRouteTablePropagationRequest = struct
  type t =
    { transit_gateway_route_table_id : String.t
    ; transit_gateway_attachment_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~transit_gateway_route_table_id ~transit_gateway_attachment_id ?dry_run () =
    { transit_gateway_route_table_id; transit_gateway_attachment_id; dry_run }

  let parse xml =
    Some
      { transit_gateway_route_table_id =
          Aws.Xml.required
            "TransitGatewayRouteTableId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayRouteTableId" xml)
               String.parse)
      ; transit_gateway_attachment_id =
          Aws.Xml.required
            "TransitGatewayAttachmentId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayAttachmentId" xml)
               String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayAttachmentId"
                , String.to_query v.transit_gateway_attachment_id ))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayRouteTableId"
                , String.to_query v.transit_gateway_route_table_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ("TransitGatewayAttachmentId", String.to_json v.transit_gateway_attachment_id)
         ; Some
             ( "TransitGatewayRouteTableId"
             , String.to_json v.transit_gateway_route_table_id )
         ])

  let of_json j =
    { transit_gateway_route_table_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayRouteTableId"))
    ; transit_gateway_attachment_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayAttachmentId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module ModifyVolumeAttributeRequest = struct
  type t =
    { auto_enable_i_o : AttributeBooleanValue.t option
    ; volume_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ?auto_enable_i_o ~volume_id ?dry_run () =
    { auto_enable_i_o; volume_id; dry_run }

  let parse xml =
    Some
      { auto_enable_i_o =
          Aws.Util.option_bind
            (Aws.Xml.member "AutoEnableIO" xml)
            AttributeBooleanValue.parse
      ; volume_id =
          Aws.Xml.required
            "VolumeId"
            (Aws.Util.option_bind (Aws.Xml.member "VolumeId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("VolumeId", String.to_query v.volume_id))
         ; Aws.Util.option_map v.auto_enable_i_o (fun f ->
               Aws.Query.Pair ("AutoEnableIO", AttributeBooleanValue.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("VolumeId", String.to_json v.volume_id)
         ; Aws.Util.option_map v.auto_enable_i_o (fun f ->
               "AutoEnableIO", AttributeBooleanValue.to_json f)
         ])

  let of_json j =
    { auto_enable_i_o =
        Aws.Util.option_map
          (Aws.Json.lookup j "AutoEnableIO")
          AttributeBooleanValue.of_json
    ; volume_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VolumeId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module TrafficMirrorFilterRuleField = struct
  type t =
    | Destination_port_range
    | Source_port_range
    | Protocol
    | Description

  let str_to_t =
    [ "description", Description
    ; "protocol", Protocol
    ; "source-port-range", Source_port_range
    ; "destination-port-range", Destination_port_range
    ]

  let t_to_str =
    [ Description, "description"
    ; Protocol, "protocol"
    ; Source_port_range, "source-port-range"
    ; Destination_port_range, "destination-port-range"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module VpcEndpointSecurityGroupIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module ModifyVpcEndpointRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; vpc_endpoint_id : String.t
    ; reset_policy : Boolean.t option
    ; policy_document : String.t option
    ; add_route_table_ids : VpcEndpointRouteTableIdList.t
    ; remove_route_table_ids : VpcEndpointRouteTableIdList.t
    ; add_subnet_ids : VpcEndpointSubnetIdList.t
    ; remove_subnet_ids : VpcEndpointSubnetIdList.t
    ; add_security_group_ids : VpcEndpointSecurityGroupIdList.t
    ; remove_security_group_ids : VpcEndpointSecurityGroupIdList.t
    ; private_dns_enabled : Boolean.t option
    }

  let make
      ?dry_run
      ~vpc_endpoint_id
      ?reset_policy
      ?policy_document
      ?(add_route_table_ids = [])
      ?(remove_route_table_ids = [])
      ?(add_subnet_ids = [])
      ?(remove_subnet_ids = [])
      ?(add_security_group_ids = [])
      ?(remove_security_group_ids = [])
      ?private_dns_enabled
      () =
    { dry_run
    ; vpc_endpoint_id
    ; reset_policy
    ; policy_document
    ; add_route_table_ids
    ; remove_route_table_ids
    ; add_subnet_ids
    ; remove_subnet_ids
    ; add_security_group_ids
    ; remove_security_group_ids
    ; private_dns_enabled
    }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; vpc_endpoint_id =
          Aws.Xml.required
            "VpcEndpointId"
            (Aws.Util.option_bind (Aws.Xml.member "VpcEndpointId" xml) String.parse)
      ; reset_policy =
          Aws.Util.option_bind (Aws.Xml.member "ResetPolicy" xml) Boolean.parse
      ; policy_document =
          Aws.Util.option_bind (Aws.Xml.member "PolicyDocument" xml) String.parse
      ; add_route_table_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AddRouteTableId" xml)
               VpcEndpointRouteTableIdList.parse)
      ; remove_route_table_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "RemoveRouteTableId" xml)
               VpcEndpointRouteTableIdList.parse)
      ; add_subnet_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AddSubnetId" xml)
               VpcEndpointSubnetIdList.parse)
      ; remove_subnet_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "RemoveSubnetId" xml)
               VpcEndpointSubnetIdList.parse)
      ; add_security_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AddSecurityGroupId" xml)
               VpcEndpointSecurityGroupIdList.parse)
      ; remove_security_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "RemoveSecurityGroupId" xml)
               VpcEndpointSecurityGroupIdList.parse)
      ; private_dns_enabled =
          Aws.Util.option_bind (Aws.Xml.member "PrivateDnsEnabled" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.private_dns_enabled (fun f ->
               Aws.Query.Pair ("PrivateDnsEnabled", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "RemoveSecurityGroupId"
                , VpcEndpointSecurityGroupIdList.to_query v.remove_security_group_ids ))
         ; Some
             (Aws.Query.Pair
                ( "AddSecurityGroupId"
                , VpcEndpointSecurityGroupIdList.to_query v.add_security_group_ids ))
         ; Some
             (Aws.Query.Pair
                ("RemoveSubnetId", VpcEndpointSubnetIdList.to_query v.remove_subnet_ids))
         ; Some
             (Aws.Query.Pair
                ("AddSubnetId", VpcEndpointSubnetIdList.to_query v.add_subnet_ids))
         ; Some
             (Aws.Query.Pair
                ( "RemoveRouteTableId"
                , VpcEndpointRouteTableIdList.to_query v.remove_route_table_ids ))
         ; Some
             (Aws.Query.Pair
                ( "AddRouteTableId"
                , VpcEndpointRouteTableIdList.to_query v.add_route_table_ids ))
         ; Aws.Util.option_map v.policy_document (fun f ->
               Aws.Query.Pair ("PolicyDocument", String.to_query f))
         ; Aws.Util.option_map v.reset_policy (fun f ->
               Aws.Query.Pair ("ResetPolicy", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("VpcEndpointId", String.to_query v.vpc_endpoint_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.private_dns_enabled (fun f ->
               "PrivateDnsEnabled", Boolean.to_json f)
         ; Some
             ( "RemoveSecurityGroupId"
             , VpcEndpointSecurityGroupIdList.to_json v.remove_security_group_ids )
         ; Some
             ( "AddSecurityGroupId"
             , VpcEndpointSecurityGroupIdList.to_json v.add_security_group_ids )
         ; Some ("RemoveSubnetId", VpcEndpointSubnetIdList.to_json v.remove_subnet_ids)
         ; Some ("AddSubnetId", VpcEndpointSubnetIdList.to_json v.add_subnet_ids)
         ; Some
             ( "RemoveRouteTableId"
             , VpcEndpointRouteTableIdList.to_json v.remove_route_table_ids )
         ; Some
             ("AddRouteTableId", VpcEndpointRouteTableIdList.to_json v.add_route_table_ids)
         ; Aws.Util.option_map v.policy_document (fun f ->
               "PolicyDocument", String.to_json f)
         ; Aws.Util.option_map v.reset_policy (fun f -> "ResetPolicy", Boolean.to_json f)
         ; Some ("VpcEndpointId", String.to_json v.vpc_endpoint_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; vpc_endpoint_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcEndpointId"))
    ; reset_policy = Aws.Util.option_map (Aws.Json.lookup j "ResetPolicy") Boolean.of_json
    ; policy_document =
        Aws.Util.option_map (Aws.Json.lookup j "PolicyDocument") String.of_json
    ; add_route_table_ids =
        VpcEndpointRouteTableIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AddRouteTableId"))
    ; remove_route_table_ids =
        VpcEndpointRouteTableIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "RemoveRouteTableId"))
    ; add_subnet_ids =
        VpcEndpointSubnetIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AddSubnetId"))
    ; remove_subnet_ids =
        VpcEndpointSubnetIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "RemoveSubnetId"))
    ; add_security_group_ids =
        VpcEndpointSecurityGroupIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AddSecurityGroupId"))
    ; remove_security_group_ids =
        VpcEndpointSecurityGroupIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "RemoveSecurityGroupId"))
    ; private_dns_enabled =
        Aws.Util.option_map (Aws.Json.lookup j "PrivateDnsEnabled") Boolean.of_json
    }
end

module DisassociateTransitGatewayMulticastDomainRequest = struct
  type t =
    { transit_gateway_multicast_domain_id : String.t option
    ; transit_gateway_attachment_id : String.t option
    ; subnet_ids : ValueStringList.t
    ; dry_run : Boolean.t option
    }

  let make
      ?transit_gateway_multicast_domain_id
      ?transit_gateway_attachment_id
      ?(subnet_ids = [])
      ?dry_run
      () =
    { transit_gateway_multicast_domain_id
    ; transit_gateway_attachment_id
    ; subnet_ids
    ; dry_run
    }

  let parse xml =
    Some
      { transit_gateway_multicast_domain_id =
          Aws.Util.option_bind
            (Aws.Xml.member "TransitGatewayMulticastDomainId" xml)
            String.parse
      ; transit_gateway_attachment_id =
          Aws.Util.option_bind
            (Aws.Xml.member "TransitGatewayAttachmentId" xml)
            String.parse
      ; subnet_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "SubnetIds" xml) ValueStringList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("SubnetIds", ValueStringList.to_query v.subnet_ids))
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               Aws.Query.Pair ("TransitGatewayAttachmentId", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               Aws.Query.Pair ("TransitGatewayMulticastDomainId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("SubnetIds", ValueStringList.to_json v.subnet_ids)
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               "TransitGatewayAttachmentId", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               "TransitGatewayMulticastDomainId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_multicast_domain_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "TransitGatewayMulticastDomainId")
          String.of_json
    ; transit_gateway_attachment_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "TransitGatewayAttachmentId")
          String.of_json
    ; subnet_ids =
        ValueStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SubnetIds"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DescribeConversionTasksRequest = struct
  type t =
    { conversion_task_ids : ConversionIdStringList.t
    ; dry_run : Boolean.t option
    }

  let make ?(conversion_task_ids = []) ?dry_run () = { conversion_task_ids; dry_run }

  let parse xml =
    Some
      { conversion_task_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "conversionTaskId" xml)
               ConversionIdStringList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ConversionTaskId", ConversionIdStringList.to_query v.conversion_task_ids))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("conversionTaskId", ConversionIdStringList.to_json v.conversion_task_ids)
         ])

  let of_json j =
    { conversion_task_ids =
        ConversionIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "conversionTaskId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module AccountAttributeName = struct
  type t =
    | Supported_platforms
    | Default_vpc

  let str_to_t =
    [ "default-vpc", Default_vpc; "supported-platforms", Supported_platforms ]

  let t_to_str =
    [ Default_vpc, "default-vpc"; Supported_platforms, "supported-platforms" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module AccountAttributeNameStringList = struct
  type t = AccountAttributeName.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map AccountAttributeName.parse (Aws.Xml.members "attributeName" xml))

  let to_query v = Aws.Query.to_query_list AccountAttributeName.to_query v

  let to_json v = `List (List.map AccountAttributeName.to_json v)

  let of_json j = Aws.Json.to_list AccountAttributeName.of_json j
end

module DescribeAccountAttributesRequest = struct
  type t =
    { attribute_names : AccountAttributeNameStringList.t
    ; dry_run : Boolean.t option
    }

  let make ?(attribute_names = []) ?dry_run () = { attribute_names; dry_run }

  let parse xml =
    Some
      { attribute_names =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "attributeName" xml)
               AccountAttributeNameStringList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "AttributeName"
                , AccountAttributeNameStringList.to_query v.attribute_names ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("attributeName", AccountAttributeNameStringList.to_json v.attribute_names)
         ])

  let of_json j =
    { attribute_names =
        AccountAttributeNameStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "attributeName"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module ClientVpnAuthenticationList = struct
  type t = ClientVpnAuthentication.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ClientVpnAuthentication.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ClientVpnAuthentication.to_query v

  let to_json v = `List (List.map ClientVpnAuthentication.to_json v)

  let of_json j = Aws.Json.to_list ClientVpnAuthentication.of_json j
end

module SecurityGroupStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "SecurityGroup" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module LaunchTemplatesMonitoringRequest = struct
  type t = { enabled : Boolean.t option }

  let make ?enabled () = { enabled }

  let parse xml =
    Some { enabled = Aws.Util.option_bind (Aws.Xml.member "Enabled" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enabled (fun f ->
               Aws.Query.Pair ("Enabled", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enabled (fun f -> "Enabled", Boolean.to_json f) ])

  let of_json j =
    { enabled = Aws.Util.option_map (Aws.Json.lookup j "Enabled") Boolean.of_json }
end

module LaunchTemplateTagSpecificationRequest = struct
  type t =
    { resource_type : ResourceType.t option
    ; tags : TagList.t
    }

  let make ?resource_type ?(tags = []) () = { resource_type; tags }

  let parse xml =
    Some
      { resource_type =
          Aws.Util.option_bind (Aws.Xml.member "ResourceType" xml) ResourceType.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Tag" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tag", TagList.to_query v.tags))
         ; Aws.Util.option_map v.resource_type (fun f ->
               Aws.Query.Pair ("ResourceType", ResourceType.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Tag", TagList.to_json v.tags)
         ; Aws.Util.option_map v.resource_type (fun f ->
               "ResourceType", ResourceType.to_json f)
         ])

  let of_json j =
    { resource_type =
        Aws.Util.option_map (Aws.Json.lookup j "ResourceType") ResourceType.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Tag"))
    }
end

module LaunchTemplateTagSpecificationRequestList = struct
  type t = LaunchTemplateTagSpecificationRequest.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         LaunchTemplateTagSpecificationRequest.parse
         (Aws.Xml.members "LaunchTemplateTagSpecificationRequest" xml))

  let to_query v =
    Aws.Query.to_query_list LaunchTemplateTagSpecificationRequest.to_query v

  let to_json v = `List (List.map LaunchTemplateTagSpecificationRequest.to_json v)

  let of_json j = Aws.Json.to_list LaunchTemplateTagSpecificationRequest.of_json j
end

module LaunchTemplatePlacementRequest = struct
  type t =
    { availability_zone : String.t option
    ; affinity : String.t option
    ; group_name : String.t option
    ; host_id : String.t option
    ; tenancy : Tenancy.t option
    ; spread_domain : String.t option
    ; host_resource_group_arn : String.t option
    ; partition_number : Integer.t option
    }

  let make
      ?availability_zone
      ?affinity
      ?group_name
      ?host_id
      ?tenancy
      ?spread_domain
      ?host_resource_group_arn
      ?partition_number
      () =
    { availability_zone
    ; affinity
    ; group_name
    ; host_id
    ; tenancy
    ; spread_domain
    ; host_resource_group_arn
    ; partition_number
    }

  let parse xml =
    Some
      { availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "AvailabilityZone" xml) String.parse
      ; affinity = Aws.Util.option_bind (Aws.Xml.member "Affinity" xml) String.parse
      ; group_name = Aws.Util.option_bind (Aws.Xml.member "GroupName" xml) String.parse
      ; host_id = Aws.Util.option_bind (Aws.Xml.member "HostId" xml) String.parse
      ; tenancy = Aws.Util.option_bind (Aws.Xml.member "Tenancy" xml) Tenancy.parse
      ; spread_domain =
          Aws.Util.option_bind (Aws.Xml.member "SpreadDomain" xml) String.parse
      ; host_resource_group_arn =
          Aws.Util.option_bind (Aws.Xml.member "HostResourceGroupArn" xml) String.parse
      ; partition_number =
          Aws.Util.option_bind (Aws.Xml.member "PartitionNumber" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.partition_number (fun f ->
               Aws.Query.Pair ("PartitionNumber", Integer.to_query f))
         ; Aws.Util.option_map v.host_resource_group_arn (fun f ->
               Aws.Query.Pair ("HostResourceGroupArn", String.to_query f))
         ; Aws.Util.option_map v.spread_domain (fun f ->
               Aws.Query.Pair ("SpreadDomain", String.to_query f))
         ; Aws.Util.option_map v.tenancy (fun f ->
               Aws.Query.Pair ("Tenancy", Tenancy.to_query f))
         ; Aws.Util.option_map v.host_id (fun f ->
               Aws.Query.Pair ("HostId", String.to_query f))
         ; Aws.Util.option_map v.group_name (fun f ->
               Aws.Query.Pair ("GroupName", String.to_query f))
         ; Aws.Util.option_map v.affinity (fun f ->
               Aws.Query.Pair ("Affinity", String.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.partition_number (fun f ->
               "PartitionNumber", Integer.to_json f)
         ; Aws.Util.option_map v.host_resource_group_arn (fun f ->
               "HostResourceGroupArn", String.to_json f)
         ; Aws.Util.option_map v.spread_domain (fun f -> "SpreadDomain", String.to_json f)
         ; Aws.Util.option_map v.tenancy (fun f -> "Tenancy", Tenancy.to_json f)
         ; Aws.Util.option_map v.host_id (fun f -> "HostId", String.to_json f)
         ; Aws.Util.option_map v.group_name (fun f -> "GroupName", String.to_json f)
         ; Aws.Util.option_map v.affinity (fun f -> "Affinity", String.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "AvailabilityZone", String.to_json f)
         ])

  let of_json j =
    { availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "AvailabilityZone") String.of_json
    ; affinity = Aws.Util.option_map (Aws.Json.lookup j "Affinity") String.of_json
    ; group_name = Aws.Util.option_map (Aws.Json.lookup j "GroupName") String.of_json
    ; host_id = Aws.Util.option_map (Aws.Json.lookup j "HostId") String.of_json
    ; tenancy = Aws.Util.option_map (Aws.Json.lookup j "Tenancy") Tenancy.of_json
    ; spread_domain =
        Aws.Util.option_map (Aws.Json.lookup j "SpreadDomain") String.of_json
    ; host_resource_group_arn =
        Aws.Util.option_map (Aws.Json.lookup j "HostResourceGroupArn") String.of_json
    ; partition_number =
        Aws.Util.option_map (Aws.Json.lookup j "PartitionNumber") Integer.of_json
    }
end

module LaunchTemplateInstanceNetworkInterfaceSpecificationRequest = struct
  type t =
    { associate_carrier_ip_address : Boolean.t option
    ; associate_public_ip_address : Boolean.t option
    ; delete_on_termination : Boolean.t option
    ; description : String.t option
    ; device_index : Integer.t option
    ; groups : SecurityGroupIdStringList.t
    ; interface_type : String.t option
    ; ipv6_address_count : Integer.t option
    ; ipv6_addresses : InstanceIpv6AddressListRequest.t
    ; network_interface_id : String.t option
    ; private_ip_address : String.t option
    ; private_ip_addresses : PrivateIpAddressSpecificationList.t
    ; secondary_private_ip_address_count : Integer.t option
    ; subnet_id : String.t option
    ; network_card_index : Integer.t option
    }

  let make
      ?associate_carrier_ip_address
      ?associate_public_ip_address
      ?delete_on_termination
      ?description
      ?device_index
      ?(groups = [])
      ?interface_type
      ?ipv6_address_count
      ?(ipv6_addresses = [])
      ?network_interface_id
      ?private_ip_address
      ?(private_ip_addresses = [])
      ?secondary_private_ip_address_count
      ?subnet_id
      ?network_card_index
      () =
    { associate_carrier_ip_address
    ; associate_public_ip_address
    ; delete_on_termination
    ; description
    ; device_index
    ; groups
    ; interface_type
    ; ipv6_address_count
    ; ipv6_addresses
    ; network_interface_id
    ; private_ip_address
    ; private_ip_addresses
    ; secondary_private_ip_address_count
    ; subnet_id
    ; network_card_index
    }

  let parse xml =
    Some
      { associate_carrier_ip_address =
          Aws.Util.option_bind
            (Aws.Xml.member "AssociateCarrierIpAddress" xml)
            Boolean.parse
      ; associate_public_ip_address =
          Aws.Util.option_bind
            (Aws.Xml.member "AssociatePublicIpAddress" xml)
            Boolean.parse
      ; delete_on_termination =
          Aws.Util.option_bind (Aws.Xml.member "DeleteOnTermination" xml) Boolean.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; device_index =
          Aws.Util.option_bind (Aws.Xml.member "DeviceIndex" xml) Integer.parse
      ; groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SecurityGroupId" xml)
               SecurityGroupIdStringList.parse)
      ; interface_type =
          Aws.Util.option_bind (Aws.Xml.member "InterfaceType" xml) String.parse
      ; ipv6_address_count =
          Aws.Util.option_bind (Aws.Xml.member "Ipv6AddressCount" xml) Integer.parse
      ; ipv6_addresses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Ipv6Addresses" xml)
               InstanceIpv6AddressListRequest.parse)
      ; network_interface_id =
          Aws.Util.option_bind (Aws.Xml.member "NetworkInterfaceId" xml) String.parse
      ; private_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "PrivateIpAddress" xml) String.parse
      ; private_ip_addresses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "PrivateIpAddresses" xml)
               PrivateIpAddressSpecificationList.parse)
      ; secondary_private_ip_address_count =
          Aws.Util.option_bind
            (Aws.Xml.member "SecondaryPrivateIpAddressCount" xml)
            Integer.parse
      ; subnet_id = Aws.Util.option_bind (Aws.Xml.member "SubnetId" xml) String.parse
      ; network_card_index =
          Aws.Util.option_bind (Aws.Xml.member "NetworkCardIndex" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.network_card_index (fun f ->
               Aws.Query.Pair ("NetworkCardIndex", Integer.to_query f))
         ; Aws.Util.option_map v.subnet_id (fun f ->
               Aws.Query.Pair ("SubnetId", String.to_query f))
         ; Aws.Util.option_map v.secondary_private_ip_address_count (fun f ->
               Aws.Query.Pair ("SecondaryPrivateIpAddressCount", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "PrivateIpAddresses"
                , PrivateIpAddressSpecificationList.to_query v.private_ip_addresses ))
         ; Aws.Util.option_map v.private_ip_address (fun f ->
               Aws.Query.Pair ("PrivateIpAddress", String.to_query f))
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               Aws.Query.Pair ("NetworkInterfaceId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Ipv6Addresses", InstanceIpv6AddressListRequest.to_query v.ipv6_addresses))
         ; Aws.Util.option_map v.ipv6_address_count (fun f ->
               Aws.Query.Pair ("Ipv6AddressCount", Integer.to_query f))
         ; Aws.Util.option_map v.interface_type (fun f ->
               Aws.Query.Pair ("InterfaceType", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("SecurityGroupId", SecurityGroupIdStringList.to_query v.groups))
         ; Aws.Util.option_map v.device_index (fun f ->
               Aws.Query.Pair ("DeviceIndex", Integer.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.delete_on_termination (fun f ->
               Aws.Query.Pair ("DeleteOnTermination", Boolean.to_query f))
         ; Aws.Util.option_map v.associate_public_ip_address (fun f ->
               Aws.Query.Pair ("AssociatePublicIpAddress", Boolean.to_query f))
         ; Aws.Util.option_map v.associate_carrier_ip_address (fun f ->
               Aws.Query.Pair ("AssociateCarrierIpAddress", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.network_card_index (fun f ->
               "NetworkCardIndex", Integer.to_json f)
         ; Aws.Util.option_map v.subnet_id (fun f -> "SubnetId", String.to_json f)
         ; Aws.Util.option_map v.secondary_private_ip_address_count (fun f ->
               "SecondaryPrivateIpAddressCount", Integer.to_json f)
         ; Some
             ( "PrivateIpAddresses"
             , PrivateIpAddressSpecificationList.to_json v.private_ip_addresses )
         ; Aws.Util.option_map v.private_ip_address (fun f ->
               "PrivateIpAddress", String.to_json f)
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               "NetworkInterfaceId", String.to_json f)
         ; Some ("Ipv6Addresses", InstanceIpv6AddressListRequest.to_json v.ipv6_addresses)
         ; Aws.Util.option_map v.ipv6_address_count (fun f ->
               "Ipv6AddressCount", Integer.to_json f)
         ; Aws.Util.option_map v.interface_type (fun f ->
               "InterfaceType", String.to_json f)
         ; Some ("SecurityGroupId", SecurityGroupIdStringList.to_json v.groups)
         ; Aws.Util.option_map v.device_index (fun f -> "DeviceIndex", Integer.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.delete_on_termination (fun f ->
               "DeleteOnTermination", Boolean.to_json f)
         ; Aws.Util.option_map v.associate_public_ip_address (fun f ->
               "AssociatePublicIpAddress", Boolean.to_json f)
         ; Aws.Util.option_map v.associate_carrier_ip_address (fun f ->
               "AssociateCarrierIpAddress", Boolean.to_json f)
         ])

  let of_json j =
    { associate_carrier_ip_address =
        Aws.Util.option_map
          (Aws.Json.lookup j "AssociateCarrierIpAddress")
          Boolean.of_json
    ; associate_public_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "AssociatePublicIpAddress") Boolean.of_json
    ; delete_on_termination =
        Aws.Util.option_map (Aws.Json.lookup j "DeleteOnTermination") Boolean.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; device_index = Aws.Util.option_map (Aws.Json.lookup j "DeviceIndex") Integer.of_json
    ; groups =
        SecurityGroupIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SecurityGroupId"))
    ; interface_type =
        Aws.Util.option_map (Aws.Json.lookup j "InterfaceType") String.of_json
    ; ipv6_address_count =
        Aws.Util.option_map (Aws.Json.lookup j "Ipv6AddressCount") Integer.of_json
    ; ipv6_addresses =
        InstanceIpv6AddressListRequest.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Ipv6Addresses"))
    ; network_interface_id =
        Aws.Util.option_map (Aws.Json.lookup j "NetworkInterfaceId") String.of_json
    ; private_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "PrivateIpAddress") String.of_json
    ; private_ip_addresses =
        PrivateIpAddressSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "PrivateIpAddresses"))
    ; secondary_private_ip_address_count =
        Aws.Util.option_map
          (Aws.Json.lookup j "SecondaryPrivateIpAddressCount")
          Integer.of_json
    ; subnet_id = Aws.Util.option_map (Aws.Json.lookup j "SubnetId") String.of_json
    ; network_card_index =
        Aws.Util.option_map (Aws.Json.lookup j "NetworkCardIndex") Integer.of_json
    }
end

module LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList = struct
  type t = LaunchTemplateInstanceNetworkInterfaceSpecificationRequest.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         LaunchTemplateInstanceNetworkInterfaceSpecificationRequest.parse
         (Aws.Xml.members "InstanceNetworkInterfaceSpecification" xml))

  let to_query v =
    Aws.Query.to_query_list
      LaunchTemplateInstanceNetworkInterfaceSpecificationRequest.to_query
      v

  let to_json v =
    `List (List.map LaunchTemplateInstanceNetworkInterfaceSpecificationRequest.to_json v)

  let of_json j =
    Aws.Json.to_list LaunchTemplateInstanceNetworkInterfaceSpecificationRequest.of_json j
end

module LaunchTemplateInstanceMetadataOptionsRequest = struct
  type t =
    { http_tokens : LaunchTemplateHttpTokensState.t option
    ; http_put_response_hop_limit : Integer.t option
    ; http_endpoint : LaunchTemplateInstanceMetadataEndpointState.t option
    }

  let make ?http_tokens ?http_put_response_hop_limit ?http_endpoint () =
    { http_tokens; http_put_response_hop_limit; http_endpoint }

  let parse xml =
    Some
      { http_tokens =
          Aws.Util.option_bind
            (Aws.Xml.member "HttpTokens" xml)
            LaunchTemplateHttpTokensState.parse
      ; http_put_response_hop_limit =
          Aws.Util.option_bind
            (Aws.Xml.member "HttpPutResponseHopLimit" xml)
            Integer.parse
      ; http_endpoint =
          Aws.Util.option_bind
            (Aws.Xml.member "HttpEndpoint" xml)
            LaunchTemplateInstanceMetadataEndpointState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.http_endpoint (fun f ->
               Aws.Query.Pair
                 ("HttpEndpoint", LaunchTemplateInstanceMetadataEndpointState.to_query f))
         ; Aws.Util.option_map v.http_put_response_hop_limit (fun f ->
               Aws.Query.Pair ("HttpPutResponseHopLimit", Integer.to_query f))
         ; Aws.Util.option_map v.http_tokens (fun f ->
               Aws.Query.Pair ("HttpTokens", LaunchTemplateHttpTokensState.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.http_endpoint (fun f ->
               "HttpEndpoint", LaunchTemplateInstanceMetadataEndpointState.to_json f)
         ; Aws.Util.option_map v.http_put_response_hop_limit (fun f ->
               "HttpPutResponseHopLimit", Integer.to_json f)
         ; Aws.Util.option_map v.http_tokens (fun f ->
               "HttpTokens", LaunchTemplateHttpTokensState.to_json f)
         ])

  let of_json j =
    { http_tokens =
        Aws.Util.option_map
          (Aws.Json.lookup j "HttpTokens")
          LaunchTemplateHttpTokensState.of_json
    ; http_put_response_hop_limit =
        Aws.Util.option_map (Aws.Json.lookup j "HttpPutResponseHopLimit") Integer.of_json
    ; http_endpoint =
        Aws.Util.option_map
          (Aws.Json.lookup j "HttpEndpoint")
          LaunchTemplateInstanceMetadataEndpointState.of_json
    }
end

module LaunchTemplateSpotMarketOptionsRequest = struct
  type t =
    { max_price : String.t option
    ; spot_instance_type : SpotInstanceType.t option
    ; block_duration_minutes : Integer.t option
    ; valid_until : DateTime.t option
    ; instance_interruption_behavior : InstanceInterruptionBehavior.t option
    }

  let make
      ?max_price
      ?spot_instance_type
      ?block_duration_minutes
      ?valid_until
      ?instance_interruption_behavior
      () =
    { max_price
    ; spot_instance_type
    ; block_duration_minutes
    ; valid_until
    ; instance_interruption_behavior
    }

  let parse xml =
    Some
      { max_price = Aws.Util.option_bind (Aws.Xml.member "MaxPrice" xml) String.parse
      ; spot_instance_type =
          Aws.Util.option_bind
            (Aws.Xml.member "SpotInstanceType" xml)
            SpotInstanceType.parse
      ; block_duration_minutes =
          Aws.Util.option_bind (Aws.Xml.member "BlockDurationMinutes" xml) Integer.parse
      ; valid_until =
          Aws.Util.option_bind (Aws.Xml.member "ValidUntil" xml) DateTime.parse
      ; instance_interruption_behavior =
          Aws.Util.option_bind
            (Aws.Xml.member "InstanceInterruptionBehavior" xml)
            InstanceInterruptionBehavior.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_interruption_behavior (fun f ->
               Aws.Query.Pair
                 ("InstanceInterruptionBehavior", InstanceInterruptionBehavior.to_query f))
         ; Aws.Util.option_map v.valid_until (fun f ->
               Aws.Query.Pair ("ValidUntil", DateTime.to_query f))
         ; Aws.Util.option_map v.block_duration_minutes (fun f ->
               Aws.Query.Pair ("BlockDurationMinutes", Integer.to_query f))
         ; Aws.Util.option_map v.spot_instance_type (fun f ->
               Aws.Query.Pair ("SpotInstanceType", SpotInstanceType.to_query f))
         ; Aws.Util.option_map v.max_price (fun f ->
               Aws.Query.Pair ("MaxPrice", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_interruption_behavior (fun f ->
               "InstanceInterruptionBehavior", InstanceInterruptionBehavior.to_json f)
         ; Aws.Util.option_map v.valid_until (fun f -> "ValidUntil", DateTime.to_json f)
         ; Aws.Util.option_map v.block_duration_minutes (fun f ->
               "BlockDurationMinutes", Integer.to_json f)
         ; Aws.Util.option_map v.spot_instance_type (fun f ->
               "SpotInstanceType", SpotInstanceType.to_json f)
         ; Aws.Util.option_map v.max_price (fun f -> "MaxPrice", String.to_json f)
         ])

  let of_json j =
    { max_price = Aws.Util.option_map (Aws.Json.lookup j "MaxPrice") String.of_json
    ; spot_instance_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "SpotInstanceType")
          SpotInstanceType.of_json
    ; block_duration_minutes =
        Aws.Util.option_map (Aws.Json.lookup j "BlockDurationMinutes") Integer.of_json
    ; valid_until = Aws.Util.option_map (Aws.Json.lookup j "ValidUntil") DateTime.of_json
    ; instance_interruption_behavior =
        Aws.Util.option_map
          (Aws.Json.lookup j "InstanceInterruptionBehavior")
          InstanceInterruptionBehavior.of_json
    }
end

module LaunchTemplateInstanceMarketOptionsRequest = struct
  type t =
    { market_type : MarketType.t option
    ; spot_options : LaunchTemplateSpotMarketOptionsRequest.t option
    }

  let make ?market_type ?spot_options () = { market_type; spot_options }

  let parse xml =
    Some
      { market_type =
          Aws.Util.option_bind (Aws.Xml.member "MarketType" xml) MarketType.parse
      ; spot_options =
          Aws.Util.option_bind
            (Aws.Xml.member "SpotOptions" xml)
            LaunchTemplateSpotMarketOptionsRequest.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.spot_options (fun f ->
               Aws.Query.Pair
                 ("SpotOptions", LaunchTemplateSpotMarketOptionsRequest.to_query f))
         ; Aws.Util.option_map v.market_type (fun f ->
               Aws.Query.Pair ("MarketType", MarketType.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.spot_options (fun f ->
               "SpotOptions", LaunchTemplateSpotMarketOptionsRequest.to_json f)
         ; Aws.Util.option_map v.market_type (fun f -> "MarketType", MarketType.to_json f)
         ])

  let of_json j =
    { market_type =
        Aws.Util.option_map (Aws.Json.lookup j "MarketType") MarketType.of_json
    ; spot_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "SpotOptions")
          LaunchTemplateSpotMarketOptionsRequest.of_json
    }
end

module LaunchTemplateIamInstanceProfileSpecificationRequest = struct
  type t =
    { arn : String.t option
    ; name : String.t option
    }

  let make ?arn ?name () = { arn; name }

  let parse xml =
    Some
      { arn = Aws.Util.option_bind (Aws.Xml.member "Arn" xml) String.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.arn (fun f -> Aws.Query.Pair ("Arn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.arn (fun f -> "Arn", String.to_json f)
         ])

  let of_json j =
    { arn = Aws.Util.option_map (Aws.Json.lookup j "Arn") String.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    }
end

module LaunchTemplateHibernationOptionsRequest = struct
  type t = { configured : Boolean.t option }

  let make ?configured () = { configured }

  let parse xml =
    Some
      { configured = Aws.Util.option_bind (Aws.Xml.member "Configured" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.configured (fun f ->
               Aws.Query.Pair ("Configured", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.configured (fun f -> "Configured", Boolean.to_json f) ])

  let of_json j =
    { configured = Aws.Util.option_map (Aws.Json.lookup j "Configured") Boolean.of_json }
end

module LaunchTemplateEnclaveOptionsRequest = struct
  type t = { enabled : Boolean.t option }

  let make ?enabled () = { enabled }

  let parse xml =
    Some { enabled = Aws.Util.option_bind (Aws.Xml.member "Enabled" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enabled (fun f ->
               Aws.Query.Pair ("Enabled", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enabled (fun f -> "Enabled", Boolean.to_json f) ])

  let of_json j =
    { enabled = Aws.Util.option_map (Aws.Json.lookup j "Enabled") Boolean.of_json }
end

module LaunchTemplateCpuOptionsRequest = struct
  type t =
    { core_count : Integer.t option
    ; threads_per_core : Integer.t option
    }

  let make ?core_count ?threads_per_core () = { core_count; threads_per_core }

  let parse xml =
    Some
      { core_count = Aws.Util.option_bind (Aws.Xml.member "CoreCount" xml) Integer.parse
      ; threads_per_core =
          Aws.Util.option_bind (Aws.Xml.member "ThreadsPerCore" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.threads_per_core (fun f ->
               Aws.Query.Pair ("ThreadsPerCore", Integer.to_query f))
         ; Aws.Util.option_map v.core_count (fun f ->
               Aws.Query.Pair ("CoreCount", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.threads_per_core (fun f ->
               "ThreadsPerCore", Integer.to_json f)
         ; Aws.Util.option_map v.core_count (fun f -> "CoreCount", Integer.to_json f)
         ])

  let of_json j =
    { core_count = Aws.Util.option_map (Aws.Json.lookup j "CoreCount") Integer.of_json
    ; threads_per_core =
        Aws.Util.option_map (Aws.Json.lookup j "ThreadsPerCore") Integer.of_json
    }
end

module LaunchTemplateCapacityReservationSpecificationRequest = struct
  type t =
    { capacity_reservation_preference : CapacityReservationPreference.t option
    ; capacity_reservation_target : CapacityReservationTarget.t option
    }

  let make ?capacity_reservation_preference ?capacity_reservation_target () =
    { capacity_reservation_preference; capacity_reservation_target }

  let parse xml =
    Some
      { capacity_reservation_preference =
          Aws.Util.option_bind
            (Aws.Xml.member "CapacityReservationPreference" xml)
            CapacityReservationPreference.parse
      ; capacity_reservation_target =
          Aws.Util.option_bind
            (Aws.Xml.member "CapacityReservationTarget" xml)
            CapacityReservationTarget.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.capacity_reservation_target (fun f ->
               Aws.Query.Pair
                 ("CapacityReservationTarget", CapacityReservationTarget.to_query f))
         ; Aws.Util.option_map v.capacity_reservation_preference (fun f ->
               Aws.Query.Pair
                 ( "CapacityReservationPreference"
                 , CapacityReservationPreference.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.capacity_reservation_target (fun f ->
               "CapacityReservationTarget", CapacityReservationTarget.to_json f)
         ; Aws.Util.option_map v.capacity_reservation_preference (fun f ->
               "CapacityReservationPreference", CapacityReservationPreference.to_json f)
         ])

  let of_json j =
    { capacity_reservation_preference =
        Aws.Util.option_map
          (Aws.Json.lookup j "CapacityReservationPreference")
          CapacityReservationPreference.of_json
    ; capacity_reservation_target =
        Aws.Util.option_map
          (Aws.Json.lookup j "CapacityReservationTarget")
          CapacityReservationTarget.of_json
    }
end

module ElasticGpuSpecification = struct
  type t = { type_ : String.t }

  let make ~type_ () = { type_ }

  let parse xml =
    Some
      { type_ =
          Aws.Xml.required
            "Type"
            (Aws.Util.option_bind (Aws.Xml.member "Type" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Type", String.to_query v.type_)) ])

  let to_json v =
    `Assoc (Aws.Util.list_filter_opt [ Some ("Type", String.to_json v.type_) ])

  let of_json j =
    { type_ = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Type")) }
end

module ElasticGpuSpecificationList = struct
  type t = ElasticGpuSpecification.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         ElasticGpuSpecification.parse
         (Aws.Xml.members "ElasticGpuSpecification" xml))

  let to_query v = Aws.Query.to_query_list ElasticGpuSpecification.to_query v

  let to_json v = `List (List.map ElasticGpuSpecification.to_json v)

  let of_json j = Aws.Json.to_list ElasticGpuSpecification.of_json j
end

module CreditSpecificationRequest = struct
  type t = { cpu_credits : String.t }

  let make ~cpu_credits () = { cpu_credits }

  let parse xml =
    Some
      { cpu_credits =
          Aws.Xml.required
            "CpuCredits"
            (Aws.Util.option_bind (Aws.Xml.member "CpuCredits" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("CpuCredits", String.to_query v.cpu_credits)) ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt [ Some ("CpuCredits", String.to_json v.cpu_credits) ])

  let of_json j =
    { cpu_credits =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "CpuCredits"))
    }
end

module RequestLaunchTemplateData = struct
  type t =
    { kernel_id : String.t option
    ; ebs_optimized : Boolean.t option
    ; iam_instance_profile : LaunchTemplateIamInstanceProfileSpecificationRequest.t option
    ; block_device_mappings : LaunchTemplateBlockDeviceMappingRequestList.t
    ; network_interfaces :
        LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList.t
    ; image_id : String.t option
    ; instance_type : InstanceType.t option
    ; key_name : String.t option
    ; monitoring : LaunchTemplatesMonitoringRequest.t option
    ; placement : LaunchTemplatePlacementRequest.t option
    ; ram_disk_id : String.t option
    ; disable_api_termination : Boolean.t option
    ; instance_initiated_shutdown_behavior : ShutdownBehavior.t option
    ; user_data : String.t option
    ; tag_specifications : LaunchTemplateTagSpecificationRequestList.t
    ; elastic_gpu_specifications : ElasticGpuSpecificationList.t
    ; elastic_inference_accelerators : LaunchTemplateElasticInferenceAcceleratorList.t
    ; security_group_ids : SecurityGroupIdStringList.t
    ; security_groups : SecurityGroupStringList.t
    ; instance_market_options : LaunchTemplateInstanceMarketOptionsRequest.t option
    ; credit_specification : CreditSpecificationRequest.t option
    ; cpu_options : LaunchTemplateCpuOptionsRequest.t option
    ; capacity_reservation_specification :
        LaunchTemplateCapacityReservationSpecificationRequest.t option
    ; license_specifications : LaunchTemplateLicenseSpecificationListRequest.t
    ; hibernation_options : LaunchTemplateHibernationOptionsRequest.t option
    ; metadata_options : LaunchTemplateInstanceMetadataOptionsRequest.t option
    ; enclave_options : LaunchTemplateEnclaveOptionsRequest.t option
    }

  let make
      ?kernel_id
      ?ebs_optimized
      ?iam_instance_profile
      ?(block_device_mappings = [])
      ?(network_interfaces = [])
      ?image_id
      ?instance_type
      ?key_name
      ?monitoring
      ?placement
      ?ram_disk_id
      ?disable_api_termination
      ?instance_initiated_shutdown_behavior
      ?user_data
      ?(tag_specifications = [])
      ?(elastic_gpu_specifications = [])
      ?(elastic_inference_accelerators = [])
      ?(security_group_ids = [])
      ?(security_groups = [])
      ?instance_market_options
      ?credit_specification
      ?cpu_options
      ?capacity_reservation_specification
      ?(license_specifications = [])
      ?hibernation_options
      ?metadata_options
      ?enclave_options
      () =
    { kernel_id
    ; ebs_optimized
    ; iam_instance_profile
    ; block_device_mappings
    ; network_interfaces
    ; image_id
    ; instance_type
    ; key_name
    ; monitoring
    ; placement
    ; ram_disk_id
    ; disable_api_termination
    ; instance_initiated_shutdown_behavior
    ; user_data
    ; tag_specifications
    ; elastic_gpu_specifications
    ; elastic_inference_accelerators
    ; security_group_ids
    ; security_groups
    ; instance_market_options
    ; credit_specification
    ; cpu_options
    ; capacity_reservation_specification
    ; license_specifications
    ; hibernation_options
    ; metadata_options
    ; enclave_options
    }

  let parse xml =
    Some
      { kernel_id = Aws.Util.option_bind (Aws.Xml.member "KernelId" xml) String.parse
      ; ebs_optimized =
          Aws.Util.option_bind (Aws.Xml.member "EbsOptimized" xml) Boolean.parse
      ; iam_instance_profile =
          Aws.Util.option_bind
            (Aws.Xml.member "IamInstanceProfile" xml)
            LaunchTemplateIamInstanceProfileSpecificationRequest.parse
      ; block_device_mappings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "BlockDeviceMapping" xml)
               LaunchTemplateBlockDeviceMappingRequestList.parse)
      ; network_interfaces =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "NetworkInterface" xml)
               LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList.parse)
      ; image_id = Aws.Util.option_bind (Aws.Xml.member "ImageId" xml) String.parse
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "InstanceType" xml) InstanceType.parse
      ; key_name = Aws.Util.option_bind (Aws.Xml.member "KeyName" xml) String.parse
      ; monitoring =
          Aws.Util.option_bind
            (Aws.Xml.member "Monitoring" xml)
            LaunchTemplatesMonitoringRequest.parse
      ; placement =
          Aws.Util.option_bind
            (Aws.Xml.member "Placement" xml)
            LaunchTemplatePlacementRequest.parse
      ; ram_disk_id = Aws.Util.option_bind (Aws.Xml.member "RamDiskId" xml) String.parse
      ; disable_api_termination =
          Aws.Util.option_bind (Aws.Xml.member "DisableApiTermination" xml) Boolean.parse
      ; instance_initiated_shutdown_behavior =
          Aws.Util.option_bind
            (Aws.Xml.member "InstanceInitiatedShutdownBehavior" xml)
            ShutdownBehavior.parse
      ; user_data = Aws.Util.option_bind (Aws.Xml.member "UserData" xml) String.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               LaunchTemplateTagSpecificationRequestList.parse)
      ; elastic_gpu_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ElasticGpuSpecification" xml)
               ElasticGpuSpecificationList.parse)
      ; elastic_inference_accelerators =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ElasticInferenceAccelerator" xml)
               LaunchTemplateElasticInferenceAcceleratorList.parse)
      ; security_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SecurityGroupId" xml)
               SecurityGroupIdStringList.parse)
      ; security_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SecurityGroup" xml)
               SecurityGroupStringList.parse)
      ; instance_market_options =
          Aws.Util.option_bind
            (Aws.Xml.member "InstanceMarketOptions" xml)
            LaunchTemplateInstanceMarketOptionsRequest.parse
      ; credit_specification =
          Aws.Util.option_bind
            (Aws.Xml.member "CreditSpecification" xml)
            CreditSpecificationRequest.parse
      ; cpu_options =
          Aws.Util.option_bind
            (Aws.Xml.member "CpuOptions" xml)
            LaunchTemplateCpuOptionsRequest.parse
      ; capacity_reservation_specification =
          Aws.Util.option_bind
            (Aws.Xml.member "CapacityReservationSpecification" xml)
            LaunchTemplateCapacityReservationSpecificationRequest.parse
      ; license_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "LicenseSpecification" xml)
               LaunchTemplateLicenseSpecificationListRequest.parse)
      ; hibernation_options =
          Aws.Util.option_bind
            (Aws.Xml.member "HibernationOptions" xml)
            LaunchTemplateHibernationOptionsRequest.parse
      ; metadata_options =
          Aws.Util.option_bind
            (Aws.Xml.member "MetadataOptions" xml)
            LaunchTemplateInstanceMetadataOptionsRequest.parse
      ; enclave_options =
          Aws.Util.option_bind
            (Aws.Xml.member "EnclaveOptions" xml)
            LaunchTemplateEnclaveOptionsRequest.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enclave_options (fun f ->
               Aws.Query.Pair
                 ("EnclaveOptions", LaunchTemplateEnclaveOptionsRequest.to_query f))
         ; Aws.Util.option_map v.metadata_options (fun f ->
               Aws.Query.Pair
                 ( "MetadataOptions"
                 , LaunchTemplateInstanceMetadataOptionsRequest.to_query f ))
         ; Aws.Util.option_map v.hibernation_options (fun f ->
               Aws.Query.Pair
                 ("HibernationOptions", LaunchTemplateHibernationOptionsRequest.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "LicenseSpecification"
                , LaunchTemplateLicenseSpecificationListRequest.to_query
                    v.license_specifications ))
         ; Aws.Util.option_map v.capacity_reservation_specification (fun f ->
               Aws.Query.Pair
                 ( "CapacityReservationSpecification"
                 , LaunchTemplateCapacityReservationSpecificationRequest.to_query f ))
         ; Aws.Util.option_map v.cpu_options (fun f ->
               Aws.Query.Pair ("CpuOptions", LaunchTemplateCpuOptionsRequest.to_query f))
         ; Aws.Util.option_map v.credit_specification (fun f ->
               Aws.Query.Pair
                 ("CreditSpecification", CreditSpecificationRequest.to_query f))
         ; Aws.Util.option_map v.instance_market_options (fun f ->
               Aws.Query.Pair
                 ( "InstanceMarketOptions"
                 , LaunchTemplateInstanceMarketOptionsRequest.to_query f ))
         ; Some
             (Aws.Query.Pair
                ("SecurityGroup", SecurityGroupStringList.to_query v.security_groups))
         ; Some
             (Aws.Query.Pair
                ( "SecurityGroupId"
                , SecurityGroupIdStringList.to_query v.security_group_ids ))
         ; Some
             (Aws.Query.Pair
                ( "ElasticInferenceAccelerator"
                , LaunchTemplateElasticInferenceAcceleratorList.to_query
                    v.elastic_inference_accelerators ))
         ; Some
             (Aws.Query.Pair
                ( "ElasticGpuSpecification"
                , ElasticGpuSpecificationList.to_query v.elastic_gpu_specifications ))
         ; Some
             (Aws.Query.Pair
                ( "TagSpecification"
                , LaunchTemplateTagSpecificationRequestList.to_query v.tag_specifications
                ))
         ; Aws.Util.option_map v.user_data (fun f ->
               Aws.Query.Pair ("UserData", String.to_query f))
         ; Aws.Util.option_map v.instance_initiated_shutdown_behavior (fun f ->
               Aws.Query.Pair
                 ("InstanceInitiatedShutdownBehavior", ShutdownBehavior.to_query f))
         ; Aws.Util.option_map v.disable_api_termination (fun f ->
               Aws.Query.Pair ("DisableApiTermination", Boolean.to_query f))
         ; Aws.Util.option_map v.ram_disk_id (fun f ->
               Aws.Query.Pair ("RamDiskId", String.to_query f))
         ; Aws.Util.option_map v.placement (fun f ->
               Aws.Query.Pair ("Placement", LaunchTemplatePlacementRequest.to_query f))
         ; Aws.Util.option_map v.monitoring (fun f ->
               Aws.Query.Pair ("Monitoring", LaunchTemplatesMonitoringRequest.to_query f))
         ; Aws.Util.option_map v.key_name (fun f ->
               Aws.Query.Pair ("KeyName", String.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", InstanceType.to_query f))
         ; Aws.Util.option_map v.image_id (fun f ->
               Aws.Query.Pair ("ImageId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "NetworkInterface"
                , LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList.to_query
                    v.network_interfaces ))
         ; Some
             (Aws.Query.Pair
                ( "BlockDeviceMapping"
                , LaunchTemplateBlockDeviceMappingRequestList.to_query
                    v.block_device_mappings ))
         ; Aws.Util.option_map v.iam_instance_profile (fun f ->
               Aws.Query.Pair
                 ( "IamInstanceProfile"
                 , LaunchTemplateIamInstanceProfileSpecificationRequest.to_query f ))
         ; Aws.Util.option_map v.ebs_optimized (fun f ->
               Aws.Query.Pair ("EbsOptimized", Boolean.to_query f))
         ; Aws.Util.option_map v.kernel_id (fun f ->
               Aws.Query.Pair ("KernelId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enclave_options (fun f ->
               "EnclaveOptions", LaunchTemplateEnclaveOptionsRequest.to_json f)
         ; Aws.Util.option_map v.metadata_options (fun f ->
               "MetadataOptions", LaunchTemplateInstanceMetadataOptionsRequest.to_json f)
         ; Aws.Util.option_map v.hibernation_options (fun f ->
               "HibernationOptions", LaunchTemplateHibernationOptionsRequest.to_json f)
         ; Some
             ( "LicenseSpecification"
             , LaunchTemplateLicenseSpecificationListRequest.to_json
                 v.license_specifications )
         ; Aws.Util.option_map v.capacity_reservation_specification (fun f ->
               ( "CapacityReservationSpecification"
               , LaunchTemplateCapacityReservationSpecificationRequest.to_json f ))
         ; Aws.Util.option_map v.cpu_options (fun f ->
               "CpuOptions", LaunchTemplateCpuOptionsRequest.to_json f)
         ; Aws.Util.option_map v.credit_specification (fun f ->
               "CreditSpecification", CreditSpecificationRequest.to_json f)
         ; Aws.Util.option_map v.instance_market_options (fun f ->
               ( "InstanceMarketOptions"
               , LaunchTemplateInstanceMarketOptionsRequest.to_json f ))
         ; Some ("SecurityGroup", SecurityGroupStringList.to_json v.security_groups)
         ; Some ("SecurityGroupId", SecurityGroupIdStringList.to_json v.security_group_ids)
         ; Some
             ( "ElasticInferenceAccelerator"
             , LaunchTemplateElasticInferenceAcceleratorList.to_json
                 v.elastic_inference_accelerators )
         ; Some
             ( "ElasticGpuSpecification"
             , ElasticGpuSpecificationList.to_json v.elastic_gpu_specifications )
         ; Some
             ( "TagSpecification"
             , LaunchTemplateTagSpecificationRequestList.to_json v.tag_specifications )
         ; Aws.Util.option_map v.user_data (fun f -> "UserData", String.to_json f)
         ; Aws.Util.option_map v.instance_initiated_shutdown_behavior (fun f ->
               "InstanceInitiatedShutdownBehavior", ShutdownBehavior.to_json f)
         ; Aws.Util.option_map v.disable_api_termination (fun f ->
               "DisableApiTermination", Boolean.to_json f)
         ; Aws.Util.option_map v.ram_disk_id (fun f -> "RamDiskId", String.to_json f)
         ; Aws.Util.option_map v.placement (fun f ->
               "Placement", LaunchTemplatePlacementRequest.to_json f)
         ; Aws.Util.option_map v.monitoring (fun f ->
               "Monitoring", LaunchTemplatesMonitoringRequest.to_json f)
         ; Aws.Util.option_map v.key_name (fun f -> "KeyName", String.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f ->
               "InstanceType", InstanceType.to_json f)
         ; Aws.Util.option_map v.image_id (fun f -> "ImageId", String.to_json f)
         ; Some
             ( "NetworkInterface"
             , LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList.to_json
                 v.network_interfaces )
         ; Some
             ( "BlockDeviceMapping"
             , LaunchTemplateBlockDeviceMappingRequestList.to_json v.block_device_mappings
             )
         ; Aws.Util.option_map v.iam_instance_profile (fun f ->
               ( "IamInstanceProfile"
               , LaunchTemplateIamInstanceProfileSpecificationRequest.to_json f ))
         ; Aws.Util.option_map v.ebs_optimized (fun f ->
               "EbsOptimized", Boolean.to_json f)
         ; Aws.Util.option_map v.kernel_id (fun f -> "KernelId", String.to_json f)
         ])

  let of_json j =
    { kernel_id = Aws.Util.option_map (Aws.Json.lookup j "KernelId") String.of_json
    ; ebs_optimized =
        Aws.Util.option_map (Aws.Json.lookup j "EbsOptimized") Boolean.of_json
    ; iam_instance_profile =
        Aws.Util.option_map
          (Aws.Json.lookup j "IamInstanceProfile")
          LaunchTemplateIamInstanceProfileSpecificationRequest.of_json
    ; block_device_mappings =
        LaunchTemplateBlockDeviceMappingRequestList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "BlockDeviceMapping"))
    ; network_interfaces =
        LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "NetworkInterface"))
    ; image_id = Aws.Util.option_map (Aws.Json.lookup j "ImageId") String.of_json
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "InstanceType") InstanceType.of_json
    ; key_name = Aws.Util.option_map (Aws.Json.lookup j "KeyName") String.of_json
    ; monitoring =
        Aws.Util.option_map
          (Aws.Json.lookup j "Monitoring")
          LaunchTemplatesMonitoringRequest.of_json
    ; placement =
        Aws.Util.option_map
          (Aws.Json.lookup j "Placement")
          LaunchTemplatePlacementRequest.of_json
    ; ram_disk_id = Aws.Util.option_map (Aws.Json.lookup j "RamDiskId") String.of_json
    ; disable_api_termination =
        Aws.Util.option_map (Aws.Json.lookup j "DisableApiTermination") Boolean.of_json
    ; instance_initiated_shutdown_behavior =
        Aws.Util.option_map
          (Aws.Json.lookup j "InstanceInitiatedShutdownBehavior")
          ShutdownBehavior.of_json
    ; user_data = Aws.Util.option_map (Aws.Json.lookup j "UserData") String.of_json
    ; tag_specifications =
        LaunchTemplateTagSpecificationRequestList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    ; elastic_gpu_specifications =
        ElasticGpuSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ElasticGpuSpecification"))
    ; elastic_inference_accelerators =
        LaunchTemplateElasticInferenceAcceleratorList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ElasticInferenceAccelerator"))
    ; security_group_ids =
        SecurityGroupIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SecurityGroupId"))
    ; security_groups =
        SecurityGroupStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SecurityGroup"))
    ; instance_market_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "InstanceMarketOptions")
          LaunchTemplateInstanceMarketOptionsRequest.of_json
    ; credit_specification =
        Aws.Util.option_map
          (Aws.Json.lookup j "CreditSpecification")
          CreditSpecificationRequest.of_json
    ; cpu_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "CpuOptions")
          LaunchTemplateCpuOptionsRequest.of_json
    ; capacity_reservation_specification =
        Aws.Util.option_map
          (Aws.Json.lookup j "CapacityReservationSpecification")
          LaunchTemplateCapacityReservationSpecificationRequest.of_json
    ; license_specifications =
        LaunchTemplateLicenseSpecificationListRequest.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "LicenseSpecification"))
    ; hibernation_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "HibernationOptions")
          LaunchTemplateHibernationOptionsRequest.of_json
    ; metadata_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "MetadataOptions")
          LaunchTemplateInstanceMetadataOptionsRequest.of_json
    ; enclave_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "EnclaveOptions")
          LaunchTemplateEnclaveOptionsRequest.of_json
    }
end

module CreateLaunchTemplateRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; client_token : String.t option
    ; launch_template_name : String.t
    ; version_description : String.t option
    ; launch_template_data : RequestLaunchTemplateData.t
    ; tag_specifications : TagSpecificationList.t
    }

  let make
      ?dry_run
      ?client_token
      ~launch_template_name
      ?version_description
      ~launch_template_data
      ?(tag_specifications = [])
      () =
    { dry_run
    ; client_token
    ; launch_template_name
    ; version_description
    ; launch_template_data
    ; tag_specifications
    }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; launch_template_name =
          Aws.Xml.required
            "LaunchTemplateName"
            (Aws.Util.option_bind (Aws.Xml.member "LaunchTemplateName" xml) String.parse)
      ; version_description =
          Aws.Util.option_bind (Aws.Xml.member "VersionDescription" xml) String.parse
      ; launch_template_data =
          Aws.Xml.required
            "LaunchTemplateData"
            (Aws.Util.option_bind
               (Aws.Xml.member "LaunchTemplateData" xml)
               RequestLaunchTemplateData.parse)
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Some
             (Aws.Query.Pair
                ( "LaunchTemplateData"
                , RequestLaunchTemplateData.to_query v.launch_template_data ))
         ; Aws.Util.option_map v.version_description (fun f ->
               Aws.Query.Pair ("VersionDescription", String.to_query f))
         ; Some
             (Aws.Query.Pair ("LaunchTemplateName", String.to_query v.launch_template_name))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Some
             ( "LaunchTemplateData"
             , RequestLaunchTemplateData.to_json v.launch_template_data )
         ; Aws.Util.option_map v.version_description (fun f ->
               "VersionDescription", String.to_json f)
         ; Some ("LaunchTemplateName", String.to_json v.launch_template_name)
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; launch_template_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "LaunchTemplateName"))
    ; version_description =
        Aws.Util.option_map (Aws.Json.lookup j "VersionDescription") String.of_json
    ; launch_template_data =
        RequestLaunchTemplateData.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "LaunchTemplateData"))
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    }
end

module KeyPairInfo = struct
  type t =
    { key_pair_id : String.t option
    ; key_fingerprint : String.t option
    ; key_name : String.t option
    ; tags : TagList.t
    }

  let make ?key_pair_id ?key_fingerprint ?key_name ?(tags = []) () =
    { key_pair_id; key_fingerprint; key_name; tags }

  let parse xml =
    Some
      { key_pair_id = Aws.Util.option_bind (Aws.Xml.member "keyPairId" xml) String.parse
      ; key_fingerprint =
          Aws.Util.option_bind (Aws.Xml.member "keyFingerprint" xml) String.parse
      ; key_name = Aws.Util.option_bind (Aws.Xml.member "keyName" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.key_name (fun f ->
               Aws.Query.Pair ("KeyName", String.to_query f))
         ; Aws.Util.option_map v.key_fingerprint (fun f ->
               Aws.Query.Pair ("KeyFingerprint", String.to_query f))
         ; Aws.Util.option_map v.key_pair_id (fun f ->
               Aws.Query.Pair ("KeyPairId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.key_name (fun f -> "keyName", String.to_json f)
         ; Aws.Util.option_map v.key_fingerprint (fun f ->
               "keyFingerprint", String.to_json f)
         ; Aws.Util.option_map v.key_pair_id (fun f -> "keyPairId", String.to_json f)
         ])

  let of_json j =
    { key_pair_id = Aws.Util.option_map (Aws.Json.lookup j "keyPairId") String.of_json
    ; key_fingerprint =
        Aws.Util.option_map (Aws.Json.lookup j "keyFingerprint") String.of_json
    ; key_name = Aws.Util.option_map (Aws.Json.lookup j "keyName") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module NetworkInterfaceIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeNetworkInterfacesRequest = struct
  type t =
    { filters : FilterList.t
    ; dry_run : Boolean.t option
    ; network_interface_ids : NetworkInterfaceIdList.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    }

  let make
      ?(filters = [])
      ?dry_run
      ?(network_interface_ids = [])
      ?next_token
      ?max_results
      () =
    { filters; dry_run; network_interface_ids; next_token; max_results }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "filter" xml) FilterList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; network_interface_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "NetworkInterfaceId" xml)
               NetworkInterfaceIdList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "NetworkInterfaceId"
                , NetworkInterfaceIdList.to_query v.network_interface_ids ))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some
             ("NetworkInterfaceId", NetworkInterfaceIdList.to_json v.network_interface_ids)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "filter"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; network_interface_ids =
        NetworkInterfaceIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "NetworkInterfaceId"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module DescribeInternetGatewaysResult = struct
  type t =
    { internet_gateways : InternetGatewayList.t
    ; next_token : String.t option
    }

  let make ?(internet_gateways = []) ?next_token () = { internet_gateways; next_token }

  let parse xml =
    Some
      { internet_gateways =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "internetGatewaySet" xml)
               InternetGatewayList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("InternetGatewaySet", InternetGatewayList.to_query v.internet_gateways))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("internetGatewaySet", InternetGatewayList.to_json v.internet_gateways)
         ])

  let of_json j =
    { internet_gateways =
        InternetGatewayList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "internetGatewaySet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module TransitGatewayMulticastDeregisteredGroupSources = struct
  type t =
    { transit_gateway_multicast_domain_id : String.t option
    ; deregistered_network_interface_ids : ValueStringList.t
    ; group_ip_address : String.t option
    }

  let make
      ?transit_gateway_multicast_domain_id
      ?(deregistered_network_interface_ids = [])
      ?group_ip_address
      () =
    { transit_gateway_multicast_domain_id
    ; deregistered_network_interface_ids
    ; group_ip_address
    }

  let parse xml =
    Some
      { transit_gateway_multicast_domain_id =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayMulticastDomainId" xml)
            String.parse
      ; deregistered_network_interface_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "deregisteredNetworkInterfaceIds" xml)
               ValueStringList.parse)
      ; group_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "groupIpAddress" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.group_ip_address (fun f ->
               Aws.Query.Pair ("GroupIpAddress", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "DeregisteredNetworkInterfaceIds"
                , ValueStringList.to_query v.deregistered_network_interface_ids ))
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               Aws.Query.Pair ("TransitGatewayMulticastDomainId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.group_ip_address (fun f ->
               "groupIpAddress", String.to_json f)
         ; Some
             ( "deregisteredNetworkInterfaceIds"
             , ValueStringList.to_json v.deregistered_network_interface_ids )
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               "transitGatewayMulticastDomainId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_multicast_domain_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayMulticastDomainId")
          String.of_json
    ; deregistered_network_interface_ids =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "deregisteredNetworkInterfaceIds"))
    ; group_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "groupIpAddress") String.of_json
    }
end

module DeregisterTransitGatewayMulticastGroupSourcesResult = struct
  type t =
    { deregistered_multicast_group_sources :
        TransitGatewayMulticastDeregisteredGroupSources.t option
    }

  let make ?deregistered_multicast_group_sources () =
    { deregistered_multicast_group_sources }

  let parse xml =
    Some
      { deregistered_multicast_group_sources =
          Aws.Util.option_bind
            (Aws.Xml.member "deregisteredMulticastGroupSources" xml)
            TransitGatewayMulticastDeregisteredGroupSources.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.deregistered_multicast_group_sources (fun f ->
               Aws.Query.Pair
                 ( "DeregisteredMulticastGroupSources"
                 , TransitGatewayMulticastDeregisteredGroupSources.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.deregistered_multicast_group_sources (fun f ->
               ( "deregisteredMulticastGroupSources"
               , TransitGatewayMulticastDeregisteredGroupSources.to_json f ))
         ])

  let of_json j =
    { deregistered_multicast_group_sources =
        Aws.Util.option_map
          (Aws.Json.lookup j "deregisteredMulticastGroupSources")
          TransitGatewayMulticastDeregisteredGroupSources.of_json
    }
end

module EnableVgwRoutePropagationRequest = struct
  type t =
    { gateway_id : String.t
    ; route_table_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~gateway_id ~route_table_id ?dry_run () =
    { gateway_id; route_table_id; dry_run }

  let parse xml =
    Some
      { gateway_id =
          Aws.Xml.required
            "GatewayId"
            (Aws.Util.option_bind (Aws.Xml.member "GatewayId" xml) String.parse)
      ; route_table_id =
          Aws.Xml.required
            "RouteTableId"
            (Aws.Util.option_bind (Aws.Xml.member "RouteTableId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("RouteTableId", String.to_query v.route_table_id))
         ; Some (Aws.Query.Pair ("GatewayId", String.to_query v.gateway_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("RouteTableId", String.to_json v.route_table_id)
         ; Some ("GatewayId", String.to_json v.gateway_id)
         ])

  let of_json j =
    { gateway_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "GatewayId"))
    ; route_table_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "RouteTableId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module PlacementGroupState = struct
  type t =
    | Pending
    | Available
    | Deleting
    | Deleted

  let str_to_t =
    [ "deleted", Deleted
    ; "deleting", Deleting
    ; "available", Available
    ; "pending", Pending
    ]

  let t_to_str =
    [ Deleted, "deleted"
    ; Deleting, "deleting"
    ; Available, "available"
    ; Pending, "pending"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DeleteFlowLogsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; flow_log_ids : FlowLogIdList.t
    }

  let make ?dry_run ~flow_log_ids () = { dry_run; flow_log_ids }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; flow_log_ids =
          Aws.Xml.required
            "FlowLogId"
            (Aws.Util.option_bind (Aws.Xml.member "FlowLogId" xml) FlowLogIdList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("FlowLogId", FlowLogIdList.to_query v.flow_log_ids))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("FlowLogId", FlowLogIdList.to_json v.flow_log_ids)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; flow_log_ids =
        FlowLogIdList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "FlowLogId"))
    }
end

module ResetEbsDefaultKmsKeyIdRequest = struct
  type t = { dry_run : Boolean.t option }

  let make ?dry_run () = { dry_run }

  let parse xml =
    Some { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f) ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json }
end

module RejectVpcEndpointConnectionsResult = struct
  type t = { unsuccessful : UnsuccessfulItemSet.t }

  let make ?(unsuccessful = []) () = { unsuccessful }

  let parse xml =
    Some
      { unsuccessful =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "unsuccessful" xml)
               UnsuccessfulItemSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("Unsuccessful", UnsuccessfulItemSet.to_query v.unsuccessful))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("unsuccessful", UnsuccessfulItemSet.to_json v.unsuccessful) ])

  let of_json j =
    { unsuccessful =
        UnsuccessfulItemSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "unsuccessful"))
    }
end

module SpotOptionsRequest = struct
  type t =
    { allocation_strategy : SpotAllocationStrategy.t option
    ; maintenance_strategies : FleetSpotMaintenanceStrategiesRequest.t option
    ; instance_interruption_behavior : SpotInstanceInterruptionBehavior.t option
    ; instance_pools_to_use_count : Integer.t option
    ; single_instance_type : Boolean.t option
    ; single_availability_zone : Boolean.t option
    ; min_target_capacity : Integer.t option
    ; max_total_price : String.t option
    }

  let make
      ?allocation_strategy
      ?maintenance_strategies
      ?instance_interruption_behavior
      ?instance_pools_to_use_count
      ?single_instance_type
      ?single_availability_zone
      ?min_target_capacity
      ?max_total_price
      () =
    { allocation_strategy
    ; maintenance_strategies
    ; instance_interruption_behavior
    ; instance_pools_to_use_count
    ; single_instance_type
    ; single_availability_zone
    ; min_target_capacity
    ; max_total_price
    }

  let parse xml =
    Some
      { allocation_strategy =
          Aws.Util.option_bind
            (Aws.Xml.member "AllocationStrategy" xml)
            SpotAllocationStrategy.parse
      ; maintenance_strategies =
          Aws.Util.option_bind
            (Aws.Xml.member "MaintenanceStrategies" xml)
            FleetSpotMaintenanceStrategiesRequest.parse
      ; instance_interruption_behavior =
          Aws.Util.option_bind
            (Aws.Xml.member "InstanceInterruptionBehavior" xml)
            SpotInstanceInterruptionBehavior.parse
      ; instance_pools_to_use_count =
          Aws.Util.option_bind
            (Aws.Xml.member "InstancePoolsToUseCount" xml)
            Integer.parse
      ; single_instance_type =
          Aws.Util.option_bind (Aws.Xml.member "SingleInstanceType" xml) Boolean.parse
      ; single_availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "SingleAvailabilityZone" xml) Boolean.parse
      ; min_target_capacity =
          Aws.Util.option_bind (Aws.Xml.member "MinTargetCapacity" xml) Integer.parse
      ; max_total_price =
          Aws.Util.option_bind (Aws.Xml.member "MaxTotalPrice" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_total_price (fun f ->
               Aws.Query.Pair ("MaxTotalPrice", String.to_query f))
         ; Aws.Util.option_map v.min_target_capacity (fun f ->
               Aws.Query.Pair ("MinTargetCapacity", Integer.to_query f))
         ; Aws.Util.option_map v.single_availability_zone (fun f ->
               Aws.Query.Pair ("SingleAvailabilityZone", Boolean.to_query f))
         ; Aws.Util.option_map v.single_instance_type (fun f ->
               Aws.Query.Pair ("SingleInstanceType", Boolean.to_query f))
         ; Aws.Util.option_map v.instance_pools_to_use_count (fun f ->
               Aws.Query.Pair ("InstancePoolsToUseCount", Integer.to_query f))
         ; Aws.Util.option_map v.instance_interruption_behavior (fun f ->
               Aws.Query.Pair
                 ( "InstanceInterruptionBehavior"
                 , SpotInstanceInterruptionBehavior.to_query f ))
         ; Aws.Util.option_map v.maintenance_strategies (fun f ->
               Aws.Query.Pair
                 ( "MaintenanceStrategies"
                 , FleetSpotMaintenanceStrategiesRequest.to_query f ))
         ; Aws.Util.option_map v.allocation_strategy (fun f ->
               Aws.Query.Pair ("AllocationStrategy", SpotAllocationStrategy.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_total_price (fun f ->
               "MaxTotalPrice", String.to_json f)
         ; Aws.Util.option_map v.min_target_capacity (fun f ->
               "MinTargetCapacity", Integer.to_json f)
         ; Aws.Util.option_map v.single_availability_zone (fun f ->
               "SingleAvailabilityZone", Boolean.to_json f)
         ; Aws.Util.option_map v.single_instance_type (fun f ->
               "SingleInstanceType", Boolean.to_json f)
         ; Aws.Util.option_map v.instance_pools_to_use_count (fun f ->
               "InstancePoolsToUseCount", Integer.to_json f)
         ; Aws.Util.option_map v.instance_interruption_behavior (fun f ->
               "InstanceInterruptionBehavior", SpotInstanceInterruptionBehavior.to_json f)
         ; Aws.Util.option_map v.maintenance_strategies (fun f ->
               "MaintenanceStrategies", FleetSpotMaintenanceStrategiesRequest.to_json f)
         ; Aws.Util.option_map v.allocation_strategy (fun f ->
               "AllocationStrategy", SpotAllocationStrategy.to_json f)
         ])

  let of_json j =
    { allocation_strategy =
        Aws.Util.option_map
          (Aws.Json.lookup j "AllocationStrategy")
          SpotAllocationStrategy.of_json
    ; maintenance_strategies =
        Aws.Util.option_map
          (Aws.Json.lookup j "MaintenanceStrategies")
          FleetSpotMaintenanceStrategiesRequest.of_json
    ; instance_interruption_behavior =
        Aws.Util.option_map
          (Aws.Json.lookup j "InstanceInterruptionBehavior")
          SpotInstanceInterruptionBehavior.of_json
    ; instance_pools_to_use_count =
        Aws.Util.option_map (Aws.Json.lookup j "InstancePoolsToUseCount") Integer.of_json
    ; single_instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "SingleInstanceType") Boolean.of_json
    ; single_availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "SingleAvailabilityZone") Boolean.of_json
    ; min_target_capacity =
        Aws.Util.option_map (Aws.Json.lookup j "MinTargetCapacity") Integer.of_json
    ; max_total_price =
        Aws.Util.option_map (Aws.Json.lookup j "MaxTotalPrice") String.of_json
    }
end

module CapacityReservationOptionsRequest = struct
  type t = { usage_strategy : FleetCapacityReservationUsageStrategy.t option }

  let make ?usage_strategy () = { usage_strategy }

  let parse xml =
    Some
      { usage_strategy =
          Aws.Util.option_bind
            (Aws.Xml.member "UsageStrategy" xml)
            FleetCapacityReservationUsageStrategy.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.usage_strategy (fun f ->
               Aws.Query.Pair
                 ("UsageStrategy", FleetCapacityReservationUsageStrategy.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.usage_strategy (fun f ->
               "UsageStrategy", FleetCapacityReservationUsageStrategy.to_json f)
         ])

  let of_json j =
    { usage_strategy =
        Aws.Util.option_map
          (Aws.Json.lookup j "UsageStrategy")
          FleetCapacityReservationUsageStrategy.of_json
    }
end

module OnDemandOptionsRequest = struct
  type t =
    { allocation_strategy : FleetOnDemandAllocationStrategy.t option
    ; capacity_reservation_options : CapacityReservationOptionsRequest.t option
    ; single_instance_type : Boolean.t option
    ; single_availability_zone : Boolean.t option
    ; min_target_capacity : Integer.t option
    ; max_total_price : String.t option
    }

  let make
      ?allocation_strategy
      ?capacity_reservation_options
      ?single_instance_type
      ?single_availability_zone
      ?min_target_capacity
      ?max_total_price
      () =
    { allocation_strategy
    ; capacity_reservation_options
    ; single_instance_type
    ; single_availability_zone
    ; min_target_capacity
    ; max_total_price
    }

  let parse xml =
    Some
      { allocation_strategy =
          Aws.Util.option_bind
            (Aws.Xml.member "AllocationStrategy" xml)
            FleetOnDemandAllocationStrategy.parse
      ; capacity_reservation_options =
          Aws.Util.option_bind
            (Aws.Xml.member "CapacityReservationOptions" xml)
            CapacityReservationOptionsRequest.parse
      ; single_instance_type =
          Aws.Util.option_bind (Aws.Xml.member "SingleInstanceType" xml) Boolean.parse
      ; single_availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "SingleAvailabilityZone" xml) Boolean.parse
      ; min_target_capacity =
          Aws.Util.option_bind (Aws.Xml.member "MinTargetCapacity" xml) Integer.parse
      ; max_total_price =
          Aws.Util.option_bind (Aws.Xml.member "MaxTotalPrice" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_total_price (fun f ->
               Aws.Query.Pair ("MaxTotalPrice", String.to_query f))
         ; Aws.Util.option_map v.min_target_capacity (fun f ->
               Aws.Query.Pair ("MinTargetCapacity", Integer.to_query f))
         ; Aws.Util.option_map v.single_availability_zone (fun f ->
               Aws.Query.Pair ("SingleAvailabilityZone", Boolean.to_query f))
         ; Aws.Util.option_map v.single_instance_type (fun f ->
               Aws.Query.Pair ("SingleInstanceType", Boolean.to_query f))
         ; Aws.Util.option_map v.capacity_reservation_options (fun f ->
               Aws.Query.Pair
                 ( "CapacityReservationOptions"
                 , CapacityReservationOptionsRequest.to_query f ))
         ; Aws.Util.option_map v.allocation_strategy (fun f ->
               Aws.Query.Pair
                 ("AllocationStrategy", FleetOnDemandAllocationStrategy.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_total_price (fun f ->
               "MaxTotalPrice", String.to_json f)
         ; Aws.Util.option_map v.min_target_capacity (fun f ->
               "MinTargetCapacity", Integer.to_json f)
         ; Aws.Util.option_map v.single_availability_zone (fun f ->
               "SingleAvailabilityZone", Boolean.to_json f)
         ; Aws.Util.option_map v.single_instance_type (fun f ->
               "SingleInstanceType", Boolean.to_json f)
         ; Aws.Util.option_map v.capacity_reservation_options (fun f ->
               "CapacityReservationOptions", CapacityReservationOptionsRequest.to_json f)
         ; Aws.Util.option_map v.allocation_strategy (fun f ->
               "AllocationStrategy", FleetOnDemandAllocationStrategy.to_json f)
         ])

  let of_json j =
    { allocation_strategy =
        Aws.Util.option_map
          (Aws.Json.lookup j "AllocationStrategy")
          FleetOnDemandAllocationStrategy.of_json
    ; capacity_reservation_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "CapacityReservationOptions")
          CapacityReservationOptionsRequest.of_json
    ; single_instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "SingleInstanceType") Boolean.of_json
    ; single_availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "SingleAvailabilityZone") Boolean.of_json
    ; min_target_capacity =
        Aws.Util.option_map (Aws.Json.lookup j "MinTargetCapacity") Integer.of_json
    ; max_total_price =
        Aws.Util.option_map (Aws.Json.lookup j "MaxTotalPrice") String.of_json
    }
end

module CreateFleetRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; client_token : String.t option
    ; spot_options : SpotOptionsRequest.t option
    ; on_demand_options : OnDemandOptionsRequest.t option
    ; excess_capacity_termination_policy : FleetExcessCapacityTerminationPolicy.t option
    ; launch_template_configs : FleetLaunchTemplateConfigListRequest.t
    ; target_capacity_specification : TargetCapacitySpecificationRequest.t
    ; terminate_instances_with_expiration : Boolean.t option
    ; type_ : FleetType.t option
    ; valid_from : DateTime.t option
    ; valid_until : DateTime.t option
    ; replace_unhealthy_instances : Boolean.t option
    ; tag_specifications : TagSpecificationList.t
    }

  let make
      ?dry_run
      ?client_token
      ?spot_options
      ?on_demand_options
      ?excess_capacity_termination_policy
      ~launch_template_configs
      ~target_capacity_specification
      ?terminate_instances_with_expiration
      ?type_
      ?valid_from
      ?valid_until
      ?replace_unhealthy_instances
      ?(tag_specifications = [])
      () =
    { dry_run
    ; client_token
    ; spot_options
    ; on_demand_options
    ; excess_capacity_termination_policy
    ; launch_template_configs
    ; target_capacity_specification
    ; terminate_instances_with_expiration
    ; type_
    ; valid_from
    ; valid_until
    ; replace_unhealthy_instances
    ; tag_specifications
    }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; spot_options =
          Aws.Util.option_bind (Aws.Xml.member "SpotOptions" xml) SpotOptionsRequest.parse
      ; on_demand_options =
          Aws.Util.option_bind
            (Aws.Xml.member "OnDemandOptions" xml)
            OnDemandOptionsRequest.parse
      ; excess_capacity_termination_policy =
          Aws.Util.option_bind
            (Aws.Xml.member "ExcessCapacityTerminationPolicy" xml)
            FleetExcessCapacityTerminationPolicy.parse
      ; launch_template_configs =
          Aws.Xml.required
            "LaunchTemplateConfigs"
            (Aws.Util.option_bind
               (Aws.Xml.member "LaunchTemplateConfigs" xml)
               FleetLaunchTemplateConfigListRequest.parse)
      ; target_capacity_specification =
          Aws.Xml.required
            "TargetCapacitySpecification"
            (Aws.Util.option_bind
               (Aws.Xml.member "TargetCapacitySpecification" xml)
               TargetCapacitySpecificationRequest.parse)
      ; terminate_instances_with_expiration =
          Aws.Util.option_bind
            (Aws.Xml.member "TerminateInstancesWithExpiration" xml)
            Boolean.parse
      ; type_ = Aws.Util.option_bind (Aws.Xml.member "Type" xml) FleetType.parse
      ; valid_from = Aws.Util.option_bind (Aws.Xml.member "ValidFrom" xml) DateTime.parse
      ; valid_until =
          Aws.Util.option_bind (Aws.Xml.member "ValidUntil" xml) DateTime.parse
      ; replace_unhealthy_instances =
          Aws.Util.option_bind
            (Aws.Xml.member "ReplaceUnhealthyInstances" xml)
            Boolean.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Aws.Util.option_map v.replace_unhealthy_instances (fun f ->
               Aws.Query.Pair ("ReplaceUnhealthyInstances", Boolean.to_query f))
         ; Aws.Util.option_map v.valid_until (fun f ->
               Aws.Query.Pair ("ValidUntil", DateTime.to_query f))
         ; Aws.Util.option_map v.valid_from (fun f ->
               Aws.Query.Pair ("ValidFrom", DateTime.to_query f))
         ; Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", FleetType.to_query f))
         ; Aws.Util.option_map v.terminate_instances_with_expiration (fun f ->
               Aws.Query.Pair ("TerminateInstancesWithExpiration", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TargetCapacitySpecification"
                , TargetCapacitySpecificationRequest.to_query
                    v.target_capacity_specification ))
         ; Some
             (Aws.Query.Pair
                ( "LaunchTemplateConfigs"
                , FleetLaunchTemplateConfigListRequest.to_query v.launch_template_configs
                ))
         ; Aws.Util.option_map v.excess_capacity_termination_policy (fun f ->
               Aws.Query.Pair
                 ( "ExcessCapacityTerminationPolicy"
                 , FleetExcessCapacityTerminationPolicy.to_query f ))
         ; Aws.Util.option_map v.on_demand_options (fun f ->
               Aws.Query.Pair ("OnDemandOptions", OnDemandOptionsRequest.to_query f))
         ; Aws.Util.option_map v.spot_options (fun f ->
               Aws.Query.Pair ("SpotOptions", SpotOptionsRequest.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Aws.Util.option_map v.replace_unhealthy_instances (fun f ->
               "ReplaceUnhealthyInstances", Boolean.to_json f)
         ; Aws.Util.option_map v.valid_until (fun f -> "ValidUntil", DateTime.to_json f)
         ; Aws.Util.option_map v.valid_from (fun f -> "ValidFrom", DateTime.to_json f)
         ; Aws.Util.option_map v.type_ (fun f -> "Type", FleetType.to_json f)
         ; Aws.Util.option_map v.terminate_instances_with_expiration (fun f ->
               "TerminateInstancesWithExpiration", Boolean.to_json f)
         ; Some
             ( "TargetCapacitySpecification"
             , TargetCapacitySpecificationRequest.to_json v.target_capacity_specification
             )
         ; Some
             ( "LaunchTemplateConfigs"
             , FleetLaunchTemplateConfigListRequest.to_json v.launch_template_configs )
         ; Aws.Util.option_map v.excess_capacity_termination_policy (fun f ->
               ( "ExcessCapacityTerminationPolicy"
               , FleetExcessCapacityTerminationPolicy.to_json f ))
         ; Aws.Util.option_map v.on_demand_options (fun f ->
               "OnDemandOptions", OnDemandOptionsRequest.to_json f)
         ; Aws.Util.option_map v.spot_options (fun f ->
               "SpotOptions", SpotOptionsRequest.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; spot_options =
        Aws.Util.option_map (Aws.Json.lookup j "SpotOptions") SpotOptionsRequest.of_json
    ; on_demand_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "OnDemandOptions")
          OnDemandOptionsRequest.of_json
    ; excess_capacity_termination_policy =
        Aws.Util.option_map
          (Aws.Json.lookup j "ExcessCapacityTerminationPolicy")
          FleetExcessCapacityTerminationPolicy.of_json
    ; launch_template_configs =
        FleetLaunchTemplateConfigListRequest.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "LaunchTemplateConfigs"))
    ; target_capacity_specification =
        TargetCapacitySpecificationRequest.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TargetCapacitySpecification"))
    ; terminate_instances_with_expiration =
        Aws.Util.option_map
          (Aws.Json.lookup j "TerminateInstancesWithExpiration")
          Boolean.of_json
    ; type_ = Aws.Util.option_map (Aws.Json.lookup j "Type") FleetType.of_json
    ; valid_from = Aws.Util.option_map (Aws.Json.lookup j "ValidFrom") DateTime.of_json
    ; valid_until = Aws.Util.option_map (Aws.Json.lookup j "ValidUntil") DateTime.of_json
    ; replace_unhealthy_instances =
        Aws.Util.option_map
          (Aws.Json.lookup j "ReplaceUnhealthyInstances")
          Boolean.of_json
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    }
end

module TransitGatewayAttachmentIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeTransitGatewayAttachmentsRequest = struct
  type t =
    { transit_gateway_attachment_ids : TransitGatewayAttachmentIdStringList.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make
      ?(transit_gateway_attachment_ids = [])
      ?(filters = [])
      ?max_results
      ?next_token
      ?dry_run
      () =
    { transit_gateway_attachment_ids; filters; max_results; next_token; dry_run }

  let parse xml =
    Some
      { transit_gateway_attachment_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayAttachmentIds" xml)
               TransitGatewayAttachmentIdStringList.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayAttachmentIds"
                , TransitGatewayAttachmentIdStringList.to_query
                    v.transit_gateway_attachment_ids ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some
             ( "TransitGatewayAttachmentIds"
             , TransitGatewayAttachmentIdStringList.to_json
                 v.transit_gateway_attachment_ids )
         ])

  let of_json j =
    { transit_gateway_attachment_ids =
        TransitGatewayAttachmentIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayAttachmentIds"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DeleteFleetSuccessSet = struct
  type t = DeleteFleetSuccessItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map DeleteFleetSuccessItem.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list DeleteFleetSuccessItem.to_query v

  let to_json v = `List (List.map DeleteFleetSuccessItem.to_json v)

  let of_json j = Aws.Json.to_list DeleteFleetSuccessItem.of_json j
end

module CreateSpotDatafeedSubscriptionRequest = struct
  type t =
    { bucket : String.t
    ; dry_run : Boolean.t option
    ; prefix : String.t option
    }

  let make ~bucket ?dry_run ?prefix () = { bucket; dry_run; prefix }

  let parse xml =
    Some
      { bucket =
          Aws.Xml.required
            "bucket"
            (Aws.Util.option_bind (Aws.Xml.member "bucket" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; prefix = Aws.Util.option_bind (Aws.Xml.member "prefix" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.prefix (fun f ->
               Aws.Query.Pair ("Prefix", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Bucket", String.to_query v.bucket))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.prefix (fun f -> "prefix", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("bucket", String.to_json v.bucket)
         ])

  let of_json j =
    { bucket = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "bucket"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; prefix = Aws.Util.option_map (Aws.Json.lookup j "prefix") String.of_json
    }
end

module ByoipCidrSet = struct
  type t = ByoipCidr.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ByoipCidr.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ByoipCidr.to_query v

  let to_json v = `List (List.map ByoipCidr.to_json v)

  let of_json j = Aws.Json.to_list ByoipCidr.of_json j
end

module TransitGatewayMulticastDomainList = struct
  type t = TransitGatewayMulticastDomain.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map TransitGatewayMulticastDomain.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list TransitGatewayMulticastDomain.to_query v

  let to_json v = `List (List.map TransitGatewayMulticastDomain.to_json v)

  let of_json j = Aws.Json.to_list TransitGatewayMulticastDomain.of_json j
end

module FlowLogSet = struct
  type t = FlowLog.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map FlowLog.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list FlowLog.to_query v

  let to_json v = `List (List.map FlowLog.to_json v)

  let of_json j = Aws.Json.to_list FlowLog.of_json j
end

module DeleteVpnConnectionRouteRequest = struct
  type t =
    { destination_cidr_block : String.t
    ; vpn_connection_id : String.t
    }

  let make ~destination_cidr_block ~vpn_connection_id () =
    { destination_cidr_block; vpn_connection_id }

  let parse xml =
    Some
      { destination_cidr_block =
          Aws.Xml.required
            "DestinationCidrBlock"
            (Aws.Util.option_bind
               (Aws.Xml.member "DestinationCidrBlock" xml)
               String.parse)
      ; vpn_connection_id =
          Aws.Xml.required
            "VpnConnectionId"
            (Aws.Util.option_bind (Aws.Xml.member "VpnConnectionId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("VpnConnectionId", String.to_query v.vpn_connection_id))
         ; Some
             (Aws.Query.Pair
                ("DestinationCidrBlock", String.to_query v.destination_cidr_block))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("VpnConnectionId", String.to_json v.vpn_connection_id)
         ; Some ("DestinationCidrBlock", String.to_json v.destination_cidr_block)
         ])

  let of_json j =
    { destination_cidr_block =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DestinationCidrBlock"))
    ; vpn_connection_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpnConnectionId"))
    }
end

module ModifyInstanceCapacityReservationAttributesResult = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module ClientVpnEndpointStatus = struct
  type t =
    { code : ClientVpnEndpointStatusCode.t option
    ; message : String.t option
    }

  let make ?code ?message () = { code; message }

  let parse xml =
    Some
      { code =
          Aws.Util.option_bind
            (Aws.Xml.member "code" xml)
            ClientVpnEndpointStatusCode.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair ("Code", ClientVpnEndpointStatusCode.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f)
         ; Aws.Util.option_map v.code (fun f ->
               "code", ClientVpnEndpointStatusCode.to_json f)
         ])

  let of_json j =
    { code =
        Aws.Util.option_map (Aws.Json.lookup j "code") ClientVpnEndpointStatusCode.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json
    }
end

module BundleIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "BundleId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module VpnProtocol = struct
  type t = Openvpn

  let str_to_t = [ "openvpn", Openvpn ]

  let t_to_str = [ Openvpn, "openvpn" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module TransportProtocol = struct
  type t =
    | Tcp
    | Udp

  let str_to_t = [ "udp", Udp; "tcp", Tcp ]

  let t_to_str = [ Udp, "udp"; Tcp, "tcp" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module AssociatedTargetNetworkSet = struct
  type t = AssociatedTargetNetwork.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map AssociatedTargetNetwork.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list AssociatedTargetNetwork.to_query v

  let to_json v = `List (List.map AssociatedTargetNetwork.to_json v)

  let of_json j = Aws.Json.to_list AssociatedTargetNetwork.of_json j
end

module ClientVpnEndpoint = struct
  type t =
    { client_vpn_endpoint_id : String.t option
    ; description : String.t option
    ; status : ClientVpnEndpointStatus.t option
    ; creation_time : String.t option
    ; deletion_time : String.t option
    ; dns_name : String.t option
    ; client_cidr_block : String.t option
    ; dns_servers : ValueStringList.t
    ; split_tunnel : Boolean.t option
    ; vpn_protocol : VpnProtocol.t option
    ; transport_protocol : TransportProtocol.t option
    ; vpn_port : Integer.t option
    ; associated_target_networks : AssociatedTargetNetworkSet.t
    ; server_certificate_arn : String.t option
    ; authentication_options : ClientVpnAuthenticationList.t
    ; connection_log_options : ConnectionLogResponseOptions.t option
    ; tags : TagList.t
    ; security_group_ids : ClientVpnSecurityGroupIdSet.t
    ; vpc_id : String.t option
    ; self_service_portal_url : String.t option
    ; client_connect_options : ClientConnectResponseOptions.t option
    }

  let make
      ?client_vpn_endpoint_id
      ?description
      ?status
      ?creation_time
      ?deletion_time
      ?dns_name
      ?client_cidr_block
      ?(dns_servers = [])
      ?split_tunnel
      ?vpn_protocol
      ?transport_protocol
      ?vpn_port
      ?(associated_target_networks = [])
      ?server_certificate_arn
      ?(authentication_options = [])
      ?connection_log_options
      ?(tags = [])
      ?(security_group_ids = [])
      ?vpc_id
      ?self_service_portal_url
      ?client_connect_options
      () =
    { client_vpn_endpoint_id
    ; description
    ; status
    ; creation_time
    ; deletion_time
    ; dns_name
    ; client_cidr_block
    ; dns_servers
    ; split_tunnel
    ; vpn_protocol
    ; transport_protocol
    ; vpn_port
    ; associated_target_networks
    ; server_certificate_arn
    ; authentication_options
    ; connection_log_options
    ; tags
    ; security_group_ids
    ; vpc_id
    ; self_service_portal_url
    ; client_connect_options
    }

  let parse xml =
    Some
      { client_vpn_endpoint_id =
          Aws.Util.option_bind (Aws.Xml.member "clientVpnEndpointId" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; status =
          Aws.Util.option_bind (Aws.Xml.member "status" xml) ClientVpnEndpointStatus.parse
      ; creation_time =
          Aws.Util.option_bind (Aws.Xml.member "creationTime" xml) String.parse
      ; deletion_time =
          Aws.Util.option_bind (Aws.Xml.member "deletionTime" xml) String.parse
      ; dns_name = Aws.Util.option_bind (Aws.Xml.member "dnsName" xml) String.parse
      ; client_cidr_block =
          Aws.Util.option_bind (Aws.Xml.member "clientCidrBlock" xml) String.parse
      ; dns_servers =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "dnsServer" xml) ValueStringList.parse)
      ; split_tunnel =
          Aws.Util.option_bind (Aws.Xml.member "splitTunnel" xml) Boolean.parse
      ; vpn_protocol =
          Aws.Util.option_bind (Aws.Xml.member "vpnProtocol" xml) VpnProtocol.parse
      ; transport_protocol =
          Aws.Util.option_bind
            (Aws.Xml.member "transportProtocol" xml)
            TransportProtocol.parse
      ; vpn_port = Aws.Util.option_bind (Aws.Xml.member "vpnPort" xml) Integer.parse
      ; associated_target_networks =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "associatedTargetNetwork" xml)
               AssociatedTargetNetworkSet.parse)
      ; server_certificate_arn =
          Aws.Util.option_bind (Aws.Xml.member "serverCertificateArn" xml) String.parse
      ; authentication_options =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "authenticationOptions" xml)
               ClientVpnAuthenticationList.parse)
      ; connection_log_options =
          Aws.Util.option_bind
            (Aws.Xml.member "connectionLogOptions" xml)
            ConnectionLogResponseOptions.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      ; security_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "securityGroupIdSet" xml)
               ClientVpnSecurityGroupIdSet.parse)
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse
      ; self_service_portal_url =
          Aws.Util.option_bind (Aws.Xml.member "selfServicePortalUrl" xml) String.parse
      ; client_connect_options =
          Aws.Util.option_bind
            (Aws.Xml.member "clientConnectOptions" xml)
            ClientConnectResponseOptions.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_connect_options (fun f ->
               Aws.Query.Pair
                 ("ClientConnectOptions", ClientConnectResponseOptions.to_query f))
         ; Aws.Util.option_map v.self_service_portal_url (fun f ->
               Aws.Query.Pair ("SelfServicePortalUrl", String.to_query f))
         ; Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "SecurityGroupIdSet"
                , ClientVpnSecurityGroupIdSet.to_query v.security_group_ids ))
         ; Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.connection_log_options (fun f ->
               Aws.Query.Pair
                 ("ConnectionLogOptions", ConnectionLogResponseOptions.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "AuthenticationOptions"
                , ClientVpnAuthenticationList.to_query v.authentication_options ))
         ; Aws.Util.option_map v.server_certificate_arn (fun f ->
               Aws.Query.Pair ("ServerCertificateArn", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "AssociatedTargetNetwork"
                , AssociatedTargetNetworkSet.to_query v.associated_target_networks ))
         ; Aws.Util.option_map v.vpn_port (fun f ->
               Aws.Query.Pair ("VpnPort", Integer.to_query f))
         ; Aws.Util.option_map v.transport_protocol (fun f ->
               Aws.Query.Pair ("TransportProtocol", TransportProtocol.to_query f))
         ; Aws.Util.option_map v.vpn_protocol (fun f ->
               Aws.Query.Pair ("VpnProtocol", VpnProtocol.to_query f))
         ; Aws.Util.option_map v.split_tunnel (fun f ->
               Aws.Query.Pair ("SplitTunnel", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("DnsServer", ValueStringList.to_query v.dns_servers))
         ; Aws.Util.option_map v.client_cidr_block (fun f ->
               Aws.Query.Pair ("ClientCidrBlock", String.to_query f))
         ; Aws.Util.option_map v.dns_name (fun f ->
               Aws.Query.Pair ("DnsName", String.to_query f))
         ; Aws.Util.option_map v.deletion_time (fun f ->
               Aws.Query.Pair ("DeletionTime", String.to_query f))
         ; Aws.Util.option_map v.creation_time (fun f ->
               Aws.Query.Pair ("CreationTime", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", ClientVpnEndpointStatus.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.client_vpn_endpoint_id (fun f ->
               Aws.Query.Pair ("ClientVpnEndpointId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_connect_options (fun f ->
               "clientConnectOptions", ClientConnectResponseOptions.to_json f)
         ; Aws.Util.option_map v.self_service_portal_url (fun f ->
               "selfServicePortalUrl", String.to_json f)
         ; Aws.Util.option_map v.vpc_id (fun f -> "vpcId", String.to_json f)
         ; Some
             ( "securityGroupIdSet"
             , ClientVpnSecurityGroupIdSet.to_json v.security_group_ids )
         ; Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.connection_log_options (fun f ->
               "connectionLogOptions", ConnectionLogResponseOptions.to_json f)
         ; Some
             ( "authenticationOptions"
             , ClientVpnAuthenticationList.to_json v.authentication_options )
         ; Aws.Util.option_map v.server_certificate_arn (fun f ->
               "serverCertificateArn", String.to_json f)
         ; Some
             ( "associatedTargetNetwork"
             , AssociatedTargetNetworkSet.to_json v.associated_target_networks )
         ; Aws.Util.option_map v.vpn_port (fun f -> "vpnPort", Integer.to_json f)
         ; Aws.Util.option_map v.transport_protocol (fun f ->
               "transportProtocol", TransportProtocol.to_json f)
         ; Aws.Util.option_map v.vpn_protocol (fun f ->
               "vpnProtocol", VpnProtocol.to_json f)
         ; Aws.Util.option_map v.split_tunnel (fun f -> "splitTunnel", Boolean.to_json f)
         ; Some ("dnsServer", ValueStringList.to_json v.dns_servers)
         ; Aws.Util.option_map v.client_cidr_block (fun f ->
               "clientCidrBlock", String.to_json f)
         ; Aws.Util.option_map v.dns_name (fun f -> "dnsName", String.to_json f)
         ; Aws.Util.option_map v.deletion_time (fun f -> "deletionTime", String.to_json f)
         ; Aws.Util.option_map v.creation_time (fun f -> "creationTime", String.to_json f)
         ; Aws.Util.option_map v.status (fun f ->
               "status", ClientVpnEndpointStatus.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Aws.Util.option_map v.client_vpn_endpoint_id (fun f ->
               "clientVpnEndpointId", String.to_json f)
         ])

  let of_json j =
    { client_vpn_endpoint_id =
        Aws.Util.option_map (Aws.Json.lookup j "clientVpnEndpointId") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; status =
        Aws.Util.option_map (Aws.Json.lookup j "status") ClientVpnEndpointStatus.of_json
    ; creation_time =
        Aws.Util.option_map (Aws.Json.lookup j "creationTime") String.of_json
    ; deletion_time =
        Aws.Util.option_map (Aws.Json.lookup j "deletionTime") String.of_json
    ; dns_name = Aws.Util.option_map (Aws.Json.lookup j "dnsName") String.of_json
    ; client_cidr_block =
        Aws.Util.option_map (Aws.Json.lookup j "clientCidrBlock") String.of_json
    ; dns_servers =
        ValueStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "dnsServer"))
    ; split_tunnel = Aws.Util.option_map (Aws.Json.lookup j "splitTunnel") Boolean.of_json
    ; vpn_protocol =
        Aws.Util.option_map (Aws.Json.lookup j "vpnProtocol") VpnProtocol.of_json
    ; transport_protocol =
        Aws.Util.option_map
          (Aws.Json.lookup j "transportProtocol")
          TransportProtocol.of_json
    ; vpn_port = Aws.Util.option_map (Aws.Json.lookup j "vpnPort") Integer.of_json
    ; associated_target_networks =
        AssociatedTargetNetworkSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "associatedTargetNetwork"))
    ; server_certificate_arn =
        Aws.Util.option_map (Aws.Json.lookup j "serverCertificateArn") String.of_json
    ; authentication_options =
        ClientVpnAuthenticationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "authenticationOptions"))
    ; connection_log_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "connectionLogOptions")
          ConnectionLogResponseOptions.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    ; security_group_ids =
        ClientVpnSecurityGroupIdSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "securityGroupIdSet"))
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "vpcId") String.of_json
    ; self_service_portal_url =
        Aws.Util.option_map (Aws.Json.lookup j "selfServicePortalUrl") String.of_json
    ; client_connect_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "clientConnectOptions")
          ClientConnectResponseOptions.of_json
    }
end

module EndpointSet = struct
  type t = ClientVpnEndpoint.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ClientVpnEndpoint.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ClientVpnEndpoint.to_query v

  let to_json v = `List (List.map ClientVpnEndpoint.to_json v)

  let of_json j = Aws.Json.to_list ClientVpnEndpoint.of_json j
end

module DescribeClientVpnEndpointsResult = struct
  type t =
    { client_vpn_endpoints : EndpointSet.t
    ; next_token : String.t option
    }

  let make ?(client_vpn_endpoints = []) ?next_token () =
    { client_vpn_endpoints; next_token }

  let parse xml =
    Some
      { client_vpn_endpoints =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "clientVpnEndpoint" xml)
               EndpointSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ClientVpnEndpoint", EndpointSet.to_query v.client_vpn_endpoints))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("clientVpnEndpoint", EndpointSet.to_json v.client_vpn_endpoints)
         ])

  let of_json j =
    { client_vpn_endpoints =
        EndpointSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "clientVpnEndpoint"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module BundleTaskList = struct
  type t = BundleTask.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map BundleTask.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list BundleTask.to_query v

  let to_json v = `List (List.map BundleTask.to_json v)

  let of_json j = Aws.Json.to_list BundleTask.of_json j
end

module GetConsoleOutputResult = struct
  type t =
    { instance_id : String.t option
    ; output : String.t option
    ; timestamp : DateTime.t option
    }

  let make ?instance_id ?output ?timestamp () = { instance_id; output; timestamp }

  let parse xml =
    Some
      { instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      ; output = Aws.Util.option_bind (Aws.Xml.member "output" xml) String.parse
      ; timestamp = Aws.Util.option_bind (Aws.Xml.member "timestamp" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timestamp (fun f ->
               Aws.Query.Pair ("Timestamp", DateTime.to_query f))
         ; Aws.Util.option_map v.output (fun f ->
               Aws.Query.Pair ("Output", String.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timestamp (fun f -> "timestamp", DateTime.to_json f)
         ; Aws.Util.option_map v.output (fun f -> "output", String.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ])

  let of_json j =
    { instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    ; output = Aws.Util.option_map (Aws.Json.lookup j "output") String.of_json
    ; timestamp = Aws.Util.option_map (Aws.Json.lookup j "timestamp") DateTime.of_json
    }
end

module CancelCapacityReservationRequest = struct
  type t =
    { capacity_reservation_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~capacity_reservation_id ?dry_run () = { capacity_reservation_id; dry_run }

  let parse xml =
    Some
      { capacity_reservation_id =
          Aws.Xml.required
            "CapacityReservationId"
            (Aws.Util.option_bind
               (Aws.Xml.member "CapacityReservationId" xml)
               String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("CapacityReservationId", String.to_query v.capacity_reservation_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("CapacityReservationId", String.to_json v.capacity_reservation_id)
         ])

  let of_json j =
    { capacity_reservation_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "CapacityReservationId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DeleteTransitGatewayVpcAttachmentResult = struct
  type t = { transit_gateway_vpc_attachment : TransitGatewayVpcAttachment.t option }

  let make ?transit_gateway_vpc_attachment () = { transit_gateway_vpc_attachment }

  let parse xml =
    Some
      { transit_gateway_vpc_attachment =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayVpcAttachment" xml)
            TransitGatewayVpcAttachment.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_vpc_attachment (fun f ->
               Aws.Query.Pair
                 ("TransitGatewayVpcAttachment", TransitGatewayVpcAttachment.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_vpc_attachment (fun f ->
               "transitGatewayVpcAttachment", TransitGatewayVpcAttachment.to_json f)
         ])

  let of_json j =
    { transit_gateway_vpc_attachment =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayVpcAttachment")
          TransitGatewayVpcAttachment.of_json
    }
end

module LocalGatewayRouteTable = struct
  type t =
    { local_gateway_route_table_id : String.t option
    ; local_gateway_route_table_arn : String.t option
    ; local_gateway_id : String.t option
    ; outpost_arn : String.t option
    ; owner_id : String.t option
    ; state : String.t option
    ; tags : TagList.t
    }

  let make
      ?local_gateway_route_table_id
      ?local_gateway_route_table_arn
      ?local_gateway_id
      ?outpost_arn
      ?owner_id
      ?state
      ?(tags = [])
      () =
    { local_gateway_route_table_id
    ; local_gateway_route_table_arn
    ; local_gateway_id
    ; outpost_arn
    ; owner_id
    ; state
    ; tags
    }

  let parse xml =
    Some
      { local_gateway_route_table_id =
          Aws.Util.option_bind
            (Aws.Xml.member "localGatewayRouteTableId" xml)
            String.parse
      ; local_gateway_route_table_arn =
          Aws.Util.option_bind
            (Aws.Xml.member "localGatewayRouteTableArn" xml)
            String.parse
      ; local_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "localGatewayId" xml) String.parse
      ; outpost_arn = Aws.Util.option_bind (Aws.Xml.member "outpostArn" xml) String.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; state = Aws.Util.option_bind (Aws.Xml.member "state" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", String.to_query f))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.outpost_arn (fun f ->
               Aws.Query.Pair ("OutpostArn", String.to_query f))
         ; Aws.Util.option_map v.local_gateway_id (fun f ->
               Aws.Query.Pair ("LocalGatewayId", String.to_query f))
         ; Aws.Util.option_map v.local_gateway_route_table_arn (fun f ->
               Aws.Query.Pair ("LocalGatewayRouteTableArn", String.to_query f))
         ; Aws.Util.option_map v.local_gateway_route_table_id (fun f ->
               Aws.Query.Pair ("LocalGatewayRouteTableId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.state (fun f -> "state", String.to_json f)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.outpost_arn (fun f -> "outpostArn", String.to_json f)
         ; Aws.Util.option_map v.local_gateway_id (fun f ->
               "localGatewayId", String.to_json f)
         ; Aws.Util.option_map v.local_gateway_route_table_arn (fun f ->
               "localGatewayRouteTableArn", String.to_json f)
         ; Aws.Util.option_map v.local_gateway_route_table_id (fun f ->
               "localGatewayRouteTableId", String.to_json f)
         ])

  let of_json j =
    { local_gateway_route_table_id =
        Aws.Util.option_map (Aws.Json.lookup j "localGatewayRouteTableId") String.of_json
    ; local_gateway_route_table_arn =
        Aws.Util.option_map (Aws.Json.lookup j "localGatewayRouteTableArn") String.of_json
    ; local_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "localGatewayId") String.of_json
    ; outpost_arn = Aws.Util.option_map (Aws.Json.lookup j "outpostArn") String.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; state = Aws.Util.option_map (Aws.Json.lookup j "state") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module LocalGatewayRouteTableSet = struct
  type t = LocalGatewayRouteTable.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map LocalGatewayRouteTable.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list LocalGatewayRouteTable.to_query v

  let to_json v = `List (List.map LocalGatewayRouteTable.to_json v)

  let of_json j = Aws.Json.to_list LocalGatewayRouteTable.of_json j
end

module DescribeVpcEndpointServicesResult = struct
  type t =
    { service_names : ValueStringList.t
    ; service_details : ServiceDetailSet.t
    ; next_token : String.t option
    }

  let make ?(service_names = []) ?(service_details = []) ?next_token () =
    { service_names; service_details; next_token }

  let parse xml =
    Some
      { service_names =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "serviceNameSet" xml)
               ValueStringList.parse)
      ; service_details =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "serviceDetailSet" xml)
               ServiceDetailSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ServiceDetailSet", ServiceDetailSet.to_query v.service_details))
         ; Some
             (Aws.Query.Pair ("ServiceNameSet", ValueStringList.to_query v.service_names))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("serviceDetailSet", ServiceDetailSet.to_json v.service_details)
         ; Some ("serviceNameSet", ValueStringList.to_json v.service_names)
         ])

  let of_json j =
    { service_names =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "serviceNameSet"))
    ; service_details =
        ServiceDetailSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "serviceDetailSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module CreateTrafficMirrorTargetResult = struct
  type t =
    { traffic_mirror_target : TrafficMirrorTarget.t option
    ; client_token : String.t option
    }

  let make ?traffic_mirror_target ?client_token () =
    { traffic_mirror_target; client_token }

  let parse xml =
    Some
      { traffic_mirror_target =
          Aws.Util.option_bind
            (Aws.Xml.member "trafficMirrorTarget" xml)
            TrafficMirrorTarget.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "clientToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.traffic_mirror_target (fun f ->
               Aws.Query.Pair ("TrafficMirrorTarget", TrafficMirrorTarget.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f -> "clientToken", String.to_json f)
         ; Aws.Util.option_map v.traffic_mirror_target (fun f ->
               "trafficMirrorTarget", TrafficMirrorTarget.to_json f)
         ])

  let of_json j =
    { traffic_mirror_target =
        Aws.Util.option_map
          (Aws.Json.lookup j "trafficMirrorTarget")
          TrafficMirrorTarget.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "clientToken") String.of_json
    }
end

module TrafficMirrorSessionIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DeleteSubnetRequest = struct
  type t =
    { subnet_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~subnet_id ?dry_run () = { subnet_id; dry_run }

  let parse xml =
    Some
      { subnet_id =
          Aws.Xml.required
            "SubnetId"
            (Aws.Util.option_bind (Aws.Xml.member "SubnetId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("SubnetId", String.to_query v.subnet_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("SubnetId", String.to_json v.subnet_id)
         ])

  let of_json j =
    { subnet_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SubnetId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module ModifyVpnConnectionOptionsRequest = struct
  type t =
    { vpn_connection_id : String.t
    ; local_ipv4_network_cidr : String.t option
    ; remote_ipv4_network_cidr : String.t option
    ; local_ipv6_network_cidr : String.t option
    ; remote_ipv6_network_cidr : String.t option
    ; dry_run : Boolean.t option
    }

  let make
      ~vpn_connection_id
      ?local_ipv4_network_cidr
      ?remote_ipv4_network_cidr
      ?local_ipv6_network_cidr
      ?remote_ipv6_network_cidr
      ?dry_run
      () =
    { vpn_connection_id
    ; local_ipv4_network_cidr
    ; remote_ipv4_network_cidr
    ; local_ipv6_network_cidr
    ; remote_ipv6_network_cidr
    ; dry_run
    }

  let parse xml =
    Some
      { vpn_connection_id =
          Aws.Xml.required
            "VpnConnectionId"
            (Aws.Util.option_bind (Aws.Xml.member "VpnConnectionId" xml) String.parse)
      ; local_ipv4_network_cidr =
          Aws.Util.option_bind (Aws.Xml.member "LocalIpv4NetworkCidr" xml) String.parse
      ; remote_ipv4_network_cidr =
          Aws.Util.option_bind (Aws.Xml.member "RemoteIpv4NetworkCidr" xml) String.parse
      ; local_ipv6_network_cidr =
          Aws.Util.option_bind (Aws.Xml.member "LocalIpv6NetworkCidr" xml) String.parse
      ; remote_ipv6_network_cidr =
          Aws.Util.option_bind (Aws.Xml.member "RemoteIpv6NetworkCidr" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.remote_ipv6_network_cidr (fun f ->
               Aws.Query.Pair ("RemoteIpv6NetworkCidr", String.to_query f))
         ; Aws.Util.option_map v.local_ipv6_network_cidr (fun f ->
               Aws.Query.Pair ("LocalIpv6NetworkCidr", String.to_query f))
         ; Aws.Util.option_map v.remote_ipv4_network_cidr (fun f ->
               Aws.Query.Pair ("RemoteIpv4NetworkCidr", String.to_query f))
         ; Aws.Util.option_map v.local_ipv4_network_cidr (fun f ->
               Aws.Query.Pair ("LocalIpv4NetworkCidr", String.to_query f))
         ; Some (Aws.Query.Pair ("VpnConnectionId", String.to_query v.vpn_connection_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.remote_ipv6_network_cidr (fun f ->
               "RemoteIpv6NetworkCidr", String.to_json f)
         ; Aws.Util.option_map v.local_ipv6_network_cidr (fun f ->
               "LocalIpv6NetworkCidr", String.to_json f)
         ; Aws.Util.option_map v.remote_ipv4_network_cidr (fun f ->
               "RemoteIpv4NetworkCidr", String.to_json f)
         ; Aws.Util.option_map v.local_ipv4_network_cidr (fun f ->
               "LocalIpv4NetworkCidr", String.to_json f)
         ; Some ("VpnConnectionId", String.to_json v.vpn_connection_id)
         ])

  let of_json j =
    { vpn_connection_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpnConnectionId"))
    ; local_ipv4_network_cidr =
        Aws.Util.option_map (Aws.Json.lookup j "LocalIpv4NetworkCidr") String.of_json
    ; remote_ipv4_network_cidr =
        Aws.Util.option_map (Aws.Json.lookup j "RemoteIpv4NetworkCidr") String.of_json
    ; local_ipv6_network_cidr =
        Aws.Util.option_map (Aws.Json.lookup j "LocalIpv6NetworkCidr") String.of_json
    ; remote_ipv6_network_cidr =
        Aws.Util.option_map (Aws.Json.lookup j "RemoteIpv6NetworkCidr") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module LocalGatewayRouteTableVpcAssociation = struct
  type t =
    { local_gateway_route_table_vpc_association_id : String.t option
    ; local_gateway_route_table_id : String.t option
    ; local_gateway_route_table_arn : String.t option
    ; local_gateway_id : String.t option
    ; vpc_id : String.t option
    ; owner_id : String.t option
    ; state : String.t option
    ; tags : TagList.t
    }

  let make
      ?local_gateway_route_table_vpc_association_id
      ?local_gateway_route_table_id
      ?local_gateway_route_table_arn
      ?local_gateway_id
      ?vpc_id
      ?owner_id
      ?state
      ?(tags = [])
      () =
    { local_gateway_route_table_vpc_association_id
    ; local_gateway_route_table_id
    ; local_gateway_route_table_arn
    ; local_gateway_id
    ; vpc_id
    ; owner_id
    ; state
    ; tags
    }

  let parse xml =
    Some
      { local_gateway_route_table_vpc_association_id =
          Aws.Util.option_bind
            (Aws.Xml.member "localGatewayRouteTableVpcAssociationId" xml)
            String.parse
      ; local_gateway_route_table_id =
          Aws.Util.option_bind
            (Aws.Xml.member "localGatewayRouteTableId" xml)
            String.parse
      ; local_gateway_route_table_arn =
          Aws.Util.option_bind
            (Aws.Xml.member "localGatewayRouteTableArn" xml)
            String.parse
      ; local_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "localGatewayId" xml) String.parse
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; state = Aws.Util.option_bind (Aws.Xml.member "state" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", String.to_query f))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Aws.Util.option_map v.local_gateway_id (fun f ->
               Aws.Query.Pair ("LocalGatewayId", String.to_query f))
         ; Aws.Util.option_map v.local_gateway_route_table_arn (fun f ->
               Aws.Query.Pair ("LocalGatewayRouteTableArn", String.to_query f))
         ; Aws.Util.option_map v.local_gateway_route_table_id (fun f ->
               Aws.Query.Pair ("LocalGatewayRouteTableId", String.to_query f))
         ; Aws.Util.option_map v.local_gateway_route_table_vpc_association_id (fun f ->
               Aws.Query.Pair ("LocalGatewayRouteTableVpcAssociationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.state (fun f -> "state", String.to_json f)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.vpc_id (fun f -> "vpcId", String.to_json f)
         ; Aws.Util.option_map v.local_gateway_id (fun f ->
               "localGatewayId", String.to_json f)
         ; Aws.Util.option_map v.local_gateway_route_table_arn (fun f ->
               "localGatewayRouteTableArn", String.to_json f)
         ; Aws.Util.option_map v.local_gateway_route_table_id (fun f ->
               "localGatewayRouteTableId", String.to_json f)
         ; Aws.Util.option_map v.local_gateway_route_table_vpc_association_id (fun f ->
               "localGatewayRouteTableVpcAssociationId", String.to_json f)
         ])

  let of_json j =
    { local_gateway_route_table_vpc_association_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "localGatewayRouteTableVpcAssociationId")
          String.of_json
    ; local_gateway_route_table_id =
        Aws.Util.option_map (Aws.Json.lookup j "localGatewayRouteTableId") String.of_json
    ; local_gateway_route_table_arn =
        Aws.Util.option_map (Aws.Json.lookup j "localGatewayRouteTableArn") String.of_json
    ; local_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "localGatewayId") String.of_json
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "vpcId") String.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; state = Aws.Util.option_map (Aws.Json.lookup j "state") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module DeleteLocalGatewayRouteTableVpcAssociationResult = struct
  type t =
    { local_gateway_route_table_vpc_association :
        LocalGatewayRouteTableVpcAssociation.t option
    }

  let make ?local_gateway_route_table_vpc_association () =
    { local_gateway_route_table_vpc_association }

  let parse xml =
    Some
      { local_gateway_route_table_vpc_association =
          Aws.Util.option_bind
            (Aws.Xml.member "localGatewayRouteTableVpcAssociation" xml)
            LocalGatewayRouteTableVpcAssociation.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.local_gateway_route_table_vpc_association (fun f ->
               Aws.Query.Pair
                 ( "LocalGatewayRouteTableVpcAssociation"
                 , LocalGatewayRouteTableVpcAssociation.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.local_gateway_route_table_vpc_association (fun f ->
               ( "localGatewayRouteTableVpcAssociation"
               , LocalGatewayRouteTableVpcAssociation.to_json f ))
         ])

  let of_json j =
    { local_gateway_route_table_vpc_association =
        Aws.Util.option_map
          (Aws.Json.lookup j "localGatewayRouteTableVpcAssociation")
          LocalGatewayRouteTableVpcAssociation.of_json
    }
end

module SecurityGroup = struct
  type t =
    { description : String.t
    ; group_name : String.t
    ; ip_permissions : IpPermissionList.t
    ; owner_id : String.t
    ; group_id : String.t
    ; ip_permissions_egress : IpPermissionList.t
    ; tags : TagList.t
    ; vpc_id : String.t option
    }

  let make
      ~description
      ~group_name
      ?(ip_permissions = [])
      ~owner_id
      ~group_id
      ?(ip_permissions_egress = [])
      ?(tags = [])
      ?vpc_id
      () =
    { description
    ; group_name
    ; ip_permissions
    ; owner_id
    ; group_id
    ; ip_permissions_egress
    ; tags
    ; vpc_id
    }

  let parse xml =
    Some
      { description =
          Aws.Xml.required
            "groupDescription"
            (Aws.Util.option_bind (Aws.Xml.member "groupDescription" xml) String.parse)
      ; group_name =
          Aws.Xml.required
            "groupName"
            (Aws.Util.option_bind (Aws.Xml.member "groupName" xml) String.parse)
      ; ip_permissions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ipPermissions" xml)
               IpPermissionList.parse)
      ; owner_id =
          Aws.Xml.required
            "ownerId"
            (Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse)
      ; group_id =
          Aws.Xml.required
            "groupId"
            (Aws.Util.option_bind (Aws.Xml.member "groupId" xml) String.parse)
      ; ip_permissions_egress =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ipPermissionsEgress" xml)
               IpPermissionList.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Some
             (Aws.Query.Pair
                ("IpPermissionsEgress", IpPermissionList.to_query v.ip_permissions_egress))
         ; Some (Aws.Query.Pair ("GroupId", String.to_query v.group_id))
         ; Some (Aws.Query.Pair ("OwnerId", String.to_query v.owner_id))
         ; Some
             (Aws.Query.Pair ("IpPermissions", IpPermissionList.to_query v.ip_permissions))
         ; Some (Aws.Query.Pair ("GroupName", String.to_query v.group_name))
         ; Some (Aws.Query.Pair ("GroupDescription", String.to_query v.description))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_id (fun f -> "vpcId", String.to_json f)
         ; Some ("tagSet", TagList.to_json v.tags)
         ; Some ("ipPermissionsEgress", IpPermissionList.to_json v.ip_permissions_egress)
         ; Some ("groupId", String.to_json v.group_id)
         ; Some ("ownerId", String.to_json v.owner_id)
         ; Some ("ipPermissions", IpPermissionList.to_json v.ip_permissions)
         ; Some ("groupName", String.to_json v.group_name)
         ; Some ("groupDescription", String.to_json v.description)
         ])

  let of_json j =
    { description =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "groupDescription"))
    ; group_name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "groupName"))
    ; ip_permissions =
        IpPermissionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ipPermissions"))
    ; owner_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ownerId"))
    ; group_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "groupId"))
    ; ip_permissions_egress =
        IpPermissionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ipPermissionsEgress"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "vpcId") String.of_json
    }
end

module SecurityGroupList = struct
  type t = SecurityGroup.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map SecurityGroup.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list SecurityGroup.to_query v

  let to_json v = `List (List.map SecurityGroup.to_json v)

  let of_json j = Aws.Json.to_list SecurityGroup.of_json j
end

module DescribeSecurityGroupsResult = struct
  type t =
    { security_groups : SecurityGroupList.t
    ; next_token : String.t option
    }

  let make ?(security_groups = []) ?next_token () = { security_groups; next_token }

  let parse xml =
    Some
      { security_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "securityGroupInfo" xml)
               SecurityGroupList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("SecurityGroupInfo", SecurityGroupList.to_query v.security_groups))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("securityGroupInfo", SecurityGroupList.to_json v.security_groups)
         ])

  let of_json j =
    { security_groups =
        SecurityGroupList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "securityGroupInfo"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DescribeClientVpnAuthorizationRulesRequest = struct
  type t =
    { client_vpn_endpoint_id : String.t
    ; dry_run : Boolean.t option
    ; next_token : String.t option
    ; filters : FilterList.t
    ; max_results : Integer.t option
    }

  let make ~client_vpn_endpoint_id ?dry_run ?next_token ?(filters = []) ?max_results () =
    { client_vpn_endpoint_id; dry_run; next_token; filters; max_results }

  let parse xml =
    Some
      { client_vpn_endpoint_id =
          Aws.Xml.required
            "ClientVpnEndpointId"
            (Aws.Util.option_bind (Aws.Xml.member "ClientVpnEndpointId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ClientVpnEndpointId", String.to_query v.client_vpn_endpoint_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("ClientVpnEndpointId", String.to_json v.client_vpn_endpoint_id)
         ])

  let of_json j =
    { client_vpn_endpoint_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ClientVpnEndpointId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module CreateTransitGatewayRouteResult = struct
  type t = { route : TransitGatewayRoute.t option }

  let make ?route () = { route }

  let parse xml =
    Some
      { route =
          Aws.Util.option_bind (Aws.Xml.member "route" xml) TransitGatewayRoute.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.route (fun f ->
               Aws.Query.Pair ("Route", TransitGatewayRoute.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.route (fun f -> "route", TransitGatewayRoute.to_json f) ])

  let of_json j =
    { route = Aws.Util.option_map (Aws.Json.lookup j "route") TransitGatewayRoute.of_json
    }
end

module UnmonitorInstancesResult = struct
  type t = { instance_monitorings : InstanceMonitoringList.t }

  let make ?(instance_monitorings = []) () = { instance_monitorings }

  let parse xml =
    Some
      { instance_monitorings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "instancesSet" xml)
               InstanceMonitoringList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("InstancesSet", InstanceMonitoringList.to_query v.instance_monitorings))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("instancesSet", InstanceMonitoringList.to_json v.instance_monitorings) ])

  let of_json j =
    { instance_monitorings =
        InstanceMonitoringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "instancesSet"))
    }
end

module EbsInstanceBlockDeviceSpecification = struct
  type t =
    { delete_on_termination : Boolean.t option
    ; volume_id : String.t option
    }

  let make ?delete_on_termination ?volume_id () = { delete_on_termination; volume_id }

  let parse xml =
    Some
      { delete_on_termination =
          Aws.Util.option_bind (Aws.Xml.member "deleteOnTermination" xml) Boolean.parse
      ; volume_id = Aws.Util.option_bind (Aws.Xml.member "volumeId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.volume_id (fun f ->
               Aws.Query.Pair ("VolumeId", String.to_query f))
         ; Aws.Util.option_map v.delete_on_termination (fun f ->
               Aws.Query.Pair ("DeleteOnTermination", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.volume_id (fun f -> "volumeId", String.to_json f)
         ; Aws.Util.option_map v.delete_on_termination (fun f ->
               "deleteOnTermination", Boolean.to_json f)
         ])

  let of_json j =
    { delete_on_termination =
        Aws.Util.option_map (Aws.Json.lookup j "deleteOnTermination") Boolean.of_json
    ; volume_id = Aws.Util.option_map (Aws.Json.lookup j "volumeId") String.of_json
    }
end

module InstanceBlockDeviceMappingSpecification = struct
  type t =
    { device_name : String.t option
    ; ebs : EbsInstanceBlockDeviceSpecification.t option
    ; no_device : String.t option
    ; virtual_name : String.t option
    }

  let make ?device_name ?ebs ?no_device ?virtual_name () =
    { device_name; ebs; no_device; virtual_name }

  let parse xml =
    Some
      { device_name = Aws.Util.option_bind (Aws.Xml.member "deviceName" xml) String.parse
      ; ebs =
          Aws.Util.option_bind
            (Aws.Xml.member "ebs" xml)
            EbsInstanceBlockDeviceSpecification.parse
      ; no_device = Aws.Util.option_bind (Aws.Xml.member "noDevice" xml) String.parse
      ; virtual_name =
          Aws.Util.option_bind (Aws.Xml.member "virtualName" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.virtual_name (fun f ->
               Aws.Query.Pair ("VirtualName", String.to_query f))
         ; Aws.Util.option_map v.no_device (fun f ->
               Aws.Query.Pair ("NoDevice", String.to_query f))
         ; Aws.Util.option_map v.ebs (fun f ->
               Aws.Query.Pair ("Ebs", EbsInstanceBlockDeviceSpecification.to_query f))
         ; Aws.Util.option_map v.device_name (fun f ->
               Aws.Query.Pair ("DeviceName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.virtual_name (fun f -> "virtualName", String.to_json f)
         ; Aws.Util.option_map v.no_device (fun f -> "noDevice", String.to_json f)
         ; Aws.Util.option_map v.ebs (fun f ->
               "ebs", EbsInstanceBlockDeviceSpecification.to_json f)
         ; Aws.Util.option_map v.device_name (fun f -> "deviceName", String.to_json f)
         ])

  let of_json j =
    { device_name = Aws.Util.option_map (Aws.Json.lookup j "deviceName") String.of_json
    ; ebs =
        Aws.Util.option_map
          (Aws.Json.lookup j "ebs")
          EbsInstanceBlockDeviceSpecification.of_json
    ; no_device = Aws.Util.option_map (Aws.Json.lookup j "noDevice") String.of_json
    ; virtual_name = Aws.Util.option_map (Aws.Json.lookup j "virtualName") String.of_json
    }
end

module DescribeExportTasksResult = struct
  type t = { export_tasks : ExportTaskList.t }

  let make ?(export_tasks = []) () = { export_tasks }

  let parse xml =
    Some
      { export_tasks =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "exportTaskSet" xml)
               ExportTaskList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("ExportTaskSet", ExportTaskList.to_query v.export_tasks))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("exportTaskSet", ExportTaskList.to_json v.export_tasks) ])

  let of_json j =
    { export_tasks =
        ExportTaskList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "exportTaskSet"))
    }
end

module DeleteTransitGatewayMulticastDomainRequest = struct
  type t =
    { transit_gateway_multicast_domain_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~transit_gateway_multicast_domain_id ?dry_run () =
    { transit_gateway_multicast_domain_id; dry_run }

  let parse xml =
    Some
      { transit_gateway_multicast_domain_id =
          Aws.Xml.required
            "TransitGatewayMulticastDomainId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayMulticastDomainId" xml)
               String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayMulticastDomainId"
                , String.to_query v.transit_gateway_multicast_domain_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ( "TransitGatewayMulticastDomainId"
             , String.to_json v.transit_gateway_multicast_domain_id )
         ])

  let of_json j =
    { transit_gateway_multicast_domain_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayMulticastDomainId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module CancelExportTaskRequest = struct
  type t = { export_task_id : String.t }

  let make ~export_task_id () = { export_task_id }

  let parse xml =
    Some
      { export_task_id =
          Aws.Xml.required
            "exportTaskId"
            (Aws.Util.option_bind (Aws.Xml.member "exportTaskId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("ExportTaskId", String.to_query v.export_task_id)) ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("exportTaskId", String.to_json v.export_task_id) ])

  let of_json j =
    { export_task_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "exportTaskId"))
    }
end

module DeleteNetworkInterfacePermissionResult = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module SubnetAssociationList = struct
  type t = SubnetAssociation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map SubnetAssociation.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list SubnetAssociation.to_query v

  let to_json v = `List (List.map SubnetAssociation.to_json v)

  let of_json j = Aws.Json.to_list SubnetAssociation.of_json j
end

module TransitGatewayMulticastDomainAssociations = struct
  type t =
    { transit_gateway_multicast_domain_id : String.t option
    ; transit_gateway_attachment_id : String.t option
    ; resource_id : String.t option
    ; resource_type : TransitGatewayAttachmentResourceType.t option
    ; subnets : SubnetAssociationList.t
    }

  let make
      ?transit_gateway_multicast_domain_id
      ?transit_gateway_attachment_id
      ?resource_id
      ?resource_type
      ?(subnets = [])
      () =
    { transit_gateway_multicast_domain_id
    ; transit_gateway_attachment_id
    ; resource_id
    ; resource_type
    ; subnets
    }

  let parse xml =
    Some
      { transit_gateway_multicast_domain_id =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayMulticastDomainId" xml)
            String.parse
      ; transit_gateway_attachment_id =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayAttachmentId" xml)
            String.parse
      ; resource_id = Aws.Util.option_bind (Aws.Xml.member "resourceId" xml) String.parse
      ; resource_type =
          Aws.Util.option_bind
            (Aws.Xml.member "resourceType" xml)
            TransitGatewayAttachmentResourceType.parse
      ; subnets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "subnets" xml)
               SubnetAssociationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Subnets", SubnetAssociationList.to_query v.subnets))
         ; Aws.Util.option_map v.resource_type (fun f ->
               Aws.Query.Pair
                 ("ResourceType", TransitGatewayAttachmentResourceType.to_query f))
         ; Aws.Util.option_map v.resource_id (fun f ->
               Aws.Query.Pair ("ResourceId", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               Aws.Query.Pair ("TransitGatewayAttachmentId", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               Aws.Query.Pair ("TransitGatewayMulticastDomainId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("subnets", SubnetAssociationList.to_json v.subnets)
         ; Aws.Util.option_map v.resource_type (fun f ->
               "resourceType", TransitGatewayAttachmentResourceType.to_json f)
         ; Aws.Util.option_map v.resource_id (fun f -> "resourceId", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               "transitGatewayAttachmentId", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               "transitGatewayMulticastDomainId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_multicast_domain_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayMulticastDomainId")
          String.of_json
    ; transit_gateway_attachment_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayAttachmentId")
          String.of_json
    ; resource_id = Aws.Util.option_map (Aws.Json.lookup j "resourceId") String.of_json
    ; resource_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "resourceType")
          TransitGatewayAttachmentResourceType.of_json
    ; subnets =
        SubnetAssociationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "subnets"))
    }
end

module AssociateTransitGatewayMulticastDomainResult = struct
  type t = { associations : TransitGatewayMulticastDomainAssociations.t option }

  let make ?associations () = { associations }

  let parse xml =
    Some
      { associations =
          Aws.Util.option_bind
            (Aws.Xml.member "associations" xml)
            TransitGatewayMulticastDomainAssociations.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.associations (fun f ->
               Aws.Query.Pair
                 ("Associations", TransitGatewayMulticastDomainAssociations.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.associations (fun f ->
               "associations", TransitGatewayMulticastDomainAssociations.to_json f)
         ])

  let of_json j =
    { associations =
        Aws.Util.option_map
          (Aws.Json.lookup j "associations")
          TransitGatewayMulticastDomainAssociations.of_json
    }
end

module DeleteVpcRequest = struct
  type t =
    { vpc_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~vpc_id ?dry_run () = { vpc_id; dry_run }

  let parse xml =
    Some
      { vpc_id =
          Aws.Xml.required
            "VpcId"
            (Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("VpcId", String.to_json v.vpc_id)
         ])

  let of_json j =
    { vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module RegionNameStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "RegionName" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module GetLaunchTemplateDataResult = struct
  type t = { launch_template_data : ResponseLaunchTemplateData.t option }

  let make ?launch_template_data () = { launch_template_data }

  let parse xml =
    Some
      { launch_template_data =
          Aws.Util.option_bind
            (Aws.Xml.member "launchTemplateData" xml)
            ResponseLaunchTemplateData.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.launch_template_data (fun f ->
               Aws.Query.Pair ("LaunchTemplateData", ResponseLaunchTemplateData.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.launch_template_data (fun f ->
               "launchTemplateData", ResponseLaunchTemplateData.to_json f)
         ])

  let of_json j =
    { launch_template_data =
        Aws.Util.option_map
          (Aws.Json.lookup j "launchTemplateData")
          ResponseLaunchTemplateData.of_json
    }
end

module VolumeDetail = struct
  type t = { size : Long.t }

  let make ~size () = { size }

  let parse xml =
    Some
      { size =
          Aws.Xml.required
            "size"
            (Aws.Util.option_bind (Aws.Xml.member "size" xml) Long.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt [ Some (Aws.Query.Pair ("Size", Long.to_query v.size)) ])

  let to_json v = `Assoc (Aws.Util.list_filter_opt [ Some ("size", Long.to_json v.size) ])

  let of_json j =
    { size = Long.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "size")) }
end

module DiskImage = struct
  type t =
    { description : String.t option
    ; image : DiskImageDetail.t option
    ; volume : VolumeDetail.t option
    }

  let make ?description ?image ?volume () = { description; image; volume }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; image = Aws.Util.option_bind (Aws.Xml.member "Image" xml) DiskImageDetail.parse
      ; volume = Aws.Util.option_bind (Aws.Xml.member "Volume" xml) VolumeDetail.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.volume (fun f ->
               Aws.Query.Pair ("Volume", VolumeDetail.to_query f))
         ; Aws.Util.option_map v.image (fun f ->
               Aws.Query.Pair ("Image", DiskImageDetail.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.volume (fun f -> "Volume", VolumeDetail.to_json f)
         ; Aws.Util.option_map v.image (fun f -> "Image", DiskImageDetail.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; image = Aws.Util.option_map (Aws.Json.lookup j "Image") DiskImageDetail.of_json
    ; volume = Aws.Util.option_map (Aws.Json.lookup j "Volume") VolumeDetail.of_json
    }
end

module SuccessfulQueuedPurchaseDeletionSet = struct
  type t = SuccessfulQueuedPurchaseDeletion.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map SuccessfulQueuedPurchaseDeletion.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list SuccessfulQueuedPurchaseDeletion.to_query v

  let to_json v = `List (List.map SuccessfulQueuedPurchaseDeletion.to_json v)

  let of_json j = Aws.Json.to_list SuccessfulQueuedPurchaseDeletion.of_json j
end

module FailedQueuedPurchaseDeletionSet = struct
  type t = FailedQueuedPurchaseDeletion.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map FailedQueuedPurchaseDeletion.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list FailedQueuedPurchaseDeletion.to_query v

  let to_json v = `List (List.map FailedQueuedPurchaseDeletion.to_json v)

  let of_json j = Aws.Json.to_list FailedQueuedPurchaseDeletion.of_json j
end

module DeleteQueuedReservedInstancesResult = struct
  type t =
    { successful_queued_purchase_deletions : SuccessfulQueuedPurchaseDeletionSet.t
    ; failed_queued_purchase_deletions : FailedQueuedPurchaseDeletionSet.t
    }

  let make
      ?(successful_queued_purchase_deletions = [])
      ?(failed_queued_purchase_deletions = [])
      () =
    { successful_queued_purchase_deletions; failed_queued_purchase_deletions }

  let parse xml =
    Some
      { successful_queued_purchase_deletions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "successfulQueuedPurchaseDeletionSet" xml)
               SuccessfulQueuedPurchaseDeletionSet.parse)
      ; failed_queued_purchase_deletions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "failedQueuedPurchaseDeletionSet" xml)
               FailedQueuedPurchaseDeletionSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "FailedQueuedPurchaseDeletionSet"
                , FailedQueuedPurchaseDeletionSet.to_query
                    v.failed_queued_purchase_deletions ))
         ; Some
             (Aws.Query.Pair
                ( "SuccessfulQueuedPurchaseDeletionSet"
                , SuccessfulQueuedPurchaseDeletionSet.to_query
                    v.successful_queued_purchase_deletions ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "failedQueuedPurchaseDeletionSet"
             , FailedQueuedPurchaseDeletionSet.to_json v.failed_queued_purchase_deletions
             )
         ; Some
             ( "successfulQueuedPurchaseDeletionSet"
             , SuccessfulQueuedPurchaseDeletionSet.to_json
                 v.successful_queued_purchase_deletions )
         ])

  let of_json j =
    { successful_queued_purchase_deletions =
        SuccessfulQueuedPurchaseDeletionSet.of_json
          (Aws.Util.of_option_exn
             (Aws.Json.lookup j "successfulQueuedPurchaseDeletionSet"))
    ; failed_queued_purchase_deletions =
        FailedQueuedPurchaseDeletionSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "failedQueuedPurchaseDeletionSet"))
    }
end

module AllocationState = struct
  type t =
    | Available
    | Under_assessment
    | Permanent_failure
    | Released
    | Released_permanent_failure
    | Pending

  let str_to_t =
    [ "pending", Pending
    ; "released-permanent-failure", Released_permanent_failure
    ; "released", Released
    ; "permanent-failure", Permanent_failure
    ; "under-assessment", Under_assessment
    ; "available", Available
    ]

  let t_to_str =
    [ Pending, "pending"
    ; Released_permanent_failure, "released-permanent-failure"
    ; Released, "released"
    ; Permanent_failure, "permanent-failure"
    ; Under_assessment, "under-assessment"
    ; Available, "available"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DeleteRouteRequest = struct
  type t =
    { destination_cidr_block : String.t option
    ; destination_ipv6_cidr_block : String.t option
    ; destination_prefix_list_id : String.t option
    ; dry_run : Boolean.t option
    ; route_table_id : String.t
    }

  let make
      ?destination_cidr_block
      ?destination_ipv6_cidr_block
      ?destination_prefix_list_id
      ?dry_run
      ~route_table_id
      () =
    { destination_cidr_block
    ; destination_ipv6_cidr_block
    ; destination_prefix_list_id
    ; dry_run
    ; route_table_id
    }

  let parse xml =
    Some
      { destination_cidr_block =
          Aws.Util.option_bind (Aws.Xml.member "destinationCidrBlock" xml) String.parse
      ; destination_ipv6_cidr_block =
          Aws.Util.option_bind
            (Aws.Xml.member "destinationIpv6CidrBlock" xml)
            String.parse
      ; destination_prefix_list_id =
          Aws.Util.option_bind (Aws.Xml.member "DestinationPrefixListId" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; route_table_id =
          Aws.Xml.required
            "routeTableId"
            (Aws.Util.option_bind (Aws.Xml.member "routeTableId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("RouteTableId", String.to_query v.route_table_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.destination_prefix_list_id (fun f ->
               Aws.Query.Pair ("DestinationPrefixListId", String.to_query f))
         ; Aws.Util.option_map v.destination_ipv6_cidr_block (fun f ->
               Aws.Query.Pair ("DestinationIpv6CidrBlock", String.to_query f))
         ; Aws.Util.option_map v.destination_cidr_block (fun f ->
               Aws.Query.Pair ("DestinationCidrBlock", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("routeTableId", String.to_json v.route_table_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.destination_prefix_list_id (fun f ->
               "DestinationPrefixListId", String.to_json f)
         ; Aws.Util.option_map v.destination_ipv6_cidr_block (fun f ->
               "destinationIpv6CidrBlock", String.to_json f)
         ; Aws.Util.option_map v.destination_cidr_block (fun f ->
               "destinationCidrBlock", String.to_json f)
         ])

  let of_json j =
    { destination_cidr_block =
        Aws.Util.option_map (Aws.Json.lookup j "destinationCidrBlock") String.of_json
    ; destination_ipv6_cidr_block =
        Aws.Util.option_map (Aws.Json.lookup j "destinationIpv6CidrBlock") String.of_json
    ; destination_prefix_list_id =
        Aws.Util.option_map (Aws.Json.lookup j "DestinationPrefixListId") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; route_table_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "routeTableId"))
    }
end

module Status = struct
  type t =
    | MoveInProgress
    | InVpc
    | InClassic

  let str_to_t =
    [ "InClassic", InClassic; "InVpc", InVpc; "MoveInProgress", MoveInProgress ]

  let t_to_str =
    [ InClassic, "InClassic"; InVpc, "InVpc"; MoveInProgress, "MoveInProgress" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module MoveAddressToVpcResult = struct
  type t =
    { allocation_id : String.t option
    ; status : Status.t option
    }

  let make ?allocation_id ?status () = { allocation_id; status }

  let parse xml =
    Some
      { allocation_id =
          Aws.Util.option_bind (Aws.Xml.member "allocationId" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "status" xml) Status.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", Status.to_query f))
         ; Aws.Util.option_map v.allocation_id (fun f ->
               Aws.Query.Pair ("AllocationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f -> "status", Status.to_json f)
         ; Aws.Util.option_map v.allocation_id (fun f -> "allocationId", String.to_json f)
         ])

  let of_json j =
    { allocation_id =
        Aws.Util.option_map (Aws.Json.lookup j "allocationId") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "status") Status.of_json
    }
end

module DescribeReservedInstancesListingsRequest = struct
  type t =
    { filters : FilterList.t
    ; reserved_instances_id : String.t option
    ; reserved_instances_listing_id : String.t option
    }

  let make ?(filters = []) ?reserved_instances_id ?reserved_instances_listing_id () =
    { filters; reserved_instances_id; reserved_instances_listing_id }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; reserved_instances_id =
          Aws.Util.option_bind (Aws.Xml.member "reservedInstancesId" xml) String.parse
      ; reserved_instances_listing_id =
          Aws.Util.option_bind
            (Aws.Xml.member "reservedInstancesListingId" xml)
            String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.reserved_instances_listing_id (fun f ->
               Aws.Query.Pair ("ReservedInstancesListingId", String.to_query f))
         ; Aws.Util.option_map v.reserved_instances_id (fun f ->
               Aws.Query.Pair ("ReservedInstancesId", String.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.reserved_instances_listing_id (fun f ->
               "reservedInstancesListingId", String.to_json f)
         ; Aws.Util.option_map v.reserved_instances_id (fun f ->
               "reservedInstancesId", String.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; reserved_instances_id =
        Aws.Util.option_map (Aws.Json.lookup j "reservedInstancesId") String.of_json
    ; reserved_instances_listing_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "reservedInstancesListingId")
          String.of_json
    }
end

module TransitGatewayPrefixListReferenceSet = struct
  type t = TransitGatewayPrefixListReference.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map TransitGatewayPrefixListReference.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list TransitGatewayPrefixListReference.to_query v

  let to_json v = `List (List.map TransitGatewayPrefixListReference.to_json v)

  let of_json j = Aws.Json.to_list TransitGatewayPrefixListReference.of_json j
end

module ExportTransitGatewayRoutesRequest = struct
  type t =
    { transit_gateway_route_table_id : String.t
    ; filters : FilterList.t
    ; s3_bucket : String.t
    ; dry_run : Boolean.t option
    }

  let make ~transit_gateway_route_table_id ?(filters = []) ~s3_bucket ?dry_run () =
    { transit_gateway_route_table_id; filters; s3_bucket; dry_run }

  let parse xml =
    Some
      { transit_gateway_route_table_id =
          Aws.Xml.required
            "TransitGatewayRouteTableId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayRouteTableId" xml)
               String.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; s3_bucket =
          Aws.Xml.required
            "S3Bucket"
            (Aws.Util.option_bind (Aws.Xml.member "S3Bucket" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("S3Bucket", String.to_query v.s3_bucket))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayRouteTableId"
                , String.to_query v.transit_gateway_route_table_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("S3Bucket", String.to_json v.s3_bucket)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some
             ( "TransitGatewayRouteTableId"
             , String.to_json v.transit_gateway_route_table_id )
         ])

  let of_json j =
    { transit_gateway_route_table_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayRouteTableId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; s3_bucket = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "S3Bucket"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module RequestSpotInstancesResult = struct
  type t = { spot_instance_requests : SpotInstanceRequestList.t }

  let make ?(spot_instance_requests = []) () = { spot_instance_requests }

  let parse xml =
    Some
      { spot_instance_requests =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "spotInstanceRequestSet" xml)
               SpotInstanceRequestList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "SpotInstanceRequestSet"
                , SpotInstanceRequestList.to_query v.spot_instance_requests ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "spotInstanceRequestSet"
             , SpotInstanceRequestList.to_json v.spot_instance_requests )
         ])

  let of_json j =
    { spot_instance_requests =
        SpotInstanceRequestList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "spotInstanceRequestSet"))
    }
end

module UpdateSecurityGroupRuleDescriptionsEgressRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; group_id : String.t option
    ; group_name : String.t option
    ; ip_permissions : IpPermissionList.t
    }

  let make ?dry_run ?group_id ?group_name ~ip_permissions () =
    { dry_run; group_id; group_name; ip_permissions }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; group_id = Aws.Util.option_bind (Aws.Xml.member "GroupId" xml) String.parse
      ; group_name = Aws.Util.option_bind (Aws.Xml.member "GroupName" xml) String.parse
      ; ip_permissions =
          Aws.Xml.required
            "IpPermissions"
            (Aws.Util.option_bind
               (Aws.Xml.member "IpPermissions" xml)
               IpPermissionList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("IpPermissions", IpPermissionList.to_query v.ip_permissions))
         ; Aws.Util.option_map v.group_name (fun f ->
               Aws.Query.Pair ("GroupName", String.to_query f))
         ; Aws.Util.option_map v.group_id (fun f ->
               Aws.Query.Pair ("GroupId", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("IpPermissions", IpPermissionList.to_json v.ip_permissions)
         ; Aws.Util.option_map v.group_name (fun f -> "GroupName", String.to_json f)
         ; Aws.Util.option_map v.group_id (fun f -> "GroupId", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; group_id = Aws.Util.option_map (Aws.Json.lookup j "GroupId") String.of_json
    ; group_name = Aws.Util.option_map (Aws.Json.lookup j "GroupName") String.of_json
    ; ip_permissions =
        IpPermissionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "IpPermissions"))
    }
end

module RegisterTransitGatewayMulticastGroupSourcesResult = struct
  type t =
    { registered_multicast_group_sources :
        TransitGatewayMulticastRegisteredGroupSources.t option
    }

  let make ?registered_multicast_group_sources () = { registered_multicast_group_sources }

  let parse xml =
    Some
      { registered_multicast_group_sources =
          Aws.Util.option_bind
            (Aws.Xml.member "registeredMulticastGroupSources" xml)
            TransitGatewayMulticastRegisteredGroupSources.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.registered_multicast_group_sources (fun f ->
               Aws.Query.Pair
                 ( "RegisteredMulticastGroupSources"
                 , TransitGatewayMulticastRegisteredGroupSources.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.registered_multicast_group_sources (fun f ->
               ( "registeredMulticastGroupSources"
               , TransitGatewayMulticastRegisteredGroupSources.to_json f ))
         ])

  let of_json j =
    { registered_multicast_group_sources =
        Aws.Util.option_map
          (Aws.Json.lookup j "registeredMulticastGroupSources")
          TransitGatewayMulticastRegisteredGroupSources.of_json
    }
end

module KeyPairIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "KeyPairId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module KeyNameStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "KeyName" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeKeyPairsRequest = struct
  type t =
    { filters : FilterList.t
    ; key_names : KeyNameStringList.t
    ; key_pair_ids : KeyPairIdStringList.t
    ; dry_run : Boolean.t option
    }

  let make ?(filters = []) ?(key_names = []) ?(key_pair_ids = []) ?dry_run () =
    { filters; key_names; key_pair_ids; dry_run }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; key_names =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "KeyName" xml) KeyNameStringList.parse)
      ; key_pair_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "KeyPairId" xml)
               KeyPairIdStringList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair ("KeyPairId", KeyPairIdStringList.to_query v.key_pair_ids))
         ; Some (Aws.Query.Pair ("KeyName", KeyNameStringList.to_query v.key_names))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("KeyPairId", KeyPairIdStringList.to_json v.key_pair_ids)
         ; Some ("KeyName", KeyNameStringList.to_json v.key_names)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; key_names =
        KeyNameStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "KeyName"))
    ; key_pair_ids =
        KeyPairIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "KeyPairId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module DeleteLaunchTemplateVersionsResponseSuccessItem = struct
  type t =
    { launch_template_id : String.t option
    ; launch_template_name : String.t option
    ; version_number : Long.t option
    }

  let make ?launch_template_id ?launch_template_name ?version_number () =
    { launch_template_id; launch_template_name; version_number }

  let parse xml =
    Some
      { launch_template_id =
          Aws.Util.option_bind (Aws.Xml.member "launchTemplateId" xml) String.parse
      ; launch_template_name =
          Aws.Util.option_bind (Aws.Xml.member "launchTemplateName" xml) String.parse
      ; version_number =
          Aws.Util.option_bind (Aws.Xml.member "versionNumber" xml) Long.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.version_number (fun f ->
               Aws.Query.Pair ("VersionNumber", Long.to_query f))
         ; Aws.Util.option_map v.launch_template_name (fun f ->
               Aws.Query.Pair ("LaunchTemplateName", String.to_query f))
         ; Aws.Util.option_map v.launch_template_id (fun f ->
               Aws.Query.Pair ("LaunchTemplateId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.version_number (fun f -> "versionNumber", Long.to_json f)
         ; Aws.Util.option_map v.launch_template_name (fun f ->
               "launchTemplateName", String.to_json f)
         ; Aws.Util.option_map v.launch_template_id (fun f ->
               "launchTemplateId", String.to_json f)
         ])

  let of_json j =
    { launch_template_id =
        Aws.Util.option_map (Aws.Json.lookup j "launchTemplateId") String.of_json
    ; launch_template_name =
        Aws.Util.option_map (Aws.Json.lookup j "launchTemplateName") String.of_json
    ; version_number =
        Aws.Util.option_map (Aws.Json.lookup j "versionNumber") Long.of_json
    }
end

module DeleteLaunchTemplateVersionsResponseSuccessSet = struct
  type t = DeleteLaunchTemplateVersionsResponseSuccessItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         DeleteLaunchTemplateVersionsResponseSuccessItem.parse
         (Aws.Xml.members "item" xml))

  let to_query v =
    Aws.Query.to_query_list DeleteLaunchTemplateVersionsResponseSuccessItem.to_query v

  let to_json v =
    `List (List.map DeleteLaunchTemplateVersionsResponseSuccessItem.to_json v)

  let of_json j =
    Aws.Json.to_list DeleteLaunchTemplateVersionsResponseSuccessItem.of_json j
end

module DeleteLaunchTemplateVersionsResponseErrorItem = struct
  type t =
    { launch_template_id : String.t option
    ; launch_template_name : String.t option
    ; version_number : Long.t option
    ; response_error : ResponseError.t option
    }

  let make ?launch_template_id ?launch_template_name ?version_number ?response_error () =
    { launch_template_id; launch_template_name; version_number; response_error }

  let parse xml =
    Some
      { launch_template_id =
          Aws.Util.option_bind (Aws.Xml.member "launchTemplateId" xml) String.parse
      ; launch_template_name =
          Aws.Util.option_bind (Aws.Xml.member "launchTemplateName" xml) String.parse
      ; version_number =
          Aws.Util.option_bind (Aws.Xml.member "versionNumber" xml) Long.parse
      ; response_error =
          Aws.Util.option_bind (Aws.Xml.member "responseError" xml) ResponseError.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.response_error (fun f ->
               Aws.Query.Pair ("ResponseError", ResponseError.to_query f))
         ; Aws.Util.option_map v.version_number (fun f ->
               Aws.Query.Pair ("VersionNumber", Long.to_query f))
         ; Aws.Util.option_map v.launch_template_name (fun f ->
               Aws.Query.Pair ("LaunchTemplateName", String.to_query f))
         ; Aws.Util.option_map v.launch_template_id (fun f ->
               Aws.Query.Pair ("LaunchTemplateId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.response_error (fun f ->
               "responseError", ResponseError.to_json f)
         ; Aws.Util.option_map v.version_number (fun f -> "versionNumber", Long.to_json f)
         ; Aws.Util.option_map v.launch_template_name (fun f ->
               "launchTemplateName", String.to_json f)
         ; Aws.Util.option_map v.launch_template_id (fun f ->
               "launchTemplateId", String.to_json f)
         ])

  let of_json j =
    { launch_template_id =
        Aws.Util.option_map (Aws.Json.lookup j "launchTemplateId") String.of_json
    ; launch_template_name =
        Aws.Util.option_map (Aws.Json.lookup j "launchTemplateName") String.of_json
    ; version_number =
        Aws.Util.option_map (Aws.Json.lookup j "versionNumber") Long.of_json
    ; response_error =
        Aws.Util.option_map (Aws.Json.lookup j "responseError") ResponseError.of_json
    }
end

module DeleteLaunchTemplateVersionsResponseErrorSet = struct
  type t = DeleteLaunchTemplateVersionsResponseErrorItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         DeleteLaunchTemplateVersionsResponseErrorItem.parse
         (Aws.Xml.members "item" xml))

  let to_query v =
    Aws.Query.to_query_list DeleteLaunchTemplateVersionsResponseErrorItem.to_query v

  let to_json v = `List (List.map DeleteLaunchTemplateVersionsResponseErrorItem.to_json v)

  let of_json j = Aws.Json.to_list DeleteLaunchTemplateVersionsResponseErrorItem.of_json j
end

module DeleteLaunchTemplateVersionsResult = struct
  type t =
    { successfully_deleted_launch_template_versions :
        DeleteLaunchTemplateVersionsResponseSuccessSet.t
    ; unsuccessfully_deleted_launch_template_versions :
        DeleteLaunchTemplateVersionsResponseErrorSet.t
    }

  let make
      ?(successfully_deleted_launch_template_versions = [])
      ?(unsuccessfully_deleted_launch_template_versions = [])
      () =
    { successfully_deleted_launch_template_versions
    ; unsuccessfully_deleted_launch_template_versions
    }

  let parse xml =
    Some
      { successfully_deleted_launch_template_versions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "successfullyDeletedLaunchTemplateVersionSet" xml)
               DeleteLaunchTemplateVersionsResponseSuccessSet.parse)
      ; unsuccessfully_deleted_launch_template_versions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "unsuccessfullyDeletedLaunchTemplateVersionSet" xml)
               DeleteLaunchTemplateVersionsResponseErrorSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "UnsuccessfullyDeletedLaunchTemplateVersionSet"
                , DeleteLaunchTemplateVersionsResponseErrorSet.to_query
                    v.unsuccessfully_deleted_launch_template_versions ))
         ; Some
             (Aws.Query.Pair
                ( "SuccessfullyDeletedLaunchTemplateVersionSet"
                , DeleteLaunchTemplateVersionsResponseSuccessSet.to_query
                    v.successfully_deleted_launch_template_versions ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "unsuccessfullyDeletedLaunchTemplateVersionSet"
             , DeleteLaunchTemplateVersionsResponseErrorSet.to_json
                 v.unsuccessfully_deleted_launch_template_versions )
         ; Some
             ( "successfullyDeletedLaunchTemplateVersionSet"
             , DeleteLaunchTemplateVersionsResponseSuccessSet.to_json
                 v.successfully_deleted_launch_template_versions )
         ])

  let of_json j =
    { successfully_deleted_launch_template_versions =
        DeleteLaunchTemplateVersionsResponseSuccessSet.of_json
          (Aws.Util.of_option_exn
             (Aws.Json.lookup j "successfullyDeletedLaunchTemplateVersionSet"))
    ; unsuccessfully_deleted_launch_template_versions =
        DeleteLaunchTemplateVersionsResponseErrorSet.of_json
          (Aws.Util.of_option_exn
             (Aws.Json.lookup j "unsuccessfullyDeletedLaunchTemplateVersionSet"))
    }
end

module CoipAddressUsage = struct
  type t =
    { allocation_id : String.t option
    ; aws_account_id : String.t option
    ; aws_service : String.t option
    ; co_ip : String.t option
    }

  let make ?allocation_id ?aws_account_id ?aws_service ?co_ip () =
    { allocation_id; aws_account_id; aws_service; co_ip }

  let parse xml =
    Some
      { allocation_id =
          Aws.Util.option_bind (Aws.Xml.member "allocationId" xml) String.parse
      ; aws_account_id =
          Aws.Util.option_bind (Aws.Xml.member "awsAccountId" xml) String.parse
      ; aws_service = Aws.Util.option_bind (Aws.Xml.member "awsService" xml) String.parse
      ; co_ip = Aws.Util.option_bind (Aws.Xml.member "coIp" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.co_ip (fun f ->
               Aws.Query.Pair ("CoIp", String.to_query f))
         ; Aws.Util.option_map v.aws_service (fun f ->
               Aws.Query.Pair ("AwsService", String.to_query f))
         ; Aws.Util.option_map v.aws_account_id (fun f ->
               Aws.Query.Pair ("AwsAccountId", String.to_query f))
         ; Aws.Util.option_map v.allocation_id (fun f ->
               Aws.Query.Pair ("AllocationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.co_ip (fun f -> "coIp", String.to_json f)
         ; Aws.Util.option_map v.aws_service (fun f -> "awsService", String.to_json f)
         ; Aws.Util.option_map v.aws_account_id (fun f ->
               "awsAccountId", String.to_json f)
         ; Aws.Util.option_map v.allocation_id (fun f -> "allocationId", String.to_json f)
         ])

  let of_json j =
    { allocation_id =
        Aws.Util.option_map (Aws.Json.lookup j "allocationId") String.of_json
    ; aws_account_id =
        Aws.Util.option_map (Aws.Json.lookup j "awsAccountId") String.of_json
    ; aws_service = Aws.Util.option_map (Aws.Json.lookup j "awsService") String.of_json
    ; co_ip = Aws.Util.option_map (Aws.Json.lookup j "coIp") String.of_json
    }
end

module GetTransitGatewayMulticastDomainAssociationsRequest = struct
  type t =
    { transit_gateway_multicast_domain_id : String.t option
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make
      ?transit_gateway_multicast_domain_id
      ?(filters = [])
      ?max_results
      ?next_token
      ?dry_run
      () =
    { transit_gateway_multicast_domain_id; filters; max_results; next_token; dry_run }

  let parse xml =
    Some
      { transit_gateway_multicast_domain_id =
          Aws.Util.option_bind
            (Aws.Xml.member "TransitGatewayMulticastDomainId" xml)
            String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               Aws.Query.Pair ("TransitGatewayMulticastDomainId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               "TransitGatewayMulticastDomainId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_multicast_domain_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "TransitGatewayMulticastDomainId")
          String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module UnassignIpv6AddressesRequest = struct
  type t =
    { ipv6_addresses : Ipv6AddressList.t
    ; network_interface_id : String.t
    }

  let make ~ipv6_addresses ~network_interface_id () =
    { ipv6_addresses; network_interface_id }

  let parse xml =
    Some
      { ipv6_addresses =
          Aws.Xml.required
            "ipv6Addresses"
            (Aws.Util.option_bind
               (Aws.Xml.member "ipv6Addresses" xml)
               Ipv6AddressList.parse)
      ; network_interface_id =
          Aws.Xml.required
            "networkInterfaceId"
            (Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("NetworkInterfaceId", String.to_query v.network_interface_id))
         ; Some
             (Aws.Query.Pair ("Ipv6Addresses", Ipv6AddressList.to_query v.ipv6_addresses))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("networkInterfaceId", String.to_json v.network_interface_id)
         ; Some ("ipv6Addresses", Ipv6AddressList.to_json v.ipv6_addresses)
         ])

  let of_json j =
    { ipv6_addresses =
        Ipv6AddressList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ipv6Addresses"))
    ; network_interface_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "networkInterfaceId"))
    }
end

module DeleteLaunchTemplateRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; launch_template_id : String.t option
    ; launch_template_name : String.t option
    }

  let make ?dry_run ?launch_template_id ?launch_template_name () =
    { dry_run; launch_template_id; launch_template_name }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; launch_template_id =
          Aws.Util.option_bind (Aws.Xml.member "LaunchTemplateId" xml) String.parse
      ; launch_template_name =
          Aws.Util.option_bind (Aws.Xml.member "LaunchTemplateName" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.launch_template_name (fun f ->
               Aws.Query.Pair ("LaunchTemplateName", String.to_query f))
         ; Aws.Util.option_map v.launch_template_id (fun f ->
               Aws.Query.Pair ("LaunchTemplateId", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.launch_template_name (fun f ->
               "LaunchTemplateName", String.to_json f)
         ; Aws.Util.option_map v.launch_template_id (fun f ->
               "LaunchTemplateId", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; launch_template_id =
        Aws.Util.option_map (Aws.Json.lookup j "LaunchTemplateId") String.of_json
    ; launch_template_name =
        Aws.Util.option_map (Aws.Json.lookup j "LaunchTemplateName") String.of_json
    }
end

module EndDateType = struct
  type t =
    | Unlimited
    | Limited

  let str_to_t = [ "limited", Limited; "unlimited", Unlimited ]

  let t_to_str = [ Limited, "limited"; Unlimited, "unlimited" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module CapacityReservation = struct
  type t =
    { capacity_reservation_id : String.t option
    ; owner_id : String.t option
    ; capacity_reservation_arn : String.t option
    ; availability_zone_id : String.t option
    ; instance_type : String.t option
    ; instance_platform : CapacityReservationInstancePlatform.t option
    ; availability_zone : String.t option
    ; tenancy : CapacityReservationTenancy.t option
    ; total_instance_count : Integer.t option
    ; available_instance_count : Integer.t option
    ; ebs_optimized : Boolean.t option
    ; ephemeral_storage : Boolean.t option
    ; state : CapacityReservationState.t option
    ; end_date : DateTime.t option
    ; end_date_type : EndDateType.t option
    ; instance_match_criteria : InstanceMatchCriteria.t option
    ; create_date : DateTime.t option
    ; tags : TagList.t
    }

  let make
      ?capacity_reservation_id
      ?owner_id
      ?capacity_reservation_arn
      ?availability_zone_id
      ?instance_type
      ?instance_platform
      ?availability_zone
      ?tenancy
      ?total_instance_count
      ?available_instance_count
      ?ebs_optimized
      ?ephemeral_storage
      ?state
      ?end_date
      ?end_date_type
      ?instance_match_criteria
      ?create_date
      ?(tags = [])
      () =
    { capacity_reservation_id
    ; owner_id
    ; capacity_reservation_arn
    ; availability_zone_id
    ; instance_type
    ; instance_platform
    ; availability_zone
    ; tenancy
    ; total_instance_count
    ; available_instance_count
    ; ebs_optimized
    ; ephemeral_storage
    ; state
    ; end_date
    ; end_date_type
    ; instance_match_criteria
    ; create_date
    ; tags
    }

  let parse xml =
    Some
      { capacity_reservation_id =
          Aws.Util.option_bind (Aws.Xml.member "capacityReservationId" xml) String.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; capacity_reservation_arn =
          Aws.Util.option_bind (Aws.Xml.member "capacityReservationArn" xml) String.parse
      ; availability_zone_id =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZoneId" xml) String.parse
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) String.parse
      ; instance_platform =
          Aws.Util.option_bind
            (Aws.Xml.member "instancePlatform" xml)
            CapacityReservationInstancePlatform.parse
      ; availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; tenancy =
          Aws.Util.option_bind
            (Aws.Xml.member "tenancy" xml)
            CapacityReservationTenancy.parse
      ; total_instance_count =
          Aws.Util.option_bind (Aws.Xml.member "totalInstanceCount" xml) Integer.parse
      ; available_instance_count =
          Aws.Util.option_bind (Aws.Xml.member "availableInstanceCount" xml) Integer.parse
      ; ebs_optimized =
          Aws.Util.option_bind (Aws.Xml.member "ebsOptimized" xml) Boolean.parse
      ; ephemeral_storage =
          Aws.Util.option_bind (Aws.Xml.member "ephemeralStorage" xml) Boolean.parse
      ; state =
          Aws.Util.option_bind (Aws.Xml.member "state" xml) CapacityReservationState.parse
      ; end_date = Aws.Util.option_bind (Aws.Xml.member "endDate" xml) DateTime.parse
      ; end_date_type =
          Aws.Util.option_bind (Aws.Xml.member "endDateType" xml) EndDateType.parse
      ; instance_match_criteria =
          Aws.Util.option_bind
            (Aws.Xml.member "instanceMatchCriteria" xml)
            InstanceMatchCriteria.parse
      ; create_date =
          Aws.Util.option_bind (Aws.Xml.member "createDate" xml) DateTime.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.create_date (fun f ->
               Aws.Query.Pair ("CreateDate", DateTime.to_query f))
         ; Aws.Util.option_map v.instance_match_criteria (fun f ->
               Aws.Query.Pair ("InstanceMatchCriteria", InstanceMatchCriteria.to_query f))
         ; Aws.Util.option_map v.end_date_type (fun f ->
               Aws.Query.Pair ("EndDateType", EndDateType.to_query f))
         ; Aws.Util.option_map v.end_date (fun f ->
               Aws.Query.Pair ("EndDate", DateTime.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", CapacityReservationState.to_query f))
         ; Aws.Util.option_map v.ephemeral_storage (fun f ->
               Aws.Query.Pair ("EphemeralStorage", Boolean.to_query f))
         ; Aws.Util.option_map v.ebs_optimized (fun f ->
               Aws.Query.Pair ("EbsOptimized", Boolean.to_query f))
         ; Aws.Util.option_map v.available_instance_count (fun f ->
               Aws.Query.Pair ("AvailableInstanceCount", Integer.to_query f))
         ; Aws.Util.option_map v.total_instance_count (fun f ->
               Aws.Query.Pair ("TotalInstanceCount", Integer.to_query f))
         ; Aws.Util.option_map v.tenancy (fun f ->
               Aws.Query.Pair ("Tenancy", CapacityReservationTenancy.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ; Aws.Util.option_map v.instance_platform (fun f ->
               Aws.Query.Pair
                 ("InstancePlatform", CapacityReservationInstancePlatform.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", String.to_query f))
         ; Aws.Util.option_map v.availability_zone_id (fun f ->
               Aws.Query.Pair ("AvailabilityZoneId", String.to_query f))
         ; Aws.Util.option_map v.capacity_reservation_arn (fun f ->
               Aws.Query.Pair ("CapacityReservationArn", String.to_query f))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.capacity_reservation_id (fun f ->
               Aws.Query.Pair ("CapacityReservationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.create_date (fun f -> "createDate", DateTime.to_json f)
         ; Aws.Util.option_map v.instance_match_criteria (fun f ->
               "instanceMatchCriteria", InstanceMatchCriteria.to_json f)
         ; Aws.Util.option_map v.end_date_type (fun f ->
               "endDateType", EndDateType.to_json f)
         ; Aws.Util.option_map v.end_date (fun f -> "endDate", DateTime.to_json f)
         ; Aws.Util.option_map v.state (fun f ->
               "state", CapacityReservationState.to_json f)
         ; Aws.Util.option_map v.ephemeral_storage (fun f ->
               "ephemeralStorage", Boolean.to_json f)
         ; Aws.Util.option_map v.ebs_optimized (fun f ->
               "ebsOptimized", Boolean.to_json f)
         ; Aws.Util.option_map v.available_instance_count (fun f ->
               "availableInstanceCount", Integer.to_json f)
         ; Aws.Util.option_map v.total_instance_count (fun f ->
               "totalInstanceCount", Integer.to_json f)
         ; Aws.Util.option_map v.tenancy (fun f ->
               "tenancy", CapacityReservationTenancy.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ; Aws.Util.option_map v.instance_platform (fun f ->
               "instancePlatform", CapacityReservationInstancePlatform.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f -> "instanceType", String.to_json f)
         ; Aws.Util.option_map v.availability_zone_id (fun f ->
               "availabilityZoneId", String.to_json f)
         ; Aws.Util.option_map v.capacity_reservation_arn (fun f ->
               "capacityReservationArn", String.to_json f)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.capacity_reservation_id (fun f ->
               "capacityReservationId", String.to_json f)
         ])

  let of_json j =
    { capacity_reservation_id =
        Aws.Util.option_map (Aws.Json.lookup j "capacityReservationId") String.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; capacity_reservation_arn =
        Aws.Util.option_map (Aws.Json.lookup j "capacityReservationArn") String.of_json
    ; availability_zone_id =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZoneId") String.of_json
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") String.of_json
    ; instance_platform =
        Aws.Util.option_map
          (Aws.Json.lookup j "instancePlatform")
          CapacityReservationInstancePlatform.of_json
    ; availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; tenancy =
        Aws.Util.option_map
          (Aws.Json.lookup j "tenancy")
          CapacityReservationTenancy.of_json
    ; total_instance_count =
        Aws.Util.option_map (Aws.Json.lookup j "totalInstanceCount") Integer.of_json
    ; available_instance_count =
        Aws.Util.option_map (Aws.Json.lookup j "availableInstanceCount") Integer.of_json
    ; ebs_optimized =
        Aws.Util.option_map (Aws.Json.lookup j "ebsOptimized") Boolean.of_json
    ; ephemeral_storage =
        Aws.Util.option_map (Aws.Json.lookup j "ephemeralStorage") Boolean.of_json
    ; state =
        Aws.Util.option_map (Aws.Json.lookup j "state") CapacityReservationState.of_json
    ; end_date = Aws.Util.option_map (Aws.Json.lookup j "endDate") DateTime.of_json
    ; end_date_type =
        Aws.Util.option_map (Aws.Json.lookup j "endDateType") EndDateType.of_json
    ; instance_match_criteria =
        Aws.Util.option_map
          (Aws.Json.lookup j "instanceMatchCriteria")
          InstanceMatchCriteria.of_json
    ; create_date = Aws.Util.option_map (Aws.Json.lookup j "createDate") DateTime.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module CapacityReservationSet = struct
  type t = CapacityReservation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map CapacityReservation.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list CapacityReservation.to_query v

  let to_json v = `List (List.map CapacityReservation.to_json v)

  let of_json j = Aws.Json.to_list CapacityReservation.of_json j
end

module ResetFpgaImageAttributeResult = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module CreateCarrierGatewayRequest = struct
  type t =
    { vpc_id : String.t
    ; tag_specifications : TagSpecificationList.t
    ; dry_run : Boolean.t option
    ; client_token : String.t option
    }

  let make ~vpc_id ?(tag_specifications = []) ?dry_run ?client_token () =
    { vpc_id; tag_specifications; dry_run; client_token }

  let parse xml =
    Some
      { vpc_id =
          Aws.Xml.required
            "VpcId"
            (Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) String.parse)
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Some ("VpcId", String.to_json v.vpc_id)
         ])

  let of_json j =
    { vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcId"))
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    }
end

module PlacementGroupStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DeleteFpgaImageResult = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module Ipv6PoolSet = struct
  type t = Ipv6Pool.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Ipv6Pool.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Ipv6Pool.to_query v

  let to_json v = `List (List.map Ipv6Pool.to_json v)

  let of_json j = Aws.Json.to_list Ipv6Pool.of_json j
end

module DescribeIpv6PoolsResult = struct
  type t =
    { ipv6_pools : Ipv6PoolSet.t
    ; next_token : String.t option
    }

  let make ?(ipv6_pools = []) ?next_token () = { ipv6_pools; next_token }

  let parse xml =
    Some
      { ipv6_pools =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "ipv6PoolSet" xml) Ipv6PoolSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("Ipv6PoolSet", Ipv6PoolSet.to_query v.ipv6_pools))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("ipv6PoolSet", Ipv6PoolSet.to_json v.ipv6_pools)
         ])

  let of_json j =
    { ipv6_pools =
        Ipv6PoolSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ipv6PoolSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module CreateTransitGatewayRouteTableResult = struct
  type t = { transit_gateway_route_table : TransitGatewayRouteTable.t option }

  let make ?transit_gateway_route_table () = { transit_gateway_route_table }

  let parse xml =
    Some
      { transit_gateway_route_table =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayRouteTable" xml)
            TransitGatewayRouteTable.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_route_table (fun f ->
               Aws.Query.Pair
                 ("TransitGatewayRouteTable", TransitGatewayRouteTable.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_route_table (fun f ->
               "transitGatewayRouteTable", TransitGatewayRouteTable.to_json f)
         ])

  let of_json j =
    { transit_gateway_route_table =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayRouteTable")
          TransitGatewayRouteTable.of_json
    }
end

module AdvertiseByoipCidrResult = struct
  type t = { byoip_cidr : ByoipCidr.t option }

  let make ?byoip_cidr () = { byoip_cidr }

  let parse xml =
    Some
      { byoip_cidr = Aws.Util.option_bind (Aws.Xml.member "byoipCidr" xml) ByoipCidr.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.byoip_cidr (fun f ->
               Aws.Query.Pair ("ByoipCidr", ByoipCidr.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.byoip_cidr (fun f -> "byoipCidr", ByoipCidr.to_json f) ])

  let of_json j =
    { byoip_cidr = Aws.Util.option_map (Aws.Json.lookup j "byoipCidr") ByoipCidr.of_json }
end

module DisassociateRouteTableRequest = struct
  type t =
    { association_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~association_id ?dry_run () = { association_id; dry_run }

  let parse xml =
    Some
      { association_id =
          Aws.Xml.required
            "associationId"
            (Aws.Util.option_bind (Aws.Xml.member "associationId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("AssociationId", String.to_query v.association_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("associationId", String.to_json v.association_id)
         ])

  let of_json j =
    { association_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "associationId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module DisassociateEnclaveCertificateIamRoleResult = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module PrincipalType = struct
  type t =
    | All
    | Service
    | OrganizationUnit
    | Account
    | User
    | Role

  let str_to_t =
    [ "Role", Role
    ; "User", User
    ; "Account", Account
    ; "OrganizationUnit", OrganizationUnit
    ; "Service", Service
    ; "All", All
    ]

  let t_to_str =
    [ Role, "Role"
    ; User, "User"
    ; Account, "Account"
    ; OrganizationUnit, "OrganizationUnit"
    ; Service, "Service"
    ; All, "All"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module AllowedPrincipal = struct
  type t =
    { principal_type : PrincipalType.t option
    ; principal : String.t option
    }

  let make ?principal_type ?principal () = { principal_type; principal }

  let parse xml =
    Some
      { principal_type =
          Aws.Util.option_bind (Aws.Xml.member "principalType" xml) PrincipalType.parse
      ; principal = Aws.Util.option_bind (Aws.Xml.member "principal" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.principal (fun f ->
               Aws.Query.Pair ("Principal", String.to_query f))
         ; Aws.Util.option_map v.principal_type (fun f ->
               Aws.Query.Pair ("PrincipalType", PrincipalType.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.principal (fun f -> "principal", String.to_json f)
         ; Aws.Util.option_map v.principal_type (fun f ->
               "principalType", PrincipalType.to_json f)
         ])

  let of_json j =
    { principal_type =
        Aws.Util.option_map (Aws.Json.lookup j "principalType") PrincipalType.of_json
    ; principal = Aws.Util.option_map (Aws.Json.lookup j "principal") String.of_json
    }
end

module AllowedPrincipalSet = struct
  type t = AllowedPrincipal.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map AllowedPrincipal.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list AllowedPrincipal.to_query v

  let to_json v = `List (List.map AllowedPrincipal.to_json v)

  let of_json j = Aws.Json.to_list AllowedPrincipal.of_json j
end

module DeleteClientVpnEndpointResult = struct
  type t = { status : ClientVpnEndpointStatus.t option }

  let make ?status () = { status }

  let parse xml =
    Some
      { status =
          Aws.Util.option_bind (Aws.Xml.member "status" xml) ClientVpnEndpointStatus.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", ClientVpnEndpointStatus.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               "status", ClientVpnEndpointStatus.to_json f)
         ])

  let of_json j =
    { status =
        Aws.Util.option_map (Aws.Json.lookup j "status") ClientVpnEndpointStatus.of_json
    }
end

module NetworkAclList = struct
  type t = NetworkAcl.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map NetworkAcl.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list NetworkAcl.to_query v

  let to_json v = `List (List.map NetworkAcl.to_json v)

  let of_json j = Aws.Json.to_list NetworkAcl.of_json j
end

module LocalGatewayIdSet = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module Snapshot = struct
  type t =
    { data_encryption_key_id : String.t option
    ; description : String.t
    ; encrypted : Boolean.t
    ; kms_key_id : String.t option
    ; owner_id : String.t
    ; progress : String.t
    ; snapshot_id : String.t
    ; start_time : DateTime.t
    ; state : SnapshotState.t
    ; state_message : String.t option
    ; volume_id : String.t
    ; volume_size : Integer.t
    ; owner_alias : String.t option
    ; tags : TagList.t
    }

  let make
      ?data_encryption_key_id
      ~description
      ~encrypted
      ?kms_key_id
      ~owner_id
      ~progress
      ~snapshot_id
      ~start_time
      ~state
      ?state_message
      ~volume_id
      ~volume_size
      ?owner_alias
      ?(tags = [])
      () =
    { data_encryption_key_id
    ; description
    ; encrypted
    ; kms_key_id
    ; owner_id
    ; progress
    ; snapshot_id
    ; start_time
    ; state
    ; state_message
    ; volume_id
    ; volume_size
    ; owner_alias
    ; tags
    }

  let parse xml =
    Some
      { data_encryption_key_id =
          Aws.Util.option_bind (Aws.Xml.member "dataEncryptionKeyId" xml) String.parse
      ; description =
          Aws.Xml.required
            "description"
            (Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse)
      ; encrypted =
          Aws.Xml.required
            "encrypted"
            (Aws.Util.option_bind (Aws.Xml.member "encrypted" xml) Boolean.parse)
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "kmsKeyId" xml) String.parse
      ; owner_id =
          Aws.Xml.required
            "ownerId"
            (Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse)
      ; progress =
          Aws.Xml.required
            "progress"
            (Aws.Util.option_bind (Aws.Xml.member "progress" xml) String.parse)
      ; snapshot_id =
          Aws.Xml.required
            "snapshotId"
            (Aws.Util.option_bind (Aws.Xml.member "snapshotId" xml) String.parse)
      ; start_time =
          Aws.Xml.required
            "startTime"
            (Aws.Util.option_bind (Aws.Xml.member "startTime" xml) DateTime.parse)
      ; state =
          Aws.Xml.required
            "status"
            (Aws.Util.option_bind (Aws.Xml.member "status" xml) SnapshotState.parse)
      ; state_message =
          Aws.Util.option_bind (Aws.Xml.member "statusMessage" xml) String.parse
      ; volume_id =
          Aws.Xml.required
            "volumeId"
            (Aws.Util.option_bind (Aws.Xml.member "volumeId" xml) String.parse)
      ; volume_size =
          Aws.Xml.required
            "volumeSize"
            (Aws.Util.option_bind (Aws.Xml.member "volumeSize" xml) Integer.parse)
      ; owner_alias = Aws.Util.option_bind (Aws.Xml.member "ownerAlias" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.owner_alias (fun f ->
               Aws.Query.Pair ("OwnerAlias", String.to_query f))
         ; Some (Aws.Query.Pair ("VolumeSize", Integer.to_query v.volume_size))
         ; Some (Aws.Query.Pair ("VolumeId", String.to_query v.volume_id))
         ; Aws.Util.option_map v.state_message (fun f ->
               Aws.Query.Pair ("StatusMessage", String.to_query f))
         ; Some (Aws.Query.Pair ("Status", SnapshotState.to_query v.state))
         ; Some (Aws.Query.Pair ("StartTime", DateTime.to_query v.start_time))
         ; Some (Aws.Query.Pair ("SnapshotId", String.to_query v.snapshot_id))
         ; Some (Aws.Query.Pair ("Progress", String.to_query v.progress))
         ; Some (Aws.Query.Pair ("OwnerId", String.to_query v.owner_id))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Some (Aws.Query.Pair ("Encrypted", Boolean.to_query v.encrypted))
         ; Some (Aws.Query.Pair ("Description", String.to_query v.description))
         ; Aws.Util.option_map v.data_encryption_key_id (fun f ->
               Aws.Query.Pair ("DataEncryptionKeyId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.owner_alias (fun f -> "ownerAlias", String.to_json f)
         ; Some ("volumeSize", Integer.to_json v.volume_size)
         ; Some ("volumeId", String.to_json v.volume_id)
         ; Aws.Util.option_map v.state_message (fun f ->
               "statusMessage", String.to_json f)
         ; Some ("status", SnapshotState.to_json v.state)
         ; Some ("startTime", DateTime.to_json v.start_time)
         ; Some ("snapshotId", String.to_json v.snapshot_id)
         ; Some ("progress", String.to_json v.progress)
         ; Some ("ownerId", String.to_json v.owner_id)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "kmsKeyId", String.to_json f)
         ; Some ("encrypted", Boolean.to_json v.encrypted)
         ; Some ("description", String.to_json v.description)
         ; Aws.Util.option_map v.data_encryption_key_id (fun f ->
               "dataEncryptionKeyId", String.to_json f)
         ])

  let of_json j =
    { data_encryption_key_id =
        Aws.Util.option_map (Aws.Json.lookup j "dataEncryptionKeyId") String.of_json
    ; description =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "description"))
    ; encrypted = Boolean.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "encrypted"))
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "kmsKeyId") String.of_json
    ; owner_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ownerId"))
    ; progress = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "progress"))
    ; snapshot_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "snapshotId"))
    ; start_time =
        DateTime.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "startTime"))
    ; state = SnapshotState.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "status"))
    ; state_message =
        Aws.Util.option_map (Aws.Json.lookup j "statusMessage") String.of_json
    ; volume_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "volumeId"))
    ; volume_size =
        Integer.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "volumeSize"))
    ; owner_alias = Aws.Util.option_map (Aws.Json.lookup j "ownerAlias") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module EnableVpcClassicLinkRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; vpc_id : String.t
    }

  let make ?dry_run ~vpc_id () = { dry_run; vpc_id }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; vpc_id =
          Aws.Xml.required
            "vpcId"
            (Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("vpcId", String.to_json v.vpc_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "vpcId"))
    }
end

module CustomerGatewayIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "CustomerGatewayId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module PublicIpv4PoolIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribePublicIpv4PoolsRequest = struct
  type t =
    { pool_ids : PublicIpv4PoolIdStringList.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    ; filters : FilterList.t
    }

  let make ?(pool_ids = []) ?next_token ?max_results ?(filters = []) () =
    { pool_ids; next_token; max_results; filters }

  let parse xml =
    Some
      { pool_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "PoolId" xml)
               PublicIpv4PoolIdStringList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair ("PoolId", PublicIpv4PoolIdStringList.to_query v.pool_ids))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Filter", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("PoolId", PublicIpv4PoolIdStringList.to_json v.pool_ids)
         ])

  let of_json j =
    { pool_ids =
        PublicIpv4PoolIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "PoolId"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    }
end

module CreateVolumeRequest = struct
  type t =
    { availability_zone : String.t
    ; encrypted : Boolean.t option
    ; iops : Integer.t option
    ; kms_key_id : String.t option
    ; outpost_arn : String.t option
    ; size : Integer.t option
    ; snapshot_id : String.t option
    ; volume_type : VolumeType.t option
    ; dry_run : Boolean.t option
    ; tag_specifications : TagSpecificationList.t
    ; multi_attach_enabled : Boolean.t option
    }

  let make
      ~availability_zone
      ?encrypted
      ?iops
      ?kms_key_id
      ?outpost_arn
      ?size
      ?snapshot_id
      ?volume_type
      ?dry_run
      ?(tag_specifications = [])
      ?multi_attach_enabled
      () =
    { availability_zone
    ; encrypted
    ; iops
    ; kms_key_id
    ; outpost_arn
    ; size
    ; snapshot_id
    ; volume_type
    ; dry_run
    ; tag_specifications
    ; multi_attach_enabled
    }

  let parse xml =
    Some
      { availability_zone =
          Aws.Xml.required
            "AvailabilityZone"
            (Aws.Util.option_bind (Aws.Xml.member "AvailabilityZone" xml) String.parse)
      ; encrypted = Aws.Util.option_bind (Aws.Xml.member "encrypted" xml) Boolean.parse
      ; iops = Aws.Util.option_bind (Aws.Xml.member "Iops" xml) Integer.parse
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "KmsKeyId" xml) String.parse
      ; outpost_arn = Aws.Util.option_bind (Aws.Xml.member "OutpostArn" xml) String.parse
      ; size = Aws.Util.option_bind (Aws.Xml.member "Size" xml) Integer.parse
      ; snapshot_id = Aws.Util.option_bind (Aws.Xml.member "SnapshotId" xml) String.parse
      ; volume_type =
          Aws.Util.option_bind (Aws.Xml.member "VolumeType" xml) VolumeType.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      ; multi_attach_enabled =
          Aws.Util.option_bind (Aws.Xml.member "MultiAttachEnabled" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.multi_attach_enabled (fun f ->
               Aws.Query.Pair ("MultiAttachEnabled", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.volume_type (fun f ->
               Aws.Query.Pair ("VolumeType", VolumeType.to_query f))
         ; Aws.Util.option_map v.snapshot_id (fun f ->
               Aws.Query.Pair ("SnapshotId", String.to_query f))
         ; Aws.Util.option_map v.size (fun f ->
               Aws.Query.Pair ("Size", Integer.to_query f))
         ; Aws.Util.option_map v.outpost_arn (fun f ->
               Aws.Query.Pair ("OutpostArn", String.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Aws.Util.option_map v.iops (fun f ->
               Aws.Query.Pair ("Iops", Integer.to_query f))
         ; Aws.Util.option_map v.encrypted (fun f ->
               Aws.Query.Pair ("Encrypted", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("AvailabilityZone", String.to_query v.availability_zone))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.multi_attach_enabled (fun f ->
               "MultiAttachEnabled", Boolean.to_json f)
         ; Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.volume_type (fun f -> "VolumeType", VolumeType.to_json f)
         ; Aws.Util.option_map v.snapshot_id (fun f -> "SnapshotId", String.to_json f)
         ; Aws.Util.option_map v.size (fun f -> "Size", Integer.to_json f)
         ; Aws.Util.option_map v.outpost_arn (fun f -> "OutpostArn", String.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "KmsKeyId", String.to_json f)
         ; Aws.Util.option_map v.iops (fun f -> "Iops", Integer.to_json f)
         ; Aws.Util.option_map v.encrypted (fun f -> "encrypted", Boolean.to_json f)
         ; Some ("AvailabilityZone", String.to_json v.availability_zone)
         ])

  let of_json j =
    { availability_zone =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "AvailabilityZone"))
    ; encrypted = Aws.Util.option_map (Aws.Json.lookup j "encrypted") Boolean.of_json
    ; iops = Aws.Util.option_map (Aws.Json.lookup j "Iops") Integer.of_json
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "KmsKeyId") String.of_json
    ; outpost_arn = Aws.Util.option_map (Aws.Json.lookup j "OutpostArn") String.of_json
    ; size = Aws.Util.option_map (Aws.Json.lookup j "Size") Integer.of_json
    ; snapshot_id = Aws.Util.option_map (Aws.Json.lookup j "SnapshotId") String.of_json
    ; volume_type =
        Aws.Util.option_map (Aws.Json.lookup j "VolumeType") VolumeType.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    ; multi_attach_enabled =
        Aws.Util.option_map (Aws.Json.lookup j "MultiAttachEnabled") Boolean.of_json
    }
end

module BlockDeviceMappingRequestList = struct
  type t = BlockDeviceMapping.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map BlockDeviceMapping.parse (Aws.Xml.members "BlockDeviceMapping" xml))

  let to_query v = Aws.Query.to_query_list BlockDeviceMapping.to_query v

  let to_json v = `List (List.map BlockDeviceMapping.to_json v)

  let of_json j = Aws.Json.to_list BlockDeviceMapping.of_json j
end

module NetworkInterfaceAttachmentChanges = struct
  type t =
    { attachment_id : String.t option
    ; delete_on_termination : Boolean.t option
    }

  let make ?attachment_id ?delete_on_termination () =
    { attachment_id; delete_on_termination }

  let parse xml =
    Some
      { attachment_id =
          Aws.Util.option_bind (Aws.Xml.member "attachmentId" xml) String.parse
      ; delete_on_termination =
          Aws.Util.option_bind (Aws.Xml.member "deleteOnTermination" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.delete_on_termination (fun f ->
               Aws.Query.Pair ("DeleteOnTermination", Boolean.to_query f))
         ; Aws.Util.option_map v.attachment_id (fun f ->
               Aws.Query.Pair ("AttachmentId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.delete_on_termination (fun f ->
               "deleteOnTermination", Boolean.to_json f)
         ; Aws.Util.option_map v.attachment_id (fun f -> "attachmentId", String.to_json f)
         ])

  let of_json j =
    { attachment_id =
        Aws.Util.option_map (Aws.Json.lookup j "attachmentId") String.of_json
    ; delete_on_termination =
        Aws.Util.option_map (Aws.Json.lookup j "deleteOnTermination") Boolean.of_json
    }
end

module ModifyNetworkInterfaceAttributeRequest = struct
  type t =
    { attachment : NetworkInterfaceAttachmentChanges.t option
    ; description : AttributeValue.t option
    ; dry_run : Boolean.t option
    ; groups : SecurityGroupIdStringList.t
    ; network_interface_id : String.t
    ; source_dest_check : AttributeBooleanValue.t option
    }

  let make
      ?attachment
      ?description
      ?dry_run
      ?(groups = [])
      ~network_interface_id
      ?source_dest_check
      () =
    { attachment; description; dry_run; groups; network_interface_id; source_dest_check }

  let parse xml =
    Some
      { attachment =
          Aws.Util.option_bind
            (Aws.Xml.member "attachment" xml)
            NetworkInterfaceAttachmentChanges.parse
      ; description =
          Aws.Util.option_bind (Aws.Xml.member "description" xml) AttributeValue.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SecurityGroupId" xml)
               SecurityGroupIdStringList.parse)
      ; network_interface_id =
          Aws.Xml.required
            "networkInterfaceId"
            (Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse)
      ; source_dest_check =
          Aws.Util.option_bind
            (Aws.Xml.member "sourceDestCheck" xml)
            AttributeBooleanValue.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.source_dest_check (fun f ->
               Aws.Query.Pair ("SourceDestCheck", AttributeBooleanValue.to_query f))
         ; Some
             (Aws.Query.Pair ("NetworkInterfaceId", String.to_query v.network_interface_id))
         ; Some
             (Aws.Query.Pair
                ("SecurityGroupId", SecurityGroupIdStringList.to_query v.groups))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", AttributeValue.to_query f))
         ; Aws.Util.option_map v.attachment (fun f ->
               Aws.Query.Pair ("Attachment", NetworkInterfaceAttachmentChanges.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.source_dest_check (fun f ->
               "sourceDestCheck", AttributeBooleanValue.to_json f)
         ; Some ("networkInterfaceId", String.to_json v.network_interface_id)
         ; Some ("SecurityGroupId", SecurityGroupIdStringList.to_json v.groups)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.description (fun f ->
               "description", AttributeValue.to_json f)
         ; Aws.Util.option_map v.attachment (fun f ->
               "attachment", NetworkInterfaceAttachmentChanges.to_json f)
         ])

  let of_json j =
    { attachment =
        Aws.Util.option_map
          (Aws.Json.lookup j "attachment")
          NetworkInterfaceAttachmentChanges.of_json
    ; description =
        Aws.Util.option_map (Aws.Json.lookup j "description") AttributeValue.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; groups =
        SecurityGroupIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SecurityGroupId"))
    ; network_interface_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "networkInterfaceId"))
    ; source_dest_check =
        Aws.Util.option_map
          (Aws.Json.lookup j "sourceDestCheck")
          AttributeBooleanValue.of_json
    }
end

module ModifyCapacityReservationResult = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module DescribeTransitGatewayVpcAttachmentsRequest = struct
  type t =
    { transit_gateway_attachment_ids : TransitGatewayAttachmentIdStringList.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make
      ?(transit_gateway_attachment_ids = [])
      ?(filters = [])
      ?max_results
      ?next_token
      ?dry_run
      () =
    { transit_gateway_attachment_ids; filters; max_results; next_token; dry_run }

  let parse xml =
    Some
      { transit_gateway_attachment_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayAttachmentIds" xml)
               TransitGatewayAttachmentIdStringList.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayAttachmentIds"
                , TransitGatewayAttachmentIdStringList.to_query
                    v.transit_gateway_attachment_ids ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some
             ( "TransitGatewayAttachmentIds"
             , TransitGatewayAttachmentIdStringList.to_json
                 v.transit_gateway_attachment_ids )
         ])

  let of_json j =
    { transit_gateway_attachment_ids =
        TransitGatewayAttachmentIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayAttachmentIds"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DeleteTrafficMirrorSessionRequest = struct
  type t =
    { traffic_mirror_session_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~traffic_mirror_session_id ?dry_run () = { traffic_mirror_session_id; dry_run }

  let parse xml =
    Some
      { traffic_mirror_session_id =
          Aws.Xml.required
            "TrafficMirrorSessionId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TrafficMirrorSessionId" xml)
               String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TrafficMirrorSessionId", String.to_query v.traffic_mirror_session_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("TrafficMirrorSessionId", String.to_json v.traffic_mirror_session_id)
         ])

  let of_json j =
    { traffic_mirror_session_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TrafficMirrorSessionId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module ImportSnapshotTaskIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "ImportTaskId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module BlobAttributeValue = struct
  type t = { value : Blob.t option }

  let make ?value () = { value }

  let parse xml =
    Some { value = Aws.Util.option_bind (Aws.Xml.member "value" xml) Blob.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", Blob.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f -> "value", Blob.to_json f) ])

  let of_json j = { value = Aws.Util.option_map (Aws.Json.lookup j "value") Blob.of_json }
end

module ClientVpnEndpointIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeClientVpnEndpointsRequest = struct
  type t =
    { client_vpn_endpoint_ids : ClientVpnEndpointIdList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; filters : FilterList.t
    ; dry_run : Boolean.t option
    }

  let make
      ?(client_vpn_endpoint_ids = [])
      ?max_results
      ?next_token
      ?(filters = [])
      ?dry_run
      () =
    { client_vpn_endpoint_ids; max_results; next_token; filters; dry_run }

  let parse xml =
    Some
      { client_vpn_endpoint_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ClientVpnEndpointId" xml)
               ClientVpnEndpointIdList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ClientVpnEndpointId"
                , ClientVpnEndpointIdList.to_query v.client_vpn_endpoint_ids ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some
             ( "ClientVpnEndpointId"
             , ClientVpnEndpointIdList.to_json v.client_vpn_endpoint_ids )
         ])

  let of_json j =
    { client_vpn_endpoint_ids =
        ClientVpnEndpointIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ClientVpnEndpointId"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module RevokeClientVpnIngressRequest = struct
  type t =
    { client_vpn_endpoint_id : String.t
    ; target_network_cidr : String.t
    ; access_group_id : String.t option
    ; revoke_all_groups : Boolean.t option
    ; dry_run : Boolean.t option
    }

  let make
      ~client_vpn_endpoint_id
      ~target_network_cidr
      ?access_group_id
      ?revoke_all_groups
      ?dry_run
      () =
    { client_vpn_endpoint_id
    ; target_network_cidr
    ; access_group_id
    ; revoke_all_groups
    ; dry_run
    }

  let parse xml =
    Some
      { client_vpn_endpoint_id =
          Aws.Xml.required
            "ClientVpnEndpointId"
            (Aws.Util.option_bind (Aws.Xml.member "ClientVpnEndpointId" xml) String.parse)
      ; target_network_cidr =
          Aws.Xml.required
            "TargetNetworkCidr"
            (Aws.Util.option_bind (Aws.Xml.member "TargetNetworkCidr" xml) String.parse)
      ; access_group_id =
          Aws.Util.option_bind (Aws.Xml.member "AccessGroupId" xml) String.parse
      ; revoke_all_groups =
          Aws.Util.option_bind (Aws.Xml.member "RevokeAllGroups" xml) Boolean.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.revoke_all_groups (fun f ->
               Aws.Query.Pair ("RevokeAllGroups", Boolean.to_query f))
         ; Aws.Util.option_map v.access_group_id (fun f ->
               Aws.Query.Pair ("AccessGroupId", String.to_query f))
         ; Some
             (Aws.Query.Pair ("TargetNetworkCidr", String.to_query v.target_network_cidr))
         ; Some
             (Aws.Query.Pair
                ("ClientVpnEndpointId", String.to_query v.client_vpn_endpoint_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.revoke_all_groups (fun f ->
               "RevokeAllGroups", Boolean.to_json f)
         ; Aws.Util.option_map v.access_group_id (fun f ->
               "AccessGroupId", String.to_json f)
         ; Some ("TargetNetworkCidr", String.to_json v.target_network_cidr)
         ; Some ("ClientVpnEndpointId", String.to_json v.client_vpn_endpoint_id)
         ])

  let of_json j =
    { client_vpn_endpoint_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ClientVpnEndpointId"))
    ; target_network_cidr =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TargetNetworkCidr"))
    ; access_group_id =
        Aws.Util.option_map (Aws.Json.lookup j "AccessGroupId") String.of_json
    ; revoke_all_groups =
        Aws.Util.option_map (Aws.Json.lookup j "RevokeAllGroups") Boolean.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module HostRecovery = struct
  type t =
    | On
    | Off

  let str_to_t = [ "off", Off; "on", On ]

  let t_to_str = [ Off, "off"; On, "on" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module AutoPlacement = struct
  type t =
    | On
    | Off

  let str_to_t = [ "off", Off; "on", On ]

  let t_to_str = [ Off, "off"; On, "on" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ModifyHostsRequest = struct
  type t =
    { auto_placement : AutoPlacement.t option
    ; host_ids : RequestHostIdList.t
    ; host_recovery : HostRecovery.t option
    ; instance_type : String.t option
    ; instance_family : String.t option
    }

  let make ?auto_placement ~host_ids ?host_recovery ?instance_type ?instance_family () =
    { auto_placement; host_ids; host_recovery; instance_type; instance_family }

  let parse xml =
    Some
      { auto_placement =
          Aws.Util.option_bind (Aws.Xml.member "autoPlacement" xml) AutoPlacement.parse
      ; host_ids =
          Aws.Xml.required
            "hostId"
            (Aws.Util.option_bind (Aws.Xml.member "hostId" xml) RequestHostIdList.parse)
      ; host_recovery =
          Aws.Util.option_bind (Aws.Xml.member "HostRecovery" xml) HostRecovery.parse
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "InstanceType" xml) String.parse
      ; instance_family =
          Aws.Util.option_bind (Aws.Xml.member "InstanceFamily" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_family (fun f ->
               Aws.Query.Pair ("InstanceFamily", String.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", String.to_query f))
         ; Aws.Util.option_map v.host_recovery (fun f ->
               Aws.Query.Pair ("HostRecovery", HostRecovery.to_query f))
         ; Some (Aws.Query.Pair ("HostId", RequestHostIdList.to_query v.host_ids))
         ; Aws.Util.option_map v.auto_placement (fun f ->
               Aws.Query.Pair ("AutoPlacement", AutoPlacement.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_family (fun f ->
               "InstanceFamily", String.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f -> "InstanceType", String.to_json f)
         ; Aws.Util.option_map v.host_recovery (fun f ->
               "HostRecovery", HostRecovery.to_json f)
         ; Some ("hostId", RequestHostIdList.to_json v.host_ids)
         ; Aws.Util.option_map v.auto_placement (fun f ->
               "autoPlacement", AutoPlacement.to_json f)
         ])

  let of_json j =
    { auto_placement =
        Aws.Util.option_map (Aws.Json.lookup j "autoPlacement") AutoPlacement.of_json
    ; host_ids =
        RequestHostIdList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "hostId"))
    ; host_recovery =
        Aws.Util.option_map (Aws.Json.lookup j "HostRecovery") HostRecovery.of_json
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "InstanceType") String.of_json
    ; instance_family =
        Aws.Util.option_map (Aws.Json.lookup j "InstanceFamily") String.of_json
    }
end

module DescribeTrafficMirrorSessionsResult = struct
  type t =
    { traffic_mirror_sessions : TrafficMirrorSessionSet.t
    ; next_token : String.t option
    }

  let make ?(traffic_mirror_sessions = []) ?next_token () =
    { traffic_mirror_sessions; next_token }

  let parse xml =
    Some
      { traffic_mirror_sessions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "trafficMirrorSessionSet" xml)
               TrafficMirrorSessionSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TrafficMirrorSessionSet"
                , TrafficMirrorSessionSet.to_query v.traffic_mirror_sessions ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "trafficMirrorSessionSet"
             , TrafficMirrorSessionSet.to_json v.traffic_mirror_sessions )
         ])

  let of_json j =
    { traffic_mirror_sessions =
        TrafficMirrorSessionSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "trafficMirrorSessionSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module ReservedInstancesModificationIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map String.parse (Aws.Xml.members "ReservedInstancesModificationId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeNetworkAclsRequest = struct
  type t =
    { filters : FilterList.t
    ; dry_run : Boolean.t option
    ; network_acl_ids : NetworkAclIdStringList.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    }

  let make ?(filters = []) ?dry_run ?(network_acl_ids = []) ?next_token ?max_results () =
    { filters; dry_run; network_acl_ids; next_token; max_results }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; network_acl_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "NetworkAclId" xml)
               NetworkAclIdStringList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("NetworkAclId", NetworkAclIdStringList.to_query v.network_acl_ids))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("NetworkAclId", NetworkAclIdStringList.to_json v.network_acl_ids)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; network_acl_ids =
        NetworkAclIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "NetworkAclId"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module PrefixListSet = struct
  type t = PrefixList.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map PrefixList.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list PrefixList.to_query v

  let to_json v = `List (List.map PrefixList.to_json v)

  let of_json j = Aws.Json.to_list PrefixList.of_json j
end

module LocalGatewayVirtualInterface = struct
  type t =
    { local_gateway_virtual_interface_id : String.t option
    ; local_gateway_id : String.t option
    ; vlan : Integer.t option
    ; local_address : String.t option
    ; peer_address : String.t option
    ; local_bgp_asn : Integer.t option
    ; peer_bgp_asn : Integer.t option
    ; owner_id : String.t option
    ; tags : TagList.t
    }

  let make
      ?local_gateway_virtual_interface_id
      ?local_gateway_id
      ?vlan
      ?local_address
      ?peer_address
      ?local_bgp_asn
      ?peer_bgp_asn
      ?owner_id
      ?(tags = [])
      () =
    { local_gateway_virtual_interface_id
    ; local_gateway_id
    ; vlan
    ; local_address
    ; peer_address
    ; local_bgp_asn
    ; peer_bgp_asn
    ; owner_id
    ; tags
    }

  let parse xml =
    Some
      { local_gateway_virtual_interface_id =
          Aws.Util.option_bind
            (Aws.Xml.member "localGatewayVirtualInterfaceId" xml)
            String.parse
      ; local_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "localGatewayId" xml) String.parse
      ; vlan = Aws.Util.option_bind (Aws.Xml.member "vlan" xml) Integer.parse
      ; local_address =
          Aws.Util.option_bind (Aws.Xml.member "localAddress" xml) String.parse
      ; peer_address =
          Aws.Util.option_bind (Aws.Xml.member "peerAddress" xml) String.parse
      ; local_bgp_asn =
          Aws.Util.option_bind (Aws.Xml.member "localBgpAsn" xml) Integer.parse
      ; peer_bgp_asn =
          Aws.Util.option_bind (Aws.Xml.member "peerBgpAsn" xml) Integer.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.peer_bgp_asn (fun f ->
               Aws.Query.Pair ("PeerBgpAsn", Integer.to_query f))
         ; Aws.Util.option_map v.local_bgp_asn (fun f ->
               Aws.Query.Pair ("LocalBgpAsn", Integer.to_query f))
         ; Aws.Util.option_map v.peer_address (fun f ->
               Aws.Query.Pair ("PeerAddress", String.to_query f))
         ; Aws.Util.option_map v.local_address (fun f ->
               Aws.Query.Pair ("LocalAddress", String.to_query f))
         ; Aws.Util.option_map v.vlan (fun f ->
               Aws.Query.Pair ("Vlan", Integer.to_query f))
         ; Aws.Util.option_map v.local_gateway_id (fun f ->
               Aws.Query.Pair ("LocalGatewayId", String.to_query f))
         ; Aws.Util.option_map v.local_gateway_virtual_interface_id (fun f ->
               Aws.Query.Pair ("LocalGatewayVirtualInterfaceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.peer_bgp_asn (fun f -> "peerBgpAsn", Integer.to_json f)
         ; Aws.Util.option_map v.local_bgp_asn (fun f -> "localBgpAsn", Integer.to_json f)
         ; Aws.Util.option_map v.peer_address (fun f -> "peerAddress", String.to_json f)
         ; Aws.Util.option_map v.local_address (fun f -> "localAddress", String.to_json f)
         ; Aws.Util.option_map v.vlan (fun f -> "vlan", Integer.to_json f)
         ; Aws.Util.option_map v.local_gateway_id (fun f ->
               "localGatewayId", String.to_json f)
         ; Aws.Util.option_map v.local_gateway_virtual_interface_id (fun f ->
               "localGatewayVirtualInterfaceId", String.to_json f)
         ])

  let of_json j =
    { local_gateway_virtual_interface_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "localGatewayVirtualInterfaceId")
          String.of_json
    ; local_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "localGatewayId") String.of_json
    ; vlan = Aws.Util.option_map (Aws.Json.lookup j "vlan") Integer.of_json
    ; local_address =
        Aws.Util.option_map (Aws.Json.lookup j "localAddress") String.of_json
    ; peer_address = Aws.Util.option_map (Aws.Json.lookup j "peerAddress") String.of_json
    ; local_bgp_asn =
        Aws.Util.option_map (Aws.Json.lookup j "localBgpAsn") Integer.of_json
    ; peer_bgp_asn = Aws.Util.option_map (Aws.Json.lookup j "peerBgpAsn") Integer.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module LocalGatewayVirtualInterfaceSet = struct
  type t = LocalGatewayVirtualInterface.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map LocalGatewayVirtualInterface.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list LocalGatewayVirtualInterface.to_query v

  let to_json v = `List (List.map LocalGatewayVirtualInterface.to_json v)

  let of_json j = Aws.Json.to_list LocalGatewayVirtualInterface.of_json j
end

module CreateLaunchTemplateVersionRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; client_token : String.t option
    ; launch_template_id : String.t option
    ; launch_template_name : String.t option
    ; source_version : String.t option
    ; version_description : String.t option
    ; launch_template_data : RequestLaunchTemplateData.t
    }

  let make
      ?dry_run
      ?client_token
      ?launch_template_id
      ?launch_template_name
      ?source_version
      ?version_description
      ~launch_template_data
      () =
    { dry_run
    ; client_token
    ; launch_template_id
    ; launch_template_name
    ; source_version
    ; version_description
    ; launch_template_data
    }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; launch_template_id =
          Aws.Util.option_bind (Aws.Xml.member "LaunchTemplateId" xml) String.parse
      ; launch_template_name =
          Aws.Util.option_bind (Aws.Xml.member "LaunchTemplateName" xml) String.parse
      ; source_version =
          Aws.Util.option_bind (Aws.Xml.member "SourceVersion" xml) String.parse
      ; version_description =
          Aws.Util.option_bind (Aws.Xml.member "VersionDescription" xml) String.parse
      ; launch_template_data =
          Aws.Xml.required
            "LaunchTemplateData"
            (Aws.Util.option_bind
               (Aws.Xml.member "LaunchTemplateData" xml)
               RequestLaunchTemplateData.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "LaunchTemplateData"
                , RequestLaunchTemplateData.to_query v.launch_template_data ))
         ; Aws.Util.option_map v.version_description (fun f ->
               Aws.Query.Pair ("VersionDescription", String.to_query f))
         ; Aws.Util.option_map v.source_version (fun f ->
               Aws.Query.Pair ("SourceVersion", String.to_query f))
         ; Aws.Util.option_map v.launch_template_name (fun f ->
               Aws.Query.Pair ("LaunchTemplateName", String.to_query f))
         ; Aws.Util.option_map v.launch_template_id (fun f ->
               Aws.Query.Pair ("LaunchTemplateId", String.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "LaunchTemplateData"
             , RequestLaunchTemplateData.to_json v.launch_template_data )
         ; Aws.Util.option_map v.version_description (fun f ->
               "VersionDescription", String.to_json f)
         ; Aws.Util.option_map v.source_version (fun f ->
               "SourceVersion", String.to_json f)
         ; Aws.Util.option_map v.launch_template_name (fun f ->
               "LaunchTemplateName", String.to_json f)
         ; Aws.Util.option_map v.launch_template_id (fun f ->
               "LaunchTemplateId", String.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; launch_template_id =
        Aws.Util.option_map (Aws.Json.lookup j "LaunchTemplateId") String.of_json
    ; launch_template_name =
        Aws.Util.option_map (Aws.Json.lookup j "LaunchTemplateName") String.of_json
    ; source_version =
        Aws.Util.option_map (Aws.Json.lookup j "SourceVersion") String.of_json
    ; version_description =
        Aws.Util.option_map (Aws.Json.lookup j "VersionDescription") String.of_json
    ; launch_template_data =
        RequestLaunchTemplateData.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "LaunchTemplateData"))
    }
end

module CreateVpcPeeringConnectionResult = struct
  type t = { vpc_peering_connection : VpcPeeringConnection.t option }

  let make ?vpc_peering_connection () = { vpc_peering_connection }

  let parse xml =
    Some
      { vpc_peering_connection =
          Aws.Util.option_bind
            (Aws.Xml.member "vpcPeeringConnection" xml)
            VpcPeeringConnection.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_peering_connection (fun f ->
               Aws.Query.Pair ("VpcPeeringConnection", VpcPeeringConnection.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_peering_connection (fun f ->
               "vpcPeeringConnection", VpcPeeringConnection.to_json f)
         ])

  let of_json j =
    { vpc_peering_connection =
        Aws.Util.option_map
          (Aws.Json.lookup j "vpcPeeringConnection")
          VpcPeeringConnection.of_json
    }
end

module TransitGatewayAttachmentPropagation = struct
  type t =
    { transit_gateway_route_table_id : String.t option
    ; state : TransitGatewayPropagationState.t option
    }

  let make ?transit_gateway_route_table_id ?state () =
    { transit_gateway_route_table_id; state }

  let parse xml =
    Some
      { transit_gateway_route_table_id =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayRouteTableId" xml)
            String.parse
      ; state =
          Aws.Util.option_bind
            (Aws.Xml.member "state" xml)
            TransitGatewayPropagationState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", TransitGatewayPropagationState.to_query f))
         ; Aws.Util.option_map v.transit_gateway_route_table_id (fun f ->
               Aws.Query.Pair ("TransitGatewayRouteTableId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               "state", TransitGatewayPropagationState.to_json f)
         ; Aws.Util.option_map v.transit_gateway_route_table_id (fun f ->
               "transitGatewayRouteTableId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_route_table_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayRouteTableId")
          String.of_json
    ; state =
        Aws.Util.option_map
          (Aws.Json.lookup j "state")
          TransitGatewayPropagationState.of_json
    }
end

module DescribeReservedInstancesOfferingsRequest = struct
  type t =
    { availability_zone : String.t option
    ; filters : FilterList.t
    ; include_marketplace : Boolean.t option
    ; instance_type : InstanceType.t option
    ; max_duration : Long.t option
    ; max_instance_count : Integer.t option
    ; min_duration : Long.t option
    ; offering_class : OfferingClassType.t option
    ; product_description : RIProductDescription.t option
    ; reserved_instances_offering_ids : ReservedInstancesOfferingIdStringList.t
    ; dry_run : Boolean.t option
    ; instance_tenancy : Tenancy.t option
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; offering_type : OfferingTypeValues.t option
    }

  let make
      ?availability_zone
      ?(filters = [])
      ?include_marketplace
      ?instance_type
      ?max_duration
      ?max_instance_count
      ?min_duration
      ?offering_class
      ?product_description
      ?(reserved_instances_offering_ids = [])
      ?dry_run
      ?instance_tenancy
      ?max_results
      ?next_token
      ?offering_type
      () =
    { availability_zone
    ; filters
    ; include_marketplace
    ; instance_type
    ; max_duration
    ; max_instance_count
    ; min_duration
    ; offering_class
    ; product_description
    ; reserved_instances_offering_ids
    ; dry_run
    ; instance_tenancy
    ; max_results
    ; next_token
    ; offering_type
    }

  let parse xml =
    Some
      { availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "AvailabilityZone" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; include_marketplace =
          Aws.Util.option_bind (Aws.Xml.member "IncludeMarketplace" xml) Boolean.parse
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "InstanceType" xml) InstanceType.parse
      ; max_duration = Aws.Util.option_bind (Aws.Xml.member "MaxDuration" xml) Long.parse
      ; max_instance_count =
          Aws.Util.option_bind (Aws.Xml.member "MaxInstanceCount" xml) Integer.parse
      ; min_duration = Aws.Util.option_bind (Aws.Xml.member "MinDuration" xml) Long.parse
      ; offering_class =
          Aws.Util.option_bind
            (Aws.Xml.member "OfferingClass" xml)
            OfferingClassType.parse
      ; product_description =
          Aws.Util.option_bind
            (Aws.Xml.member "ProductDescription" xml)
            RIProductDescription.parse
      ; reserved_instances_offering_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ReservedInstancesOfferingId" xml)
               ReservedInstancesOfferingIdStringList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; instance_tenancy =
          Aws.Util.option_bind (Aws.Xml.member "instanceTenancy" xml) Tenancy.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "maxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; offering_type =
          Aws.Util.option_bind
            (Aws.Xml.member "offeringType" xml)
            OfferingTypeValues.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.offering_type (fun f ->
               Aws.Query.Pair ("OfferingType", OfferingTypeValues.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.instance_tenancy (fun f ->
               Aws.Query.Pair ("InstanceTenancy", Tenancy.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ReservedInstancesOfferingId"
                , ReservedInstancesOfferingIdStringList.to_query
                    v.reserved_instances_offering_ids ))
         ; Aws.Util.option_map v.product_description (fun f ->
               Aws.Query.Pair ("ProductDescription", RIProductDescription.to_query f))
         ; Aws.Util.option_map v.offering_class (fun f ->
               Aws.Query.Pair ("OfferingClass", OfferingClassType.to_query f))
         ; Aws.Util.option_map v.min_duration (fun f ->
               Aws.Query.Pair ("MinDuration", Long.to_query f))
         ; Aws.Util.option_map v.max_instance_count (fun f ->
               Aws.Query.Pair ("MaxInstanceCount", Integer.to_query f))
         ; Aws.Util.option_map v.max_duration (fun f ->
               Aws.Query.Pair ("MaxDuration", Long.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", InstanceType.to_query f))
         ; Aws.Util.option_map v.include_marketplace (fun f ->
               Aws.Query.Pair ("IncludeMarketplace", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.offering_type (fun f ->
               "offeringType", OfferingTypeValues.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "maxResults", Integer.to_json f)
         ; Aws.Util.option_map v.instance_tenancy (fun f ->
               "instanceTenancy", Tenancy.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some
             ( "ReservedInstancesOfferingId"
             , ReservedInstancesOfferingIdStringList.to_json
                 v.reserved_instances_offering_ids )
         ; Aws.Util.option_map v.product_description (fun f ->
               "ProductDescription", RIProductDescription.to_json f)
         ; Aws.Util.option_map v.offering_class (fun f ->
               "OfferingClass", OfferingClassType.to_json f)
         ; Aws.Util.option_map v.min_duration (fun f -> "MinDuration", Long.to_json f)
         ; Aws.Util.option_map v.max_instance_count (fun f ->
               "MaxInstanceCount", Integer.to_json f)
         ; Aws.Util.option_map v.max_duration (fun f -> "MaxDuration", Long.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f ->
               "InstanceType", InstanceType.to_json f)
         ; Aws.Util.option_map v.include_marketplace (fun f ->
               "IncludeMarketplace", Boolean.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "AvailabilityZone", String.to_json f)
         ])

  let of_json j =
    { availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "AvailabilityZone") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; include_marketplace =
        Aws.Util.option_map (Aws.Json.lookup j "IncludeMarketplace") Boolean.of_json
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "InstanceType") InstanceType.of_json
    ; max_duration = Aws.Util.option_map (Aws.Json.lookup j "MaxDuration") Long.of_json
    ; max_instance_count =
        Aws.Util.option_map (Aws.Json.lookup j "MaxInstanceCount") Integer.of_json
    ; min_duration = Aws.Util.option_map (Aws.Json.lookup j "MinDuration") Long.of_json
    ; offering_class =
        Aws.Util.option_map (Aws.Json.lookup j "OfferingClass") OfferingClassType.of_json
    ; product_description =
        Aws.Util.option_map
          (Aws.Json.lookup j "ProductDescription")
          RIProductDescription.of_json
    ; reserved_instances_offering_ids =
        ReservedInstancesOfferingIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ReservedInstancesOfferingId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; instance_tenancy =
        Aws.Util.option_map (Aws.Json.lookup j "instanceTenancy") Tenancy.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "maxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; offering_type =
        Aws.Util.option_map (Aws.Json.lookup j "offeringType") OfferingTypeValues.of_json
    }
end

module ExportTaskIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "ExportTaskId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeExportTasksRequest = struct
  type t =
    { export_task_ids : ExportTaskIdStringList.t
    ; filters : FilterList.t
    }

  let make ?(export_task_ids = []) ?(filters = []) () = { export_task_ids; filters }

  let parse xml =
    Some
      { export_task_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "exportTaskId" xml)
               ExportTaskIdStringList.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ("ExportTaskId", ExportTaskIdStringList.to_query v.export_task_ids))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Filter", FilterList.to_json v.filters)
         ; Some ("exportTaskId", ExportTaskIdStringList.to_json v.export_task_ids)
         ])

  let of_json j =
    { export_task_ids =
        ExportTaskIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "exportTaskId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    }
end

module MoveStatus = struct
  type t =
    | MovingToVpc
    | RestoringToClassic

  let str_to_t = [ "restoringToClassic", RestoringToClassic; "movingToVpc", MovingToVpc ]

  let t_to_str = [ RestoringToClassic, "restoringToClassic"; MovingToVpc, "movingToVpc" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module MovingAddressStatus = struct
  type t =
    { move_status : MoveStatus.t option
    ; public_ip : String.t option
    }

  let make ?move_status ?public_ip () = { move_status; public_ip }

  let parse xml =
    Some
      { move_status =
          Aws.Util.option_bind (Aws.Xml.member "moveStatus" xml) MoveStatus.parse
      ; public_ip = Aws.Util.option_bind (Aws.Xml.member "publicIp" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.public_ip (fun f ->
               Aws.Query.Pair ("PublicIp", String.to_query f))
         ; Aws.Util.option_map v.move_status (fun f ->
               Aws.Query.Pair ("MoveStatus", MoveStatus.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.public_ip (fun f -> "publicIp", String.to_json f)
         ; Aws.Util.option_map v.move_status (fun f -> "moveStatus", MoveStatus.to_json f)
         ])

  let of_json j =
    { move_status =
        Aws.Util.option_map (Aws.Json.lookup j "moveStatus") MoveStatus.of_json
    ; public_ip = Aws.Util.option_map (Aws.Json.lookup j "publicIp") String.of_json
    }
end

module MovingAddressStatusSet = struct
  type t = MovingAddressStatus.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map MovingAddressStatus.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list MovingAddressStatus.to_query v

  let to_json v = `List (List.map MovingAddressStatus.to_json v)

  let of_json j = Aws.Json.to_list MovingAddressStatus.of_json j
end

module DescribeMovingAddressesResult = struct
  type t =
    { moving_address_statuses : MovingAddressStatusSet.t
    ; next_token : String.t option
    }

  let make ?(moving_address_statuses = []) ?next_token () =
    { moving_address_statuses; next_token }

  let parse xml =
    Some
      { moving_address_statuses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "movingAddressStatusSet" xml)
               MovingAddressStatusSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "MovingAddressStatusSet"
                , MovingAddressStatusSet.to_query v.moving_address_statuses ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "movingAddressStatusSet"
             , MovingAddressStatusSet.to_json v.moving_address_statuses )
         ])

  let of_json j =
    { moving_address_statuses =
        MovingAddressStatusSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "movingAddressStatusSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module TransitGatewayAssociation = struct
  type t =
    { transit_gateway_route_table_id : String.t option
    ; transit_gateway_attachment_id : String.t option
    ; resource_id : String.t option
    ; resource_type : TransitGatewayAttachmentResourceType.t option
    ; state : TransitGatewayAssociationState.t option
    }

  let make
      ?transit_gateway_route_table_id
      ?transit_gateway_attachment_id
      ?resource_id
      ?resource_type
      ?state
      () =
    { transit_gateway_route_table_id
    ; transit_gateway_attachment_id
    ; resource_id
    ; resource_type
    ; state
    }

  let parse xml =
    Some
      { transit_gateway_route_table_id =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayRouteTableId" xml)
            String.parse
      ; transit_gateway_attachment_id =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayAttachmentId" xml)
            String.parse
      ; resource_id = Aws.Util.option_bind (Aws.Xml.member "resourceId" xml) String.parse
      ; resource_type =
          Aws.Util.option_bind
            (Aws.Xml.member "resourceType" xml)
            TransitGatewayAttachmentResourceType.parse
      ; state =
          Aws.Util.option_bind
            (Aws.Xml.member "state" xml)
            TransitGatewayAssociationState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", TransitGatewayAssociationState.to_query f))
         ; Aws.Util.option_map v.resource_type (fun f ->
               Aws.Query.Pair
                 ("ResourceType", TransitGatewayAttachmentResourceType.to_query f))
         ; Aws.Util.option_map v.resource_id (fun f ->
               Aws.Query.Pair ("ResourceId", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               Aws.Query.Pair ("TransitGatewayAttachmentId", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_route_table_id (fun f ->
               Aws.Query.Pair ("TransitGatewayRouteTableId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               "state", TransitGatewayAssociationState.to_json f)
         ; Aws.Util.option_map v.resource_type (fun f ->
               "resourceType", TransitGatewayAttachmentResourceType.to_json f)
         ; Aws.Util.option_map v.resource_id (fun f -> "resourceId", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               "transitGatewayAttachmentId", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_route_table_id (fun f ->
               "transitGatewayRouteTableId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_route_table_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayRouteTableId")
          String.of_json
    ; transit_gateway_attachment_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayAttachmentId")
          String.of_json
    ; resource_id = Aws.Util.option_map (Aws.Json.lookup j "resourceId") String.of_json
    ; resource_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "resourceType")
          TransitGatewayAttachmentResourceType.of_json
    ; state =
        Aws.Util.option_map
          (Aws.Json.lookup j "state")
          TransitGatewayAssociationState.of_json
    }
end

module DisassociateTransitGatewayRouteTableResult = struct
  type t = { association : TransitGatewayAssociation.t option }

  let make ?association () = { association }

  let parse xml =
    Some
      { association =
          Aws.Util.option_bind
            (Aws.Xml.member "association" xml)
            TransitGatewayAssociation.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association (fun f ->
               Aws.Query.Pair ("Association", TransitGatewayAssociation.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association (fun f ->
               "association", TransitGatewayAssociation.to_json f)
         ])

  let of_json j =
    { association =
        Aws.Util.option_map
          (Aws.Json.lookup j "association")
          TransitGatewayAssociation.of_json
    }
end

module InstanceTagNotificationAttribute = struct
  type t =
    { instance_tag_keys : InstanceTagKeySet.t
    ; include_all_tags_of_instance : Boolean.t option
    }

  let make ?(instance_tag_keys = []) ?include_all_tags_of_instance () =
    { instance_tag_keys; include_all_tags_of_instance }

  let parse xml =
    Some
      { instance_tag_keys =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "instanceTagKeySet" xml)
               InstanceTagKeySet.parse)
      ; include_all_tags_of_instance =
          Aws.Util.option_bind
            (Aws.Xml.member "includeAllTagsOfInstance" xml)
            Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.include_all_tags_of_instance (fun f ->
               Aws.Query.Pair ("IncludeAllTagsOfInstance", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("InstanceTagKeySet", InstanceTagKeySet.to_query v.instance_tag_keys))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.include_all_tags_of_instance (fun f ->
               "includeAllTagsOfInstance", Boolean.to_json f)
         ; Some ("instanceTagKeySet", InstanceTagKeySet.to_json v.instance_tag_keys)
         ])

  let of_json j =
    { instance_tag_keys =
        InstanceTagKeySet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceTagKeySet"))
    ; include_all_tags_of_instance =
        Aws.Util.option_map (Aws.Json.lookup j "includeAllTagsOfInstance") Boolean.of_json
    }
end

module DescribeVpcPeeringConnectionsRequest = struct
  type t =
    { filters : FilterList.t
    ; dry_run : Boolean.t option
    ; vpc_peering_connection_ids : VpcPeeringConnectionIdList.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    }

  let make
      ?(filters = [])
      ?dry_run
      ?(vpc_peering_connection_ids = [])
      ?next_token
      ?max_results
      () =
    { filters; dry_run; vpc_peering_connection_ids; next_token; max_results }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; vpc_peering_connection_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "VpcPeeringConnectionId" xml)
               VpcPeeringConnectionIdList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "VpcPeeringConnectionId"
                , VpcPeeringConnectionIdList.to_query v.vpc_peering_connection_ids ))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some
             ( "VpcPeeringConnectionId"
             , VpcPeeringConnectionIdList.to_json v.vpc_peering_connection_ids )
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; vpc_peering_connection_ids =
        VpcPeeringConnectionIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcPeeringConnectionId"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module DescribeVpcEndpointsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; vpc_endpoint_ids : VpcEndpointIdList.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?dry_run ?(vpc_endpoint_ids = []) ?(filters = []) ?max_results ?next_token () =
    { dry_run; vpc_endpoint_ids; filters; max_results; next_token }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; vpc_endpoint_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "VpcEndpointId" xml)
               VpcEndpointIdList.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ("VpcEndpointId", VpcEndpointIdList.to_query v.vpc_endpoint_ids))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some ("VpcEndpointId", VpcEndpointIdList.to_json v.vpc_endpoint_ids)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; vpc_endpoint_ids =
        VpcEndpointIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcEndpointId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module AssociateEnclaveCertificateIamRoleResult = struct
  type t =
    { certificate_s3_bucket_name : String.t option
    ; certificate_s3_object_key : String.t option
    ; encryption_kms_key_id : String.t option
    }

  let make
      ?certificate_s3_bucket_name
      ?certificate_s3_object_key
      ?encryption_kms_key_id
      () =
    { certificate_s3_bucket_name; certificate_s3_object_key; encryption_kms_key_id }

  let parse xml =
    Some
      { certificate_s3_bucket_name =
          Aws.Util.option_bind (Aws.Xml.member "certificateS3BucketName" xml) String.parse
      ; certificate_s3_object_key =
          Aws.Util.option_bind (Aws.Xml.member "certificateS3ObjectKey" xml) String.parse
      ; encryption_kms_key_id =
          Aws.Util.option_bind (Aws.Xml.member "encryptionKmsKeyId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.encryption_kms_key_id (fun f ->
               Aws.Query.Pair ("EncryptionKmsKeyId", String.to_query f))
         ; Aws.Util.option_map v.certificate_s3_object_key (fun f ->
               Aws.Query.Pair ("CertificateS3ObjectKey", String.to_query f))
         ; Aws.Util.option_map v.certificate_s3_bucket_name (fun f ->
               Aws.Query.Pair ("CertificateS3BucketName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.encryption_kms_key_id (fun f ->
               "encryptionKmsKeyId", String.to_json f)
         ; Aws.Util.option_map v.certificate_s3_object_key (fun f ->
               "certificateS3ObjectKey", String.to_json f)
         ; Aws.Util.option_map v.certificate_s3_bucket_name (fun f ->
               "certificateS3BucketName", String.to_json f)
         ])

  let of_json j =
    { certificate_s3_bucket_name =
        Aws.Util.option_map (Aws.Json.lookup j "certificateS3BucketName") String.of_json
    ; certificate_s3_object_key =
        Aws.Util.option_map (Aws.Json.lookup j "certificateS3ObjectKey") String.of_json
    ; encryption_kms_key_id =
        Aws.Util.option_map (Aws.Json.lookup j "encryptionKmsKeyId") String.of_json
    }
end

module ReplaceNetworkAclAssociationRequest = struct
  type t =
    { association_id : String.t
    ; dry_run : Boolean.t option
    ; network_acl_id : String.t
    }

  let make ~association_id ?dry_run ~network_acl_id () =
    { association_id; dry_run; network_acl_id }

  let parse xml =
    Some
      { association_id =
          Aws.Xml.required
            "associationId"
            (Aws.Util.option_bind (Aws.Xml.member "associationId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; network_acl_id =
          Aws.Xml.required
            "networkAclId"
            (Aws.Util.option_bind (Aws.Xml.member "networkAclId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("NetworkAclId", String.to_query v.network_acl_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("AssociationId", String.to_query v.association_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("networkAclId", String.to_json v.network_acl_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("associationId", String.to_json v.association_id)
         ])

  let of_json j =
    { association_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "associationId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; network_acl_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "networkAclId"))
    }
end

module ExecutableByStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "ExecutableBy" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeImagesRequest = struct
  type t =
    { executable_users : ExecutableByStringList.t
    ; filters : FilterList.t
    ; image_ids : ImageIdStringList.t
    ; owners : OwnerStringList.t
    ; dry_run : Boolean.t option
    }

  let make
      ?(executable_users = [])
      ?(filters = [])
      ?(image_ids = [])
      ?(owners = [])
      ?dry_run
      () =
    { executable_users; filters; image_ids; owners; dry_run }

  let parse xml =
    Some
      { executable_users =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ExecutableBy" xml)
               ExecutableByStringList.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; image_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "ImageId" xml) ImageIdStringList.parse)
      ; owners =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Owner" xml) OwnerStringList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Owner", OwnerStringList.to_query v.owners))
         ; Some (Aws.Query.Pair ("ImageId", ImageIdStringList.to_query v.image_ids))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ("ExecutableBy", ExecutableByStringList.to_query v.executable_users))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("Owner", OwnerStringList.to_json v.owners)
         ; Some ("ImageId", ImageIdStringList.to_json v.image_ids)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some ("ExecutableBy", ExecutableByStringList.to_json v.executable_users)
         ])

  let of_json j =
    { executable_users =
        ExecutableByStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ExecutableBy"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; image_ids =
        ImageIdStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ImageId"))
    ; owners =
        OwnerStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Owner"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module CreateTransitGatewayVpcAttachmentResult = struct
  type t = { transit_gateway_vpc_attachment : TransitGatewayVpcAttachment.t option }

  let make ?transit_gateway_vpc_attachment () = { transit_gateway_vpc_attachment }

  let parse xml =
    Some
      { transit_gateway_vpc_attachment =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayVpcAttachment" xml)
            TransitGatewayVpcAttachment.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_vpc_attachment (fun f ->
               Aws.Query.Pair
                 ("TransitGatewayVpcAttachment", TransitGatewayVpcAttachment.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_vpc_attachment (fun f ->
               "transitGatewayVpcAttachment", TransitGatewayVpcAttachment.to_json f)
         ])

  let of_json j =
    { transit_gateway_vpc_attachment =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayVpcAttachment")
          TransitGatewayVpcAttachment.of_json
    }
end

module LocalGatewayVirtualInterfaceGroupSet = struct
  type t = LocalGatewayVirtualInterfaceGroup.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map LocalGatewayVirtualInterfaceGroup.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list LocalGatewayVirtualInterfaceGroup.to_query v

  let to_json v = `List (List.map LocalGatewayVirtualInterfaceGroup.to_json v)

  let of_json j = Aws.Json.to_list LocalGatewayVirtualInterfaceGroup.of_json j
end

module DescribeLocalGatewayVirtualInterfaceGroupsResult = struct
  type t =
    { local_gateway_virtual_interface_groups : LocalGatewayVirtualInterfaceGroupSet.t
    ; next_token : String.t option
    }

  let make ?(local_gateway_virtual_interface_groups = []) ?next_token () =
    { local_gateway_virtual_interface_groups; next_token }

  let parse xml =
    Some
      { local_gateway_virtual_interface_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "localGatewayVirtualInterfaceGroupSet" xml)
               LocalGatewayVirtualInterfaceGroupSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "LocalGatewayVirtualInterfaceGroupSet"
                , LocalGatewayVirtualInterfaceGroupSet.to_query
                    v.local_gateway_virtual_interface_groups ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "localGatewayVirtualInterfaceGroupSet"
             , LocalGatewayVirtualInterfaceGroupSet.to_json
                 v.local_gateway_virtual_interface_groups )
         ])

  let of_json j =
    { local_gateway_virtual_interface_groups =
        LocalGatewayVirtualInterfaceGroupSet.of_json
          (Aws.Util.of_option_exn
             (Aws.Json.lookup j "localGatewayVirtualInterfaceGroupSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module RequestSpotLaunchSpecificationSecurityGroupList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module StartInstancesResult = struct
  type t = { starting_instances : InstanceStateChangeList.t }

  let make ?(starting_instances = []) () = { starting_instances }

  let parse xml =
    Some
      { starting_instances =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "instancesSet" xml)
               InstanceStateChangeList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("InstancesSet", InstanceStateChangeList.to_query v.starting_instances))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("instancesSet", InstanceStateChangeList.to_json v.starting_instances) ])

  let of_json j =
    { starting_instances =
        InstanceStateChangeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "instancesSet"))
    }
end

module LaunchTemplateSpecification = struct
  type t =
    { launch_template_id : String.t option
    ; launch_template_name : String.t option
    ; version : String.t option
    }

  let make ?launch_template_id ?launch_template_name ?version () =
    { launch_template_id; launch_template_name; version }

  let parse xml =
    Some
      { launch_template_id =
          Aws.Util.option_bind (Aws.Xml.member "LaunchTemplateId" xml) String.parse
      ; launch_template_name =
          Aws.Util.option_bind (Aws.Xml.member "LaunchTemplateName" xml) String.parse
      ; version = Aws.Util.option_bind (Aws.Xml.member "Version" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.version (fun f ->
               Aws.Query.Pair ("Version", String.to_query f))
         ; Aws.Util.option_map v.launch_template_name (fun f ->
               Aws.Query.Pair ("LaunchTemplateName", String.to_query f))
         ; Aws.Util.option_map v.launch_template_id (fun f ->
               Aws.Query.Pair ("LaunchTemplateId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.version (fun f -> "Version", String.to_json f)
         ; Aws.Util.option_map v.launch_template_name (fun f ->
               "LaunchTemplateName", String.to_json f)
         ; Aws.Util.option_map v.launch_template_id (fun f ->
               "LaunchTemplateId", String.to_json f)
         ])

  let of_json j =
    { launch_template_id =
        Aws.Util.option_map (Aws.Json.lookup j "LaunchTemplateId") String.of_json
    ; launch_template_name =
        Aws.Util.option_map (Aws.Json.lookup j "LaunchTemplateName") String.of_json
    ; version = Aws.Util.option_map (Aws.Json.lookup j "Version") String.of_json
    }
end

module InstanceMetadataOptionsRequest = struct
  type t =
    { http_tokens : HttpTokensState.t option
    ; http_put_response_hop_limit : Integer.t option
    ; http_endpoint : InstanceMetadataEndpointState.t option
    }

  let make ?http_tokens ?http_put_response_hop_limit ?http_endpoint () =
    { http_tokens; http_put_response_hop_limit; http_endpoint }

  let parse xml =
    Some
      { http_tokens =
          Aws.Util.option_bind (Aws.Xml.member "HttpTokens" xml) HttpTokensState.parse
      ; http_put_response_hop_limit =
          Aws.Util.option_bind
            (Aws.Xml.member "HttpPutResponseHopLimit" xml)
            Integer.parse
      ; http_endpoint =
          Aws.Util.option_bind
            (Aws.Xml.member "HttpEndpoint" xml)
            InstanceMetadataEndpointState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.http_endpoint (fun f ->
               Aws.Query.Pair ("HttpEndpoint", InstanceMetadataEndpointState.to_query f))
         ; Aws.Util.option_map v.http_put_response_hop_limit (fun f ->
               Aws.Query.Pair ("HttpPutResponseHopLimit", Integer.to_query f))
         ; Aws.Util.option_map v.http_tokens (fun f ->
               Aws.Query.Pair ("HttpTokens", HttpTokensState.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.http_endpoint (fun f ->
               "HttpEndpoint", InstanceMetadataEndpointState.to_json f)
         ; Aws.Util.option_map v.http_put_response_hop_limit (fun f ->
               "HttpPutResponseHopLimit", Integer.to_json f)
         ; Aws.Util.option_map v.http_tokens (fun f ->
               "HttpTokens", HttpTokensState.to_json f)
         ])

  let of_json j =
    { http_tokens =
        Aws.Util.option_map (Aws.Json.lookup j "HttpTokens") HttpTokensState.of_json
    ; http_put_response_hop_limit =
        Aws.Util.option_map (Aws.Json.lookup j "HttpPutResponseHopLimit") Integer.of_json
    ; http_endpoint =
        Aws.Util.option_map
          (Aws.Json.lookup j "HttpEndpoint")
          InstanceMetadataEndpointState.of_json
    }
end

module HibernationOptionsRequest = struct
  type t = { configured : Boolean.t option }

  let make ?configured () = { configured }

  let parse xml =
    Some
      { configured = Aws.Util.option_bind (Aws.Xml.member "Configured" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.configured (fun f ->
               Aws.Query.Pair ("Configured", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.configured (fun f -> "Configured", Boolean.to_json f) ])

  let of_json j =
    { configured = Aws.Util.option_map (Aws.Json.lookup j "Configured") Boolean.of_json }
end

module ElasticInferenceAccelerator = struct
  type t =
    { type_ : String.t
    ; count : Integer.t option
    }

  let make ~type_ ?count () = { type_; count }

  let parse xml =
    Some
      { type_ =
          Aws.Xml.required
            "Type"
            (Aws.Util.option_bind (Aws.Xml.member "Type" xml) String.parse)
      ; count = Aws.Util.option_bind (Aws.Xml.member "Count" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.count (fun f ->
               Aws.Query.Pair ("Count", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Type", String.to_query v.type_))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.count (fun f -> "Count", Integer.to_json f)
         ; Some ("Type", String.to_json v.type_)
         ])

  let of_json j =
    { type_ = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Type"))
    ; count = Aws.Util.option_map (Aws.Json.lookup j "Count") Integer.of_json
    }
end

module ElasticInferenceAccelerators = struct
  type t = ElasticInferenceAccelerator.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ElasticInferenceAccelerator.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ElasticInferenceAccelerator.to_query v

  let to_json v = `List (List.map ElasticInferenceAccelerator.to_json v)

  let of_json j = Aws.Json.to_list ElasticInferenceAccelerator.of_json j
end

module ElasticGpuSpecifications = struct
  type t = ElasticGpuSpecification.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ElasticGpuSpecification.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ElasticGpuSpecification.to_query v

  let to_json v = `List (List.map ElasticGpuSpecification.to_json v)

  let of_json j = Aws.Json.to_list ElasticGpuSpecification.of_json j
end

module CpuOptionsRequest = struct
  type t =
    { core_count : Integer.t option
    ; threads_per_core : Integer.t option
    }

  let make ?core_count ?threads_per_core () = { core_count; threads_per_core }

  let parse xml =
    Some
      { core_count = Aws.Util.option_bind (Aws.Xml.member "CoreCount" xml) Integer.parse
      ; threads_per_core =
          Aws.Util.option_bind (Aws.Xml.member "ThreadsPerCore" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.threads_per_core (fun f ->
               Aws.Query.Pair ("ThreadsPerCore", Integer.to_query f))
         ; Aws.Util.option_map v.core_count (fun f ->
               Aws.Query.Pair ("CoreCount", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.threads_per_core (fun f ->
               "ThreadsPerCore", Integer.to_json f)
         ; Aws.Util.option_map v.core_count (fun f -> "CoreCount", Integer.to_json f)
         ])

  let of_json j =
    { core_count = Aws.Util.option_map (Aws.Json.lookup j "CoreCount") Integer.of_json
    ; threads_per_core =
        Aws.Util.option_map (Aws.Json.lookup j "ThreadsPerCore") Integer.of_json
    }
end

module RunInstancesRequest = struct
  type t =
    { block_device_mappings : BlockDeviceMappingRequestList.t
    ; image_id : String.t option
    ; instance_type : InstanceType.t option
    ; ipv6_address_count : Integer.t option
    ; ipv6_addresses : InstanceIpv6AddressList.t
    ; kernel_id : String.t option
    ; key_name : String.t option
    ; max_count : Integer.t
    ; min_count : Integer.t
    ; monitoring : RunInstancesMonitoringEnabled.t option
    ; placement : Placement.t option
    ; ramdisk_id : String.t option
    ; security_group_ids : SecurityGroupIdStringList.t
    ; security_groups : SecurityGroupStringList.t
    ; subnet_id : String.t option
    ; user_data : String.t option
    ; additional_info : String.t option
    ; client_token : String.t option
    ; disable_api_termination : Boolean.t option
    ; dry_run : Boolean.t option
    ; ebs_optimized : Boolean.t option
    ; iam_instance_profile : IamInstanceProfileSpecification.t option
    ; instance_initiated_shutdown_behavior : ShutdownBehavior.t option
    ; network_interfaces : InstanceNetworkInterfaceSpecificationList.t
    ; private_ip_address : String.t option
    ; elastic_gpu_specification : ElasticGpuSpecifications.t
    ; elastic_inference_accelerators : ElasticInferenceAccelerators.t
    ; tag_specifications : TagSpecificationList.t
    ; launch_template : LaunchTemplateSpecification.t option
    ; instance_market_options : InstanceMarketOptionsRequest.t option
    ; credit_specification : CreditSpecificationRequest.t option
    ; cpu_options : CpuOptionsRequest.t option
    ; capacity_reservation_specification : CapacityReservationSpecification.t option
    ; hibernation_options : HibernationOptionsRequest.t option
    ; license_specifications : LicenseSpecificationListRequest.t
    ; metadata_options : InstanceMetadataOptionsRequest.t option
    ; enclave_options : EnclaveOptionsRequest.t option
    }

  let make
      ?(block_device_mappings = [])
      ?image_id
      ?instance_type
      ?ipv6_address_count
      ?(ipv6_addresses = [])
      ?kernel_id
      ?key_name
      ~max_count
      ~min_count
      ?monitoring
      ?placement
      ?ramdisk_id
      ?(security_group_ids = [])
      ?(security_groups = [])
      ?subnet_id
      ?user_data
      ?additional_info
      ?client_token
      ?disable_api_termination
      ?dry_run
      ?ebs_optimized
      ?iam_instance_profile
      ?instance_initiated_shutdown_behavior
      ?(network_interfaces = [])
      ?private_ip_address
      ?(elastic_gpu_specification = [])
      ?(elastic_inference_accelerators = [])
      ?(tag_specifications = [])
      ?launch_template
      ?instance_market_options
      ?credit_specification
      ?cpu_options
      ?capacity_reservation_specification
      ?hibernation_options
      ?(license_specifications = [])
      ?metadata_options
      ?enclave_options
      () =
    { block_device_mappings
    ; image_id
    ; instance_type
    ; ipv6_address_count
    ; ipv6_addresses
    ; kernel_id
    ; key_name
    ; max_count
    ; min_count
    ; monitoring
    ; placement
    ; ramdisk_id
    ; security_group_ids
    ; security_groups
    ; subnet_id
    ; user_data
    ; additional_info
    ; client_token
    ; disable_api_termination
    ; dry_run
    ; ebs_optimized
    ; iam_instance_profile
    ; instance_initiated_shutdown_behavior
    ; network_interfaces
    ; private_ip_address
    ; elastic_gpu_specification
    ; elastic_inference_accelerators
    ; tag_specifications
    ; launch_template
    ; instance_market_options
    ; credit_specification
    ; cpu_options
    ; capacity_reservation_specification
    ; hibernation_options
    ; license_specifications
    ; metadata_options
    ; enclave_options
    }

  let parse xml =
    Some
      { block_device_mappings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "BlockDeviceMapping" xml)
               BlockDeviceMappingRequestList.parse)
      ; image_id = Aws.Util.option_bind (Aws.Xml.member "ImageId" xml) String.parse
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "InstanceType" xml) InstanceType.parse
      ; ipv6_address_count =
          Aws.Util.option_bind (Aws.Xml.member "Ipv6AddressCount" xml) Integer.parse
      ; ipv6_addresses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Ipv6Address" xml)
               InstanceIpv6AddressList.parse)
      ; kernel_id = Aws.Util.option_bind (Aws.Xml.member "KernelId" xml) String.parse
      ; key_name = Aws.Util.option_bind (Aws.Xml.member "KeyName" xml) String.parse
      ; max_count =
          Aws.Xml.required
            "MaxCount"
            (Aws.Util.option_bind (Aws.Xml.member "MaxCount" xml) Integer.parse)
      ; min_count =
          Aws.Xml.required
            "MinCount"
            (Aws.Util.option_bind (Aws.Xml.member "MinCount" xml) Integer.parse)
      ; monitoring =
          Aws.Util.option_bind
            (Aws.Xml.member "Monitoring" xml)
            RunInstancesMonitoringEnabled.parse
      ; placement = Aws.Util.option_bind (Aws.Xml.member "Placement" xml) Placement.parse
      ; ramdisk_id = Aws.Util.option_bind (Aws.Xml.member "RamdiskId" xml) String.parse
      ; security_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SecurityGroupId" xml)
               SecurityGroupIdStringList.parse)
      ; security_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SecurityGroup" xml)
               SecurityGroupStringList.parse)
      ; subnet_id = Aws.Util.option_bind (Aws.Xml.member "SubnetId" xml) String.parse
      ; user_data = Aws.Util.option_bind (Aws.Xml.member "UserData" xml) String.parse
      ; additional_info =
          Aws.Util.option_bind (Aws.Xml.member "additionalInfo" xml) String.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "clientToken" xml) String.parse
      ; disable_api_termination =
          Aws.Util.option_bind (Aws.Xml.member "disableApiTermination" xml) Boolean.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; ebs_optimized =
          Aws.Util.option_bind (Aws.Xml.member "ebsOptimized" xml) Boolean.parse
      ; iam_instance_profile =
          Aws.Util.option_bind
            (Aws.Xml.member "iamInstanceProfile" xml)
            IamInstanceProfileSpecification.parse
      ; instance_initiated_shutdown_behavior =
          Aws.Util.option_bind
            (Aws.Xml.member "instanceInitiatedShutdownBehavior" xml)
            ShutdownBehavior.parse
      ; network_interfaces =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "networkInterface" xml)
               InstanceNetworkInterfaceSpecificationList.parse)
      ; private_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "privateIpAddress" xml) String.parse
      ; elastic_gpu_specification =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ElasticGpuSpecification" xml)
               ElasticGpuSpecifications.parse)
      ; elastic_inference_accelerators =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ElasticInferenceAccelerator" xml)
               ElasticInferenceAccelerators.parse)
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      ; launch_template =
          Aws.Util.option_bind
            (Aws.Xml.member "LaunchTemplate" xml)
            LaunchTemplateSpecification.parse
      ; instance_market_options =
          Aws.Util.option_bind
            (Aws.Xml.member "InstanceMarketOptions" xml)
            InstanceMarketOptionsRequest.parse
      ; credit_specification =
          Aws.Util.option_bind
            (Aws.Xml.member "CreditSpecification" xml)
            CreditSpecificationRequest.parse
      ; cpu_options =
          Aws.Util.option_bind (Aws.Xml.member "CpuOptions" xml) CpuOptionsRequest.parse
      ; capacity_reservation_specification =
          Aws.Util.option_bind
            (Aws.Xml.member "CapacityReservationSpecification" xml)
            CapacityReservationSpecification.parse
      ; hibernation_options =
          Aws.Util.option_bind
            (Aws.Xml.member "HibernationOptions" xml)
            HibernationOptionsRequest.parse
      ; license_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "LicenseSpecification" xml)
               LicenseSpecificationListRequest.parse)
      ; metadata_options =
          Aws.Util.option_bind
            (Aws.Xml.member "MetadataOptions" xml)
            InstanceMetadataOptionsRequest.parse
      ; enclave_options =
          Aws.Util.option_bind
            (Aws.Xml.member "EnclaveOptions" xml)
            EnclaveOptionsRequest.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enclave_options (fun f ->
               Aws.Query.Pair ("EnclaveOptions", EnclaveOptionsRequest.to_query f))
         ; Aws.Util.option_map v.metadata_options (fun f ->
               Aws.Query.Pair
                 ("MetadataOptions", InstanceMetadataOptionsRequest.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "LicenseSpecification"
                , LicenseSpecificationListRequest.to_query v.license_specifications ))
         ; Aws.Util.option_map v.hibernation_options (fun f ->
               Aws.Query.Pair ("HibernationOptions", HibernationOptionsRequest.to_query f))
         ; Aws.Util.option_map v.capacity_reservation_specification (fun f ->
               Aws.Query.Pair
                 ( "CapacityReservationSpecification"
                 , CapacityReservationSpecification.to_query f ))
         ; Aws.Util.option_map v.cpu_options (fun f ->
               Aws.Query.Pair ("CpuOptions", CpuOptionsRequest.to_query f))
         ; Aws.Util.option_map v.credit_specification (fun f ->
               Aws.Query.Pair
                 ("CreditSpecification", CreditSpecificationRequest.to_query f))
         ; Aws.Util.option_map v.instance_market_options (fun f ->
               Aws.Query.Pair
                 ("InstanceMarketOptions", InstanceMarketOptionsRequest.to_query f))
         ; Aws.Util.option_map v.launch_template (fun f ->
               Aws.Query.Pair ("LaunchTemplate", LaunchTemplateSpecification.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Some
             (Aws.Query.Pair
                ( "ElasticInferenceAccelerator"
                , ElasticInferenceAccelerators.to_query v.elastic_inference_accelerators
                ))
         ; Some
             (Aws.Query.Pair
                ( "ElasticGpuSpecification"
                , ElasticGpuSpecifications.to_query v.elastic_gpu_specification ))
         ; Aws.Util.option_map v.private_ip_address (fun f ->
               Aws.Query.Pair ("PrivateIpAddress", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "NetworkInterface"
                , InstanceNetworkInterfaceSpecificationList.to_query v.network_interfaces
                ))
         ; Aws.Util.option_map v.instance_initiated_shutdown_behavior (fun f ->
               Aws.Query.Pair
                 ("InstanceInitiatedShutdownBehavior", ShutdownBehavior.to_query f))
         ; Aws.Util.option_map v.iam_instance_profile (fun f ->
               Aws.Query.Pair
                 ("IamInstanceProfile", IamInstanceProfileSpecification.to_query f))
         ; Aws.Util.option_map v.ebs_optimized (fun f ->
               Aws.Query.Pair ("EbsOptimized", Boolean.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.disable_api_termination (fun f ->
               Aws.Query.Pair ("DisableApiTermination", Boolean.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.additional_info (fun f ->
               Aws.Query.Pair ("AdditionalInfo", String.to_query f))
         ; Aws.Util.option_map v.user_data (fun f ->
               Aws.Query.Pair ("UserData", String.to_query f))
         ; Aws.Util.option_map v.subnet_id (fun f ->
               Aws.Query.Pair ("SubnetId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("SecurityGroup", SecurityGroupStringList.to_query v.security_groups))
         ; Some
             (Aws.Query.Pair
                ( "SecurityGroupId"
                , SecurityGroupIdStringList.to_query v.security_group_ids ))
         ; Aws.Util.option_map v.ramdisk_id (fun f ->
               Aws.Query.Pair ("RamdiskId", String.to_query f))
         ; Aws.Util.option_map v.placement (fun f ->
               Aws.Query.Pair ("Placement", Placement.to_query f))
         ; Aws.Util.option_map v.monitoring (fun f ->
               Aws.Query.Pair ("Monitoring", RunInstancesMonitoringEnabled.to_query f))
         ; Some (Aws.Query.Pair ("MinCount", Integer.to_query v.min_count))
         ; Some (Aws.Query.Pair ("MaxCount", Integer.to_query v.max_count))
         ; Aws.Util.option_map v.key_name (fun f ->
               Aws.Query.Pair ("KeyName", String.to_query f))
         ; Aws.Util.option_map v.kernel_id (fun f ->
               Aws.Query.Pair ("KernelId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("Ipv6Address", InstanceIpv6AddressList.to_query v.ipv6_addresses))
         ; Aws.Util.option_map v.ipv6_address_count (fun f ->
               Aws.Query.Pair ("Ipv6AddressCount", Integer.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", InstanceType.to_query f))
         ; Aws.Util.option_map v.image_id (fun f ->
               Aws.Query.Pair ("ImageId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "BlockDeviceMapping"
                , BlockDeviceMappingRequestList.to_query v.block_device_mappings ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enclave_options (fun f ->
               "EnclaveOptions", EnclaveOptionsRequest.to_json f)
         ; Aws.Util.option_map v.metadata_options (fun f ->
               "MetadataOptions", InstanceMetadataOptionsRequest.to_json f)
         ; Some
             ( "LicenseSpecification"
             , LicenseSpecificationListRequest.to_json v.license_specifications )
         ; Aws.Util.option_map v.hibernation_options (fun f ->
               "HibernationOptions", HibernationOptionsRequest.to_json f)
         ; Aws.Util.option_map v.capacity_reservation_specification (fun f ->
               ( "CapacityReservationSpecification"
               , CapacityReservationSpecification.to_json f ))
         ; Aws.Util.option_map v.cpu_options (fun f ->
               "CpuOptions", CpuOptionsRequest.to_json f)
         ; Aws.Util.option_map v.credit_specification (fun f ->
               "CreditSpecification", CreditSpecificationRequest.to_json f)
         ; Aws.Util.option_map v.instance_market_options (fun f ->
               "InstanceMarketOptions", InstanceMarketOptionsRequest.to_json f)
         ; Aws.Util.option_map v.launch_template (fun f ->
               "LaunchTemplate", LaunchTemplateSpecification.to_json f)
         ; Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Some
             ( "ElasticInferenceAccelerator"
             , ElasticInferenceAccelerators.to_json v.elastic_inference_accelerators )
         ; Some
             ( "ElasticGpuSpecification"
             , ElasticGpuSpecifications.to_json v.elastic_gpu_specification )
         ; Aws.Util.option_map v.private_ip_address (fun f ->
               "privateIpAddress", String.to_json f)
         ; Some
             ( "networkInterface"
             , InstanceNetworkInterfaceSpecificationList.to_json v.network_interfaces )
         ; Aws.Util.option_map v.instance_initiated_shutdown_behavior (fun f ->
               "instanceInitiatedShutdownBehavior", ShutdownBehavior.to_json f)
         ; Aws.Util.option_map v.iam_instance_profile (fun f ->
               "iamInstanceProfile", IamInstanceProfileSpecification.to_json f)
         ; Aws.Util.option_map v.ebs_optimized (fun f ->
               "ebsOptimized", Boolean.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.disable_api_termination (fun f ->
               "disableApiTermination", Boolean.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "clientToken", String.to_json f)
         ; Aws.Util.option_map v.additional_info (fun f ->
               "additionalInfo", String.to_json f)
         ; Aws.Util.option_map v.user_data (fun f -> "UserData", String.to_json f)
         ; Aws.Util.option_map v.subnet_id (fun f -> "SubnetId", String.to_json f)
         ; Some ("SecurityGroup", SecurityGroupStringList.to_json v.security_groups)
         ; Some ("SecurityGroupId", SecurityGroupIdStringList.to_json v.security_group_ids)
         ; Aws.Util.option_map v.ramdisk_id (fun f -> "RamdiskId", String.to_json f)
         ; Aws.Util.option_map v.placement (fun f -> "Placement", Placement.to_json f)
         ; Aws.Util.option_map v.monitoring (fun f ->
               "Monitoring", RunInstancesMonitoringEnabled.to_json f)
         ; Some ("MinCount", Integer.to_json v.min_count)
         ; Some ("MaxCount", Integer.to_json v.max_count)
         ; Aws.Util.option_map v.key_name (fun f -> "KeyName", String.to_json f)
         ; Aws.Util.option_map v.kernel_id (fun f -> "KernelId", String.to_json f)
         ; Some ("Ipv6Address", InstanceIpv6AddressList.to_json v.ipv6_addresses)
         ; Aws.Util.option_map v.ipv6_address_count (fun f ->
               "Ipv6AddressCount", Integer.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f ->
               "InstanceType", InstanceType.to_json f)
         ; Aws.Util.option_map v.image_id (fun f -> "ImageId", String.to_json f)
         ; Some
             ( "BlockDeviceMapping"
             , BlockDeviceMappingRequestList.to_json v.block_device_mappings )
         ])

  let of_json j =
    { block_device_mappings =
        BlockDeviceMappingRequestList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "BlockDeviceMapping"))
    ; image_id = Aws.Util.option_map (Aws.Json.lookup j "ImageId") String.of_json
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "InstanceType") InstanceType.of_json
    ; ipv6_address_count =
        Aws.Util.option_map (Aws.Json.lookup j "Ipv6AddressCount") Integer.of_json
    ; ipv6_addresses =
        InstanceIpv6AddressList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Ipv6Address"))
    ; kernel_id = Aws.Util.option_map (Aws.Json.lookup j "KernelId") String.of_json
    ; key_name = Aws.Util.option_map (Aws.Json.lookup j "KeyName") String.of_json
    ; max_count = Integer.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "MaxCount"))
    ; min_count = Integer.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "MinCount"))
    ; monitoring =
        Aws.Util.option_map
          (Aws.Json.lookup j "Monitoring")
          RunInstancesMonitoringEnabled.of_json
    ; placement = Aws.Util.option_map (Aws.Json.lookup j "Placement") Placement.of_json
    ; ramdisk_id = Aws.Util.option_map (Aws.Json.lookup j "RamdiskId") String.of_json
    ; security_group_ids =
        SecurityGroupIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SecurityGroupId"))
    ; security_groups =
        SecurityGroupStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SecurityGroup"))
    ; subnet_id = Aws.Util.option_map (Aws.Json.lookup j "SubnetId") String.of_json
    ; user_data = Aws.Util.option_map (Aws.Json.lookup j "UserData") String.of_json
    ; additional_info =
        Aws.Util.option_map (Aws.Json.lookup j "additionalInfo") String.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "clientToken") String.of_json
    ; disable_api_termination =
        Aws.Util.option_map (Aws.Json.lookup j "disableApiTermination") Boolean.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; ebs_optimized =
        Aws.Util.option_map (Aws.Json.lookup j "ebsOptimized") Boolean.of_json
    ; iam_instance_profile =
        Aws.Util.option_map
          (Aws.Json.lookup j "iamInstanceProfile")
          IamInstanceProfileSpecification.of_json
    ; instance_initiated_shutdown_behavior =
        Aws.Util.option_map
          (Aws.Json.lookup j "instanceInitiatedShutdownBehavior")
          ShutdownBehavior.of_json
    ; network_interfaces =
        InstanceNetworkInterfaceSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "networkInterface"))
    ; private_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "privateIpAddress") String.of_json
    ; elastic_gpu_specification =
        ElasticGpuSpecifications.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ElasticGpuSpecification"))
    ; elastic_inference_accelerators =
        ElasticInferenceAccelerators.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ElasticInferenceAccelerator"))
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    ; launch_template =
        Aws.Util.option_map
          (Aws.Json.lookup j "LaunchTemplate")
          LaunchTemplateSpecification.of_json
    ; instance_market_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "InstanceMarketOptions")
          InstanceMarketOptionsRequest.of_json
    ; credit_specification =
        Aws.Util.option_map
          (Aws.Json.lookup j "CreditSpecification")
          CreditSpecificationRequest.of_json
    ; cpu_options =
        Aws.Util.option_map (Aws.Json.lookup j "CpuOptions") CpuOptionsRequest.of_json
    ; capacity_reservation_specification =
        Aws.Util.option_map
          (Aws.Json.lookup j "CapacityReservationSpecification")
          CapacityReservationSpecification.of_json
    ; hibernation_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "HibernationOptions")
          HibernationOptionsRequest.of_json
    ; license_specifications =
        LicenseSpecificationListRequest.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "LicenseSpecification"))
    ; metadata_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "MetadataOptions")
          InstanceMetadataOptionsRequest.of_json
    ; enclave_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "EnclaveOptions")
          EnclaveOptionsRequest.of_json
    }
end

module DeleteEgressOnlyInternetGatewayRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; egress_only_internet_gateway_id : String.t
    }

  let make ?dry_run ~egress_only_internet_gateway_id () =
    { dry_run; egress_only_internet_gateway_id }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; egress_only_internet_gateway_id =
          Aws.Xml.required
            "EgressOnlyInternetGatewayId"
            (Aws.Util.option_bind
               (Aws.Xml.member "EgressOnlyInternetGatewayId" xml)
               String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "EgressOnlyInternetGatewayId"
                , String.to_query v.egress_only_internet_gateway_id ))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "EgressOnlyInternetGatewayId"
             , String.to_json v.egress_only_internet_gateway_id )
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; egress_only_internet_gateway_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "EgressOnlyInternetGatewayId"))
    }
end

module PrefixListEntrySet = struct
  type t = PrefixListEntry.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map PrefixListEntry.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list PrefixListEntry.to_query v

  let to_json v = `List (List.map PrefixListEntry.to_json v)

  let of_json j = Aws.Json.to_list PrefixListEntry.of_json j
end

module DescribeLocalGatewayVirtualInterfacesResult = struct
  type t =
    { local_gateway_virtual_interfaces : LocalGatewayVirtualInterfaceSet.t
    ; next_token : String.t option
    }

  let make ?(local_gateway_virtual_interfaces = []) ?next_token () =
    { local_gateway_virtual_interfaces; next_token }

  let parse xml =
    Some
      { local_gateway_virtual_interfaces =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "localGatewayVirtualInterfaceSet" xml)
               LocalGatewayVirtualInterfaceSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "LocalGatewayVirtualInterfaceSet"
                , LocalGatewayVirtualInterfaceSet.to_query
                    v.local_gateway_virtual_interfaces ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "localGatewayVirtualInterfaceSet"
             , LocalGatewayVirtualInterfaceSet.to_json v.local_gateway_virtual_interfaces
             )
         ])

  let of_json j =
    { local_gateway_virtual_interfaces =
        LocalGatewayVirtualInterfaceSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "localGatewayVirtualInterfaceSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DeleteSecurityGroupRequest = struct
  type t =
    { group_id : String.t option
    ; group_name : String.t option
    ; dry_run : Boolean.t option
    }

  let make ?group_id ?group_name ?dry_run () = { group_id; group_name; dry_run }

  let parse xml =
    Some
      { group_id = Aws.Util.option_bind (Aws.Xml.member "GroupId" xml) String.parse
      ; group_name = Aws.Util.option_bind (Aws.Xml.member "GroupName" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.group_name (fun f ->
               Aws.Query.Pair ("GroupName", String.to_query f))
         ; Aws.Util.option_map v.group_id (fun f ->
               Aws.Query.Pair ("GroupId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.group_name (fun f -> "GroupName", String.to_json f)
         ; Aws.Util.option_map v.group_id (fun f -> "GroupId", String.to_json f)
         ])

  let of_json j =
    { group_id = Aws.Util.option_map (Aws.Json.lookup j "GroupId") String.of_json
    ; group_name = Aws.Util.option_map (Aws.Json.lookup j "GroupName") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module EnableFastSnapshotRestoreSuccessItem = struct
  type t =
    { snapshot_id : String.t option
    ; availability_zone : String.t option
    ; state : FastSnapshotRestoreStateCode.t option
    ; state_transition_reason : String.t option
    ; owner_id : String.t option
    ; owner_alias : String.t option
    ; enabling_time : DateTime.t option
    ; optimizing_time : DateTime.t option
    ; enabled_time : DateTime.t option
    ; disabling_time : DateTime.t option
    ; disabled_time : DateTime.t option
    }

  let make
      ?snapshot_id
      ?availability_zone
      ?state
      ?state_transition_reason
      ?owner_id
      ?owner_alias
      ?enabling_time
      ?optimizing_time
      ?enabled_time
      ?disabling_time
      ?disabled_time
      () =
    { snapshot_id
    ; availability_zone
    ; state
    ; state_transition_reason
    ; owner_id
    ; owner_alias
    ; enabling_time
    ; optimizing_time
    ; enabled_time
    ; disabling_time
    ; disabled_time
    }

  let parse xml =
    Some
      { snapshot_id = Aws.Util.option_bind (Aws.Xml.member "snapshotId" xml) String.parse
      ; availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; state =
          Aws.Util.option_bind
            (Aws.Xml.member "state" xml)
            FastSnapshotRestoreStateCode.parse
      ; state_transition_reason =
          Aws.Util.option_bind (Aws.Xml.member "stateTransitionReason" xml) String.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; owner_alias = Aws.Util.option_bind (Aws.Xml.member "ownerAlias" xml) String.parse
      ; enabling_time =
          Aws.Util.option_bind (Aws.Xml.member "enablingTime" xml) DateTime.parse
      ; optimizing_time =
          Aws.Util.option_bind (Aws.Xml.member "optimizingTime" xml) DateTime.parse
      ; enabled_time =
          Aws.Util.option_bind (Aws.Xml.member "enabledTime" xml) DateTime.parse
      ; disabling_time =
          Aws.Util.option_bind (Aws.Xml.member "disablingTime" xml) DateTime.parse
      ; disabled_time =
          Aws.Util.option_bind (Aws.Xml.member "disabledTime" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.disabled_time (fun f ->
               Aws.Query.Pair ("DisabledTime", DateTime.to_query f))
         ; Aws.Util.option_map v.disabling_time (fun f ->
               Aws.Query.Pair ("DisablingTime", DateTime.to_query f))
         ; Aws.Util.option_map v.enabled_time (fun f ->
               Aws.Query.Pair ("EnabledTime", DateTime.to_query f))
         ; Aws.Util.option_map v.optimizing_time (fun f ->
               Aws.Query.Pair ("OptimizingTime", DateTime.to_query f))
         ; Aws.Util.option_map v.enabling_time (fun f ->
               Aws.Query.Pair ("EnablingTime", DateTime.to_query f))
         ; Aws.Util.option_map v.owner_alias (fun f ->
               Aws.Query.Pair ("OwnerAlias", String.to_query f))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.state_transition_reason (fun f ->
               Aws.Query.Pair ("StateTransitionReason", String.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", FastSnapshotRestoreStateCode.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ; Aws.Util.option_map v.snapshot_id (fun f ->
               Aws.Query.Pair ("SnapshotId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.disabled_time (fun f ->
               "disabledTime", DateTime.to_json f)
         ; Aws.Util.option_map v.disabling_time (fun f ->
               "disablingTime", DateTime.to_json f)
         ; Aws.Util.option_map v.enabled_time (fun f -> "enabledTime", DateTime.to_json f)
         ; Aws.Util.option_map v.optimizing_time (fun f ->
               "optimizingTime", DateTime.to_json f)
         ; Aws.Util.option_map v.enabling_time (fun f ->
               "enablingTime", DateTime.to_json f)
         ; Aws.Util.option_map v.owner_alias (fun f -> "ownerAlias", String.to_json f)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.state_transition_reason (fun f ->
               "stateTransitionReason", String.to_json f)
         ; Aws.Util.option_map v.state (fun f ->
               "state", FastSnapshotRestoreStateCode.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ; Aws.Util.option_map v.snapshot_id (fun f -> "snapshotId", String.to_json f)
         ])

  let of_json j =
    { snapshot_id = Aws.Util.option_map (Aws.Json.lookup j "snapshotId") String.of_json
    ; availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; state =
        Aws.Util.option_map
          (Aws.Json.lookup j "state")
          FastSnapshotRestoreStateCode.of_json
    ; state_transition_reason =
        Aws.Util.option_map (Aws.Json.lookup j "stateTransitionReason") String.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; owner_alias = Aws.Util.option_map (Aws.Json.lookup j "ownerAlias") String.of_json
    ; enabling_time =
        Aws.Util.option_map (Aws.Json.lookup j "enablingTime") DateTime.of_json
    ; optimizing_time =
        Aws.Util.option_map (Aws.Json.lookup j "optimizingTime") DateTime.of_json
    ; enabled_time =
        Aws.Util.option_map (Aws.Json.lookup j "enabledTime") DateTime.of_json
    ; disabling_time =
        Aws.Util.option_map (Aws.Json.lookup j "disablingTime") DateTime.of_json
    ; disabled_time =
        Aws.Util.option_map (Aws.Json.lookup j "disabledTime") DateTime.of_json
    }
end

module SlotStartTimeRangeRequest = struct
  type t =
    { earliest_time : DateTime.t option
    ; latest_time : DateTime.t option
    }

  let make ?earliest_time ?latest_time () = { earliest_time; latest_time }

  let parse xml =
    Some
      { earliest_time =
          Aws.Util.option_bind (Aws.Xml.member "EarliestTime" xml) DateTime.parse
      ; latest_time =
          Aws.Util.option_bind (Aws.Xml.member "LatestTime" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.latest_time (fun f ->
               Aws.Query.Pair ("LatestTime", DateTime.to_query f))
         ; Aws.Util.option_map v.earliest_time (fun f ->
               Aws.Query.Pair ("EarliestTime", DateTime.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.latest_time (fun f -> "LatestTime", DateTime.to_json f)
         ; Aws.Util.option_map v.earliest_time (fun f ->
               "EarliestTime", DateTime.to_json f)
         ])

  let of_json j =
    { earliest_time =
        Aws.Util.option_map (Aws.Json.lookup j "EarliestTime") DateTime.of_json
    ; latest_time = Aws.Util.option_map (Aws.Json.lookup j "LatestTime") DateTime.of_json
    }
end

module ScheduledInstanceIdRequestSet = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map String.parse (Aws.Xml.members "ScheduledInstanceId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeScheduledInstancesRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; scheduled_instance_ids : ScheduledInstanceIdRequestSet.t
    ; slot_start_time_range : SlotStartTimeRangeRequest.t option
    }

  let make
      ?dry_run
      ?(filters = [])
      ?max_results
      ?next_token
      ?(scheduled_instance_ids = [])
      ?slot_start_time_range
      () =
    { dry_run
    ; filters
    ; max_results
    ; next_token
    ; scheduled_instance_ids
    ; slot_start_time_range
    }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; scheduled_instance_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ScheduledInstanceId" xml)
               ScheduledInstanceIdRequestSet.parse)
      ; slot_start_time_range =
          Aws.Util.option_bind
            (Aws.Xml.member "SlotStartTimeRange" xml)
            SlotStartTimeRangeRequest.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.slot_start_time_range (fun f ->
               Aws.Query.Pair ("SlotStartTimeRange", SlotStartTimeRangeRequest.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ScheduledInstanceId"
                , ScheduledInstanceIdRequestSet.to_query v.scheduled_instance_ids ))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.slot_start_time_range (fun f ->
               "SlotStartTimeRange", SlotStartTimeRangeRequest.to_json f)
         ; Some
             ( "ScheduledInstanceId"
             , ScheduledInstanceIdRequestSet.to_json v.scheduled_instance_ids )
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; scheduled_instance_ids =
        ScheduledInstanceIdRequestSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ScheduledInstanceId"))
    ; slot_start_time_range =
        Aws.Util.option_map
          (Aws.Json.lookup j "SlotStartTimeRange")
          SlotStartTimeRangeRequest.of_json
    }
end

module TransitGatewayMulticastGroup = struct
  type t =
    { group_ip_address : String.t option
    ; transit_gateway_attachment_id : String.t option
    ; subnet_id : String.t option
    ; resource_id : String.t option
    ; resource_type : TransitGatewayAttachmentResourceType.t option
    ; network_interface_id : String.t option
    ; group_member : Boolean.t option
    ; group_source : Boolean.t option
    ; member_type : MembershipType.t option
    ; source_type : MembershipType.t option
    }

  let make
      ?group_ip_address
      ?transit_gateway_attachment_id
      ?subnet_id
      ?resource_id
      ?resource_type
      ?network_interface_id
      ?group_member
      ?group_source
      ?member_type
      ?source_type
      () =
    { group_ip_address
    ; transit_gateway_attachment_id
    ; subnet_id
    ; resource_id
    ; resource_type
    ; network_interface_id
    ; group_member
    ; group_source
    ; member_type
    ; source_type
    }

  let parse xml =
    Some
      { group_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "groupIpAddress" xml) String.parse
      ; transit_gateway_attachment_id =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayAttachmentId" xml)
            String.parse
      ; subnet_id = Aws.Util.option_bind (Aws.Xml.member "subnetId" xml) String.parse
      ; resource_id = Aws.Util.option_bind (Aws.Xml.member "resourceId" xml) String.parse
      ; resource_type =
          Aws.Util.option_bind
            (Aws.Xml.member "resourceType" xml)
            TransitGatewayAttachmentResourceType.parse
      ; network_interface_id =
          Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse
      ; group_member =
          Aws.Util.option_bind (Aws.Xml.member "groupMember" xml) Boolean.parse
      ; group_source =
          Aws.Util.option_bind (Aws.Xml.member "groupSource" xml) Boolean.parse
      ; member_type =
          Aws.Util.option_bind (Aws.Xml.member "memberType" xml) MembershipType.parse
      ; source_type =
          Aws.Util.option_bind (Aws.Xml.member "sourceType" xml) MembershipType.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.source_type (fun f ->
               Aws.Query.Pair ("SourceType", MembershipType.to_query f))
         ; Aws.Util.option_map v.member_type (fun f ->
               Aws.Query.Pair ("MemberType", MembershipType.to_query f))
         ; Aws.Util.option_map v.group_source (fun f ->
               Aws.Query.Pair ("GroupSource", Boolean.to_query f))
         ; Aws.Util.option_map v.group_member (fun f ->
               Aws.Query.Pair ("GroupMember", Boolean.to_query f))
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               Aws.Query.Pair ("NetworkInterfaceId", String.to_query f))
         ; Aws.Util.option_map v.resource_type (fun f ->
               Aws.Query.Pair
                 ("ResourceType", TransitGatewayAttachmentResourceType.to_query f))
         ; Aws.Util.option_map v.resource_id (fun f ->
               Aws.Query.Pair ("ResourceId", String.to_query f))
         ; Aws.Util.option_map v.subnet_id (fun f ->
               Aws.Query.Pair ("SubnetId", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               Aws.Query.Pair ("TransitGatewayAttachmentId", String.to_query f))
         ; Aws.Util.option_map v.group_ip_address (fun f ->
               Aws.Query.Pair ("GroupIpAddress", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.source_type (fun f ->
               "sourceType", MembershipType.to_json f)
         ; Aws.Util.option_map v.member_type (fun f ->
               "memberType", MembershipType.to_json f)
         ; Aws.Util.option_map v.group_source (fun f -> "groupSource", Boolean.to_json f)
         ; Aws.Util.option_map v.group_member (fun f -> "groupMember", Boolean.to_json f)
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               "networkInterfaceId", String.to_json f)
         ; Aws.Util.option_map v.resource_type (fun f ->
               "resourceType", TransitGatewayAttachmentResourceType.to_json f)
         ; Aws.Util.option_map v.resource_id (fun f -> "resourceId", String.to_json f)
         ; Aws.Util.option_map v.subnet_id (fun f -> "subnetId", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               "transitGatewayAttachmentId", String.to_json f)
         ; Aws.Util.option_map v.group_ip_address (fun f ->
               "groupIpAddress", String.to_json f)
         ])

  let of_json j =
    { group_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "groupIpAddress") String.of_json
    ; transit_gateway_attachment_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayAttachmentId")
          String.of_json
    ; subnet_id = Aws.Util.option_map (Aws.Json.lookup j "subnetId") String.of_json
    ; resource_id = Aws.Util.option_map (Aws.Json.lookup j "resourceId") String.of_json
    ; resource_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "resourceType")
          TransitGatewayAttachmentResourceType.of_json
    ; network_interface_id =
        Aws.Util.option_map (Aws.Json.lookup j "networkInterfaceId") String.of_json
    ; group_member = Aws.Util.option_map (Aws.Json.lookup j "groupMember") Boolean.of_json
    ; group_source = Aws.Util.option_map (Aws.Json.lookup j "groupSource") Boolean.of_json
    ; member_type =
        Aws.Util.option_map (Aws.Json.lookup j "memberType") MembershipType.of_json
    ; source_type =
        Aws.Util.option_map (Aws.Json.lookup j "sourceType") MembershipType.of_json
    }
end

module TransitGatewayMulticastGroupList = struct
  type t = TransitGatewayMulticastGroup.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map TransitGatewayMulticastGroup.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list TransitGatewayMulticastGroup.to_query v

  let to_json v = `List (List.map TransitGatewayMulticastGroup.to_json v)

  let of_json j = Aws.Json.to_list TransitGatewayMulticastGroup.of_json j
end

module SearchTransitGatewayMulticastGroupsResult = struct
  type t =
    { multicast_groups : TransitGatewayMulticastGroupList.t
    ; next_token : String.t option
    }

  let make ?(multicast_groups = []) ?next_token () = { multicast_groups; next_token }

  let parse xml =
    Some
      { multicast_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "multicastGroups" xml)
               TransitGatewayMulticastGroupList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "MulticastGroups"
                , TransitGatewayMulticastGroupList.to_query v.multicast_groups ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "multicastGroups"
             , TransitGatewayMulticastGroupList.to_json v.multicast_groups )
         ])

  let of_json j =
    { multicast_groups =
        TransitGatewayMulticastGroupList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "multicastGroups"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DescribeTransitGatewayPeeringAttachmentsRequest = struct
  type t =
    { transit_gateway_attachment_ids : TransitGatewayAttachmentIdStringList.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make
      ?(transit_gateway_attachment_ids = [])
      ?(filters = [])
      ?max_results
      ?next_token
      ?dry_run
      () =
    { transit_gateway_attachment_ids; filters; max_results; next_token; dry_run }

  let parse xml =
    Some
      { transit_gateway_attachment_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayAttachmentIds" xml)
               TransitGatewayAttachmentIdStringList.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayAttachmentIds"
                , TransitGatewayAttachmentIdStringList.to_query
                    v.transit_gateway_attachment_ids ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some
             ( "TransitGatewayAttachmentIds"
             , TransitGatewayAttachmentIdStringList.to_json
                 v.transit_gateway_attachment_ids )
         ])

  let of_json j =
    { transit_gateway_attachment_ids =
        TransitGatewayAttachmentIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayAttachmentIds"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DescribeVpcEndpointConnectionsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?dry_run ?(filters = []) ?max_results ?next_token () =
    { dry_run; filters; max_results; next_token }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module SnapshotList = struct
  type t = Snapshot.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Snapshot.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Snapshot.to_query v

  let to_json v = `List (List.map Snapshot.to_json v)

  let of_json j = Aws.Json.to_list Snapshot.of_json j
end

module CarrierGatewaySet = struct
  type t = CarrierGateway.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map CarrierGateway.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list CarrierGateway.to_query v

  let to_json v = `List (List.map CarrierGateway.to_json v)

  let of_json j = Aws.Json.to_list CarrierGateway.of_json j
end

module PeeringTgwInfo = struct
  type t =
    { transit_gateway_id : String.t option
    ; owner_id : String.t option
    ; region : String.t option
    }

  let make ?transit_gateway_id ?owner_id ?region () =
    { transit_gateway_id; owner_id; region }

  let parse xml =
    Some
      { transit_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "transitGatewayId" xml) String.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; region = Aws.Util.option_bind (Aws.Xml.member "region" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.region (fun f ->
               Aws.Query.Pair ("Region", String.to_query f))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_id (fun f ->
               Aws.Query.Pair ("TransitGatewayId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.region (fun f -> "region", String.to_json f)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_id (fun f ->
               "transitGatewayId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "transitGatewayId") String.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; region = Aws.Util.option_map (Aws.Json.lookup j "region") String.of_json
    }
end

module PeeringAttachmentStatus = struct
  type t =
    { code : String.t option
    ; message : String.t option
    }

  let make ?code ?message () = { code; message }

  let parse xml =
    Some
      { code = Aws.Util.option_bind (Aws.Xml.member "code" xml) String.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair ("Code", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f)
         ; Aws.Util.option_map v.code (fun f -> "code", String.to_json f)
         ])

  let of_json j =
    { code = Aws.Util.option_map (Aws.Json.lookup j "code") String.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json
    }
end

module TransitGatewayPeeringAttachment = struct
  type t =
    { transit_gateway_attachment_id : String.t option
    ; requester_tgw_info : PeeringTgwInfo.t option
    ; accepter_tgw_info : PeeringTgwInfo.t option
    ; status : PeeringAttachmentStatus.t option
    ; state : TransitGatewayAttachmentState.t option
    ; creation_time : DateTime.t option
    ; tags : TagList.t
    }

  let make
      ?transit_gateway_attachment_id
      ?requester_tgw_info
      ?accepter_tgw_info
      ?status
      ?state
      ?creation_time
      ?(tags = [])
      () =
    { transit_gateway_attachment_id
    ; requester_tgw_info
    ; accepter_tgw_info
    ; status
    ; state
    ; creation_time
    ; tags
    }

  let parse xml =
    Some
      { transit_gateway_attachment_id =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayAttachmentId" xml)
            String.parse
      ; requester_tgw_info =
          Aws.Util.option_bind
            (Aws.Xml.member "requesterTgwInfo" xml)
            PeeringTgwInfo.parse
      ; accepter_tgw_info =
          Aws.Util.option_bind (Aws.Xml.member "accepterTgwInfo" xml) PeeringTgwInfo.parse
      ; status =
          Aws.Util.option_bind (Aws.Xml.member "status" xml) PeeringAttachmentStatus.parse
      ; state =
          Aws.Util.option_bind
            (Aws.Xml.member "state" xml)
            TransitGatewayAttachmentState.parse
      ; creation_time =
          Aws.Util.option_bind (Aws.Xml.member "creationTime" xml) DateTime.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.creation_time (fun f ->
               Aws.Query.Pair ("CreationTime", DateTime.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", TransitGatewayAttachmentState.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", PeeringAttachmentStatus.to_query f))
         ; Aws.Util.option_map v.accepter_tgw_info (fun f ->
               Aws.Query.Pair ("AccepterTgwInfo", PeeringTgwInfo.to_query f))
         ; Aws.Util.option_map v.requester_tgw_info (fun f ->
               Aws.Query.Pair ("RequesterTgwInfo", PeeringTgwInfo.to_query f))
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               Aws.Query.Pair ("TransitGatewayAttachmentId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.creation_time (fun f ->
               "creationTime", DateTime.to_json f)
         ; Aws.Util.option_map v.state (fun f ->
               "state", TransitGatewayAttachmentState.to_json f)
         ; Aws.Util.option_map v.status (fun f ->
               "status", PeeringAttachmentStatus.to_json f)
         ; Aws.Util.option_map v.accepter_tgw_info (fun f ->
               "accepterTgwInfo", PeeringTgwInfo.to_json f)
         ; Aws.Util.option_map v.requester_tgw_info (fun f ->
               "requesterTgwInfo", PeeringTgwInfo.to_json f)
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               "transitGatewayAttachmentId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_attachment_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayAttachmentId")
          String.of_json
    ; requester_tgw_info =
        Aws.Util.option_map (Aws.Json.lookup j "requesterTgwInfo") PeeringTgwInfo.of_json
    ; accepter_tgw_info =
        Aws.Util.option_map (Aws.Json.lookup j "accepterTgwInfo") PeeringTgwInfo.of_json
    ; status =
        Aws.Util.option_map (Aws.Json.lookup j "status") PeeringAttachmentStatus.of_json
    ; state =
        Aws.Util.option_map
          (Aws.Json.lookup j "state")
          TransitGatewayAttachmentState.of_json
    ; creation_time =
        Aws.Util.option_map (Aws.Json.lookup j "creationTime") DateTime.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module AcceptTransitGatewayPeeringAttachmentResult = struct
  type t =
    { transit_gateway_peering_attachment : TransitGatewayPeeringAttachment.t option }

  let make ?transit_gateway_peering_attachment () = { transit_gateway_peering_attachment }

  let parse xml =
    Some
      { transit_gateway_peering_attachment =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayPeeringAttachment" xml)
            TransitGatewayPeeringAttachment.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_peering_attachment (fun f ->
               Aws.Query.Pair
                 ( "TransitGatewayPeeringAttachment"
                 , TransitGatewayPeeringAttachment.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_peering_attachment (fun f ->
               ( "transitGatewayPeeringAttachment"
               , TransitGatewayPeeringAttachment.to_json f ))
         ])

  let of_json j =
    { transit_gateway_peering_attachment =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayPeeringAttachment")
          TransitGatewayPeeringAttachment.of_json
    }
end

module DeleteDhcpOptionsRequest = struct
  type t =
    { dhcp_options_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~dhcp_options_id ?dry_run () = { dhcp_options_id; dry_run }

  let parse xml =
    Some
      { dhcp_options_id =
          Aws.Xml.required
            "DhcpOptionsId"
            (Aws.Util.option_bind (Aws.Xml.member "DhcpOptionsId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("DhcpOptionsId", String.to_query v.dhcp_options_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("DhcpOptionsId", String.to_json v.dhcp_options_id)
         ])

  let of_json j =
    { dhcp_options_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DhcpOptionsId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module VpcEndpointType = struct
  type t =
    | Interface
    | Gateway
    | GatewayLoadBalancer

  let str_to_t =
    [ "GatewayLoadBalancer", GatewayLoadBalancer
    ; "Gateway", Gateway
    ; "Interface", Interface
    ]

  let t_to_str =
    [ GatewayLoadBalancer, "GatewayLoadBalancer"
    ; Gateway, "Gateway"
    ; Interface, "Interface"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module CreateVpcEndpointRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; vpc_endpoint_type : VpcEndpointType.t option
    ; vpc_id : String.t
    ; service_name : String.t
    ; policy_document : String.t option
    ; route_table_ids : VpcEndpointRouteTableIdList.t
    ; subnet_ids : VpcEndpointSubnetIdList.t
    ; security_group_ids : VpcEndpointSecurityGroupIdList.t
    ; client_token : String.t option
    ; private_dns_enabled : Boolean.t option
    ; tag_specifications : TagSpecificationList.t
    }

  let make
      ?dry_run
      ?vpc_endpoint_type
      ~vpc_id
      ~service_name
      ?policy_document
      ?(route_table_ids = [])
      ?(subnet_ids = [])
      ?(security_group_ids = [])
      ?client_token
      ?private_dns_enabled
      ?(tag_specifications = [])
      () =
    { dry_run
    ; vpc_endpoint_type
    ; vpc_id
    ; service_name
    ; policy_document
    ; route_table_ids
    ; subnet_ids
    ; security_group_ids
    ; client_token
    ; private_dns_enabled
    ; tag_specifications
    }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; vpc_endpoint_type =
          Aws.Util.option_bind
            (Aws.Xml.member "VpcEndpointType" xml)
            VpcEndpointType.parse
      ; vpc_id =
          Aws.Xml.required
            "VpcId"
            (Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) String.parse)
      ; service_name =
          Aws.Xml.required
            "ServiceName"
            (Aws.Util.option_bind (Aws.Xml.member "ServiceName" xml) String.parse)
      ; policy_document =
          Aws.Util.option_bind (Aws.Xml.member "PolicyDocument" xml) String.parse
      ; route_table_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "RouteTableId" xml)
               VpcEndpointRouteTableIdList.parse)
      ; subnet_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SubnetId" xml)
               VpcEndpointSubnetIdList.parse)
      ; security_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SecurityGroupId" xml)
               VpcEndpointSecurityGroupIdList.parse)
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; private_dns_enabled =
          Aws.Util.option_bind (Aws.Xml.member "PrivateDnsEnabled" xml) Boolean.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Aws.Util.option_map v.private_dns_enabled (fun f ->
               Aws.Query.Pair ("PrivateDnsEnabled", Boolean.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "SecurityGroupId"
                , VpcEndpointSecurityGroupIdList.to_query v.security_group_ids ))
         ; Some
             (Aws.Query.Pair ("SubnetId", VpcEndpointSubnetIdList.to_query v.subnet_ids))
         ; Some
             (Aws.Query.Pair
                ("RouteTableId", VpcEndpointRouteTableIdList.to_query v.route_table_ids))
         ; Aws.Util.option_map v.policy_document (fun f ->
               Aws.Query.Pair ("PolicyDocument", String.to_query f))
         ; Some (Aws.Query.Pair ("ServiceName", String.to_query v.service_name))
         ; Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ; Aws.Util.option_map v.vpc_endpoint_type (fun f ->
               Aws.Query.Pair ("VpcEndpointType", VpcEndpointType.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Aws.Util.option_map v.private_dns_enabled (fun f ->
               "PrivateDnsEnabled", Boolean.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Some
             ( "SecurityGroupId"
             , VpcEndpointSecurityGroupIdList.to_json v.security_group_ids )
         ; Some ("SubnetId", VpcEndpointSubnetIdList.to_json v.subnet_ids)
         ; Some ("RouteTableId", VpcEndpointRouteTableIdList.to_json v.route_table_ids)
         ; Aws.Util.option_map v.policy_document (fun f ->
               "PolicyDocument", String.to_json f)
         ; Some ("ServiceName", String.to_json v.service_name)
         ; Some ("VpcId", String.to_json v.vpc_id)
         ; Aws.Util.option_map v.vpc_endpoint_type (fun f ->
               "VpcEndpointType", VpcEndpointType.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; vpc_endpoint_type =
        Aws.Util.option_map (Aws.Json.lookup j "VpcEndpointType") VpcEndpointType.of_json
    ; vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcId"))
    ; service_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ServiceName"))
    ; policy_document =
        Aws.Util.option_map (Aws.Json.lookup j "PolicyDocument") String.of_json
    ; route_table_ids =
        VpcEndpointRouteTableIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "RouteTableId"))
    ; subnet_ids =
        VpcEndpointSubnetIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SubnetId"))
    ; security_group_ids =
        VpcEndpointSecurityGroupIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SecurityGroupId"))
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; private_dns_enabled =
        Aws.Util.option_map (Aws.Json.lookup j "PrivateDnsEnabled") Boolean.of_json
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    }
end

module PlacementGroup = struct
  type t =
    { group_name : String.t option
    ; state : PlacementGroupState.t option
    ; strategy : PlacementStrategy.t option
    ; partition_count : Integer.t option
    ; group_id : String.t option
    ; tags : TagList.t
    }

  let make ?group_name ?state ?strategy ?partition_count ?group_id ?(tags = []) () =
    { group_name; state; strategy; partition_count; group_id; tags }

  let parse xml =
    Some
      { group_name = Aws.Util.option_bind (Aws.Xml.member "groupName" xml) String.parse
      ; state =
          Aws.Util.option_bind (Aws.Xml.member "state" xml) PlacementGroupState.parse
      ; strategy =
          Aws.Util.option_bind (Aws.Xml.member "strategy" xml) PlacementStrategy.parse
      ; partition_count =
          Aws.Util.option_bind (Aws.Xml.member "partitionCount" xml) Integer.parse
      ; group_id = Aws.Util.option_bind (Aws.Xml.member "groupId" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.group_id (fun f ->
               Aws.Query.Pair ("GroupId", String.to_query f))
         ; Aws.Util.option_map v.partition_count (fun f ->
               Aws.Query.Pair ("PartitionCount", Integer.to_query f))
         ; Aws.Util.option_map v.strategy (fun f ->
               Aws.Query.Pair ("Strategy", PlacementStrategy.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", PlacementGroupState.to_query f))
         ; Aws.Util.option_map v.group_name (fun f ->
               Aws.Query.Pair ("GroupName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.group_id (fun f -> "groupId", String.to_json f)
         ; Aws.Util.option_map v.partition_count (fun f ->
               "partitionCount", Integer.to_json f)
         ; Aws.Util.option_map v.strategy (fun f ->
               "strategy", PlacementStrategy.to_json f)
         ; Aws.Util.option_map v.state (fun f -> "state", PlacementGroupState.to_json f)
         ; Aws.Util.option_map v.group_name (fun f -> "groupName", String.to_json f)
         ])

  let of_json j =
    { group_name = Aws.Util.option_map (Aws.Json.lookup j "groupName") String.of_json
    ; state = Aws.Util.option_map (Aws.Json.lookup j "state") PlacementGroupState.of_json
    ; strategy =
        Aws.Util.option_map (Aws.Json.lookup j "strategy") PlacementStrategy.of_json
    ; partition_count =
        Aws.Util.option_map (Aws.Json.lookup j "partitionCount") Integer.of_json
    ; group_id = Aws.Util.option_map (Aws.Json.lookup j "groupId") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module CreatePlacementGroupResult = struct
  type t = { placement_group : PlacementGroup.t option }

  let make ?placement_group () = { placement_group }

  let parse xml =
    Some
      { placement_group =
          Aws.Util.option_bind (Aws.Xml.member "placementGroup" xml) PlacementGroup.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.placement_group (fun f ->
               Aws.Query.Pair ("PlacementGroup", PlacementGroup.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.placement_group (fun f ->
               "placementGroup", PlacementGroup.to_json f)
         ])

  let of_json j =
    { placement_group =
        Aws.Util.option_map (Aws.Json.lookup j "placementGroup") PlacementGroup.of_json
    }
end

module ReservedInstancesModificationResultList = struct
  type t = ReservedInstancesModificationResult.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ReservedInstancesModificationResult.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ReservedInstancesModificationResult.to_query v

  let to_json v = `List (List.map ReservedInstancesModificationResult.to_json v)

  let of_json j = Aws.Json.to_list ReservedInstancesModificationResult.of_json j
end

module CapacityReservationGroup = struct
  type t =
    { group_arn : String.t option
    ; owner_id : String.t option
    }

  let make ?group_arn ?owner_id () = { group_arn; owner_id }

  let parse xml =
    Some
      { group_arn = Aws.Util.option_bind (Aws.Xml.member "groupArn" xml) String.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.group_arn (fun f ->
               Aws.Query.Pair ("GroupArn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.group_arn (fun f -> "groupArn", String.to_json f)
         ])

  let of_json j =
    { group_arn = Aws.Util.option_map (Aws.Json.lookup j "groupArn") String.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    }
end

module CapacityReservationGroupSet = struct
  type t = CapacityReservationGroup.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map CapacityReservationGroup.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list CapacityReservationGroup.to_query v

  let to_json v = `List (List.map CapacityReservationGroup.to_json v)

  let of_json j = Aws.Json.to_list CapacityReservationGroup.of_json j
end

module GetGroupsForCapacityReservationResult = struct
  type t =
    { next_token : String.t option
    ; capacity_reservation_groups : CapacityReservationGroupSet.t
    }

  let make ?next_token ?(capacity_reservation_groups = []) () =
    { next_token; capacity_reservation_groups }

  let parse xml =
    Some
      { next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; capacity_reservation_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "capacityReservationGroupSet" xml)
               CapacityReservationGroupSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "CapacityReservationGroupSet"
                , CapacityReservationGroupSet.to_query v.capacity_reservation_groups ))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "capacityReservationGroupSet"
             , CapacityReservationGroupSet.to_json v.capacity_reservation_groups )
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ])

  let of_json j =
    { next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; capacity_reservation_groups =
        CapacityReservationGroupSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "capacityReservationGroupSet"))
    }
end

module ReservedIntancesIds = struct
  type t = ReservedInstancesId.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ReservedInstancesId.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ReservedInstancesId.to_query v

  let to_json v = `List (List.map ReservedInstancesId.to_json v)

  let of_json j = Aws.Json.to_list ReservedInstancesId.of_json j
end

module ReservedInstancesModification = struct
  type t =
    { client_token : String.t option
    ; create_date : DateTime.t option
    ; effective_date : DateTime.t option
    ; modification_results : ReservedInstancesModificationResultList.t
    ; reserved_instances_ids : ReservedIntancesIds.t
    ; reserved_instances_modification_id : String.t option
    ; status : String.t option
    ; status_message : String.t option
    ; update_date : DateTime.t option
    }

  let make
      ?client_token
      ?create_date
      ?effective_date
      ?(modification_results = [])
      ?(reserved_instances_ids = [])
      ?reserved_instances_modification_id
      ?status
      ?status_message
      ?update_date
      () =
    { client_token
    ; create_date
    ; effective_date
    ; modification_results
    ; reserved_instances_ids
    ; reserved_instances_modification_id
    ; status
    ; status_message
    ; update_date
    }

  let parse xml =
    Some
      { client_token =
          Aws.Util.option_bind (Aws.Xml.member "clientToken" xml) String.parse
      ; create_date =
          Aws.Util.option_bind (Aws.Xml.member "createDate" xml) DateTime.parse
      ; effective_date =
          Aws.Util.option_bind (Aws.Xml.member "effectiveDate" xml) DateTime.parse
      ; modification_results =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "modificationResultSet" xml)
               ReservedInstancesModificationResultList.parse)
      ; reserved_instances_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "reservedInstancesSet" xml)
               ReservedIntancesIds.parse)
      ; reserved_instances_modification_id =
          Aws.Util.option_bind
            (Aws.Xml.member "reservedInstancesModificationId" xml)
            String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "status" xml) String.parse
      ; status_message =
          Aws.Util.option_bind (Aws.Xml.member "statusMessage" xml) String.parse
      ; update_date =
          Aws.Util.option_bind (Aws.Xml.member "updateDate" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.update_date (fun f ->
               Aws.Query.Pair ("UpdateDate", DateTime.to_query f))
         ; Aws.Util.option_map v.status_message (fun f ->
               Aws.Query.Pair ("StatusMessage", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.reserved_instances_modification_id (fun f ->
               Aws.Query.Pair ("ReservedInstancesModificationId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ReservedInstancesSet"
                , ReservedIntancesIds.to_query v.reserved_instances_ids ))
         ; Some
             (Aws.Query.Pair
                ( "ModificationResultSet"
                , ReservedInstancesModificationResultList.to_query v.modification_results
                ))
         ; Aws.Util.option_map v.effective_date (fun f ->
               Aws.Query.Pair ("EffectiveDate", DateTime.to_query f))
         ; Aws.Util.option_map v.create_date (fun f ->
               Aws.Query.Pair ("CreateDate", DateTime.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.update_date (fun f -> "updateDate", DateTime.to_json f)
         ; Aws.Util.option_map v.status_message (fun f ->
               "statusMessage", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "status", String.to_json f)
         ; Aws.Util.option_map v.reserved_instances_modification_id (fun f ->
               "reservedInstancesModificationId", String.to_json f)
         ; Some
             ("reservedInstancesSet", ReservedIntancesIds.to_json v.reserved_instances_ids)
         ; Some
             ( "modificationResultSet"
             , ReservedInstancesModificationResultList.to_json v.modification_results )
         ; Aws.Util.option_map v.effective_date (fun f ->
               "effectiveDate", DateTime.to_json f)
         ; Aws.Util.option_map v.create_date (fun f -> "createDate", DateTime.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "clientToken", String.to_json f)
         ])

  let of_json j =
    { client_token = Aws.Util.option_map (Aws.Json.lookup j "clientToken") String.of_json
    ; create_date = Aws.Util.option_map (Aws.Json.lookup j "createDate") DateTime.of_json
    ; effective_date =
        Aws.Util.option_map (Aws.Json.lookup j "effectiveDate") DateTime.of_json
    ; modification_results =
        ReservedInstancesModificationResultList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "modificationResultSet"))
    ; reserved_instances_ids =
        ReservedIntancesIds.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "reservedInstancesSet"))
    ; reserved_instances_modification_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "reservedInstancesModificationId")
          String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "status") String.of_json
    ; status_message =
        Aws.Util.option_map (Aws.Json.lookup j "statusMessage") String.of_json
    ; update_date = Aws.Util.option_map (Aws.Json.lookup j "updateDate") DateTime.of_json
    }
end

module ReservedInstancesModificationList = struct
  type t = ReservedInstancesModification.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ReservedInstancesModification.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ReservedInstancesModification.to_query v

  let to_json v = `List (List.map ReservedInstancesModification.to_json v)

  let of_json j = Aws.Json.to_list ReservedInstancesModification.of_json j
end

module DescribeCarrierGatewaysResult = struct
  type t =
    { carrier_gateways : CarrierGatewaySet.t
    ; next_token : String.t option
    }

  let make ?(carrier_gateways = []) ?next_token () = { carrier_gateways; next_token }

  let parse xml =
    Some
      { carrier_gateways =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "carrierGatewaySet" xml)
               CarrierGatewaySet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("CarrierGatewaySet", CarrierGatewaySet.to_query v.carrier_gateways))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("carrierGatewaySet", CarrierGatewaySet.to_json v.carrier_gateways)
         ])

  let of_json j =
    { carrier_gateways =
        CarrierGatewaySet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "carrierGatewaySet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module LaunchTemplateVersion = struct
  type t =
    { launch_template_id : String.t option
    ; launch_template_name : String.t option
    ; version_number : Long.t option
    ; version_description : String.t option
    ; create_time : DateTime.t option
    ; created_by : String.t option
    ; default_version : Boolean.t option
    ; launch_template_data : ResponseLaunchTemplateData.t option
    }

  let make
      ?launch_template_id
      ?launch_template_name
      ?version_number
      ?version_description
      ?create_time
      ?created_by
      ?default_version
      ?launch_template_data
      () =
    { launch_template_id
    ; launch_template_name
    ; version_number
    ; version_description
    ; create_time
    ; created_by
    ; default_version
    ; launch_template_data
    }

  let parse xml =
    Some
      { launch_template_id =
          Aws.Util.option_bind (Aws.Xml.member "launchTemplateId" xml) String.parse
      ; launch_template_name =
          Aws.Util.option_bind (Aws.Xml.member "launchTemplateName" xml) String.parse
      ; version_number =
          Aws.Util.option_bind (Aws.Xml.member "versionNumber" xml) Long.parse
      ; version_description =
          Aws.Util.option_bind (Aws.Xml.member "versionDescription" xml) String.parse
      ; create_time =
          Aws.Util.option_bind (Aws.Xml.member "createTime" xml) DateTime.parse
      ; created_by = Aws.Util.option_bind (Aws.Xml.member "createdBy" xml) String.parse
      ; default_version =
          Aws.Util.option_bind (Aws.Xml.member "defaultVersion" xml) Boolean.parse
      ; launch_template_data =
          Aws.Util.option_bind
            (Aws.Xml.member "launchTemplateData" xml)
            ResponseLaunchTemplateData.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.launch_template_data (fun f ->
               Aws.Query.Pair ("LaunchTemplateData", ResponseLaunchTemplateData.to_query f))
         ; Aws.Util.option_map v.default_version (fun f ->
               Aws.Query.Pair ("DefaultVersion", Boolean.to_query f))
         ; Aws.Util.option_map v.created_by (fun f ->
               Aws.Query.Pair ("CreatedBy", String.to_query f))
         ; Aws.Util.option_map v.create_time (fun f ->
               Aws.Query.Pair ("CreateTime", DateTime.to_query f))
         ; Aws.Util.option_map v.version_description (fun f ->
               Aws.Query.Pair ("VersionDescription", String.to_query f))
         ; Aws.Util.option_map v.version_number (fun f ->
               Aws.Query.Pair ("VersionNumber", Long.to_query f))
         ; Aws.Util.option_map v.launch_template_name (fun f ->
               Aws.Query.Pair ("LaunchTemplateName", String.to_query f))
         ; Aws.Util.option_map v.launch_template_id (fun f ->
               Aws.Query.Pair ("LaunchTemplateId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.launch_template_data (fun f ->
               "launchTemplateData", ResponseLaunchTemplateData.to_json f)
         ; Aws.Util.option_map v.default_version (fun f ->
               "defaultVersion", Boolean.to_json f)
         ; Aws.Util.option_map v.created_by (fun f -> "createdBy", String.to_json f)
         ; Aws.Util.option_map v.create_time (fun f -> "createTime", DateTime.to_json f)
         ; Aws.Util.option_map v.version_description (fun f ->
               "versionDescription", String.to_json f)
         ; Aws.Util.option_map v.version_number (fun f -> "versionNumber", Long.to_json f)
         ; Aws.Util.option_map v.launch_template_name (fun f ->
               "launchTemplateName", String.to_json f)
         ; Aws.Util.option_map v.launch_template_id (fun f ->
               "launchTemplateId", String.to_json f)
         ])

  let of_json j =
    { launch_template_id =
        Aws.Util.option_map (Aws.Json.lookup j "launchTemplateId") String.of_json
    ; launch_template_name =
        Aws.Util.option_map (Aws.Json.lookup j "launchTemplateName") String.of_json
    ; version_number =
        Aws.Util.option_map (Aws.Json.lookup j "versionNumber") Long.of_json
    ; version_description =
        Aws.Util.option_map (Aws.Json.lookup j "versionDescription") String.of_json
    ; create_time = Aws.Util.option_map (Aws.Json.lookup j "createTime") DateTime.of_json
    ; created_by = Aws.Util.option_map (Aws.Json.lookup j "createdBy") String.of_json
    ; default_version =
        Aws.Util.option_map (Aws.Json.lookup j "defaultVersion") Boolean.of_json
    ; launch_template_data =
        Aws.Util.option_map
          (Aws.Json.lookup j "launchTemplateData")
          ResponseLaunchTemplateData.of_json
    }
end

module LaunchTemplateVersionSet = struct
  type t = LaunchTemplateVersion.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map LaunchTemplateVersion.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list LaunchTemplateVersion.to_query v

  let to_json v = `List (List.map LaunchTemplateVersion.to_json v)

  let of_json j = Aws.Json.to_list LaunchTemplateVersion.of_json j
end

module DescribeLaunchTemplateVersionsResult = struct
  type t =
    { launch_template_versions : LaunchTemplateVersionSet.t
    ; next_token : String.t option
    }

  let make ?(launch_template_versions = []) ?next_token () =
    { launch_template_versions; next_token }

  let parse xml =
    Some
      { launch_template_versions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "launchTemplateVersionSet" xml)
               LaunchTemplateVersionSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "LaunchTemplateVersionSet"
                , LaunchTemplateVersionSet.to_query v.launch_template_versions ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "launchTemplateVersionSet"
             , LaunchTemplateVersionSet.to_json v.launch_template_versions )
         ])

  let of_json j =
    { launch_template_versions =
        LaunchTemplateVersionSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "launchTemplateVersionSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DeleteVpcEndpointsResult = struct
  type t = { unsuccessful : UnsuccessfulItemSet.t }

  let make ?(unsuccessful = []) () = { unsuccessful }

  let parse xml =
    Some
      { unsuccessful =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "unsuccessful" xml)
               UnsuccessfulItemSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("Unsuccessful", UnsuccessfulItemSet.to_query v.unsuccessful))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("unsuccessful", UnsuccessfulItemSet.to_json v.unsuccessful) ])

  let of_json j =
    { unsuccessful =
        UnsuccessfulItemSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "unsuccessful"))
    }
end

module CreateRouteResult = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module TerminateInstancesRequest = struct
  type t =
    { instance_ids : InstanceIdStringList.t
    ; dry_run : Boolean.t option
    }

  let make ~instance_ids ?dry_run () = { instance_ids; dry_run }

  let parse xml =
    Some
      { instance_ids =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind
               (Aws.Xml.member "InstanceId" xml)
               InstanceIdStringList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair ("InstanceId", InstanceIdStringList.to_query v.instance_ids))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("InstanceId", InstanceIdStringList.to_json v.instance_ids)
         ])

  let of_json j =
    { instance_ids =
        InstanceIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module ModifyVpcEndpointResult = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module IamInstanceProfileAssociationSet = struct
  type t = IamInstanceProfileAssociation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map IamInstanceProfileAssociation.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list IamInstanceProfileAssociation.to_query v

  let to_json v = `List (List.map IamInstanceProfileAssociation.to_json v)

  let of_json j = Aws.Json.to_list IamInstanceProfileAssociation.of_json j
end

module DescribeIamInstanceProfileAssociationsResult = struct
  type t =
    { iam_instance_profile_associations : IamInstanceProfileAssociationSet.t
    ; next_token : String.t option
    }

  let make ?(iam_instance_profile_associations = []) ?next_token () =
    { iam_instance_profile_associations; next_token }

  let parse xml =
    Some
      { iam_instance_profile_associations =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "iamInstanceProfileAssociationSet" xml)
               IamInstanceProfileAssociationSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "IamInstanceProfileAssociationSet"
                , IamInstanceProfileAssociationSet.to_query
                    v.iam_instance_profile_associations ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "iamInstanceProfileAssociationSet"
             , IamInstanceProfileAssociationSet.to_json
                 v.iam_instance_profile_associations )
         ])

  let of_json j =
    { iam_instance_profile_associations =
        IamInstanceProfileAssociationSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "iamInstanceProfileAssociationSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module RejectVpcPeeringConnectionResult = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module ModifyVpcAttributeRequest = struct
  type t =
    { enable_dns_hostnames : AttributeBooleanValue.t option
    ; enable_dns_support : AttributeBooleanValue.t option
    ; vpc_id : String.t
    }

  let make ?enable_dns_hostnames ?enable_dns_support ~vpc_id () =
    { enable_dns_hostnames; enable_dns_support; vpc_id }

  let parse xml =
    Some
      { enable_dns_hostnames =
          Aws.Util.option_bind
            (Aws.Xml.member "EnableDnsHostnames" xml)
            AttributeBooleanValue.parse
      ; enable_dns_support =
          Aws.Util.option_bind
            (Aws.Xml.member "EnableDnsSupport" xml)
            AttributeBooleanValue.parse
      ; vpc_id =
          Aws.Xml.required
            "vpcId"
            (Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ; Aws.Util.option_map v.enable_dns_support (fun f ->
               Aws.Query.Pair ("EnableDnsSupport", AttributeBooleanValue.to_query f))
         ; Aws.Util.option_map v.enable_dns_hostnames (fun f ->
               Aws.Query.Pair ("EnableDnsHostnames", AttributeBooleanValue.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("vpcId", String.to_json v.vpc_id)
         ; Aws.Util.option_map v.enable_dns_support (fun f ->
               "EnableDnsSupport", AttributeBooleanValue.to_json f)
         ; Aws.Util.option_map v.enable_dns_hostnames (fun f ->
               "EnableDnsHostnames", AttributeBooleanValue.to_json f)
         ])

  let of_json j =
    { enable_dns_hostnames =
        Aws.Util.option_map
          (Aws.Json.lookup j "EnableDnsHostnames")
          AttributeBooleanValue.of_json
    ; enable_dns_support =
        Aws.Util.option_map
          (Aws.Json.lookup j "EnableDnsSupport")
          AttributeBooleanValue.of_json
    ; vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "vpcId"))
    }
end

module PurchaseReservedInstancesOfferingResult = struct
  type t = { reserved_instances_id : String.t option }

  let make ?reserved_instances_id () = { reserved_instances_id }

  let parse xml =
    Some
      { reserved_instances_id =
          Aws.Util.option_bind (Aws.Xml.member "reservedInstancesId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.reserved_instances_id (fun f ->
               Aws.Query.Pair ("ReservedInstancesId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.reserved_instances_id (fun f ->
               "reservedInstancesId", String.to_json f)
         ])

  let of_json j =
    { reserved_instances_id =
        Aws.Util.option_map (Aws.Json.lookup j "reservedInstancesId") String.of_json
    }
end

module CreateNetworkInterfacePermissionRequest = struct
  type t =
    { network_interface_id : String.t
    ; aws_account_id : String.t option
    ; aws_service : String.t option
    ; permission : InterfacePermissionType.t
    ; dry_run : Boolean.t option
    }

  let make ~network_interface_id ?aws_account_id ?aws_service ~permission ?dry_run () =
    { network_interface_id; aws_account_id; aws_service; permission; dry_run }

  let parse xml =
    Some
      { network_interface_id =
          Aws.Xml.required
            "NetworkInterfaceId"
            (Aws.Util.option_bind (Aws.Xml.member "NetworkInterfaceId" xml) String.parse)
      ; aws_account_id =
          Aws.Util.option_bind (Aws.Xml.member "AwsAccountId" xml) String.parse
      ; aws_service = Aws.Util.option_bind (Aws.Xml.member "AwsService" xml) String.parse
      ; permission =
          Aws.Xml.required
            "Permission"
            (Aws.Util.option_bind
               (Aws.Xml.member "Permission" xml)
               InterfacePermissionType.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair ("Permission", InterfacePermissionType.to_query v.permission))
         ; Aws.Util.option_map v.aws_service (fun f ->
               Aws.Query.Pair ("AwsService", String.to_query f))
         ; Aws.Util.option_map v.aws_account_id (fun f ->
               Aws.Query.Pair ("AwsAccountId", String.to_query f))
         ; Some
             (Aws.Query.Pair ("NetworkInterfaceId", String.to_query v.network_interface_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("Permission", InterfacePermissionType.to_json v.permission)
         ; Aws.Util.option_map v.aws_service (fun f -> "AwsService", String.to_json f)
         ; Aws.Util.option_map v.aws_account_id (fun f ->
               "AwsAccountId", String.to_json f)
         ; Some ("NetworkInterfaceId", String.to_json v.network_interface_id)
         ])

  let of_json j =
    { network_interface_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "NetworkInterfaceId"))
    ; aws_account_id =
        Aws.Util.option_map (Aws.Json.lookup j "AwsAccountId") String.of_json
    ; aws_service = Aws.Util.option_map (Aws.Json.lookup j "AwsService") String.of_json
    ; permission =
        InterfacePermissionType.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Permission"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module CreateDefaultSubnetRequest = struct
  type t =
    { availability_zone : String.t
    ; dry_run : Boolean.t option
    }

  let make ~availability_zone ?dry_run () = { availability_zone; dry_run }

  let parse xml =
    Some
      { availability_zone =
          Aws.Xml.required
            "AvailabilityZone"
            (Aws.Util.option_bind (Aws.Xml.member "AvailabilityZone" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("AvailabilityZone", String.to_query v.availability_zone))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("AvailabilityZone", String.to_json v.availability_zone)
         ])

  let of_json j =
    { availability_zone =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "AvailabilityZone"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module EnableVpcClassicLinkResult = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module CreateFleetInstance = struct
  type t =
    { launch_template_and_overrides : LaunchTemplateAndOverridesResponse.t option
    ; lifecycle : InstanceLifecycle.t option
    ; instance_ids : InstanceIdsSet.t
    ; instance_type : InstanceType.t option
    ; platform : PlatformValues.t option
    }

  let make
      ?launch_template_and_overrides
      ?lifecycle
      ?(instance_ids = [])
      ?instance_type
      ?platform
      () =
    { launch_template_and_overrides; lifecycle; instance_ids; instance_type; platform }

  let parse xml =
    Some
      { launch_template_and_overrides =
          Aws.Util.option_bind
            (Aws.Xml.member "launchTemplateAndOverrides" xml)
            LaunchTemplateAndOverridesResponse.parse
      ; lifecycle =
          Aws.Util.option_bind (Aws.Xml.member "lifecycle" xml) InstanceLifecycle.parse
      ; instance_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "instanceIds" xml) InstanceIdsSet.parse)
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) InstanceType.parse
      ; platform =
          Aws.Util.option_bind (Aws.Xml.member "platform" xml) PlatformValues.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.platform (fun f ->
               Aws.Query.Pair ("Platform", PlatformValues.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", InstanceType.to_query f))
         ; Some (Aws.Query.Pair ("InstanceIds", InstanceIdsSet.to_query v.instance_ids))
         ; Aws.Util.option_map v.lifecycle (fun f ->
               Aws.Query.Pair ("Lifecycle", InstanceLifecycle.to_query f))
         ; Aws.Util.option_map v.launch_template_and_overrides (fun f ->
               Aws.Query.Pair
                 ( "LaunchTemplateAndOverrides"
                 , LaunchTemplateAndOverridesResponse.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.platform (fun f -> "platform", PlatformValues.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f ->
               "instanceType", InstanceType.to_json f)
         ; Some ("instanceIds", InstanceIdsSet.to_json v.instance_ids)
         ; Aws.Util.option_map v.lifecycle (fun f ->
               "lifecycle", InstanceLifecycle.to_json f)
         ; Aws.Util.option_map v.launch_template_and_overrides (fun f ->
               "launchTemplateAndOverrides", LaunchTemplateAndOverridesResponse.to_json f)
         ])

  let of_json j =
    { launch_template_and_overrides =
        Aws.Util.option_map
          (Aws.Json.lookup j "launchTemplateAndOverrides")
          LaunchTemplateAndOverridesResponse.of_json
    ; lifecycle =
        Aws.Util.option_map (Aws.Json.lookup j "lifecycle") InstanceLifecycle.of_json
    ; instance_ids =
        InstanceIdsSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceIds"))
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") InstanceType.of_json
    ; platform = Aws.Util.option_map (Aws.Json.lookup j "platform") PlatformValues.of_json
    }
end

module ReleaseHostsResult = struct
  type t =
    { successful : ResponseHostIdList.t
    ; unsuccessful : UnsuccessfulItemList.t
    }

  let make ?(successful = []) ?(unsuccessful = []) () = { successful; unsuccessful }

  let parse xml =
    Some
      { successful =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "successful" xml)
               ResponseHostIdList.parse)
      ; unsuccessful =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "unsuccessful" xml)
               UnsuccessfulItemList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("Unsuccessful", UnsuccessfulItemList.to_query v.unsuccessful))
         ; Some (Aws.Query.Pair ("Successful", ResponseHostIdList.to_query v.successful))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("unsuccessful", UnsuccessfulItemList.to_json v.unsuccessful)
         ; Some ("successful", ResponseHostIdList.to_json v.successful)
         ])

  let of_json j =
    { successful =
        ResponseHostIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "successful"))
    ; unsuccessful =
        UnsuccessfulItemList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "unsuccessful"))
    }
end

module LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest = struct
  type t =
    { local_gateway_route_table_virtual_interface_group_association_ids :
        LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make
      ?(local_gateway_route_table_virtual_interface_group_association_ids = [])
      ?(filters = [])
      ?max_results
      ?next_token
      ?dry_run
      () =
    { local_gateway_route_table_virtual_interface_group_association_ids
    ; filters
    ; max_results
    ; next_token
    ; dry_run
    }

  let parse xml =
    Some
      { local_gateway_route_table_virtual_interface_group_association_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member
                  "LocalGatewayRouteTableVirtualInterfaceGroupAssociationId"
                  xml)
               LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ( "LocalGatewayRouteTableVirtualInterfaceGroupAssociationId"
                , LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet.to_query
                    v.local_gateway_route_table_virtual_interface_group_association_ids ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some
             ( "LocalGatewayRouteTableVirtualInterfaceGroupAssociationId"
             , LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet.to_json
                 v.local_gateway_route_table_virtual_interface_group_association_ids )
         ])

  let of_json j =
    { local_gateway_route_table_virtual_interface_group_association_ids =
        LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet.of_json
          (Aws.Util.of_option_exn
             (Aws.Json.lookup
                j
                "LocalGatewayRouteTableVirtualInterfaceGroupAssociationId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module ModifyVpcEndpointConnectionNotificationResult = struct
  type t = { return_value : Boolean.t option }

  let make ?return_value () = { return_value }

  let parse xml =
    Some
      { return_value = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return_value (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return_value (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return_value = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module HostProperties = struct
  type t =
    { cores : Integer.t option
    ; instance_type : String.t option
    ; instance_family : String.t option
    ; sockets : Integer.t option
    ; total_v_cpus : Integer.t option
    }

  let make ?cores ?instance_type ?instance_family ?sockets ?total_v_cpus () =
    { cores; instance_type; instance_family; sockets; total_v_cpus }

  let parse xml =
    Some
      { cores = Aws.Util.option_bind (Aws.Xml.member "cores" xml) Integer.parse
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) String.parse
      ; instance_family =
          Aws.Util.option_bind (Aws.Xml.member "instanceFamily" xml) String.parse
      ; sockets = Aws.Util.option_bind (Aws.Xml.member "sockets" xml) Integer.parse
      ; total_v_cpus =
          Aws.Util.option_bind (Aws.Xml.member "totalVCpus" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.total_v_cpus (fun f ->
               Aws.Query.Pair ("TotalVCpus", Integer.to_query f))
         ; Aws.Util.option_map v.sockets (fun f ->
               Aws.Query.Pair ("Sockets", Integer.to_query f))
         ; Aws.Util.option_map v.instance_family (fun f ->
               Aws.Query.Pair ("InstanceFamily", String.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", String.to_query f))
         ; Aws.Util.option_map v.cores (fun f ->
               Aws.Query.Pair ("Cores", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.total_v_cpus (fun f -> "totalVCpus", Integer.to_json f)
         ; Aws.Util.option_map v.sockets (fun f -> "sockets", Integer.to_json f)
         ; Aws.Util.option_map v.instance_family (fun f ->
               "instanceFamily", String.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f -> "instanceType", String.to_json f)
         ; Aws.Util.option_map v.cores (fun f -> "cores", Integer.to_json f)
         ])

  let of_json j =
    { cores = Aws.Util.option_map (Aws.Json.lookup j "cores") Integer.of_json
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") String.of_json
    ; instance_family =
        Aws.Util.option_map (Aws.Json.lookup j "instanceFamily") String.of_json
    ; sockets = Aws.Util.option_map (Aws.Json.lookup j "sockets") Integer.of_json
    ; total_v_cpus = Aws.Util.option_map (Aws.Json.lookup j "totalVCpus") Integer.of_json
    }
end

module DisassociateSubnetCidrBlockResult = struct
  type t =
    { ipv6_cidr_block_association : SubnetIpv6CidrBlockAssociation.t option
    ; subnet_id : String.t option
    }

  let make ?ipv6_cidr_block_association ?subnet_id () =
    { ipv6_cidr_block_association; subnet_id }

  let parse xml =
    Some
      { ipv6_cidr_block_association =
          Aws.Util.option_bind
            (Aws.Xml.member "ipv6CidrBlockAssociation" xml)
            SubnetIpv6CidrBlockAssociation.parse
      ; subnet_id = Aws.Util.option_bind (Aws.Xml.member "subnetId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.subnet_id (fun f ->
               Aws.Query.Pair ("SubnetId", String.to_query f))
         ; Aws.Util.option_map v.ipv6_cidr_block_association (fun f ->
               Aws.Query.Pair
                 ("Ipv6CidrBlockAssociation", SubnetIpv6CidrBlockAssociation.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.subnet_id (fun f -> "subnetId", String.to_json f)
         ; Aws.Util.option_map v.ipv6_cidr_block_association (fun f ->
               "ipv6CidrBlockAssociation", SubnetIpv6CidrBlockAssociation.to_json f)
         ])

  let of_json j =
    { ipv6_cidr_block_association =
        Aws.Util.option_map
          (Aws.Json.lookup j "ipv6CidrBlockAssociation")
          SubnetIpv6CidrBlockAssociation.of_json
    ; subnet_id = Aws.Util.option_map (Aws.Json.lookup j "subnetId") String.of_json
    }
end

module DeleteTransitGatewayResult = struct
  type t = { transit_gateway : TransitGateway.t option }

  let make ?transit_gateway () = { transit_gateway }

  let parse xml =
    Some
      { transit_gateway =
          Aws.Util.option_bind (Aws.Xml.member "transitGateway" xml) TransitGateway.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway (fun f ->
               Aws.Query.Pair ("TransitGateway", TransitGateway.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway (fun f ->
               "transitGateway", TransitGateway.to_json f)
         ])

  let of_json j =
    { transit_gateway =
        Aws.Util.option_map (Aws.Json.lookup j "transitGateway") TransitGateway.of_json
    }
end

module WithdrawByoipCidrResult = struct
  type t = { byoip_cidr : ByoipCidr.t option }

  let make ?byoip_cidr () = { byoip_cidr }

  let parse xml =
    Some
      { byoip_cidr = Aws.Util.option_bind (Aws.Xml.member "byoipCidr" xml) ByoipCidr.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.byoip_cidr (fun f ->
               Aws.Query.Pair ("ByoipCidr", ByoipCidr.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.byoip_cidr (fun f -> "byoipCidr", ByoipCidr.to_json f) ])

  let of_json j =
    { byoip_cidr = Aws.Util.option_map (Aws.Json.lookup j "byoipCidr") ByoipCidr.of_json }
end

module DescribeSnapshotAttributeResult = struct
  type t =
    { create_volume_permissions : CreateVolumePermissionList.t
    ; product_codes : ProductCodeList.t
    ; snapshot_id : String.t option
    }

  let make ?(create_volume_permissions = []) ?(product_codes = []) ?snapshot_id () =
    { create_volume_permissions; product_codes; snapshot_id }

  let parse xml =
    Some
      { create_volume_permissions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "createVolumePermission" xml)
               CreateVolumePermissionList.parse)
      ; product_codes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "productCodes" xml)
               ProductCodeList.parse)
      ; snapshot_id = Aws.Util.option_bind (Aws.Xml.member "snapshotId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.snapshot_id (fun f ->
               Aws.Query.Pair ("SnapshotId", String.to_query f))
         ; Some
             (Aws.Query.Pair ("ProductCodes", ProductCodeList.to_query v.product_codes))
         ; Some
             (Aws.Query.Pair
                ( "CreateVolumePermission"
                , CreateVolumePermissionList.to_query v.create_volume_permissions ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.snapshot_id (fun f -> "snapshotId", String.to_json f)
         ; Some ("productCodes", ProductCodeList.to_json v.product_codes)
         ; Some
             ( "createVolumePermission"
             , CreateVolumePermissionList.to_json v.create_volume_permissions )
         ])

  let of_json j =
    { create_volume_permissions =
        CreateVolumePermissionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "createVolumePermission"))
    ; product_codes =
        ProductCodeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "productCodes"))
    ; snapshot_id = Aws.Util.option_map (Aws.Json.lookup j "snapshotId") String.of_json
    }
end

module TransitGatewayMulticastDomainIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeSpotDatafeedSubscriptionRequest = struct
  type t = { dry_run : Boolean.t option }

  let make ?dry_run () = { dry_run }

  let parse xml =
    Some { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f) ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json }
end

module DescribeRouteTablesResult = struct
  type t =
    { route_tables : RouteTableList.t
    ; next_token : String.t option
    }

  let make ?(route_tables = []) ?next_token () = { route_tables; next_token }

  let parse xml =
    Some
      { route_tables =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "routeTableSet" xml)
               RouteTableList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("RouteTableSet", RouteTableList.to_query v.route_tables))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("routeTableSet", RouteTableList.to_json v.route_tables)
         ])

  let of_json j =
    { route_tables =
        RouteTableList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "routeTableSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DescribeStaleSecurityGroupsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; vpc_id : String.t
    }

  let make ?dry_run ?max_results ?next_token ~vpc_id () =
    { dry_run; max_results; next_token; vpc_id }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; vpc_id =
          Aws.Xml.required
            "VpcId"
            (Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("VpcId", String.to_json v.vpc_id)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcId"))
    }
end

module ClientCertificateRevocationListStatusCode = struct
  type t =
    | Pending
    | Active

  let str_to_t = [ "active", Active; "pending", Pending ]

  let t_to_str = [ Active, "active"; Pending, "pending" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module InstanceIdSet = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module RunScheduledInstancesResult = struct
  type t = { instance_id_set : InstanceIdSet.t }

  let make ?(instance_id_set = []) () = { instance_id_set }

  let parse xml =
    Some
      { instance_id_set =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "instanceIdSet" xml)
               InstanceIdSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("InstanceIdSet", InstanceIdSet.to_query v.instance_id_set))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("instanceIdSet", InstanceIdSet.to_json v.instance_id_set) ])

  let of_json j =
    { instance_id_set =
        InstanceIdSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceIdSet"))
    }
end

module EnableTransitGatewayRouteTablePropagationRequest = struct
  type t =
    { transit_gateway_route_table_id : String.t
    ; transit_gateway_attachment_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~transit_gateway_route_table_id ~transit_gateway_attachment_id ?dry_run () =
    { transit_gateway_route_table_id; transit_gateway_attachment_id; dry_run }

  let parse xml =
    Some
      { transit_gateway_route_table_id =
          Aws.Xml.required
            "TransitGatewayRouteTableId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayRouteTableId" xml)
               String.parse)
      ; transit_gateway_attachment_id =
          Aws.Xml.required
            "TransitGatewayAttachmentId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayAttachmentId" xml)
               String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayAttachmentId"
                , String.to_query v.transit_gateway_attachment_id ))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayRouteTableId"
                , String.to_query v.transit_gateway_route_table_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ("TransitGatewayAttachmentId", String.to_json v.transit_gateway_attachment_id)
         ; Some
             ( "TransitGatewayRouteTableId"
             , String.to_json v.transit_gateway_route_table_id )
         ])

  let of_json j =
    { transit_gateway_route_table_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayRouteTableId"))
    ; transit_gateway_attachment_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayAttachmentId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module PrivateIpAddressStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "PrivateIpAddress" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module AssignPrivateIpAddressesRequest = struct
  type t =
    { allow_reassignment : Boolean.t option
    ; network_interface_id : String.t
    ; private_ip_addresses : PrivateIpAddressStringList.t
    ; secondary_private_ip_address_count : Integer.t option
    }

  let make
      ?allow_reassignment
      ~network_interface_id
      ?(private_ip_addresses = [])
      ?secondary_private_ip_address_count
      () =
    { allow_reassignment
    ; network_interface_id
    ; private_ip_addresses
    ; secondary_private_ip_address_count
    }

  let parse xml =
    Some
      { allow_reassignment =
          Aws.Util.option_bind (Aws.Xml.member "allowReassignment" xml) Boolean.parse
      ; network_interface_id =
          Aws.Xml.required
            "networkInterfaceId"
            (Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse)
      ; private_ip_addresses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "privateIpAddress" xml)
               PrivateIpAddressStringList.parse)
      ; secondary_private_ip_address_count =
          Aws.Util.option_bind
            (Aws.Xml.member "secondaryPrivateIpAddressCount" xml)
            Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.secondary_private_ip_address_count (fun f ->
               Aws.Query.Pair ("SecondaryPrivateIpAddressCount", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "PrivateIpAddress"
                , PrivateIpAddressStringList.to_query v.private_ip_addresses ))
         ; Some
             (Aws.Query.Pair ("NetworkInterfaceId", String.to_query v.network_interface_id))
         ; Aws.Util.option_map v.allow_reassignment (fun f ->
               Aws.Query.Pair ("AllowReassignment", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.secondary_private_ip_address_count (fun f ->
               "secondaryPrivateIpAddressCount", Integer.to_json f)
         ; Some
             ( "privateIpAddress"
             , PrivateIpAddressStringList.to_json v.private_ip_addresses )
         ; Some ("networkInterfaceId", String.to_json v.network_interface_id)
         ; Aws.Util.option_map v.allow_reassignment (fun f ->
               "allowReassignment", Boolean.to_json f)
         ])

  let of_json j =
    { allow_reassignment =
        Aws.Util.option_map (Aws.Json.lookup j "allowReassignment") Boolean.of_json
    ; network_interface_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "networkInterfaceId"))
    ; private_ip_addresses =
        PrivateIpAddressStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "privateIpAddress"))
    ; secondary_private_ip_address_count =
        Aws.Util.option_map
          (Aws.Json.lookup j "secondaryPrivateIpAddressCount")
          Integer.of_json
    }
end

module EnableFastSnapshotRestoreSuccessSet = struct
  type t = EnableFastSnapshotRestoreSuccessItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map EnableFastSnapshotRestoreSuccessItem.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list EnableFastSnapshotRestoreSuccessItem.to_query v

  let to_json v = `List (List.map EnableFastSnapshotRestoreSuccessItem.to_json v)

  let of_json j = Aws.Json.to_list EnableFastSnapshotRestoreSuccessItem.of_json j
end

module EnableFastSnapshotRestoreErrorSet = struct
  type t = EnableFastSnapshotRestoreErrorItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map EnableFastSnapshotRestoreErrorItem.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list EnableFastSnapshotRestoreErrorItem.to_query v

  let to_json v = `List (List.map EnableFastSnapshotRestoreErrorItem.to_json v)

  let of_json j = Aws.Json.to_list EnableFastSnapshotRestoreErrorItem.of_json j
end

module EnableFastSnapshotRestoresResult = struct
  type t =
    { successful : EnableFastSnapshotRestoreSuccessSet.t
    ; unsuccessful : EnableFastSnapshotRestoreErrorSet.t
    }

  let make ?(successful = []) ?(unsuccessful = []) () = { successful; unsuccessful }

  let parse xml =
    Some
      { successful =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "successful" xml)
               EnableFastSnapshotRestoreSuccessSet.parse)
      ; unsuccessful =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "unsuccessful" xml)
               EnableFastSnapshotRestoreErrorSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("Unsuccessful", EnableFastSnapshotRestoreErrorSet.to_query v.unsuccessful))
         ; Some
             (Aws.Query.Pair
                ("Successful", EnableFastSnapshotRestoreSuccessSet.to_query v.successful))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("unsuccessful", EnableFastSnapshotRestoreErrorSet.to_json v.unsuccessful)
         ; Some ("successful", EnableFastSnapshotRestoreSuccessSet.to_json v.successful)
         ])

  let of_json j =
    { successful =
        EnableFastSnapshotRestoreSuccessSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "successful"))
    ; unsuccessful =
        EnableFastSnapshotRestoreErrorSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "unsuccessful"))
    }
end

module DescribeFlowLogsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; filter : FilterList.t
    ; flow_log_ids : FlowLogIdList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?dry_run ?(filter = []) ?(flow_log_ids = []) ?max_results ?next_token () =
    { dry_run; filter; flow_log_ids; max_results; next_token }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; filter =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; flow_log_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "FlowLogId" xml) FlowLogIdList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("FlowLogId", FlowLogIdList.to_query v.flow_log_ids))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filter))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("FlowLogId", FlowLogIdList.to_json v.flow_log_ids)
         ; Some ("Filter", FilterList.to_json v.filter)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; filter = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; flow_log_ids =
        FlowLogIdList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "FlowLogId"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module UnassignIpv6AddressesResult = struct
  type t =
    { network_interface_id : String.t option
    ; unassigned_ipv6_addresses : Ipv6AddressList.t
    }

  let make ?network_interface_id ?(unassigned_ipv6_addresses = []) () =
    { network_interface_id; unassigned_ipv6_addresses }

  let parse xml =
    Some
      { network_interface_id =
          Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse
      ; unassigned_ipv6_addresses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "unassignedIpv6Addresses" xml)
               Ipv6AddressList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "UnassignedIpv6Addresses"
                , Ipv6AddressList.to_query v.unassigned_ipv6_addresses ))
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               Aws.Query.Pair ("NetworkInterfaceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "unassignedIpv6Addresses"
             , Ipv6AddressList.to_json v.unassigned_ipv6_addresses )
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               "networkInterfaceId", String.to_json f)
         ])

  let of_json j =
    { network_interface_id =
        Aws.Util.option_map (Aws.Json.lookup j "networkInterfaceId") String.of_json
    ; unassigned_ipv6_addresses =
        Ipv6AddressList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "unassignedIpv6Addresses"))
    }
end

module ConnectionLogOptions = struct
  type t =
    { enabled : Boolean.t option
    ; cloudwatch_log_group : String.t option
    ; cloudwatch_log_stream : String.t option
    }

  let make ?enabled ?cloudwatch_log_group ?cloudwatch_log_stream () =
    { enabled; cloudwatch_log_group; cloudwatch_log_stream }

  let parse xml =
    Some
      { enabled = Aws.Util.option_bind (Aws.Xml.member "Enabled" xml) Boolean.parse
      ; cloudwatch_log_group =
          Aws.Util.option_bind (Aws.Xml.member "CloudwatchLogGroup" xml) String.parse
      ; cloudwatch_log_stream =
          Aws.Util.option_bind (Aws.Xml.member "CloudwatchLogStream" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cloudwatch_log_stream (fun f ->
               Aws.Query.Pair ("CloudwatchLogStream", String.to_query f))
         ; Aws.Util.option_map v.cloudwatch_log_group (fun f ->
               Aws.Query.Pair ("CloudwatchLogGroup", String.to_query f))
         ; Aws.Util.option_map v.enabled (fun f ->
               Aws.Query.Pair ("Enabled", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cloudwatch_log_stream (fun f ->
               "CloudwatchLogStream", String.to_json f)
         ; Aws.Util.option_map v.cloudwatch_log_group (fun f ->
               "CloudwatchLogGroup", String.to_json f)
         ; Aws.Util.option_map v.enabled (fun f -> "Enabled", Boolean.to_json f)
         ])

  let of_json j =
    { enabled = Aws.Util.option_map (Aws.Json.lookup j "Enabled") Boolean.of_json
    ; cloudwatch_log_group =
        Aws.Util.option_map (Aws.Json.lookup j "CloudwatchLogGroup") String.of_json
    ; cloudwatch_log_stream =
        Aws.Util.option_map (Aws.Json.lookup j "CloudwatchLogStream") String.of_json
    }
end

module ReplaceNetworkAclEntryRequest = struct
  type t =
    { cidr_block : String.t option
    ; dry_run : Boolean.t option
    ; egress : Boolean.t
    ; icmp_type_code : IcmpTypeCode.t option
    ; ipv6_cidr_block : String.t option
    ; network_acl_id : String.t
    ; port_range : PortRange.t option
    ; protocol : String.t
    ; rule_action : RuleAction.t
    ; rule_number : Integer.t
    }

  let make
      ?cidr_block
      ?dry_run
      ~egress
      ?icmp_type_code
      ?ipv6_cidr_block
      ~network_acl_id
      ?port_range
      ~protocol
      ~rule_action
      ~rule_number
      () =
    { cidr_block
    ; dry_run
    ; egress
    ; icmp_type_code
    ; ipv6_cidr_block
    ; network_acl_id
    ; port_range
    ; protocol
    ; rule_action
    ; rule_number
    }

  let parse xml =
    Some
      { cidr_block = Aws.Util.option_bind (Aws.Xml.member "cidrBlock" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; egress =
          Aws.Xml.required
            "egress"
            (Aws.Util.option_bind (Aws.Xml.member "egress" xml) Boolean.parse)
      ; icmp_type_code =
          Aws.Util.option_bind (Aws.Xml.member "Icmp" xml) IcmpTypeCode.parse
      ; ipv6_cidr_block =
          Aws.Util.option_bind (Aws.Xml.member "ipv6CidrBlock" xml) String.parse
      ; network_acl_id =
          Aws.Xml.required
            "networkAclId"
            (Aws.Util.option_bind (Aws.Xml.member "networkAclId" xml) String.parse)
      ; port_range = Aws.Util.option_bind (Aws.Xml.member "portRange" xml) PortRange.parse
      ; protocol =
          Aws.Xml.required
            "protocol"
            (Aws.Util.option_bind (Aws.Xml.member "protocol" xml) String.parse)
      ; rule_action =
          Aws.Xml.required
            "ruleAction"
            (Aws.Util.option_bind (Aws.Xml.member "ruleAction" xml) RuleAction.parse)
      ; rule_number =
          Aws.Xml.required
            "ruleNumber"
            (Aws.Util.option_bind (Aws.Xml.member "ruleNumber" xml) Integer.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("RuleNumber", Integer.to_query v.rule_number))
         ; Some (Aws.Query.Pair ("RuleAction", RuleAction.to_query v.rule_action))
         ; Some (Aws.Query.Pair ("Protocol", String.to_query v.protocol))
         ; Aws.Util.option_map v.port_range (fun f ->
               Aws.Query.Pair ("PortRange", PortRange.to_query f))
         ; Some (Aws.Query.Pair ("NetworkAclId", String.to_query v.network_acl_id))
         ; Aws.Util.option_map v.ipv6_cidr_block (fun f ->
               Aws.Query.Pair ("Ipv6CidrBlock", String.to_query f))
         ; Aws.Util.option_map v.icmp_type_code (fun f ->
               Aws.Query.Pair ("Icmp", IcmpTypeCode.to_query f))
         ; Some (Aws.Query.Pair ("Egress", Boolean.to_query v.egress))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.cidr_block (fun f ->
               Aws.Query.Pair ("CidrBlock", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("ruleNumber", Integer.to_json v.rule_number)
         ; Some ("ruleAction", RuleAction.to_json v.rule_action)
         ; Some ("protocol", String.to_json v.protocol)
         ; Aws.Util.option_map v.port_range (fun f -> "portRange", PortRange.to_json f)
         ; Some ("networkAclId", String.to_json v.network_acl_id)
         ; Aws.Util.option_map v.ipv6_cidr_block (fun f ->
               "ipv6CidrBlock", String.to_json f)
         ; Aws.Util.option_map v.icmp_type_code (fun f -> "Icmp", IcmpTypeCode.to_json f)
         ; Some ("egress", Boolean.to_json v.egress)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.cidr_block (fun f -> "cidrBlock", String.to_json f)
         ])

  let of_json j =
    { cidr_block = Aws.Util.option_map (Aws.Json.lookup j "cidrBlock") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; egress = Boolean.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "egress"))
    ; icmp_type_code = Aws.Util.option_map (Aws.Json.lookup j "Icmp") IcmpTypeCode.of_json
    ; ipv6_cidr_block =
        Aws.Util.option_map (Aws.Json.lookup j "ipv6CidrBlock") String.of_json
    ; network_acl_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "networkAclId"))
    ; port_range = Aws.Util.option_map (Aws.Json.lookup j "portRange") PortRange.of_json
    ; protocol = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "protocol"))
    ; rule_action =
        RuleAction.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ruleAction"))
    ; rule_number =
        Integer.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ruleNumber"))
    }
end

module ModifyInstanceMetadataOptionsRequest = struct
  type t =
    { instance_id : String.t
    ; http_tokens : HttpTokensState.t option
    ; http_put_response_hop_limit : Integer.t option
    ; http_endpoint : InstanceMetadataEndpointState.t option
    ; dry_run : Boolean.t option
    }

  let make
      ~instance_id
      ?http_tokens
      ?http_put_response_hop_limit
      ?http_endpoint
      ?dry_run
      () =
    { instance_id; http_tokens; http_put_response_hop_limit; http_endpoint; dry_run }

  let parse xml =
    Some
      { instance_id =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse)
      ; http_tokens =
          Aws.Util.option_bind (Aws.Xml.member "HttpTokens" xml) HttpTokensState.parse
      ; http_put_response_hop_limit =
          Aws.Util.option_bind
            (Aws.Xml.member "HttpPutResponseHopLimit" xml)
            Integer.parse
      ; http_endpoint =
          Aws.Util.option_bind
            (Aws.Xml.member "HttpEndpoint" xml)
            InstanceMetadataEndpointState.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.http_endpoint (fun f ->
               Aws.Query.Pair ("HttpEndpoint", InstanceMetadataEndpointState.to_query f))
         ; Aws.Util.option_map v.http_put_response_hop_limit (fun f ->
               Aws.Query.Pair ("HttpPutResponseHopLimit", Integer.to_query f))
         ; Aws.Util.option_map v.http_tokens (fun f ->
               Aws.Query.Pair ("HttpTokens", HttpTokensState.to_query f))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.http_endpoint (fun f ->
               "HttpEndpoint", InstanceMetadataEndpointState.to_json f)
         ; Aws.Util.option_map v.http_put_response_hop_limit (fun f ->
               "HttpPutResponseHopLimit", Integer.to_json f)
         ; Aws.Util.option_map v.http_tokens (fun f ->
               "HttpTokens", HttpTokensState.to_json f)
         ; Some ("InstanceId", String.to_json v.instance_id)
         ])

  let of_json j =
    { instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; http_tokens =
        Aws.Util.option_map (Aws.Json.lookup j "HttpTokens") HttpTokensState.of_json
    ; http_put_response_hop_limit =
        Aws.Util.option_map (Aws.Json.lookup j "HttpPutResponseHopLimit") Integer.of_json
    ; http_endpoint =
        Aws.Util.option_map
          (Aws.Json.lookup j "HttpEndpoint")
          InstanceMetadataEndpointState.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module ManagedPrefixListSet = struct
  type t = ManagedPrefixList.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ManagedPrefixList.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ManagedPrefixList.to_query v

  let to_json v = `List (List.map ManagedPrefixList.to_json v)

  let of_json j = Aws.Json.to_list ManagedPrefixList.of_json j
end

module ModifyAvailabilityZoneOptInStatus = struct
  type t =
    | Opted_in
    | Not_opted_in

  let str_to_t = [ "not-opted-in", Not_opted_in; "opted-in", Opted_in ]

  let t_to_str = [ Not_opted_in, "not-opted-in"; Opted_in, "opted-in" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ModifyAvailabilityZoneGroupRequest = struct
  type t =
    { group_name : String.t
    ; opt_in_status : ModifyAvailabilityZoneOptInStatus.t
    ; dry_run : Boolean.t option
    }

  let make ~group_name ~opt_in_status ?dry_run () = { group_name; opt_in_status; dry_run }

  let parse xml =
    Some
      { group_name =
          Aws.Xml.required
            "GroupName"
            (Aws.Util.option_bind (Aws.Xml.member "GroupName" xml) String.parse)
      ; opt_in_status =
          Aws.Xml.required
            "OptInStatus"
            (Aws.Util.option_bind
               (Aws.Xml.member "OptInStatus" xml)
               ModifyAvailabilityZoneOptInStatus.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("OptInStatus", ModifyAvailabilityZoneOptInStatus.to_query v.opt_in_status))
         ; Some (Aws.Query.Pair ("GroupName", String.to_query v.group_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("OptInStatus", ModifyAvailabilityZoneOptInStatus.to_json v.opt_in_status)
         ; Some ("GroupName", String.to_json v.group_name)
         ])

  let of_json j =
    { group_name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "GroupName"))
    ; opt_in_status =
        ModifyAvailabilityZoneOptInStatus.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "OptInStatus"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module PrivateDnsNameConfiguration = struct
  type t =
    { state : DnsNameState.t option
    ; type_ : String.t option
    ; value : String.t option
    ; name : String.t option
    }

  let make ?state ?type_ ?value ?name () = { state; type_; value; name }

  let parse xml =
    Some
      { state = Aws.Util.option_bind (Aws.Xml.member "state" xml) DnsNameState.parse
      ; type_ = Aws.Util.option_bind (Aws.Xml.member "type" xml) String.parse
      ; value = Aws.Util.option_bind (Aws.Xml.member "value" xml) String.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "name" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", String.to_query f))
         ; Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", String.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", DnsNameState.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.name (fun f -> "name", String.to_json f)
         ; Aws.Util.option_map v.value (fun f -> "value", String.to_json f)
         ; Aws.Util.option_map v.type_ (fun f -> "type", String.to_json f)
         ; Aws.Util.option_map v.state (fun f -> "state", DnsNameState.to_json f)
         ])

  let of_json j =
    { state = Aws.Util.option_map (Aws.Json.lookup j "state") DnsNameState.of_json
    ; type_ = Aws.Util.option_map (Aws.Json.lookup j "type") String.of_json
    ; value = Aws.Util.option_map (Aws.Json.lookup j "value") String.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "name") String.of_json
    }
end

module ServiceConfiguration = struct
  type t =
    { service_type : ServiceTypeDetailSet.t
    ; service_id : String.t option
    ; service_name : String.t option
    ; service_state : ServiceState.t option
    ; availability_zones : ValueStringList.t
    ; acceptance_required : Boolean.t option
    ; manages_vpc_endpoints : Boolean.t option
    ; network_load_balancer_arns : ValueStringList.t
    ; gateway_load_balancer_arns : ValueStringList.t
    ; base_endpoint_dns_names : ValueStringList.t
    ; private_dns_name : String.t option
    ; private_dns_name_configuration : PrivateDnsNameConfiguration.t option
    ; tags : TagList.t
    }

  let make
      ?(service_type = [])
      ?service_id
      ?service_name
      ?service_state
      ?(availability_zones = [])
      ?acceptance_required
      ?manages_vpc_endpoints
      ?(network_load_balancer_arns = [])
      ?(gateway_load_balancer_arns = [])
      ?(base_endpoint_dns_names = [])
      ?private_dns_name
      ?private_dns_name_configuration
      ?(tags = [])
      () =
    { service_type
    ; service_id
    ; service_name
    ; service_state
    ; availability_zones
    ; acceptance_required
    ; manages_vpc_endpoints
    ; network_load_balancer_arns
    ; gateway_load_balancer_arns
    ; base_endpoint_dns_names
    ; private_dns_name
    ; private_dns_name_configuration
    ; tags
    }

  let parse xml =
    Some
      { service_type =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "serviceType" xml)
               ServiceTypeDetailSet.parse)
      ; service_id = Aws.Util.option_bind (Aws.Xml.member "serviceId" xml) String.parse
      ; service_name =
          Aws.Util.option_bind (Aws.Xml.member "serviceName" xml) String.parse
      ; service_state =
          Aws.Util.option_bind (Aws.Xml.member "serviceState" xml) ServiceState.parse
      ; availability_zones =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "availabilityZoneSet" xml)
               ValueStringList.parse)
      ; acceptance_required =
          Aws.Util.option_bind (Aws.Xml.member "acceptanceRequired" xml) Boolean.parse
      ; manages_vpc_endpoints =
          Aws.Util.option_bind (Aws.Xml.member "managesVpcEndpoints" xml) Boolean.parse
      ; network_load_balancer_arns =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "networkLoadBalancerArnSet" xml)
               ValueStringList.parse)
      ; gateway_load_balancer_arns =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "gatewayLoadBalancerArnSet" xml)
               ValueStringList.parse)
      ; base_endpoint_dns_names =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "baseEndpointDnsNameSet" xml)
               ValueStringList.parse)
      ; private_dns_name =
          Aws.Util.option_bind (Aws.Xml.member "privateDnsName" xml) String.parse
      ; private_dns_name_configuration =
          Aws.Util.option_bind
            (Aws.Xml.member "privateDnsNameConfiguration" xml)
            PrivateDnsNameConfiguration.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.private_dns_name_configuration (fun f ->
               Aws.Query.Pair
                 ("PrivateDnsNameConfiguration", PrivateDnsNameConfiguration.to_query f))
         ; Aws.Util.option_map v.private_dns_name (fun f ->
               Aws.Query.Pair ("PrivateDnsName", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "BaseEndpointDnsNameSet"
                , ValueStringList.to_query v.base_endpoint_dns_names ))
         ; Some
             (Aws.Query.Pair
                ( "GatewayLoadBalancerArnSet"
                , ValueStringList.to_query v.gateway_load_balancer_arns ))
         ; Some
             (Aws.Query.Pair
                ( "NetworkLoadBalancerArnSet"
                , ValueStringList.to_query v.network_load_balancer_arns ))
         ; Aws.Util.option_map v.manages_vpc_endpoints (fun f ->
               Aws.Query.Pair ("ManagesVpcEndpoints", Boolean.to_query f))
         ; Aws.Util.option_map v.acceptance_required (fun f ->
               Aws.Query.Pair ("AcceptanceRequired", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("AvailabilityZoneSet", ValueStringList.to_query v.availability_zones))
         ; Aws.Util.option_map v.service_state (fun f ->
               Aws.Query.Pair ("ServiceState", ServiceState.to_query f))
         ; Aws.Util.option_map v.service_name (fun f ->
               Aws.Query.Pair ("ServiceName", String.to_query f))
         ; Aws.Util.option_map v.service_id (fun f ->
               Aws.Query.Pair ("ServiceId", String.to_query f))
         ; Some
             (Aws.Query.Pair ("ServiceType", ServiceTypeDetailSet.to_query v.service_type))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.private_dns_name_configuration (fun f ->
               "privateDnsNameConfiguration", PrivateDnsNameConfiguration.to_json f)
         ; Aws.Util.option_map v.private_dns_name (fun f ->
               "privateDnsName", String.to_json f)
         ; Some
             ("baseEndpointDnsNameSet", ValueStringList.to_json v.base_endpoint_dns_names)
         ; Some
             ( "gatewayLoadBalancerArnSet"
             , ValueStringList.to_json v.gateway_load_balancer_arns )
         ; Some
             ( "networkLoadBalancerArnSet"
             , ValueStringList.to_json v.network_load_balancer_arns )
         ; Aws.Util.option_map v.manages_vpc_endpoints (fun f ->
               "managesVpcEndpoints", Boolean.to_json f)
         ; Aws.Util.option_map v.acceptance_required (fun f ->
               "acceptanceRequired", Boolean.to_json f)
         ; Some ("availabilityZoneSet", ValueStringList.to_json v.availability_zones)
         ; Aws.Util.option_map v.service_state (fun f ->
               "serviceState", ServiceState.to_json f)
         ; Aws.Util.option_map v.service_name (fun f -> "serviceName", String.to_json f)
         ; Aws.Util.option_map v.service_id (fun f -> "serviceId", String.to_json f)
         ; Some ("serviceType", ServiceTypeDetailSet.to_json v.service_type)
         ])

  let of_json j =
    { service_type =
        ServiceTypeDetailSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "serviceType"))
    ; service_id = Aws.Util.option_map (Aws.Json.lookup j "serviceId") String.of_json
    ; service_name = Aws.Util.option_map (Aws.Json.lookup j "serviceName") String.of_json
    ; service_state =
        Aws.Util.option_map (Aws.Json.lookup j "serviceState") ServiceState.of_json
    ; availability_zones =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "availabilityZoneSet"))
    ; acceptance_required =
        Aws.Util.option_map (Aws.Json.lookup j "acceptanceRequired") Boolean.of_json
    ; manages_vpc_endpoints =
        Aws.Util.option_map (Aws.Json.lookup j "managesVpcEndpoints") Boolean.of_json
    ; network_load_balancer_arns =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "networkLoadBalancerArnSet"))
    ; gateway_load_balancer_arns =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "gatewayLoadBalancerArnSet"))
    ; base_endpoint_dns_names =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "baseEndpointDnsNameSet"))
    ; private_dns_name =
        Aws.Util.option_map (Aws.Json.lookup j "privateDnsName") String.of_json
    ; private_dns_name_configuration =
        Aws.Util.option_map
          (Aws.Json.lookup j "privateDnsNameConfiguration")
          PrivateDnsNameConfiguration.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module ServiceConfigurationSet = struct
  type t = ServiceConfiguration.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ServiceConfiguration.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ServiceConfiguration.to_query v

  let to_json v = `List (List.map ServiceConfiguration.to_json v)

  let of_json j = Aws.Json.to_list ServiceConfiguration.of_json j
end

module SnapshotIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "SnapshotId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module RestorableByStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeSnapshotsRequest = struct
  type t =
    { filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; owner_ids : OwnerStringList.t
    ; restorable_by_user_ids : RestorableByStringList.t
    ; snapshot_ids : SnapshotIdStringList.t
    ; dry_run : Boolean.t option
    }

  let make
      ?(filters = [])
      ?max_results
      ?next_token
      ?(owner_ids = [])
      ?(restorable_by_user_ids = [])
      ?(snapshot_ids = [])
      ?dry_run
      () =
    { filters
    ; max_results
    ; next_token
    ; owner_ids
    ; restorable_by_user_ids
    ; snapshot_ids
    ; dry_run
    }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; owner_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Owner" xml) OwnerStringList.parse)
      ; restorable_by_user_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "RestorableBy" xml)
               RestorableByStringList.parse)
      ; snapshot_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SnapshotId" xml)
               SnapshotIdStringList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair ("SnapshotId", SnapshotIdStringList.to_query v.snapshot_ids))
         ; Some
             (Aws.Query.Pair
                ("RestorableBy", RestorableByStringList.to_query v.restorable_by_user_ids))
         ; Some (Aws.Query.Pair ("Owner", OwnerStringList.to_query v.owner_ids))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("SnapshotId", SnapshotIdStringList.to_json v.snapshot_ids)
         ; Some ("RestorableBy", RestorableByStringList.to_json v.restorable_by_user_ids)
         ; Some ("Owner", OwnerStringList.to_json v.owner_ids)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; owner_ids =
        OwnerStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Owner"))
    ; restorable_by_user_ids =
        RestorableByStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "RestorableBy"))
    ; snapshot_ids =
        SnapshotIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SnapshotId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module DescribeFpgaImagesResult = struct
  type t =
    { fpga_images : FpgaImageList.t
    ; next_token : String.t option
    }

  let make ?(fpga_images = []) ?next_token () = { fpga_images; next_token }

  let parse xml =
    Some
      { fpga_images =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "fpgaImageSet" xml) FpgaImageList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("FpgaImageSet", FpgaImageList.to_query v.fpga_images))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("fpgaImageSet", FpgaImageList.to_json v.fpga_images)
         ])

  let of_json j =
    { fpga_images =
        FpgaImageList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "fpgaImageSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module CancelReservedInstancesListingRequest = struct
  type t = { reserved_instances_listing_id : String.t }

  let make ~reserved_instances_listing_id () = { reserved_instances_listing_id }

  let parse xml =
    Some
      { reserved_instances_listing_id =
          Aws.Xml.required
            "reservedInstancesListingId"
            (Aws.Util.option_bind
               (Aws.Xml.member "reservedInstancesListingId" xml)
               String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "ReservedInstancesListingId"
                , String.to_query v.reserved_instances_listing_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ("reservedInstancesListingId", String.to_json v.reserved_instances_listing_id)
         ])

  let of_json j =
    { reserved_instances_listing_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "reservedInstancesListingId"))
    }
end

module EventInformation = struct
  type t =
    { event_description : String.t option
    ; event_sub_type : String.t option
    ; instance_id : String.t option
    }

  let make ?event_description ?event_sub_type ?instance_id () =
    { event_description; event_sub_type; instance_id }

  let parse xml =
    Some
      { event_description =
          Aws.Util.option_bind (Aws.Xml.member "eventDescription" xml) String.parse
      ; event_sub_type =
          Aws.Util.option_bind (Aws.Xml.member "eventSubType" xml) String.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.event_sub_type (fun f ->
               Aws.Query.Pair ("EventSubType", String.to_query f))
         ; Aws.Util.option_map v.event_description (fun f ->
               Aws.Query.Pair ("EventDescription", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ; Aws.Util.option_map v.event_sub_type (fun f ->
               "eventSubType", String.to_json f)
         ; Aws.Util.option_map v.event_description (fun f ->
               "eventDescription", String.to_json f)
         ])

  let of_json j =
    { event_description =
        Aws.Util.option_map (Aws.Json.lookup j "eventDescription") String.of_json
    ; event_sub_type =
        Aws.Util.option_map (Aws.Json.lookup j "eventSubType") String.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    }
end

module HistoryRecord = struct
  type t =
    { event_information : EventInformation.t option
    ; event_type : EventType.t option
    ; timestamp : DateTime.t option
    }

  let make ?event_information ?event_type ?timestamp () =
    { event_information; event_type; timestamp }

  let parse xml =
    Some
      { event_information =
          Aws.Util.option_bind
            (Aws.Xml.member "eventInformation" xml)
            EventInformation.parse
      ; event_type = Aws.Util.option_bind (Aws.Xml.member "eventType" xml) EventType.parse
      ; timestamp = Aws.Util.option_bind (Aws.Xml.member "timestamp" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timestamp (fun f ->
               Aws.Query.Pair ("Timestamp", DateTime.to_query f))
         ; Aws.Util.option_map v.event_type (fun f ->
               Aws.Query.Pair ("EventType", EventType.to_query f))
         ; Aws.Util.option_map v.event_information (fun f ->
               Aws.Query.Pair ("EventInformation", EventInformation.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timestamp (fun f -> "timestamp", DateTime.to_json f)
         ; Aws.Util.option_map v.event_type (fun f -> "eventType", EventType.to_json f)
         ; Aws.Util.option_map v.event_information (fun f ->
               "eventInformation", EventInformation.to_json f)
         ])

  let of_json j =
    { event_information =
        Aws.Util.option_map
          (Aws.Json.lookup j "eventInformation")
          EventInformation.of_json
    ; event_type = Aws.Util.option_map (Aws.Json.lookup j "eventType") EventType.of_json
    ; timestamp = Aws.Util.option_map (Aws.Json.lookup j "timestamp") DateTime.of_json
    }
end

module HistoryRecords = struct
  type t = HistoryRecord.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map HistoryRecord.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list HistoryRecord.to_query v

  let to_json v = `List (List.map HistoryRecord.to_json v)

  let of_json j = Aws.Json.to_list HistoryRecord.of_json j
end

module DescribeSpotFleetRequestHistoryResponse = struct
  type t =
    { history_records : HistoryRecords.t
    ; last_evaluated_time : DateTime.t option
    ; next_token : String.t option
    ; spot_fleet_request_id : String.t option
    ; start_time : DateTime.t option
    }

  let make
      ?(history_records = [])
      ?last_evaluated_time
      ?next_token
      ?spot_fleet_request_id
      ?start_time
      () =
    { history_records
    ; last_evaluated_time
    ; next_token
    ; spot_fleet_request_id
    ; start_time
    }

  let parse xml =
    Some
      { history_records =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "historyRecordSet" xml)
               HistoryRecords.parse)
      ; last_evaluated_time =
          Aws.Util.option_bind (Aws.Xml.member "lastEvaluatedTime" xml) DateTime.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; spot_fleet_request_id =
          Aws.Util.option_bind (Aws.Xml.member "spotFleetRequestId" xml) String.parse
      ; start_time = Aws.Util.option_bind (Aws.Xml.member "startTime" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.start_time (fun f ->
               Aws.Query.Pair ("StartTime", DateTime.to_query f))
         ; Aws.Util.option_map v.spot_fleet_request_id (fun f ->
               Aws.Query.Pair ("SpotFleetRequestId", String.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.last_evaluated_time (fun f ->
               Aws.Query.Pair ("LastEvaluatedTime", DateTime.to_query f))
         ; Some
             (Aws.Query.Pair
                ("HistoryRecordSet", HistoryRecords.to_query v.history_records))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.start_time (fun f -> "startTime", DateTime.to_json f)
         ; Aws.Util.option_map v.spot_fleet_request_id (fun f ->
               "spotFleetRequestId", String.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Aws.Util.option_map v.last_evaluated_time (fun f ->
               "lastEvaluatedTime", DateTime.to_json f)
         ; Some ("historyRecordSet", HistoryRecords.to_json v.history_records)
         ])

  let of_json j =
    { history_records =
        HistoryRecords.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "historyRecordSet"))
    ; last_evaluated_time =
        Aws.Util.option_map (Aws.Json.lookup j "lastEvaluatedTime") DateTime.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; spot_fleet_request_id =
        Aws.Util.option_map (Aws.Json.lookup j "spotFleetRequestId") String.of_json
    ; start_time = Aws.Util.option_map (Aws.Json.lookup j "startTime") DateTime.of_json
    }
end

module CreateSecurityGroupResult = struct
  type t =
    { group_id : String.t
    ; tags : TagList.t
    }

  let make ~group_id ?(tags = []) () = { group_id; tags }

  let parse xml =
    Some
      { group_id =
          Aws.Xml.required
            "groupId"
            (Aws.Util.option_bind (Aws.Xml.member "groupId" xml) String.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Some (Aws.Query.Pair ("GroupId", String.to_query v.group_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Some ("groupId", String.to_json v.group_id)
         ])

  let of_json j =
    { group_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "groupId"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module TransitGatewayRouteList = struct
  type t = TransitGatewayRoute.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map TransitGatewayRoute.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list TransitGatewayRoute.to_query v

  let to_json v = `List (List.map TransitGatewayRoute.to_json v)

  let of_json j = Aws.Json.to_list TransitGatewayRoute.of_json j
end

module SearchTransitGatewayRoutesResult = struct
  type t =
    { routes : TransitGatewayRouteList.t
    ; additional_routes_available : Boolean.t option
    }

  let make ?(routes = []) ?additional_routes_available () =
    { routes; additional_routes_available }

  let parse xml =
    Some
      { routes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "routeSet" xml)
               TransitGatewayRouteList.parse)
      ; additional_routes_available =
          Aws.Util.option_bind
            (Aws.Xml.member "additionalRoutesAvailable" xml)
            Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.additional_routes_available (fun f ->
               Aws.Query.Pair ("AdditionalRoutesAvailable", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("RouteSet", TransitGatewayRouteList.to_query v.routes))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.additional_routes_available (fun f ->
               "additionalRoutesAvailable", Boolean.to_json f)
         ; Some ("routeSet", TransitGatewayRouteList.to_json v.routes)
         ])

  let of_json j =
    { routes =
        TransitGatewayRouteList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "routeSet"))
    ; additional_routes_available =
        Aws.Util.option_map
          (Aws.Json.lookup j "additionalRoutesAvailable")
          Boolean.of_json
    }
end

module TargetReservationValueSet = struct
  type t = TargetReservationValue.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map TargetReservationValue.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list TargetReservationValue.to_query v

  let to_json v = `List (List.map TargetReservationValue.to_json v)

  let of_json j = Aws.Json.to_list TargetReservationValue.of_json j
end

module ReservedInstanceReservationValue = struct
  type t =
    { reservation_value : ReservationValue.t option
    ; reserved_instance_id : String.t option
    }

  let make ?reservation_value ?reserved_instance_id () =
    { reservation_value; reserved_instance_id }

  let parse xml =
    Some
      { reservation_value =
          Aws.Util.option_bind
            (Aws.Xml.member "reservationValue" xml)
            ReservationValue.parse
      ; reserved_instance_id =
          Aws.Util.option_bind (Aws.Xml.member "reservedInstanceId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.reserved_instance_id (fun f ->
               Aws.Query.Pair ("ReservedInstanceId", String.to_query f))
         ; Aws.Util.option_map v.reservation_value (fun f ->
               Aws.Query.Pair ("ReservationValue", ReservationValue.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.reserved_instance_id (fun f ->
               "reservedInstanceId", String.to_json f)
         ; Aws.Util.option_map v.reservation_value (fun f ->
               "reservationValue", ReservationValue.to_json f)
         ])

  let of_json j =
    { reservation_value =
        Aws.Util.option_map
          (Aws.Json.lookup j "reservationValue")
          ReservationValue.of_json
    ; reserved_instance_id =
        Aws.Util.option_map (Aws.Json.lookup j "reservedInstanceId") String.of_json
    }
end

module ReservedInstanceReservationValueSet = struct
  type t = ReservedInstanceReservationValue.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ReservedInstanceReservationValue.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ReservedInstanceReservationValue.to_query v

  let to_json v = `List (List.map ReservedInstanceReservationValue.to_json v)

  let of_json j = Aws.Json.to_list ReservedInstanceReservationValue.of_json j
end

module GetReservedInstancesExchangeQuoteResult = struct
  type t =
    { currency_code : String.t option
    ; is_valid_exchange : Boolean.t option
    ; output_reserved_instances_will_expire_at : DateTime.t option
    ; payment_due : String.t option
    ; reserved_instance_value_rollup : ReservationValue.t option
    ; reserved_instance_value_set : ReservedInstanceReservationValueSet.t
    ; target_configuration_value_rollup : ReservationValue.t option
    ; target_configuration_value_set : TargetReservationValueSet.t
    ; validation_failure_reason : String.t option
    }

  let make
      ?currency_code
      ?is_valid_exchange
      ?output_reserved_instances_will_expire_at
      ?payment_due
      ?reserved_instance_value_rollup
      ?(reserved_instance_value_set = [])
      ?target_configuration_value_rollup
      ?(target_configuration_value_set = [])
      ?validation_failure_reason
      () =
    { currency_code
    ; is_valid_exchange
    ; output_reserved_instances_will_expire_at
    ; payment_due
    ; reserved_instance_value_rollup
    ; reserved_instance_value_set
    ; target_configuration_value_rollup
    ; target_configuration_value_set
    ; validation_failure_reason
    }

  let parse xml =
    Some
      { currency_code =
          Aws.Util.option_bind (Aws.Xml.member "currencyCode" xml) String.parse
      ; is_valid_exchange =
          Aws.Util.option_bind (Aws.Xml.member "isValidExchange" xml) Boolean.parse
      ; output_reserved_instances_will_expire_at =
          Aws.Util.option_bind
            (Aws.Xml.member "outputReservedInstancesWillExpireAt" xml)
            DateTime.parse
      ; payment_due = Aws.Util.option_bind (Aws.Xml.member "paymentDue" xml) String.parse
      ; reserved_instance_value_rollup =
          Aws.Util.option_bind
            (Aws.Xml.member "reservedInstanceValueRollup" xml)
            ReservationValue.parse
      ; reserved_instance_value_set =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "reservedInstanceValueSet" xml)
               ReservedInstanceReservationValueSet.parse)
      ; target_configuration_value_rollup =
          Aws.Util.option_bind
            (Aws.Xml.member "targetConfigurationValueRollup" xml)
            ReservationValue.parse
      ; target_configuration_value_set =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "targetConfigurationValueSet" xml)
               TargetReservationValueSet.parse)
      ; validation_failure_reason =
          Aws.Util.option_bind (Aws.Xml.member "validationFailureReason" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.validation_failure_reason (fun f ->
               Aws.Query.Pair ("ValidationFailureReason", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TargetConfigurationValueSet"
                , TargetReservationValueSet.to_query v.target_configuration_value_set ))
         ; Aws.Util.option_map v.target_configuration_value_rollup (fun f ->
               Aws.Query.Pair
                 ("TargetConfigurationValueRollup", ReservationValue.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ReservedInstanceValueSet"
                , ReservedInstanceReservationValueSet.to_query
                    v.reserved_instance_value_set ))
         ; Aws.Util.option_map v.reserved_instance_value_rollup (fun f ->
               Aws.Query.Pair ("ReservedInstanceValueRollup", ReservationValue.to_query f))
         ; Aws.Util.option_map v.payment_due (fun f ->
               Aws.Query.Pair ("PaymentDue", String.to_query f))
         ; Aws.Util.option_map v.output_reserved_instances_will_expire_at (fun f ->
               Aws.Query.Pair ("OutputReservedInstancesWillExpireAt", DateTime.to_query f))
         ; Aws.Util.option_map v.is_valid_exchange (fun f ->
               Aws.Query.Pair ("IsValidExchange", Boolean.to_query f))
         ; Aws.Util.option_map v.currency_code (fun f ->
               Aws.Query.Pair ("CurrencyCode", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.validation_failure_reason (fun f ->
               "validationFailureReason", String.to_json f)
         ; Some
             ( "targetConfigurationValueSet"
             , TargetReservationValueSet.to_json v.target_configuration_value_set )
         ; Aws.Util.option_map v.target_configuration_value_rollup (fun f ->
               "targetConfigurationValueRollup", ReservationValue.to_json f)
         ; Some
             ( "reservedInstanceValueSet"
             , ReservedInstanceReservationValueSet.to_json v.reserved_instance_value_set
             )
         ; Aws.Util.option_map v.reserved_instance_value_rollup (fun f ->
               "reservedInstanceValueRollup", ReservationValue.to_json f)
         ; Aws.Util.option_map v.payment_due (fun f -> "paymentDue", String.to_json f)
         ; Aws.Util.option_map v.output_reserved_instances_will_expire_at (fun f ->
               "outputReservedInstancesWillExpireAt", DateTime.to_json f)
         ; Aws.Util.option_map v.is_valid_exchange (fun f ->
               "isValidExchange", Boolean.to_json f)
         ; Aws.Util.option_map v.currency_code (fun f -> "currencyCode", String.to_json f)
         ])

  let of_json j =
    { currency_code =
        Aws.Util.option_map (Aws.Json.lookup j "currencyCode") String.of_json
    ; is_valid_exchange =
        Aws.Util.option_map (Aws.Json.lookup j "isValidExchange") Boolean.of_json
    ; output_reserved_instances_will_expire_at =
        Aws.Util.option_map
          (Aws.Json.lookup j "outputReservedInstancesWillExpireAt")
          DateTime.of_json
    ; payment_due = Aws.Util.option_map (Aws.Json.lookup j "paymentDue") String.of_json
    ; reserved_instance_value_rollup =
        Aws.Util.option_map
          (Aws.Json.lookup j "reservedInstanceValueRollup")
          ReservationValue.of_json
    ; reserved_instance_value_set =
        ReservedInstanceReservationValueSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "reservedInstanceValueSet"))
    ; target_configuration_value_rollup =
        Aws.Util.option_map
          (Aws.Json.lookup j "targetConfigurationValueRollup")
          ReservationValue.of_json
    ; target_configuration_value_set =
        TargetReservationValueSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "targetConfigurationValueSet"))
    ; validation_failure_reason =
        Aws.Util.option_map (Aws.Json.lookup j "validationFailureReason") String.of_json
    }
end

module ExportToS3TaskSpecification = struct
  type t =
    { container_format : ContainerFormat.t option
    ; disk_image_format : DiskImageFormat.t option
    ; s3_bucket : String.t option
    ; s3_prefix : String.t option
    }

  let make ?container_format ?disk_image_format ?s3_bucket ?s3_prefix () =
    { container_format; disk_image_format; s3_bucket; s3_prefix }

  let parse xml =
    Some
      { container_format =
          Aws.Util.option_bind
            (Aws.Xml.member "containerFormat" xml)
            ContainerFormat.parse
      ; disk_image_format =
          Aws.Util.option_bind
            (Aws.Xml.member "diskImageFormat" xml)
            DiskImageFormat.parse
      ; s3_bucket = Aws.Util.option_bind (Aws.Xml.member "s3Bucket" xml) String.parse
      ; s3_prefix = Aws.Util.option_bind (Aws.Xml.member "s3Prefix" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.s3_prefix (fun f ->
               Aws.Query.Pair ("S3Prefix", String.to_query f))
         ; Aws.Util.option_map v.s3_bucket (fun f ->
               Aws.Query.Pair ("S3Bucket", String.to_query f))
         ; Aws.Util.option_map v.disk_image_format (fun f ->
               Aws.Query.Pair ("DiskImageFormat", DiskImageFormat.to_query f))
         ; Aws.Util.option_map v.container_format (fun f ->
               Aws.Query.Pair ("ContainerFormat", ContainerFormat.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.s3_prefix (fun f -> "s3Prefix", String.to_json f)
         ; Aws.Util.option_map v.s3_bucket (fun f -> "s3Bucket", String.to_json f)
         ; Aws.Util.option_map v.disk_image_format (fun f ->
               "diskImageFormat", DiskImageFormat.to_json f)
         ; Aws.Util.option_map v.container_format (fun f ->
               "containerFormat", ContainerFormat.to_json f)
         ])

  let of_json j =
    { container_format =
        Aws.Util.option_map (Aws.Json.lookup j "containerFormat") ContainerFormat.of_json
    ; disk_image_format =
        Aws.Util.option_map (Aws.Json.lookup j "diskImageFormat") DiskImageFormat.of_json
    ; s3_bucket = Aws.Util.option_map (Aws.Json.lookup j "s3Bucket") String.of_json
    ; s3_prefix = Aws.Util.option_map (Aws.Json.lookup j "s3Prefix") String.of_json
    }
end

module CreateInstanceExportTaskRequest = struct
  type t =
    { description : String.t option
    ; export_to_s3_task : ExportToS3TaskSpecification.t
    ; instance_id : String.t
    ; target_environment : ExportEnvironment.t
    ; tag_specifications : TagSpecificationList.t
    }

  let make
      ?description
      ~export_to_s3_task
      ~instance_id
      ~target_environment
      ?(tag_specifications = [])
      () =
    { description
    ; export_to_s3_task
    ; instance_id
    ; target_environment
    ; tag_specifications
    }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; export_to_s3_task =
          Aws.Xml.required
            "exportToS3"
            (Aws.Util.option_bind
               (Aws.Xml.member "exportToS3" xml)
               ExportToS3TaskSpecification.parse)
      ; instance_id =
          Aws.Xml.required
            "instanceId"
            (Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse)
      ; target_environment =
          Aws.Xml.required
            "targetEnvironment"
            (Aws.Util.option_bind
               (Aws.Xml.member "targetEnvironment" xml)
               ExportEnvironment.parse)
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Some
             (Aws.Query.Pair
                ("TargetEnvironment", ExportEnvironment.to_query v.target_environment))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ; Some
             (Aws.Query.Pair
                ("ExportToS3", ExportToS3TaskSpecification.to_query v.export_to_s3_task))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Some ("targetEnvironment", ExportEnvironment.to_json v.target_environment)
         ; Some ("instanceId", String.to_json v.instance_id)
         ; Some ("exportToS3", ExportToS3TaskSpecification.to_json v.export_to_s3_task)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; export_to_s3_task =
        ExportToS3TaskSpecification.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "exportToS3"))
    ; instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceId"))
    ; target_environment =
        ExportEnvironment.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "targetEnvironment"))
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    }
end

module ImageTypeValues = struct
  type t =
    | Machine
    | Kernel
    | Ramdisk

  let str_to_t = [ "ramdisk", Ramdisk; "kernel", Kernel; "machine", Machine ]

  let t_to_str = [ Ramdisk, "ramdisk"; Kernel, "kernel"; Machine, "machine" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module Image = struct
  type t =
    { architecture : ArchitectureValues.t
    ; creation_date : String.t option
    ; image_id : String.t
    ; image_location : String.t
    ; image_type : ImageTypeValues.t
    ; public : Boolean.t
    ; kernel_id : String.t option
    ; owner_id : String.t
    ; platform : PlatformValues.t option
    ; platform_details : String.t option
    ; usage_operation : String.t option
    ; product_codes : ProductCodeList.t
    ; ramdisk_id : String.t option
    ; state : ImageState.t
    ; block_device_mappings : BlockDeviceMappingList.t
    ; description : String.t option
    ; ena_support : Boolean.t option
    ; hypervisor : HypervisorType.t
    ; image_owner_alias : String.t option
    ; name : String.t option
    ; root_device_name : String.t option
    ; root_device_type : DeviceType.t
    ; sriov_net_support : String.t option
    ; state_reason : StateReason.t option
    ; tags : TagList.t
    ; virtualization_type : VirtualizationType.t
    }

  let make
      ~architecture
      ?creation_date
      ~image_id
      ~image_location
      ~image_type
      ~public
      ?kernel_id
      ~owner_id
      ?platform
      ?platform_details
      ?usage_operation
      ?(product_codes = [])
      ?ramdisk_id
      ~state
      ?(block_device_mappings = [])
      ?description
      ?ena_support
      ~hypervisor
      ?image_owner_alias
      ?name
      ?root_device_name
      ~root_device_type
      ?sriov_net_support
      ?state_reason
      ?(tags = [])
      ~virtualization_type
      () =
    { architecture
    ; creation_date
    ; image_id
    ; image_location
    ; image_type
    ; public
    ; kernel_id
    ; owner_id
    ; platform
    ; platform_details
    ; usage_operation
    ; product_codes
    ; ramdisk_id
    ; state
    ; block_device_mappings
    ; description
    ; ena_support
    ; hypervisor
    ; image_owner_alias
    ; name
    ; root_device_name
    ; root_device_type
    ; sriov_net_support
    ; state_reason
    ; tags
    ; virtualization_type
    }

  let parse xml =
    Some
      { architecture =
          Aws.Xml.required
            "architecture"
            (Aws.Util.option_bind
               (Aws.Xml.member "architecture" xml)
               ArchitectureValues.parse)
      ; creation_date =
          Aws.Util.option_bind (Aws.Xml.member "creationDate" xml) String.parse
      ; image_id =
          Aws.Xml.required
            "imageId"
            (Aws.Util.option_bind (Aws.Xml.member "imageId" xml) String.parse)
      ; image_location =
          Aws.Xml.required
            "imageLocation"
            (Aws.Util.option_bind (Aws.Xml.member "imageLocation" xml) String.parse)
      ; image_type =
          Aws.Xml.required
            "imageType"
            (Aws.Util.option_bind (Aws.Xml.member "imageType" xml) ImageTypeValues.parse)
      ; public =
          Aws.Xml.required
            "isPublic"
            (Aws.Util.option_bind (Aws.Xml.member "isPublic" xml) Boolean.parse)
      ; kernel_id = Aws.Util.option_bind (Aws.Xml.member "kernelId" xml) String.parse
      ; owner_id =
          Aws.Xml.required
            "imageOwnerId"
            (Aws.Util.option_bind (Aws.Xml.member "imageOwnerId" xml) String.parse)
      ; platform =
          Aws.Util.option_bind (Aws.Xml.member "platform" xml) PlatformValues.parse
      ; platform_details =
          Aws.Util.option_bind (Aws.Xml.member "platformDetails" xml) String.parse
      ; usage_operation =
          Aws.Util.option_bind (Aws.Xml.member "usageOperation" xml) String.parse
      ; product_codes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "productCodes" xml)
               ProductCodeList.parse)
      ; ramdisk_id = Aws.Util.option_bind (Aws.Xml.member "ramdiskId" xml) String.parse
      ; state =
          Aws.Xml.required
            "imageState"
            (Aws.Util.option_bind (Aws.Xml.member "imageState" xml) ImageState.parse)
      ; block_device_mappings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "blockDeviceMapping" xml)
               BlockDeviceMappingList.parse)
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; ena_support = Aws.Util.option_bind (Aws.Xml.member "enaSupport" xml) Boolean.parse
      ; hypervisor =
          Aws.Xml.required
            "hypervisor"
            (Aws.Util.option_bind (Aws.Xml.member "hypervisor" xml) HypervisorType.parse)
      ; image_owner_alias =
          Aws.Util.option_bind (Aws.Xml.member "imageOwnerAlias" xml) String.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "name" xml) String.parse
      ; root_device_name =
          Aws.Util.option_bind (Aws.Xml.member "rootDeviceName" xml) String.parse
      ; root_device_type =
          Aws.Xml.required
            "rootDeviceType"
            (Aws.Util.option_bind (Aws.Xml.member "rootDeviceType" xml) DeviceType.parse)
      ; sriov_net_support =
          Aws.Util.option_bind (Aws.Xml.member "sriovNetSupport" xml) String.parse
      ; state_reason =
          Aws.Util.option_bind (Aws.Xml.member "stateReason" xml) StateReason.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      ; virtualization_type =
          Aws.Xml.required
            "virtualizationType"
            (Aws.Util.option_bind
               (Aws.Xml.member "virtualizationType" xml)
               VirtualizationType.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("VirtualizationType", VirtualizationType.to_query v.virtualization_type))
         ; Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.state_reason (fun f ->
               Aws.Query.Pair ("StateReason", StateReason.to_query f))
         ; Aws.Util.option_map v.sriov_net_support (fun f ->
               Aws.Query.Pair ("SriovNetSupport", String.to_query f))
         ; Some
             (Aws.Query.Pair ("RootDeviceType", DeviceType.to_query v.root_device_type))
         ; Aws.Util.option_map v.root_device_name (fun f ->
               Aws.Query.Pair ("RootDeviceName", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.image_owner_alias (fun f ->
               Aws.Query.Pair ("ImageOwnerAlias", String.to_query f))
         ; Some (Aws.Query.Pair ("Hypervisor", HypervisorType.to_query v.hypervisor))
         ; Aws.Util.option_map v.ena_support (fun f ->
               Aws.Query.Pair ("EnaSupport", Boolean.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "BlockDeviceMapping"
                , BlockDeviceMappingList.to_query v.block_device_mappings ))
         ; Some (Aws.Query.Pair ("ImageState", ImageState.to_query v.state))
         ; Aws.Util.option_map v.ramdisk_id (fun f ->
               Aws.Query.Pair ("RamdiskId", String.to_query f))
         ; Some
             (Aws.Query.Pair ("ProductCodes", ProductCodeList.to_query v.product_codes))
         ; Aws.Util.option_map v.usage_operation (fun f ->
               Aws.Query.Pair ("UsageOperation", String.to_query f))
         ; Aws.Util.option_map v.platform_details (fun f ->
               Aws.Query.Pair ("PlatformDetails", String.to_query f))
         ; Aws.Util.option_map v.platform (fun f ->
               Aws.Query.Pair ("Platform", PlatformValues.to_query f))
         ; Some (Aws.Query.Pair ("ImageOwnerId", String.to_query v.owner_id))
         ; Aws.Util.option_map v.kernel_id (fun f ->
               Aws.Query.Pair ("KernelId", String.to_query f))
         ; Some (Aws.Query.Pair ("IsPublic", Boolean.to_query v.public))
         ; Some (Aws.Query.Pair ("ImageType", ImageTypeValues.to_query v.image_type))
         ; Some (Aws.Query.Pair ("ImageLocation", String.to_query v.image_location))
         ; Some (Aws.Query.Pair ("ImageId", String.to_query v.image_id))
         ; Aws.Util.option_map v.creation_date (fun f ->
               Aws.Query.Pair ("CreationDate", String.to_query f))
         ; Some
             (Aws.Query.Pair ("Architecture", ArchitectureValues.to_query v.architecture))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("virtualizationType", VirtualizationType.to_json v.virtualization_type)
         ; Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.state_reason (fun f ->
               "stateReason", StateReason.to_json f)
         ; Aws.Util.option_map v.sriov_net_support (fun f ->
               "sriovNetSupport", String.to_json f)
         ; Some ("rootDeviceType", DeviceType.to_json v.root_device_type)
         ; Aws.Util.option_map v.root_device_name (fun f ->
               "rootDeviceName", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "name", String.to_json f)
         ; Aws.Util.option_map v.image_owner_alias (fun f ->
               "imageOwnerAlias", String.to_json f)
         ; Some ("hypervisor", HypervisorType.to_json v.hypervisor)
         ; Aws.Util.option_map v.ena_support (fun f -> "enaSupport", Boolean.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Some
             ("blockDeviceMapping", BlockDeviceMappingList.to_json v.block_device_mappings)
         ; Some ("imageState", ImageState.to_json v.state)
         ; Aws.Util.option_map v.ramdisk_id (fun f -> "ramdiskId", String.to_json f)
         ; Some ("productCodes", ProductCodeList.to_json v.product_codes)
         ; Aws.Util.option_map v.usage_operation (fun f ->
               "usageOperation", String.to_json f)
         ; Aws.Util.option_map v.platform_details (fun f ->
               "platformDetails", String.to_json f)
         ; Aws.Util.option_map v.platform (fun f -> "platform", PlatformValues.to_json f)
         ; Some ("imageOwnerId", String.to_json v.owner_id)
         ; Aws.Util.option_map v.kernel_id (fun f -> "kernelId", String.to_json f)
         ; Some ("isPublic", Boolean.to_json v.public)
         ; Some ("imageType", ImageTypeValues.to_json v.image_type)
         ; Some ("imageLocation", String.to_json v.image_location)
         ; Some ("imageId", String.to_json v.image_id)
         ; Aws.Util.option_map v.creation_date (fun f -> "creationDate", String.to_json f)
         ; Some ("architecture", ArchitectureValues.to_json v.architecture)
         ])

  let of_json j =
    { architecture =
        ArchitectureValues.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "architecture"))
    ; creation_date =
        Aws.Util.option_map (Aws.Json.lookup j "creationDate") String.of_json
    ; image_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "imageId"))
    ; image_location =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "imageLocation"))
    ; image_type =
        ImageTypeValues.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "imageType"))
    ; public = Boolean.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "isPublic"))
    ; kernel_id = Aws.Util.option_map (Aws.Json.lookup j "kernelId") String.of_json
    ; owner_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "imageOwnerId"))
    ; platform = Aws.Util.option_map (Aws.Json.lookup j "platform") PlatformValues.of_json
    ; platform_details =
        Aws.Util.option_map (Aws.Json.lookup j "platformDetails") String.of_json
    ; usage_operation =
        Aws.Util.option_map (Aws.Json.lookup j "usageOperation") String.of_json
    ; product_codes =
        ProductCodeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "productCodes"))
    ; ramdisk_id = Aws.Util.option_map (Aws.Json.lookup j "ramdiskId") String.of_json
    ; state = ImageState.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "imageState"))
    ; block_device_mappings =
        BlockDeviceMappingList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "blockDeviceMapping"))
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; ena_support = Aws.Util.option_map (Aws.Json.lookup j "enaSupport") Boolean.of_json
    ; hypervisor =
        HypervisorType.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "hypervisor"))
    ; image_owner_alias =
        Aws.Util.option_map (Aws.Json.lookup j "imageOwnerAlias") String.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "name") String.of_json
    ; root_device_name =
        Aws.Util.option_map (Aws.Json.lookup j "rootDeviceName") String.of_json
    ; root_device_type =
        DeviceType.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "rootDeviceType"))
    ; sriov_net_support =
        Aws.Util.option_map (Aws.Json.lookup j "sriovNetSupport") String.of_json
    ; state_reason =
        Aws.Util.option_map (Aws.Json.lookup j "stateReason") StateReason.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    ; virtualization_type =
        VirtualizationType.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "virtualizationType"))
    }
end

module DescribeTransitGatewayVpcAttachmentsResult = struct
  type t =
    { transit_gateway_vpc_attachments : TransitGatewayVpcAttachmentList.t
    ; next_token : String.t option
    }

  let make ?(transit_gateway_vpc_attachments = []) ?next_token () =
    { transit_gateway_vpc_attachments; next_token }

  let parse xml =
    Some
      { transit_gateway_vpc_attachments =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "transitGatewayVpcAttachments" xml)
               TransitGatewayVpcAttachmentList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayVpcAttachments"
                , TransitGatewayVpcAttachmentList.to_query
                    v.transit_gateway_vpc_attachments ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "transitGatewayVpcAttachments"
             , TransitGatewayVpcAttachmentList.to_json v.transit_gateway_vpc_attachments
             )
         ])

  let of_json j =
    { transit_gateway_vpc_attachments =
        TransitGatewayVpcAttachmentList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "transitGatewayVpcAttachments"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module CreateDefaultVpcRequest = struct
  type t = { dry_run : Boolean.t option }

  let make ?dry_run () = { dry_run }

  let parse xml =
    Some { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f) ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json }
end

module RequestHostIdSet = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module LocalGatewayRouteTableIdSet = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeLocalGatewayRouteTablesRequest = struct
  type t =
    { local_gateway_route_table_ids : LocalGatewayRouteTableIdSet.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make
      ?(local_gateway_route_table_ids = [])
      ?(filters = [])
      ?max_results
      ?next_token
      ?dry_run
      () =
    { local_gateway_route_table_ids; filters; max_results; next_token; dry_run }

  let parse xml =
    Some
      { local_gateway_route_table_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "LocalGatewayRouteTableId" xml)
               LocalGatewayRouteTableIdSet.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ( "LocalGatewayRouteTableId"
                , LocalGatewayRouteTableIdSet.to_query v.local_gateway_route_table_ids ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some
             ( "LocalGatewayRouteTableId"
             , LocalGatewayRouteTableIdSet.to_json v.local_gateway_route_table_ids )
         ])

  let of_json j =
    { local_gateway_route_table_ids =
        LocalGatewayRouteTableIdSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "LocalGatewayRouteTableId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DescribeConversionTasksResult = struct
  type t = { conversion_tasks : DescribeConversionTaskList.t }

  let make ?(conversion_tasks = []) () = { conversion_tasks }

  let parse xml =
    Some
      { conversion_tasks =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "conversionTasks" xml)
               DescribeConversionTaskList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("ConversionTasks", DescribeConversionTaskList.to_query v.conversion_tasks))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("conversionTasks", DescribeConversionTaskList.to_json v.conversion_tasks)
         ])

  let of_json j =
    { conversion_tasks =
        DescribeConversionTaskList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "conversionTasks"))
    }
end

module DescribeBundleTasksRequest = struct
  type t =
    { bundle_ids : BundleIdStringList.t
    ; filters : FilterList.t
    ; dry_run : Boolean.t option
    }

  let make ?(bundle_ids = []) ?(filters = []) ?dry_run () =
    { bundle_ids; filters; dry_run }

  let parse xml =
    Some
      { bundle_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "BundleId" xml)
               BundleIdStringList.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some (Aws.Query.Pair ("BundleId", BundleIdStringList.to_query v.bundle_ids))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some ("BundleId", BundleIdStringList.to_json v.bundle_ids)
         ])

  let of_json j =
    { bundle_ids =
        BundleIdStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "BundleId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module CreateFpgaImageRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; input_storage_location : StorageLocation.t
    ; logs_storage_location : StorageLocation.t option
    ; description : String.t option
    ; name : String.t option
    ; client_token : String.t option
    ; tag_specifications : TagSpecificationList.t
    }

  let make
      ?dry_run
      ~input_storage_location
      ?logs_storage_location
      ?description
      ?name
      ?client_token
      ?(tag_specifications = [])
      () =
    { dry_run
    ; input_storage_location
    ; logs_storage_location
    ; description
    ; name
    ; client_token
    ; tag_specifications
    }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; input_storage_location =
          Aws.Xml.required
            "InputStorageLocation"
            (Aws.Util.option_bind
               (Aws.Xml.member "InputStorageLocation" xml)
               StorageLocation.parse)
      ; logs_storage_location =
          Aws.Util.option_bind
            (Aws.Xml.member "LogsStorageLocation" xml)
            StorageLocation.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.logs_storage_location (fun f ->
               Aws.Query.Pair ("LogsStorageLocation", StorageLocation.to_query f))
         ; Some
             (Aws.Query.Pair
                ("InputStorageLocation", StorageLocation.to_query v.input_storage_location))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.logs_storage_location (fun f ->
               "LogsStorageLocation", StorageLocation.to_json f)
         ; Some ("InputStorageLocation", StorageLocation.to_json v.input_storage_location)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; input_storage_location =
        StorageLocation.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InputStorageLocation"))
    ; logs_storage_location =
        Aws.Util.option_map
          (Aws.Json.lookup j "LogsStorageLocation")
          StorageLocation.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    }
end

module DescribeVpcEndpointServiceConfigurationsResult = struct
  type t =
    { service_configurations : ServiceConfigurationSet.t
    ; next_token : String.t option
    }

  let make ?(service_configurations = []) ?next_token () =
    { service_configurations; next_token }

  let parse xml =
    Some
      { service_configurations =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "serviceConfigurationSet" xml)
               ServiceConfigurationSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ServiceConfigurationSet"
                , ServiceConfigurationSet.to_query v.service_configurations ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "serviceConfigurationSet"
             , ServiceConfigurationSet.to_json v.service_configurations )
         ])

  let of_json j =
    { service_configurations =
        ServiceConfigurationSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "serviceConfigurationSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module RequestSpotLaunchSpecification = struct
  type t =
    { security_group_ids : RequestSpotLaunchSpecificationSecurityGroupIdList.t
    ; security_groups : RequestSpotLaunchSpecificationSecurityGroupList.t
    ; addressing_type : String.t option
    ; block_device_mappings : BlockDeviceMappingList.t
    ; ebs_optimized : Boolean.t option
    ; iam_instance_profile : IamInstanceProfileSpecification.t option
    ; image_id : String.t option
    ; instance_type : InstanceType.t option
    ; kernel_id : String.t option
    ; key_name : String.t option
    ; monitoring : RunInstancesMonitoringEnabled.t option
    ; network_interfaces : InstanceNetworkInterfaceSpecificationList.t
    ; placement : SpotPlacement.t option
    ; ramdisk_id : String.t option
    ; subnet_id : String.t option
    ; user_data : String.t option
    }

  let make
      ?(security_group_ids = [])
      ?(security_groups = [])
      ?addressing_type
      ?(block_device_mappings = [])
      ?ebs_optimized
      ?iam_instance_profile
      ?image_id
      ?instance_type
      ?kernel_id
      ?key_name
      ?monitoring
      ?(network_interfaces = [])
      ?placement
      ?ramdisk_id
      ?subnet_id
      ?user_data
      () =
    { security_group_ids
    ; security_groups
    ; addressing_type
    ; block_device_mappings
    ; ebs_optimized
    ; iam_instance_profile
    ; image_id
    ; instance_type
    ; kernel_id
    ; key_name
    ; monitoring
    ; network_interfaces
    ; placement
    ; ramdisk_id
    ; subnet_id
    ; user_data
    }

  let parse xml =
    Some
      { security_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SecurityGroupId" xml)
               RequestSpotLaunchSpecificationSecurityGroupIdList.parse)
      ; security_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SecurityGroup" xml)
               RequestSpotLaunchSpecificationSecurityGroupList.parse)
      ; addressing_type =
          Aws.Util.option_bind (Aws.Xml.member "addressingType" xml) String.parse
      ; block_device_mappings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "blockDeviceMapping" xml)
               BlockDeviceMappingList.parse)
      ; ebs_optimized =
          Aws.Util.option_bind (Aws.Xml.member "ebsOptimized" xml) Boolean.parse
      ; iam_instance_profile =
          Aws.Util.option_bind
            (Aws.Xml.member "iamInstanceProfile" xml)
            IamInstanceProfileSpecification.parse
      ; image_id = Aws.Util.option_bind (Aws.Xml.member "imageId" xml) String.parse
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) InstanceType.parse
      ; kernel_id = Aws.Util.option_bind (Aws.Xml.member "kernelId" xml) String.parse
      ; key_name = Aws.Util.option_bind (Aws.Xml.member "keyName" xml) String.parse
      ; monitoring =
          Aws.Util.option_bind
            (Aws.Xml.member "monitoring" xml)
            RunInstancesMonitoringEnabled.parse
      ; network_interfaces =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "NetworkInterface" xml)
               InstanceNetworkInterfaceSpecificationList.parse)
      ; placement =
          Aws.Util.option_bind (Aws.Xml.member "placement" xml) SpotPlacement.parse
      ; ramdisk_id = Aws.Util.option_bind (Aws.Xml.member "ramdiskId" xml) String.parse
      ; subnet_id = Aws.Util.option_bind (Aws.Xml.member "subnetId" xml) String.parse
      ; user_data = Aws.Util.option_bind (Aws.Xml.member "userData" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.user_data (fun f ->
               Aws.Query.Pair ("UserData", String.to_query f))
         ; Aws.Util.option_map v.subnet_id (fun f ->
               Aws.Query.Pair ("SubnetId", String.to_query f))
         ; Aws.Util.option_map v.ramdisk_id (fun f ->
               Aws.Query.Pair ("RamdiskId", String.to_query f))
         ; Aws.Util.option_map v.placement (fun f ->
               Aws.Query.Pair ("Placement", SpotPlacement.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "NetworkInterface"
                , InstanceNetworkInterfaceSpecificationList.to_query v.network_interfaces
                ))
         ; Aws.Util.option_map v.monitoring (fun f ->
               Aws.Query.Pair ("Monitoring", RunInstancesMonitoringEnabled.to_query f))
         ; Aws.Util.option_map v.key_name (fun f ->
               Aws.Query.Pair ("KeyName", String.to_query f))
         ; Aws.Util.option_map v.kernel_id (fun f ->
               Aws.Query.Pair ("KernelId", String.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", InstanceType.to_query f))
         ; Aws.Util.option_map v.image_id (fun f ->
               Aws.Query.Pair ("ImageId", String.to_query f))
         ; Aws.Util.option_map v.iam_instance_profile (fun f ->
               Aws.Query.Pair
                 ("IamInstanceProfile", IamInstanceProfileSpecification.to_query f))
         ; Aws.Util.option_map v.ebs_optimized (fun f ->
               Aws.Query.Pair ("EbsOptimized", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "BlockDeviceMapping"
                , BlockDeviceMappingList.to_query v.block_device_mappings ))
         ; Aws.Util.option_map v.addressing_type (fun f ->
               Aws.Query.Pair ("AddressingType", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "SecurityGroup"
                , RequestSpotLaunchSpecificationSecurityGroupList.to_query
                    v.security_groups ))
         ; Some
             (Aws.Query.Pair
                ( "SecurityGroupId"
                , RequestSpotLaunchSpecificationSecurityGroupIdList.to_query
                    v.security_group_ids ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.user_data (fun f -> "userData", String.to_json f)
         ; Aws.Util.option_map v.subnet_id (fun f -> "subnetId", String.to_json f)
         ; Aws.Util.option_map v.ramdisk_id (fun f -> "ramdiskId", String.to_json f)
         ; Aws.Util.option_map v.placement (fun f -> "placement", SpotPlacement.to_json f)
         ; Some
             ( "NetworkInterface"
             , InstanceNetworkInterfaceSpecificationList.to_json v.network_interfaces )
         ; Aws.Util.option_map v.monitoring (fun f ->
               "monitoring", RunInstancesMonitoringEnabled.to_json f)
         ; Aws.Util.option_map v.key_name (fun f -> "keyName", String.to_json f)
         ; Aws.Util.option_map v.kernel_id (fun f -> "kernelId", String.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f ->
               "instanceType", InstanceType.to_json f)
         ; Aws.Util.option_map v.image_id (fun f -> "imageId", String.to_json f)
         ; Aws.Util.option_map v.iam_instance_profile (fun f ->
               "iamInstanceProfile", IamInstanceProfileSpecification.to_json f)
         ; Aws.Util.option_map v.ebs_optimized (fun f ->
               "ebsOptimized", Boolean.to_json f)
         ; Some
             ("blockDeviceMapping", BlockDeviceMappingList.to_json v.block_device_mappings)
         ; Aws.Util.option_map v.addressing_type (fun f ->
               "addressingType", String.to_json f)
         ; Some
             ( "SecurityGroup"
             , RequestSpotLaunchSpecificationSecurityGroupList.to_json v.security_groups
             )
         ; Some
             ( "SecurityGroupId"
             , RequestSpotLaunchSpecificationSecurityGroupIdList.to_json
                 v.security_group_ids )
         ])

  let of_json j =
    { security_group_ids =
        RequestSpotLaunchSpecificationSecurityGroupIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SecurityGroupId"))
    ; security_groups =
        RequestSpotLaunchSpecificationSecurityGroupList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SecurityGroup"))
    ; addressing_type =
        Aws.Util.option_map (Aws.Json.lookup j "addressingType") String.of_json
    ; block_device_mappings =
        BlockDeviceMappingList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "blockDeviceMapping"))
    ; ebs_optimized =
        Aws.Util.option_map (Aws.Json.lookup j "ebsOptimized") Boolean.of_json
    ; iam_instance_profile =
        Aws.Util.option_map
          (Aws.Json.lookup j "iamInstanceProfile")
          IamInstanceProfileSpecification.of_json
    ; image_id = Aws.Util.option_map (Aws.Json.lookup j "imageId") String.of_json
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") InstanceType.of_json
    ; kernel_id = Aws.Util.option_map (Aws.Json.lookup j "kernelId") String.of_json
    ; key_name = Aws.Util.option_map (Aws.Json.lookup j "keyName") String.of_json
    ; monitoring =
        Aws.Util.option_map
          (Aws.Json.lookup j "monitoring")
          RunInstancesMonitoringEnabled.of_json
    ; network_interfaces =
        InstanceNetworkInterfaceSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "NetworkInterface"))
    ; placement =
        Aws.Util.option_map (Aws.Json.lookup j "placement") SpotPlacement.of_json
    ; ramdisk_id = Aws.Util.option_map (Aws.Json.lookup j "ramdiskId") String.of_json
    ; subnet_id = Aws.Util.option_map (Aws.Json.lookup j "subnetId") String.of_json
    ; user_data = Aws.Util.option_map (Aws.Json.lookup j "userData") String.of_json
    }
end

module DeleteTransitGatewayRouteRequest = struct
  type t =
    { transit_gateway_route_table_id : String.t
    ; destination_cidr_block : String.t
    ; dry_run : Boolean.t option
    }

  let make ~transit_gateway_route_table_id ~destination_cidr_block ?dry_run () =
    { transit_gateway_route_table_id; destination_cidr_block; dry_run }

  let parse xml =
    Some
      { transit_gateway_route_table_id =
          Aws.Xml.required
            "TransitGatewayRouteTableId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayRouteTableId" xml)
               String.parse)
      ; destination_cidr_block =
          Aws.Xml.required
            "DestinationCidrBlock"
            (Aws.Util.option_bind
               (Aws.Xml.member "DestinationCidrBlock" xml)
               String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DestinationCidrBlock", String.to_query v.destination_cidr_block))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayRouteTableId"
                , String.to_query v.transit_gateway_route_table_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("DestinationCidrBlock", String.to_json v.destination_cidr_block)
         ; Some
             ( "TransitGatewayRouteTableId"
             , String.to_json v.transit_gateway_route_table_id )
         ])

  let of_json j =
    { transit_gateway_route_table_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayRouteTableId"))
    ; destination_cidr_block =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DestinationCidrBlock"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module CreateSpotDatafeedSubscriptionResult = struct
  type t = { spot_datafeed_subscription : SpotDatafeedSubscription.t option }

  let make ?spot_datafeed_subscription () = { spot_datafeed_subscription }

  let parse xml =
    Some
      { spot_datafeed_subscription =
          Aws.Util.option_bind
            (Aws.Xml.member "spotDatafeedSubscription" xml)
            SpotDatafeedSubscription.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.spot_datafeed_subscription (fun f ->
               Aws.Query.Pair
                 ("SpotDatafeedSubscription", SpotDatafeedSubscription.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.spot_datafeed_subscription (fun f ->
               "spotDatafeedSubscription", SpotDatafeedSubscription.to_json f)
         ])

  let of_json j =
    { spot_datafeed_subscription =
        Aws.Util.option_map
          (Aws.Json.lookup j "spotDatafeedSubscription")
          SpotDatafeedSubscription.of_json
    }
end

module CancelledSpotInstanceRequestList = struct
  type t = CancelledSpotInstanceRequest.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map CancelledSpotInstanceRequest.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list CancelledSpotInstanceRequest.to_query v

  let to_json v = `List (List.map CancelledSpotInstanceRequest.to_json v)

  let of_json j = Aws.Json.to_list CancelledSpotInstanceRequest.of_json j
end

module CancelSpotInstanceRequestsResult = struct
  type t = { cancelled_spot_instance_requests : CancelledSpotInstanceRequestList.t }

  let make ?(cancelled_spot_instance_requests = []) () =
    { cancelled_spot_instance_requests }

  let parse xml =
    Some
      { cancelled_spot_instance_requests =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "spotInstanceRequestSet" xml)
               CancelledSpotInstanceRequestList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "SpotInstanceRequestSet"
                , CancelledSpotInstanceRequestList.to_query
                    v.cancelled_spot_instance_requests ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "spotInstanceRequestSet"
             , CancelledSpotInstanceRequestList.to_json v.cancelled_spot_instance_requests
             )
         ])

  let of_json j =
    { cancelled_spot_instance_requests =
        CancelledSpotInstanceRequestList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "spotInstanceRequestSet"))
    }
end

module AcceptTransitGatewayPeeringAttachmentRequest = struct
  type t =
    { transit_gateway_attachment_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~transit_gateway_attachment_id ?dry_run () =
    { transit_gateway_attachment_id; dry_run }

  let parse xml =
    Some
      { transit_gateway_attachment_id =
          Aws.Xml.required
            "TransitGatewayAttachmentId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayAttachmentId" xml)
               String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayAttachmentId"
                , String.to_query v.transit_gateway_attachment_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ("TransitGatewayAttachmentId", String.to_json v.transit_gateway_attachment_id)
         ])

  let of_json j =
    { transit_gateway_attachment_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayAttachmentId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module TransitGatewayPeeringAttachmentList = struct
  type t = TransitGatewayPeeringAttachment.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map TransitGatewayPeeringAttachment.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list TransitGatewayPeeringAttachment.to_query v

  let to_json v = `List (List.map TransitGatewayPeeringAttachment.to_json v)

  let of_json j = Aws.Json.to_list TransitGatewayPeeringAttachment.of_json j
end

module DescribeTransitGatewayPeeringAttachmentsResult = struct
  type t =
    { transit_gateway_peering_attachments : TransitGatewayPeeringAttachmentList.t
    ; next_token : String.t option
    }

  let make ?(transit_gateway_peering_attachments = []) ?next_token () =
    { transit_gateway_peering_attachments; next_token }

  let parse xml =
    Some
      { transit_gateway_peering_attachments =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "transitGatewayPeeringAttachments" xml)
               TransitGatewayPeeringAttachmentList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayPeeringAttachments"
                , TransitGatewayPeeringAttachmentList.to_query
                    v.transit_gateway_peering_attachments ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "transitGatewayPeeringAttachments"
             , TransitGatewayPeeringAttachmentList.to_json
                 v.transit_gateway_peering_attachments )
         ])

  let of_json j =
    { transit_gateway_peering_attachments =
        TransitGatewayPeeringAttachmentList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "transitGatewayPeeringAttachments"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DescribePrincipalIdFormatRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; resources : ResourceList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?dry_run ?(resources = []) ?max_results ?next_token () =
    { dry_run; resources; max_results; next_token }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; resources =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Resource" xml) ResourceList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Resource", ResourceList.to_query v.resources))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Resource", ResourceList.to_json v.resources)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; resources =
        ResourceList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Resource"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module CreateNatGatewayResult = struct
  type t =
    { client_token : String.t option
    ; nat_gateway : NatGateway.t option
    }

  let make ?client_token ?nat_gateway () = { client_token; nat_gateway }

  let parse xml =
    Some
      { client_token =
          Aws.Util.option_bind (Aws.Xml.member "clientToken" xml) String.parse
      ; nat_gateway =
          Aws.Util.option_bind (Aws.Xml.member "natGateway" xml) NatGateway.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.nat_gateway (fun f ->
               Aws.Query.Pair ("NatGateway", NatGateway.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.nat_gateway (fun f -> "natGateway", NatGateway.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "clientToken", String.to_json f)
         ])

  let of_json j =
    { client_token = Aws.Util.option_map (Aws.Json.lookup j "clientToken") String.of_json
    ; nat_gateway =
        Aws.Util.option_map (Aws.Json.lookup j "natGateway") NatGateway.of_json
    }
end

module TransitGatewayRouteTablePropagation = struct
  type t =
    { transit_gateway_attachment_id : String.t option
    ; resource_id : String.t option
    ; resource_type : TransitGatewayAttachmentResourceType.t option
    ; state : TransitGatewayPropagationState.t option
    }

  let make ?transit_gateway_attachment_id ?resource_id ?resource_type ?state () =
    { transit_gateway_attachment_id; resource_id; resource_type; state }

  let parse xml =
    Some
      { transit_gateway_attachment_id =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayAttachmentId" xml)
            String.parse
      ; resource_id = Aws.Util.option_bind (Aws.Xml.member "resourceId" xml) String.parse
      ; resource_type =
          Aws.Util.option_bind
            (Aws.Xml.member "resourceType" xml)
            TransitGatewayAttachmentResourceType.parse
      ; state =
          Aws.Util.option_bind
            (Aws.Xml.member "state" xml)
            TransitGatewayPropagationState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", TransitGatewayPropagationState.to_query f))
         ; Aws.Util.option_map v.resource_type (fun f ->
               Aws.Query.Pair
                 ("ResourceType", TransitGatewayAttachmentResourceType.to_query f))
         ; Aws.Util.option_map v.resource_id (fun f ->
               Aws.Query.Pair ("ResourceId", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               Aws.Query.Pair ("TransitGatewayAttachmentId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               "state", TransitGatewayPropagationState.to_json f)
         ; Aws.Util.option_map v.resource_type (fun f ->
               "resourceType", TransitGatewayAttachmentResourceType.to_json f)
         ; Aws.Util.option_map v.resource_id (fun f -> "resourceId", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               "transitGatewayAttachmentId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_attachment_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayAttachmentId")
          String.of_json
    ; resource_id = Aws.Util.option_map (Aws.Json.lookup j "resourceId") String.of_json
    ; resource_type =
        Aws.Util.option_map
          (Aws.Json.lookup j "resourceType")
          TransitGatewayAttachmentResourceType.of_json
    ; state =
        Aws.Util.option_map
          (Aws.Json.lookup j "state")
          TransitGatewayPropagationState.of_json
    }
end

module DhcpConfiguration = struct
  type t =
    { key : String.t option
    ; values : DhcpConfigurationValueList.t
    }

  let make ?key ?(values = []) () = { key; values }

  let parse xml =
    Some
      { key = Aws.Util.option_bind (Aws.Xml.member "key" xml) String.parse
      ; values =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "valueSet" xml)
               DhcpConfigurationValueList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("ValueSet", DhcpConfigurationValueList.to_query v.values))
         ; Aws.Util.option_map v.key (fun f -> Aws.Query.Pair ("Key", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("valueSet", DhcpConfigurationValueList.to_json v.values)
         ; Aws.Util.option_map v.key (fun f -> "key", String.to_json f)
         ])

  let of_json j =
    { key = Aws.Util.option_map (Aws.Json.lookup j "key") String.of_json
    ; values =
        DhcpConfigurationValueList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "valueSet"))
    }
end

module DhcpConfigurationList = struct
  type t = DhcpConfiguration.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map DhcpConfiguration.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list DhcpConfiguration.to_query v

  let to_json v = `List (List.map DhcpConfiguration.to_json v)

  let of_json j = Aws.Json.to_list DhcpConfiguration.of_json j
end

module GroupIds = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeSecurityGroupReferencesRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; group_id : GroupIds.t
    }

  let make ?dry_run ~group_id () = { dry_run; group_id }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; group_id =
          Aws.Xml.required
            "GroupId"
            (Aws.Util.option_bind (Aws.Xml.member "GroupId" xml) GroupIds.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("GroupId", GroupIds.to_query v.group_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("GroupId", GroupIds.to_json v.group_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; group_id = GroupIds.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "GroupId"))
    }
end

module ReservedInstancesList = struct
  type t = ReservedInstances.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ReservedInstances.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ReservedInstances.to_query v

  let to_json v = `List (List.map ReservedInstances.to_json v)

  let of_json j = Aws.Json.to_list ReservedInstances.of_json j
end

module DescribeReservedInstancesResult = struct
  type t = { reserved_instances : ReservedInstancesList.t }

  let make ?(reserved_instances = []) () = { reserved_instances }

  let parse xml =
    Some
      { reserved_instances =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "reservedInstancesSet" xml)
               ReservedInstancesList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "ReservedInstancesSet"
                , ReservedInstancesList.to_query v.reserved_instances ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ("reservedInstancesSet", ReservedInstancesList.to_json v.reserved_instances)
         ])

  let of_json j =
    { reserved_instances =
        ReservedInstancesList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "reservedInstancesSet"))
    }
end

module DescribeNetworkInterfaceAttributeResult = struct
  type t =
    { attachment : NetworkInterfaceAttachment.t option
    ; description : AttributeValue.t option
    ; groups : GroupIdentifierList.t
    ; network_interface_id : String.t option
    ; source_dest_check : AttributeBooleanValue.t option
    }

  let make
      ?attachment
      ?description
      ?(groups = [])
      ?network_interface_id
      ?source_dest_check
      () =
    { attachment; description; groups; network_interface_id; source_dest_check }

  let parse xml =
    Some
      { attachment =
          Aws.Util.option_bind
            (Aws.Xml.member "attachment" xml)
            NetworkInterfaceAttachment.parse
      ; description =
          Aws.Util.option_bind (Aws.Xml.member "description" xml) AttributeValue.parse
      ; groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "groupSet" xml)
               GroupIdentifierList.parse)
      ; network_interface_id =
          Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse
      ; source_dest_check =
          Aws.Util.option_bind
            (Aws.Xml.member "sourceDestCheck" xml)
            AttributeBooleanValue.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.source_dest_check (fun f ->
               Aws.Query.Pair ("SourceDestCheck", AttributeBooleanValue.to_query f))
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               Aws.Query.Pair ("NetworkInterfaceId", String.to_query f))
         ; Some (Aws.Query.Pair ("GroupSet", GroupIdentifierList.to_query v.groups))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", AttributeValue.to_query f))
         ; Aws.Util.option_map v.attachment (fun f ->
               Aws.Query.Pair ("Attachment", NetworkInterfaceAttachment.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.source_dest_check (fun f ->
               "sourceDestCheck", AttributeBooleanValue.to_json f)
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               "networkInterfaceId", String.to_json f)
         ; Some ("groupSet", GroupIdentifierList.to_json v.groups)
         ; Aws.Util.option_map v.description (fun f ->
               "description", AttributeValue.to_json f)
         ; Aws.Util.option_map v.attachment (fun f ->
               "attachment", NetworkInterfaceAttachment.to_json f)
         ])

  let of_json j =
    { attachment =
        Aws.Util.option_map
          (Aws.Json.lookup j "attachment")
          NetworkInterfaceAttachment.of_json
    ; description =
        Aws.Util.option_map (Aws.Json.lookup j "description") AttributeValue.of_json
    ; groups =
        GroupIdentifierList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "groupSet"))
    ; network_interface_id =
        Aws.Util.option_map (Aws.Json.lookup j "networkInterfaceId") String.of_json
    ; source_dest_check =
        Aws.Util.option_map
          (Aws.Json.lookup j "sourceDestCheck")
          AttributeBooleanValue.of_json
    }
end

module DeleteCarrierGatewayRequest = struct
  type t =
    { carrier_gateway_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~carrier_gateway_id ?dry_run () = { carrier_gateway_id; dry_run }

  let parse xml =
    Some
      { carrier_gateway_id =
          Aws.Xml.required
            "CarrierGatewayId"
            (Aws.Util.option_bind (Aws.Xml.member "CarrierGatewayId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair ("CarrierGatewayId", String.to_query v.carrier_gateway_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("CarrierGatewayId", String.to_json v.carrier_gateway_id)
         ])

  let of_json j =
    { carrier_gateway_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "CarrierGatewayId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module RejectTransitGatewayVpcAttachmentResult = struct
  type t = { transit_gateway_vpc_attachment : TransitGatewayVpcAttachment.t option }

  let make ?transit_gateway_vpc_attachment () = { transit_gateway_vpc_attachment }

  let parse xml =
    Some
      { transit_gateway_vpc_attachment =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayVpcAttachment" xml)
            TransitGatewayVpcAttachment.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_vpc_attachment (fun f ->
               Aws.Query.Pair
                 ("TransitGatewayVpcAttachment", TransitGatewayVpcAttachment.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_vpc_attachment (fun f ->
               "transitGatewayVpcAttachment", TransitGatewayVpcAttachment.to_json f)
         ])

  let of_json j =
    { transit_gateway_vpc_attachment =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayVpcAttachment")
          TransitGatewayVpcAttachment.of_json
    }
end

module CopyImageRequest = struct
  type t =
    { client_token : String.t option
    ; description : String.t option
    ; encrypted : Boolean.t option
    ; kms_key_id : String.t option
    ; name : String.t
    ; source_image_id : String.t
    ; source_region : String.t
    ; dry_run : Boolean.t option
    }

  let make
      ?client_token
      ?description
      ?encrypted
      ?kms_key_id
      ~name
      ~source_image_id
      ~source_region
      ?dry_run
      () =
    { client_token
    ; description
    ; encrypted
    ; kms_key_id
    ; name
    ; source_image_id
    ; source_region
    ; dry_run
    }

  let parse xml =
    Some
      { client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; encrypted = Aws.Util.option_bind (Aws.Xml.member "encrypted" xml) Boolean.parse
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "kmsKeyId" xml) String.parse
      ; name =
          Aws.Xml.required
            "Name"
            (Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse)
      ; source_image_id =
          Aws.Xml.required
            "SourceImageId"
            (Aws.Util.option_bind (Aws.Xml.member "SourceImageId" xml) String.parse)
      ; source_region =
          Aws.Xml.required
            "SourceRegion"
            (Aws.Util.option_bind (Aws.Xml.member "SourceRegion" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("SourceRegion", String.to_query v.source_region))
         ; Some (Aws.Query.Pair ("SourceImageId", String.to_query v.source_image_id))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Aws.Util.option_map v.encrypted (fun f ->
               Aws.Query.Pair ("Encrypted", Boolean.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("SourceRegion", String.to_json v.source_region)
         ; Some ("SourceImageId", String.to_json v.source_image_id)
         ; Some ("Name", String.to_json v.name)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "kmsKeyId", String.to_json f)
         ; Aws.Util.option_map v.encrypted (fun f -> "encrypted", Boolean.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ])

  let of_json j =
    { client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; encrypted = Aws.Util.option_map (Aws.Json.lookup j "encrypted") Boolean.of_json
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "kmsKeyId") String.of_json
    ; name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Name"))
    ; source_image_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceImageId"))
    ; source_region =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceRegion"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module InstanceStatusEvent = struct
  type t =
    { instance_event_id : String.t option
    ; code : EventCode.t option
    ; description : String.t option
    ; not_after : DateTime.t option
    ; not_before : DateTime.t option
    ; not_before_deadline : DateTime.t option
    }

  let make
      ?instance_event_id
      ?code
      ?description
      ?not_after
      ?not_before
      ?not_before_deadline
      () =
    { instance_event_id; code; description; not_after; not_before; not_before_deadline }

  let parse xml =
    Some
      { instance_event_id =
          Aws.Util.option_bind (Aws.Xml.member "instanceEventId" xml) String.parse
      ; code = Aws.Util.option_bind (Aws.Xml.member "code" xml) EventCode.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; not_after = Aws.Util.option_bind (Aws.Xml.member "notAfter" xml) DateTime.parse
      ; not_before = Aws.Util.option_bind (Aws.Xml.member "notBefore" xml) DateTime.parse
      ; not_before_deadline =
          Aws.Util.option_bind (Aws.Xml.member "notBeforeDeadline" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.not_before_deadline (fun f ->
               Aws.Query.Pair ("NotBeforeDeadline", DateTime.to_query f))
         ; Aws.Util.option_map v.not_before (fun f ->
               Aws.Query.Pair ("NotBefore", DateTime.to_query f))
         ; Aws.Util.option_map v.not_after (fun f ->
               Aws.Query.Pair ("NotAfter", DateTime.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair ("Code", EventCode.to_query f))
         ; Aws.Util.option_map v.instance_event_id (fun f ->
               Aws.Query.Pair ("InstanceEventId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.not_before_deadline (fun f ->
               "notBeforeDeadline", DateTime.to_json f)
         ; Aws.Util.option_map v.not_before (fun f -> "notBefore", DateTime.to_json f)
         ; Aws.Util.option_map v.not_after (fun f -> "notAfter", DateTime.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Aws.Util.option_map v.code (fun f -> "code", EventCode.to_json f)
         ; Aws.Util.option_map v.instance_event_id (fun f ->
               "instanceEventId", String.to_json f)
         ])

  let of_json j =
    { instance_event_id =
        Aws.Util.option_map (Aws.Json.lookup j "instanceEventId") String.of_json
    ; code = Aws.Util.option_map (Aws.Json.lookup j "code") EventCode.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; not_after = Aws.Util.option_map (Aws.Json.lookup j "notAfter") DateTime.of_json
    ; not_before = Aws.Util.option_map (Aws.Json.lookup j "notBefore") DateTime.of_json
    ; not_before_deadline =
        Aws.Util.option_map (Aws.Json.lookup j "notBeforeDeadline") DateTime.of_json
    }
end

module CreateNetworkAclRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; vpc_id : String.t
    ; tag_specifications : TagSpecificationList.t
    }

  let make ?dry_run ~vpc_id ?(tag_specifications = []) () =
    { dry_run; vpc_id; tag_specifications }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; vpc_id =
          Aws.Xml.required
            "vpcId"
            (Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse)
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Some ("vpcId", String.to_json v.vpc_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "vpcId"))
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    }
end

module CreateImageResult = struct
  type t = { image_id : String.t option }

  let make ?image_id () = { image_id }

  let parse xml =
    Some { image_id = Aws.Util.option_bind (Aws.Xml.member "imageId" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.image_id (fun f ->
               Aws.Query.Pair ("ImageId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.image_id (fun f -> "imageId", String.to_json f) ])

  let of_json j =
    { image_id = Aws.Util.option_map (Aws.Json.lookup j "imageId") String.of_json }
end

module DescribeClientVpnConnectionsRequest = struct
  type t =
    { client_vpn_endpoint_id : String.t
    ; filters : FilterList.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    ; dry_run : Boolean.t option
    }

  let make ~client_vpn_endpoint_id ?(filters = []) ?next_token ?max_results ?dry_run () =
    { client_vpn_endpoint_id; filters; next_token; max_results; dry_run }

  let parse xml =
    Some
      { client_vpn_endpoint_id =
          Aws.Xml.required
            "ClientVpnEndpointId"
            (Aws.Util.option_bind (Aws.Xml.member "ClientVpnEndpointId" xml) String.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ("ClientVpnEndpointId", String.to_query v.client_vpn_endpoint_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some ("ClientVpnEndpointId", String.to_json v.client_vpn_endpoint_id)
         ])

  let of_json j =
    { client_vpn_endpoint_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ClientVpnEndpointId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DeleteManagedPrefixListResult = struct
  type t = { prefix_list : ManagedPrefixList.t option }

  let make ?prefix_list () = { prefix_list }

  let parse xml =
    Some
      { prefix_list =
          Aws.Util.option_bind (Aws.Xml.member "prefixList" xml) ManagedPrefixList.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.prefix_list (fun f ->
               Aws.Query.Pair ("PrefixList", ManagedPrefixList.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.prefix_list (fun f ->
               "prefixList", ManagedPrefixList.to_json f)
         ])

  let of_json j =
    { prefix_list =
        Aws.Util.option_map (Aws.Json.lookup j "prefixList") ManagedPrefixList.of_json
    }
end

module ResetFpgaImageAttributeRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; fpga_image_id : String.t
    ; attribute : ResetFpgaImageAttributeName.t option
    }

  let make ?dry_run ~fpga_image_id ?attribute () = { dry_run; fpga_image_id; attribute }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; fpga_image_id =
          Aws.Xml.required
            "FpgaImageId"
            (Aws.Util.option_bind (Aws.Xml.member "FpgaImageId" xml) String.parse)
      ; attribute =
          Aws.Util.option_bind
            (Aws.Xml.member "Attribute" xml)
            ResetFpgaImageAttributeName.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.attribute (fun f ->
               Aws.Query.Pair ("Attribute", ResetFpgaImageAttributeName.to_query f))
         ; Some (Aws.Query.Pair ("FpgaImageId", String.to_query v.fpga_image_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.attribute (fun f ->
               "Attribute", ResetFpgaImageAttributeName.to_json f)
         ; Some ("FpgaImageId", String.to_json v.fpga_image_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; fpga_image_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "FpgaImageId"))
    ; attribute =
        Aws.Util.option_map
          (Aws.Json.lookup j "Attribute")
          ResetFpgaImageAttributeName.of_json
    }
end

module DescribeVpcEndpointConnectionNotificationsResult = struct
  type t =
    { connection_notification_set : ConnectionNotificationSet.t
    ; next_token : String.t option
    }

  let make ?(connection_notification_set = []) ?next_token () =
    { connection_notification_set; next_token }

  let parse xml =
    Some
      { connection_notification_set =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "connectionNotificationSet" xml)
               ConnectionNotificationSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ConnectionNotificationSet"
                , ConnectionNotificationSet.to_query v.connection_notification_set ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "connectionNotificationSet"
             , ConnectionNotificationSet.to_json v.connection_notification_set )
         ])

  let of_json j =
    { connection_notification_set =
        ConnectionNotificationSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "connectionNotificationSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module CreateVpcRequest = struct
  type t =
    { cidr_block : String.t
    ; amazon_provided_ipv6_cidr_block : Boolean.t option
    ; ipv6_pool : String.t option
    ; ipv6_cidr_block : String.t option
    ; dry_run : Boolean.t option
    ; instance_tenancy : Tenancy.t option
    ; ipv6_cidr_block_network_border_group : String.t option
    ; tag_specifications : TagSpecificationList.t
    }

  let make
      ~cidr_block
      ?amazon_provided_ipv6_cidr_block
      ?ipv6_pool
      ?ipv6_cidr_block
      ?dry_run
      ?instance_tenancy
      ?ipv6_cidr_block_network_border_group
      ?(tag_specifications = [])
      () =
    { cidr_block
    ; amazon_provided_ipv6_cidr_block
    ; ipv6_pool
    ; ipv6_cidr_block
    ; dry_run
    ; instance_tenancy
    ; ipv6_cidr_block_network_border_group
    ; tag_specifications
    }

  let parse xml =
    Some
      { cidr_block =
          Aws.Xml.required
            "CidrBlock"
            (Aws.Util.option_bind (Aws.Xml.member "CidrBlock" xml) String.parse)
      ; amazon_provided_ipv6_cidr_block =
          Aws.Util.option_bind
            (Aws.Xml.member "amazonProvidedIpv6CidrBlock" xml)
            Boolean.parse
      ; ipv6_pool = Aws.Util.option_bind (Aws.Xml.member "Ipv6Pool" xml) String.parse
      ; ipv6_cidr_block =
          Aws.Util.option_bind (Aws.Xml.member "Ipv6CidrBlock" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; instance_tenancy =
          Aws.Util.option_bind (Aws.Xml.member "instanceTenancy" xml) Tenancy.parse
      ; ipv6_cidr_block_network_border_group =
          Aws.Util.option_bind
            (Aws.Xml.member "Ipv6CidrBlockNetworkBorderGroup" xml)
            String.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Aws.Util.option_map v.ipv6_cidr_block_network_border_group (fun f ->
               Aws.Query.Pair ("Ipv6CidrBlockNetworkBorderGroup", String.to_query f))
         ; Aws.Util.option_map v.instance_tenancy (fun f ->
               Aws.Query.Pair ("InstanceTenancy", Tenancy.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.ipv6_cidr_block (fun f ->
               Aws.Query.Pair ("Ipv6CidrBlock", String.to_query f))
         ; Aws.Util.option_map v.ipv6_pool (fun f ->
               Aws.Query.Pair ("Ipv6Pool", String.to_query f))
         ; Aws.Util.option_map v.amazon_provided_ipv6_cidr_block (fun f ->
               Aws.Query.Pair ("AmazonProvidedIpv6CidrBlock", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("CidrBlock", String.to_query v.cidr_block))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Aws.Util.option_map v.ipv6_cidr_block_network_border_group (fun f ->
               "Ipv6CidrBlockNetworkBorderGroup", String.to_json f)
         ; Aws.Util.option_map v.instance_tenancy (fun f ->
               "instanceTenancy", Tenancy.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.ipv6_cidr_block (fun f ->
               "Ipv6CidrBlock", String.to_json f)
         ; Aws.Util.option_map v.ipv6_pool (fun f -> "Ipv6Pool", String.to_json f)
         ; Aws.Util.option_map v.amazon_provided_ipv6_cidr_block (fun f ->
               "amazonProvidedIpv6CidrBlock", Boolean.to_json f)
         ; Some ("CidrBlock", String.to_json v.cidr_block)
         ])

  let of_json j =
    { cidr_block = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "CidrBlock"))
    ; amazon_provided_ipv6_cidr_block =
        Aws.Util.option_map
          (Aws.Json.lookup j "amazonProvidedIpv6CidrBlock")
          Boolean.of_json
    ; ipv6_pool = Aws.Util.option_map (Aws.Json.lookup j "Ipv6Pool") String.of_json
    ; ipv6_cidr_block =
        Aws.Util.option_map (Aws.Json.lookup j "Ipv6CidrBlock") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; instance_tenancy =
        Aws.Util.option_map (Aws.Json.lookup j "instanceTenancy") Tenancy.of_json
    ; ipv6_cidr_block_network_border_group =
        Aws.Util.option_map
          (Aws.Json.lookup j "Ipv6CidrBlockNetworkBorderGroup")
          String.of_json
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    }
end

module DescribeNetworkInterfacesResult = struct
  type t =
    { network_interfaces : NetworkInterfaceList.t
    ; next_token : String.t option
    }

  let make ?(network_interfaces = []) ?next_token () = { network_interfaces; next_token }

  let parse xml =
    Some
      { network_interfaces =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "networkInterfaceSet" xml)
               NetworkInterfaceList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("NetworkInterfaceSet", NetworkInterfaceList.to_query v.network_interfaces))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("networkInterfaceSet", NetworkInterfaceList.to_json v.network_interfaces)
         ])

  let of_json j =
    { network_interfaces =
        NetworkInterfaceList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "networkInterfaceSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module GetConsoleScreenshotResult = struct
  type t =
    { image_data : String.t option
    ; instance_id : String.t option
    }

  let make ?image_data ?instance_id () = { image_data; instance_id }

  let parse xml =
    Some
      { image_data = Aws.Util.option_bind (Aws.Xml.member "imageData" xml) String.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.image_data (fun f ->
               Aws.Query.Pair ("ImageData", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ; Aws.Util.option_map v.image_data (fun f -> "imageData", String.to_json f)
         ])

  let of_json j =
    { image_data = Aws.Util.option_map (Aws.Json.lookup j "imageData") String.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    }
end

module VpcAttributeName = struct
  type t =
    | EnableDnsSupport
    | EnableDnsHostnames

  let str_to_t =
    [ "enableDnsHostnames", EnableDnsHostnames; "enableDnsSupport", EnableDnsSupport ]

  let t_to_str =
    [ EnableDnsHostnames, "enableDnsHostnames"; EnableDnsSupport, "enableDnsSupport" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DescribeVpcAttributeRequest = struct
  type t =
    { attribute : VpcAttributeName.t
    ; vpc_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~attribute ~vpc_id ?dry_run () = { attribute; vpc_id; dry_run }

  let parse xml =
    Some
      { attribute =
          Aws.Xml.required
            "Attribute"
            (Aws.Util.option_bind (Aws.Xml.member "Attribute" xml) VpcAttributeName.parse)
      ; vpc_id =
          Aws.Xml.required
            "VpcId"
            (Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ; Some (Aws.Query.Pair ("Attribute", VpcAttributeName.to_query v.attribute))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("VpcId", String.to_json v.vpc_id)
         ; Some ("Attribute", VpcAttributeName.to_json v.attribute)
         ])

  let of_json j =
    { attribute =
        VpcAttributeName.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Attribute"))
    ; vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module InstanceSpecification = struct
  type t =
    { instance_id : String.t option
    ; exclude_boot_volume : Boolean.t option
    }

  let make ?instance_id ?exclude_boot_volume () = { instance_id; exclude_boot_volume }

  let parse xml =
    Some
      { instance_id = Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse
      ; exclude_boot_volume =
          Aws.Util.option_bind (Aws.Xml.member "ExcludeBootVolume" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.exclude_boot_volume (fun f ->
               Aws.Query.Pair ("ExcludeBootVolume", Boolean.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.exclude_boot_volume (fun f ->
               "ExcludeBootVolume", Boolean.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "InstanceId", String.to_json f)
         ])

  let of_json j =
    { instance_id = Aws.Util.option_map (Aws.Json.lookup j "InstanceId") String.of_json
    ; exclude_boot_volume =
        Aws.Util.option_map (Aws.Json.lookup j "ExcludeBootVolume") Boolean.of_json
    }
end

module UpdateSecurityGroupRuleDescriptionsIngressResult = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module NewDhcpConfiguration = struct
  type t =
    { key : String.t option
    ; values : ValueStringList.t
    }

  let make ?key ?(values = []) () = { key; values }

  let parse xml =
    Some
      { key = Aws.Util.option_bind (Aws.Xml.member "key" xml) String.parse
      ; values =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Value" xml) ValueStringList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Value", ValueStringList.to_query v.values))
         ; Aws.Util.option_map v.key (fun f -> Aws.Query.Pair ("Key", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Value", ValueStringList.to_json v.values)
         ; Aws.Util.option_map v.key (fun f -> "key", String.to_json f)
         ])

  let of_json j =
    { key = Aws.Util.option_map (Aws.Json.lookup j "key") String.of_json
    ; values =
        ValueStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Value"))
    }
end

module NewDhcpConfigurationList = struct
  type t = NewDhcpConfiguration.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map NewDhcpConfiguration.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list NewDhcpConfiguration.to_query v

  let to_json v = `List (List.map NewDhcpConfiguration.to_json v)

  let of_json j = Aws.Json.to_list NewDhcpConfiguration.of_json j
end

module CreateDhcpOptionsRequest = struct
  type t =
    { dhcp_configurations : NewDhcpConfigurationList.t
    ; tag_specifications : TagSpecificationList.t
    ; dry_run : Boolean.t option
    }

  let make ~dhcp_configurations ?(tag_specifications = []) ?dry_run () =
    { dhcp_configurations; tag_specifications; dry_run }

  let parse xml =
    Some
      { dhcp_configurations =
          Aws.Xml.required
            "dhcpConfiguration"
            (Aws.Util.option_bind
               (Aws.Xml.member "dhcpConfiguration" xml)
               NewDhcpConfigurationList.parse)
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Some
             (Aws.Query.Pair
                ( "DhcpConfiguration"
                , NewDhcpConfigurationList.to_query v.dhcp_configurations ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Some
             ("dhcpConfiguration", NewDhcpConfigurationList.to_json v.dhcp_configurations)
         ])

  let of_json j =
    { dhcp_configurations =
        NewDhcpConfigurationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "dhcpConfiguration"))
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module CopySnapshotRequest = struct
  type t =
    { description : String.t option
    ; destination_region : String.t option
    ; encrypted : Boolean.t option
    ; kms_key_id : String.t option
    ; presigned_url : String.t option
    ; source_region : String.t
    ; source_snapshot_id : String.t
    ; tag_specifications : TagSpecificationList.t
    ; dry_run : Boolean.t option
    }

  let make
      ?description
      ?destination_region
      ?encrypted
      ?kms_key_id
      ?presigned_url
      ~source_region
      ~source_snapshot_id
      ?(tag_specifications = [])
      ?dry_run
      () =
    { description
    ; destination_region
    ; encrypted
    ; kms_key_id
    ; presigned_url
    ; source_region
    ; source_snapshot_id
    ; tag_specifications
    ; dry_run
    }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; destination_region =
          Aws.Util.option_bind (Aws.Xml.member "destinationRegion" xml) String.parse
      ; encrypted = Aws.Util.option_bind (Aws.Xml.member "encrypted" xml) Boolean.parse
      ; kms_key_id = Aws.Util.option_bind (Aws.Xml.member "kmsKeyId" xml) String.parse
      ; presigned_url =
          Aws.Util.option_bind (Aws.Xml.member "presignedUrl" xml) String.parse
      ; source_region =
          Aws.Xml.required
            "SourceRegion"
            (Aws.Util.option_bind (Aws.Xml.member "SourceRegion" xml) String.parse)
      ; source_snapshot_id =
          Aws.Xml.required
            "SourceSnapshotId"
            (Aws.Util.option_bind (Aws.Xml.member "SourceSnapshotId" xml) String.parse)
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Some
             (Aws.Query.Pair ("SourceSnapshotId", String.to_query v.source_snapshot_id))
         ; Some (Aws.Query.Pair ("SourceRegion", String.to_query v.source_region))
         ; Aws.Util.option_map v.presigned_url (fun f ->
               Aws.Query.Pair ("PresignedUrl", String.to_query f))
         ; Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ; Aws.Util.option_map v.encrypted (fun f ->
               Aws.Query.Pair ("Encrypted", Boolean.to_query f))
         ; Aws.Util.option_map v.destination_region (fun f ->
               Aws.Query.Pair ("DestinationRegion", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Some ("SourceSnapshotId", String.to_json v.source_snapshot_id)
         ; Some ("SourceRegion", String.to_json v.source_region)
         ; Aws.Util.option_map v.presigned_url (fun f -> "presignedUrl", String.to_json f)
         ; Aws.Util.option_map v.kms_key_id (fun f -> "kmsKeyId", String.to_json f)
         ; Aws.Util.option_map v.encrypted (fun f -> "encrypted", Boolean.to_json f)
         ; Aws.Util.option_map v.destination_region (fun f ->
               "destinationRegion", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; destination_region =
        Aws.Util.option_map (Aws.Json.lookup j "destinationRegion") String.of_json
    ; encrypted = Aws.Util.option_map (Aws.Json.lookup j "encrypted") Boolean.of_json
    ; kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "kmsKeyId") String.of_json
    ; presigned_url =
        Aws.Util.option_map (Aws.Json.lookup j "presignedUrl") String.of_json
    ; source_region =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceRegion"))
    ; source_snapshot_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceSnapshotId"))
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module CancelCapacityReservationResult = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module SearchTransitGatewayRoutesRequest = struct
  type t =
    { transit_gateway_route_table_id : String.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; dry_run : Boolean.t option
    }

  let make ~transit_gateway_route_table_id ~filters ?max_results ?dry_run () =
    { transit_gateway_route_table_id; filters; max_results; dry_run }

  let parse xml =
    Some
      { transit_gateway_route_table_id =
          Aws.Xml.required
            "TransitGatewayRouteTableId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayRouteTableId" xml)
               String.parse)
      ; filters =
          Aws.Xml.required
            "Filter"
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayRouteTableId"
                , String.to_query v.transit_gateway_route_table_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some
             ( "TransitGatewayRouteTableId"
             , String.to_json v.transit_gateway_route_table_id )
         ])

  let of_json j =
    { transit_gateway_route_table_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayRouteTableId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module InstanceStatusEventList = struct
  type t = InstanceStatusEvent.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map InstanceStatusEvent.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list InstanceStatusEvent.to_query v

  let to_json v = `List (List.map InstanceStatusEvent.to_json v)

  let of_json j = Aws.Json.to_list InstanceStatusEvent.of_json j
end

module KeyPairList = struct
  type t = KeyPairInfo.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map KeyPairInfo.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list KeyPairInfo.to_query v

  let to_json v = `List (List.map KeyPairInfo.to_json v)

  let of_json j = Aws.Json.to_list KeyPairInfo.of_json j
end

module DeleteManagedPrefixListRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; prefix_list_id : String.t
    }

  let make ?dry_run ~prefix_list_id () = { dry_run; prefix_list_id }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; prefix_list_id =
          Aws.Xml.required
            "PrefixListId"
            (Aws.Util.option_bind (Aws.Xml.member "PrefixListId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("PrefixListId", String.to_query v.prefix_list_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("PrefixListId", String.to_json v.prefix_list_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; prefix_list_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PrefixListId"))
    }
end

module AcceptVpcEndpointConnectionsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; service_id : String.t
    ; vpc_endpoint_ids : VpcEndpointIdList.t
    }

  let make ?dry_run ~service_id ~vpc_endpoint_ids () =
    { dry_run; service_id; vpc_endpoint_ids }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; service_id =
          Aws.Xml.required
            "ServiceId"
            (Aws.Util.option_bind (Aws.Xml.member "ServiceId" xml) String.parse)
      ; vpc_endpoint_ids =
          Aws.Xml.required
            "VpcEndpointId"
            (Aws.Util.option_bind
               (Aws.Xml.member "VpcEndpointId" xml)
               VpcEndpointIdList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("VpcEndpointId", VpcEndpointIdList.to_query v.vpc_endpoint_ids))
         ; Some (Aws.Query.Pair ("ServiceId", String.to_query v.service_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("VpcEndpointId", VpcEndpointIdList.to_json v.vpc_endpoint_ids)
         ; Some ("ServiceId", String.to_json v.service_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; service_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ServiceId"))
    ; vpc_endpoint_ids =
        VpcEndpointIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcEndpointId"))
    }
end

module ResetImageAttributeName = struct
  type t = LaunchPermission

  let str_to_t = [ "launchPermission", LaunchPermission ]

  let t_to_str = [ LaunchPermission, "launchPermission" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module ResetImageAttributeRequest = struct
  type t =
    { attribute : ResetImageAttributeName.t
    ; image_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~attribute ~image_id ?dry_run () = { attribute; image_id; dry_run }

  let parse xml =
    Some
      { attribute =
          Aws.Xml.required
            "Attribute"
            (Aws.Util.option_bind
               (Aws.Xml.member "Attribute" xml)
               ResetImageAttributeName.parse)
      ; image_id =
          Aws.Xml.required
            "ImageId"
            (Aws.Util.option_bind (Aws.Xml.member "ImageId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("ImageId", String.to_query v.image_id))
         ; Some
             (Aws.Query.Pair ("Attribute", ResetImageAttributeName.to_query v.attribute))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("ImageId", String.to_json v.image_id)
         ; Some ("Attribute", ResetImageAttributeName.to_json v.attribute)
         ])

  let of_json j =
    { attribute =
        ResetImageAttributeName.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Attribute"))
    ; image_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ImageId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module ResetEbsDefaultKmsKeyIdResult = struct
  type t = { kms_key_id : String.t option }

  let make ?kms_key_id () = { kms_key_id }

  let parse xml =
    Some
      { kms_key_id = Aws.Util.option_bind (Aws.Xml.member "kmsKeyId" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.kms_key_id (fun f -> "kmsKeyId", String.to_json f) ])

  let of_json j =
    { kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "kmsKeyId") String.of_json }
end

module RegisterTransitGatewayMulticastGroupSourcesRequest = struct
  type t =
    { transit_gateway_multicast_domain_id : String.t option
    ; group_ip_address : String.t option
    ; network_interface_ids : TransitGatewayNetworkInterfaceIdList.t
    ; dry_run : Boolean.t option
    }

  let make
      ?transit_gateway_multicast_domain_id
      ?group_ip_address
      ?(network_interface_ids = [])
      ?dry_run
      () =
    { transit_gateway_multicast_domain_id
    ; group_ip_address
    ; network_interface_ids
    ; dry_run
    }

  let parse xml =
    Some
      { transit_gateway_multicast_domain_id =
          Aws.Util.option_bind
            (Aws.Xml.member "TransitGatewayMulticastDomainId" xml)
            String.parse
      ; group_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "GroupIpAddress" xml) String.parse
      ; network_interface_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "NetworkInterfaceIds" xml)
               TransitGatewayNetworkInterfaceIdList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "NetworkInterfaceIds"
                , TransitGatewayNetworkInterfaceIdList.to_query v.network_interface_ids ))
         ; Aws.Util.option_map v.group_ip_address (fun f ->
               Aws.Query.Pair ("GroupIpAddress", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               Aws.Query.Pair ("TransitGatewayMulticastDomainId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ( "NetworkInterfaceIds"
             , TransitGatewayNetworkInterfaceIdList.to_json v.network_interface_ids )
         ; Aws.Util.option_map v.group_ip_address (fun f ->
               "GroupIpAddress", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               "TransitGatewayMulticastDomainId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_multicast_domain_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "TransitGatewayMulticastDomainId")
          String.of_json
    ; group_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "GroupIpAddress") String.of_json
    ; network_interface_ids =
        TransitGatewayNetworkInterfaceIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "NetworkInterfaceIds"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module VolumeModificationList = struct
  type t = VolumeModification.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map VolumeModification.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list VolumeModification.to_query v

  let to_json v = `List (List.map VolumeModification.to_json v)

  let of_json j = Aws.Json.to_list VolumeModification.of_json j
end

module DescribeVolumesModificationsResult = struct
  type t =
    { volumes_modifications : VolumeModificationList.t
    ; next_token : String.t option
    }

  let make ?(volumes_modifications = []) ?next_token () =
    { volumes_modifications; next_token }

  let parse xml =
    Some
      { volumes_modifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "volumeModificationSet" xml)
               VolumeModificationList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "VolumeModificationSet"
                , VolumeModificationList.to_query v.volumes_modifications ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "volumeModificationSet"
             , VolumeModificationList.to_json v.volumes_modifications )
         ])

  let of_json j =
    { volumes_modifications =
        VolumeModificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "volumeModificationSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module MoveAddressToVpcRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; public_ip : String.t
    }

  let make ?dry_run ~public_ip () = { dry_run; public_ip }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; public_ip =
          Aws.Xml.required
            "publicIp"
            (Aws.Util.option_bind (Aws.Xml.member "publicIp" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("PublicIp", String.to_query v.public_ip))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("publicIp", String.to_json v.public_ip)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; public_ip = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "publicIp"))
    }
end

module DescribeMovingAddressesRequest = struct
  type t =
    { filters : FilterList.t
    ; dry_run : Boolean.t option
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; public_ips : ValueStringList.t
    }

  let make ?(filters = []) ?dry_run ?max_results ?next_token ?(public_ips = []) () =
    { filters; dry_run; max_results; next_token; public_ips }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "filter" xml) FilterList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "maxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; public_ips =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "publicIp" xml) ValueStringList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("PublicIp", ValueStringList.to_query v.public_ips))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("publicIp", ValueStringList.to_json v.public_ips)
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "maxResults", Integer.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "filter"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "maxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; public_ips =
        ValueStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "publicIp"))
    }
end

module LastError = struct
  type t =
    { message : String.t option
    ; code : String.t option
    }

  let make ?message ?code () = { message; code }

  let parse xml =
    Some
      { message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse
      ; code = Aws.Util.option_bind (Aws.Xml.member "code" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair ("Code", String.to_query f))
         ; Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.code (fun f -> "code", String.to_json f)
         ; Aws.Util.option_map v.message (fun f -> "message", String.to_json f)
         ])

  let of_json j =
    { message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json
    ; code = Aws.Util.option_map (Aws.Json.lookup j "code") String.of_json
    }
end

module SecurityGroupIdentifier = struct
  type t =
    { group_id : String.t option
    ; group_name : String.t option
    }

  let make ?group_id ?group_name () = { group_id; group_name }

  let parse xml =
    Some
      { group_id = Aws.Util.option_bind (Aws.Xml.member "groupId" xml) String.parse
      ; group_name = Aws.Util.option_bind (Aws.Xml.member "groupName" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.group_name (fun f ->
               Aws.Query.Pair ("GroupName", String.to_query f))
         ; Aws.Util.option_map v.group_id (fun f ->
               Aws.Query.Pair ("GroupId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.group_name (fun f -> "groupName", String.to_json f)
         ; Aws.Util.option_map v.group_id (fun f -> "groupId", String.to_json f)
         ])

  let of_json j =
    { group_id = Aws.Util.option_map (Aws.Json.lookup j "groupId") String.of_json
    ; group_name = Aws.Util.option_map (Aws.Json.lookup j "groupName") String.of_json
    }
end

module GroupIdentifierSet = struct
  type t = SecurityGroupIdentifier.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map SecurityGroupIdentifier.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list SecurityGroupIdentifier.to_query v

  let to_json v = `List (List.map SecurityGroupIdentifier.to_json v)

  let of_json j = Aws.Json.to_list SecurityGroupIdentifier.of_json j
end

module VpcEndpoint = struct
  type t =
    { vpc_endpoint_id : String.t option
    ; vpc_endpoint_type : VpcEndpointType.t option
    ; vpc_id : String.t option
    ; service_name : String.t option
    ; state : State.t option
    ; policy_document : String.t option
    ; route_table_ids : ValueStringList.t
    ; subnet_ids : ValueStringList.t
    ; groups : GroupIdentifierSet.t
    ; private_dns_enabled : Boolean.t option
    ; requester_managed : Boolean.t option
    ; network_interface_ids : ValueStringList.t
    ; dns_entries : DnsEntrySet.t
    ; creation_timestamp : DateTime.t option
    ; tags : TagList.t
    ; owner_id : String.t option
    ; last_error : LastError.t option
    }

  let make
      ?vpc_endpoint_id
      ?vpc_endpoint_type
      ?vpc_id
      ?service_name
      ?state
      ?policy_document
      ?(route_table_ids = [])
      ?(subnet_ids = [])
      ?(groups = [])
      ?private_dns_enabled
      ?requester_managed
      ?(network_interface_ids = [])
      ?(dns_entries = [])
      ?creation_timestamp
      ?(tags = [])
      ?owner_id
      ?last_error
      () =
    { vpc_endpoint_id
    ; vpc_endpoint_type
    ; vpc_id
    ; service_name
    ; state
    ; policy_document
    ; route_table_ids
    ; subnet_ids
    ; groups
    ; private_dns_enabled
    ; requester_managed
    ; network_interface_ids
    ; dns_entries
    ; creation_timestamp
    ; tags
    ; owner_id
    ; last_error
    }

  let parse xml =
    Some
      { vpc_endpoint_id =
          Aws.Util.option_bind (Aws.Xml.member "vpcEndpointId" xml) String.parse
      ; vpc_endpoint_type =
          Aws.Util.option_bind
            (Aws.Xml.member "vpcEndpointType" xml)
            VpcEndpointType.parse
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse
      ; service_name =
          Aws.Util.option_bind (Aws.Xml.member "serviceName" xml) String.parse
      ; state = Aws.Util.option_bind (Aws.Xml.member "state" xml) State.parse
      ; policy_document =
          Aws.Util.option_bind (Aws.Xml.member "policyDocument" xml) String.parse
      ; route_table_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "routeTableIdSet" xml)
               ValueStringList.parse)
      ; subnet_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "subnetIdSet" xml)
               ValueStringList.parse)
      ; groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "groupSet" xml)
               GroupIdentifierSet.parse)
      ; private_dns_enabled =
          Aws.Util.option_bind (Aws.Xml.member "privateDnsEnabled" xml) Boolean.parse
      ; requester_managed =
          Aws.Util.option_bind (Aws.Xml.member "requesterManaged" xml) Boolean.parse
      ; network_interface_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "networkInterfaceIdSet" xml)
               ValueStringList.parse)
      ; dns_entries =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "dnsEntrySet" xml) DnsEntrySet.parse)
      ; creation_timestamp =
          Aws.Util.option_bind (Aws.Xml.member "creationTimestamp" xml) DateTime.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; last_error = Aws.Util.option_bind (Aws.Xml.member "lastError" xml) LastError.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.last_error (fun f ->
               Aws.Query.Pair ("LastError", LastError.to_query f))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.creation_timestamp (fun f ->
               Aws.Query.Pair ("CreationTimestamp", DateTime.to_query f))
         ; Some (Aws.Query.Pair ("DnsEntrySet", DnsEntrySet.to_query v.dns_entries))
         ; Some
             (Aws.Query.Pair
                ("NetworkInterfaceIdSet", ValueStringList.to_query v.network_interface_ids))
         ; Aws.Util.option_map v.requester_managed (fun f ->
               Aws.Query.Pair ("RequesterManaged", Boolean.to_query f))
         ; Aws.Util.option_map v.private_dns_enabled (fun f ->
               Aws.Query.Pair ("PrivateDnsEnabled", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("GroupSet", GroupIdentifierSet.to_query v.groups))
         ; Some (Aws.Query.Pair ("SubnetIdSet", ValueStringList.to_query v.subnet_ids))
         ; Some
             (Aws.Query.Pair
                ("RouteTableIdSet", ValueStringList.to_query v.route_table_ids))
         ; Aws.Util.option_map v.policy_document (fun f ->
               Aws.Query.Pair ("PolicyDocument", String.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", State.to_query f))
         ; Aws.Util.option_map v.service_name (fun f ->
               Aws.Query.Pair ("ServiceName", String.to_query f))
         ; Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Aws.Util.option_map v.vpc_endpoint_type (fun f ->
               Aws.Query.Pair ("VpcEndpointType", VpcEndpointType.to_query f))
         ; Aws.Util.option_map v.vpc_endpoint_id (fun f ->
               Aws.Query.Pair ("VpcEndpointId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.last_error (fun f -> "lastError", LastError.to_json f)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.creation_timestamp (fun f ->
               "creationTimestamp", DateTime.to_json f)
         ; Some ("dnsEntrySet", DnsEntrySet.to_json v.dns_entries)
         ; Some ("networkInterfaceIdSet", ValueStringList.to_json v.network_interface_ids)
         ; Aws.Util.option_map v.requester_managed (fun f ->
               "requesterManaged", Boolean.to_json f)
         ; Aws.Util.option_map v.private_dns_enabled (fun f ->
               "privateDnsEnabled", Boolean.to_json f)
         ; Some ("groupSet", GroupIdentifierSet.to_json v.groups)
         ; Some ("subnetIdSet", ValueStringList.to_json v.subnet_ids)
         ; Some ("routeTableIdSet", ValueStringList.to_json v.route_table_ids)
         ; Aws.Util.option_map v.policy_document (fun f ->
               "policyDocument", String.to_json f)
         ; Aws.Util.option_map v.state (fun f -> "state", State.to_json f)
         ; Aws.Util.option_map v.service_name (fun f -> "serviceName", String.to_json f)
         ; Aws.Util.option_map v.vpc_id (fun f -> "vpcId", String.to_json f)
         ; Aws.Util.option_map v.vpc_endpoint_type (fun f ->
               "vpcEndpointType", VpcEndpointType.to_json f)
         ; Aws.Util.option_map v.vpc_endpoint_id (fun f ->
               "vpcEndpointId", String.to_json f)
         ])

  let of_json j =
    { vpc_endpoint_id =
        Aws.Util.option_map (Aws.Json.lookup j "vpcEndpointId") String.of_json
    ; vpc_endpoint_type =
        Aws.Util.option_map (Aws.Json.lookup j "vpcEndpointType") VpcEndpointType.of_json
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "vpcId") String.of_json
    ; service_name = Aws.Util.option_map (Aws.Json.lookup j "serviceName") String.of_json
    ; state = Aws.Util.option_map (Aws.Json.lookup j "state") State.of_json
    ; policy_document =
        Aws.Util.option_map (Aws.Json.lookup j "policyDocument") String.of_json
    ; route_table_ids =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "routeTableIdSet"))
    ; subnet_ids =
        ValueStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "subnetIdSet"))
    ; groups =
        GroupIdentifierSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "groupSet"))
    ; private_dns_enabled =
        Aws.Util.option_map (Aws.Json.lookup j "privateDnsEnabled") Boolean.of_json
    ; requester_managed =
        Aws.Util.option_map (Aws.Json.lookup j "requesterManaged") Boolean.of_json
    ; network_interface_ids =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "networkInterfaceIdSet"))
    ; dns_entries =
        DnsEntrySet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "dnsEntrySet"))
    ; creation_timestamp =
        Aws.Util.option_map (Aws.Json.lookup j "creationTimestamp") DateTime.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; last_error = Aws.Util.option_map (Aws.Json.lookup j "lastError") LastError.of_json
    }
end

module CreateVpcEndpointResult = struct
  type t =
    { vpc_endpoint : VpcEndpoint.t option
    ; client_token : String.t option
    }

  let make ?vpc_endpoint ?client_token () = { vpc_endpoint; client_token }

  let parse xml =
    Some
      { vpc_endpoint =
          Aws.Util.option_bind (Aws.Xml.member "vpcEndpoint" xml) VpcEndpoint.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "clientToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.vpc_endpoint (fun f ->
               Aws.Query.Pair ("VpcEndpoint", VpcEndpoint.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f -> "clientToken", String.to_json f)
         ; Aws.Util.option_map v.vpc_endpoint (fun f ->
               "vpcEndpoint", VpcEndpoint.to_json f)
         ])

  let of_json j =
    { vpc_endpoint =
        Aws.Util.option_map (Aws.Json.lookup j "vpcEndpoint") VpcEndpoint.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "clientToken") String.of_json
    }
end

module NetworkInterfacePermissionList = struct
  type t = NetworkInterfacePermission.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map NetworkInterfacePermission.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list NetworkInterfacePermission.to_query v

  let to_json v = `List (List.map NetworkInterfacePermission.to_json v)

  let of_json j = Aws.Json.to_list NetworkInterfacePermission.of_json j
end

module LocalGatewayRouteTableVpcAssociationSet = struct
  type t = LocalGatewayRouteTableVpcAssociation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map LocalGatewayRouteTableVpcAssociation.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list LocalGatewayRouteTableVpcAssociation.to_query v

  let to_json v = `List (List.map LocalGatewayRouteTableVpcAssociation.to_json v)

  let of_json j = Aws.Json.to_list LocalGatewayRouteTableVpcAssociation.of_json j
end

module StartVpcEndpointServicePrivateDnsVerificationResult = struct
  type t = { return_value : Boolean.t option }

  let make ?return_value () = { return_value }

  let parse xml =
    Some
      { return_value = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return_value (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return_value (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return_value = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module CreateClientVpnEndpointResult = struct
  type t =
    { client_vpn_endpoint_id : String.t option
    ; status : ClientVpnEndpointStatus.t option
    ; dns_name : String.t option
    }

  let make ?client_vpn_endpoint_id ?status ?dns_name () =
    { client_vpn_endpoint_id; status; dns_name }

  let parse xml =
    Some
      { client_vpn_endpoint_id =
          Aws.Util.option_bind (Aws.Xml.member "clientVpnEndpointId" xml) String.parse
      ; status =
          Aws.Util.option_bind (Aws.Xml.member "status" xml) ClientVpnEndpointStatus.parse
      ; dns_name = Aws.Util.option_bind (Aws.Xml.member "dnsName" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dns_name (fun f ->
               Aws.Query.Pair ("DnsName", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", ClientVpnEndpointStatus.to_query f))
         ; Aws.Util.option_map v.client_vpn_endpoint_id (fun f ->
               Aws.Query.Pair ("ClientVpnEndpointId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dns_name (fun f -> "dnsName", String.to_json f)
         ; Aws.Util.option_map v.status (fun f ->
               "status", ClientVpnEndpointStatus.to_json f)
         ; Aws.Util.option_map v.client_vpn_endpoint_id (fun f ->
               "clientVpnEndpointId", String.to_json f)
         ])

  let of_json j =
    { client_vpn_endpoint_id =
        Aws.Util.option_map (Aws.Json.lookup j "clientVpnEndpointId") String.of_json
    ; status =
        Aws.Util.option_map (Aws.Json.lookup j "status") ClientVpnEndpointStatus.of_json
    ; dns_name = Aws.Util.option_map (Aws.Json.lookup j "dnsName") String.of_json
    }
end

module CreateTransitGatewayRouteRequest = struct
  type t =
    { destination_cidr_block : String.t
    ; transit_gateway_route_table_id : String.t
    ; transit_gateway_attachment_id : String.t option
    ; blackhole : Boolean.t option
    ; dry_run : Boolean.t option
    }

  let make
      ~destination_cidr_block
      ~transit_gateway_route_table_id
      ?transit_gateway_attachment_id
      ?blackhole
      ?dry_run
      () =
    { destination_cidr_block
    ; transit_gateway_route_table_id
    ; transit_gateway_attachment_id
    ; blackhole
    ; dry_run
    }

  let parse xml =
    Some
      { destination_cidr_block =
          Aws.Xml.required
            "DestinationCidrBlock"
            (Aws.Util.option_bind
               (Aws.Xml.member "DestinationCidrBlock" xml)
               String.parse)
      ; transit_gateway_route_table_id =
          Aws.Xml.required
            "TransitGatewayRouteTableId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayRouteTableId" xml)
               String.parse)
      ; transit_gateway_attachment_id =
          Aws.Util.option_bind
            (Aws.Xml.member "TransitGatewayAttachmentId" xml)
            String.parse
      ; blackhole = Aws.Util.option_bind (Aws.Xml.member "Blackhole" xml) Boolean.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.blackhole (fun f ->
               Aws.Query.Pair ("Blackhole", Boolean.to_query f))
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               Aws.Query.Pair ("TransitGatewayAttachmentId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayRouteTableId"
                , String.to_query v.transit_gateway_route_table_id ))
         ; Some
             (Aws.Query.Pair
                ("DestinationCidrBlock", String.to_query v.destination_cidr_block))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.blackhole (fun f -> "Blackhole", Boolean.to_json f)
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               "TransitGatewayAttachmentId", String.to_json f)
         ; Some
             ( "TransitGatewayRouteTableId"
             , String.to_json v.transit_gateway_route_table_id )
         ; Some ("DestinationCidrBlock", String.to_json v.destination_cidr_block)
         ])

  let of_json j =
    { destination_cidr_block =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DestinationCidrBlock"))
    ; transit_gateway_route_table_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayRouteTableId"))
    ; transit_gateway_attachment_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "TransitGatewayAttachmentId")
          String.of_json
    ; blackhole = Aws.Util.option_map (Aws.Json.lookup j "Blackhole") Boolean.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module TrafficMirrorFilterRuleFieldList = struct
  type t = TrafficMirrorFilterRuleField.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map TrafficMirrorFilterRuleField.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list TrafficMirrorFilterRuleField.to_query v

  let to_json v = `List (List.map TrafficMirrorFilterRuleField.to_json v)

  let of_json j = Aws.Json.to_list TrafficMirrorFilterRuleField.of_json j
end

module ModifyTrafficMirrorFilterRuleRequest = struct
  type t =
    { traffic_mirror_filter_rule_id : String.t
    ; traffic_direction : TrafficDirection.t option
    ; rule_number : Integer.t option
    ; rule_action : TrafficMirrorRuleAction.t option
    ; destination_port_range : TrafficMirrorPortRangeRequest.t option
    ; source_port_range : TrafficMirrorPortRangeRequest.t option
    ; protocol : Integer.t option
    ; destination_cidr_block : String.t option
    ; source_cidr_block : String.t option
    ; description : String.t option
    ; remove_fields : TrafficMirrorFilterRuleFieldList.t
    ; dry_run : Boolean.t option
    }

  let make
      ~traffic_mirror_filter_rule_id
      ?traffic_direction
      ?rule_number
      ?rule_action
      ?destination_port_range
      ?source_port_range
      ?protocol
      ?destination_cidr_block
      ?source_cidr_block
      ?description
      ?(remove_fields = [])
      ?dry_run
      () =
    { traffic_mirror_filter_rule_id
    ; traffic_direction
    ; rule_number
    ; rule_action
    ; destination_port_range
    ; source_port_range
    ; protocol
    ; destination_cidr_block
    ; source_cidr_block
    ; description
    ; remove_fields
    ; dry_run
    }

  let parse xml =
    Some
      { traffic_mirror_filter_rule_id =
          Aws.Xml.required
            "TrafficMirrorFilterRuleId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TrafficMirrorFilterRuleId" xml)
               String.parse)
      ; traffic_direction =
          Aws.Util.option_bind
            (Aws.Xml.member "TrafficDirection" xml)
            TrafficDirection.parse
      ; rule_number = Aws.Util.option_bind (Aws.Xml.member "RuleNumber" xml) Integer.parse
      ; rule_action =
          Aws.Util.option_bind
            (Aws.Xml.member "RuleAction" xml)
            TrafficMirrorRuleAction.parse
      ; destination_port_range =
          Aws.Util.option_bind
            (Aws.Xml.member "DestinationPortRange" xml)
            TrafficMirrorPortRangeRequest.parse
      ; source_port_range =
          Aws.Util.option_bind
            (Aws.Xml.member "SourcePortRange" xml)
            TrafficMirrorPortRangeRequest.parse
      ; protocol = Aws.Util.option_bind (Aws.Xml.member "Protocol" xml) Integer.parse
      ; destination_cidr_block =
          Aws.Util.option_bind (Aws.Xml.member "DestinationCidrBlock" xml) String.parse
      ; source_cidr_block =
          Aws.Util.option_bind (Aws.Xml.member "SourceCidrBlock" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; remove_fields =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "RemoveField" xml)
               TrafficMirrorFilterRuleFieldList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("RemoveField", TrafficMirrorFilterRuleFieldList.to_query v.remove_fields))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.source_cidr_block (fun f ->
               Aws.Query.Pair ("SourceCidrBlock", String.to_query f))
         ; Aws.Util.option_map v.destination_cidr_block (fun f ->
               Aws.Query.Pair ("DestinationCidrBlock", String.to_query f))
         ; Aws.Util.option_map v.protocol (fun f ->
               Aws.Query.Pair ("Protocol", Integer.to_query f))
         ; Aws.Util.option_map v.source_port_range (fun f ->
               Aws.Query.Pair ("SourcePortRange", TrafficMirrorPortRangeRequest.to_query f))
         ; Aws.Util.option_map v.destination_port_range (fun f ->
               Aws.Query.Pair
                 ("DestinationPortRange", TrafficMirrorPortRangeRequest.to_query f))
         ; Aws.Util.option_map v.rule_action (fun f ->
               Aws.Query.Pair ("RuleAction", TrafficMirrorRuleAction.to_query f))
         ; Aws.Util.option_map v.rule_number (fun f ->
               Aws.Query.Pair ("RuleNumber", Integer.to_query f))
         ; Aws.Util.option_map v.traffic_direction (fun f ->
               Aws.Query.Pair ("TrafficDirection", TrafficDirection.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TrafficMirrorFilterRuleId"
                , String.to_query v.traffic_mirror_filter_rule_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("RemoveField", TrafficMirrorFilterRuleFieldList.to_json v.remove_fields)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.source_cidr_block (fun f ->
               "SourceCidrBlock", String.to_json f)
         ; Aws.Util.option_map v.destination_cidr_block (fun f ->
               "DestinationCidrBlock", String.to_json f)
         ; Aws.Util.option_map v.protocol (fun f -> "Protocol", Integer.to_json f)
         ; Aws.Util.option_map v.source_port_range (fun f ->
               "SourcePortRange", TrafficMirrorPortRangeRequest.to_json f)
         ; Aws.Util.option_map v.destination_port_range (fun f ->
               "DestinationPortRange", TrafficMirrorPortRangeRequest.to_json f)
         ; Aws.Util.option_map v.rule_action (fun f ->
               "RuleAction", TrafficMirrorRuleAction.to_json f)
         ; Aws.Util.option_map v.rule_number (fun f -> "RuleNumber", Integer.to_json f)
         ; Aws.Util.option_map v.traffic_direction (fun f ->
               "TrafficDirection", TrafficDirection.to_json f)
         ; Some
             ("TrafficMirrorFilterRuleId", String.to_json v.traffic_mirror_filter_rule_id)
         ])

  let of_json j =
    { traffic_mirror_filter_rule_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TrafficMirrorFilterRuleId"))
    ; traffic_direction =
        Aws.Util.option_map
          (Aws.Json.lookup j "TrafficDirection")
          TrafficDirection.of_json
    ; rule_number = Aws.Util.option_map (Aws.Json.lookup j "RuleNumber") Integer.of_json
    ; rule_action =
        Aws.Util.option_map
          (Aws.Json.lookup j "RuleAction")
          TrafficMirrorRuleAction.of_json
    ; destination_port_range =
        Aws.Util.option_map
          (Aws.Json.lookup j "DestinationPortRange")
          TrafficMirrorPortRangeRequest.of_json
    ; source_port_range =
        Aws.Util.option_map
          (Aws.Json.lookup j "SourcePortRange")
          TrafficMirrorPortRangeRequest.of_json
    ; protocol = Aws.Util.option_map (Aws.Json.lookup j "Protocol") Integer.of_json
    ; destination_cidr_block =
        Aws.Util.option_map (Aws.Json.lookup j "DestinationCidrBlock") String.of_json
    ; source_cidr_block =
        Aws.Util.option_map (Aws.Json.lookup j "SourceCidrBlock") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; remove_fields =
        TrafficMirrorFilterRuleFieldList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "RemoveField"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module EnableVpcClassicLinkDnsSupportResult = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module NetworkInterfaceAttribute = struct
  type t =
    | Description
    | GroupSet
    | SourceDestCheck
    | Attachment

  let str_to_t =
    [ "attachment", Attachment
    ; "sourceDestCheck", SourceDestCheck
    ; "groupSet", GroupSet
    ; "description", Description
    ]

  let t_to_str =
    [ Attachment, "attachment"
    ; SourceDestCheck, "sourceDestCheck"
    ; GroupSet, "groupSet"
    ; Description, "description"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module DescribeNetworkInterfaceAttributeRequest = struct
  type t =
    { attribute : NetworkInterfaceAttribute.t option
    ; dry_run : Boolean.t option
    ; network_interface_id : String.t
    }

  let make ?attribute ?dry_run ~network_interface_id () =
    { attribute; dry_run; network_interface_id }

  let parse xml =
    Some
      { attribute =
          Aws.Util.option_bind
            (Aws.Xml.member "attribute" xml)
            NetworkInterfaceAttribute.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; network_interface_id =
          Aws.Xml.required
            "networkInterfaceId"
            (Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("NetworkInterfaceId", String.to_query v.network_interface_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.attribute (fun f ->
               Aws.Query.Pair ("Attribute", NetworkInterfaceAttribute.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("networkInterfaceId", String.to_json v.network_interface_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.attribute (fun f ->
               "attribute", NetworkInterfaceAttribute.to_json f)
         ])

  let of_json j =
    { attribute =
        Aws.Util.option_map
          (Aws.Json.lookup j "attribute")
          NetworkInterfaceAttribute.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; network_interface_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "networkInterfaceId"))
    }
end

module DescribeTrafficMirrorTargetsResult = struct
  type t =
    { traffic_mirror_targets : TrafficMirrorTargetSet.t
    ; next_token : String.t option
    }

  let make ?(traffic_mirror_targets = []) ?next_token () =
    { traffic_mirror_targets; next_token }

  let parse xml =
    Some
      { traffic_mirror_targets =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "trafficMirrorTargetSet" xml)
               TrafficMirrorTargetSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TrafficMirrorTargetSet"
                , TrafficMirrorTargetSet.to_query v.traffic_mirror_targets ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "trafficMirrorTargetSet"
             , TrafficMirrorTargetSet.to_json v.traffic_mirror_targets )
         ])

  let of_json j =
    { traffic_mirror_targets =
        TrafficMirrorTargetSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "trafficMirrorTargetSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module TransitGatewayRouteTableIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module SnapshotSet = struct
  type t = SnapshotInfo.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map SnapshotInfo.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list SnapshotInfo.to_query v

  let to_json v = `List (List.map SnapshotInfo.to_json v)

  let of_json j = Aws.Json.to_list SnapshotInfo.of_json j
end

module CreateSnapshotsResult = struct
  type t = { snapshots : SnapshotSet.t }

  let make ?(snapshots = []) () = { snapshots }

  let parse xml =
    Some
      { snapshots =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "snapshotSet" xml) SnapshotSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("SnapshotSet", SnapshotSet.to_query v.snapshots)) ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt [ Some ("snapshotSet", SnapshotSet.to_json v.snapshots) ])

  let of_json j =
    { snapshots =
        SnapshotSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "snapshotSet"))
    }
end

module CreateCarrierGatewayResult = struct
  type t = { carrier_gateway : CarrierGateway.t option }

  let make ?carrier_gateway () = { carrier_gateway }

  let parse xml =
    Some
      { carrier_gateway =
          Aws.Util.option_bind (Aws.Xml.member "carrierGateway" xml) CarrierGateway.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.carrier_gateway (fun f ->
               Aws.Query.Pair ("CarrierGateway", CarrierGateway.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.carrier_gateway (fun f ->
               "carrierGateway", CarrierGateway.to_json f)
         ])

  let of_json j =
    { carrier_gateway =
        Aws.Util.option_map (Aws.Json.lookup j "carrierGateway") CarrierGateway.of_json
    }
end

module RequestInstanceTypeList = struct
  type t = InstanceType.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map InstanceType.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list InstanceType.to_query v

  let to_json v = `List (List.map InstanceType.to_json v)

  let of_json j = Aws.Json.to_list InstanceType.of_json j
end

module CreateFleetInstancesSet = struct
  type t = CreateFleetInstance.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map CreateFleetInstance.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list CreateFleetInstance.to_query v

  let to_json v = `List (List.map CreateFleetInstance.to_json v)

  let of_json j = Aws.Json.to_list CreateFleetInstance.of_json j
end

module CreateFleetErrorsSet = struct
  type t = CreateFleetError.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map CreateFleetError.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list CreateFleetError.to_query v

  let to_json v = `List (List.map CreateFleetError.to_json v)

  let of_json j = Aws.Json.to_list CreateFleetError.of_json j
end

module CreateFleetResult = struct
  type t =
    { fleet_id : String.t option
    ; errors : CreateFleetErrorsSet.t
    ; instances : CreateFleetInstancesSet.t
    }

  let make ?fleet_id ?(errors = []) ?(instances = []) () = { fleet_id; errors; instances }

  let parse xml =
    Some
      { fleet_id = Aws.Util.option_bind (Aws.Xml.member "fleetId" xml) String.parse
      ; errors =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "errorSet" xml)
               CreateFleetErrorsSet.parse)
      ; instances =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "fleetInstanceSet" xml)
               CreateFleetInstancesSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("FleetInstanceSet", CreateFleetInstancesSet.to_query v.instances))
         ; Some (Aws.Query.Pair ("ErrorSet", CreateFleetErrorsSet.to_query v.errors))
         ; Aws.Util.option_map v.fleet_id (fun f ->
               Aws.Query.Pair ("FleetId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("fleetInstanceSet", CreateFleetInstancesSet.to_json v.instances)
         ; Some ("errorSet", CreateFleetErrorsSet.to_json v.errors)
         ; Aws.Util.option_map v.fleet_id (fun f -> "fleetId", String.to_json f)
         ])

  let of_json j =
    { fleet_id = Aws.Util.option_map (Aws.Json.lookup j "fleetId") String.of_json
    ; errors =
        CreateFleetErrorsSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "errorSet"))
    ; instances =
        CreateFleetInstancesSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "fleetInstanceSet"))
    }
end

module ScheduledInstance = struct
  type t =
    { availability_zone : String.t option
    ; create_date : DateTime.t option
    ; hourly_price : String.t option
    ; instance_count : Integer.t option
    ; instance_type : String.t option
    ; network_platform : String.t option
    ; next_slot_start_time : DateTime.t option
    ; platform : String.t option
    ; previous_slot_end_time : DateTime.t option
    ; recurrence : ScheduledInstanceRecurrence.t option
    ; scheduled_instance_id : String.t option
    ; slot_duration_in_hours : Integer.t option
    ; term_end_date : DateTime.t option
    ; term_start_date : DateTime.t option
    ; total_scheduled_instance_hours : Integer.t option
    }

  let make
      ?availability_zone
      ?create_date
      ?hourly_price
      ?instance_count
      ?instance_type
      ?network_platform
      ?next_slot_start_time
      ?platform
      ?previous_slot_end_time
      ?recurrence
      ?scheduled_instance_id
      ?slot_duration_in_hours
      ?term_end_date
      ?term_start_date
      ?total_scheduled_instance_hours
      () =
    { availability_zone
    ; create_date
    ; hourly_price
    ; instance_count
    ; instance_type
    ; network_platform
    ; next_slot_start_time
    ; platform
    ; previous_slot_end_time
    ; recurrence
    ; scheduled_instance_id
    ; slot_duration_in_hours
    ; term_end_date
    ; term_start_date
    ; total_scheduled_instance_hours
    }

  let parse xml =
    Some
      { availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; create_date =
          Aws.Util.option_bind (Aws.Xml.member "createDate" xml) DateTime.parse
      ; hourly_price =
          Aws.Util.option_bind (Aws.Xml.member "hourlyPrice" xml) String.parse
      ; instance_count =
          Aws.Util.option_bind (Aws.Xml.member "instanceCount" xml) Integer.parse
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) String.parse
      ; network_platform =
          Aws.Util.option_bind (Aws.Xml.member "networkPlatform" xml) String.parse
      ; next_slot_start_time =
          Aws.Util.option_bind (Aws.Xml.member "nextSlotStartTime" xml) DateTime.parse
      ; platform = Aws.Util.option_bind (Aws.Xml.member "platform" xml) String.parse
      ; previous_slot_end_time =
          Aws.Util.option_bind (Aws.Xml.member "previousSlotEndTime" xml) DateTime.parse
      ; recurrence =
          Aws.Util.option_bind
            (Aws.Xml.member "recurrence" xml)
            ScheduledInstanceRecurrence.parse
      ; scheduled_instance_id =
          Aws.Util.option_bind (Aws.Xml.member "scheduledInstanceId" xml) String.parse
      ; slot_duration_in_hours =
          Aws.Util.option_bind (Aws.Xml.member "slotDurationInHours" xml) Integer.parse
      ; term_end_date =
          Aws.Util.option_bind (Aws.Xml.member "termEndDate" xml) DateTime.parse
      ; term_start_date =
          Aws.Util.option_bind (Aws.Xml.member "termStartDate" xml) DateTime.parse
      ; total_scheduled_instance_hours =
          Aws.Util.option_bind
            (Aws.Xml.member "totalScheduledInstanceHours" xml)
            Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.total_scheduled_instance_hours (fun f ->
               Aws.Query.Pair ("TotalScheduledInstanceHours", Integer.to_query f))
         ; Aws.Util.option_map v.term_start_date (fun f ->
               Aws.Query.Pair ("TermStartDate", DateTime.to_query f))
         ; Aws.Util.option_map v.term_end_date (fun f ->
               Aws.Query.Pair ("TermEndDate", DateTime.to_query f))
         ; Aws.Util.option_map v.slot_duration_in_hours (fun f ->
               Aws.Query.Pair ("SlotDurationInHours", Integer.to_query f))
         ; Aws.Util.option_map v.scheduled_instance_id (fun f ->
               Aws.Query.Pair ("ScheduledInstanceId", String.to_query f))
         ; Aws.Util.option_map v.recurrence (fun f ->
               Aws.Query.Pair ("Recurrence", ScheduledInstanceRecurrence.to_query f))
         ; Aws.Util.option_map v.previous_slot_end_time (fun f ->
               Aws.Query.Pair ("PreviousSlotEndTime", DateTime.to_query f))
         ; Aws.Util.option_map v.platform (fun f ->
               Aws.Query.Pair ("Platform", String.to_query f))
         ; Aws.Util.option_map v.next_slot_start_time (fun f ->
               Aws.Query.Pair ("NextSlotStartTime", DateTime.to_query f))
         ; Aws.Util.option_map v.network_platform (fun f ->
               Aws.Query.Pair ("NetworkPlatform", String.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", String.to_query f))
         ; Aws.Util.option_map v.instance_count (fun f ->
               Aws.Query.Pair ("InstanceCount", Integer.to_query f))
         ; Aws.Util.option_map v.hourly_price (fun f ->
               Aws.Query.Pair ("HourlyPrice", String.to_query f))
         ; Aws.Util.option_map v.create_date (fun f ->
               Aws.Query.Pair ("CreateDate", DateTime.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.total_scheduled_instance_hours (fun f ->
               "totalScheduledInstanceHours", Integer.to_json f)
         ; Aws.Util.option_map v.term_start_date (fun f ->
               "termStartDate", DateTime.to_json f)
         ; Aws.Util.option_map v.term_end_date (fun f ->
               "termEndDate", DateTime.to_json f)
         ; Aws.Util.option_map v.slot_duration_in_hours (fun f ->
               "slotDurationInHours", Integer.to_json f)
         ; Aws.Util.option_map v.scheduled_instance_id (fun f ->
               "scheduledInstanceId", String.to_json f)
         ; Aws.Util.option_map v.recurrence (fun f ->
               "recurrence", ScheduledInstanceRecurrence.to_json f)
         ; Aws.Util.option_map v.previous_slot_end_time (fun f ->
               "previousSlotEndTime", DateTime.to_json f)
         ; Aws.Util.option_map v.platform (fun f -> "platform", String.to_json f)
         ; Aws.Util.option_map v.next_slot_start_time (fun f ->
               "nextSlotStartTime", DateTime.to_json f)
         ; Aws.Util.option_map v.network_platform (fun f ->
               "networkPlatform", String.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f -> "instanceType", String.to_json f)
         ; Aws.Util.option_map v.instance_count (fun f ->
               "instanceCount", Integer.to_json f)
         ; Aws.Util.option_map v.hourly_price (fun f -> "hourlyPrice", String.to_json f)
         ; Aws.Util.option_map v.create_date (fun f -> "createDate", DateTime.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ])

  let of_json j =
    { availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; create_date = Aws.Util.option_map (Aws.Json.lookup j "createDate") DateTime.of_json
    ; hourly_price = Aws.Util.option_map (Aws.Json.lookup j "hourlyPrice") String.of_json
    ; instance_count =
        Aws.Util.option_map (Aws.Json.lookup j "instanceCount") Integer.of_json
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") String.of_json
    ; network_platform =
        Aws.Util.option_map (Aws.Json.lookup j "networkPlatform") String.of_json
    ; next_slot_start_time =
        Aws.Util.option_map (Aws.Json.lookup j "nextSlotStartTime") DateTime.of_json
    ; platform = Aws.Util.option_map (Aws.Json.lookup j "platform") String.of_json
    ; previous_slot_end_time =
        Aws.Util.option_map (Aws.Json.lookup j "previousSlotEndTime") DateTime.of_json
    ; recurrence =
        Aws.Util.option_map
          (Aws.Json.lookup j "recurrence")
          ScheduledInstanceRecurrence.of_json
    ; scheduled_instance_id =
        Aws.Util.option_map (Aws.Json.lookup j "scheduledInstanceId") String.of_json
    ; slot_duration_in_hours =
        Aws.Util.option_map (Aws.Json.lookup j "slotDurationInHours") Integer.of_json
    ; term_end_date =
        Aws.Util.option_map (Aws.Json.lookup j "termEndDate") DateTime.of_json
    ; term_start_date =
        Aws.Util.option_map (Aws.Json.lookup j "termStartDate") DateTime.of_json
    ; total_scheduled_instance_hours =
        Aws.Util.option_map
          (Aws.Json.lookup j "totalScheduledInstanceHours")
          Integer.of_json
    }
end

module PurchasedScheduledInstanceSet = struct
  type t = ScheduledInstance.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ScheduledInstance.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ScheduledInstance.to_query v

  let to_json v = `List (List.map ScheduledInstance.to_json v)

  let of_json j = Aws.Json.to_list ScheduledInstance.of_json j
end

module PurchaseScheduledInstancesResult = struct
  type t = { scheduled_instance_set : PurchasedScheduledInstanceSet.t }

  let make ?(scheduled_instance_set = []) () = { scheduled_instance_set }

  let parse xml =
    Some
      { scheduled_instance_set =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "scheduledInstanceSet" xml)
               PurchasedScheduledInstanceSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "ScheduledInstanceSet"
                , PurchasedScheduledInstanceSet.to_query v.scheduled_instance_set ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "scheduledInstanceSet"
             , PurchasedScheduledInstanceSet.to_json v.scheduled_instance_set )
         ])

  let of_json j =
    { scheduled_instance_set =
        PurchasedScheduledInstanceSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "scheduledInstanceSet"))
    }
end

module CreateTransitGatewayMulticastDomainResult = struct
  type t = { transit_gateway_multicast_domain : TransitGatewayMulticastDomain.t option }

  let make ?transit_gateway_multicast_domain () = { transit_gateway_multicast_domain }

  let parse xml =
    Some
      { transit_gateway_multicast_domain =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayMulticastDomain" xml)
            TransitGatewayMulticastDomain.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_multicast_domain (fun f ->
               Aws.Query.Pair
                 ( "TransitGatewayMulticastDomain"
                 , TransitGatewayMulticastDomain.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_multicast_domain (fun f ->
               "transitGatewayMulticastDomain", TransitGatewayMulticastDomain.to_json f)
         ])

  let of_json j =
    { transit_gateway_multicast_domain =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayMulticastDomain")
          TransitGatewayMulticastDomain.of_json
    }
end

module DescribeTransitGatewayMulticastDomainsRequest = struct
  type t =
    { transit_gateway_multicast_domain_ids : TransitGatewayMulticastDomainIdStringList.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make
      ?(transit_gateway_multicast_domain_ids = [])
      ?(filters = [])
      ?max_results
      ?next_token
      ?dry_run
      () =
    { transit_gateway_multicast_domain_ids; filters; max_results; next_token; dry_run }

  let parse xml =
    Some
      { transit_gateway_multicast_domain_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayMulticastDomainIds" xml)
               TransitGatewayMulticastDomainIdStringList.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayMulticastDomainIds"
                , TransitGatewayMulticastDomainIdStringList.to_query
                    v.transit_gateway_multicast_domain_ids ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some
             ( "TransitGatewayMulticastDomainIds"
             , TransitGatewayMulticastDomainIdStringList.to_json
                 v.transit_gateway_multicast_domain_ids )
         ])

  let of_json j =
    { transit_gateway_multicast_domain_ids =
        TransitGatewayMulticastDomainIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayMulticastDomainIds"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module CreateTrafficMirrorFilterRequest = struct
  type t =
    { description : String.t option
    ; tag_specifications : TagSpecificationList.t
    ; dry_run : Boolean.t option
    ; client_token : String.t option
    }

  let make ?description ?(tag_specifications = []) ?dry_run ?client_token () =
    { description; tag_specifications; dry_run; client_token }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    }
end

module ClientVpnRouteSet = struct
  type t = ClientVpnRoute.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ClientVpnRoute.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ClientVpnRoute.to_query v

  let to_json v = `List (List.map ClientVpnRoute.to_json v)

  let of_json j = Aws.Json.to_list ClientVpnRoute.of_json j
end

module EnableVolumeIORequest = struct
  type t =
    { dry_run : Boolean.t option
    ; volume_id : String.t
    }

  let make ?dry_run ~volume_id () = { dry_run; volume_id }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; volume_id =
          Aws.Xml.required
            "volumeId"
            (Aws.Util.option_bind (Aws.Xml.member "volumeId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("VolumeId", String.to_query v.volume_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("volumeId", String.to_json v.volume_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; volume_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "volumeId"))
    }
end

module AssociateIamInstanceProfileResult = struct
  type t = { iam_instance_profile_association : IamInstanceProfileAssociation.t option }

  let make ?iam_instance_profile_association () = { iam_instance_profile_association }

  let parse xml =
    Some
      { iam_instance_profile_association =
          Aws.Util.option_bind
            (Aws.Xml.member "iamInstanceProfileAssociation" xml)
            IamInstanceProfileAssociation.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.iam_instance_profile_association (fun f ->
               Aws.Query.Pair
                 ( "IamInstanceProfileAssociation"
                 , IamInstanceProfileAssociation.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.iam_instance_profile_association (fun f ->
               "iamInstanceProfileAssociation", IamInstanceProfileAssociation.to_json f)
         ])

  let of_json j =
    { iam_instance_profile_association =
        Aws.Util.option_map
          (Aws.Json.lookup j "iamInstanceProfileAssociation")
          IamInstanceProfileAssociation.of_json
    }
end

module GetEbsEncryptionByDefaultResult = struct
  type t = { ebs_encryption_by_default : Boolean.t option }

  let make ?ebs_encryption_by_default () = { ebs_encryption_by_default }

  let parse xml =
    Some
      { ebs_encryption_by_default =
          Aws.Util.option_bind (Aws.Xml.member "ebsEncryptionByDefault" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ebs_encryption_by_default (fun f ->
               Aws.Query.Pair ("EbsEncryptionByDefault", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ebs_encryption_by_default (fun f ->
               "ebsEncryptionByDefault", Boolean.to_json f)
         ])

  let of_json j =
    { ebs_encryption_by_default =
        Aws.Util.option_map (Aws.Json.lookup j "ebsEncryptionByDefault") Boolean.of_json
    }
end

module DescribeSnapshotsResult = struct
  type t =
    { snapshots : SnapshotList.t
    ; next_token : String.t option
    }

  let make ?(snapshots = []) ?next_token () = { snapshots; next_token }

  let parse xml =
    Some
      { snapshots =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "snapshotSet" xml) SnapshotList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("SnapshotSet", SnapshotList.to_query v.snapshots))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("snapshotSet", SnapshotList.to_json v.snapshots)
         ])

  let of_json j =
    { snapshots =
        SnapshotList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "snapshotSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module ValidationError = struct
  type t =
    { code : String.t option
    ; message : String.t option
    }

  let make ?code ?message () = { code; message }

  let parse xml =
    Some
      { code = Aws.Util.option_bind (Aws.Xml.member "code" xml) String.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair ("Code", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f)
         ; Aws.Util.option_map v.code (fun f -> "code", String.to_json f)
         ])

  let of_json j =
    { code = Aws.Util.option_map (Aws.Json.lookup j "code") String.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json
    }
end

module ErrorSet = struct
  type t = ValidationError.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ValidationError.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ValidationError.to_query v

  let to_json v = `List (List.map ValidationError.to_json v)

  let of_json j = Aws.Json.to_list ValidationError.of_json j
end

module ModifyVpnTunnelCertificateResult = struct
  type t = { vpn_connection : VpnConnection.t option }

  let make ?vpn_connection () = { vpn_connection }

  let parse xml =
    Some
      { vpn_connection =
          Aws.Util.option_bind (Aws.Xml.member "vpnConnection" xml) VpnConnection.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpn_connection (fun f ->
               Aws.Query.Pair ("VpnConnection", VpnConnection.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpn_connection (fun f ->
               "vpnConnection", VpnConnection.to_json f)
         ])

  let of_json j =
    { vpn_connection =
        Aws.Util.option_map (Aws.Json.lookup j "vpnConnection") VpnConnection.of_json
    }
end

module ModifyVpnConnectionRequest = struct
  type t =
    { vpn_connection_id : String.t
    ; transit_gateway_id : String.t option
    ; customer_gateway_id : String.t option
    ; vpn_gateway_id : String.t option
    ; dry_run : Boolean.t option
    }

  let make
      ~vpn_connection_id
      ?transit_gateway_id
      ?customer_gateway_id
      ?vpn_gateway_id
      ?dry_run
      () =
    { vpn_connection_id
    ; transit_gateway_id
    ; customer_gateway_id
    ; vpn_gateway_id
    ; dry_run
    }

  let parse xml =
    Some
      { vpn_connection_id =
          Aws.Xml.required
            "VpnConnectionId"
            (Aws.Util.option_bind (Aws.Xml.member "VpnConnectionId" xml) String.parse)
      ; transit_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "TransitGatewayId" xml) String.parse
      ; customer_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "CustomerGatewayId" xml) String.parse
      ; vpn_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "VpnGatewayId" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.vpn_gateway_id (fun f ->
               Aws.Query.Pair ("VpnGatewayId", String.to_query f))
         ; Aws.Util.option_map v.customer_gateway_id (fun f ->
               Aws.Query.Pair ("CustomerGatewayId", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_id (fun f ->
               Aws.Query.Pair ("TransitGatewayId", String.to_query f))
         ; Some (Aws.Query.Pair ("VpnConnectionId", String.to_query v.vpn_connection_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.vpn_gateway_id (fun f ->
               "VpnGatewayId", String.to_json f)
         ; Aws.Util.option_map v.customer_gateway_id (fun f ->
               "CustomerGatewayId", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_id (fun f ->
               "TransitGatewayId", String.to_json f)
         ; Some ("VpnConnectionId", String.to_json v.vpn_connection_id)
         ])

  let of_json j =
    { vpn_connection_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpnConnectionId"))
    ; transit_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "TransitGatewayId") String.of_json
    ; customer_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "CustomerGatewayId") String.of_json
    ; vpn_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "VpnGatewayId") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DescribeImageAttributeRequest = struct
  type t =
    { attribute : ImageAttributeName.t
    ; image_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~attribute ~image_id ?dry_run () = { attribute; image_id; dry_run }

  let parse xml =
    Some
      { attribute =
          Aws.Xml.required
            "Attribute"
            (Aws.Util.option_bind
               (Aws.Xml.member "Attribute" xml)
               ImageAttributeName.parse)
      ; image_id =
          Aws.Xml.required
            "ImageId"
            (Aws.Util.option_bind (Aws.Xml.member "ImageId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("ImageId", String.to_query v.image_id))
         ; Some (Aws.Query.Pair ("Attribute", ImageAttributeName.to_query v.attribute))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("ImageId", String.to_json v.image_id)
         ; Some ("Attribute", ImageAttributeName.to_json v.attribute)
         ])

  let of_json j =
    { attribute =
        ImageAttributeName.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Attribute"))
    ; image_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ImageId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module CreateInternetGatewayRequest = struct
  type t =
    { tag_specifications : TagSpecificationList.t
    ; dry_run : Boolean.t option
    }

  let make ?(tag_specifications = []) ?dry_run () = { tag_specifications; dry_run }

  let parse xml =
    Some
      { tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ])

  let of_json j =
    { tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module ModifyTransitGatewayRequest = struct
  type t =
    { transit_gateway_id : String.t
    ; description : String.t option
    ; options : ModifyTransitGatewayOptions.t option
    ; dry_run : Boolean.t option
    }

  let make ~transit_gateway_id ?description ?options ?dry_run () =
    { transit_gateway_id; description; options; dry_run }

  let parse xml =
    Some
      { transit_gateway_id =
          Aws.Xml.required
            "TransitGatewayId"
            (Aws.Util.option_bind (Aws.Xml.member "TransitGatewayId" xml) String.parse)
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; options =
          Aws.Util.option_bind
            (Aws.Xml.member "Options" xml)
            ModifyTransitGatewayOptions.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.options (fun f ->
               Aws.Query.Pair ("Options", ModifyTransitGatewayOptions.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Some
             (Aws.Query.Pair ("TransitGatewayId", String.to_query v.transit_gateway_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.options (fun f ->
               "Options", ModifyTransitGatewayOptions.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Some ("TransitGatewayId", String.to_json v.transit_gateway_id)
         ])

  let of_json j =
    { transit_gateway_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayId"))
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; options =
        Aws.Util.option_map
          (Aws.Json.lookup j "Options")
          ModifyTransitGatewayOptions.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DescribeTransitGatewayAttachmentsResult = struct
  type t =
    { transit_gateway_attachments : TransitGatewayAttachmentList.t
    ; next_token : String.t option
    }

  let make ?(transit_gateway_attachments = []) ?next_token () =
    { transit_gateway_attachments; next_token }

  let parse xml =
    Some
      { transit_gateway_attachments =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "transitGatewayAttachments" xml)
               TransitGatewayAttachmentList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayAttachments"
                , TransitGatewayAttachmentList.to_query v.transit_gateway_attachments ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "transitGatewayAttachments"
             , TransitGatewayAttachmentList.to_json v.transit_gateway_attachments )
         ])

  let of_json j =
    { transit_gateway_attachments =
        TransitGatewayAttachmentList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "transitGatewayAttachments"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module GetHostReservationPurchasePreviewResult = struct
  type t =
    { currency_code : CurrencyCodeValues.t option
    ; purchase : PurchaseSet.t
    ; total_hourly_price : String.t option
    ; total_upfront_price : String.t option
    }

  let make ?currency_code ?(purchase = []) ?total_hourly_price ?total_upfront_price () =
    { currency_code; purchase; total_hourly_price; total_upfront_price }

  let parse xml =
    Some
      { currency_code =
          Aws.Util.option_bind
            (Aws.Xml.member "currencyCode" xml)
            CurrencyCodeValues.parse
      ; purchase =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "purchase" xml) PurchaseSet.parse)
      ; total_hourly_price =
          Aws.Util.option_bind (Aws.Xml.member "totalHourlyPrice" xml) String.parse
      ; total_upfront_price =
          Aws.Util.option_bind (Aws.Xml.member "totalUpfrontPrice" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.total_upfront_price (fun f ->
               Aws.Query.Pair ("TotalUpfrontPrice", String.to_query f))
         ; Aws.Util.option_map v.total_hourly_price (fun f ->
               Aws.Query.Pair ("TotalHourlyPrice", String.to_query f))
         ; Some (Aws.Query.Pair ("Purchase", PurchaseSet.to_query v.purchase))
         ; Aws.Util.option_map v.currency_code (fun f ->
               Aws.Query.Pair ("CurrencyCode", CurrencyCodeValues.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.total_upfront_price (fun f ->
               "totalUpfrontPrice", String.to_json f)
         ; Aws.Util.option_map v.total_hourly_price (fun f ->
               "totalHourlyPrice", String.to_json f)
         ; Some ("purchase", PurchaseSet.to_json v.purchase)
         ; Aws.Util.option_map v.currency_code (fun f ->
               "currencyCode", CurrencyCodeValues.to_json f)
         ])

  let of_json j =
    { currency_code =
        Aws.Util.option_map (Aws.Json.lookup j "currencyCode") CurrencyCodeValues.of_json
    ; purchase =
        PurchaseSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "purchase"))
    ; total_hourly_price =
        Aws.Util.option_map (Aws.Json.lookup j "totalHourlyPrice") String.of_json
    ; total_upfront_price =
        Aws.Util.option_map (Aws.Json.lookup j "totalUpfrontPrice") String.of_json
    }
end

module ClassicLinkInstance = struct
  type t =
    { groups : GroupIdentifierList.t
    ; instance_id : String.t option
    ; tags : TagList.t
    ; vpc_id : String.t option
    }

  let make ?(groups = []) ?instance_id ?(tags = []) ?vpc_id () =
    { groups; instance_id; tags; vpc_id }

  let parse xml =
    Some
      { groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "groupSet" xml)
               GroupIdentifierList.parse)
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Some (Aws.Query.Pair ("GroupSet", GroupIdentifierList.to_query v.groups))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_id (fun f -> "vpcId", String.to_json f)
         ; Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ; Some ("groupSet", GroupIdentifierList.to_json v.groups)
         ])

  let of_json j =
    { groups =
        GroupIdentifierList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "groupSet"))
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "vpcId") String.of_json
    }
end

module ClassicLinkInstanceList = struct
  type t = ClassicLinkInstance.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ClassicLinkInstance.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ClassicLinkInstance.to_query v

  let to_json v = `List (List.map ClassicLinkInstance.to_json v)

  let of_json j = Aws.Json.to_list ClassicLinkInstance.of_json j
end

module DescribeClassicLinkInstancesResult = struct
  type t =
    { instances : ClassicLinkInstanceList.t
    ; next_token : String.t option
    }

  let make ?(instances = []) ?next_token () = { instances; next_token }

  let parse xml =
    Some
      { instances =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "instancesSet" xml)
               ClassicLinkInstanceList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair ("InstancesSet", ClassicLinkInstanceList.to_query v.instances))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("instancesSet", ClassicLinkInstanceList.to_json v.instances)
         ])

  let of_json j =
    { instances =
        ClassicLinkInstanceList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "instancesSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module AssociatedRolesList = struct
  type t = AssociatedRole.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map AssociatedRole.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list AssociatedRole.to_query v

  let to_json v = `List (List.map AssociatedRole.to_json v)

  let of_json j = Aws.Json.to_list AssociatedRole.of_json j
end

module VpcEndpointSet = struct
  type t = VpcEndpoint.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map VpcEndpoint.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list VpcEndpoint.to_query v

  let to_json v = `List (List.map VpcEndpoint.to_json v)

  let of_json j = Aws.Json.to_list VpcEndpoint.of_json j
end

module DescribeVpcEndpointsResult = struct
  type t =
    { vpc_endpoints : VpcEndpointSet.t
    ; next_token : String.t option
    }

  let make ?(vpc_endpoints = []) ?next_token () = { vpc_endpoints; next_token }

  let parse xml =
    Some
      { vpc_endpoints =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "vpcEndpointSet" xml)
               VpcEndpointSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair ("VpcEndpointSet", VpcEndpointSet.to_query v.vpc_endpoints))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("vpcEndpointSet", VpcEndpointSet.to_json v.vpc_endpoints)
         ])

  let of_json j =
    { vpc_endpoints =
        VpcEndpointSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "vpcEndpointSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module CancelImportTaskRequest = struct
  type t =
    { cancel_reason : String.t option
    ; dry_run : Boolean.t option
    ; import_task_id : String.t option
    }

  let make ?cancel_reason ?dry_run ?import_task_id () =
    { cancel_reason; dry_run; import_task_id }

  let parse xml =
    Some
      { cancel_reason =
          Aws.Util.option_bind (Aws.Xml.member "CancelReason" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; import_task_id =
          Aws.Util.option_bind (Aws.Xml.member "ImportTaskId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.import_task_id (fun f ->
               Aws.Query.Pair ("ImportTaskId", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.cancel_reason (fun f ->
               Aws.Query.Pair ("CancelReason", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.import_task_id (fun f ->
               "ImportTaskId", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.cancel_reason (fun f -> "CancelReason", String.to_json f)
         ])

  let of_json j =
    { cancel_reason =
        Aws.Util.option_map (Aws.Json.lookup j "CancelReason") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; import_task_id =
        Aws.Util.option_map (Aws.Json.lookup j "ImportTaskId") String.of_json
    }
end

module ModifyClientVpnEndpointResult = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module DescribeInstanceStatusRequest = struct
  type t =
    { filters : FilterList.t
    ; instance_ids : InstanceIdStringList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; dry_run : Boolean.t option
    ; include_all_instances : Boolean.t option
    }

  let make
      ?(filters = [])
      ?(instance_ids = [])
      ?max_results
      ?next_token
      ?dry_run
      ?include_all_instances
      () =
    { filters; instance_ids; max_results; next_token; dry_run; include_all_instances }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; instance_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "InstanceId" xml)
               InstanceIdStringList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; include_all_instances =
          Aws.Util.option_bind (Aws.Xml.member "includeAllInstances" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.include_all_instances (fun f ->
               Aws.Query.Pair ("IncludeAllInstances", Boolean.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair ("InstanceId", InstanceIdStringList.to_query v.instance_ids))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.include_all_instances (fun f ->
               "includeAllInstances", Boolean.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("InstanceId", InstanceIdStringList.to_json v.instance_ids)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; instance_ids =
        InstanceIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; include_all_instances =
        Aws.Util.option_map (Aws.Json.lookup j "includeAllInstances") Boolean.of_json
    }
end

module ImportVolumeRequest = struct
  type t =
    { availability_zone : String.t
    ; description : String.t option
    ; dry_run : Boolean.t option
    ; image : DiskImageDetail.t
    ; volume : VolumeDetail.t
    }

  let make ~availability_zone ?description ?dry_run ~image ~volume () =
    { availability_zone; description; dry_run; image; volume }

  let parse xml =
    Some
      { availability_zone =
          Aws.Xml.required
            "availabilityZone"
            (Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse)
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; image =
          Aws.Xml.required
            "image"
            (Aws.Util.option_bind (Aws.Xml.member "image" xml) DiskImageDetail.parse)
      ; volume =
          Aws.Xml.required
            "volume"
            (Aws.Util.option_bind (Aws.Xml.member "volume" xml) VolumeDetail.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Volume", VolumeDetail.to_query v.volume))
         ; Some (Aws.Query.Pair ("Image", DiskImageDetail.to_query v.image))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Some (Aws.Query.Pair ("AvailabilityZone", String.to_query v.availability_zone))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("volume", VolumeDetail.to_json v.volume)
         ; Some ("image", DiskImageDetail.to_json v.image)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Some ("availabilityZone", String.to_json v.availability_zone)
         ])

  let of_json j =
    { availability_zone =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "availabilityZone"))
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; image = DiskImageDetail.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "image"))
    ; volume = VolumeDetail.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "volume"))
    }
end

module UserData = struct
  type t = { data : String.t option }

  let make ?data () = { data }

  let parse xml =
    Some { data = Aws.Util.option_bind (Aws.Xml.member "data" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.data (fun f ->
               Aws.Query.Pair ("Data", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.data (fun f -> "data", String.to_json f) ])

  let of_json j = { data = Aws.Util.option_map (Aws.Json.lookup j "data") String.of_json }
end

module ImportInstanceLaunchSpecification = struct
  type t =
    { additional_info : String.t option
    ; architecture : ArchitectureValues.t option
    ; group_ids : SecurityGroupIdStringList.t
    ; group_names : SecurityGroupStringList.t
    ; instance_initiated_shutdown_behavior : ShutdownBehavior.t option
    ; instance_type : InstanceType.t option
    ; monitoring : Boolean.t option
    ; placement : Placement.t option
    ; private_ip_address : String.t option
    ; subnet_id : String.t option
    ; user_data : UserData.t option
    }

  let make
      ?additional_info
      ?architecture
      ?(group_ids = [])
      ?(group_names = [])
      ?instance_initiated_shutdown_behavior
      ?instance_type
      ?monitoring
      ?placement
      ?private_ip_address
      ?subnet_id
      ?user_data
      () =
    { additional_info
    ; architecture
    ; group_ids
    ; group_names
    ; instance_initiated_shutdown_behavior
    ; instance_type
    ; monitoring
    ; placement
    ; private_ip_address
    ; subnet_id
    ; user_data
    }

  let parse xml =
    Some
      { additional_info =
          Aws.Util.option_bind (Aws.Xml.member "additionalInfo" xml) String.parse
      ; architecture =
          Aws.Util.option_bind
            (Aws.Xml.member "architecture" xml)
            ArchitectureValues.parse
      ; group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "GroupId" xml)
               SecurityGroupIdStringList.parse)
      ; group_names =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "GroupName" xml)
               SecurityGroupStringList.parse)
      ; instance_initiated_shutdown_behavior =
          Aws.Util.option_bind
            (Aws.Xml.member "instanceInitiatedShutdownBehavior" xml)
            ShutdownBehavior.parse
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) InstanceType.parse
      ; monitoring = Aws.Util.option_bind (Aws.Xml.member "monitoring" xml) Boolean.parse
      ; placement = Aws.Util.option_bind (Aws.Xml.member "placement" xml) Placement.parse
      ; private_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "privateIpAddress" xml) String.parse
      ; subnet_id = Aws.Util.option_bind (Aws.Xml.member "subnetId" xml) String.parse
      ; user_data = Aws.Util.option_bind (Aws.Xml.member "userData" xml) UserData.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.user_data (fun f ->
               Aws.Query.Pair ("UserData", UserData.to_query f))
         ; Aws.Util.option_map v.subnet_id (fun f ->
               Aws.Query.Pair ("SubnetId", String.to_query f))
         ; Aws.Util.option_map v.private_ip_address (fun f ->
               Aws.Query.Pair ("PrivateIpAddress", String.to_query f))
         ; Aws.Util.option_map v.placement (fun f ->
               Aws.Query.Pair ("Placement", Placement.to_query f))
         ; Aws.Util.option_map v.monitoring (fun f ->
               Aws.Query.Pair ("Monitoring", Boolean.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", InstanceType.to_query f))
         ; Aws.Util.option_map v.instance_initiated_shutdown_behavior (fun f ->
               Aws.Query.Pair
                 ("InstanceInitiatedShutdownBehavior", ShutdownBehavior.to_query f))
         ; Some
             (Aws.Query.Pair ("GroupName", SecurityGroupStringList.to_query v.group_names))
         ; Some
             (Aws.Query.Pair ("GroupId", SecurityGroupIdStringList.to_query v.group_ids))
         ; Aws.Util.option_map v.architecture (fun f ->
               Aws.Query.Pair ("Architecture", ArchitectureValues.to_query f))
         ; Aws.Util.option_map v.additional_info (fun f ->
               Aws.Query.Pair ("AdditionalInfo", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.user_data (fun f -> "userData", UserData.to_json f)
         ; Aws.Util.option_map v.subnet_id (fun f -> "subnetId", String.to_json f)
         ; Aws.Util.option_map v.private_ip_address (fun f ->
               "privateIpAddress", String.to_json f)
         ; Aws.Util.option_map v.placement (fun f -> "placement", Placement.to_json f)
         ; Aws.Util.option_map v.monitoring (fun f -> "monitoring", Boolean.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f ->
               "instanceType", InstanceType.to_json f)
         ; Aws.Util.option_map v.instance_initiated_shutdown_behavior (fun f ->
               "instanceInitiatedShutdownBehavior", ShutdownBehavior.to_json f)
         ; Some ("GroupName", SecurityGroupStringList.to_json v.group_names)
         ; Some ("GroupId", SecurityGroupIdStringList.to_json v.group_ids)
         ; Aws.Util.option_map v.architecture (fun f ->
               "architecture", ArchitectureValues.to_json f)
         ; Aws.Util.option_map v.additional_info (fun f ->
               "additionalInfo", String.to_json f)
         ])

  let of_json j =
    { additional_info =
        Aws.Util.option_map (Aws.Json.lookup j "additionalInfo") String.of_json
    ; architecture =
        Aws.Util.option_map (Aws.Json.lookup j "architecture") ArchitectureValues.of_json
    ; group_ids =
        SecurityGroupIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "GroupId"))
    ; group_names =
        SecurityGroupStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "GroupName"))
    ; instance_initiated_shutdown_behavior =
        Aws.Util.option_map
          (Aws.Json.lookup j "instanceInitiatedShutdownBehavior")
          ShutdownBehavior.of_json
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") InstanceType.of_json
    ; monitoring = Aws.Util.option_map (Aws.Json.lookup j "monitoring") Boolean.of_json
    ; placement = Aws.Util.option_map (Aws.Json.lookup j "placement") Placement.of_json
    ; private_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "privateIpAddress") String.of_json
    ; subnet_id = Aws.Util.option_map (Aws.Json.lookup j "subnetId") String.of_json
    ; user_data = Aws.Util.option_map (Aws.Json.lookup j "userData") UserData.of_json
    }
end

module DiskImageList = struct
  type t = DiskImage.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map DiskImage.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list DiskImage.to_query v

  let to_json v = `List (List.map DiskImage.to_json v)

  let of_json j = Aws.Json.to_list DiskImage.of_json j
end

module ImportInstanceRequest = struct
  type t =
    { description : String.t option
    ; disk_images : DiskImageList.t
    ; dry_run : Boolean.t option
    ; launch_specification : ImportInstanceLaunchSpecification.t option
    ; platform : PlatformValues.t
    }

  let make ?description ?(disk_images = []) ?dry_run ?launch_specification ~platform () =
    { description; disk_images; dry_run; launch_specification; platform }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; disk_images =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "diskImage" xml) DiskImageList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; launch_specification =
          Aws.Util.option_bind
            (Aws.Xml.member "launchSpecification" xml)
            ImportInstanceLaunchSpecification.parse
      ; platform =
          Aws.Xml.required
            "platform"
            (Aws.Util.option_bind (Aws.Xml.member "platform" xml) PlatformValues.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Platform", PlatformValues.to_query v.platform))
         ; Aws.Util.option_map v.launch_specification (fun f ->
               Aws.Query.Pair
                 ("LaunchSpecification", ImportInstanceLaunchSpecification.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("DiskImage", DiskImageList.to_query v.disk_images))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("platform", PlatformValues.to_json v.platform)
         ; Aws.Util.option_map v.launch_specification (fun f ->
               "launchSpecification", ImportInstanceLaunchSpecification.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("diskImage", DiskImageList.to_json v.disk_images)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; disk_images =
        DiskImageList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "diskImage"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; launch_specification =
        Aws.Util.option_map
          (Aws.Json.lookup j "launchSpecification")
          ImportInstanceLaunchSpecification.of_json
    ; platform =
        PlatformValues.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "platform"))
    }
end

module StaleSecurityGroupSet = struct
  type t = StaleSecurityGroup.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map StaleSecurityGroup.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list StaleSecurityGroup.to_query v

  let to_json v = `List (List.map StaleSecurityGroup.to_json v)

  let of_json j = Aws.Json.to_list StaleSecurityGroup.of_json j
end

module DeleteTransitGatewayRequest = struct
  type t =
    { transit_gateway_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~transit_gateway_id ?dry_run () = { transit_gateway_id; dry_run }

  let parse xml =
    Some
      { transit_gateway_id =
          Aws.Xml.required
            "TransitGatewayId"
            (Aws.Util.option_bind (Aws.Xml.member "TransitGatewayId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair ("TransitGatewayId", String.to_query v.transit_gateway_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("TransitGatewayId", String.to_json v.transit_gateway_id)
         ])

  let of_json j =
    { transit_gateway_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module BundleInstanceRequest = struct
  type t =
    { instance_id : String.t
    ; storage : Storage.t
    ; dry_run : Boolean.t option
    }

  let make ~instance_id ~storage ?dry_run () = { instance_id; storage; dry_run }

  let parse xml =
    Some
      { instance_id =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse)
      ; storage =
          Aws.Xml.required
            "Storage"
            (Aws.Util.option_bind (Aws.Xml.member "Storage" xml) Storage.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Storage", Storage.to_query v.storage))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("Storage", Storage.to_json v.storage)
         ; Some ("InstanceId", String.to_json v.instance_id)
         ])

  let of_json j =
    { instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; storage = Storage.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Storage"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module InstanceFamilyCreditSpecification = struct
  type t =
    { instance_family : UnlimitedSupportedInstanceFamily.t option
    ; cpu_credits : String.t option
    }

  let make ?instance_family ?cpu_credits () = { instance_family; cpu_credits }

  let parse xml =
    Some
      { instance_family =
          Aws.Util.option_bind
            (Aws.Xml.member "instanceFamily" xml)
            UnlimitedSupportedInstanceFamily.parse
      ; cpu_credits = Aws.Util.option_bind (Aws.Xml.member "cpuCredits" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cpu_credits (fun f ->
               Aws.Query.Pair ("CpuCredits", String.to_query f))
         ; Aws.Util.option_map v.instance_family (fun f ->
               Aws.Query.Pair
                 ("InstanceFamily", UnlimitedSupportedInstanceFamily.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.cpu_credits (fun f -> "cpuCredits", String.to_json f)
         ; Aws.Util.option_map v.instance_family (fun f ->
               "instanceFamily", UnlimitedSupportedInstanceFamily.to_json f)
         ])

  let of_json j =
    { instance_family =
        Aws.Util.option_map
          (Aws.Json.lookup j "instanceFamily")
          UnlimitedSupportedInstanceFamily.of_json
    ; cpu_credits = Aws.Util.option_map (Aws.Json.lookup j "cpuCredits") String.of_json
    }
end

module ModifyDefaultCreditSpecificationResult = struct
  type t =
    { instance_family_credit_specification : InstanceFamilyCreditSpecification.t option }

  let make ?instance_family_credit_specification () =
    { instance_family_credit_specification }

  let parse xml =
    Some
      { instance_family_credit_specification =
          Aws.Util.option_bind
            (Aws.Xml.member "instanceFamilyCreditSpecification" xml)
            InstanceFamilyCreditSpecification.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_family_credit_specification (fun f ->
               Aws.Query.Pair
                 ( "InstanceFamilyCreditSpecification"
                 , InstanceFamilyCreditSpecification.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_family_credit_specification (fun f ->
               ( "instanceFamilyCreditSpecification"
               , InstanceFamilyCreditSpecification.to_json f ))
         ])

  let of_json j =
    { instance_family_credit_specification =
        Aws.Util.option_map
          (Aws.Json.lookup j "instanceFamilyCreditSpecification")
          InstanceFamilyCreditSpecification.of_json
    }
end

module VpcClassicLinkIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "VpcId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeVpcClassicLinkDnsSupportRequest = struct
  type t =
    { max_results : Integer.t option
    ; next_token : String.t option
    ; vpc_ids : VpcClassicLinkIdList.t
    }

  let make ?max_results ?next_token ?(vpc_ids = []) () =
    { max_results; next_token; vpc_ids }

  let parse xml =
    Some
      { max_results = Aws.Util.option_bind (Aws.Xml.member "maxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; vpc_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "VpcIds" xml)
               VpcClassicLinkIdList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("VpcIds", VpcClassicLinkIdList.to_query v.vpc_ids))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("VpcIds", VpcClassicLinkIdList.to_json v.vpc_ids)
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "maxResults", Integer.to_json f)
         ])

  let of_json j =
    { max_results = Aws.Util.option_map (Aws.Json.lookup j "maxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; vpc_ids =
        VpcClassicLinkIdList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcIds"))
    }
end

module DeleteTrafficMirrorFilterRuleResult = struct
  type t = { traffic_mirror_filter_rule_id : String.t option }

  let make ?traffic_mirror_filter_rule_id () = { traffic_mirror_filter_rule_id }

  let parse xml =
    Some
      { traffic_mirror_filter_rule_id =
          Aws.Util.option_bind
            (Aws.Xml.member "trafficMirrorFilterRuleId" xml)
            String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.traffic_mirror_filter_rule_id (fun f ->
               Aws.Query.Pair ("TrafficMirrorFilterRuleId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.traffic_mirror_filter_rule_id (fun f ->
               "trafficMirrorFilterRuleId", String.to_json f)
         ])

  let of_json j =
    { traffic_mirror_filter_rule_id =
        Aws.Util.option_map (Aws.Json.lookup j "trafficMirrorFilterRuleId") String.of_json
    }
end

module RevokeClientVpnIngressResult = struct
  type t = { status : ClientVpnAuthorizationRuleStatus.t option }

  let make ?status () = { status }

  let parse xml =
    Some
      { status =
          Aws.Util.option_bind
            (Aws.Xml.member "status" xml)
            ClientVpnAuthorizationRuleStatus.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", ClientVpnAuthorizationRuleStatus.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               "status", ClientVpnAuthorizationRuleStatus.to_json f)
         ])

  let of_json j =
    { status =
        Aws.Util.option_map
          (Aws.Json.lookup j "status")
          ClientVpnAuthorizationRuleStatus.of_json
    }
end

module SendDiagnosticInterruptRequest = struct
  type t =
    { instance_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~instance_id ?dry_run () = { instance_id; dry_run }

  let parse xml =
    Some
      { instance_id =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("InstanceId", String.to_json v.instance_id)
         ])

  let of_json j =
    { instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DescribeVpcsRequest = struct
  type t =
    { filters : FilterList.t
    ; vpc_ids : VpcIdStringList.t
    ; dry_run : Boolean.t option
    ; next_token : String.t option
    ; max_results : Integer.t option
    }

  let make ?(filters = []) ?(vpc_ids = []) ?dry_run ?next_token ?max_results () =
    { filters; vpc_ids; dry_run; next_token; max_results }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; vpc_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) VpcIdStringList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("VpcId", VpcIdStringList.to_query v.vpc_ids))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("VpcId", VpcIdStringList.to_json v.vpc_ids)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; vpc_ids =
        VpcIdStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module CreateVpcPeeringConnectionRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; peer_owner_id : String.t option
    ; peer_vpc_id : String.t option
    ; vpc_id : String.t option
    ; peer_region : String.t option
    ; tag_specifications : TagSpecificationList.t
    }

  let make
      ?dry_run
      ?peer_owner_id
      ?peer_vpc_id
      ?vpc_id
      ?peer_region
      ?(tag_specifications = [])
      () =
    { dry_run; peer_owner_id; peer_vpc_id; vpc_id; peer_region; tag_specifications }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; peer_owner_id =
          Aws.Util.option_bind (Aws.Xml.member "peerOwnerId" xml) String.parse
      ; peer_vpc_id = Aws.Util.option_bind (Aws.Xml.member "peerVpcId" xml) String.parse
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse
      ; peer_region = Aws.Util.option_bind (Aws.Xml.member "PeerRegion" xml) String.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Aws.Util.option_map v.peer_region (fun f ->
               Aws.Query.Pair ("PeerRegion", String.to_query f))
         ; Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Aws.Util.option_map v.peer_vpc_id (fun f ->
               Aws.Query.Pair ("PeerVpcId", String.to_query f))
         ; Aws.Util.option_map v.peer_owner_id (fun f ->
               Aws.Query.Pair ("PeerOwnerId", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Aws.Util.option_map v.peer_region (fun f -> "PeerRegion", String.to_json f)
         ; Aws.Util.option_map v.vpc_id (fun f -> "vpcId", String.to_json f)
         ; Aws.Util.option_map v.peer_vpc_id (fun f -> "peerVpcId", String.to_json f)
         ; Aws.Util.option_map v.peer_owner_id (fun f -> "peerOwnerId", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; peer_owner_id = Aws.Util.option_map (Aws.Json.lookup j "peerOwnerId") String.of_json
    ; peer_vpc_id = Aws.Util.option_map (Aws.Json.lookup j "peerVpcId") String.of_json
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "vpcId") String.of_json
    ; peer_region = Aws.Util.option_map (Aws.Json.lookup j "PeerRegion") String.of_json
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    }
end

module ClientConnectOptions = struct
  type t =
    { enabled : Boolean.t option
    ; lambda_function_arn : String.t option
    }

  let make ?enabled ?lambda_function_arn () = { enabled; lambda_function_arn }

  let parse xml =
    Some
      { enabled = Aws.Util.option_bind (Aws.Xml.member "Enabled" xml) Boolean.parse
      ; lambda_function_arn =
          Aws.Util.option_bind (Aws.Xml.member "LambdaFunctionArn" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.lambda_function_arn (fun f ->
               Aws.Query.Pair ("LambdaFunctionArn", String.to_query f))
         ; Aws.Util.option_map v.enabled (fun f ->
               Aws.Query.Pair ("Enabled", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.lambda_function_arn (fun f ->
               "LambdaFunctionArn", String.to_json f)
         ; Aws.Util.option_map v.enabled (fun f -> "Enabled", Boolean.to_json f)
         ])

  let of_json j =
    { enabled = Aws.Util.option_map (Aws.Json.lookup j "Enabled") Boolean.of_json
    ; lambda_function_arn =
        Aws.Util.option_map (Aws.Json.lookup j "LambdaFunctionArn") String.of_json
    }
end

module ModifyTrafficMirrorFilterNetworkServicesRequest = struct
  type t =
    { traffic_mirror_filter_id : String.t
    ; add_network_services : TrafficMirrorNetworkServiceList.t
    ; remove_network_services : TrafficMirrorNetworkServiceList.t
    ; dry_run : Boolean.t option
    }

  let make
      ~traffic_mirror_filter_id
      ?(add_network_services = [])
      ?(remove_network_services = [])
      ?dry_run
      () =
    { traffic_mirror_filter_id; add_network_services; remove_network_services; dry_run }

  let parse xml =
    Some
      { traffic_mirror_filter_id =
          Aws.Xml.required
            "TrafficMirrorFilterId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TrafficMirrorFilterId" xml)
               String.parse)
      ; add_network_services =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AddNetworkService" xml)
               TrafficMirrorNetworkServiceList.parse)
      ; remove_network_services =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "RemoveNetworkService" xml)
               TrafficMirrorNetworkServiceList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "RemoveNetworkService"
                , TrafficMirrorNetworkServiceList.to_query v.remove_network_services ))
         ; Some
             (Aws.Query.Pair
                ( "AddNetworkService"
                , TrafficMirrorNetworkServiceList.to_query v.add_network_services ))
         ; Some
             (Aws.Query.Pair
                ("TrafficMirrorFilterId", String.to_query v.traffic_mirror_filter_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ( "RemoveNetworkService"
             , TrafficMirrorNetworkServiceList.to_json v.remove_network_services )
         ; Some
             ( "AddNetworkService"
             , TrafficMirrorNetworkServiceList.to_json v.add_network_services )
         ; Some ("TrafficMirrorFilterId", String.to_json v.traffic_mirror_filter_id)
         ])

  let of_json j =
    { traffic_mirror_filter_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TrafficMirrorFilterId"))
    ; add_network_services =
        TrafficMirrorNetworkServiceList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AddNetworkService"))
    ; remove_network_services =
        TrafficMirrorNetworkServiceList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "RemoveNetworkService"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module ImportClientVpnClientCertificateRevocationListRequest = struct
  type t =
    { client_vpn_endpoint_id : String.t
    ; certificate_revocation_list : String.t
    ; dry_run : Boolean.t option
    }

  let make ~client_vpn_endpoint_id ~certificate_revocation_list ?dry_run () =
    { client_vpn_endpoint_id; certificate_revocation_list; dry_run }

  let parse xml =
    Some
      { client_vpn_endpoint_id =
          Aws.Xml.required
            "ClientVpnEndpointId"
            (Aws.Util.option_bind (Aws.Xml.member "ClientVpnEndpointId" xml) String.parse)
      ; certificate_revocation_list =
          Aws.Xml.required
            "CertificateRevocationList"
            (Aws.Util.option_bind
               (Aws.Xml.member "CertificateRevocationList" xml)
               String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "CertificateRevocationList"
                , String.to_query v.certificate_revocation_list ))
         ; Some
             (Aws.Query.Pair
                ("ClientVpnEndpointId", String.to_query v.client_vpn_endpoint_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("CertificateRevocationList", String.to_json v.certificate_revocation_list)
         ; Some ("ClientVpnEndpointId", String.to_json v.client_vpn_endpoint_id)
         ])

  let of_json j =
    { client_vpn_endpoint_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ClientVpnEndpointId"))
    ; certificate_revocation_list =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "CertificateRevocationList"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module ScheduledInstanceSet = struct
  type t = ScheduledInstance.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ScheduledInstance.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ScheduledInstance.to_query v

  let to_json v = `List (List.map ScheduledInstance.to_json v)

  let of_json j = Aws.Json.to_list ScheduledInstance.of_json j
end

module ModifyVpcPeeringConnectionOptionsResult = struct
  type t =
    { accepter_peering_connection_options : PeeringConnectionOptions.t option
    ; requester_peering_connection_options : PeeringConnectionOptions.t option
    }

  let make ?accepter_peering_connection_options ?requester_peering_connection_options () =
    { accepter_peering_connection_options; requester_peering_connection_options }

  let parse xml =
    Some
      { accepter_peering_connection_options =
          Aws.Util.option_bind
            (Aws.Xml.member "accepterPeeringConnectionOptions" xml)
            PeeringConnectionOptions.parse
      ; requester_peering_connection_options =
          Aws.Util.option_bind
            (Aws.Xml.member "requesterPeeringConnectionOptions" xml)
            PeeringConnectionOptions.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.requester_peering_connection_options (fun f ->
               Aws.Query.Pair
                 ("RequesterPeeringConnectionOptions", PeeringConnectionOptions.to_query f))
         ; Aws.Util.option_map v.accepter_peering_connection_options (fun f ->
               Aws.Query.Pair
                 ("AccepterPeeringConnectionOptions", PeeringConnectionOptions.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.requester_peering_connection_options (fun f ->
               "requesterPeeringConnectionOptions", PeeringConnectionOptions.to_json f)
         ; Aws.Util.option_map v.accepter_peering_connection_options (fun f ->
               "accepterPeeringConnectionOptions", PeeringConnectionOptions.to_json f)
         ])

  let of_json j =
    { accepter_peering_connection_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "accepterPeeringConnectionOptions")
          PeeringConnectionOptions.of_json
    ; requester_peering_connection_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "requesterPeeringConnectionOptions")
          PeeringConnectionOptions.of_json
    }
end

module DeregisterInstanceEventNotificationAttributesRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; instance_tag_attribute : DeregisterInstanceTagAttributeRequest.t option
    }

  let make ?dry_run ?instance_tag_attribute () = { dry_run; instance_tag_attribute }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; instance_tag_attribute =
          Aws.Util.option_bind
            (Aws.Xml.member "InstanceTagAttribute" xml)
            DeregisterInstanceTagAttributeRequest.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_tag_attribute (fun f ->
               Aws.Query.Pair
                 ("InstanceTagAttribute", DeregisterInstanceTagAttributeRequest.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_tag_attribute (fun f ->
               "InstanceTagAttribute", DeregisterInstanceTagAttributeRequest.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; instance_tag_attribute =
        Aws.Util.option_map
          (Aws.Json.lookup j "InstanceTagAttribute")
          DeregisterInstanceTagAttributeRequest.of_json
    }
end

module DeleteTagsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; resources : ResourceIdList.t
    ; tags : TagList.t
    }

  let make ?dry_run ~resources ?(tags = []) () = { dry_run; resources; tags }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; resources =
          Aws.Xml.required
            "resourceId"
            (Aws.Util.option_bind (Aws.Xml.member "resourceId" xml) ResourceIdList.parse)
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tag" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Tag", TagList.to_query v.tags))
         ; Some (Aws.Query.Pair ("ResourceId", ResourceIdList.to_query v.resources))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tag", TagList.to_json v.tags)
         ; Some ("resourceId", ResourceIdList.to_json v.resources)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; resources =
        ResourceIdList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "resourceId"))
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tag"))
    }
end

module ImageList = struct
  type t = Image.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map Image.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Image.to_query v

  let to_json v = `List (List.map Image.to_json v)

  let of_json j = Aws.Json.to_list Image.of_json j
end

module SelfServicePortal = struct
  type t =
    | Enabled
    | Disabled

  let str_to_t = [ "disabled", Disabled; "enabled", Enabled ]

  let t_to_str = [ Disabled, "disabled"; Enabled, "enabled" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module CreateLocalGatewayRouteResult = struct
  type t = { route : LocalGatewayRoute.t option }

  let make ?route () = { route }

  let parse xml =
    Some
      { route = Aws.Util.option_bind (Aws.Xml.member "route" xml) LocalGatewayRoute.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.route (fun f ->
               Aws.Query.Pair ("Route", LocalGatewayRoute.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.route (fun f -> "route", LocalGatewayRoute.to_json f) ])

  let of_json j =
    { route = Aws.Util.option_map (Aws.Json.lookup j "route") LocalGatewayRoute.of_json }
end

module ClientVpnAuthenticationRequestList = struct
  type t = ClientVpnAuthenticationRequest.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map ClientVpnAuthenticationRequest.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list ClientVpnAuthenticationRequest.to_query v

  let to_json v = `List (List.map ClientVpnAuthenticationRequest.to_json v)

  let of_json j = Aws.Json.to_list ClientVpnAuthenticationRequest.of_json j
end

module GetEbsDefaultKmsKeyIdRequest = struct
  type t = { dry_run : Boolean.t option }

  let make ?dry_run () = { dry_run }

  let parse xml =
    Some { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f) ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json }
end

module GetAssociatedIpv6PoolCidrsRequest = struct
  type t =
    { pool_id : String.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    ; dry_run : Boolean.t option
    }

  let make ~pool_id ?next_token ?max_results ?dry_run () =
    { pool_id; next_token; max_results; dry_run }

  let parse xml =
    Some
      { pool_id =
          Aws.Xml.required
            "PoolId"
            (Aws.Util.option_bind (Aws.Xml.member "PoolId" xml) String.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("PoolId", String.to_query v.pool_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("PoolId", String.to_json v.pool_id)
         ])

  let of_json j =
    { pool_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PoolId"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DescribeAggregateIdFormatRequest = struct
  type t = { dry_run : Boolean.t option }

  let make ?dry_run () = { dry_run }

  let parse xml =
    Some { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f) ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json }
end

module DescribeVolumeStatusRequest = struct
  type t =
    { filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; volume_ids : VolumeIdStringList.t
    ; dry_run : Boolean.t option
    }

  let make ?(filters = []) ?max_results ?next_token ?(volume_ids = []) ?dry_run () =
    { filters; max_results; next_token; volume_ids; dry_run }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; volume_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "VolumeId" xml)
               VolumeIdStringList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("VolumeId", VolumeIdStringList.to_query v.volume_ids))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("VolumeId", VolumeIdStringList.to_json v.volume_ids)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; volume_ids =
        VolumeIdStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VolumeId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module GetCapacityReservationUsageRequest = struct
  type t =
    { capacity_reservation_id : String.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    ; dry_run : Boolean.t option
    }

  let make ~capacity_reservation_id ?next_token ?max_results ?dry_run () =
    { capacity_reservation_id; next_token; max_results; dry_run }

  let parse xml =
    Some
      { capacity_reservation_id =
          Aws.Xml.required
            "CapacityReservationId"
            (Aws.Util.option_bind
               (Aws.Xml.member "CapacityReservationId" xml)
               String.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("CapacityReservationId", String.to_query v.capacity_reservation_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("CapacityReservationId", String.to_json v.capacity_reservation_id)
         ])

  let of_json j =
    { capacity_reservation_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "CapacityReservationId"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module Ipv6PoolIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module ReplaceRouteTableAssociationResult = struct
  type t =
    { new_association_id : String.t option
    ; association_state : RouteTableAssociationState.t option
    }

  let make ?new_association_id ?association_state () =
    { new_association_id; association_state }

  let parse xml =
    Some
      { new_association_id =
          Aws.Util.option_bind (Aws.Xml.member "newAssociationId" xml) String.parse
      ; association_state =
          Aws.Util.option_bind
            (Aws.Xml.member "associationState" xml)
            RouteTableAssociationState.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_state (fun f ->
               Aws.Query.Pair ("AssociationState", RouteTableAssociationState.to_query f))
         ; Aws.Util.option_map v.new_association_id (fun f ->
               Aws.Query.Pair ("NewAssociationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_state (fun f ->
               "associationState", RouteTableAssociationState.to_json f)
         ; Aws.Util.option_map v.new_association_id (fun f ->
               "newAssociationId", String.to_json f)
         ])

  let of_json j =
    { new_association_id =
        Aws.Util.option_map (Aws.Json.lookup j "newAssociationId") String.of_json
    ; association_state =
        Aws.Util.option_map
          (Aws.Json.lookup j "associationState")
          RouteTableAssociationState.of_json
    }
end

module CreateTransitGatewayPeeringAttachmentResult = struct
  type t =
    { transit_gateway_peering_attachment : TransitGatewayPeeringAttachment.t option }

  let make ?transit_gateway_peering_attachment () = { transit_gateway_peering_attachment }

  let parse xml =
    Some
      { transit_gateway_peering_attachment =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayPeeringAttachment" xml)
            TransitGatewayPeeringAttachment.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_peering_attachment (fun f ->
               Aws.Query.Pair
                 ( "TransitGatewayPeeringAttachment"
                 , TransitGatewayPeeringAttachment.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_peering_attachment (fun f ->
               ( "transitGatewayPeeringAttachment"
               , TransitGatewayPeeringAttachment.to_json f ))
         ])

  let of_json j =
    { transit_gateway_peering_attachment =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayPeeringAttachment")
          TransitGatewayPeeringAttachment.of_json
    }
end

module AccountAttributeValue = struct
  type t = { attribute_value : String.t option }

  let make ?attribute_value () = { attribute_value }

  let parse xml =
    Some
      { attribute_value =
          Aws.Util.option_bind (Aws.Xml.member "attributeValue" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.attribute_value (fun f ->
               Aws.Query.Pair ("AttributeValue", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.attribute_value (fun f ->
               "attributeValue", String.to_json f)
         ])

  let of_json j =
    { attribute_value =
        Aws.Util.option_map (Aws.Json.lookup j "attributeValue") String.of_json
    }
end

module AccountAttributeValueList = struct
  type t = AccountAttributeValue.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map AccountAttributeValue.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list AccountAttributeValue.to_query v

  let to_json v = `List (List.map AccountAttributeValue.to_json v)

  let of_json j = Aws.Json.to_list AccountAttributeValue.of_json j
end

module AccountAttribute = struct
  type t =
    { attribute_name : String.t option
    ; attribute_values : AccountAttributeValueList.t
    }

  let make ?attribute_name ?(attribute_values = []) () =
    { attribute_name; attribute_values }

  let parse xml =
    Some
      { attribute_name =
          Aws.Util.option_bind (Aws.Xml.member "attributeName" xml) String.parse
      ; attribute_values =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "attributeValueSet" xml)
               AccountAttributeValueList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "AttributeValueSet"
                , AccountAttributeValueList.to_query v.attribute_values ))
         ; Aws.Util.option_map v.attribute_name (fun f ->
               Aws.Query.Pair ("AttributeName", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("attributeValueSet", AccountAttributeValueList.to_json v.attribute_values)
         ; Aws.Util.option_map v.attribute_name (fun f ->
               "attributeName", String.to_json f)
         ])

  let of_json j =
    { attribute_name =
        Aws.Util.option_map (Aws.Json.lookup j "attributeName") String.of_json
    ; attribute_values =
        AccountAttributeValueList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "attributeValueSet"))
    }
end

module AccountAttributeList = struct
  type t = AccountAttribute.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map AccountAttribute.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list AccountAttribute.to_query v

  let to_json v = `List (List.map AccountAttribute.to_json v)

  let of_json j = Aws.Json.to_list AccountAttribute.of_json j
end

module DescribeAccountAttributesResult = struct
  type t = { account_attributes : AccountAttributeList.t }

  let make ?(account_attributes = []) () = { account_attributes }

  let parse xml =
    Some
      { account_attributes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "accountAttributeSet" xml)
               AccountAttributeList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("AccountAttributeSet", AccountAttributeList.to_query v.account_attributes))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("accountAttributeSet", AccountAttributeList.to_json v.account_attributes)
         ])

  let of_json j =
    { account_attributes =
        AccountAttributeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "accountAttributeSet"))
    }
end

module CreateSnapshotRequest = struct
  type t =
    { description : String.t option
    ; volume_id : String.t
    ; tag_specifications : TagSpecificationList.t
    ; dry_run : Boolean.t option
    }

  let make ?description ~volume_id ?(tag_specifications = []) ?dry_run () =
    { description; volume_id; tag_specifications; dry_run }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; volume_id =
          Aws.Xml.required
            "VolumeId"
            (Aws.Util.option_bind (Aws.Xml.member "VolumeId" xml) String.parse)
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Some (Aws.Query.Pair ("VolumeId", String.to_query v.volume_id))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Some ("VolumeId", String.to_json v.volume_id)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; volume_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VolumeId"))
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module CancelSpotFleetRequestsErrorItem = struct
  type t =
    { error : CancelSpotFleetRequestsError.t option
    ; spot_fleet_request_id : String.t option
    }

  let make ?error ?spot_fleet_request_id () = { error; spot_fleet_request_id }

  let parse xml =
    Some
      { error =
          Aws.Util.option_bind
            (Aws.Xml.member "error" xml)
            CancelSpotFleetRequestsError.parse
      ; spot_fleet_request_id =
          Aws.Util.option_bind (Aws.Xml.member "spotFleetRequestId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.spot_fleet_request_id (fun f ->
               Aws.Query.Pair ("SpotFleetRequestId", String.to_query f))
         ; Aws.Util.option_map v.error (fun f ->
               Aws.Query.Pair ("Error", CancelSpotFleetRequestsError.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.spot_fleet_request_id (fun f ->
               "spotFleetRequestId", String.to_json f)
         ; Aws.Util.option_map v.error (fun f ->
               "error", CancelSpotFleetRequestsError.to_json f)
         ])

  let of_json j =
    { error =
        Aws.Util.option_map
          (Aws.Json.lookup j "error")
          CancelSpotFleetRequestsError.of_json
    ; spot_fleet_request_id =
        Aws.Util.option_map (Aws.Json.lookup j "spotFleetRequestId") String.of_json
    }
end

module CancelSpotFleetRequestsErrorSet = struct
  type t = CancelSpotFleetRequestsErrorItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map CancelSpotFleetRequestsErrorItem.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list CancelSpotFleetRequestsErrorItem.to_query v

  let to_json v = `List (List.map CancelSpotFleetRequestsErrorItem.to_json v)

  let of_json j = Aws.Json.to_list CancelSpotFleetRequestsErrorItem.of_json j
end

module CancelSpotFleetRequestsResponse = struct
  type t =
    { successful_fleet_requests : CancelSpotFleetRequestsSuccessSet.t
    ; unsuccessful_fleet_requests : CancelSpotFleetRequestsErrorSet.t
    }

  let make ?(successful_fleet_requests = []) ?(unsuccessful_fleet_requests = []) () =
    { successful_fleet_requests; unsuccessful_fleet_requests }

  let parse xml =
    Some
      { successful_fleet_requests =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "successfulFleetRequestSet" xml)
               CancelSpotFleetRequestsSuccessSet.parse)
      ; unsuccessful_fleet_requests =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "unsuccessfulFleetRequestSet" xml)
               CancelSpotFleetRequestsErrorSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "UnsuccessfulFleetRequestSet"
                , CancelSpotFleetRequestsErrorSet.to_query v.unsuccessful_fleet_requests
                ))
         ; Some
             (Aws.Query.Pair
                ( "SuccessfulFleetRequestSet"
                , CancelSpotFleetRequestsSuccessSet.to_query v.successful_fleet_requests
                ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "unsuccessfulFleetRequestSet"
             , CancelSpotFleetRequestsErrorSet.to_json v.unsuccessful_fleet_requests )
         ; Some
             ( "successfulFleetRequestSet"
             , CancelSpotFleetRequestsSuccessSet.to_json v.successful_fleet_requests )
         ])

  let of_json j =
    { successful_fleet_requests =
        CancelSpotFleetRequestsSuccessSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "successfulFleetRequestSet"))
    ; unsuccessful_fleet_requests =
        CancelSpotFleetRequestsErrorSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "unsuccessfulFleetRequestSet"))
    }
end

module DescribeLaunchTemplatesRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; launch_template_ids : LaunchTemplateIdStringList.t
    ; launch_template_names : LaunchTemplateNameStringList.t
    ; filters : FilterList.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    }

  let make
      ?dry_run
      ?(launch_template_ids = [])
      ?(launch_template_names = [])
      ?(filters = [])
      ?next_token
      ?max_results
      () =
    { dry_run
    ; launch_template_ids
    ; launch_template_names
    ; filters
    ; next_token
    ; max_results
    }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; launch_template_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "LaunchTemplateId" xml)
               LaunchTemplateIdStringList.parse)
      ; launch_template_names =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "LaunchTemplateName" xml)
               LaunchTemplateNameStringList.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ( "LaunchTemplateName"
                , LaunchTemplateNameStringList.to_query v.launch_template_names ))
         ; Some
             (Aws.Query.Pair
                ( "LaunchTemplateId"
                , LaunchTemplateIdStringList.to_query v.launch_template_ids ))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some
             ( "LaunchTemplateName"
             , LaunchTemplateNameStringList.to_json v.launch_template_names )
         ; Some
             ("LaunchTemplateId", LaunchTemplateIdStringList.to_json v.launch_template_ids)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; launch_template_ids =
        LaunchTemplateIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "LaunchTemplateId"))
    ; launch_template_names =
        LaunchTemplateNameStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "LaunchTemplateName"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module DescribeFleetsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; fleet_ids : FleetIdSet.t
    ; filters : FilterList.t
    }

  let make ?dry_run ?max_results ?next_token ?(fleet_ids = []) ?(filters = []) () =
    { dry_run; max_results; next_token; fleet_ids; filters }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; fleet_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "FleetId" xml) FleetIdSet.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some (Aws.Query.Pair ("FleetId", FleetIdSet.to_query v.fleet_ids))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Filter", FilterList.to_json v.filters)
         ; Some ("FleetId", FleetIdSet.to_json v.fleet_ids)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; fleet_ids =
        FleetIdSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "FleetId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    }
end

module DescribeFleetHistoryRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; event_type : FleetEventType.t option
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; fleet_id : String.t
    ; start_time : DateTime.t
    }

  let make ?dry_run ?event_type ?max_results ?next_token ~fleet_id ~start_time () =
    { dry_run; event_type; max_results; next_token; fleet_id; start_time }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; event_type =
          Aws.Util.option_bind (Aws.Xml.member "EventType" xml) FleetEventType.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; fleet_id =
          Aws.Xml.required
            "FleetId"
            (Aws.Util.option_bind (Aws.Xml.member "FleetId" xml) String.parse)
      ; start_time =
          Aws.Xml.required
            "StartTime"
            (Aws.Util.option_bind (Aws.Xml.member "StartTime" xml) DateTime.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("StartTime", DateTime.to_query v.start_time))
         ; Some (Aws.Query.Pair ("FleetId", String.to_query v.fleet_id))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.event_type (fun f ->
               Aws.Query.Pair ("EventType", FleetEventType.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("StartTime", DateTime.to_json v.start_time)
         ; Some ("FleetId", String.to_json v.fleet_id)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.event_type (fun f ->
               "EventType", FleetEventType.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; event_type =
        Aws.Util.option_map (Aws.Json.lookup j "EventType") FleetEventType.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; fleet_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "FleetId"))
    ; start_time =
        DateTime.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "StartTime"))
    }
end

module HostInstanceList = struct
  type t = HostInstance.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map HostInstance.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list HostInstance.to_query v

  let to_json v = `List (List.map HostInstance.to_json v)

  let of_json j = Aws.Json.to_list HostInstance.of_json j
end

module AvailableCapacity = struct
  type t =
    { available_instance_capacity : AvailableInstanceCapacityList.t
    ; available_v_cpus : Integer.t option
    }

  let make ?(available_instance_capacity = []) ?available_v_cpus () =
    { available_instance_capacity; available_v_cpus }

  let parse xml =
    Some
      { available_instance_capacity =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "availableInstanceCapacity" xml)
               AvailableInstanceCapacityList.parse)
      ; available_v_cpus =
          Aws.Util.option_bind (Aws.Xml.member "availableVCpus" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.available_v_cpus (fun f ->
               Aws.Query.Pair ("AvailableVCpus", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "AvailableInstanceCapacity"
                , AvailableInstanceCapacityList.to_query v.available_instance_capacity ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.available_v_cpus (fun f ->
               "availableVCpus", Integer.to_json f)
         ; Some
             ( "availableInstanceCapacity"
             , AvailableInstanceCapacityList.to_json v.available_instance_capacity )
         ])

  let of_json j =
    { available_instance_capacity =
        AvailableInstanceCapacityList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "availableInstanceCapacity"))
    ; available_v_cpus =
        Aws.Util.option_map (Aws.Json.lookup j "availableVCpus") Integer.of_json
    }
end

module Host = struct
  type t =
    { auto_placement : AutoPlacement.t option
    ; availability_zone : String.t option
    ; available_capacity : AvailableCapacity.t option
    ; client_token : String.t option
    ; host_id : String.t option
    ; host_properties : HostProperties.t option
    ; host_reservation_id : String.t option
    ; instances : HostInstanceList.t
    ; state : AllocationState.t option
    ; allocation_time : DateTime.t option
    ; release_time : DateTime.t option
    ; tags : TagList.t
    ; host_recovery : HostRecovery.t option
    ; allows_multiple_instance_types : AllowsMultipleInstanceTypes.t option
    ; owner_id : String.t option
    ; availability_zone_id : String.t option
    ; member_of_service_linked_resource_group : Boolean.t option
    }

  let make
      ?auto_placement
      ?availability_zone
      ?available_capacity
      ?client_token
      ?host_id
      ?host_properties
      ?host_reservation_id
      ?(instances = [])
      ?state
      ?allocation_time
      ?release_time
      ?(tags = [])
      ?host_recovery
      ?allows_multiple_instance_types
      ?owner_id
      ?availability_zone_id
      ?member_of_service_linked_resource_group
      () =
    { auto_placement
    ; availability_zone
    ; available_capacity
    ; client_token
    ; host_id
    ; host_properties
    ; host_reservation_id
    ; instances
    ; state
    ; allocation_time
    ; release_time
    ; tags
    ; host_recovery
    ; allows_multiple_instance_types
    ; owner_id
    ; availability_zone_id
    ; member_of_service_linked_resource_group
    }

  let parse xml =
    Some
      { auto_placement =
          Aws.Util.option_bind (Aws.Xml.member "autoPlacement" xml) AutoPlacement.parse
      ; availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; available_capacity =
          Aws.Util.option_bind
            (Aws.Xml.member "availableCapacity" xml)
            AvailableCapacity.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "clientToken" xml) String.parse
      ; host_id = Aws.Util.option_bind (Aws.Xml.member "hostId" xml) String.parse
      ; host_properties =
          Aws.Util.option_bind (Aws.Xml.member "hostProperties" xml) HostProperties.parse
      ; host_reservation_id =
          Aws.Util.option_bind (Aws.Xml.member "hostReservationId" xml) String.parse
      ; instances =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "instances" xml) HostInstanceList.parse)
      ; state = Aws.Util.option_bind (Aws.Xml.member "state" xml) AllocationState.parse
      ; allocation_time =
          Aws.Util.option_bind (Aws.Xml.member "allocationTime" xml) DateTime.parse
      ; release_time =
          Aws.Util.option_bind (Aws.Xml.member "releaseTime" xml) DateTime.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      ; host_recovery =
          Aws.Util.option_bind (Aws.Xml.member "hostRecovery" xml) HostRecovery.parse
      ; allows_multiple_instance_types =
          Aws.Util.option_bind
            (Aws.Xml.member "allowsMultipleInstanceTypes" xml)
            AllowsMultipleInstanceTypes.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; availability_zone_id =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZoneId" xml) String.parse
      ; member_of_service_linked_resource_group =
          Aws.Util.option_bind
            (Aws.Xml.member "memberOfServiceLinkedResourceGroup" xml)
            Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.member_of_service_linked_resource_group (fun f ->
               Aws.Query.Pair ("MemberOfServiceLinkedResourceGroup", Boolean.to_query f))
         ; Aws.Util.option_map v.availability_zone_id (fun f ->
               Aws.Query.Pair ("AvailabilityZoneId", String.to_query f))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.allows_multiple_instance_types (fun f ->
               Aws.Query.Pair
                 ("AllowsMultipleInstanceTypes", AllowsMultipleInstanceTypes.to_query f))
         ; Aws.Util.option_map v.host_recovery (fun f ->
               Aws.Query.Pair ("HostRecovery", HostRecovery.to_query f))
         ; Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.release_time (fun f ->
               Aws.Query.Pair ("ReleaseTime", DateTime.to_query f))
         ; Aws.Util.option_map v.allocation_time (fun f ->
               Aws.Query.Pair ("AllocationTime", DateTime.to_query f))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", AllocationState.to_query f))
         ; Some (Aws.Query.Pair ("Instances", HostInstanceList.to_query v.instances))
         ; Aws.Util.option_map v.host_reservation_id (fun f ->
               Aws.Query.Pair ("HostReservationId", String.to_query f))
         ; Aws.Util.option_map v.host_properties (fun f ->
               Aws.Query.Pair ("HostProperties", HostProperties.to_query f))
         ; Aws.Util.option_map v.host_id (fun f ->
               Aws.Query.Pair ("HostId", String.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.available_capacity (fun f ->
               Aws.Query.Pair ("AvailableCapacity", AvailableCapacity.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ; Aws.Util.option_map v.auto_placement (fun f ->
               Aws.Query.Pair ("AutoPlacement", AutoPlacement.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.member_of_service_linked_resource_group (fun f ->
               "memberOfServiceLinkedResourceGroup", Boolean.to_json f)
         ; Aws.Util.option_map v.availability_zone_id (fun f ->
               "availabilityZoneId", String.to_json f)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.allows_multiple_instance_types (fun f ->
               "allowsMultipleInstanceTypes", AllowsMultipleInstanceTypes.to_json f)
         ; Aws.Util.option_map v.host_recovery (fun f ->
               "hostRecovery", HostRecovery.to_json f)
         ; Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.release_time (fun f -> "releaseTime", DateTime.to_json f)
         ; Aws.Util.option_map v.allocation_time (fun f ->
               "allocationTime", DateTime.to_json f)
         ; Aws.Util.option_map v.state (fun f -> "state", AllocationState.to_json f)
         ; Some ("instances", HostInstanceList.to_json v.instances)
         ; Aws.Util.option_map v.host_reservation_id (fun f ->
               "hostReservationId", String.to_json f)
         ; Aws.Util.option_map v.host_properties (fun f ->
               "hostProperties", HostProperties.to_json f)
         ; Aws.Util.option_map v.host_id (fun f -> "hostId", String.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "clientToken", String.to_json f)
         ; Aws.Util.option_map v.available_capacity (fun f ->
               "availableCapacity", AvailableCapacity.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ; Aws.Util.option_map v.auto_placement (fun f ->
               "autoPlacement", AutoPlacement.to_json f)
         ])

  let of_json j =
    { auto_placement =
        Aws.Util.option_map (Aws.Json.lookup j "autoPlacement") AutoPlacement.of_json
    ; availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; available_capacity =
        Aws.Util.option_map
          (Aws.Json.lookup j "availableCapacity")
          AvailableCapacity.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "clientToken") String.of_json
    ; host_id = Aws.Util.option_map (Aws.Json.lookup j "hostId") String.of_json
    ; host_properties =
        Aws.Util.option_map (Aws.Json.lookup j "hostProperties") HostProperties.of_json
    ; host_reservation_id =
        Aws.Util.option_map (Aws.Json.lookup j "hostReservationId") String.of_json
    ; instances =
        HostInstanceList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "instances"))
    ; state = Aws.Util.option_map (Aws.Json.lookup j "state") AllocationState.of_json
    ; allocation_time =
        Aws.Util.option_map (Aws.Json.lookup j "allocationTime") DateTime.of_json
    ; release_time =
        Aws.Util.option_map (Aws.Json.lookup j "releaseTime") DateTime.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    ; host_recovery =
        Aws.Util.option_map (Aws.Json.lookup j "hostRecovery") HostRecovery.of_json
    ; allows_multiple_instance_types =
        Aws.Util.option_map
          (Aws.Json.lookup j "allowsMultipleInstanceTypes")
          AllowsMultipleInstanceTypes.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; availability_zone_id =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZoneId") String.of_json
    ; member_of_service_linked_resource_group =
        Aws.Util.option_map
          (Aws.Json.lookup j "memberOfServiceLinkedResourceGroup")
          Boolean.of_json
    }
end

module HostList = struct
  type t = Host.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map Host.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Host.to_query v

  let to_json v = `List (List.map Host.to_json v)

  let of_json j = Aws.Json.to_list Host.of_json j
end

module BillingProductList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module AttachInternetGatewayRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; internet_gateway_id : String.t
    ; vpc_id : String.t
    }

  let make ?dry_run ~internet_gateway_id ~vpc_id () =
    { dry_run; internet_gateway_id; vpc_id }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; internet_gateway_id =
          Aws.Xml.required
            "internetGatewayId"
            (Aws.Util.option_bind (Aws.Xml.member "internetGatewayId" xml) String.parse)
      ; vpc_id =
          Aws.Xml.required
            "vpcId"
            (Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ; Some
             (Aws.Query.Pair ("InternetGatewayId", String.to_query v.internet_gateway_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("vpcId", String.to_json v.vpc_id)
         ; Some ("internetGatewayId", String.to_json v.internet_gateway_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; internet_gateway_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "internetGatewayId"))
    ; vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "vpcId"))
    }
end

module AssociateClientVpnTargetNetworkRequest = struct
  type t =
    { client_vpn_endpoint_id : String.t
    ; subnet_id : String.t
    ; client_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make ~client_vpn_endpoint_id ~subnet_id ?client_token ?dry_run () =
    { client_vpn_endpoint_id; subnet_id; client_token; dry_run }

  let parse xml =
    Some
      { client_vpn_endpoint_id =
          Aws.Xml.required
            "ClientVpnEndpointId"
            (Aws.Util.option_bind (Aws.Xml.member "ClientVpnEndpointId" xml) String.parse)
      ; subnet_id =
          Aws.Xml.required
            "SubnetId"
            (Aws.Util.option_bind (Aws.Xml.member "SubnetId" xml) String.parse)
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Some (Aws.Query.Pair ("SubnetId", String.to_query v.subnet_id))
         ; Some
             (Aws.Query.Pair
                ("ClientVpnEndpointId", String.to_query v.client_vpn_endpoint_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Some ("SubnetId", String.to_json v.subnet_id)
         ; Some ("ClientVpnEndpointId", String.to_json v.client_vpn_endpoint_id)
         ])

  let of_json j =
    { client_vpn_endpoint_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ClientVpnEndpointId"))
    ; subnet_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SubnetId"))
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module CancelConversionRequest = struct
  type t =
    { conversion_task_id : String.t
    ; dry_run : Boolean.t option
    ; reason_message : String.t option
    }

  let make ~conversion_task_id ?dry_run ?reason_message () =
    { conversion_task_id; dry_run; reason_message }

  let parse xml =
    Some
      { conversion_task_id =
          Aws.Xml.required
            "conversionTaskId"
            (Aws.Util.option_bind (Aws.Xml.member "conversionTaskId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; reason_message =
          Aws.Util.option_bind (Aws.Xml.member "reasonMessage" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.reason_message (fun f ->
               Aws.Query.Pair ("ReasonMessage", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair ("ConversionTaskId", String.to_query v.conversion_task_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.reason_message (fun f ->
               "reasonMessage", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("conversionTaskId", String.to_json v.conversion_task_id)
         ])

  let of_json j =
    { conversion_task_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "conversionTaskId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; reason_message =
        Aws.Util.option_map (Aws.Json.lookup j "reasonMessage") String.of_json
    }
end

module LocalGatewayRouteTableVirtualInterfaceGroupAssociation = struct
  type t =
    { local_gateway_route_table_virtual_interface_group_association_id : String.t option
    ; local_gateway_virtual_interface_group_id : String.t option
    ; local_gateway_id : String.t option
    ; local_gateway_route_table_id : String.t option
    ; local_gateway_route_table_arn : String.t option
    ; owner_id : String.t option
    ; state : String.t option
    ; tags : TagList.t
    }

  let make
      ?local_gateway_route_table_virtual_interface_group_association_id
      ?local_gateway_virtual_interface_group_id
      ?local_gateway_id
      ?local_gateway_route_table_id
      ?local_gateway_route_table_arn
      ?owner_id
      ?state
      ?(tags = [])
      () =
    { local_gateway_route_table_virtual_interface_group_association_id
    ; local_gateway_virtual_interface_group_id
    ; local_gateway_id
    ; local_gateway_route_table_id
    ; local_gateway_route_table_arn
    ; owner_id
    ; state
    ; tags
    }

  let parse xml =
    Some
      { local_gateway_route_table_virtual_interface_group_association_id =
          Aws.Util.option_bind
            (Aws.Xml.member
               "localGatewayRouteTableVirtualInterfaceGroupAssociationId"
               xml)
            String.parse
      ; local_gateway_virtual_interface_group_id =
          Aws.Util.option_bind
            (Aws.Xml.member "localGatewayVirtualInterfaceGroupId" xml)
            String.parse
      ; local_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "localGatewayId" xml) String.parse
      ; local_gateway_route_table_id =
          Aws.Util.option_bind
            (Aws.Xml.member "localGatewayRouteTableId" xml)
            String.parse
      ; local_gateway_route_table_arn =
          Aws.Util.option_bind
            (Aws.Xml.member "localGatewayRouteTableArn" xml)
            String.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; state = Aws.Util.option_bind (Aws.Xml.member "state" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", String.to_query f))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.local_gateway_route_table_arn (fun f ->
               Aws.Query.Pair ("LocalGatewayRouteTableArn", String.to_query f))
         ; Aws.Util.option_map v.local_gateway_route_table_id (fun f ->
               Aws.Query.Pair ("LocalGatewayRouteTableId", String.to_query f))
         ; Aws.Util.option_map v.local_gateway_id (fun f ->
               Aws.Query.Pair ("LocalGatewayId", String.to_query f))
         ; Aws.Util.option_map v.local_gateway_virtual_interface_group_id (fun f ->
               Aws.Query.Pair ("LocalGatewayVirtualInterfaceGroupId", String.to_query f))
         ; Aws.Util.option_map
             v.local_gateway_route_table_virtual_interface_group_association_id
             (fun f ->
               Aws.Query.Pair
                 ( "LocalGatewayRouteTableVirtualInterfaceGroupAssociationId"
                 , String.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.state (fun f -> "state", String.to_json f)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.local_gateway_route_table_arn (fun f ->
               "localGatewayRouteTableArn", String.to_json f)
         ; Aws.Util.option_map v.local_gateway_route_table_id (fun f ->
               "localGatewayRouteTableId", String.to_json f)
         ; Aws.Util.option_map v.local_gateway_id (fun f ->
               "localGatewayId", String.to_json f)
         ; Aws.Util.option_map v.local_gateway_virtual_interface_group_id (fun f ->
               "localGatewayVirtualInterfaceGroupId", String.to_json f)
         ; Aws.Util.option_map
             v.local_gateway_route_table_virtual_interface_group_association_id
             (fun f ->
               ( "localGatewayRouteTableVirtualInterfaceGroupAssociationId"
               , String.to_json f ))
         ])

  let of_json j =
    { local_gateway_route_table_virtual_interface_group_association_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "localGatewayRouteTableVirtualInterfaceGroupAssociationId")
          String.of_json
    ; local_gateway_virtual_interface_group_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "localGatewayVirtualInterfaceGroupId")
          String.of_json
    ; local_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "localGatewayId") String.of_json
    ; local_gateway_route_table_id =
        Aws.Util.option_map (Aws.Json.lookup j "localGatewayRouteTableId") String.of_json
    ; local_gateway_route_table_arn =
        Aws.Util.option_map (Aws.Json.lookup j "localGatewayRouteTableArn") String.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; state = Aws.Util.option_map (Aws.Json.lookup j "state") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet = struct
  type t = LocalGatewayRouteTableVirtualInterfaceGroupAssociation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         LocalGatewayRouteTableVirtualInterfaceGroupAssociation.parse
         (Aws.Xml.members "item" xml))

  let to_query v =
    Aws.Query.to_query_list
      LocalGatewayRouteTableVirtualInterfaceGroupAssociation.to_query
      v

  let to_json v =
    `List (List.map LocalGatewayRouteTableVirtualInterfaceGroupAssociation.to_json v)

  let of_json j =
    Aws.Json.to_list LocalGatewayRouteTableVirtualInterfaceGroupAssociation.of_json j
end

module PurchaseHostReservationRequest = struct
  type t =
    { client_token : String.t option
    ; currency_code : CurrencyCodeValues.t option
    ; host_id_set : RequestHostIdSet.t
    ; limit_price : String.t option
    ; offering_id : String.t
    ; tag_specifications : TagSpecificationList.t
    }

  let make
      ?client_token
      ?currency_code
      ~host_id_set
      ?limit_price
      ~offering_id
      ?(tag_specifications = [])
      () =
    { client_token
    ; currency_code
    ; host_id_set
    ; limit_price
    ; offering_id
    ; tag_specifications
    }

  let parse xml =
    Some
      { client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; currency_code =
          Aws.Util.option_bind
            (Aws.Xml.member "CurrencyCode" xml)
            CurrencyCodeValues.parse
      ; host_id_set =
          Aws.Xml.required
            "HostIdSet"
            (Aws.Util.option_bind (Aws.Xml.member "HostIdSet" xml) RequestHostIdSet.parse)
      ; limit_price = Aws.Util.option_bind (Aws.Xml.member "LimitPrice" xml) String.parse
      ; offering_id =
          Aws.Xml.required
            "OfferingId"
            (Aws.Util.option_bind (Aws.Xml.member "OfferingId" xml) String.parse)
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Some (Aws.Query.Pair ("OfferingId", String.to_query v.offering_id))
         ; Aws.Util.option_map v.limit_price (fun f ->
               Aws.Query.Pair ("LimitPrice", String.to_query f))
         ; Some (Aws.Query.Pair ("HostIdSet", RequestHostIdSet.to_query v.host_id_set))
         ; Aws.Util.option_map v.currency_code (fun f ->
               Aws.Query.Pair ("CurrencyCode", CurrencyCodeValues.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Some ("OfferingId", String.to_json v.offering_id)
         ; Aws.Util.option_map v.limit_price (fun f -> "LimitPrice", String.to_json f)
         ; Some ("HostIdSet", RequestHostIdSet.to_json v.host_id_set)
         ; Aws.Util.option_map v.currency_code (fun f ->
               "CurrencyCode", CurrencyCodeValues.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ])

  let of_json j =
    { client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; currency_code =
        Aws.Util.option_map (Aws.Json.lookup j "CurrencyCode") CurrencyCodeValues.of_json
    ; host_id_set =
        RequestHostIdSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "HostIdSet"))
    ; limit_price = Aws.Util.option_map (Aws.Json.lookup j "LimitPrice") String.of_json
    ; offering_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "OfferingId"))
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    }
end

module EnableEbsEncryptionByDefaultResult = struct
  type t = { ebs_encryption_by_default : Boolean.t option }

  let make ?ebs_encryption_by_default () = { ebs_encryption_by_default }

  let parse xml =
    Some
      { ebs_encryption_by_default =
          Aws.Util.option_bind (Aws.Xml.member "ebsEncryptionByDefault" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ebs_encryption_by_default (fun f ->
               Aws.Query.Pair ("EbsEncryptionByDefault", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.ebs_encryption_by_default (fun f ->
               "ebsEncryptionByDefault", Boolean.to_json f)
         ])

  let of_json j =
    { ebs_encryption_by_default =
        Aws.Util.option_map (Aws.Json.lookup j "ebsEncryptionByDefault") Boolean.of_json
    }
end

module DescribeManagedPrefixListsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; prefix_list_ids : ValueStringList.t
    }

  let make ?dry_run ?(filters = []) ?max_results ?next_token ?(prefix_list_ids = []) () =
    { dry_run; filters; max_results; next_token; prefix_list_ids }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; prefix_list_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "PrefixListId" xml)
               ValueStringList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("PrefixListId", ValueStringList.to_query v.prefix_list_ids))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("PrefixListId", ValueStringList.to_json v.prefix_list_ids)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; prefix_list_ids =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "PrefixListId"))
    }
end

module AssociateEnclaveCertificateIamRoleRequest = struct
  type t =
    { certificate_arn : String.t option
    ; role_arn : String.t option
    ; dry_run : Boolean.t option
    }

  let make ?certificate_arn ?role_arn ?dry_run () = { certificate_arn; role_arn; dry_run }

  let parse xml =
    Some
      { certificate_arn =
          Aws.Util.option_bind (Aws.Xml.member "CertificateArn" xml) String.parse
      ; role_arn = Aws.Util.option_bind (Aws.Xml.member "RoleArn" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.role_arn (fun f ->
               Aws.Query.Pair ("RoleArn", String.to_query f))
         ; Aws.Util.option_map v.certificate_arn (fun f ->
               Aws.Query.Pair ("CertificateArn", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.role_arn (fun f -> "RoleArn", String.to_json f)
         ; Aws.Util.option_map v.certificate_arn (fun f ->
               "CertificateArn", String.to_json f)
         ])

  let of_json j =
    { certificate_arn =
        Aws.Util.option_map (Aws.Json.lookup j "CertificateArn") String.of_json
    ; role_arn = Aws.Util.option_map (Aws.Json.lookup j "RoleArn") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module PrefixListAssociation = struct
  type t =
    { resource_id : String.t option
    ; resource_owner : String.t option
    }

  let make ?resource_id ?resource_owner () = { resource_id; resource_owner }

  let parse xml =
    Some
      { resource_id = Aws.Util.option_bind (Aws.Xml.member "resourceId" xml) String.parse
      ; resource_owner =
          Aws.Util.option_bind (Aws.Xml.member "resourceOwner" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.resource_owner (fun f ->
               Aws.Query.Pair ("ResourceOwner", String.to_query f))
         ; Aws.Util.option_map v.resource_id (fun f ->
               Aws.Query.Pair ("ResourceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.resource_owner (fun f ->
               "resourceOwner", String.to_json f)
         ; Aws.Util.option_map v.resource_id (fun f -> "resourceId", String.to_json f)
         ])

  let of_json j =
    { resource_id = Aws.Util.option_map (Aws.Json.lookup j "resourceId") String.of_json
    ; resource_owner =
        Aws.Util.option_map (Aws.Json.lookup j "resourceOwner") String.of_json
    }
end

module PrefixListAssociationSet = struct
  type t = PrefixListAssociation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map PrefixListAssociation.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list PrefixListAssociation.to_query v

  let to_json v = `List (List.map PrefixListAssociation.to_json v)

  let of_json j = Aws.Json.to_list PrefixListAssociation.of_json j
end

module DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult = struct
  type t =
    { local_gateway_route_table_virtual_interface_group_associations :
        LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet.t
    ; next_token : String.t option
    }

  let make
      ?(local_gateway_route_table_virtual_interface_group_associations = [])
      ?next_token
      () =
    { local_gateway_route_table_virtual_interface_group_associations; next_token }

  let parse xml =
    Some
      { local_gateway_route_table_virtual_interface_group_associations =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member
                  "localGatewayRouteTableVirtualInterfaceGroupAssociationSet"
                  xml)
               LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet"
                , LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet.to_query
                    v.local_gateway_route_table_virtual_interface_group_associations ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "localGatewayRouteTableVirtualInterfaceGroupAssociationSet"
             , LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet.to_json
                 v.local_gateway_route_table_virtual_interface_group_associations )
         ])

  let of_json j =
    { local_gateway_route_table_virtual_interface_group_associations =
        LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet.of_json
          (Aws.Util.of_option_exn
             (Aws.Json.lookup
                j
                "localGatewayRouteTableVirtualInterfaceGroupAssociationSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DeleteTrafficMirrorFilterRequest = struct
  type t =
    { traffic_mirror_filter_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~traffic_mirror_filter_id ?dry_run () = { traffic_mirror_filter_id; dry_run }

  let parse xml =
    Some
      { traffic_mirror_filter_id =
          Aws.Xml.required
            "TrafficMirrorFilterId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TrafficMirrorFilterId" xml)
               String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TrafficMirrorFilterId", String.to_query v.traffic_mirror_filter_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("TrafficMirrorFilterId", String.to_json v.traffic_mirror_filter_id)
         ])

  let of_json j =
    { traffic_mirror_filter_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TrafficMirrorFilterId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DhcpOptions = struct
  type t =
    { dhcp_configurations : DhcpConfigurationList.t
    ; dhcp_options_id : String.t option
    ; owner_id : String.t option
    ; tags : TagList.t
    }

  let make ?(dhcp_configurations = []) ?dhcp_options_id ?owner_id ?(tags = []) () =
    { dhcp_configurations; dhcp_options_id; owner_id; tags }

  let parse xml =
    Some
      { dhcp_configurations =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "dhcpConfigurationSet" xml)
               DhcpConfigurationList.parse)
      ; dhcp_options_id =
          Aws.Util.option_bind (Aws.Xml.member "dhcpOptionsId" xml) String.parse
      ; owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ; Aws.Util.option_map v.dhcp_options_id (fun f ->
               Aws.Query.Pair ("DhcpOptionsId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "DhcpConfigurationSet"
                , DhcpConfigurationList.to_query v.dhcp_configurations ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ; Aws.Util.option_map v.dhcp_options_id (fun f ->
               "dhcpOptionsId", String.to_json f)
         ; Some
             ("dhcpConfigurationSet", DhcpConfigurationList.to_json v.dhcp_configurations)
         ])

  let of_json j =
    { dhcp_configurations =
        DhcpConfigurationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "dhcpConfigurationSet"))
    ; dhcp_options_id =
        Aws.Util.option_map (Aws.Json.lookup j "dhcpOptionsId") String.of_json
    ; owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module DeleteTrafficMirrorTargetResult = struct
  type t = { traffic_mirror_target_id : String.t option }

  let make ?traffic_mirror_target_id () = { traffic_mirror_target_id }

  let parse xml =
    Some
      { traffic_mirror_target_id =
          Aws.Util.option_bind (Aws.Xml.member "trafficMirrorTargetId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.traffic_mirror_target_id (fun f ->
               Aws.Query.Pair ("TrafficMirrorTargetId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.traffic_mirror_target_id (fun f ->
               "trafficMirrorTargetId", String.to_json f)
         ])

  let of_json j =
    { traffic_mirror_target_id =
        Aws.Util.option_map (Aws.Json.lookup j "trafficMirrorTargetId") String.of_json
    }
end

module DescribeNetworkAclsResult = struct
  type t =
    { network_acls : NetworkAclList.t
    ; next_token : String.t option
    }

  let make ?(network_acls = []) ?next_token () = { network_acls; next_token }

  let parse xml =
    Some
      { network_acls =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "networkAclSet" xml)
               NetworkAclList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("NetworkAclSet", NetworkAclList.to_query v.network_acls))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("networkAclSet", NetworkAclList.to_json v.network_acls)
         ])

  let of_json j =
    { network_acls =
        NetworkAclList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "networkAclSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module SpotFleetRequestIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeVpcPeeringConnectionsResult = struct
  type t =
    { vpc_peering_connections : VpcPeeringConnectionList.t
    ; next_token : String.t option
    }

  let make ?(vpc_peering_connections = []) ?next_token () =
    { vpc_peering_connections; next_token }

  let parse xml =
    Some
      { vpc_peering_connections =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "vpcPeeringConnectionSet" xml)
               VpcPeeringConnectionList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "VpcPeeringConnectionSet"
                , VpcPeeringConnectionList.to_query v.vpc_peering_connections ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "vpcPeeringConnectionSet"
             , VpcPeeringConnectionList.to_json v.vpc_peering_connections )
         ])

  let of_json j =
    { vpc_peering_connections =
        VpcPeeringConnectionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "vpcPeeringConnectionSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DisableVpcClassicLinkDnsSupportRequest = struct
  type t = { vpc_id : String.t option }

  let make ?vpc_id () = { vpc_id }

  let parse xml =
    Some { vpc_id = Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_id (fun f -> "VpcId", String.to_json f) ])

  let of_json j =
    { vpc_id = Aws.Util.option_map (Aws.Json.lookup j "VpcId") String.of_json }
end

module DescribeInstanceEventNotificationAttributesRequest = struct
  type t = { dry_run : Boolean.t option }

  let make ?dry_run () = { dry_run }

  let parse xml =
    Some { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f) ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json }
end

module ZoneIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "ZoneId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module CreateSecurityGroupRequest = struct
  type t =
    { description : String.t
    ; group_name : String.t
    ; vpc_id : String.t option
    ; tag_specifications : TagSpecificationList.t
    ; dry_run : Boolean.t option
    }

  let make ~description ~group_name ?vpc_id ?(tag_specifications = []) ?dry_run () =
    { description; group_name; vpc_id; tag_specifications; dry_run }

  let parse xml =
    Some
      { description =
          Aws.Xml.required
            "GroupDescription"
            (Aws.Util.option_bind (Aws.Xml.member "GroupDescription" xml) String.parse)
      ; group_name =
          Aws.Xml.required
            "GroupName"
            (Aws.Util.option_bind (Aws.Xml.member "GroupName" xml) String.parse)
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) String.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Some (Aws.Query.Pair ("GroupName", String.to_query v.group_name))
         ; Some (Aws.Query.Pair ("GroupDescription", String.to_query v.description))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Aws.Util.option_map v.vpc_id (fun f -> "VpcId", String.to_json f)
         ; Some ("GroupName", String.to_json v.group_name)
         ; Some ("GroupDescription", String.to_json v.description)
         ])

  let of_json j =
    { description =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "GroupDescription"))
    ; group_name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "GroupName"))
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "VpcId") String.of_json
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module TransitGatewayList = struct
  type t = TransitGateway.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map TransitGateway.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list TransitGateway.to_query v

  let to_json v = `List (List.map TransitGateway.to_json v)

  let of_json j = Aws.Json.to_list TransitGateway.of_json j
end

module RegisterImageRequest = struct
  type t =
    { image_location : String.t option
    ; architecture : ArchitectureValues.t option
    ; block_device_mappings : BlockDeviceMappingRequestList.t
    ; description : String.t option
    ; dry_run : Boolean.t option
    ; ena_support : Boolean.t option
    ; kernel_id : String.t option
    ; name : String.t
    ; billing_products : BillingProductList.t
    ; ramdisk_id : String.t option
    ; root_device_name : String.t option
    ; sriov_net_support : String.t option
    ; virtualization_type : String.t option
    }

  let make
      ?image_location
      ?architecture
      ?(block_device_mappings = [])
      ?description
      ?dry_run
      ?ena_support
      ?kernel_id
      ~name
      ?(billing_products = [])
      ?ramdisk_id
      ?root_device_name
      ?sriov_net_support
      ?virtualization_type
      () =
    { image_location
    ; architecture
    ; block_device_mappings
    ; description
    ; dry_run
    ; ena_support
    ; kernel_id
    ; name
    ; billing_products
    ; ramdisk_id
    ; root_device_name
    ; sriov_net_support
    ; virtualization_type
    }

  let parse xml =
    Some
      { image_location =
          Aws.Util.option_bind (Aws.Xml.member "ImageLocation" xml) String.parse
      ; architecture =
          Aws.Util.option_bind
            (Aws.Xml.member "architecture" xml)
            ArchitectureValues.parse
      ; block_device_mappings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "BlockDeviceMapping" xml)
               BlockDeviceMappingRequestList.parse)
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; ena_support = Aws.Util.option_bind (Aws.Xml.member "enaSupport" xml) Boolean.parse
      ; kernel_id = Aws.Util.option_bind (Aws.Xml.member "kernelId" xml) String.parse
      ; name =
          Aws.Xml.required
            "name"
            (Aws.Util.option_bind (Aws.Xml.member "name" xml) String.parse)
      ; billing_products =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "BillingProduct" xml)
               BillingProductList.parse)
      ; ramdisk_id = Aws.Util.option_bind (Aws.Xml.member "ramdiskId" xml) String.parse
      ; root_device_name =
          Aws.Util.option_bind (Aws.Xml.member "rootDeviceName" xml) String.parse
      ; sriov_net_support =
          Aws.Util.option_bind (Aws.Xml.member "sriovNetSupport" xml) String.parse
      ; virtualization_type =
          Aws.Util.option_bind (Aws.Xml.member "virtualizationType" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.virtualization_type (fun f ->
               Aws.Query.Pair ("VirtualizationType", String.to_query f))
         ; Aws.Util.option_map v.sriov_net_support (fun f ->
               Aws.Query.Pair ("SriovNetSupport", String.to_query f))
         ; Aws.Util.option_map v.root_device_name (fun f ->
               Aws.Query.Pair ("RootDeviceName", String.to_query f))
         ; Aws.Util.option_map v.ramdisk_id (fun f ->
               Aws.Query.Pair ("RamdiskId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("BillingProduct", BillingProductList.to_query v.billing_products))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ; Aws.Util.option_map v.kernel_id (fun f ->
               Aws.Query.Pair ("KernelId", String.to_query f))
         ; Aws.Util.option_map v.ena_support (fun f ->
               Aws.Query.Pair ("EnaSupport", Boolean.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "BlockDeviceMapping"
                , BlockDeviceMappingRequestList.to_query v.block_device_mappings ))
         ; Aws.Util.option_map v.architecture (fun f ->
               Aws.Query.Pair ("Architecture", ArchitectureValues.to_query f))
         ; Aws.Util.option_map v.image_location (fun f ->
               Aws.Query.Pair ("ImageLocation", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.virtualization_type (fun f ->
               "virtualizationType", String.to_json f)
         ; Aws.Util.option_map v.sriov_net_support (fun f ->
               "sriovNetSupport", String.to_json f)
         ; Aws.Util.option_map v.root_device_name (fun f ->
               "rootDeviceName", String.to_json f)
         ; Aws.Util.option_map v.ramdisk_id (fun f -> "ramdiskId", String.to_json f)
         ; Some ("BillingProduct", BillingProductList.to_json v.billing_products)
         ; Some ("name", String.to_json v.name)
         ; Aws.Util.option_map v.kernel_id (fun f -> "kernelId", String.to_json f)
         ; Aws.Util.option_map v.ena_support (fun f -> "enaSupport", Boolean.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Some
             ( "BlockDeviceMapping"
             , BlockDeviceMappingRequestList.to_json v.block_device_mappings )
         ; Aws.Util.option_map v.architecture (fun f ->
               "architecture", ArchitectureValues.to_json f)
         ; Aws.Util.option_map v.image_location (fun f ->
               "ImageLocation", String.to_json f)
         ])

  let of_json j =
    { image_location =
        Aws.Util.option_map (Aws.Json.lookup j "ImageLocation") String.of_json
    ; architecture =
        Aws.Util.option_map (Aws.Json.lookup j "architecture") ArchitectureValues.of_json
    ; block_device_mappings =
        BlockDeviceMappingRequestList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "BlockDeviceMapping"))
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; ena_support = Aws.Util.option_map (Aws.Json.lookup j "enaSupport") Boolean.of_json
    ; kernel_id = Aws.Util.option_map (Aws.Json.lookup j "kernelId") String.of_json
    ; name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "name"))
    ; billing_products =
        BillingProductList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "BillingProduct"))
    ; ramdisk_id = Aws.Util.option_map (Aws.Json.lookup j "ramdiskId") String.of_json
    ; root_device_name =
        Aws.Util.option_map (Aws.Json.lookup j "rootDeviceName") String.of_json
    ; sriov_net_support =
        Aws.Util.option_map (Aws.Json.lookup j "sriovNetSupport") String.of_json
    ; virtualization_type =
        Aws.Util.option_map (Aws.Json.lookup j "virtualizationType") String.of_json
    }
end

module ImportInstanceResult = struct
  type t = { conversion_task : ConversionTask.t option }

  let make ?conversion_task () = { conversion_task }

  let parse xml =
    Some
      { conversion_task =
          Aws.Util.option_bind (Aws.Xml.member "conversionTask" xml) ConversionTask.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.conversion_task (fun f ->
               Aws.Query.Pair ("ConversionTask", ConversionTask.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.conversion_task (fun f ->
               "conversionTask", ConversionTask.to_json f)
         ])

  let of_json j =
    { conversion_task =
        Aws.Util.option_map (Aws.Json.lookup j "conversionTask") ConversionTask.of_json
    }
end

module AvailabilityZoneStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "AvailabilityZone" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DisableFastSnapshotRestoresRequest = struct
  type t =
    { availability_zones : AvailabilityZoneStringList.t
    ; source_snapshot_ids : SnapshotIdStringList.t
    ; dry_run : Boolean.t option
    }

  let make ~availability_zones ~source_snapshot_ids ?dry_run () =
    { availability_zones; source_snapshot_ids; dry_run }

  let parse xml =
    Some
      { availability_zones =
          Aws.Xml.required
            "AvailabilityZone"
            (Aws.Util.option_bind
               (Aws.Xml.member "AvailabilityZone" xml)
               AvailabilityZoneStringList.parse)
      ; source_snapshot_ids =
          Aws.Xml.required
            "SourceSnapshotId"
            (Aws.Util.option_bind
               (Aws.Xml.member "SourceSnapshotId" xml)
               SnapshotIdStringList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("SourceSnapshotId", SnapshotIdStringList.to_query v.source_snapshot_ids))
         ; Some
             (Aws.Query.Pair
                ( "AvailabilityZone"
                , AvailabilityZoneStringList.to_query v.availability_zones ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("SourceSnapshotId", SnapshotIdStringList.to_json v.source_snapshot_ids)
         ; Some
             ("AvailabilityZone", AvailabilityZoneStringList.to_json v.availability_zones)
         ])

  let of_json j =
    { availability_zones =
        AvailabilityZoneStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AvailabilityZone"))
    ; source_snapshot_ids =
        SnapshotIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceSnapshotId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module ModifySubnetAttributeRequest = struct
  type t =
    { assign_ipv6_address_on_creation : AttributeBooleanValue.t option
    ; map_public_ip_on_launch : AttributeBooleanValue.t option
    ; subnet_id : String.t
    ; map_customer_owned_ip_on_launch : AttributeBooleanValue.t option
    ; customer_owned_ipv4_pool : String.t option
    }

  let make
      ?assign_ipv6_address_on_creation
      ?map_public_ip_on_launch
      ~subnet_id
      ?map_customer_owned_ip_on_launch
      ?customer_owned_ipv4_pool
      () =
    { assign_ipv6_address_on_creation
    ; map_public_ip_on_launch
    ; subnet_id
    ; map_customer_owned_ip_on_launch
    ; customer_owned_ipv4_pool
    }

  let parse xml =
    Some
      { assign_ipv6_address_on_creation =
          Aws.Util.option_bind
            (Aws.Xml.member "AssignIpv6AddressOnCreation" xml)
            AttributeBooleanValue.parse
      ; map_public_ip_on_launch =
          Aws.Util.option_bind
            (Aws.Xml.member "MapPublicIpOnLaunch" xml)
            AttributeBooleanValue.parse
      ; subnet_id =
          Aws.Xml.required
            "subnetId"
            (Aws.Util.option_bind (Aws.Xml.member "subnetId" xml) String.parse)
      ; map_customer_owned_ip_on_launch =
          Aws.Util.option_bind
            (Aws.Xml.member "MapCustomerOwnedIpOnLaunch" xml)
            AttributeBooleanValue.parse
      ; customer_owned_ipv4_pool =
          Aws.Util.option_bind (Aws.Xml.member "CustomerOwnedIpv4Pool" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.customer_owned_ipv4_pool (fun f ->
               Aws.Query.Pair ("CustomerOwnedIpv4Pool", String.to_query f))
         ; Aws.Util.option_map v.map_customer_owned_ip_on_launch (fun f ->
               Aws.Query.Pair
                 ("MapCustomerOwnedIpOnLaunch", AttributeBooleanValue.to_query f))
         ; Some (Aws.Query.Pair ("SubnetId", String.to_query v.subnet_id))
         ; Aws.Util.option_map v.map_public_ip_on_launch (fun f ->
               Aws.Query.Pair ("MapPublicIpOnLaunch", AttributeBooleanValue.to_query f))
         ; Aws.Util.option_map v.assign_ipv6_address_on_creation (fun f ->
               Aws.Query.Pair
                 ("AssignIpv6AddressOnCreation", AttributeBooleanValue.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.customer_owned_ipv4_pool (fun f ->
               "CustomerOwnedIpv4Pool", String.to_json f)
         ; Aws.Util.option_map v.map_customer_owned_ip_on_launch (fun f ->
               "MapCustomerOwnedIpOnLaunch", AttributeBooleanValue.to_json f)
         ; Some ("subnetId", String.to_json v.subnet_id)
         ; Aws.Util.option_map v.map_public_ip_on_launch (fun f ->
               "MapPublicIpOnLaunch", AttributeBooleanValue.to_json f)
         ; Aws.Util.option_map v.assign_ipv6_address_on_creation (fun f ->
               "AssignIpv6AddressOnCreation", AttributeBooleanValue.to_json f)
         ])

  let of_json j =
    { assign_ipv6_address_on_creation =
        Aws.Util.option_map
          (Aws.Json.lookup j "AssignIpv6AddressOnCreation")
          AttributeBooleanValue.of_json
    ; map_public_ip_on_launch =
        Aws.Util.option_map
          (Aws.Json.lookup j "MapPublicIpOnLaunch")
          AttributeBooleanValue.of_json
    ; subnet_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "subnetId"))
    ; map_customer_owned_ip_on_launch =
        Aws.Util.option_map
          (Aws.Json.lookup j "MapCustomerOwnedIpOnLaunch")
          AttributeBooleanValue.of_json
    ; customer_owned_ipv4_pool =
        Aws.Util.option_map (Aws.Json.lookup j "CustomerOwnedIpv4Pool") String.of_json
    }
end

module ModifyVpcEndpointServicePermissionsResult = struct
  type t = { return_value : Boolean.t option }

  let make ?return_value () = { return_value }

  let parse xml =
    Some
      { return_value = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return_value (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return_value (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return_value = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module DescribeVpcEndpointServicePermissionsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; service_id : String.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?dry_run ~service_id ?(filters = []) ?max_results ?next_token () =
    { dry_run; service_id; filters; max_results; next_token }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; service_id =
          Aws.Xml.required
            "ServiceId"
            (Aws.Util.option_bind (Aws.Xml.member "ServiceId" xml) String.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some (Aws.Query.Pair ("ServiceId", String.to_query v.service_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some ("ServiceId", String.to_json v.service_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; service_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ServiceId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module DescribeRegionsRequest = struct
  type t =
    { filters : FilterList.t
    ; region_names : RegionNameStringList.t
    ; dry_run : Boolean.t option
    ; all_regions : Boolean.t option
    }

  let make ?(filters = []) ?(region_names = []) ?dry_run ?all_regions () =
    { filters; region_names; dry_run; all_regions }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; region_names =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "RegionName" xml)
               RegionNameStringList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; all_regions = Aws.Util.option_bind (Aws.Xml.member "AllRegions" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.all_regions (fun f ->
               Aws.Query.Pair ("AllRegions", Boolean.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair ("RegionName", RegionNameStringList.to_query v.region_names))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.all_regions (fun f -> "AllRegions", Boolean.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("RegionName", RegionNameStringList.to_json v.region_names)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; region_names =
        RegionNameStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "RegionName"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; all_regions = Aws.Util.option_map (Aws.Json.lookup j "AllRegions") Boolean.of_json
    }
end

module ModifyTransitGatewayPrefixListReferenceRequest = struct
  type t =
    { transit_gateway_route_table_id : String.t
    ; prefix_list_id : String.t
    ; transit_gateway_attachment_id : String.t option
    ; blackhole : Boolean.t option
    ; dry_run : Boolean.t option
    }

  let make
      ~transit_gateway_route_table_id
      ~prefix_list_id
      ?transit_gateway_attachment_id
      ?blackhole
      ?dry_run
      () =
    { transit_gateway_route_table_id
    ; prefix_list_id
    ; transit_gateway_attachment_id
    ; blackhole
    ; dry_run
    }

  let parse xml =
    Some
      { transit_gateway_route_table_id =
          Aws.Xml.required
            "TransitGatewayRouteTableId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayRouteTableId" xml)
               String.parse)
      ; prefix_list_id =
          Aws.Xml.required
            "PrefixListId"
            (Aws.Util.option_bind (Aws.Xml.member "PrefixListId" xml) String.parse)
      ; transit_gateway_attachment_id =
          Aws.Util.option_bind
            (Aws.Xml.member "TransitGatewayAttachmentId" xml)
            String.parse
      ; blackhole = Aws.Util.option_bind (Aws.Xml.member "Blackhole" xml) Boolean.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.blackhole (fun f ->
               Aws.Query.Pair ("Blackhole", Boolean.to_query f))
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               Aws.Query.Pair ("TransitGatewayAttachmentId", String.to_query f))
         ; Some (Aws.Query.Pair ("PrefixListId", String.to_query v.prefix_list_id))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayRouteTableId"
                , String.to_query v.transit_gateway_route_table_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.blackhole (fun f -> "Blackhole", Boolean.to_json f)
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               "TransitGatewayAttachmentId", String.to_json f)
         ; Some ("PrefixListId", String.to_json v.prefix_list_id)
         ; Some
             ( "TransitGatewayRouteTableId"
             , String.to_json v.transit_gateway_route_table_id )
         ])

  let of_json j =
    { transit_gateway_route_table_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayRouteTableId"))
    ; prefix_list_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PrefixListId"))
    ; transit_gateway_attachment_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "TransitGatewayAttachmentId")
          String.of_json
    ; blackhole = Aws.Util.option_map (Aws.Json.lookup j "Blackhole") Boolean.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module TargetNetworkSet = struct
  type t = TargetNetwork.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map TargetNetwork.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list TargetNetwork.to_query v

  let to_json v = `List (List.map TargetNetwork.to_json v)

  let of_json j = Aws.Json.to_list TargetNetwork.of_json j
end

module DescribeClientVpnTargetNetworksResult = struct
  type t =
    { client_vpn_target_networks : TargetNetworkSet.t
    ; next_token : String.t option
    }

  let make ?(client_vpn_target_networks = []) ?next_token () =
    { client_vpn_target_networks; next_token }

  let parse xml =
    Some
      { client_vpn_target_networks =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "clientVpnTargetNetworks" xml)
               TargetNetworkSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ClientVpnTargetNetworks"
                , TargetNetworkSet.to_query v.client_vpn_target_networks ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "clientVpnTargetNetworks"
             , TargetNetworkSet.to_json v.client_vpn_target_networks )
         ])

  let of_json j =
    { client_vpn_target_networks =
        TargetNetworkSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "clientVpnTargetNetworks"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module CapacityReservationIdSet = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module GetPasswordDataResult = struct
  type t =
    { instance_id : String.t
    ; password_data : String.t
    ; timestamp : DateTime.t
    }

  let make ~instance_id ~password_data ~timestamp () =
    { instance_id; password_data; timestamp }

  let parse xml =
    Some
      { instance_id =
          Aws.Xml.required
            "instanceId"
            (Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse)
      ; password_data =
          Aws.Xml.required
            "passwordData"
            (Aws.Util.option_bind (Aws.Xml.member "passwordData" xml) String.parse)
      ; timestamp =
          Aws.Xml.required
            "timestamp"
            (Aws.Util.option_bind (Aws.Xml.member "timestamp" xml) DateTime.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Timestamp", DateTime.to_query v.timestamp))
         ; Some (Aws.Query.Pair ("PasswordData", String.to_query v.password_data))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("timestamp", DateTime.to_json v.timestamp)
         ; Some ("passwordData", String.to_json v.password_data)
         ; Some ("instanceId", String.to_json v.instance_id)
         ])

  let of_json j =
    { instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceId"))
    ; password_data =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "passwordData"))
    ; timestamp =
        DateTime.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "timestamp"))
    }
end

module DnsServersOptionsModifyStructure = struct
  type t =
    { custom_dns_servers : ValueStringList.t
    ; enabled : Boolean.t option
    }

  let make ?(custom_dns_servers = []) ?enabled () = { custom_dns_servers; enabled }

  let parse xml =
    Some
      { custom_dns_servers =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "CustomDnsServers" xml)
               ValueStringList.parse)
      ; enabled = Aws.Util.option_bind (Aws.Xml.member "Enabled" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enabled (fun f ->
               Aws.Query.Pair ("Enabled", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("CustomDnsServers", ValueStringList.to_query v.custom_dns_servers))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.enabled (fun f -> "Enabled", Boolean.to_json f)
         ; Some ("CustomDnsServers", ValueStringList.to_json v.custom_dns_servers)
         ])

  let of_json j =
    { custom_dns_servers =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "CustomDnsServers"))
    ; enabled = Aws.Util.option_map (Aws.Json.lookup j "Enabled") Boolean.of_json
    }
end

module ModifyClientVpnEndpointRequest = struct
  type t =
    { client_vpn_endpoint_id : String.t
    ; server_certificate_arn : String.t option
    ; connection_log_options : ConnectionLogOptions.t option
    ; dns_servers : DnsServersOptionsModifyStructure.t option
    ; vpn_port : Integer.t option
    ; description : String.t option
    ; split_tunnel : Boolean.t option
    ; dry_run : Boolean.t option
    ; security_group_ids : ClientVpnSecurityGroupIdSet.t
    ; vpc_id : String.t option
    ; self_service_portal : SelfServicePortal.t option
    ; client_connect_options : ClientConnectOptions.t option
    }

  let make
      ~client_vpn_endpoint_id
      ?server_certificate_arn
      ?connection_log_options
      ?dns_servers
      ?vpn_port
      ?description
      ?split_tunnel
      ?dry_run
      ?(security_group_ids = [])
      ?vpc_id
      ?self_service_portal
      ?client_connect_options
      () =
    { client_vpn_endpoint_id
    ; server_certificate_arn
    ; connection_log_options
    ; dns_servers
    ; vpn_port
    ; description
    ; split_tunnel
    ; dry_run
    ; security_group_ids
    ; vpc_id
    ; self_service_portal
    ; client_connect_options
    }

  let parse xml =
    Some
      { client_vpn_endpoint_id =
          Aws.Xml.required
            "ClientVpnEndpointId"
            (Aws.Util.option_bind (Aws.Xml.member "ClientVpnEndpointId" xml) String.parse)
      ; server_certificate_arn =
          Aws.Util.option_bind (Aws.Xml.member "ServerCertificateArn" xml) String.parse
      ; connection_log_options =
          Aws.Util.option_bind
            (Aws.Xml.member "ConnectionLogOptions" xml)
            ConnectionLogOptions.parse
      ; dns_servers =
          Aws.Util.option_bind
            (Aws.Xml.member "DnsServers" xml)
            DnsServersOptionsModifyStructure.parse
      ; vpn_port = Aws.Util.option_bind (Aws.Xml.member "VpnPort" xml) Integer.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; split_tunnel =
          Aws.Util.option_bind (Aws.Xml.member "SplitTunnel" xml) Boolean.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; security_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SecurityGroupId" xml)
               ClientVpnSecurityGroupIdSet.parse)
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) String.parse
      ; self_service_portal =
          Aws.Util.option_bind
            (Aws.Xml.member "SelfServicePortal" xml)
            SelfServicePortal.parse
      ; client_connect_options =
          Aws.Util.option_bind
            (Aws.Xml.member "ClientConnectOptions" xml)
            ClientConnectOptions.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_connect_options (fun f ->
               Aws.Query.Pair ("ClientConnectOptions", ClientConnectOptions.to_query f))
         ; Aws.Util.option_map v.self_service_portal (fun f ->
               Aws.Query.Pair ("SelfServicePortal", SelfServicePortal.to_query f))
         ; Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "SecurityGroupId"
                , ClientVpnSecurityGroupIdSet.to_query v.security_group_ids ))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.split_tunnel (fun f ->
               Aws.Query.Pair ("SplitTunnel", Boolean.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.vpn_port (fun f ->
               Aws.Query.Pair ("VpnPort", Integer.to_query f))
         ; Aws.Util.option_map v.dns_servers (fun f ->
               Aws.Query.Pair ("DnsServers", DnsServersOptionsModifyStructure.to_query f))
         ; Aws.Util.option_map v.connection_log_options (fun f ->
               Aws.Query.Pair ("ConnectionLogOptions", ConnectionLogOptions.to_query f))
         ; Aws.Util.option_map v.server_certificate_arn (fun f ->
               Aws.Query.Pair ("ServerCertificateArn", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ClientVpnEndpointId", String.to_query v.client_vpn_endpoint_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_connect_options (fun f ->
               "ClientConnectOptions", ClientConnectOptions.to_json f)
         ; Aws.Util.option_map v.self_service_portal (fun f ->
               "SelfServicePortal", SelfServicePortal.to_json f)
         ; Aws.Util.option_map v.vpc_id (fun f -> "VpcId", String.to_json f)
         ; Some
             ("SecurityGroupId", ClientVpnSecurityGroupIdSet.to_json v.security_group_ids)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.split_tunnel (fun f -> "SplitTunnel", Boolean.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.vpn_port (fun f -> "VpnPort", Integer.to_json f)
         ; Aws.Util.option_map v.dns_servers (fun f ->
               "DnsServers", DnsServersOptionsModifyStructure.to_json f)
         ; Aws.Util.option_map v.connection_log_options (fun f ->
               "ConnectionLogOptions", ConnectionLogOptions.to_json f)
         ; Aws.Util.option_map v.server_certificate_arn (fun f ->
               "ServerCertificateArn", String.to_json f)
         ; Some ("ClientVpnEndpointId", String.to_json v.client_vpn_endpoint_id)
         ])

  let of_json j =
    { client_vpn_endpoint_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ClientVpnEndpointId"))
    ; server_certificate_arn =
        Aws.Util.option_map (Aws.Json.lookup j "ServerCertificateArn") String.of_json
    ; connection_log_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "ConnectionLogOptions")
          ConnectionLogOptions.of_json
    ; dns_servers =
        Aws.Util.option_map
          (Aws.Json.lookup j "DnsServers")
          DnsServersOptionsModifyStructure.of_json
    ; vpn_port = Aws.Util.option_map (Aws.Json.lookup j "VpnPort") Integer.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; split_tunnel = Aws.Util.option_map (Aws.Json.lookup j "SplitTunnel") Boolean.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; security_group_ids =
        ClientVpnSecurityGroupIdSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SecurityGroupId"))
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "VpcId") String.of_json
    ; self_service_portal =
        Aws.Util.option_map
          (Aws.Json.lookup j "SelfServicePortal")
          SelfServicePortal.of_json
    ; client_connect_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "ClientConnectOptions")
          ClientConnectOptions.of_json
    }
end

module CreateLocalGatewayRouteTableVpcAssociationResult = struct
  type t =
    { local_gateway_route_table_vpc_association :
        LocalGatewayRouteTableVpcAssociation.t option
    }

  let make ?local_gateway_route_table_vpc_association () =
    { local_gateway_route_table_vpc_association }

  let parse xml =
    Some
      { local_gateway_route_table_vpc_association =
          Aws.Util.option_bind
            (Aws.Xml.member "localGatewayRouteTableVpcAssociation" xml)
            LocalGatewayRouteTableVpcAssociation.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.local_gateway_route_table_vpc_association (fun f ->
               Aws.Query.Pair
                 ( "LocalGatewayRouteTableVpcAssociation"
                 , LocalGatewayRouteTableVpcAssociation.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.local_gateway_route_table_vpc_association (fun f ->
               ( "localGatewayRouteTableVpcAssociation"
               , LocalGatewayRouteTableVpcAssociation.to_json f ))
         ])

  let of_json j =
    { local_gateway_route_table_vpc_association =
        Aws.Util.option_map
          (Aws.Json.lookup j "localGatewayRouteTableVpcAssociation")
          LocalGatewayRouteTableVpcAssociation.of_json
    }
end

module ModifyIdentityIdFormatRequest = struct
  type t =
    { principal_arn : String.t
    ; resource : String.t
    ; use_long_ids : Boolean.t
    }

  let make ~principal_arn ~resource ~use_long_ids () =
    { principal_arn; resource; use_long_ids }

  let parse xml =
    Some
      { principal_arn =
          Aws.Xml.required
            "principalArn"
            (Aws.Util.option_bind (Aws.Xml.member "principalArn" xml) String.parse)
      ; resource =
          Aws.Xml.required
            "resource"
            (Aws.Util.option_bind (Aws.Xml.member "resource" xml) String.parse)
      ; use_long_ids =
          Aws.Xml.required
            "useLongIds"
            (Aws.Util.option_bind (Aws.Xml.member "useLongIds" xml) Boolean.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("UseLongIds", Boolean.to_query v.use_long_ids))
         ; Some (Aws.Query.Pair ("Resource", String.to_query v.resource))
         ; Some (Aws.Query.Pair ("PrincipalArn", String.to_query v.principal_arn))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("useLongIds", Boolean.to_json v.use_long_ids)
         ; Some ("resource", String.to_json v.resource)
         ; Some ("principalArn", String.to_json v.principal_arn)
         ])

  let of_json j =
    { principal_arn =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "principalArn"))
    ; resource = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "resource"))
    ; use_long_ids =
        Boolean.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "useLongIds"))
    }
end

module AcceptTransitGatewayVpcAttachmentResult = struct
  type t = { transit_gateway_vpc_attachment : TransitGatewayVpcAttachment.t option }

  let make ?transit_gateway_vpc_attachment () = { transit_gateway_vpc_attachment }

  let parse xml =
    Some
      { transit_gateway_vpc_attachment =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayVpcAttachment" xml)
            TransitGatewayVpcAttachment.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_vpc_attachment (fun f ->
               Aws.Query.Pair
                 ("TransitGatewayVpcAttachment", TransitGatewayVpcAttachment.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_vpc_attachment (fun f ->
               "transitGatewayVpcAttachment", TransitGatewayVpcAttachment.to_json f)
         ])

  let of_json j =
    { transit_gateway_vpc_attachment =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayVpcAttachment")
          TransitGatewayVpcAttachment.of_json
    }
end

module DeleteVpcEndpointConnectionNotificationsResult = struct
  type t = { unsuccessful : UnsuccessfulItemSet.t }

  let make ?(unsuccessful = []) () = { unsuccessful }

  let parse xml =
    Some
      { unsuccessful =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "unsuccessful" xml)
               UnsuccessfulItemSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("Unsuccessful", UnsuccessfulItemSet.to_query v.unsuccessful))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("unsuccessful", UnsuccessfulItemSet.to_json v.unsuccessful) ])

  let of_json j =
    { unsuccessful =
        UnsuccessfulItemSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "unsuccessful"))
    }
end

module GetHostReservationPurchasePreviewRequest = struct
  type t =
    { host_id_set : RequestHostIdSet.t
    ; offering_id : String.t
    }

  let make ~host_id_set ~offering_id () = { host_id_set; offering_id }

  let parse xml =
    Some
      { host_id_set =
          Aws.Xml.required
            "HostIdSet"
            (Aws.Util.option_bind (Aws.Xml.member "HostIdSet" xml) RequestHostIdSet.parse)
      ; offering_id =
          Aws.Xml.required
            "OfferingId"
            (Aws.Util.option_bind (Aws.Xml.member "OfferingId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("OfferingId", String.to_query v.offering_id))
         ; Some (Aws.Query.Pair ("HostIdSet", RequestHostIdSet.to_query v.host_id_set))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("OfferingId", String.to_json v.offering_id)
         ; Some ("HostIdSet", RequestHostIdSet.to_json v.host_id_set)
         ])

  let of_json j =
    { host_id_set =
        RequestHostIdSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "HostIdSet"))
    ; offering_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "OfferingId"))
    }
end

module AssociateSubnetCidrBlockRequest = struct
  type t =
    { ipv6_cidr_block : String.t
    ; subnet_id : String.t
    }

  let make ~ipv6_cidr_block ~subnet_id () = { ipv6_cidr_block; subnet_id }

  let parse xml =
    Some
      { ipv6_cidr_block =
          Aws.Xml.required
            "ipv6CidrBlock"
            (Aws.Util.option_bind (Aws.Xml.member "ipv6CidrBlock" xml) String.parse)
      ; subnet_id =
          Aws.Xml.required
            "subnetId"
            (Aws.Util.option_bind (Aws.Xml.member "subnetId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("SubnetId", String.to_query v.subnet_id))
         ; Some (Aws.Query.Pair ("Ipv6CidrBlock", String.to_query v.ipv6_cidr_block))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("subnetId", String.to_json v.subnet_id)
         ; Some ("ipv6CidrBlock", String.to_json v.ipv6_cidr_block)
         ])

  let of_json j =
    { ipv6_cidr_block =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ipv6CidrBlock"))
    ; subnet_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "subnetId"))
    }
end

module VpnConnectionList = struct
  type t = VpnConnection.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map VpnConnection.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list VpnConnection.to_query v

  let to_json v = `List (List.map VpnConnection.to_json v)

  let of_json j = Aws.Json.to_list VpnConnection.of_json j
end

module DescribeVpnConnectionsResult = struct
  type t = { vpn_connections : VpnConnectionList.t }

  let make ?(vpn_connections = []) () = { vpn_connections }

  let parse xml =
    Some
      { vpn_connections =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "vpnConnectionSet" xml)
               VpnConnectionList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("VpnConnectionSet", VpnConnectionList.to_query v.vpn_connections))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("vpnConnectionSet", VpnConnectionList.to_json v.vpn_connections) ])

  let of_json j =
    { vpn_connections =
        VpnConnectionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "vpnConnectionSet"))
    }
end

module ApplySecurityGroupsToClientVpnTargetNetworkResult = struct
  type t = { security_group_ids : ClientVpnSecurityGroupIdSet.t }

  let make ?(security_group_ids = []) () = { security_group_ids }

  let parse xml =
    Some
      { security_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "securityGroupIds" xml)
               ClientVpnSecurityGroupIdSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "SecurityGroupIds"
                , ClientVpnSecurityGroupIdSet.to_query v.security_group_ids ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ("securityGroupIds", ClientVpnSecurityGroupIdSet.to_json v.security_group_ids)
         ])

  let of_json j =
    { security_group_ids =
        ClientVpnSecurityGroupIdSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "securityGroupIds"))
    }
end

module ModifyInstanceCapacityReservationAttributesRequest = struct
  type t =
    { instance_id : String.t
    ; capacity_reservation_specification : CapacityReservationSpecification.t
    ; dry_run : Boolean.t option
    }

  let make ~instance_id ~capacity_reservation_specification ?dry_run () =
    { instance_id; capacity_reservation_specification; dry_run }

  let parse xml =
    Some
      { instance_id =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse)
      ; capacity_reservation_specification =
          Aws.Xml.required
            "CapacityReservationSpecification"
            (Aws.Util.option_bind
               (Aws.Xml.member "CapacityReservationSpecification" xml)
               CapacityReservationSpecification.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "CapacityReservationSpecification"
                , CapacityReservationSpecification.to_query
                    v.capacity_reservation_specification ))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ( "CapacityReservationSpecification"
             , CapacityReservationSpecification.to_json
                 v.capacity_reservation_specification )
         ; Some ("InstanceId", String.to_json v.instance_id)
         ])

  let of_json j =
    { instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; capacity_reservation_specification =
        CapacityReservationSpecification.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "CapacityReservationSpecification"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DescribeClientVpnRoutesResult = struct
  type t =
    { routes : ClientVpnRouteSet.t
    ; next_token : String.t option
    }

  let make ?(routes = []) ?next_token () = { routes; next_token }

  let parse xml =
    Some
      { routes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "routes" xml) ClientVpnRouteSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("Routes", ClientVpnRouteSet.to_query v.routes))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("routes", ClientVpnRouteSet.to_json v.routes)
         ])

  let of_json j =
    { routes =
        ClientVpnRouteSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "routes"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module ClientVpnConnectionSet = struct
  type t = ClientVpnConnection.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map ClientVpnConnection.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list ClientVpnConnection.to_query v

  let to_json v = `List (List.map ClientVpnConnection.to_json v)

  let of_json j = Aws.Json.to_list ClientVpnConnection.of_json j
end

module HistoryRecordEntry = struct
  type t =
    { event_information : EventInformation.t option
    ; event_type : FleetEventType.t option
    ; timestamp : DateTime.t option
    }

  let make ?event_information ?event_type ?timestamp () =
    { event_information; event_type; timestamp }

  let parse xml =
    Some
      { event_information =
          Aws.Util.option_bind
            (Aws.Xml.member "eventInformation" xml)
            EventInformation.parse
      ; event_type =
          Aws.Util.option_bind (Aws.Xml.member "eventType" xml) FleetEventType.parse
      ; timestamp = Aws.Util.option_bind (Aws.Xml.member "timestamp" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timestamp (fun f ->
               Aws.Query.Pair ("Timestamp", DateTime.to_query f))
         ; Aws.Util.option_map v.event_type (fun f ->
               Aws.Query.Pair ("EventType", FleetEventType.to_query f))
         ; Aws.Util.option_map v.event_information (fun f ->
               Aws.Query.Pair ("EventInformation", EventInformation.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.timestamp (fun f -> "timestamp", DateTime.to_json f)
         ; Aws.Util.option_map v.event_type (fun f ->
               "eventType", FleetEventType.to_json f)
         ; Aws.Util.option_map v.event_information (fun f ->
               "eventInformation", EventInformation.to_json f)
         ])

  let of_json j =
    { event_information =
        Aws.Util.option_map
          (Aws.Json.lookup j "eventInformation")
          EventInformation.of_json
    ; event_type =
        Aws.Util.option_map (Aws.Json.lookup j "eventType") FleetEventType.of_json
    ; timestamp = Aws.Util.option_map (Aws.Json.lookup j "timestamp") DateTime.of_json
    }
end

module HistoryRecordSet = struct
  type t = HistoryRecordEntry.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map HistoryRecordEntry.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list HistoryRecordEntry.to_query v

  let to_json v = `List (List.map HistoryRecordEntry.to_json v)

  let of_json j = Aws.Json.to_list HistoryRecordEntry.of_json j
end

module CreateSubnetResult = struct
  type t = { subnet : Subnet.t option }

  let make ?subnet () = { subnet }

  let parse xml =
    Some { subnet = Aws.Util.option_bind (Aws.Xml.member "subnet" xml) Subnet.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.subnet (fun f ->
               Aws.Query.Pair ("Subnet", Subnet.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.subnet (fun f -> "subnet", Subnet.to_json f) ])

  let of_json j =
    { subnet = Aws.Util.option_map (Aws.Json.lookup j "subnet") Subnet.of_json }
end

module CreateNatGatewayRequest = struct
  type t =
    { allocation_id : String.t
    ; client_token : String.t option
    ; dry_run : Boolean.t option
    ; subnet_id : String.t
    ; tag_specifications : TagSpecificationList.t
    }

  let make ~allocation_id ?client_token ?dry_run ~subnet_id ?(tag_specifications = []) ()
      =
    { allocation_id; client_token; dry_run; subnet_id; tag_specifications }

  let parse xml =
    Some
      { allocation_id =
          Aws.Xml.required
            "AllocationId"
            (Aws.Util.option_bind (Aws.Xml.member "AllocationId" xml) String.parse)
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; subnet_id =
          Aws.Xml.required
            "SubnetId"
            (Aws.Util.option_bind (Aws.Xml.member "SubnetId" xml) String.parse)
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Some (Aws.Query.Pair ("SubnetId", String.to_query v.subnet_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Some (Aws.Query.Pair ("AllocationId", String.to_query v.allocation_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Some ("SubnetId", String.to_json v.subnet_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Some ("AllocationId", String.to_json v.allocation_id)
         ])

  let of_json j =
    { allocation_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "AllocationId"))
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; subnet_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SubnetId"))
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    }
end

module DescribeInstanceTypesResult = struct
  type t =
    { instance_types : InstanceTypeInfoList.t
    ; next_token : String.t option
    }

  let make ?(instance_types = []) ?next_token () = { instance_types; next_token }

  let parse xml =
    Some
      { instance_types =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "instanceTypeSet" xml)
               InstanceTypeInfoList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("InstanceTypeSet", InstanceTypeInfoList.to_query v.instance_types))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("instanceTypeSet", InstanceTypeInfoList.to_json v.instance_types)
         ])

  let of_json j =
    { instance_types =
        InstanceTypeInfoList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceTypeSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DescribeAddressesResult = struct
  type t = { addresses : AddressList.t }

  let make ?(addresses = []) () = { addresses }

  let parse xml =
    Some
      { addresses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "addressesSet" xml) AddressList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("AddressesSet", AddressList.to_query v.addresses)) ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("addressesSet", AddressList.to_json v.addresses) ])

  let of_json j =
    { addresses =
        AddressList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "addressesSet"))
    }
end

module GetManagedPrefixListAssociationsResult = struct
  type t =
    { prefix_list_associations : PrefixListAssociationSet.t
    ; next_token : String.t option
    }

  let make ?(prefix_list_associations = []) ?next_token () =
    { prefix_list_associations; next_token }

  let parse xml =
    Some
      { prefix_list_associations =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "prefixListAssociationSet" xml)
               PrefixListAssociationSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "PrefixListAssociationSet"
                , PrefixListAssociationSet.to_query v.prefix_list_associations ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "prefixListAssociationSet"
             , PrefixListAssociationSet.to_json v.prefix_list_associations )
         ])

  let of_json j =
    { prefix_list_associations =
        PrefixListAssociationSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "prefixListAssociationSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module ValidationWarning = struct
  type t = { errors : ErrorSet.t }

  let make ?(errors = []) () = { errors }

  let parse xml =
    Some
      { errors =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "errorSet" xml) ErrorSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("ErrorSet", ErrorSet.to_query v.errors)) ])

  let to_json v =
    `Assoc (Aws.Util.list_filter_opt [ Some ("errorSet", ErrorSet.to_json v.errors) ])

  let of_json j =
    { errors = ErrorSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "errorSet")) }
end

module DetachVolumeRequest = struct
  type t =
    { device : String.t option
    ; force : Boolean.t option
    ; instance_id : String.t option
    ; volume_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ?device ?force ?instance_id ~volume_id ?dry_run () =
    { device; force; instance_id; volume_id; dry_run }

  let parse xml =
    Some
      { device = Aws.Util.option_bind (Aws.Xml.member "Device" xml) String.parse
      ; force = Aws.Util.option_bind (Aws.Xml.member "Force" xml) Boolean.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse
      ; volume_id =
          Aws.Xml.required
            "VolumeId"
            (Aws.Util.option_bind (Aws.Xml.member "VolumeId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("VolumeId", String.to_query v.volume_id))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.force (fun f ->
               Aws.Query.Pair ("Force", Boolean.to_query f))
         ; Aws.Util.option_map v.device (fun f ->
               Aws.Query.Pair ("Device", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("VolumeId", String.to_json v.volume_id)
         ; Aws.Util.option_map v.instance_id (fun f -> "InstanceId", String.to_json f)
         ; Aws.Util.option_map v.force (fun f -> "Force", Boolean.to_json f)
         ; Aws.Util.option_map v.device (fun f -> "Device", String.to_json f)
         ])

  let of_json j =
    { device = Aws.Util.option_map (Aws.Json.lookup j "Device") String.of_json
    ; force = Aws.Util.option_map (Aws.Json.lookup j "Force") Boolean.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "InstanceId") String.of_json
    ; volume_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VolumeId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module DeregisterTransitGatewayMulticastGroupMembersRequest = struct
  type t =
    { transit_gateway_multicast_domain_id : String.t option
    ; group_ip_address : String.t option
    ; network_interface_ids : TransitGatewayNetworkInterfaceIdList.t
    ; dry_run : Boolean.t option
    }

  let make
      ?transit_gateway_multicast_domain_id
      ?group_ip_address
      ?(network_interface_ids = [])
      ?dry_run
      () =
    { transit_gateway_multicast_domain_id
    ; group_ip_address
    ; network_interface_ids
    ; dry_run
    }

  let parse xml =
    Some
      { transit_gateway_multicast_domain_id =
          Aws.Util.option_bind
            (Aws.Xml.member "TransitGatewayMulticastDomainId" xml)
            String.parse
      ; group_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "GroupIpAddress" xml) String.parse
      ; network_interface_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "NetworkInterfaceIds" xml)
               TransitGatewayNetworkInterfaceIdList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "NetworkInterfaceIds"
                , TransitGatewayNetworkInterfaceIdList.to_query v.network_interface_ids ))
         ; Aws.Util.option_map v.group_ip_address (fun f ->
               Aws.Query.Pair ("GroupIpAddress", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               Aws.Query.Pair ("TransitGatewayMulticastDomainId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ( "NetworkInterfaceIds"
             , TransitGatewayNetworkInterfaceIdList.to_json v.network_interface_ids )
         ; Aws.Util.option_map v.group_ip_address (fun f ->
               "GroupIpAddress", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               "TransitGatewayMulticastDomainId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_multicast_domain_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "TransitGatewayMulticastDomainId")
          String.of_json
    ; group_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "GroupIpAddress") String.of_json
    ; network_interface_ids =
        TransitGatewayNetworkInterfaceIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "NetworkInterfaceIds"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module ModifyVpcPeeringConnectionOptionsRequest = struct
  type t =
    { accepter_peering_connection_options : PeeringConnectionOptionsRequest.t option
    ; dry_run : Boolean.t option
    ; requester_peering_connection_options : PeeringConnectionOptionsRequest.t option
    ; vpc_peering_connection_id : String.t
    }

  let make
      ?accepter_peering_connection_options
      ?dry_run
      ?requester_peering_connection_options
      ~vpc_peering_connection_id
      () =
    { accepter_peering_connection_options
    ; dry_run
    ; requester_peering_connection_options
    ; vpc_peering_connection_id
    }

  let parse xml =
    Some
      { accepter_peering_connection_options =
          Aws.Util.option_bind
            (Aws.Xml.member "AccepterPeeringConnectionOptions" xml)
            PeeringConnectionOptionsRequest.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; requester_peering_connection_options =
          Aws.Util.option_bind
            (Aws.Xml.member "RequesterPeeringConnectionOptions" xml)
            PeeringConnectionOptionsRequest.parse
      ; vpc_peering_connection_id =
          Aws.Xml.required
            "VpcPeeringConnectionId"
            (Aws.Util.option_bind
               (Aws.Xml.member "VpcPeeringConnectionId" xml)
               String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("VpcPeeringConnectionId", String.to_query v.vpc_peering_connection_id))
         ; Aws.Util.option_map v.requester_peering_connection_options (fun f ->
               Aws.Query.Pair
                 ( "RequesterPeeringConnectionOptions"
                 , PeeringConnectionOptionsRequest.to_query f ))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.accepter_peering_connection_options (fun f ->
               Aws.Query.Pair
                 ( "AccepterPeeringConnectionOptions"
                 , PeeringConnectionOptionsRequest.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("VpcPeeringConnectionId", String.to_json v.vpc_peering_connection_id)
         ; Aws.Util.option_map v.requester_peering_connection_options (fun f ->
               ( "RequesterPeeringConnectionOptions"
               , PeeringConnectionOptionsRequest.to_json f ))
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.accepter_peering_connection_options (fun f ->
               ( "AccepterPeeringConnectionOptions"
               , PeeringConnectionOptionsRequest.to_json f ))
         ])

  let of_json j =
    { accepter_peering_connection_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "AccepterPeeringConnectionOptions")
          PeeringConnectionOptionsRequest.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; requester_peering_connection_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "RequesterPeeringConnectionOptions")
          PeeringConnectionOptionsRequest.of_json
    ; vpc_peering_connection_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcPeeringConnectionId"))
    }
end

module AssociateVpcCidrBlockResult = struct
  type t =
    { ipv6_cidr_block_association : VpcIpv6CidrBlockAssociation.t option
    ; cidr_block_association : VpcCidrBlockAssociation.t option
    ; vpc_id : String.t option
    }

  let make ?ipv6_cidr_block_association ?cidr_block_association ?vpc_id () =
    { ipv6_cidr_block_association; cidr_block_association; vpc_id }

  let parse xml =
    Some
      { ipv6_cidr_block_association =
          Aws.Util.option_bind
            (Aws.Xml.member "ipv6CidrBlockAssociation" xml)
            VpcIpv6CidrBlockAssociation.parse
      ; cidr_block_association =
          Aws.Util.option_bind
            (Aws.Xml.member "cidrBlockAssociation" xml)
            VpcCidrBlockAssociation.parse
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Aws.Util.option_map v.cidr_block_association (fun f ->
               Aws.Query.Pair ("CidrBlockAssociation", VpcCidrBlockAssociation.to_query f))
         ; Aws.Util.option_map v.ipv6_cidr_block_association (fun f ->
               Aws.Query.Pair
                 ("Ipv6CidrBlockAssociation", VpcIpv6CidrBlockAssociation.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_id (fun f -> "vpcId", String.to_json f)
         ; Aws.Util.option_map v.cidr_block_association (fun f ->
               "cidrBlockAssociation", VpcCidrBlockAssociation.to_json f)
         ; Aws.Util.option_map v.ipv6_cidr_block_association (fun f ->
               "ipv6CidrBlockAssociation", VpcIpv6CidrBlockAssociation.to_json f)
         ])

  let of_json j =
    { ipv6_cidr_block_association =
        Aws.Util.option_map
          (Aws.Json.lookup j "ipv6CidrBlockAssociation")
          VpcIpv6CidrBlockAssociation.of_json
    ; cidr_block_association =
        Aws.Util.option_map
          (Aws.Json.lookup j "cidrBlockAssociation")
          VpcCidrBlockAssociation.of_json
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "vpcId") String.of_json
    }
end

module DeleteTransitGatewayRouteTableResult = struct
  type t = { transit_gateway_route_table : TransitGatewayRouteTable.t option }

  let make ?transit_gateway_route_table () = { transit_gateway_route_table }

  let parse xml =
    Some
      { transit_gateway_route_table =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayRouteTable" xml)
            TransitGatewayRouteTable.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_route_table (fun f ->
               Aws.Query.Pair
                 ("TransitGatewayRouteTable", TransitGatewayRouteTable.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_route_table (fun f ->
               "transitGatewayRouteTable", TransitGatewayRouteTable.to_json f)
         ])

  let of_json j =
    { transit_gateway_route_table =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayRouteTable")
          TransitGatewayRouteTable.of_json
    }
end

module PublicIpStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "PublicIp" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module AllocationIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "AllocationId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeAddressesRequest = struct
  type t =
    { filters : FilterList.t
    ; public_ips : PublicIpStringList.t
    ; allocation_ids : AllocationIdList.t
    ; dry_run : Boolean.t option
    }

  let make ?(filters = []) ?(public_ips = []) ?(allocation_ids = []) ?dry_run () =
    { filters; public_ips; allocation_ids; dry_run }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; public_ips =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "PublicIp" xml)
               PublicIpStringList.parse)
      ; allocation_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AllocationId" xml)
               AllocationIdList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair ("AllocationId", AllocationIdList.to_query v.allocation_ids))
         ; Some (Aws.Query.Pair ("PublicIp", PublicIpStringList.to_query v.public_ips))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("AllocationId", AllocationIdList.to_json v.allocation_ids)
         ; Some ("PublicIp", PublicIpStringList.to_json v.public_ips)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; public_ips =
        PublicIpStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PublicIp"))
    ; allocation_ids =
        AllocationIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AllocationId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module DisableEbsEncryptionByDefaultRequest = struct
  type t = { dry_run : Boolean.t option }

  let make ?dry_run () = { dry_run }

  let parse xml =
    Some { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f) ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json }
end

module CreateRouteRequest = struct
  type t =
    { destination_cidr_block : String.t option
    ; destination_ipv6_cidr_block : String.t option
    ; destination_prefix_list_id : String.t option
    ; dry_run : Boolean.t option
    ; vpc_endpoint_id : String.t option
    ; egress_only_internet_gateway_id : String.t option
    ; gateway_id : String.t option
    ; instance_id : String.t option
    ; nat_gateway_id : String.t option
    ; transit_gateway_id : String.t option
    ; local_gateway_id : String.t option
    ; carrier_gateway_id : String.t option
    ; network_interface_id : String.t option
    ; route_table_id : String.t
    ; vpc_peering_connection_id : String.t option
    }

  let make
      ?destination_cidr_block
      ?destination_ipv6_cidr_block
      ?destination_prefix_list_id
      ?dry_run
      ?vpc_endpoint_id
      ?egress_only_internet_gateway_id
      ?gateway_id
      ?instance_id
      ?nat_gateway_id
      ?transit_gateway_id
      ?local_gateway_id
      ?carrier_gateway_id
      ?network_interface_id
      ~route_table_id
      ?vpc_peering_connection_id
      () =
    { destination_cidr_block
    ; destination_ipv6_cidr_block
    ; destination_prefix_list_id
    ; dry_run
    ; vpc_endpoint_id
    ; egress_only_internet_gateway_id
    ; gateway_id
    ; instance_id
    ; nat_gateway_id
    ; transit_gateway_id
    ; local_gateway_id
    ; carrier_gateway_id
    ; network_interface_id
    ; route_table_id
    ; vpc_peering_connection_id
    }

  let parse xml =
    Some
      { destination_cidr_block =
          Aws.Util.option_bind (Aws.Xml.member "destinationCidrBlock" xml) String.parse
      ; destination_ipv6_cidr_block =
          Aws.Util.option_bind
            (Aws.Xml.member "destinationIpv6CidrBlock" xml)
            String.parse
      ; destination_prefix_list_id =
          Aws.Util.option_bind (Aws.Xml.member "DestinationPrefixListId" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; vpc_endpoint_id =
          Aws.Util.option_bind (Aws.Xml.member "VpcEndpointId" xml) String.parse
      ; egress_only_internet_gateway_id =
          Aws.Util.option_bind
            (Aws.Xml.member "egressOnlyInternetGatewayId" xml)
            String.parse
      ; gateway_id = Aws.Util.option_bind (Aws.Xml.member "gatewayId" xml) String.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      ; nat_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "natGatewayId" xml) String.parse
      ; transit_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "TransitGatewayId" xml) String.parse
      ; local_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "LocalGatewayId" xml) String.parse
      ; carrier_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "CarrierGatewayId" xml) String.parse
      ; network_interface_id =
          Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse
      ; route_table_id =
          Aws.Xml.required
            "routeTableId"
            (Aws.Util.option_bind (Aws.Xml.member "routeTableId" xml) String.parse)
      ; vpc_peering_connection_id =
          Aws.Util.option_bind (Aws.Xml.member "vpcPeeringConnectionId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_peering_connection_id (fun f ->
               Aws.Query.Pair ("VpcPeeringConnectionId", String.to_query f))
         ; Some (Aws.Query.Pair ("RouteTableId", String.to_query v.route_table_id))
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               Aws.Query.Pair ("NetworkInterfaceId", String.to_query f))
         ; Aws.Util.option_map v.carrier_gateway_id (fun f ->
               Aws.Query.Pair ("CarrierGatewayId", String.to_query f))
         ; Aws.Util.option_map v.local_gateway_id (fun f ->
               Aws.Query.Pair ("LocalGatewayId", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_id (fun f ->
               Aws.Query.Pair ("TransitGatewayId", String.to_query f))
         ; Aws.Util.option_map v.nat_gateway_id (fun f ->
               Aws.Query.Pair ("NatGatewayId", String.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.gateway_id (fun f ->
               Aws.Query.Pair ("GatewayId", String.to_query f))
         ; Aws.Util.option_map v.egress_only_internet_gateway_id (fun f ->
               Aws.Query.Pair ("EgressOnlyInternetGatewayId", String.to_query f))
         ; Aws.Util.option_map v.vpc_endpoint_id (fun f ->
               Aws.Query.Pair ("VpcEndpointId", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.destination_prefix_list_id (fun f ->
               Aws.Query.Pair ("DestinationPrefixListId", String.to_query f))
         ; Aws.Util.option_map v.destination_ipv6_cidr_block (fun f ->
               Aws.Query.Pair ("DestinationIpv6CidrBlock", String.to_query f))
         ; Aws.Util.option_map v.destination_cidr_block (fun f ->
               Aws.Query.Pair ("DestinationCidrBlock", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_peering_connection_id (fun f ->
               "vpcPeeringConnectionId", String.to_json f)
         ; Some ("routeTableId", String.to_json v.route_table_id)
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               "networkInterfaceId", String.to_json f)
         ; Aws.Util.option_map v.carrier_gateway_id (fun f ->
               "CarrierGatewayId", String.to_json f)
         ; Aws.Util.option_map v.local_gateway_id (fun f ->
               "LocalGatewayId", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_id (fun f ->
               "TransitGatewayId", String.to_json f)
         ; Aws.Util.option_map v.nat_gateway_id (fun f ->
               "natGatewayId", String.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ; Aws.Util.option_map v.gateway_id (fun f -> "gatewayId", String.to_json f)
         ; Aws.Util.option_map v.egress_only_internet_gateway_id (fun f ->
               "egressOnlyInternetGatewayId", String.to_json f)
         ; Aws.Util.option_map v.vpc_endpoint_id (fun f ->
               "VpcEndpointId", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.destination_prefix_list_id (fun f ->
               "DestinationPrefixListId", String.to_json f)
         ; Aws.Util.option_map v.destination_ipv6_cidr_block (fun f ->
               "destinationIpv6CidrBlock", String.to_json f)
         ; Aws.Util.option_map v.destination_cidr_block (fun f ->
               "destinationCidrBlock", String.to_json f)
         ])

  let of_json j =
    { destination_cidr_block =
        Aws.Util.option_map (Aws.Json.lookup j "destinationCidrBlock") String.of_json
    ; destination_ipv6_cidr_block =
        Aws.Util.option_map (Aws.Json.lookup j "destinationIpv6CidrBlock") String.of_json
    ; destination_prefix_list_id =
        Aws.Util.option_map (Aws.Json.lookup j "DestinationPrefixListId") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; vpc_endpoint_id =
        Aws.Util.option_map (Aws.Json.lookup j "VpcEndpointId") String.of_json
    ; egress_only_internet_gateway_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "egressOnlyInternetGatewayId")
          String.of_json
    ; gateway_id = Aws.Util.option_map (Aws.Json.lookup j "gatewayId") String.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    ; nat_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "natGatewayId") String.of_json
    ; transit_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "TransitGatewayId") String.of_json
    ; local_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "LocalGatewayId") String.of_json
    ; carrier_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "CarrierGatewayId") String.of_json
    ; network_interface_id =
        Aws.Util.option_map (Aws.Json.lookup j "networkInterfaceId") String.of_json
    ; route_table_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "routeTableId"))
    ; vpc_peering_connection_id =
        Aws.Util.option_map (Aws.Json.lookup j "vpcPeeringConnectionId") String.of_json
    }
end

module ProductDescriptionList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "member" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module TransitGatewaySubnetIdList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module ModifyTransitGatewayVpcAttachmentRequestOptions = struct
  type t =
    { dns_support : DnsSupportValue.t option
    ; ipv6_support : Ipv6SupportValue.t option
    ; appliance_mode_support : ApplianceModeSupportValue.t option
    }

  let make ?dns_support ?ipv6_support ?appliance_mode_support () =
    { dns_support; ipv6_support; appliance_mode_support }

  let parse xml =
    Some
      { dns_support =
          Aws.Util.option_bind (Aws.Xml.member "DnsSupport" xml) DnsSupportValue.parse
      ; ipv6_support =
          Aws.Util.option_bind (Aws.Xml.member "Ipv6Support" xml) Ipv6SupportValue.parse
      ; appliance_mode_support =
          Aws.Util.option_bind
            (Aws.Xml.member "ApplianceModeSupport" xml)
            ApplianceModeSupportValue.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.appliance_mode_support (fun f ->
               Aws.Query.Pair
                 ("ApplianceModeSupport", ApplianceModeSupportValue.to_query f))
         ; Aws.Util.option_map v.ipv6_support (fun f ->
               Aws.Query.Pair ("Ipv6Support", Ipv6SupportValue.to_query f))
         ; Aws.Util.option_map v.dns_support (fun f ->
               Aws.Query.Pair ("DnsSupport", DnsSupportValue.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.appliance_mode_support (fun f ->
               "ApplianceModeSupport", ApplianceModeSupportValue.to_json f)
         ; Aws.Util.option_map v.ipv6_support (fun f ->
               "Ipv6Support", Ipv6SupportValue.to_json f)
         ; Aws.Util.option_map v.dns_support (fun f ->
               "DnsSupport", DnsSupportValue.to_json f)
         ])

  let of_json j =
    { dns_support =
        Aws.Util.option_map (Aws.Json.lookup j "DnsSupport") DnsSupportValue.of_json
    ; ipv6_support =
        Aws.Util.option_map (Aws.Json.lookup j "Ipv6Support") Ipv6SupportValue.of_json
    ; appliance_mode_support =
        Aws.Util.option_map
          (Aws.Json.lookup j "ApplianceModeSupport")
          ApplianceModeSupportValue.of_json
    }
end

module ModifyTransitGatewayVpcAttachmentRequest = struct
  type t =
    { transit_gateway_attachment_id : String.t
    ; add_subnet_ids : TransitGatewaySubnetIdList.t
    ; remove_subnet_ids : TransitGatewaySubnetIdList.t
    ; options : ModifyTransitGatewayVpcAttachmentRequestOptions.t option
    ; dry_run : Boolean.t option
    }

  let make
      ~transit_gateway_attachment_id
      ?(add_subnet_ids = [])
      ?(remove_subnet_ids = [])
      ?options
      ?dry_run
      () =
    { transit_gateway_attachment_id; add_subnet_ids; remove_subnet_ids; options; dry_run }

  let parse xml =
    Some
      { transit_gateway_attachment_id =
          Aws.Xml.required
            "TransitGatewayAttachmentId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayAttachmentId" xml)
               String.parse)
      ; add_subnet_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AddSubnetIds" xml)
               TransitGatewaySubnetIdList.parse)
      ; remove_subnet_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "RemoveSubnetIds" xml)
               TransitGatewaySubnetIdList.parse)
      ; options =
          Aws.Util.option_bind
            (Aws.Xml.member "Options" xml)
            ModifyTransitGatewayVpcAttachmentRequestOptions.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.options (fun f ->
               Aws.Query.Pair
                 ("Options", ModifyTransitGatewayVpcAttachmentRequestOptions.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "RemoveSubnetIds"
                , TransitGatewaySubnetIdList.to_query v.remove_subnet_ids ))
         ; Some
             (Aws.Query.Pair
                ("AddSubnetIds", TransitGatewaySubnetIdList.to_query v.add_subnet_ids))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayAttachmentId"
                , String.to_query v.transit_gateway_attachment_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.options (fun f ->
               "Options", ModifyTransitGatewayVpcAttachmentRequestOptions.to_json f)
         ; Some ("RemoveSubnetIds", TransitGatewaySubnetIdList.to_json v.remove_subnet_ids)
         ; Some ("AddSubnetIds", TransitGatewaySubnetIdList.to_json v.add_subnet_ids)
         ; Some
             ("TransitGatewayAttachmentId", String.to_json v.transit_gateway_attachment_id)
         ])

  let of_json j =
    { transit_gateway_attachment_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayAttachmentId"))
    ; add_subnet_ids =
        TransitGatewaySubnetIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AddSubnetIds"))
    ; remove_subnet_ids =
        TransitGatewaySubnetIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "RemoveSubnetIds"))
    ; options =
        Aws.Util.option_map
          (Aws.Json.lookup j "Options")
          ModifyTransitGatewayVpcAttachmentRequestOptions.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module ConfirmProductInstanceResult = struct
  type t =
    { owner_id : String.t option
    ; return : Boolean.t option
    }

  let make ?owner_id ?return () = { owner_id; return }

  let parse xml =
    Some
      { owner_id = Aws.Util.option_bind (Aws.Xml.member "ownerId" xml) String.parse
      ; return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ; Aws.Util.option_map v.owner_id (fun f ->
               Aws.Query.Pair ("OwnerId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f)
         ; Aws.Util.option_map v.owner_id (fun f -> "ownerId", String.to_json f)
         ])

  let of_json j =
    { owner_id = Aws.Util.option_map (Aws.Json.lookup j "ownerId") String.of_json
    ; return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json
    }
end

module ProvisionByoipCidrRequest = struct
  type t =
    { cidr : String.t
    ; cidr_authorization_context : CidrAuthorizationContext.t option
    ; publicly_advertisable : Boolean.t option
    ; description : String.t option
    ; dry_run : Boolean.t option
    ; pool_tag_specifications : TagSpecificationList.t
    }

  let make
      ~cidr
      ?cidr_authorization_context
      ?publicly_advertisable
      ?description
      ?dry_run
      ?(pool_tag_specifications = [])
      () =
    { cidr
    ; cidr_authorization_context
    ; publicly_advertisable
    ; description
    ; dry_run
    ; pool_tag_specifications
    }

  let parse xml =
    Some
      { cidr =
          Aws.Xml.required
            "Cidr"
            (Aws.Util.option_bind (Aws.Xml.member "Cidr" xml) String.parse)
      ; cidr_authorization_context =
          Aws.Util.option_bind
            (Aws.Xml.member "CidrAuthorizationContext" xml)
            CidrAuthorizationContext.parse
      ; publicly_advertisable =
          Aws.Util.option_bind (Aws.Xml.member "PubliclyAdvertisable" xml) Boolean.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; pool_tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "PoolTagSpecification" xml)
               TagSpecificationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "PoolTagSpecification"
                , TagSpecificationList.to_query v.pool_tag_specifications ))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.publicly_advertisable (fun f ->
               Aws.Query.Pair ("PubliclyAdvertisable", Boolean.to_query f))
         ; Aws.Util.option_map v.cidr_authorization_context (fun f ->
               Aws.Query.Pair
                 ("CidrAuthorizationContext", CidrAuthorizationContext.to_query f))
         ; Some (Aws.Query.Pair ("Cidr", String.to_query v.cidr))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "PoolTagSpecification"
             , TagSpecificationList.to_json v.pool_tag_specifications )
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.publicly_advertisable (fun f ->
               "PubliclyAdvertisable", Boolean.to_json f)
         ; Aws.Util.option_map v.cidr_authorization_context (fun f ->
               "CidrAuthorizationContext", CidrAuthorizationContext.to_json f)
         ; Some ("Cidr", String.to_json v.cidr)
         ])

  let of_json j =
    { cidr = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Cidr"))
    ; cidr_authorization_context =
        Aws.Util.option_map
          (Aws.Json.lookup j "CidrAuthorizationContext")
          CidrAuthorizationContext.of_json
    ; publicly_advertisable =
        Aws.Util.option_map (Aws.Json.lookup j "PubliclyAdvertisable") Boolean.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; pool_tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "PoolTagSpecification"))
    }
end

module SummaryStatus = struct
  type t =
    | Ok
    | Impaired
    | Insufficient_data
    | Not_applicable
    | Initializing

  let str_to_t =
    [ "initializing", Initializing
    ; "not-applicable", Not_applicable
    ; "insufficient-data", Insufficient_data
    ; "impaired", Impaired
    ; "ok", Ok
    ]

  let t_to_str =
    [ Initializing, "initializing"
    ; Not_applicable, "not-applicable"
    ; Insufficient_data, "insufficient-data"
    ; Impaired, "impaired"
    ; Ok, "ok"
    ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module InstanceStatusSummary = struct
  type t =
    { details : InstanceStatusDetailsList.t
    ; status : SummaryStatus.t
    }

  let make ?(details = []) ~status () = { details; status }

  let parse xml =
    Some
      { details =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "details" xml)
               InstanceStatusDetailsList.parse)
      ; status =
          Aws.Xml.required
            "status"
            (Aws.Util.option_bind (Aws.Xml.member "status" xml) SummaryStatus.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Status", SummaryStatus.to_query v.status))
         ; Some (Aws.Query.Pair ("Details", InstanceStatusDetailsList.to_query v.details))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("status", SummaryStatus.to_json v.status)
         ; Some ("details", InstanceStatusDetailsList.to_json v.details)
         ])

  let of_json j =
    { details =
        InstanceStatusDetailsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "details"))
    ; status = SummaryStatus.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "status"))
    }
end

module CreateDhcpOptionsResult = struct
  type t = { dhcp_options : DhcpOptions.t option }

  let make ?dhcp_options () = { dhcp_options }

  let parse xml =
    Some
      { dhcp_options =
          Aws.Util.option_bind (Aws.Xml.member "dhcpOptions" xml) DhcpOptions.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dhcp_options (fun f ->
               Aws.Query.Pair ("DhcpOptions", DhcpOptions.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dhcp_options (fun f ->
               "dhcpOptions", DhcpOptions.to_json f)
         ])

  let of_json j =
    { dhcp_options =
        Aws.Util.option_map (Aws.Json.lookup j "dhcpOptions") DhcpOptions.of_json
    }
end

module ModifyCapacityReservationRequest = struct
  type t =
    { capacity_reservation_id : String.t
    ; instance_count : Integer.t option
    ; end_date : DateTime.t option
    ; end_date_type : EndDateType.t option
    ; dry_run : Boolean.t option
    }

  let make ~capacity_reservation_id ?instance_count ?end_date ?end_date_type ?dry_run () =
    { capacity_reservation_id; instance_count; end_date; end_date_type; dry_run }

  let parse xml =
    Some
      { capacity_reservation_id =
          Aws.Xml.required
            "CapacityReservationId"
            (Aws.Util.option_bind
               (Aws.Xml.member "CapacityReservationId" xml)
               String.parse)
      ; instance_count =
          Aws.Util.option_bind (Aws.Xml.member "InstanceCount" xml) Integer.parse
      ; end_date = Aws.Util.option_bind (Aws.Xml.member "EndDate" xml) DateTime.parse
      ; end_date_type =
          Aws.Util.option_bind (Aws.Xml.member "EndDateType" xml) EndDateType.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.end_date_type (fun f ->
               Aws.Query.Pair ("EndDateType", EndDateType.to_query f))
         ; Aws.Util.option_map v.end_date (fun f ->
               Aws.Query.Pair ("EndDate", DateTime.to_query f))
         ; Aws.Util.option_map v.instance_count (fun f ->
               Aws.Query.Pair ("InstanceCount", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("CapacityReservationId", String.to_query v.capacity_reservation_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.end_date_type (fun f ->
               "EndDateType", EndDateType.to_json f)
         ; Aws.Util.option_map v.end_date (fun f -> "EndDate", DateTime.to_json f)
         ; Aws.Util.option_map v.instance_count (fun f ->
               "InstanceCount", Integer.to_json f)
         ; Some ("CapacityReservationId", String.to_json v.capacity_reservation_id)
         ])

  let of_json j =
    { capacity_reservation_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "CapacityReservationId"))
    ; instance_count =
        Aws.Util.option_map (Aws.Json.lookup j "InstanceCount") Integer.of_json
    ; end_date = Aws.Util.option_map (Aws.Json.lookup j "EndDate") DateTime.of_json
    ; end_date_type =
        Aws.Util.option_map (Aws.Json.lookup j "EndDateType") EndDateType.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module AllocateHostsRequest = struct
  type t =
    { auto_placement : AutoPlacement.t option
    ; availability_zone : String.t
    ; client_token : String.t option
    ; instance_type : String.t option
    ; instance_family : String.t option
    ; quantity : Integer.t
    ; tag_specifications : TagSpecificationList.t
    ; host_recovery : HostRecovery.t option
    }

  let make
      ?auto_placement
      ~availability_zone
      ?client_token
      ?instance_type
      ?instance_family
      ~quantity
      ?(tag_specifications = [])
      ?host_recovery
      () =
    { auto_placement
    ; availability_zone
    ; client_token
    ; instance_type
    ; instance_family
    ; quantity
    ; tag_specifications
    ; host_recovery
    }

  let parse xml =
    Some
      { auto_placement =
          Aws.Util.option_bind (Aws.Xml.member "autoPlacement" xml) AutoPlacement.parse
      ; availability_zone =
          Aws.Xml.required
            "availabilityZone"
            (Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse)
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "clientToken" xml) String.parse
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) String.parse
      ; instance_family =
          Aws.Util.option_bind (Aws.Xml.member "InstanceFamily" xml) String.parse
      ; quantity =
          Aws.Xml.required
            "quantity"
            (Aws.Util.option_bind (Aws.Xml.member "quantity" xml) Integer.parse)
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      ; host_recovery =
          Aws.Util.option_bind (Aws.Xml.member "HostRecovery" xml) HostRecovery.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.host_recovery (fun f ->
               Aws.Query.Pair ("HostRecovery", HostRecovery.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Some (Aws.Query.Pair ("Quantity", Integer.to_query v.quantity))
         ; Aws.Util.option_map v.instance_family (fun f ->
               Aws.Query.Pair ("InstanceFamily", String.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", String.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Some (Aws.Query.Pair ("AvailabilityZone", String.to_query v.availability_zone))
         ; Aws.Util.option_map v.auto_placement (fun f ->
               Aws.Query.Pair ("AutoPlacement", AutoPlacement.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.host_recovery (fun f ->
               "HostRecovery", HostRecovery.to_json f)
         ; Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Some ("quantity", Integer.to_json v.quantity)
         ; Aws.Util.option_map v.instance_family (fun f ->
               "InstanceFamily", String.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f -> "instanceType", String.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "clientToken", String.to_json f)
         ; Some ("availabilityZone", String.to_json v.availability_zone)
         ; Aws.Util.option_map v.auto_placement (fun f ->
               "autoPlacement", AutoPlacement.to_json f)
         ])

  let of_json j =
    { auto_placement =
        Aws.Util.option_map (Aws.Json.lookup j "autoPlacement") AutoPlacement.of_json
    ; availability_zone =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "availabilityZone"))
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "clientToken") String.of_json
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") String.of_json
    ; instance_family =
        Aws.Util.option_map (Aws.Json.lookup j "InstanceFamily") String.of_json
    ; quantity = Integer.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "quantity"))
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    ; host_recovery =
        Aws.Util.option_map (Aws.Json.lookup j "HostRecovery") HostRecovery.of_json
    }
end

module Ipv6CidrAssociationSet = struct
  type t = Ipv6CidrAssociation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map Ipv6CidrAssociation.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Ipv6CidrAssociation.to_query v

  let to_json v = `List (List.map Ipv6CidrAssociation.to_json v)

  let of_json j = Aws.Json.to_list Ipv6CidrAssociation.of_json j
end

module GetAssociatedIpv6PoolCidrsResult = struct
  type t =
    { ipv6_cidr_associations : Ipv6CidrAssociationSet.t
    ; next_token : String.t option
    }

  let make ?(ipv6_cidr_associations = []) ?next_token () =
    { ipv6_cidr_associations; next_token }

  let parse xml =
    Some
      { ipv6_cidr_associations =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ipv6CidrAssociationSet" xml)
               Ipv6CidrAssociationSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "Ipv6CidrAssociationSet"
                , Ipv6CidrAssociationSet.to_query v.ipv6_cidr_associations ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "ipv6CidrAssociationSet"
             , Ipv6CidrAssociationSet.to_json v.ipv6_cidr_associations )
         ])

  let of_json j =
    { ipv6_cidr_associations =
        Ipv6CidrAssociationSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ipv6CidrAssociationSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DeleteClientVpnEndpointRequest = struct
  type t =
    { client_vpn_endpoint_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~client_vpn_endpoint_id ?dry_run () = { client_vpn_endpoint_id; dry_run }

  let parse xml =
    Some
      { client_vpn_endpoint_id =
          Aws.Xml.required
            "ClientVpnEndpointId"
            (Aws.Util.option_bind (Aws.Xml.member "ClientVpnEndpointId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ClientVpnEndpointId", String.to_query v.client_vpn_endpoint_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("ClientVpnEndpointId", String.to_json v.client_vpn_endpoint_id)
         ])

  let of_json j =
    { client_vpn_endpoint_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ClientVpnEndpointId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module ExportImageResult = struct
  type t =
    { description : String.t option
    ; disk_image_format : DiskImageFormat.t option
    ; export_image_task_id : String.t option
    ; image_id : String.t option
    ; role_name : String.t option
    ; progress : String.t option
    ; s3_export_location : ExportTaskS3Location.t option
    ; status : String.t option
    ; status_message : String.t option
    ; tags : TagList.t
    }

  let make
      ?description
      ?disk_image_format
      ?export_image_task_id
      ?image_id
      ?role_name
      ?progress
      ?s3_export_location
      ?status
      ?status_message
      ?(tags = [])
      () =
    { description
    ; disk_image_format
    ; export_image_task_id
    ; image_id
    ; role_name
    ; progress
    ; s3_export_location
    ; status
    ; status_message
    ; tags
    }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; disk_image_format =
          Aws.Util.option_bind
            (Aws.Xml.member "diskImageFormat" xml)
            DiskImageFormat.parse
      ; export_image_task_id =
          Aws.Util.option_bind (Aws.Xml.member "exportImageTaskId" xml) String.parse
      ; image_id = Aws.Util.option_bind (Aws.Xml.member "imageId" xml) String.parse
      ; role_name = Aws.Util.option_bind (Aws.Xml.member "roleName" xml) String.parse
      ; progress = Aws.Util.option_bind (Aws.Xml.member "progress" xml) String.parse
      ; s3_export_location =
          Aws.Util.option_bind
            (Aws.Xml.member "s3ExportLocation" xml)
            ExportTaskS3Location.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "status" xml) String.parse
      ; status_message =
          Aws.Util.option_bind (Aws.Xml.member "statusMessage" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.status_message (fun f ->
               Aws.Query.Pair ("StatusMessage", String.to_query f))
         ; Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", String.to_query f))
         ; Aws.Util.option_map v.s3_export_location (fun f ->
               Aws.Query.Pair ("S3ExportLocation", ExportTaskS3Location.to_query f))
         ; Aws.Util.option_map v.progress (fun f ->
               Aws.Query.Pair ("Progress", String.to_query f))
         ; Aws.Util.option_map v.role_name (fun f ->
               Aws.Query.Pair ("RoleName", String.to_query f))
         ; Aws.Util.option_map v.image_id (fun f ->
               Aws.Query.Pair ("ImageId", String.to_query f))
         ; Aws.Util.option_map v.export_image_task_id (fun f ->
               Aws.Query.Pair ("ExportImageTaskId", String.to_query f))
         ; Aws.Util.option_map v.disk_image_format (fun f ->
               Aws.Query.Pair ("DiskImageFormat", DiskImageFormat.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.status_message (fun f ->
               "statusMessage", String.to_json f)
         ; Aws.Util.option_map v.status (fun f -> "status", String.to_json f)
         ; Aws.Util.option_map v.s3_export_location (fun f ->
               "s3ExportLocation", ExportTaskS3Location.to_json f)
         ; Aws.Util.option_map v.progress (fun f -> "progress", String.to_json f)
         ; Aws.Util.option_map v.role_name (fun f -> "roleName", String.to_json f)
         ; Aws.Util.option_map v.image_id (fun f -> "imageId", String.to_json f)
         ; Aws.Util.option_map v.export_image_task_id (fun f ->
               "exportImageTaskId", String.to_json f)
         ; Aws.Util.option_map v.disk_image_format (fun f ->
               "diskImageFormat", DiskImageFormat.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; disk_image_format =
        Aws.Util.option_map (Aws.Json.lookup j "diskImageFormat") DiskImageFormat.of_json
    ; export_image_task_id =
        Aws.Util.option_map (Aws.Json.lookup j "exportImageTaskId") String.of_json
    ; image_id = Aws.Util.option_map (Aws.Json.lookup j "imageId") String.of_json
    ; role_name = Aws.Util.option_map (Aws.Json.lookup j "roleName") String.of_json
    ; progress = Aws.Util.option_map (Aws.Json.lookup j "progress") String.of_json
    ; s3_export_location =
        Aws.Util.option_map
          (Aws.Json.lookup j "s3ExportLocation")
          ExportTaskS3Location.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "status") String.of_json
    ; status_message =
        Aws.Util.option_map (Aws.Json.lookup j "statusMessage") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module CreateVpnConnectionRequest = struct
  type t =
    { customer_gateway_id : String.t
    ; type_ : String.t
    ; vpn_gateway_id : String.t option
    ; transit_gateway_id : String.t option
    ; dry_run : Boolean.t option
    ; options : VpnConnectionOptionsSpecification.t option
    ; tag_specifications : TagSpecificationList.t
    }

  let make
      ~customer_gateway_id
      ~type_
      ?vpn_gateway_id
      ?transit_gateway_id
      ?dry_run
      ?options
      ?(tag_specifications = [])
      () =
    { customer_gateway_id
    ; type_
    ; vpn_gateway_id
    ; transit_gateway_id
    ; dry_run
    ; options
    ; tag_specifications
    }

  let parse xml =
    Some
      { customer_gateway_id =
          Aws.Xml.required
            "CustomerGatewayId"
            (Aws.Util.option_bind (Aws.Xml.member "CustomerGatewayId" xml) String.parse)
      ; type_ =
          Aws.Xml.required
            "Type"
            (Aws.Util.option_bind (Aws.Xml.member "Type" xml) String.parse)
      ; vpn_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "VpnGatewayId" xml) String.parse
      ; transit_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "TransitGatewayId" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; options =
          Aws.Util.option_bind
            (Aws.Xml.member "options" xml)
            VpnConnectionOptionsSpecification.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Aws.Util.option_map v.options (fun f ->
               Aws.Query.Pair ("Options", VpnConnectionOptionsSpecification.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.transit_gateway_id (fun f ->
               Aws.Query.Pair ("TransitGatewayId", String.to_query f))
         ; Aws.Util.option_map v.vpn_gateway_id (fun f ->
               Aws.Query.Pair ("VpnGatewayId", String.to_query f))
         ; Some (Aws.Query.Pair ("Type", String.to_query v.type_))
         ; Some
             (Aws.Query.Pair ("CustomerGatewayId", String.to_query v.customer_gateway_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Aws.Util.option_map v.options (fun f ->
               "options", VpnConnectionOptionsSpecification.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.transit_gateway_id (fun f ->
               "TransitGatewayId", String.to_json f)
         ; Aws.Util.option_map v.vpn_gateway_id (fun f ->
               "VpnGatewayId", String.to_json f)
         ; Some ("Type", String.to_json v.type_)
         ; Some ("CustomerGatewayId", String.to_json v.customer_gateway_id)
         ])

  let of_json j =
    { customer_gateway_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "CustomerGatewayId"))
    ; type_ = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Type"))
    ; vpn_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "VpnGatewayId") String.of_json
    ; transit_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "TransitGatewayId") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; options =
        Aws.Util.option_map
          (Aws.Json.lookup j "options")
          VpnConnectionOptionsSpecification.of_json
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    }
end

module PriceScheduleSpecification = struct
  type t =
    { currency_code : CurrencyCodeValues.t option
    ; price : Double.t option
    ; term : Long.t option
    }

  let make ?currency_code ?price ?term () = { currency_code; price; term }

  let parse xml =
    Some
      { currency_code =
          Aws.Util.option_bind
            (Aws.Xml.member "currencyCode" xml)
            CurrencyCodeValues.parse
      ; price = Aws.Util.option_bind (Aws.Xml.member "price" xml) Double.parse
      ; term = Aws.Util.option_bind (Aws.Xml.member "term" xml) Long.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.term (fun f -> Aws.Query.Pair ("Term", Long.to_query f))
         ; Aws.Util.option_map v.price (fun f ->
               Aws.Query.Pair ("Price", Double.to_query f))
         ; Aws.Util.option_map v.currency_code (fun f ->
               Aws.Query.Pair ("CurrencyCode", CurrencyCodeValues.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.term (fun f -> "term", Long.to_json f)
         ; Aws.Util.option_map v.price (fun f -> "price", Double.to_json f)
         ; Aws.Util.option_map v.currency_code (fun f ->
               "currencyCode", CurrencyCodeValues.to_json f)
         ])

  let of_json j =
    { currency_code =
        Aws.Util.option_map (Aws.Json.lookup j "currencyCode") CurrencyCodeValues.of_json
    ; price = Aws.Util.option_map (Aws.Json.lookup j "price") Double.of_json
    ; term = Aws.Util.option_map (Aws.Json.lookup j "term") Long.of_json
    }
end

module DescribeRegionsResult = struct
  type t = { regions : RegionList.t }

  let make ?(regions = []) () = { regions }

  let parse xml =
    Some
      { regions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "regionInfo" xml) RegionList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("RegionInfo", RegionList.to_query v.regions)) ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt [ Some ("regionInfo", RegionList.to_json v.regions) ])

  let of_json j =
    { regions =
        RegionList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "regionInfo"))
    }
end

module DeleteTransitGatewayPeeringAttachmentResult = struct
  type t =
    { transit_gateway_peering_attachment : TransitGatewayPeeringAttachment.t option }

  let make ?transit_gateway_peering_attachment () = { transit_gateway_peering_attachment }

  let parse xml =
    Some
      { transit_gateway_peering_attachment =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayPeeringAttachment" xml)
            TransitGatewayPeeringAttachment.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_peering_attachment (fun f ->
               Aws.Query.Pair
                 ( "TransitGatewayPeeringAttachment"
                 , TransitGatewayPeeringAttachment.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_peering_attachment (fun f ->
               ( "transitGatewayPeeringAttachment"
               , TransitGatewayPeeringAttachment.to_json f ))
         ])

  let of_json j =
    { transit_gateway_peering_attachment =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayPeeringAttachment")
          TransitGatewayPeeringAttachment.of_json
    }
end

module ModifyVpnTunnelOptionsResult = struct
  type t = { vpn_connection : VpnConnection.t option }

  let make ?vpn_connection () = { vpn_connection }

  let parse xml =
    Some
      { vpn_connection =
          Aws.Util.option_bind (Aws.Xml.member "vpnConnection" xml) VpnConnection.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpn_connection (fun f ->
               Aws.Query.Pair ("VpnConnection", VpnConnection.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpn_connection (fun f ->
               "vpnConnection", VpnConnection.to_json f)
         ])

  let of_json j =
    { vpn_connection =
        Aws.Util.option_map (Aws.Json.lookup j "vpnConnection") VpnConnection.of_json
    }
end

module EnableVpcClassicLinkDnsSupportRequest = struct
  type t = { vpc_id : String.t option }

  let make ?vpc_id () = { vpc_id }

  let parse xml =
    Some { vpc_id = Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_id (fun f -> "VpcId", String.to_json f) ])

  let of_json j =
    { vpc_id = Aws.Util.option_map (Aws.Json.lookup j "VpcId") String.of_json }
end

module PlacementGroupIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "GroupId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeVpcClassicLinkRequest = struct
  type t =
    { filters : FilterList.t
    ; dry_run : Boolean.t option
    ; vpc_ids : VpcClassicLinkIdList.t
    }

  let make ?(filters = []) ?dry_run ?(vpc_ids = []) () = { filters; dry_run; vpc_ids }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; vpc_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) VpcClassicLinkIdList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("VpcId", VpcClassicLinkIdList.to_query v.vpc_ids))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("VpcId", VpcClassicLinkIdList.to_json v.vpc_ids)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; vpc_ids =
        VpcClassicLinkIdList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcId"))
    }
end

module ReservedInstancesIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map String.parse (Aws.Xml.members "ReservedInstancesId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeReservedInstancesRequest = struct
  type t =
    { filters : FilterList.t
    ; offering_class : OfferingClassType.t option
    ; reserved_instances_ids : ReservedInstancesIdStringList.t
    ; dry_run : Boolean.t option
    ; offering_type : OfferingTypeValues.t option
    }

  let make
      ?(filters = [])
      ?offering_class
      ?(reserved_instances_ids = [])
      ?dry_run
      ?offering_type
      () =
    { filters; offering_class; reserved_instances_ids; dry_run; offering_type }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; offering_class =
          Aws.Util.option_bind
            (Aws.Xml.member "OfferingClass" xml)
            OfferingClassType.parse
      ; reserved_instances_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ReservedInstancesId" xml)
               ReservedInstancesIdStringList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; offering_type =
          Aws.Util.option_bind
            (Aws.Xml.member "offeringType" xml)
            OfferingTypeValues.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.offering_type (fun f ->
               Aws.Query.Pair ("OfferingType", OfferingTypeValues.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ReservedInstancesId"
                , ReservedInstancesIdStringList.to_query v.reserved_instances_ids ))
         ; Aws.Util.option_map v.offering_class (fun f ->
               Aws.Query.Pair ("OfferingClass", OfferingClassType.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.offering_type (fun f ->
               "offeringType", OfferingTypeValues.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some
             ( "ReservedInstancesId"
             , ReservedInstancesIdStringList.to_json v.reserved_instances_ids )
         ; Aws.Util.option_map v.offering_class (fun f ->
               "OfferingClass", OfferingClassType.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; offering_class =
        Aws.Util.option_map (Aws.Json.lookup j "OfferingClass") OfferingClassType.of_json
    ; reserved_instances_ids =
        ReservedInstancesIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ReservedInstancesId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; offering_type =
        Aws.Util.option_map (Aws.Json.lookup j "offeringType") OfferingTypeValues.of_json
    }
end

module DescribeLocalGatewayRouteTablesResult = struct
  type t =
    { local_gateway_route_tables : LocalGatewayRouteTableSet.t
    ; next_token : String.t option
    }

  let make ?(local_gateway_route_tables = []) ?next_token () =
    { local_gateway_route_tables; next_token }

  let parse xml =
    Some
      { local_gateway_route_tables =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "localGatewayRouteTableSet" xml)
               LocalGatewayRouteTableSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "LocalGatewayRouteTableSet"
                , LocalGatewayRouteTableSet.to_query v.local_gateway_route_tables ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "localGatewayRouteTableSet"
             , LocalGatewayRouteTableSet.to_json v.local_gateway_route_tables )
         ])

  let of_json j =
    { local_gateway_route_tables =
        LocalGatewayRouteTableSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "localGatewayRouteTableSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DescribeVolumesModificationsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; volume_ids : VolumeIdStringList.t
    ; filters : FilterList.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    }

  let make ?dry_run ?(volume_ids = []) ?(filters = []) ?next_token ?max_results () =
    { dry_run; volume_ids; filters; next_token; max_results }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; volume_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "VolumeId" xml)
               VolumeIdStringList.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some (Aws.Query.Pair ("VolumeId", VolumeIdStringList.to_query v.volume_ids))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some ("VolumeId", VolumeIdStringList.to_json v.volume_ids)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; volume_ids =
        VolumeIdStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VolumeId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module CreateTrafficMirrorFilterRuleRequest = struct
  type t =
    { traffic_mirror_filter_id : String.t
    ; traffic_direction : TrafficDirection.t
    ; rule_number : Integer.t
    ; rule_action : TrafficMirrorRuleAction.t
    ; destination_port_range : TrafficMirrorPortRangeRequest.t option
    ; source_port_range : TrafficMirrorPortRangeRequest.t option
    ; protocol : Integer.t option
    ; destination_cidr_block : String.t
    ; source_cidr_block : String.t
    ; description : String.t option
    ; dry_run : Boolean.t option
    ; client_token : String.t option
    }

  let make
      ~traffic_mirror_filter_id
      ~traffic_direction
      ~rule_number
      ~rule_action
      ?destination_port_range
      ?source_port_range
      ?protocol
      ~destination_cidr_block
      ~source_cidr_block
      ?description
      ?dry_run
      ?client_token
      () =
    { traffic_mirror_filter_id
    ; traffic_direction
    ; rule_number
    ; rule_action
    ; destination_port_range
    ; source_port_range
    ; protocol
    ; destination_cidr_block
    ; source_cidr_block
    ; description
    ; dry_run
    ; client_token
    }

  let parse xml =
    Some
      { traffic_mirror_filter_id =
          Aws.Xml.required
            "TrafficMirrorFilterId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TrafficMirrorFilterId" xml)
               String.parse)
      ; traffic_direction =
          Aws.Xml.required
            "TrafficDirection"
            (Aws.Util.option_bind
               (Aws.Xml.member "TrafficDirection" xml)
               TrafficDirection.parse)
      ; rule_number =
          Aws.Xml.required
            "RuleNumber"
            (Aws.Util.option_bind (Aws.Xml.member "RuleNumber" xml) Integer.parse)
      ; rule_action =
          Aws.Xml.required
            "RuleAction"
            (Aws.Util.option_bind
               (Aws.Xml.member "RuleAction" xml)
               TrafficMirrorRuleAction.parse)
      ; destination_port_range =
          Aws.Util.option_bind
            (Aws.Xml.member "DestinationPortRange" xml)
            TrafficMirrorPortRangeRequest.parse
      ; source_port_range =
          Aws.Util.option_bind
            (Aws.Xml.member "SourcePortRange" xml)
            TrafficMirrorPortRangeRequest.parse
      ; protocol = Aws.Util.option_bind (Aws.Xml.member "Protocol" xml) Integer.parse
      ; destination_cidr_block =
          Aws.Xml.required
            "DestinationCidrBlock"
            (Aws.Util.option_bind
               (Aws.Xml.member "DestinationCidrBlock" xml)
               String.parse)
      ; source_cidr_block =
          Aws.Xml.required
            "SourceCidrBlock"
            (Aws.Util.option_bind (Aws.Xml.member "SourceCidrBlock" xml) String.parse)
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Some (Aws.Query.Pair ("SourceCidrBlock", String.to_query v.source_cidr_block))
         ; Some
             (Aws.Query.Pair
                ("DestinationCidrBlock", String.to_query v.destination_cidr_block))
         ; Aws.Util.option_map v.protocol (fun f ->
               Aws.Query.Pair ("Protocol", Integer.to_query f))
         ; Aws.Util.option_map v.source_port_range (fun f ->
               Aws.Query.Pair ("SourcePortRange", TrafficMirrorPortRangeRequest.to_query f))
         ; Aws.Util.option_map v.destination_port_range (fun f ->
               Aws.Query.Pair
                 ("DestinationPortRange", TrafficMirrorPortRangeRequest.to_query f))
         ; Some
             (Aws.Query.Pair ("RuleAction", TrafficMirrorRuleAction.to_query v.rule_action))
         ; Some (Aws.Query.Pair ("RuleNumber", Integer.to_query v.rule_number))
         ; Some
             (Aws.Query.Pair
                ("TrafficDirection", TrafficDirection.to_query v.traffic_direction))
         ; Some
             (Aws.Query.Pair
                ("TrafficMirrorFilterId", String.to_query v.traffic_mirror_filter_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Some ("SourceCidrBlock", String.to_json v.source_cidr_block)
         ; Some ("DestinationCidrBlock", String.to_json v.destination_cidr_block)
         ; Aws.Util.option_map v.protocol (fun f -> "Protocol", Integer.to_json f)
         ; Aws.Util.option_map v.source_port_range (fun f ->
               "SourcePortRange", TrafficMirrorPortRangeRequest.to_json f)
         ; Aws.Util.option_map v.destination_port_range (fun f ->
               "DestinationPortRange", TrafficMirrorPortRangeRequest.to_json f)
         ; Some ("RuleAction", TrafficMirrorRuleAction.to_json v.rule_action)
         ; Some ("RuleNumber", Integer.to_json v.rule_number)
         ; Some ("TrafficDirection", TrafficDirection.to_json v.traffic_direction)
         ; Some ("TrafficMirrorFilterId", String.to_json v.traffic_mirror_filter_id)
         ])

  let of_json j =
    { traffic_mirror_filter_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TrafficMirrorFilterId"))
    ; traffic_direction =
        TrafficDirection.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TrafficDirection"))
    ; rule_number =
        Integer.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "RuleNumber"))
    ; rule_action =
        TrafficMirrorRuleAction.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "RuleAction"))
    ; destination_port_range =
        Aws.Util.option_map
          (Aws.Json.lookup j "DestinationPortRange")
          TrafficMirrorPortRangeRequest.of_json
    ; source_port_range =
        Aws.Util.option_map
          (Aws.Json.lookup j "SourcePortRange")
          TrafficMirrorPortRangeRequest.of_json
    ; protocol = Aws.Util.option_map (Aws.Json.lookup j "Protocol") Integer.of_json
    ; destination_cidr_block =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DestinationCidrBlock"))
    ; source_cidr_block =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceCidrBlock"))
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    }
end

module AttachNetworkInterfaceResult = struct
  type t =
    { attachment_id : String.t option
    ; network_card_index : Integer.t option
    }

  let make ?attachment_id ?network_card_index () = { attachment_id; network_card_index }

  let parse xml =
    Some
      { attachment_id =
          Aws.Util.option_bind (Aws.Xml.member "attachmentId" xml) String.parse
      ; network_card_index =
          Aws.Util.option_bind (Aws.Xml.member "networkCardIndex" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.network_card_index (fun f ->
               Aws.Query.Pair ("NetworkCardIndex", Integer.to_query f))
         ; Aws.Util.option_map v.attachment_id (fun f ->
               Aws.Query.Pair ("AttachmentId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.network_card_index (fun f ->
               "networkCardIndex", Integer.to_json f)
         ; Aws.Util.option_map v.attachment_id (fun f -> "attachmentId", String.to_json f)
         ])

  let of_json j =
    { attachment_id =
        Aws.Util.option_map (Aws.Json.lookup j "attachmentId") String.of_json
    ; network_card_index =
        Aws.Util.option_map (Aws.Json.lookup j "networkCardIndex") Integer.of_json
    }
end

module DescribeFleetInstancesResult = struct
  type t =
    { active_instances : ActiveInstanceSet.t
    ; next_token : String.t option
    ; fleet_id : String.t option
    }

  let make ?(active_instances = []) ?next_token ?fleet_id () =
    { active_instances; next_token; fleet_id }

  let parse xml =
    Some
      { active_instances =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "activeInstanceSet" xml)
               ActiveInstanceSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; fleet_id = Aws.Util.option_bind (Aws.Xml.member "fleetId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.fleet_id (fun f ->
               Aws.Query.Pair ("FleetId", String.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ActiveInstanceSet", ActiveInstanceSet.to_query v.active_instances))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.fleet_id (fun f -> "fleetId", String.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("activeInstanceSet", ActiveInstanceSet.to_json v.active_instances)
         ])

  let of_json j =
    { active_instances =
        ActiveInstanceSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "activeInstanceSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; fleet_id = Aws.Util.option_map (Aws.Json.lookup j "fleetId") String.of_json
    }
end

module DescribeClientVpnConnectionsResult = struct
  type t =
    { connections : ClientVpnConnectionSet.t
    ; next_token : String.t option
    }

  let make ?(connections = []) ?next_token () = { connections; next_token }

  let parse xml =
    Some
      { connections =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "connections" xml)
               ClientVpnConnectionSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair ("Connections", ClientVpnConnectionSet.to_query v.connections))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("connections", ClientVpnConnectionSet.to_json v.connections)
         ])

  let of_json j =
    { connections =
        ClientVpnConnectionSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "connections"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module EnableFastSnapshotRestoresRequest = struct
  type t =
    { availability_zones : AvailabilityZoneStringList.t
    ; source_snapshot_ids : SnapshotIdStringList.t
    ; dry_run : Boolean.t option
    }

  let make ~availability_zones ~source_snapshot_ids ?dry_run () =
    { availability_zones; source_snapshot_ids; dry_run }

  let parse xml =
    Some
      { availability_zones =
          Aws.Xml.required
            "AvailabilityZone"
            (Aws.Util.option_bind
               (Aws.Xml.member "AvailabilityZone" xml)
               AvailabilityZoneStringList.parse)
      ; source_snapshot_ids =
          Aws.Xml.required
            "SourceSnapshotId"
            (Aws.Util.option_bind
               (Aws.Xml.member "SourceSnapshotId" xml)
               SnapshotIdStringList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("SourceSnapshotId", SnapshotIdStringList.to_query v.source_snapshot_ids))
         ; Some
             (Aws.Query.Pair
                ( "AvailabilityZone"
                , AvailabilityZoneStringList.to_query v.availability_zones ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("SourceSnapshotId", SnapshotIdStringList.to_json v.source_snapshot_ids)
         ; Some
             ("AvailabilityZone", AvailabilityZoneStringList.to_json v.availability_zones)
         ])

  let of_json j =
    { availability_zones =
        AvailabilityZoneStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AvailabilityZone"))
    ; source_snapshot_ids =
        SnapshotIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceSnapshotId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module VolumeList = struct
  type t = Volume.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map Volume.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list Volume.to_query v

  let to_json v = `List (List.map Volume.to_json v)

  let of_json j = Aws.Json.to_list Volume.of_json j
end

module DescribeVolumesResult = struct
  type t =
    { volumes : VolumeList.t
    ; next_token : String.t option
    }

  let make ?(volumes = []) ?next_token () = { volumes; next_token }

  let parse xml =
    Some
      { volumes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "volumeSet" xml) VolumeList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("VolumeSet", VolumeList.to_query v.volumes))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("volumeSet", VolumeList.to_json v.volumes)
         ])

  let of_json j =
    { volumes =
        VolumeList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "volumeSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module ImportSnapshotResult = struct
  type t =
    { description : String.t option
    ; import_task_id : String.t option
    ; snapshot_task_detail : SnapshotTaskDetail.t option
    ; tags : TagList.t
    }

  let make ?description ?import_task_id ?snapshot_task_detail ?(tags = []) () =
    { description; import_task_id; snapshot_task_detail; tags }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; import_task_id =
          Aws.Util.option_bind (Aws.Xml.member "importTaskId" xml) String.parse
      ; snapshot_task_detail =
          Aws.Util.option_bind
            (Aws.Xml.member "snapshotTaskDetail" xml)
            SnapshotTaskDetail.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.snapshot_task_detail (fun f ->
               Aws.Query.Pair ("SnapshotTaskDetail", SnapshotTaskDetail.to_query f))
         ; Aws.Util.option_map v.import_task_id (fun f ->
               Aws.Query.Pair ("ImportTaskId", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.snapshot_task_detail (fun f ->
               "snapshotTaskDetail", SnapshotTaskDetail.to_json f)
         ; Aws.Util.option_map v.import_task_id (fun f ->
               "importTaskId", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; import_task_id =
        Aws.Util.option_map (Aws.Json.lookup j "importTaskId") String.of_json
    ; snapshot_task_detail =
        Aws.Util.option_map
          (Aws.Json.lookup j "snapshotTaskDetail")
          SnapshotTaskDetail.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module ReleaseAddressRequest = struct
  type t =
    { allocation_id : String.t option
    ; public_ip : String.t option
    ; network_border_group : String.t option
    ; dry_run : Boolean.t option
    }

  let make ?allocation_id ?public_ip ?network_border_group ?dry_run () =
    { allocation_id; public_ip; network_border_group; dry_run }

  let parse xml =
    Some
      { allocation_id =
          Aws.Util.option_bind (Aws.Xml.member "AllocationId" xml) String.parse
      ; public_ip = Aws.Util.option_bind (Aws.Xml.member "PublicIp" xml) String.parse
      ; network_border_group =
          Aws.Util.option_bind (Aws.Xml.member "NetworkBorderGroup" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.network_border_group (fun f ->
               Aws.Query.Pair ("NetworkBorderGroup", String.to_query f))
         ; Aws.Util.option_map v.public_ip (fun f ->
               Aws.Query.Pair ("PublicIp", String.to_query f))
         ; Aws.Util.option_map v.allocation_id (fun f ->
               Aws.Query.Pair ("AllocationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.network_border_group (fun f ->
               "NetworkBorderGroup", String.to_json f)
         ; Aws.Util.option_map v.public_ip (fun f -> "PublicIp", String.to_json f)
         ; Aws.Util.option_map v.allocation_id (fun f -> "AllocationId", String.to_json f)
         ])

  let of_json j =
    { allocation_id =
        Aws.Util.option_map (Aws.Json.lookup j "AllocationId") String.of_json
    ; public_ip = Aws.Util.option_map (Aws.Json.lookup j "PublicIp") String.of_json
    ; network_border_group =
        Aws.Util.option_map (Aws.Json.lookup j "NetworkBorderGroup") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module ModifyVolumeResult = struct
  type t = { volume_modification : VolumeModification.t option }

  let make ?volume_modification () = { volume_modification }

  let parse xml =
    Some
      { volume_modification =
          Aws.Util.option_bind
            (Aws.Xml.member "volumeModification" xml)
            VolumeModification.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.volume_modification (fun f ->
               Aws.Query.Pair ("VolumeModification", VolumeModification.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.volume_modification (fun f ->
               "volumeModification", VolumeModification.to_json f)
         ])

  let of_json j =
    { volume_modification =
        Aws.Util.option_map
          (Aws.Json.lookup j "volumeModification")
          VolumeModification.of_json
    }
end

module GroupNameStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "GroupName" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module ModifySnapshotAttributeRequest = struct
  type t =
    { attribute : SnapshotAttributeName.t option
    ; create_volume_permission : CreateVolumePermissionModifications.t option
    ; group_names : GroupNameStringList.t
    ; operation_type : OperationType.t option
    ; snapshot_id : String.t
    ; user_ids : UserIdStringList.t
    ; dry_run : Boolean.t option
    }

  let make
      ?attribute
      ?create_volume_permission
      ?(group_names = [])
      ?operation_type
      ~snapshot_id
      ?(user_ids = [])
      ?dry_run
      () =
    { attribute
    ; create_volume_permission
    ; group_names
    ; operation_type
    ; snapshot_id
    ; user_ids
    ; dry_run
    }

  let parse xml =
    Some
      { attribute =
          Aws.Util.option_bind
            (Aws.Xml.member "Attribute" xml)
            SnapshotAttributeName.parse
      ; create_volume_permission =
          Aws.Util.option_bind
            (Aws.Xml.member "CreateVolumePermission" xml)
            CreateVolumePermissionModifications.parse
      ; group_names =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "UserGroup" xml)
               GroupNameStringList.parse)
      ; operation_type =
          Aws.Util.option_bind (Aws.Xml.member "OperationType" xml) OperationType.parse
      ; snapshot_id =
          Aws.Xml.required
            "SnapshotId"
            (Aws.Util.option_bind (Aws.Xml.member "SnapshotId" xml) String.parse)
      ; user_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "UserId" xml) UserIdStringList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("UserId", UserIdStringList.to_query v.user_ids))
         ; Some (Aws.Query.Pair ("SnapshotId", String.to_query v.snapshot_id))
         ; Aws.Util.option_map v.operation_type (fun f ->
               Aws.Query.Pair ("OperationType", OperationType.to_query f))
         ; Some (Aws.Query.Pair ("UserGroup", GroupNameStringList.to_query v.group_names))
         ; Aws.Util.option_map v.create_volume_permission (fun f ->
               Aws.Query.Pair
                 ("CreateVolumePermission", CreateVolumePermissionModifications.to_query f))
         ; Aws.Util.option_map v.attribute (fun f ->
               Aws.Query.Pair ("Attribute", SnapshotAttributeName.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("UserId", UserIdStringList.to_json v.user_ids)
         ; Some ("SnapshotId", String.to_json v.snapshot_id)
         ; Aws.Util.option_map v.operation_type (fun f ->
               "OperationType", OperationType.to_json f)
         ; Some ("UserGroup", GroupNameStringList.to_json v.group_names)
         ; Aws.Util.option_map v.create_volume_permission (fun f ->
               "CreateVolumePermission", CreateVolumePermissionModifications.to_json f)
         ; Aws.Util.option_map v.attribute (fun f ->
               "Attribute", SnapshotAttributeName.to_json f)
         ])

  let of_json j =
    { attribute =
        Aws.Util.option_map (Aws.Json.lookup j "Attribute") SnapshotAttributeName.of_json
    ; create_volume_permission =
        Aws.Util.option_map
          (Aws.Json.lookup j "CreateVolumePermission")
          CreateVolumePermissionModifications.of_json
    ; group_names =
        GroupNameStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "UserGroup"))
    ; operation_type =
        Aws.Util.option_map (Aws.Json.lookup j "OperationType") OperationType.of_json
    ; snapshot_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SnapshotId"))
    ; user_ids =
        UserIdStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "UserId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module DescribeIamInstanceProfileAssociationsRequest = struct
  type t =
    { association_ids : AssociationIdList.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?(association_ids = []) ?(filters = []) ?max_results ?next_token () =
    { association_ids; filters; max_results; next_token }

  let parse xml =
    Some
      { association_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AssociationId" xml)
               AssociationIdList.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ("AssociationId", AssociationIdList.to_query v.association_ids))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some ("AssociationId", AssociationIdList.to_json v.association_ids)
         ])

  let of_json j =
    { association_ids =
        AssociationIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AssociationId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module CreateLocalGatewayRouteRequest = struct
  type t =
    { destination_cidr_block : String.t
    ; local_gateway_route_table_id : String.t
    ; local_gateway_virtual_interface_group_id : String.t
    ; dry_run : Boolean.t option
    }

  let make
      ~destination_cidr_block
      ~local_gateway_route_table_id
      ~local_gateway_virtual_interface_group_id
      ?dry_run
      () =
    { destination_cidr_block
    ; local_gateway_route_table_id
    ; local_gateway_virtual_interface_group_id
    ; dry_run
    }

  let parse xml =
    Some
      { destination_cidr_block =
          Aws.Xml.required
            "DestinationCidrBlock"
            (Aws.Util.option_bind
               (Aws.Xml.member "DestinationCidrBlock" xml)
               String.parse)
      ; local_gateway_route_table_id =
          Aws.Xml.required
            "LocalGatewayRouteTableId"
            (Aws.Util.option_bind
               (Aws.Xml.member "LocalGatewayRouteTableId" xml)
               String.parse)
      ; local_gateway_virtual_interface_group_id =
          Aws.Xml.required
            "LocalGatewayVirtualInterfaceGroupId"
            (Aws.Util.option_bind
               (Aws.Xml.member "LocalGatewayVirtualInterfaceGroupId" xml)
               String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "LocalGatewayVirtualInterfaceGroupId"
                , String.to_query v.local_gateway_virtual_interface_group_id ))
         ; Some
             (Aws.Query.Pair
                ( "LocalGatewayRouteTableId"
                , String.to_query v.local_gateway_route_table_id ))
         ; Some
             (Aws.Query.Pair
                ("DestinationCidrBlock", String.to_query v.destination_cidr_block))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ( "LocalGatewayVirtualInterfaceGroupId"
             , String.to_json v.local_gateway_virtual_interface_group_id )
         ; Some ("LocalGatewayRouteTableId", String.to_json v.local_gateway_route_table_id)
         ; Some ("DestinationCidrBlock", String.to_json v.destination_cidr_block)
         ])

  let of_json j =
    { destination_cidr_block =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DestinationCidrBlock"))
    ; local_gateway_route_table_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "LocalGatewayRouteTableId"))
    ; local_gateway_virtual_interface_group_id =
        String.of_json
          (Aws.Util.of_option_exn
             (Aws.Json.lookup j "LocalGatewayVirtualInterfaceGroupId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DescribeLocalGatewayRouteTableVpcAssociationsResult = struct
  type t =
    { local_gateway_route_table_vpc_associations :
        LocalGatewayRouteTableVpcAssociationSet.t
    ; next_token : String.t option
    }

  let make ?(local_gateway_route_table_vpc_associations = []) ?next_token () =
    { local_gateway_route_table_vpc_associations; next_token }

  let parse xml =
    Some
      { local_gateway_route_table_vpc_associations =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "localGatewayRouteTableVpcAssociationSet" xml)
               LocalGatewayRouteTableVpcAssociationSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "LocalGatewayRouteTableVpcAssociationSet"
                , LocalGatewayRouteTableVpcAssociationSet.to_query
                    v.local_gateway_route_table_vpc_associations ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "localGatewayRouteTableVpcAssociationSet"
             , LocalGatewayRouteTableVpcAssociationSet.to_json
                 v.local_gateway_route_table_vpc_associations )
         ])

  let of_json j =
    { local_gateway_route_table_vpc_associations =
        LocalGatewayRouteTableVpcAssociationSet.of_json
          (Aws.Util.of_option_exn
             (Aws.Json.lookup j "localGatewayRouteTableVpcAssociationSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module ModifyReservedInstancesResult = struct
  type t = { reserved_instances_modification_id : String.t option }

  let make ?reserved_instances_modification_id () = { reserved_instances_modification_id }

  let parse xml =
    Some
      { reserved_instances_modification_id =
          Aws.Util.option_bind
            (Aws.Xml.member "reservedInstancesModificationId" xml)
            String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.reserved_instances_modification_id (fun f ->
               Aws.Query.Pair ("ReservedInstancesModificationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.reserved_instances_modification_id (fun f ->
               "reservedInstancesModificationId", String.to_json f)
         ])

  let of_json j =
    { reserved_instances_modification_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "reservedInstancesModificationId")
          String.of_json
    }
end

module CreateCustomerGatewayResult = struct
  type t = { customer_gateway : CustomerGateway.t option }

  let make ?customer_gateway () = { customer_gateway }

  let parse xml =
    Some
      { customer_gateway =
          Aws.Util.option_bind
            (Aws.Xml.member "customerGateway" xml)
            CustomerGateway.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.customer_gateway (fun f ->
               Aws.Query.Pair ("CustomerGateway", CustomerGateway.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.customer_gateway (fun f ->
               "customerGateway", CustomerGateway.to_json f)
         ])

  let of_json j =
    { customer_gateway =
        Aws.Util.option_map (Aws.Json.lookup j "customerGateway") CustomerGateway.of_json
    }
end

module RegisterTransitGatewayMulticastGroupMembersResult = struct
  type t =
    { registered_multicast_group_members :
        TransitGatewayMulticastRegisteredGroupMembers.t option
    }

  let make ?registered_multicast_group_members () = { registered_multicast_group_members }

  let parse xml =
    Some
      { registered_multicast_group_members =
          Aws.Util.option_bind
            (Aws.Xml.member "registeredMulticastGroupMembers" xml)
            TransitGatewayMulticastRegisteredGroupMembers.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.registered_multicast_group_members (fun f ->
               Aws.Query.Pair
                 ( "RegisteredMulticastGroupMembers"
                 , TransitGatewayMulticastRegisteredGroupMembers.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.registered_multicast_group_members (fun f ->
               ( "registeredMulticastGroupMembers"
               , TransitGatewayMulticastRegisteredGroupMembers.to_json f ))
         ])

  let of_json j =
    { registered_multicast_group_members =
        Aws.Util.option_map
          (Aws.Json.lookup j "registeredMulticastGroupMembers")
          TransitGatewayMulticastRegisteredGroupMembers.of_json
    }
end

module ModifyInstanceEventStartTimeResult = struct
  type t = { event : InstanceStatusEvent.t option }

  let make ?event () = { event }

  let parse xml =
    Some
      { event =
          Aws.Util.option_bind (Aws.Xml.member "event" xml) InstanceStatusEvent.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.event (fun f ->
               Aws.Query.Pair ("Event", InstanceStatusEvent.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.event (fun f -> "event", InstanceStatusEvent.to_json f) ])

  let of_json j =
    { event = Aws.Util.option_map (Aws.Json.lookup j "event") InstanceStatusEvent.of_json
    }
end

module DeleteVpcPeeringConnectionRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; vpc_peering_connection_id : String.t
    }

  let make ?dry_run ~vpc_peering_connection_id () = { dry_run; vpc_peering_connection_id }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; vpc_peering_connection_id =
          Aws.Xml.required
            "vpcPeeringConnectionId"
            (Aws.Util.option_bind
               (Aws.Xml.member "vpcPeeringConnectionId" xml)
               String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("VpcPeeringConnectionId", String.to_query v.vpc_peering_connection_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("vpcPeeringConnectionId", String.to_json v.vpc_peering_connection_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; vpc_peering_connection_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "vpcPeeringConnectionId"))
    }
end

module DescribeIdentityIdFormatRequest = struct
  type t =
    { principal_arn : String.t
    ; resource : String.t option
    }

  let make ~principal_arn ?resource () = { principal_arn; resource }

  let parse xml =
    Some
      { principal_arn =
          Aws.Xml.required
            "principalArn"
            (Aws.Util.option_bind (Aws.Xml.member "principalArn" xml) String.parse)
      ; resource = Aws.Util.option_bind (Aws.Xml.member "resource" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.resource (fun f ->
               Aws.Query.Pair ("Resource", String.to_query f))
         ; Some (Aws.Query.Pair ("PrincipalArn", String.to_query v.principal_arn))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.resource (fun f -> "resource", String.to_json f)
         ; Some ("principalArn", String.to_json v.principal_arn)
         ])

  let of_json j =
    { principal_arn =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "principalArn"))
    ; resource = Aws.Util.option_map (Aws.Json.lookup j "resource") String.of_json
    }
end

module AssignPrivateIpAddressesResult = struct
  type t =
    { network_interface_id : String.t option
    ; assigned_private_ip_addresses : AssignedPrivateIpAddressList.t
    }

  let make ?network_interface_id ?(assigned_private_ip_addresses = []) () =
    { network_interface_id; assigned_private_ip_addresses }

  let parse xml =
    Some
      { network_interface_id =
          Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse
      ; assigned_private_ip_addresses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "assignedPrivateIpAddressesSet" xml)
               AssignedPrivateIpAddressList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "AssignedPrivateIpAddressesSet"
                , AssignedPrivateIpAddressList.to_query v.assigned_private_ip_addresses ))
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               Aws.Query.Pair ("NetworkInterfaceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "assignedPrivateIpAddressesSet"
             , AssignedPrivateIpAddressList.to_json v.assigned_private_ip_addresses )
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               "networkInterfaceId", String.to_json f)
         ])

  let of_json j =
    { network_interface_id =
        Aws.Util.option_map (Aws.Json.lookup j "networkInterfaceId") String.of_json
    ; assigned_private_ip_addresses =
        AssignedPrivateIpAddressList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "assignedPrivateIpAddressesSet"))
    }
end

module RestoreAddressToClassicRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; public_ip : String.t
    }

  let make ?dry_run ~public_ip () = { dry_run; public_ip }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; public_ip =
          Aws.Xml.required
            "publicIp"
            (Aws.Util.option_bind (Aws.Xml.member "publicIp" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("PublicIp", String.to_query v.public_ip))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("publicIp", String.to_json v.public_ip)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; public_ip = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "publicIp"))
    }
end

module ModifyVpcEndpointServicePermissionsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; service_id : String.t
    ; add_allowed_principals : ValueStringList.t
    ; remove_allowed_principals : ValueStringList.t
    }

  let make
      ?dry_run
      ~service_id
      ?(add_allowed_principals = [])
      ?(remove_allowed_principals = [])
      () =
    { dry_run; service_id; add_allowed_principals; remove_allowed_principals }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; service_id =
          Aws.Xml.required
            "ServiceId"
            (Aws.Util.option_bind (Aws.Xml.member "ServiceId" xml) String.parse)
      ; add_allowed_principals =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AddAllowedPrincipals" xml)
               ValueStringList.parse)
      ; remove_allowed_principals =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "RemoveAllowedPrincipals" xml)
               ValueStringList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "RemoveAllowedPrincipals"
                , ValueStringList.to_query v.remove_allowed_principals ))
         ; Some
             (Aws.Query.Pair
                ("AddAllowedPrincipals", ValueStringList.to_query v.add_allowed_principals))
         ; Some (Aws.Query.Pair ("ServiceId", String.to_query v.service_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "RemoveAllowedPrincipals"
             , ValueStringList.to_json v.remove_allowed_principals )
         ; Some ("AddAllowedPrincipals", ValueStringList.to_json v.add_allowed_principals)
         ; Some ("ServiceId", String.to_json v.service_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; service_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ServiceId"))
    ; add_allowed_principals =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AddAllowedPrincipals"))
    ; remove_allowed_principals =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "RemoveAllowedPrincipals"))
    }
end

module KeyPair = struct
  type t =
    { key_fingerprint : String.t
    ; key_material : String.t
    ; key_name : String.t
    ; key_pair_id : String.t option
    ; tags : TagList.t
    }

  let make ~key_fingerprint ~key_material ~key_name ?key_pair_id ?(tags = []) () =
    { key_fingerprint; key_material; key_name; key_pair_id; tags }

  let parse xml =
    Some
      { key_fingerprint =
          Aws.Xml.required
            "keyFingerprint"
            (Aws.Util.option_bind (Aws.Xml.member "keyFingerprint" xml) String.parse)
      ; key_material =
          Aws.Xml.required
            "keyMaterial"
            (Aws.Util.option_bind (Aws.Xml.member "keyMaterial" xml) String.parse)
      ; key_name =
          Aws.Xml.required
            "keyName"
            (Aws.Util.option_bind (Aws.Xml.member "keyName" xml) String.parse)
      ; key_pair_id = Aws.Util.option_bind (Aws.Xml.member "keyPairId" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.key_pair_id (fun f ->
               Aws.Query.Pair ("KeyPairId", String.to_query f))
         ; Some (Aws.Query.Pair ("KeyName", String.to_query v.key_name))
         ; Some (Aws.Query.Pair ("KeyMaterial", String.to_query v.key_material))
         ; Some (Aws.Query.Pair ("KeyFingerprint", String.to_query v.key_fingerprint))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.key_pair_id (fun f -> "keyPairId", String.to_json f)
         ; Some ("keyName", String.to_json v.key_name)
         ; Some ("keyMaterial", String.to_json v.key_material)
         ; Some ("keyFingerprint", String.to_json v.key_fingerprint)
         ])

  let of_json j =
    { key_fingerprint =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "keyFingerprint"))
    ; key_material =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "keyMaterial"))
    ; key_name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "keyName"))
    ; key_pair_id = Aws.Util.option_map (Aws.Json.lookup j "keyPairId") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module CreateVpnConnectionResult = struct
  type t = { vpn_connection : VpnConnection.t option }

  let make ?vpn_connection () = { vpn_connection }

  let parse xml =
    Some
      { vpn_connection =
          Aws.Util.option_bind (Aws.Xml.member "vpnConnection" xml) VpnConnection.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpn_connection (fun f ->
               Aws.Query.Pair ("VpnConnection", VpnConnection.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpn_connection (fun f ->
               "vpnConnection", VpnConnection.to_json f)
         ])

  let of_json j =
    { vpn_connection =
        Aws.Util.option_map (Aws.Json.lookup j "vpnConnection") VpnConnection.of_json
    }
end

module CreateTransitGatewayRouteTableRequest = struct
  type t =
    { transit_gateway_id : String.t
    ; tag_specifications : TagSpecificationList.t
    ; dry_run : Boolean.t option
    }

  let make ~transit_gateway_id ?(tag_specifications = []) ?dry_run () =
    { transit_gateway_id; tag_specifications; dry_run }

  let parse xml =
    Some
      { transit_gateway_id =
          Aws.Xml.required
            "TransitGatewayId"
            (Aws.Util.option_bind (Aws.Xml.member "TransitGatewayId" xml) String.parse)
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecifications" xml)
               TagSpecificationList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TagSpecifications", TagSpecificationList.to_query v.tag_specifications))
         ; Some
             (Aws.Query.Pair ("TransitGatewayId", String.to_query v.transit_gateway_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("TagSpecifications", TagSpecificationList.to_json v.tag_specifications)
         ; Some ("TransitGatewayId", String.to_json v.transit_gateway_id)
         ])

  let of_json j =
    { transit_gateway_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayId"))
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecifications"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module TrafficMirrorFilterSet = struct
  type t = TrafficMirrorFilter.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map TrafficMirrorFilter.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list TrafficMirrorFilter.to_query v

  let to_json v = `List (List.map TrafficMirrorFilter.to_json v)

  let of_json j = Aws.Json.to_list TrafficMirrorFilter.of_json j
end

module GetConsoleOutputRequest = struct
  type t =
    { instance_id : String.t
    ; dry_run : Boolean.t option
    ; latest : Boolean.t option
    }

  let make ~instance_id ?dry_run ?latest () = { instance_id; dry_run; latest }

  let parse xml =
    Some
      { instance_id =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; latest = Aws.Util.option_bind (Aws.Xml.member "Latest" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.latest (fun f ->
               Aws.Query.Pair ("Latest", Boolean.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.latest (fun f -> "Latest", Boolean.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("InstanceId", String.to_json v.instance_id)
         ])

  let of_json j =
    { instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; latest = Aws.Util.option_map (Aws.Json.lookup j "Latest") Boolean.of_json
    }
end

module ReplaceRouteRequest = struct
  type t =
    { destination_cidr_block : String.t option
    ; destination_ipv6_cidr_block : String.t option
    ; destination_prefix_list_id : String.t option
    ; dry_run : Boolean.t option
    ; vpc_endpoint_id : String.t option
    ; egress_only_internet_gateway_id : String.t option
    ; gateway_id : String.t option
    ; instance_id : String.t option
    ; local_target : Boolean.t option
    ; nat_gateway_id : String.t option
    ; transit_gateway_id : String.t option
    ; local_gateway_id : String.t option
    ; carrier_gateway_id : String.t option
    ; network_interface_id : String.t option
    ; route_table_id : String.t
    ; vpc_peering_connection_id : String.t option
    }

  let make
      ?destination_cidr_block
      ?destination_ipv6_cidr_block
      ?destination_prefix_list_id
      ?dry_run
      ?vpc_endpoint_id
      ?egress_only_internet_gateway_id
      ?gateway_id
      ?instance_id
      ?local_target
      ?nat_gateway_id
      ?transit_gateway_id
      ?local_gateway_id
      ?carrier_gateway_id
      ?network_interface_id
      ~route_table_id
      ?vpc_peering_connection_id
      () =
    { destination_cidr_block
    ; destination_ipv6_cidr_block
    ; destination_prefix_list_id
    ; dry_run
    ; vpc_endpoint_id
    ; egress_only_internet_gateway_id
    ; gateway_id
    ; instance_id
    ; local_target
    ; nat_gateway_id
    ; transit_gateway_id
    ; local_gateway_id
    ; carrier_gateway_id
    ; network_interface_id
    ; route_table_id
    ; vpc_peering_connection_id
    }

  let parse xml =
    Some
      { destination_cidr_block =
          Aws.Util.option_bind (Aws.Xml.member "destinationCidrBlock" xml) String.parse
      ; destination_ipv6_cidr_block =
          Aws.Util.option_bind
            (Aws.Xml.member "destinationIpv6CidrBlock" xml)
            String.parse
      ; destination_prefix_list_id =
          Aws.Util.option_bind (Aws.Xml.member "DestinationPrefixListId" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; vpc_endpoint_id =
          Aws.Util.option_bind (Aws.Xml.member "VpcEndpointId" xml) String.parse
      ; egress_only_internet_gateway_id =
          Aws.Util.option_bind
            (Aws.Xml.member "egressOnlyInternetGatewayId" xml)
            String.parse
      ; gateway_id = Aws.Util.option_bind (Aws.Xml.member "gatewayId" xml) String.parse
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      ; local_target =
          Aws.Util.option_bind (Aws.Xml.member "LocalTarget" xml) Boolean.parse
      ; nat_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "natGatewayId" xml) String.parse
      ; transit_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "TransitGatewayId" xml) String.parse
      ; local_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "LocalGatewayId" xml) String.parse
      ; carrier_gateway_id =
          Aws.Util.option_bind (Aws.Xml.member "CarrierGatewayId" xml) String.parse
      ; network_interface_id =
          Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse
      ; route_table_id =
          Aws.Xml.required
            "routeTableId"
            (Aws.Util.option_bind (Aws.Xml.member "routeTableId" xml) String.parse)
      ; vpc_peering_connection_id =
          Aws.Util.option_bind (Aws.Xml.member "vpcPeeringConnectionId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_peering_connection_id (fun f ->
               Aws.Query.Pair ("VpcPeeringConnectionId", String.to_query f))
         ; Some (Aws.Query.Pair ("RouteTableId", String.to_query v.route_table_id))
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               Aws.Query.Pair ("NetworkInterfaceId", String.to_query f))
         ; Aws.Util.option_map v.carrier_gateway_id (fun f ->
               Aws.Query.Pair ("CarrierGatewayId", String.to_query f))
         ; Aws.Util.option_map v.local_gateway_id (fun f ->
               Aws.Query.Pair ("LocalGatewayId", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_id (fun f ->
               Aws.Query.Pair ("TransitGatewayId", String.to_query f))
         ; Aws.Util.option_map v.nat_gateway_id (fun f ->
               Aws.Query.Pair ("NatGatewayId", String.to_query f))
         ; Aws.Util.option_map v.local_target (fun f ->
               Aws.Query.Pair ("LocalTarget", Boolean.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Aws.Util.option_map v.gateway_id (fun f ->
               Aws.Query.Pair ("GatewayId", String.to_query f))
         ; Aws.Util.option_map v.egress_only_internet_gateway_id (fun f ->
               Aws.Query.Pair ("EgressOnlyInternetGatewayId", String.to_query f))
         ; Aws.Util.option_map v.vpc_endpoint_id (fun f ->
               Aws.Query.Pair ("VpcEndpointId", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.destination_prefix_list_id (fun f ->
               Aws.Query.Pair ("DestinationPrefixListId", String.to_query f))
         ; Aws.Util.option_map v.destination_ipv6_cidr_block (fun f ->
               Aws.Query.Pair ("DestinationIpv6CidrBlock", String.to_query f))
         ; Aws.Util.option_map v.destination_cidr_block (fun f ->
               Aws.Query.Pair ("DestinationCidrBlock", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_peering_connection_id (fun f ->
               "vpcPeeringConnectionId", String.to_json f)
         ; Some ("routeTableId", String.to_json v.route_table_id)
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               "networkInterfaceId", String.to_json f)
         ; Aws.Util.option_map v.carrier_gateway_id (fun f ->
               "CarrierGatewayId", String.to_json f)
         ; Aws.Util.option_map v.local_gateway_id (fun f ->
               "LocalGatewayId", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_id (fun f ->
               "TransitGatewayId", String.to_json f)
         ; Aws.Util.option_map v.nat_gateway_id (fun f ->
               "natGatewayId", String.to_json f)
         ; Aws.Util.option_map v.local_target (fun f -> "LocalTarget", Boolean.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ; Aws.Util.option_map v.gateway_id (fun f -> "gatewayId", String.to_json f)
         ; Aws.Util.option_map v.egress_only_internet_gateway_id (fun f ->
               "egressOnlyInternetGatewayId", String.to_json f)
         ; Aws.Util.option_map v.vpc_endpoint_id (fun f ->
               "VpcEndpointId", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.destination_prefix_list_id (fun f ->
               "DestinationPrefixListId", String.to_json f)
         ; Aws.Util.option_map v.destination_ipv6_cidr_block (fun f ->
               "destinationIpv6CidrBlock", String.to_json f)
         ; Aws.Util.option_map v.destination_cidr_block (fun f ->
               "destinationCidrBlock", String.to_json f)
         ])

  let of_json j =
    { destination_cidr_block =
        Aws.Util.option_map (Aws.Json.lookup j "destinationCidrBlock") String.of_json
    ; destination_ipv6_cidr_block =
        Aws.Util.option_map (Aws.Json.lookup j "destinationIpv6CidrBlock") String.of_json
    ; destination_prefix_list_id =
        Aws.Util.option_map (Aws.Json.lookup j "DestinationPrefixListId") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; vpc_endpoint_id =
        Aws.Util.option_map (Aws.Json.lookup j "VpcEndpointId") String.of_json
    ; egress_only_internet_gateway_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "egressOnlyInternetGatewayId")
          String.of_json
    ; gateway_id = Aws.Util.option_map (Aws.Json.lookup j "gatewayId") String.of_json
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    ; local_target = Aws.Util.option_map (Aws.Json.lookup j "LocalTarget") Boolean.of_json
    ; nat_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "natGatewayId") String.of_json
    ; transit_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "TransitGatewayId") String.of_json
    ; local_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "LocalGatewayId") String.of_json
    ; carrier_gateway_id =
        Aws.Util.option_map (Aws.Json.lookup j "CarrierGatewayId") String.of_json
    ; network_interface_id =
        Aws.Util.option_map (Aws.Json.lookup j "networkInterfaceId") String.of_json
    ; route_table_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "routeTableId"))
    ; vpc_peering_connection_id =
        Aws.Util.option_map (Aws.Json.lookup j "vpcPeeringConnectionId") String.of_json
    }
end

module DescribeSecurityGroupReferencesResult = struct
  type t = { security_group_reference_set : SecurityGroupReferences.t }

  let make ?(security_group_reference_set = []) () = { security_group_reference_set }

  let parse xml =
    Some
      { security_group_reference_set =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "securityGroupReferenceSet" xml)
               SecurityGroupReferences.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "SecurityGroupReferenceSet"
                , SecurityGroupReferences.to_query v.security_group_reference_set ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "securityGroupReferenceSet"
             , SecurityGroupReferences.to_json v.security_group_reference_set )
         ])

  let of_json j =
    { security_group_reference_set =
        SecurityGroupReferences.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "securityGroupReferenceSet"))
    }
end

module DisassociateAddressRequest = struct
  type t =
    { association_id : String.t option
    ; public_ip : String.t option
    ; dry_run : Boolean.t option
    }

  let make ?association_id ?public_ip ?dry_run () = { association_id; public_ip; dry_run }

  let parse xml =
    Some
      { association_id =
          Aws.Util.option_bind (Aws.Xml.member "AssociationId" xml) String.parse
      ; public_ip = Aws.Util.option_bind (Aws.Xml.member "PublicIp" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.public_ip (fun f ->
               Aws.Query.Pair ("PublicIp", String.to_query f))
         ; Aws.Util.option_map v.association_id (fun f ->
               Aws.Query.Pair ("AssociationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.public_ip (fun f -> "PublicIp", String.to_json f)
         ; Aws.Util.option_map v.association_id (fun f ->
               "AssociationId", String.to_json f)
         ])

  let of_json j =
    { association_id =
        Aws.Util.option_map (Aws.Json.lookup j "AssociationId") String.of_json
    ; public_ip = Aws.Util.option_map (Aws.Json.lookup j "PublicIp") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module CreateKeyPairRequest = struct
  type t =
    { key_name : String.t
    ; dry_run : Boolean.t option
    ; tag_specifications : TagSpecificationList.t
    }

  let make ~key_name ?dry_run ?(tag_specifications = []) () =
    { key_name; dry_run; tag_specifications }

  let parse xml =
    Some
      { key_name =
          Aws.Xml.required
            "KeyName"
            (Aws.Util.option_bind (Aws.Xml.member "KeyName" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("KeyName", String.to_query v.key_name))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("KeyName", String.to_json v.key_name)
         ])

  let of_json j =
    { key_name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "KeyName"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    }
end

module DescribeStaleSecurityGroupsResult = struct
  type t =
    { next_token : String.t option
    ; stale_security_group_set : StaleSecurityGroupSet.t
    }

  let make ?next_token ?(stale_security_group_set = []) () =
    { next_token; stale_security_group_set }

  let parse xml =
    Some
      { next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; stale_security_group_set =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "staleSecurityGroupSet" xml)
               StaleSecurityGroupSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "StaleSecurityGroupSet"
                , StaleSecurityGroupSet.to_query v.stale_security_group_set ))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "staleSecurityGroupSet"
             , StaleSecurityGroupSet.to_json v.stale_security_group_set )
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ])

  let of_json j =
    { next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; stale_security_group_set =
        StaleSecurityGroupSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "staleSecurityGroupSet"))
    }
end

module LocalGatewayRouteTableVpcAssociationIdSet = struct
  type t = String.t list

  let make elems () = elems

  let parse xml = Aws.Util.option_all (List.map String.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeLocalGatewayRouteTableVpcAssociationsRequest = struct
  type t =
    { local_gateway_route_table_vpc_association_ids :
        LocalGatewayRouteTableVpcAssociationIdSet.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make
      ?(local_gateway_route_table_vpc_association_ids = [])
      ?(filters = [])
      ?max_results
      ?next_token
      ?dry_run
      () =
    { local_gateway_route_table_vpc_association_ids
    ; filters
    ; max_results
    ; next_token
    ; dry_run
    }

  let parse xml =
    Some
      { local_gateway_route_table_vpc_association_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "LocalGatewayRouteTableVpcAssociationId" xml)
               LocalGatewayRouteTableVpcAssociationIdSet.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ( "LocalGatewayRouteTableVpcAssociationId"
                , LocalGatewayRouteTableVpcAssociationIdSet.to_query
                    v.local_gateway_route_table_vpc_association_ids ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some
             ( "LocalGatewayRouteTableVpcAssociationId"
             , LocalGatewayRouteTableVpcAssociationIdSet.to_json
                 v.local_gateway_route_table_vpc_association_ids )
         ])

  let of_json j =
    { local_gateway_route_table_vpc_association_ids =
        LocalGatewayRouteTableVpcAssociationIdSet.of_json
          (Aws.Util.of_option_exn
             (Aws.Json.lookup j "LocalGatewayRouteTableVpcAssociationId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module AcceptReservedInstancesExchangeQuoteRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; reserved_instance_ids : ReservedInstanceIdSet.t
    ; target_configurations : TargetConfigurationRequestSet.t
    }

  let make ?dry_run ~reserved_instance_ids ?(target_configurations = []) () =
    { dry_run; reserved_instance_ids; target_configurations }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; reserved_instance_ids =
          Aws.Xml.required
            "ReservedInstanceId"
            (Aws.Util.option_bind
               (Aws.Xml.member "ReservedInstanceId" xml)
               ReservedInstanceIdSet.parse)
      ; target_configurations =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TargetConfiguration" xml)
               TargetConfigurationRequestSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "TargetConfiguration"
                , TargetConfigurationRequestSet.to_query v.target_configurations ))
         ; Some
             (Aws.Query.Pair
                ( "ReservedInstanceId"
                , ReservedInstanceIdSet.to_query v.reserved_instance_ids ))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "TargetConfiguration"
             , TargetConfigurationRequestSet.to_json v.target_configurations )
         ; Some
             ("ReservedInstanceId", ReservedInstanceIdSet.to_json v.reserved_instance_ids)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; reserved_instance_ids =
        ReservedInstanceIdSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ReservedInstanceId"))
    ; target_configurations =
        TargetConfigurationRequestSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TargetConfiguration"))
    }
end

module ImportKeyPairResult = struct
  type t =
    { key_fingerprint : String.t option
    ; key_name : String.t option
    ; key_pair_id : String.t option
    ; tags : TagList.t
    }

  let make ?key_fingerprint ?key_name ?key_pair_id ?(tags = []) () =
    { key_fingerprint; key_name; key_pair_id; tags }

  let parse xml =
    Some
      { key_fingerprint =
          Aws.Util.option_bind (Aws.Xml.member "keyFingerprint" xml) String.parse
      ; key_name = Aws.Util.option_bind (Aws.Xml.member "keyName" xml) String.parse
      ; key_pair_id = Aws.Util.option_bind (Aws.Xml.member "keyPairId" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.key_pair_id (fun f ->
               Aws.Query.Pair ("KeyPairId", String.to_query f))
         ; Aws.Util.option_map v.key_name (fun f ->
               Aws.Query.Pair ("KeyName", String.to_query f))
         ; Aws.Util.option_map v.key_fingerprint (fun f ->
               Aws.Query.Pair ("KeyFingerprint", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.key_pair_id (fun f -> "keyPairId", String.to_json f)
         ; Aws.Util.option_map v.key_name (fun f -> "keyName", String.to_json f)
         ; Aws.Util.option_map v.key_fingerprint (fun f ->
               "keyFingerprint", String.to_json f)
         ])

  let of_json j =
    { key_fingerprint =
        Aws.Util.option_map (Aws.Json.lookup j "keyFingerprint") String.of_json
    ; key_name = Aws.Util.option_map (Aws.Json.lookup j "keyName") String.of_json
    ; key_pair_id = Aws.Util.option_map (Aws.Json.lookup j "keyPairId") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module CoipAddressUsageSet = struct
  type t = CoipAddressUsage.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map CoipAddressUsage.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list CoipAddressUsage.to_query v

  let to_json v = `List (List.map CoipAddressUsage.to_json v)

  let of_json j = Aws.Json.to_list CoipAddressUsage.of_json j
end

module GetCoipPoolUsageResult = struct
  type t =
    { coip_pool_id : String.t option
    ; coip_address_usages : CoipAddressUsageSet.t
    ; local_gateway_route_table_id : String.t option
    }

  let make ?coip_pool_id ?(coip_address_usages = []) ?local_gateway_route_table_id () =
    { coip_pool_id; coip_address_usages; local_gateway_route_table_id }

  let parse xml =
    Some
      { coip_pool_id = Aws.Util.option_bind (Aws.Xml.member "coipPoolId" xml) String.parse
      ; coip_address_usages =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "coipAddressUsageSet" xml)
               CoipAddressUsageSet.parse)
      ; local_gateway_route_table_id =
          Aws.Util.option_bind
            (Aws.Xml.member "localGatewayRouteTableId" xml)
            String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.local_gateway_route_table_id (fun f ->
               Aws.Query.Pair ("LocalGatewayRouteTableId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("CoipAddressUsageSet", CoipAddressUsageSet.to_query v.coip_address_usages))
         ; Aws.Util.option_map v.coip_pool_id (fun f ->
               Aws.Query.Pair ("CoipPoolId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.local_gateway_route_table_id (fun f ->
               "localGatewayRouteTableId", String.to_json f)
         ; Some ("coipAddressUsageSet", CoipAddressUsageSet.to_json v.coip_address_usages)
         ; Aws.Util.option_map v.coip_pool_id (fun f -> "coipPoolId", String.to_json f)
         ])

  let of_json j =
    { coip_pool_id = Aws.Util.option_map (Aws.Json.lookup j "coipPoolId") String.of_json
    ; coip_address_usages =
        CoipAddressUsageSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "coipAddressUsageSet"))
    ; local_gateway_route_table_id =
        Aws.Util.option_map (Aws.Json.lookup j "localGatewayRouteTableId") String.of_json
    }
end

module ExportTaskS3LocationRequest = struct
  type t =
    { s3_bucket : String.t
    ; s3_prefix : String.t option
    }

  let make ~s3_bucket ?s3_prefix () = { s3_bucket; s3_prefix }

  let parse xml =
    Some
      { s3_bucket =
          Aws.Xml.required
            "S3Bucket"
            (Aws.Util.option_bind (Aws.Xml.member "S3Bucket" xml) String.parse)
      ; s3_prefix = Aws.Util.option_bind (Aws.Xml.member "S3Prefix" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.s3_prefix (fun f ->
               Aws.Query.Pair ("S3Prefix", String.to_query f))
         ; Some (Aws.Query.Pair ("S3Bucket", String.to_query v.s3_bucket))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.s3_prefix (fun f -> "S3Prefix", String.to_json f)
         ; Some ("S3Bucket", String.to_json v.s3_bucket)
         ])

  let of_json j =
    { s3_bucket = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "S3Bucket"))
    ; s3_prefix = Aws.Util.option_map (Aws.Json.lookup j "S3Prefix") String.of_json
    }
end

module DescribeSubnetsRequest = struct
  type t =
    { filters : FilterList.t
    ; subnet_ids : SubnetIdStringList.t
    ; dry_run : Boolean.t option
    ; next_token : String.t option
    ; max_results : Integer.t option
    }

  let make ?(filters = []) ?(subnet_ids = []) ?dry_run ?next_token ?max_results () =
    { filters; subnet_ids; dry_run; next_token; max_results }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; subnet_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SubnetId" xml)
               SubnetIdStringList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("SubnetId", SubnetIdStringList.to_query v.subnet_ids))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("SubnetId", SubnetIdStringList.to_json v.subnet_ids)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; subnet_ids =
        SubnetIdStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SubnetId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module ExportClientVpnClientCertificateRevocationListRequest = struct
  type t =
    { client_vpn_endpoint_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~client_vpn_endpoint_id ?dry_run () = { client_vpn_endpoint_id; dry_run }

  let parse xml =
    Some
      { client_vpn_endpoint_id =
          Aws.Xml.required
            "ClientVpnEndpointId"
            (Aws.Util.option_bind (Aws.Xml.member "ClientVpnEndpointId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ClientVpnEndpointId", String.to_query v.client_vpn_endpoint_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("ClientVpnEndpointId", String.to_json v.client_vpn_endpoint_id)
         ])

  let of_json j =
    { client_vpn_endpoint_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ClientVpnEndpointId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DescribeInstanceCreditSpecificationsResult = struct
  type t =
    { instance_credit_specifications : InstanceCreditSpecificationList.t
    ; next_token : String.t option
    }

  let make ?(instance_credit_specifications = []) ?next_token () =
    { instance_credit_specifications; next_token }

  let parse xml =
    Some
      { instance_credit_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "instanceCreditSpecificationSet" xml)
               InstanceCreditSpecificationList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "InstanceCreditSpecificationSet"
                , InstanceCreditSpecificationList.to_query
                    v.instance_credit_specifications ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "instanceCreditSpecificationSet"
             , InstanceCreditSpecificationList.to_json v.instance_credit_specifications )
         ])

  let of_json j =
    { instance_credit_specifications =
        InstanceCreditSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceCreditSpecificationSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DescribeBundleTasksResult = struct
  type t = { bundle_tasks : BundleTaskList.t }

  let make ?(bundle_tasks = []) () = { bundle_tasks }

  let parse xml =
    Some
      { bundle_tasks =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "bundleInstanceTasksSet" xml)
               BundleTaskList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("BundleInstanceTasksSet", BundleTaskList.to_query v.bundle_tasks))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("bundleInstanceTasksSet", BundleTaskList.to_json v.bundle_tasks) ])

  let of_json j =
    { bundle_tasks =
        BundleTaskList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "bundleInstanceTasksSet"))
    }
end

module CreateVpcEndpointServiceConfigurationRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; acceptance_required : Boolean.t option
    ; private_dns_name : String.t option
    ; network_load_balancer_arns : ValueStringList.t
    ; gateway_load_balancer_arns : ValueStringList.t
    ; client_token : String.t option
    ; tag_specifications : TagSpecificationList.t
    }

  let make
      ?dry_run
      ?acceptance_required
      ?private_dns_name
      ?(network_load_balancer_arns = [])
      ?(gateway_load_balancer_arns = [])
      ?client_token
      ?(tag_specifications = [])
      () =
    { dry_run
    ; acceptance_required
    ; private_dns_name
    ; network_load_balancer_arns
    ; gateway_load_balancer_arns
    ; client_token
    ; tag_specifications
    }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; acceptance_required =
          Aws.Util.option_bind (Aws.Xml.member "AcceptanceRequired" xml) Boolean.parse
      ; private_dns_name =
          Aws.Util.option_bind (Aws.Xml.member "PrivateDnsName" xml) String.parse
      ; network_load_balancer_arns =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "NetworkLoadBalancerArn" xml)
               ValueStringList.parse)
      ; gateway_load_balancer_arns =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "GatewayLoadBalancerArn" xml)
               ValueStringList.parse)
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "GatewayLoadBalancerArn"
                , ValueStringList.to_query v.gateway_load_balancer_arns ))
         ; Some
             (Aws.Query.Pair
                ( "NetworkLoadBalancerArn"
                , ValueStringList.to_query v.network_load_balancer_arns ))
         ; Aws.Util.option_map v.private_dns_name (fun f ->
               Aws.Query.Pair ("PrivateDnsName", String.to_query f))
         ; Aws.Util.option_map v.acceptance_required (fun f ->
               Aws.Query.Pair ("AcceptanceRequired", Boolean.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Some
             ( "GatewayLoadBalancerArn"
             , ValueStringList.to_json v.gateway_load_balancer_arns )
         ; Some
             ( "NetworkLoadBalancerArn"
             , ValueStringList.to_json v.network_load_balancer_arns )
         ; Aws.Util.option_map v.private_dns_name (fun f ->
               "PrivateDnsName", String.to_json f)
         ; Aws.Util.option_map v.acceptance_required (fun f ->
               "AcceptanceRequired", Boolean.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; acceptance_required =
        Aws.Util.option_map (Aws.Json.lookup j "AcceptanceRequired") Boolean.of_json
    ; private_dns_name =
        Aws.Util.option_map (Aws.Json.lookup j "PrivateDnsName") String.of_json
    ; network_load_balancer_arns =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "NetworkLoadBalancerArn"))
    ; gateway_load_balancer_arns =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "GatewayLoadBalancerArn"))
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    }
end

module DescribeFlowLogsResult = struct
  type t =
    { flow_logs : FlowLogSet.t
    ; next_token : String.t option
    }

  let make ?(flow_logs = []) ?next_token () = { flow_logs; next_token }

  let parse xml =
    Some
      { flow_logs =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "flowLogSet" xml) FlowLogSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("FlowLogSet", FlowLogSet.to_query v.flow_logs))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("flowLogSet", FlowLogSet.to_json v.flow_logs)
         ])

  let of_json j =
    { flow_logs =
        FlowLogSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "flowLogSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module ModifyInstanceMetadataOptionsResult = struct
  type t =
    { instance_id : String.t option
    ; instance_metadata_options : InstanceMetadataOptionsResponse.t option
    }

  let make ?instance_id ?instance_metadata_options () =
    { instance_id; instance_metadata_options }

  let parse xml =
    Some
      { instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      ; instance_metadata_options =
          Aws.Util.option_bind
            (Aws.Xml.member "instanceMetadataOptions" xml)
            InstanceMetadataOptionsResponse.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_metadata_options (fun f ->
               Aws.Query.Pair
                 ("InstanceMetadataOptions", InstanceMetadataOptionsResponse.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_metadata_options (fun f ->
               "instanceMetadataOptions", InstanceMetadataOptionsResponse.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ])

  let of_json j =
    { instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    ; instance_metadata_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "instanceMetadataOptions")
          InstanceMetadataOptionsResponse.of_json
    }
end

module DescribeScheduledInstancesResult = struct
  type t =
    { next_token : String.t option
    ; scheduled_instance_set : ScheduledInstanceSet.t
    }

  let make ?next_token ?(scheduled_instance_set = []) () =
    { next_token; scheduled_instance_set }

  let parse xml =
    Some
      { next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; scheduled_instance_set =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "scheduledInstanceSet" xml)
               ScheduledInstanceSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "ScheduledInstanceSet"
                , ScheduledInstanceSet.to_query v.scheduled_instance_set ))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "scheduledInstanceSet"
             , ScheduledInstanceSet.to_json v.scheduled_instance_set )
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ])

  let of_json j =
    { next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; scheduled_instance_set =
        ScheduledInstanceSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "scheduledInstanceSet"))
    }
end

module DescribeVpcEndpointServicesRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; service_names : ValueStringList.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?dry_run ?(service_names = []) ?(filters = []) ?max_results ?next_token () =
    { dry_run; service_names; filters; max_results; next_token }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; service_names =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ServiceName" xml)
               ValueStringList.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some (Aws.Query.Pair ("ServiceName", ValueStringList.to_query v.service_names))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some ("ServiceName", ValueStringList.to_json v.service_names)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; service_names =
        ValueStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ServiceName"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module AssignIpv6AddressesRequest = struct
  type t =
    { ipv6_address_count : Integer.t option
    ; ipv6_addresses : Ipv6AddressList.t
    ; network_interface_id : String.t
    }

  let make ?ipv6_address_count ?(ipv6_addresses = []) ~network_interface_id () =
    { ipv6_address_count; ipv6_addresses; network_interface_id }

  let parse xml =
    Some
      { ipv6_address_count =
          Aws.Util.option_bind (Aws.Xml.member "ipv6AddressCount" xml) Integer.parse
      ; ipv6_addresses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ipv6Addresses" xml)
               Ipv6AddressList.parse)
      ; network_interface_id =
          Aws.Xml.required
            "networkInterfaceId"
            (Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("NetworkInterfaceId", String.to_query v.network_interface_id))
         ; Some
             (Aws.Query.Pair ("Ipv6Addresses", Ipv6AddressList.to_query v.ipv6_addresses))
         ; Aws.Util.option_map v.ipv6_address_count (fun f ->
               Aws.Query.Pair ("Ipv6AddressCount", Integer.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("networkInterfaceId", String.to_json v.network_interface_id)
         ; Some ("ipv6Addresses", Ipv6AddressList.to_json v.ipv6_addresses)
         ; Aws.Util.option_map v.ipv6_address_count (fun f ->
               "ipv6AddressCount", Integer.to_json f)
         ])

  let of_json j =
    { ipv6_address_count =
        Aws.Util.option_map (Aws.Json.lookup j "ipv6AddressCount") Integer.of_json
    ; ipv6_addresses =
        Ipv6AddressList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ipv6Addresses"))
    ; network_interface_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "networkInterfaceId"))
    }
end

module VpcEndpointConnectionSet = struct
  type t = VpcEndpointConnection.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map VpcEndpointConnection.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list VpcEndpointConnection.to_query v

  let to_json v = `List (List.map VpcEndpointConnection.to_json v)

  let of_json j = Aws.Json.to_list VpcEndpointConnection.of_json j
end

module DescribePlacementGroupsRequest = struct
  type t =
    { filters : FilterList.t
    ; dry_run : Boolean.t option
    ; group_names : PlacementGroupStringList.t
    ; group_ids : PlacementGroupIdStringList.t
    }

  let make ?(filters = []) ?dry_run ?(group_names = []) ?(group_ids = []) () =
    { filters; dry_run; group_names; group_ids }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; group_names =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "groupName" xml)
               PlacementGroupStringList.parse)
      ; group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "GroupId" xml)
               PlacementGroupIdStringList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("GroupId", PlacementGroupIdStringList.to_query v.group_ids))
         ; Some
             (Aws.Query.Pair ("GroupName", PlacementGroupStringList.to_query v.group_names))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("GroupId", PlacementGroupIdStringList.to_json v.group_ids)
         ; Some ("groupName", PlacementGroupStringList.to_json v.group_names)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; group_names =
        PlacementGroupStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "groupName"))
    ; group_ids =
        PlacementGroupIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "GroupId"))
    }
end

module DescribeSpotInstanceRequestsRequest = struct
  type t =
    { filters : FilterList.t
    ; dry_run : Boolean.t option
    ; spot_instance_request_ids : SpotInstanceRequestIdList.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    }

  let make
      ?(filters = [])
      ?dry_run
      ?(spot_instance_request_ids = [])
      ?next_token
      ?max_results
      () =
    { filters; dry_run; spot_instance_request_ids; next_token; max_results }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; spot_instance_request_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SpotInstanceRequestId" xml)
               SpotInstanceRequestIdList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "SpotInstanceRequestId"
                , SpotInstanceRequestIdList.to_query v.spot_instance_request_ids ))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some
             ( "SpotInstanceRequestId"
             , SpotInstanceRequestIdList.to_json v.spot_instance_request_ids )
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; spot_instance_request_ids =
        SpotInstanceRequestIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SpotInstanceRequestId"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module InstanceStatus = struct
  type t =
    { availability_zone : String.t option
    ; outpost_arn : String.t option
    ; events : InstanceStatusEventList.t
    ; instance_id : String.t option
    ; instance_state : InstanceState.t option
    ; instance_status : InstanceStatusSummary.t option
    ; system_status : InstanceStatusSummary.t option
    }

  let make
      ?availability_zone
      ?outpost_arn
      ?(events = [])
      ?instance_id
      ?instance_state
      ?instance_status
      ?system_status
      () =
    { availability_zone
    ; outpost_arn
    ; events
    ; instance_id
    ; instance_state
    ; instance_status
    ; system_status
    }

  let parse xml =
    Some
      { availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; outpost_arn = Aws.Util.option_bind (Aws.Xml.member "outpostArn" xml) String.parse
      ; events =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "eventsSet" xml)
               InstanceStatusEventList.parse)
      ; instance_id = Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse
      ; instance_state =
          Aws.Util.option_bind (Aws.Xml.member "instanceState" xml) InstanceState.parse
      ; instance_status =
          Aws.Util.option_bind
            (Aws.Xml.member "instanceStatus" xml)
            InstanceStatusSummary.parse
      ; system_status =
          Aws.Util.option_bind
            (Aws.Xml.member "systemStatus" xml)
            InstanceStatusSummary.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.system_status (fun f ->
               Aws.Query.Pair ("SystemStatus", InstanceStatusSummary.to_query f))
         ; Aws.Util.option_map v.instance_status (fun f ->
               Aws.Query.Pair ("InstanceStatus", InstanceStatusSummary.to_query f))
         ; Aws.Util.option_map v.instance_state (fun f ->
               Aws.Query.Pair ("InstanceState", InstanceState.to_query f))
         ; Aws.Util.option_map v.instance_id (fun f ->
               Aws.Query.Pair ("InstanceId", String.to_query f))
         ; Some (Aws.Query.Pair ("EventsSet", InstanceStatusEventList.to_query v.events))
         ; Aws.Util.option_map v.outpost_arn (fun f ->
               Aws.Query.Pair ("OutpostArn", String.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.system_status (fun f ->
               "systemStatus", InstanceStatusSummary.to_json f)
         ; Aws.Util.option_map v.instance_status (fun f ->
               "instanceStatus", InstanceStatusSummary.to_json f)
         ; Aws.Util.option_map v.instance_state (fun f ->
               "instanceState", InstanceState.to_json f)
         ; Aws.Util.option_map v.instance_id (fun f -> "instanceId", String.to_json f)
         ; Some ("eventsSet", InstanceStatusEventList.to_json v.events)
         ; Aws.Util.option_map v.outpost_arn (fun f -> "outpostArn", String.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ])

  let of_json j =
    { availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; outpost_arn = Aws.Util.option_map (Aws.Json.lookup j "outpostArn") String.of_json
    ; events =
        InstanceStatusEventList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "eventsSet"))
    ; instance_id = Aws.Util.option_map (Aws.Json.lookup j "instanceId") String.of_json
    ; instance_state =
        Aws.Util.option_map (Aws.Json.lookup j "instanceState") InstanceState.of_json
    ; instance_status =
        Aws.Util.option_map
          (Aws.Json.lookup j "instanceStatus")
          InstanceStatusSummary.of_json
    ; system_status =
        Aws.Util.option_map
          (Aws.Json.lookup j "systemStatus")
          InstanceStatusSummary.of_json
    }
end

module DeleteNatGatewayRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; nat_gateway_id : String.t
    }

  let make ?dry_run ~nat_gateway_id () = { dry_run; nat_gateway_id }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; nat_gateway_id =
          Aws.Xml.required
            "NatGatewayId"
            (Aws.Util.option_bind (Aws.Xml.member "NatGatewayId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("NatGatewayId", String.to_query v.nat_gateway_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("NatGatewayId", String.to_json v.nat_gateway_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; nat_gateway_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "NatGatewayId"))
    }
end

module DescribeInstanceTypesRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; instance_types : RequestInstanceTypeList.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?dry_run ?(instance_types = []) ?(filters = []) ?max_results ?next_token () =
    { dry_run; instance_types; filters; max_results; next_token }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; instance_types =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "InstanceType" xml)
               RequestInstanceTypeList.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ("InstanceType", RequestInstanceTypeList.to_query v.instance_types))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some ("InstanceType", RequestInstanceTypeList.to_json v.instance_types)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; instance_types =
        RequestInstanceTypeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceType"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module DescribeReservedInstancesModificationsRequest = struct
  type t =
    { filters : FilterList.t
    ; reserved_instances_modification_ids : ReservedInstancesModificationIdStringList.t
    ; next_token : String.t option
    }

  let make ?(filters = []) ?(reserved_instances_modification_ids = []) ?next_token () =
    { filters; reserved_instances_modification_ids; next_token }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; reserved_instances_modification_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ReservedInstancesModificationId" xml)
               ReservedInstancesModificationIdStringList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ReservedInstancesModificationId"
                , ReservedInstancesModificationIdStringList.to_query
                    v.reserved_instances_modification_ids ))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "ReservedInstancesModificationId"
             , ReservedInstancesModificationIdStringList.to_json
                 v.reserved_instances_modification_ids )
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; reserved_instances_modification_ids =
        ReservedInstancesModificationIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ReservedInstancesModificationId"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DeleteTrafficMirrorFilterResult = struct
  type t = { traffic_mirror_filter_id : String.t option }

  let make ?traffic_mirror_filter_id () = { traffic_mirror_filter_id }

  let parse xml =
    Some
      { traffic_mirror_filter_id =
          Aws.Util.option_bind (Aws.Xml.member "trafficMirrorFilterId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.traffic_mirror_filter_id (fun f ->
               Aws.Query.Pair ("TrafficMirrorFilterId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.traffic_mirror_filter_id (fun f ->
               "trafficMirrorFilterId", String.to_json f)
         ])

  let of_json j =
    { traffic_mirror_filter_id =
        Aws.Util.option_map (Aws.Json.lookup j "trafficMirrorFilterId") String.of_json
    }
end

module GetEbsDefaultKmsKeyIdResult = struct
  type t = { kms_key_id : String.t option }

  let make ?kms_key_id () = { kms_key_id }

  let parse xml =
    Some
      { kms_key_id = Aws.Util.option_bind (Aws.Xml.member "kmsKeyId" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.kms_key_id (fun f ->
               Aws.Query.Pair ("KmsKeyId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.kms_key_id (fun f -> "kmsKeyId", String.to_json f) ])

  let of_json j =
    { kms_key_id = Aws.Util.option_map (Aws.Json.lookup j "kmsKeyId") String.of_json }
end

module DisableFastSnapshotRestoreSuccessSet = struct
  type t = DisableFastSnapshotRestoreSuccessItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map DisableFastSnapshotRestoreSuccessItem.parse (Aws.Xml.members "item" xml))

  let to_query v =
    Aws.Query.to_query_list DisableFastSnapshotRestoreSuccessItem.to_query v

  let to_json v = `List (List.map DisableFastSnapshotRestoreSuccessItem.to_json v)

  let of_json j = Aws.Json.to_list DisableFastSnapshotRestoreSuccessItem.of_json j
end

module DisableFastSnapshotRestoreErrorSet = struct
  type t = DisableFastSnapshotRestoreErrorItem.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map DisableFastSnapshotRestoreErrorItem.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list DisableFastSnapshotRestoreErrorItem.to_query v

  let to_json v = `List (List.map DisableFastSnapshotRestoreErrorItem.to_json v)

  let of_json j = Aws.Json.to_list DisableFastSnapshotRestoreErrorItem.of_json j
end

module DisableFastSnapshotRestoresResult = struct
  type t =
    { successful : DisableFastSnapshotRestoreSuccessSet.t
    ; unsuccessful : DisableFastSnapshotRestoreErrorSet.t
    }

  let make ?(successful = []) ?(unsuccessful = []) () = { successful; unsuccessful }

  let parse xml =
    Some
      { successful =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "successful" xml)
               DisableFastSnapshotRestoreSuccessSet.parse)
      ; unsuccessful =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "unsuccessful" xml)
               DisableFastSnapshotRestoreErrorSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "Unsuccessful"
                , DisableFastSnapshotRestoreErrorSet.to_query v.unsuccessful ))
         ; Some
             (Aws.Query.Pair
                ("Successful", DisableFastSnapshotRestoreSuccessSet.to_query v.successful))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("unsuccessful", DisableFastSnapshotRestoreErrorSet.to_json v.unsuccessful)
         ; Some ("successful", DisableFastSnapshotRestoreSuccessSet.to_json v.successful)
         ])

  let of_json j =
    { successful =
        DisableFastSnapshotRestoreSuccessSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "successful"))
    ; unsuccessful =
        DisableFastSnapshotRestoreErrorSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "unsuccessful"))
    }
end

module DeleteFleetsResult = struct
  type t =
    { successful_fleet_deletions : DeleteFleetSuccessSet.t
    ; unsuccessful_fleet_deletions : DeleteFleetErrorSet.t
    }

  let make ?(successful_fleet_deletions = []) ?(unsuccessful_fleet_deletions = []) () =
    { successful_fleet_deletions; unsuccessful_fleet_deletions }

  let parse xml =
    Some
      { successful_fleet_deletions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "successfulFleetDeletionSet" xml)
               DeleteFleetSuccessSet.parse)
      ; unsuccessful_fleet_deletions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "unsuccessfulFleetDeletionSet" xml)
               DeleteFleetErrorSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "UnsuccessfulFleetDeletionSet"
                , DeleteFleetErrorSet.to_query v.unsuccessful_fleet_deletions ))
         ; Some
             (Aws.Query.Pair
                ( "SuccessfulFleetDeletionSet"
                , DeleteFleetSuccessSet.to_query v.successful_fleet_deletions ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "unsuccessfulFleetDeletionSet"
             , DeleteFleetErrorSet.to_json v.unsuccessful_fleet_deletions )
         ; Some
             ( "successfulFleetDeletionSet"
             , DeleteFleetSuccessSet.to_json v.successful_fleet_deletions )
         ])

  let of_json j =
    { successful_fleet_deletions =
        DeleteFleetSuccessSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "successfulFleetDeletionSet"))
    ; unsuccessful_fleet_deletions =
        DeleteFleetErrorSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "unsuccessfulFleetDeletionSet"))
    }
end

module RevokeSecurityGroupEgressRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; group_id : String.t
    ; ip_permissions : IpPermissionList.t
    ; cidr_ip : String.t option
    ; from_port : Integer.t option
    ; ip_protocol : String.t option
    ; to_port : Integer.t option
    ; source_security_group_name : String.t option
    ; source_security_group_owner_id : String.t option
    }

  let make
      ?dry_run
      ~group_id
      ?(ip_permissions = [])
      ?cidr_ip
      ?from_port
      ?ip_protocol
      ?to_port
      ?source_security_group_name
      ?source_security_group_owner_id
      () =
    { dry_run
    ; group_id
    ; ip_permissions
    ; cidr_ip
    ; from_port
    ; ip_protocol
    ; to_port
    ; source_security_group_name
    ; source_security_group_owner_id
    }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; group_id =
          Aws.Xml.required
            "groupId"
            (Aws.Util.option_bind (Aws.Xml.member "groupId" xml) String.parse)
      ; ip_permissions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ipPermissions" xml)
               IpPermissionList.parse)
      ; cidr_ip = Aws.Util.option_bind (Aws.Xml.member "cidrIp" xml) String.parse
      ; from_port = Aws.Util.option_bind (Aws.Xml.member "fromPort" xml) Integer.parse
      ; ip_protocol = Aws.Util.option_bind (Aws.Xml.member "ipProtocol" xml) String.parse
      ; to_port = Aws.Util.option_bind (Aws.Xml.member "toPort" xml) Integer.parse
      ; source_security_group_name =
          Aws.Util.option_bind (Aws.Xml.member "sourceSecurityGroupName" xml) String.parse
      ; source_security_group_owner_id =
          Aws.Util.option_bind
            (Aws.Xml.member "sourceSecurityGroupOwnerId" xml)
            String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.source_security_group_owner_id (fun f ->
               Aws.Query.Pair ("SourceSecurityGroupOwnerId", String.to_query f))
         ; Aws.Util.option_map v.source_security_group_name (fun f ->
               Aws.Query.Pair ("SourceSecurityGroupName", String.to_query f))
         ; Aws.Util.option_map v.to_port (fun f ->
               Aws.Query.Pair ("ToPort", Integer.to_query f))
         ; Aws.Util.option_map v.ip_protocol (fun f ->
               Aws.Query.Pair ("IpProtocol", String.to_query f))
         ; Aws.Util.option_map v.from_port (fun f ->
               Aws.Query.Pair ("FromPort", Integer.to_query f))
         ; Aws.Util.option_map v.cidr_ip (fun f ->
               Aws.Query.Pair ("CidrIp", String.to_query f))
         ; Some
             (Aws.Query.Pair ("IpPermissions", IpPermissionList.to_query v.ip_permissions))
         ; Some (Aws.Query.Pair ("GroupId", String.to_query v.group_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.source_security_group_owner_id (fun f ->
               "sourceSecurityGroupOwnerId", String.to_json f)
         ; Aws.Util.option_map v.source_security_group_name (fun f ->
               "sourceSecurityGroupName", String.to_json f)
         ; Aws.Util.option_map v.to_port (fun f -> "toPort", Integer.to_json f)
         ; Aws.Util.option_map v.ip_protocol (fun f -> "ipProtocol", String.to_json f)
         ; Aws.Util.option_map v.from_port (fun f -> "fromPort", Integer.to_json f)
         ; Aws.Util.option_map v.cidr_ip (fun f -> "cidrIp", String.to_json f)
         ; Some ("ipPermissions", IpPermissionList.to_json v.ip_permissions)
         ; Some ("groupId", String.to_json v.group_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; group_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "groupId"))
    ; ip_permissions =
        IpPermissionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ipPermissions"))
    ; cidr_ip = Aws.Util.option_map (Aws.Json.lookup j "cidrIp") String.of_json
    ; from_port = Aws.Util.option_map (Aws.Json.lookup j "fromPort") Integer.of_json
    ; ip_protocol = Aws.Util.option_map (Aws.Json.lookup j "ipProtocol") String.of_json
    ; to_port = Aws.Util.option_map (Aws.Json.lookup j "toPort") Integer.of_json
    ; source_security_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "sourceSecurityGroupName") String.of_json
    ; source_security_group_owner_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "sourceSecurityGroupOwnerId")
          String.of_json
    }
end

module DescribeSpotDatafeedSubscriptionResult = struct
  type t = { spot_datafeed_subscription : SpotDatafeedSubscription.t option }

  let make ?spot_datafeed_subscription () = { spot_datafeed_subscription }

  let parse xml =
    Some
      { spot_datafeed_subscription =
          Aws.Util.option_bind
            (Aws.Xml.member "spotDatafeedSubscription" xml)
            SpotDatafeedSubscription.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.spot_datafeed_subscription (fun f ->
               Aws.Query.Pair
                 ("SpotDatafeedSubscription", SpotDatafeedSubscription.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.spot_datafeed_subscription (fun f ->
               "spotDatafeedSubscription", SpotDatafeedSubscription.to_json f)
         ])

  let of_json j =
    { spot_datafeed_subscription =
        Aws.Util.option_map
          (Aws.Json.lookup j "spotDatafeedSubscription")
          SpotDatafeedSubscription.of_json
    }
end

module CoipPool = struct
  type t =
    { pool_id : String.t option
    ; pool_cidrs : ValueStringList.t
    ; local_gateway_route_table_id : String.t option
    ; tags : TagList.t
    ; pool_arn : String.t option
    }

  let make
      ?pool_id
      ?(pool_cidrs = [])
      ?local_gateway_route_table_id
      ?(tags = [])
      ?pool_arn
      () =
    { pool_id; pool_cidrs; local_gateway_route_table_id; tags; pool_arn }

  let parse xml =
    Some
      { pool_id = Aws.Util.option_bind (Aws.Xml.member "poolId" xml) String.parse
      ; pool_cidrs =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "poolCidrSet" xml)
               ValueStringList.parse)
      ; local_gateway_route_table_id =
          Aws.Util.option_bind
            (Aws.Xml.member "localGatewayRouteTableId" xml)
            String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      ; pool_arn = Aws.Util.option_bind (Aws.Xml.member "poolArn" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.pool_arn (fun f ->
               Aws.Query.Pair ("PoolArn", String.to_query f))
         ; Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.local_gateway_route_table_id (fun f ->
               Aws.Query.Pair ("LocalGatewayRouteTableId", String.to_query f))
         ; Some (Aws.Query.Pair ("PoolCidrSet", ValueStringList.to_query v.pool_cidrs))
         ; Aws.Util.option_map v.pool_id (fun f ->
               Aws.Query.Pair ("PoolId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.pool_arn (fun f -> "poolArn", String.to_json f)
         ; Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.local_gateway_route_table_id (fun f ->
               "localGatewayRouteTableId", String.to_json f)
         ; Some ("poolCidrSet", ValueStringList.to_json v.pool_cidrs)
         ; Aws.Util.option_map v.pool_id (fun f -> "poolId", String.to_json f)
         ])

  let of_json j =
    { pool_id = Aws.Util.option_map (Aws.Json.lookup j "poolId") String.of_json
    ; pool_cidrs =
        ValueStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "poolCidrSet"))
    ; local_gateway_route_table_id =
        Aws.Util.option_map (Aws.Json.lookup j "localGatewayRouteTableId") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    ; pool_arn = Aws.Util.option_map (Aws.Json.lookup j "poolArn") String.of_json
    }
end

module CoipPoolSet = struct
  type t = CoipPool.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map CoipPool.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list CoipPool.to_query v

  let to_json v = `List (List.map CoipPool.to_json v)

  let of_json j = Aws.Json.to_list CoipPool.of_json j
end

module DescribeCoipPoolsResult = struct
  type t =
    { coip_pools : CoipPoolSet.t
    ; next_token : String.t option
    }

  let make ?(coip_pools = []) ?next_token () = { coip_pools; next_token }

  let parse xml =
    Some
      { coip_pools =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "coipPoolSet" xml) CoipPoolSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("CoipPoolSet", CoipPoolSet.to_query v.coip_pools))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("coipPoolSet", CoipPoolSet.to_json v.coip_pools)
         ])

  let of_json j =
    { coip_pools =
        CoipPoolSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "coipPoolSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DescribeByoipCidrsResult = struct
  type t =
    { byoip_cidrs : ByoipCidrSet.t
    ; next_token : String.t option
    }

  let make ?(byoip_cidrs = []) ?next_token () = { byoip_cidrs; next_token }

  let parse xml =
    Some
      { byoip_cidrs =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "byoipCidrSet" xml) ByoipCidrSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("ByoipCidrSet", ByoipCidrSet.to_query v.byoip_cidrs))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("byoipCidrSet", ByoipCidrSet.to_json v.byoip_cidrs)
         ])

  let of_json j =
    { byoip_cidrs =
        ByoipCidrSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "byoipCidrSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module CreateTransitGatewayPrefixListReferenceRequest = struct
  type t =
    { transit_gateway_route_table_id : String.t
    ; prefix_list_id : String.t
    ; transit_gateway_attachment_id : String.t option
    ; blackhole : Boolean.t option
    ; dry_run : Boolean.t option
    }

  let make
      ~transit_gateway_route_table_id
      ~prefix_list_id
      ?transit_gateway_attachment_id
      ?blackhole
      ?dry_run
      () =
    { transit_gateway_route_table_id
    ; prefix_list_id
    ; transit_gateway_attachment_id
    ; blackhole
    ; dry_run
    }

  let parse xml =
    Some
      { transit_gateway_route_table_id =
          Aws.Xml.required
            "TransitGatewayRouteTableId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayRouteTableId" xml)
               String.parse)
      ; prefix_list_id =
          Aws.Xml.required
            "PrefixListId"
            (Aws.Util.option_bind (Aws.Xml.member "PrefixListId" xml) String.parse)
      ; transit_gateway_attachment_id =
          Aws.Util.option_bind
            (Aws.Xml.member "TransitGatewayAttachmentId" xml)
            String.parse
      ; blackhole = Aws.Util.option_bind (Aws.Xml.member "Blackhole" xml) Boolean.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.blackhole (fun f ->
               Aws.Query.Pair ("Blackhole", Boolean.to_query f))
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               Aws.Query.Pair ("TransitGatewayAttachmentId", String.to_query f))
         ; Some (Aws.Query.Pair ("PrefixListId", String.to_query v.prefix_list_id))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayRouteTableId"
                , String.to_query v.transit_gateway_route_table_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.blackhole (fun f -> "Blackhole", Boolean.to_json f)
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               "TransitGatewayAttachmentId", String.to_json f)
         ; Some ("PrefixListId", String.to_json v.prefix_list_id)
         ; Some
             ( "TransitGatewayRouteTableId"
             , String.to_json v.transit_gateway_route_table_id )
         ])

  let of_json j =
    { transit_gateway_route_table_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayRouteTableId"))
    ; prefix_list_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PrefixListId"))
    ; transit_gateway_attachment_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "TransitGatewayAttachmentId")
          String.of_json
    ; blackhole = Aws.Util.option_map (Aws.Json.lookup j "Blackhole") Boolean.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DescribeVpcEndpointServicePermissionsResult = struct
  type t =
    { allowed_principals : AllowedPrincipalSet.t
    ; next_token : String.t option
    }

  let make ?(allowed_principals = []) ?next_token () = { allowed_principals; next_token }

  let parse xml =
    Some
      { allowed_principals =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "allowedPrincipals" xml)
               AllowedPrincipalSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("AllowedPrincipals", AllowedPrincipalSet.to_query v.allowed_principals))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("allowedPrincipals", AllowedPrincipalSet.to_json v.allowed_principals)
         ])

  let of_json j =
    { allowed_principals =
        AllowedPrincipalSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "allowedPrincipals"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DescribeSpotFleetRequestsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; spot_fleet_request_ids : SpotFleetRequestIdList.t
    }

  let make ?dry_run ?max_results ?next_token ?(spot_fleet_request_ids = []) () =
    { dry_run; max_results; next_token; spot_fleet_request_ids }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "maxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; spot_fleet_request_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "spotFleetRequestId" xml)
               SpotFleetRequestIdList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "SpotFleetRequestId"
                , SpotFleetRequestIdList.to_query v.spot_fleet_request_ids ))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "spotFleetRequestId"
             , SpotFleetRequestIdList.to_json v.spot_fleet_request_ids )
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "maxResults", Integer.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "maxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; spot_fleet_request_ids =
        SpotFleetRequestIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "spotFleetRequestId"))
    }
end

module AcceptVpcEndpointConnectionsResult = struct
  type t = { unsuccessful : UnsuccessfulItemSet.t }

  let make ?(unsuccessful = []) () = { unsuccessful }

  let parse xml =
    Some
      { unsuccessful =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "unsuccessful" xml)
               UnsuccessfulItemSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("Unsuccessful", UnsuccessfulItemSet.to_query v.unsuccessful))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("unsuccessful", UnsuccessfulItemSet.to_json v.unsuccessful) ])

  let of_json j =
    { unsuccessful =
        UnsuccessfulItemSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "unsuccessful"))
    }
end

module DescribeVpnGatewaysRequest = struct
  type t =
    { filters : FilterList.t
    ; vpn_gateway_ids : VpnGatewayIdStringList.t
    ; dry_run : Boolean.t option
    }

  let make ?(filters = []) ?(vpn_gateway_ids = []) ?dry_run () =
    { filters; vpn_gateway_ids; dry_run }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; vpn_gateway_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "VpnGatewayId" xml)
               VpnGatewayIdStringList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("VpnGatewayId", VpnGatewayIdStringList.to_query v.vpn_gateway_ids))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("VpnGatewayId", VpnGatewayIdStringList.to_json v.vpn_gateway_ids)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; vpn_gateway_ids =
        VpnGatewayIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpnGatewayId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module DescribeInstancesRequest = struct
  type t =
    { filters : FilterList.t
    ; instance_ids : InstanceIdStringList.t
    ; dry_run : Boolean.t option
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?(filters = []) ?(instance_ids = []) ?dry_run ?max_results ?next_token () =
    { filters; instance_ids; dry_run; max_results; next_token }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; instance_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "InstanceId" xml)
               InstanceIdStringList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "maxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair ("InstanceId", InstanceIdStringList.to_query v.instance_ids))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "maxResults", Integer.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("InstanceId", InstanceIdStringList.to_json v.instance_ids)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; instance_ids =
        InstanceIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "maxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DeregisterTransitGatewayMulticastGroupSourcesRequest = struct
  type t =
    { transit_gateway_multicast_domain_id : String.t option
    ; group_ip_address : String.t option
    ; network_interface_ids : TransitGatewayNetworkInterfaceIdList.t
    ; dry_run : Boolean.t option
    }

  let make
      ?transit_gateway_multicast_domain_id
      ?group_ip_address
      ?(network_interface_ids = [])
      ?dry_run
      () =
    { transit_gateway_multicast_domain_id
    ; group_ip_address
    ; network_interface_ids
    ; dry_run
    }

  let parse xml =
    Some
      { transit_gateway_multicast_domain_id =
          Aws.Util.option_bind
            (Aws.Xml.member "TransitGatewayMulticastDomainId" xml)
            String.parse
      ; group_ip_address =
          Aws.Util.option_bind (Aws.Xml.member "GroupIpAddress" xml) String.parse
      ; network_interface_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "NetworkInterfaceIds" xml)
               TransitGatewayNetworkInterfaceIdList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "NetworkInterfaceIds"
                , TransitGatewayNetworkInterfaceIdList.to_query v.network_interface_ids ))
         ; Aws.Util.option_map v.group_ip_address (fun f ->
               Aws.Query.Pair ("GroupIpAddress", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               Aws.Query.Pair ("TransitGatewayMulticastDomainId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ( "NetworkInterfaceIds"
             , TransitGatewayNetworkInterfaceIdList.to_json v.network_interface_ids )
         ; Aws.Util.option_map v.group_ip_address (fun f ->
               "GroupIpAddress", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               "TransitGatewayMulticastDomainId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_multicast_domain_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "TransitGatewayMulticastDomainId")
          String.of_json
    ; group_ip_address =
        Aws.Util.option_map (Aws.Json.lookup j "GroupIpAddress") String.of_json
    ; network_interface_ids =
        TransitGatewayNetworkInterfaceIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "NetworkInterfaceIds"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DescribePrincipalIdFormatResult = struct
  type t =
    { principals : PrincipalIdFormatList.t
    ; next_token : String.t option
    }

  let make ?(principals = []) ?next_token () = { principals; next_token }

  let parse xml =
    Some
      { principals =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "principalSet" xml)
               PrincipalIdFormatList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair ("PrincipalSet", PrincipalIdFormatList.to_query v.principals))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("principalSet", PrincipalIdFormatList.to_json v.principals)
         ])

  let of_json j =
    { principals =
        PrincipalIdFormatList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "principalSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module CreateTransitGatewayVpcAttachmentRequestOptions = struct
  type t =
    { dns_support : DnsSupportValue.t option
    ; ipv6_support : Ipv6SupportValue.t option
    ; appliance_mode_support : ApplianceModeSupportValue.t option
    }

  let make ?dns_support ?ipv6_support ?appliance_mode_support () =
    { dns_support; ipv6_support; appliance_mode_support }

  let parse xml =
    Some
      { dns_support =
          Aws.Util.option_bind (Aws.Xml.member "DnsSupport" xml) DnsSupportValue.parse
      ; ipv6_support =
          Aws.Util.option_bind (Aws.Xml.member "Ipv6Support" xml) Ipv6SupportValue.parse
      ; appliance_mode_support =
          Aws.Util.option_bind
            (Aws.Xml.member "ApplianceModeSupport" xml)
            ApplianceModeSupportValue.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.appliance_mode_support (fun f ->
               Aws.Query.Pair
                 ("ApplianceModeSupport", ApplianceModeSupportValue.to_query f))
         ; Aws.Util.option_map v.ipv6_support (fun f ->
               Aws.Query.Pair ("Ipv6Support", Ipv6SupportValue.to_query f))
         ; Aws.Util.option_map v.dns_support (fun f ->
               Aws.Query.Pair ("DnsSupport", DnsSupportValue.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.appliance_mode_support (fun f ->
               "ApplianceModeSupport", ApplianceModeSupportValue.to_json f)
         ; Aws.Util.option_map v.ipv6_support (fun f ->
               "Ipv6Support", Ipv6SupportValue.to_json f)
         ; Aws.Util.option_map v.dns_support (fun f ->
               "DnsSupport", DnsSupportValue.to_json f)
         ])

  let of_json j =
    { dns_support =
        Aws.Util.option_map (Aws.Json.lookup j "DnsSupport") DnsSupportValue.of_json
    ; ipv6_support =
        Aws.Util.option_map (Aws.Json.lookup j "Ipv6Support") Ipv6SupportValue.of_json
    ; appliance_mode_support =
        Aws.Util.option_map
          (Aws.Json.lookup j "ApplianceModeSupport")
          ApplianceModeSupportValue.of_json
    }
end

module DeleteTransitGatewayVpcAttachmentRequest = struct
  type t =
    { transit_gateway_attachment_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~transit_gateway_attachment_id ?dry_run () =
    { transit_gateway_attachment_id; dry_run }

  let parse xml =
    Some
      { transit_gateway_attachment_id =
          Aws.Xml.required
            "TransitGatewayAttachmentId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayAttachmentId" xml)
               String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayAttachmentId"
                , String.to_query v.transit_gateway_attachment_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ("TransitGatewayAttachmentId", String.to_json v.transit_gateway_attachment_id)
         ])

  let of_json j =
    { transit_gateway_attachment_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayAttachmentId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DescribeTransitGatewayMulticastDomainsResult = struct
  type t =
    { transit_gateway_multicast_domains : TransitGatewayMulticastDomainList.t
    ; next_token : String.t option
    }

  let make ?(transit_gateway_multicast_domains = []) ?next_token () =
    { transit_gateway_multicast_domains; next_token }

  let parse xml =
    Some
      { transit_gateway_multicast_domains =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "transitGatewayMulticastDomains" xml)
               TransitGatewayMulticastDomainList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayMulticastDomains"
                , TransitGatewayMulticastDomainList.to_query
                    v.transit_gateway_multicast_domains ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "transitGatewayMulticastDomains"
             , TransitGatewayMulticastDomainList.to_json
                 v.transit_gateway_multicast_domains )
         ])

  let of_json j =
    { transit_gateway_multicast_domains =
        TransitGatewayMulticastDomainList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "transitGatewayMulticastDomains"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module StopInstancesRequest = struct
  type t =
    { instance_ids : InstanceIdStringList.t
    ; hibernate : Boolean.t option
    ; dry_run : Boolean.t option
    ; force : Boolean.t option
    }

  let make ~instance_ids ?hibernate ?dry_run ?force () =
    { instance_ids; hibernate; dry_run; force }

  let parse xml =
    Some
      { instance_ids =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind
               (Aws.Xml.member "InstanceId" xml)
               InstanceIdStringList.parse)
      ; hibernate = Aws.Util.option_bind (Aws.Xml.member "Hibernate" xml) Boolean.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; force = Aws.Util.option_bind (Aws.Xml.member "force" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.force (fun f ->
               Aws.Query.Pair ("Force", Boolean.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.hibernate (fun f ->
               Aws.Query.Pair ("Hibernate", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair ("InstanceId", InstanceIdStringList.to_query v.instance_ids))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.force (fun f -> "force", Boolean.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.hibernate (fun f -> "Hibernate", Boolean.to_json f)
         ; Some ("InstanceId", InstanceIdStringList.to_json v.instance_ids)
         ])

  let of_json j =
    { instance_ids =
        InstanceIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; hibernate = Aws.Util.option_map (Aws.Json.lookup j "Hibernate") Boolean.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; force = Aws.Util.option_map (Aws.Json.lookup j "force") Boolean.of_json
    }
end

module ZoneNameStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "ZoneName" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module DescribeAvailabilityZonesRequest = struct
  type t =
    { filters : FilterList.t
    ; zone_names : ZoneNameStringList.t
    ; zone_ids : ZoneIdStringList.t
    ; all_availability_zones : Boolean.t option
    ; dry_run : Boolean.t option
    }

  let make
      ?(filters = [])
      ?(zone_names = [])
      ?(zone_ids = [])
      ?all_availability_zones
      ?dry_run
      () =
    { filters; zone_names; zone_ids; all_availability_zones; dry_run }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; zone_names =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ZoneName" xml)
               ZoneNameStringList.parse)
      ; zone_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "ZoneId" xml) ZoneIdStringList.parse)
      ; all_availability_zones =
          Aws.Util.option_bind (Aws.Xml.member "AllAvailabilityZones" xml) Boolean.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.all_availability_zones (fun f ->
               Aws.Query.Pair ("AllAvailabilityZones", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("ZoneId", ZoneIdStringList.to_query v.zone_ids))
         ; Some (Aws.Query.Pair ("ZoneName", ZoneNameStringList.to_query v.zone_names))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.all_availability_zones (fun f ->
               "AllAvailabilityZones", Boolean.to_json f)
         ; Some ("ZoneId", ZoneIdStringList.to_json v.zone_ids)
         ; Some ("ZoneName", ZoneNameStringList.to_json v.zone_names)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; zone_names =
        ZoneNameStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ZoneName"))
    ; zone_ids =
        ZoneIdStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ZoneId"))
    ; all_availability_zones =
        Aws.Util.option_map (Aws.Json.lookup j "AllAvailabilityZones") Boolean.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module ResetSnapshotAttributeRequest = struct
  type t =
    { attribute : SnapshotAttributeName.t
    ; snapshot_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~attribute ~snapshot_id ?dry_run () = { attribute; snapshot_id; dry_run }

  let parse xml =
    Some
      { attribute =
          Aws.Xml.required
            "Attribute"
            (Aws.Util.option_bind
               (Aws.Xml.member "Attribute" xml)
               SnapshotAttributeName.parse)
      ; snapshot_id =
          Aws.Xml.required
            "SnapshotId"
            (Aws.Util.option_bind (Aws.Xml.member "SnapshotId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("SnapshotId", String.to_query v.snapshot_id))
         ; Some (Aws.Query.Pair ("Attribute", SnapshotAttributeName.to_query v.attribute))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("SnapshotId", String.to_json v.snapshot_id)
         ; Some ("Attribute", SnapshotAttributeName.to_json v.attribute)
         ])

  let of_json j =
    { attribute =
        SnapshotAttributeName.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Attribute"))
    ; snapshot_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SnapshotId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module DeleteEgressOnlyInternetGatewayResult = struct
  type t = { return_code : Boolean.t option }

  let make ?return_code () = { return_code }

  let parse xml =
    Some
      { return_code = Aws.Util.option_bind (Aws.Xml.member "returnCode" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return_code (fun f ->
               Aws.Query.Pair ("ReturnCode", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return_code (fun f -> "returnCode", Boolean.to_json f) ])

  let of_json j =
    { return_code = Aws.Util.option_map (Aws.Json.lookup j "returnCode") Boolean.of_json }
end

module DescribeInstanceTypeOfferingsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; location_type : LocationType.t option
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?dry_run ?location_type ?(filters = []) ?max_results ?next_token () =
    { dry_run; location_type; filters; max_results; next_token }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; location_type =
          Aws.Util.option_bind (Aws.Xml.member "LocationType" xml) LocationType.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.location_type (fun f ->
               Aws.Query.Pair ("LocationType", LocationType.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.location_type (fun f ->
               "LocationType", LocationType.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; location_type =
        Aws.Util.option_map (Aws.Json.lookup j "LocationType") LocationType.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module AttachVpnGatewayRequest = struct
  type t =
    { vpc_id : String.t
    ; vpn_gateway_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~vpc_id ~vpn_gateway_id ?dry_run () = { vpc_id; vpn_gateway_id; dry_run }

  let parse xml =
    Some
      { vpc_id =
          Aws.Xml.required
            "VpcId"
            (Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) String.parse)
      ; vpn_gateway_id =
          Aws.Xml.required
            "VpnGatewayId"
            (Aws.Util.option_bind (Aws.Xml.member "VpnGatewayId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("VpnGatewayId", String.to_query v.vpn_gateway_id))
         ; Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("VpnGatewayId", String.to_json v.vpn_gateway_id)
         ; Some ("VpcId", String.to_json v.vpc_id)
         ])

  let of_json j =
    { vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcId"))
    ; vpn_gateway_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpnGatewayId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module AssociateTransitGatewayRouteTableRequest = struct
  type t =
    { transit_gateway_route_table_id : String.t
    ; transit_gateway_attachment_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~transit_gateway_route_table_id ~transit_gateway_attachment_id ?dry_run () =
    { transit_gateway_route_table_id; transit_gateway_attachment_id; dry_run }

  let parse xml =
    Some
      { transit_gateway_route_table_id =
          Aws.Xml.required
            "TransitGatewayRouteTableId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayRouteTableId" xml)
               String.parse)
      ; transit_gateway_attachment_id =
          Aws.Xml.required
            "TransitGatewayAttachmentId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayAttachmentId" xml)
               String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayAttachmentId"
                , String.to_query v.transit_gateway_attachment_id ))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayRouteTableId"
                , String.to_query v.transit_gateway_route_table_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ("TransitGatewayAttachmentId", String.to_json v.transit_gateway_attachment_id)
         ; Some
             ( "TransitGatewayRouteTableId"
             , String.to_json v.transit_gateway_route_table_id )
         ])

  let of_json j =
    { transit_gateway_route_table_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayRouteTableId"))
    ; transit_gateway_attachment_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayAttachmentId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DhcpOptionsList = struct
  type t = DhcpOptions.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map DhcpOptions.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list DhcpOptions.to_query v

  let to_json v = `List (List.map DhcpOptions.to_json v)

  let of_json j = Aws.Json.to_list DhcpOptions.of_json j
end

module CreateDefaultSubnetResult = struct
  type t = { subnet : Subnet.t option }

  let make ?subnet () = { subnet }

  let parse xml =
    Some { subnet = Aws.Util.option_bind (Aws.Xml.member "subnet" xml) Subnet.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.subnet (fun f ->
               Aws.Query.Pair ("Subnet", Subnet.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.subnet (fun f -> "subnet", Subnet.to_json f) ])

  let of_json j =
    { subnet = Aws.Util.option_map (Aws.Json.lookup j "subnet") Subnet.of_json }
end

module CopyTagsFromSource = struct
  type t = Volume

  let str_to_t = [ "volume", Volume ]

  let t_to_str = [ Volume, "volume" ]

  let to_string e = Aws.Util.of_option_exn (Aws.Util.list_find t_to_str e)

  let of_string s = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t s)

  let make v () = v

  let parse xml =
    Aws.Util.option_bind (String.parse xml) (fun s -> Aws.Util.list_find str_to_t s)

  let to_query v =
    Aws.Query.Value (Some (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v)))

  let to_json v = String.to_json (Aws.Util.of_option_exn (Aws.Util.list_find t_to_str v))

  let of_json j = Aws.Util.of_option_exn (Aws.Util.list_find str_to_t (String.of_json j))
end

module CreateSnapshotsRequest = struct
  type t =
    { description : String.t option
    ; instance_specification : InstanceSpecification.t
    ; tag_specifications : TagSpecificationList.t
    ; dry_run : Boolean.t option
    ; copy_tags_from_source : CopyTagsFromSource.t option
    }

  let make
      ?description
      ~instance_specification
      ?(tag_specifications = [])
      ?dry_run
      ?copy_tags_from_source
      () =
    { description
    ; instance_specification
    ; tag_specifications
    ; dry_run
    ; copy_tags_from_source
    }

  let parse xml =
    Some
      { description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; instance_specification =
          Aws.Xml.required
            "InstanceSpecification"
            (Aws.Util.option_bind
               (Aws.Xml.member "InstanceSpecification" xml)
               InstanceSpecification.parse)
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; copy_tags_from_source =
          Aws.Util.option_bind
            (Aws.Xml.member "CopyTagsFromSource" xml)
            CopyTagsFromSource.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.copy_tags_from_source (fun f ->
               Aws.Query.Pair ("CopyTagsFromSource", CopyTagsFromSource.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Some
             (Aws.Query.Pair
                ( "InstanceSpecification"
                , InstanceSpecification.to_query v.instance_specification ))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.copy_tags_from_source (fun f ->
               "CopyTagsFromSource", CopyTagsFromSource.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Some
             ( "InstanceSpecification"
             , InstanceSpecification.to_json v.instance_specification )
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ])

  let of_json j =
    { description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; instance_specification =
        InstanceSpecification.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceSpecification"))
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; copy_tags_from_source =
        Aws.Util.option_map
          (Aws.Json.lookup j "CopyTagsFromSource")
          CopyTagsFromSource.of_json
    }
end

module DescribeFpgaImageAttributeResult = struct
  type t = { fpga_image_attribute : FpgaImageAttribute.t option }

  let make ?fpga_image_attribute () = { fpga_image_attribute }

  let parse xml =
    Some
      { fpga_image_attribute =
          Aws.Util.option_bind
            (Aws.Xml.member "fpgaImageAttribute" xml)
            FpgaImageAttribute.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.fpga_image_attribute (fun f ->
               Aws.Query.Pair ("FpgaImageAttribute", FpgaImageAttribute.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.fpga_image_attribute (fun f ->
               "fpgaImageAttribute", FpgaImageAttribute.to_json f)
         ])

  let of_json j =
    { fpga_image_attribute =
        Aws.Util.option_map
          (Aws.Json.lookup j "fpgaImageAttribute")
          FpgaImageAttribute.of_json
    }
end

module TransitGatewayAttachmentPropagationList = struct
  type t = TransitGatewayAttachmentPropagation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map TransitGatewayAttachmentPropagation.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list TransitGatewayAttachmentPropagation.to_query v

  let to_json v = `List (List.map TransitGatewayAttachmentPropagation.to_json v)

  let of_json j = Aws.Json.to_list TransitGatewayAttachmentPropagation.of_json j
end

module InstanceBlockDeviceMappingSpecificationList = struct
  type t = InstanceBlockDeviceMappingSpecification.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map
         InstanceBlockDeviceMappingSpecification.parse
         (Aws.Xml.members "item" xml))

  let to_query v =
    Aws.Query.to_query_list InstanceBlockDeviceMappingSpecification.to_query v

  let to_json v = `List (List.map InstanceBlockDeviceMappingSpecification.to_json v)

  let of_json j = Aws.Json.to_list InstanceBlockDeviceMappingSpecification.of_json j
end

module ModifyInstanceAttributeRequest = struct
  type t =
    { source_dest_check : AttributeBooleanValue.t option
    ; attribute : InstanceAttributeName.t option
    ; block_device_mappings : InstanceBlockDeviceMappingSpecificationList.t
    ; disable_api_termination : AttributeBooleanValue.t option
    ; dry_run : Boolean.t option
    ; ebs_optimized : AttributeBooleanValue.t option
    ; ena_support : AttributeBooleanValue.t option
    ; groups : GroupIdStringList.t
    ; instance_id : String.t
    ; instance_initiated_shutdown_behavior : AttributeValue.t option
    ; instance_type : AttributeValue.t option
    ; kernel : AttributeValue.t option
    ; ramdisk : AttributeValue.t option
    ; sriov_net_support : AttributeValue.t option
    ; user_data : BlobAttributeValue.t option
    ; value : String.t option
    }

  let make
      ?source_dest_check
      ?attribute
      ?(block_device_mappings = [])
      ?disable_api_termination
      ?dry_run
      ?ebs_optimized
      ?ena_support
      ?(groups = [])
      ~instance_id
      ?instance_initiated_shutdown_behavior
      ?instance_type
      ?kernel
      ?ramdisk
      ?sriov_net_support
      ?user_data
      ?value
      () =
    { source_dest_check
    ; attribute
    ; block_device_mappings
    ; disable_api_termination
    ; dry_run
    ; ebs_optimized
    ; ena_support
    ; groups
    ; instance_id
    ; instance_initiated_shutdown_behavior
    ; instance_type
    ; kernel
    ; ramdisk
    ; sriov_net_support
    ; user_data
    ; value
    }

  let parse xml =
    Some
      { source_dest_check =
          Aws.Util.option_bind
            (Aws.Xml.member "SourceDestCheck" xml)
            AttributeBooleanValue.parse
      ; attribute =
          Aws.Util.option_bind
            (Aws.Xml.member "attribute" xml)
            InstanceAttributeName.parse
      ; block_device_mappings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "blockDeviceMapping" xml)
               InstanceBlockDeviceMappingSpecificationList.parse)
      ; disable_api_termination =
          Aws.Util.option_bind
            (Aws.Xml.member "disableApiTermination" xml)
            AttributeBooleanValue.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; ebs_optimized =
          Aws.Util.option_bind
            (Aws.Xml.member "ebsOptimized" xml)
            AttributeBooleanValue.parse
      ; ena_support =
          Aws.Util.option_bind
            (Aws.Xml.member "enaSupport" xml)
            AttributeBooleanValue.parse
      ; groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "GroupId" xml) GroupIdStringList.parse)
      ; instance_id =
          Aws.Xml.required
            "instanceId"
            (Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse)
      ; instance_initiated_shutdown_behavior =
          Aws.Util.option_bind
            (Aws.Xml.member "instanceInitiatedShutdownBehavior" xml)
            AttributeValue.parse
      ; instance_type =
          Aws.Util.option_bind (Aws.Xml.member "instanceType" xml) AttributeValue.parse
      ; kernel = Aws.Util.option_bind (Aws.Xml.member "kernel" xml) AttributeValue.parse
      ; ramdisk = Aws.Util.option_bind (Aws.Xml.member "ramdisk" xml) AttributeValue.parse
      ; sriov_net_support =
          Aws.Util.option_bind (Aws.Xml.member "sriovNetSupport" xml) AttributeValue.parse
      ; user_data =
          Aws.Util.option_bind (Aws.Xml.member "userData" xml) BlobAttributeValue.parse
      ; value = Aws.Util.option_bind (Aws.Xml.member "value" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", String.to_query f))
         ; Aws.Util.option_map v.user_data (fun f ->
               Aws.Query.Pair ("UserData", BlobAttributeValue.to_query f))
         ; Aws.Util.option_map v.sriov_net_support (fun f ->
               Aws.Query.Pair ("SriovNetSupport", AttributeValue.to_query f))
         ; Aws.Util.option_map v.ramdisk (fun f ->
               Aws.Query.Pair ("Ramdisk", AttributeValue.to_query f))
         ; Aws.Util.option_map v.kernel (fun f ->
               Aws.Query.Pair ("Kernel", AttributeValue.to_query f))
         ; Aws.Util.option_map v.instance_type (fun f ->
               Aws.Query.Pair ("InstanceType", AttributeValue.to_query f))
         ; Aws.Util.option_map v.instance_initiated_shutdown_behavior (fun f ->
               Aws.Query.Pair
                 ("InstanceInitiatedShutdownBehavior", AttributeValue.to_query f))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ; Some (Aws.Query.Pair ("GroupId", GroupIdStringList.to_query v.groups))
         ; Aws.Util.option_map v.ena_support (fun f ->
               Aws.Query.Pair ("EnaSupport", AttributeBooleanValue.to_query f))
         ; Aws.Util.option_map v.ebs_optimized (fun f ->
               Aws.Query.Pair ("EbsOptimized", AttributeBooleanValue.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.disable_api_termination (fun f ->
               Aws.Query.Pair ("DisableApiTermination", AttributeBooleanValue.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "BlockDeviceMapping"
                , InstanceBlockDeviceMappingSpecificationList.to_query
                    v.block_device_mappings ))
         ; Aws.Util.option_map v.attribute (fun f ->
               Aws.Query.Pair ("Attribute", InstanceAttributeName.to_query f))
         ; Aws.Util.option_map v.source_dest_check (fun f ->
               Aws.Query.Pair ("SourceDestCheck", AttributeBooleanValue.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.value (fun f -> "value", String.to_json f)
         ; Aws.Util.option_map v.user_data (fun f ->
               "userData", BlobAttributeValue.to_json f)
         ; Aws.Util.option_map v.sriov_net_support (fun f ->
               "sriovNetSupport", AttributeValue.to_json f)
         ; Aws.Util.option_map v.ramdisk (fun f -> "ramdisk", AttributeValue.to_json f)
         ; Aws.Util.option_map v.kernel (fun f -> "kernel", AttributeValue.to_json f)
         ; Aws.Util.option_map v.instance_type (fun f ->
               "instanceType", AttributeValue.to_json f)
         ; Aws.Util.option_map v.instance_initiated_shutdown_behavior (fun f ->
               "instanceInitiatedShutdownBehavior", AttributeValue.to_json f)
         ; Some ("instanceId", String.to_json v.instance_id)
         ; Some ("GroupId", GroupIdStringList.to_json v.groups)
         ; Aws.Util.option_map v.ena_support (fun f ->
               "enaSupport", AttributeBooleanValue.to_json f)
         ; Aws.Util.option_map v.ebs_optimized (fun f ->
               "ebsOptimized", AttributeBooleanValue.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.disable_api_termination (fun f ->
               "disableApiTermination", AttributeBooleanValue.to_json f)
         ; Some
             ( "blockDeviceMapping"
             , InstanceBlockDeviceMappingSpecificationList.to_json v.block_device_mappings
             )
         ; Aws.Util.option_map v.attribute (fun f ->
               "attribute", InstanceAttributeName.to_json f)
         ; Aws.Util.option_map v.source_dest_check (fun f ->
               "SourceDestCheck", AttributeBooleanValue.to_json f)
         ])

  let of_json j =
    { source_dest_check =
        Aws.Util.option_map
          (Aws.Json.lookup j "SourceDestCheck")
          AttributeBooleanValue.of_json
    ; attribute =
        Aws.Util.option_map (Aws.Json.lookup j "attribute") InstanceAttributeName.of_json
    ; block_device_mappings =
        InstanceBlockDeviceMappingSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "blockDeviceMapping"))
    ; disable_api_termination =
        Aws.Util.option_map
          (Aws.Json.lookup j "disableApiTermination")
          AttributeBooleanValue.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; ebs_optimized =
        Aws.Util.option_map
          (Aws.Json.lookup j "ebsOptimized")
          AttributeBooleanValue.of_json
    ; ena_support =
        Aws.Util.option_map (Aws.Json.lookup j "enaSupport") AttributeBooleanValue.of_json
    ; groups =
        GroupIdStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "GroupId"))
    ; instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceId"))
    ; instance_initiated_shutdown_behavior =
        Aws.Util.option_map
          (Aws.Json.lookup j "instanceInitiatedShutdownBehavior")
          AttributeValue.of_json
    ; instance_type =
        Aws.Util.option_map (Aws.Json.lookup j "instanceType") AttributeValue.of_json
    ; kernel = Aws.Util.option_map (Aws.Json.lookup j "kernel") AttributeValue.of_json
    ; ramdisk = Aws.Util.option_map (Aws.Json.lookup j "ramdisk") AttributeValue.of_json
    ; sriov_net_support =
        Aws.Util.option_map (Aws.Json.lookup j "sriovNetSupport") AttributeValue.of_json
    ; user_data =
        Aws.Util.option_map (Aws.Json.lookup j "userData") BlobAttributeValue.of_json
    ; value = Aws.Util.option_map (Aws.Json.lookup j "value") String.of_json
    }
end

module VpnConnectionIdStringList = struct
  type t = String.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map String.parse (Aws.Xml.members "VpnConnectionId" xml))

  let to_query v = Aws.Query.to_query_list String.to_query v

  let to_json v = `List (List.map String.to_json v)

  let of_json j = Aws.Json.to_list String.of_json j
end

module AttachClassicLinkVpcRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; groups : GroupIdStringList.t
    ; instance_id : String.t
    ; vpc_id : String.t
    }

  let make ?dry_run ~groups ~instance_id ~vpc_id () =
    { dry_run; groups; instance_id; vpc_id }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; groups =
          Aws.Xml.required
            "SecurityGroupId"
            (Aws.Util.option_bind
               (Aws.Xml.member "SecurityGroupId" xml)
               GroupIdStringList.parse)
      ; instance_id =
          Aws.Xml.required
            "instanceId"
            (Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse)
      ; vpc_id =
          Aws.Xml.required
            "vpcId"
            (Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ; Some (Aws.Query.Pair ("SecurityGroupId", GroupIdStringList.to_query v.groups))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("vpcId", String.to_json v.vpc_id)
         ; Some ("instanceId", String.to_json v.instance_id)
         ; Some ("SecurityGroupId", GroupIdStringList.to_json v.groups)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; groups =
        GroupIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SecurityGroupId"))
    ; instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceId"))
    ; vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "vpcId"))
    }
end

module DetachClassicLinkVpcRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; instance_id : String.t
    ; vpc_id : String.t
    }

  let make ?dry_run ~instance_id ~vpc_id () = { dry_run; instance_id; vpc_id }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; instance_id =
          Aws.Xml.required
            "instanceId"
            (Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse)
      ; vpc_id =
          Aws.Xml.required
            "vpcId"
            (Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("vpcId", String.to_json v.vpc_id)
         ; Some ("instanceId", String.to_json v.instance_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceId"))
    ; vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "vpcId"))
    }
end

module DescribeSnapshotAttributeRequest = struct
  type t =
    { attribute : SnapshotAttributeName.t
    ; snapshot_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~attribute ~snapshot_id ?dry_run () = { attribute; snapshot_id; dry_run }

  let parse xml =
    Some
      { attribute =
          Aws.Xml.required
            "Attribute"
            (Aws.Util.option_bind
               (Aws.Xml.member "Attribute" xml)
               SnapshotAttributeName.parse)
      ; snapshot_id =
          Aws.Xml.required
            "SnapshotId"
            (Aws.Util.option_bind (Aws.Xml.member "SnapshotId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("SnapshotId", String.to_query v.snapshot_id))
         ; Some (Aws.Query.Pair ("Attribute", SnapshotAttributeName.to_query v.attribute))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("SnapshotId", String.to_json v.snapshot_id)
         ; Some ("Attribute", SnapshotAttributeName.to_json v.attribute)
         ])

  let of_json j =
    { attribute =
        SnapshotAttributeName.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Attribute"))
    ; snapshot_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SnapshotId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module DescribeSpotFleetInstancesResponse = struct
  type t =
    { active_instances : ActiveInstanceSet.t
    ; next_token : String.t option
    ; spot_fleet_request_id : String.t option
    }

  let make ?(active_instances = []) ?next_token ?spot_fleet_request_id () =
    { active_instances; next_token; spot_fleet_request_id }

  let parse xml =
    Some
      { active_instances =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "activeInstanceSet" xml)
               ActiveInstanceSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; spot_fleet_request_id =
          Aws.Util.option_bind (Aws.Xml.member "spotFleetRequestId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.spot_fleet_request_id (fun f ->
               Aws.Query.Pair ("SpotFleetRequestId", String.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ActiveInstanceSet", ActiveInstanceSet.to_query v.active_instances))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.spot_fleet_request_id (fun f ->
               "spotFleetRequestId", String.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("activeInstanceSet", ActiveInstanceSet.to_json v.active_instances)
         ])

  let of_json j =
    { active_instances =
        ActiveInstanceSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "activeInstanceSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; spot_fleet_request_id =
        Aws.Util.option_map (Aws.Json.lookup j "spotFleetRequestId") String.of_json
    }
end

module DeleteLaunchTemplateResult = struct
  type t = { launch_template : LaunchTemplate.t option }

  let make ?launch_template () = { launch_template }

  let parse xml =
    Some
      { launch_template =
          Aws.Util.option_bind (Aws.Xml.member "launchTemplate" xml) LaunchTemplate.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.launch_template (fun f ->
               Aws.Query.Pair ("LaunchTemplate", LaunchTemplate.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.launch_template (fun f ->
               "launchTemplate", LaunchTemplate.to_json f)
         ])

  let of_json j =
    { launch_template =
        Aws.Util.option_map (Aws.Json.lookup j "launchTemplate") LaunchTemplate.of_json
    }
end

module GetDefaultCreditSpecificationResult = struct
  type t =
    { instance_family_credit_specification : InstanceFamilyCreditSpecification.t option }

  let make ?instance_family_credit_specification () =
    { instance_family_credit_specification }

  let parse xml =
    Some
      { instance_family_credit_specification =
          Aws.Util.option_bind
            (Aws.Xml.member "instanceFamilyCreditSpecification" xml)
            InstanceFamilyCreditSpecification.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_family_credit_specification (fun f ->
               Aws.Query.Pair
                 ( "InstanceFamilyCreditSpecification"
                 , InstanceFamilyCreditSpecification.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_family_credit_specification (fun f ->
               ( "instanceFamilyCreditSpecification"
               , InstanceFamilyCreditSpecification.to_json f ))
         ])

  let of_json j =
    { instance_family_credit_specification =
        Aws.Util.option_map
          (Aws.Json.lookup j "instanceFamilyCreditSpecification")
          InstanceFamilyCreditSpecification.of_json
    }
end

module ModifyVolumeRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; volume_id : String.t
    ; size : Integer.t option
    ; volume_type : VolumeType.t option
    ; iops : Integer.t option
    }

  let make ?dry_run ~volume_id ?size ?volume_type ?iops () =
    { dry_run; volume_id; size; volume_type; iops }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; volume_id =
          Aws.Xml.required
            "VolumeId"
            (Aws.Util.option_bind (Aws.Xml.member "VolumeId" xml) String.parse)
      ; size = Aws.Util.option_bind (Aws.Xml.member "Size" xml) Integer.parse
      ; volume_type =
          Aws.Util.option_bind (Aws.Xml.member "VolumeType" xml) VolumeType.parse
      ; iops = Aws.Util.option_bind (Aws.Xml.member "Iops" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.iops (fun f ->
               Aws.Query.Pair ("Iops", Integer.to_query f))
         ; Aws.Util.option_map v.volume_type (fun f ->
               Aws.Query.Pair ("VolumeType", VolumeType.to_query f))
         ; Aws.Util.option_map v.size (fun f ->
               Aws.Query.Pair ("Size", Integer.to_query f))
         ; Some (Aws.Query.Pair ("VolumeId", String.to_query v.volume_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.iops (fun f -> "Iops", Integer.to_json f)
         ; Aws.Util.option_map v.volume_type (fun f -> "VolumeType", VolumeType.to_json f)
         ; Aws.Util.option_map v.size (fun f -> "Size", Integer.to_json f)
         ; Some ("VolumeId", String.to_json v.volume_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; volume_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VolumeId"))
    ; size = Aws.Util.option_map (Aws.Json.lookup j "Size") Integer.of_json
    ; volume_type =
        Aws.Util.option_map (Aws.Json.lookup j "VolumeType") VolumeType.of_json
    ; iops = Aws.Util.option_map (Aws.Json.lookup j "Iops") Integer.of_json
    }
end

module ModifyInstancePlacementResult = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module DescribeVpnConnectionsRequest = struct
  type t =
    { filters : FilterList.t
    ; vpn_connection_ids : VpnConnectionIdStringList.t
    ; dry_run : Boolean.t option
    }

  let make ?(filters = []) ?(vpn_connection_ids = []) ?dry_run () =
    { filters; vpn_connection_ids; dry_run }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; vpn_connection_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "VpnConnectionId" xml)
               VpnConnectionIdStringList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "VpnConnectionId"
                , VpnConnectionIdStringList.to_query v.vpn_connection_ids ))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("VpnConnectionId", VpnConnectionIdStringList.to_json v.vpn_connection_ids)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; vpn_connection_ids =
        VpnConnectionIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpnConnectionId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module DeprovisionByoipCidrResult = struct
  type t = { byoip_cidr : ByoipCidr.t option }

  let make ?byoip_cidr () = { byoip_cidr }

  let parse xml =
    Some
      { byoip_cidr = Aws.Util.option_bind (Aws.Xml.member "byoipCidr" xml) ByoipCidr.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.byoip_cidr (fun f ->
               Aws.Query.Pair ("ByoipCidr", ByoipCidr.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.byoip_cidr (fun f -> "byoipCidr", ByoipCidr.to_json f) ])

  let of_json j =
    { byoip_cidr = Aws.Util.option_map (Aws.Json.lookup j "byoipCidr") ByoipCidr.of_json }
end

module DescribeTrafficMirrorSessionsRequest = struct
  type t =
    { traffic_mirror_session_ids : TrafficMirrorSessionIdList.t
    ; dry_run : Boolean.t option
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make
      ?(traffic_mirror_session_ids = [])
      ?dry_run
      ?(filters = [])
      ?max_results
      ?next_token
      () =
    { traffic_mirror_session_ids; dry_run; filters; max_results; next_token }

  let parse xml =
    Some
      { traffic_mirror_session_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TrafficMirrorSessionId" xml)
               TrafficMirrorSessionIdList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TrafficMirrorSessionId"
                , TrafficMirrorSessionIdList.to_query v.traffic_mirror_session_ids ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ( "TrafficMirrorSessionId"
             , TrafficMirrorSessionIdList.to_json v.traffic_mirror_session_ids )
         ])

  let of_json j =
    { traffic_mirror_session_ids =
        TrafficMirrorSessionIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TrafficMirrorSessionId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module DeleteLocalGatewayRouteRequest = struct
  type t =
    { destination_cidr_block : String.t
    ; local_gateway_route_table_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~destination_cidr_block ~local_gateway_route_table_id ?dry_run () =
    { destination_cidr_block; local_gateway_route_table_id; dry_run }

  let parse xml =
    Some
      { destination_cidr_block =
          Aws.Xml.required
            "DestinationCidrBlock"
            (Aws.Util.option_bind
               (Aws.Xml.member "DestinationCidrBlock" xml)
               String.parse)
      ; local_gateway_route_table_id =
          Aws.Xml.required
            "LocalGatewayRouteTableId"
            (Aws.Util.option_bind
               (Aws.Xml.member "LocalGatewayRouteTableId" xml)
               String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "LocalGatewayRouteTableId"
                , String.to_query v.local_gateway_route_table_id ))
         ; Some
             (Aws.Query.Pair
                ("DestinationCidrBlock", String.to_query v.destination_cidr_block))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("LocalGatewayRouteTableId", String.to_json v.local_gateway_route_table_id)
         ; Some ("DestinationCidrBlock", String.to_json v.destination_cidr_block)
         ])

  let of_json j =
    { destination_cidr_block =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DestinationCidrBlock"))
    ; local_gateway_route_table_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "LocalGatewayRouteTableId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module CreateTransitGatewayMulticastDomainRequest = struct
  type t =
    { transit_gateway_id : String.t
    ; tag_specifications : TagSpecificationList.t
    ; dry_run : Boolean.t option
    }

  let make ~transit_gateway_id ?(tag_specifications = []) ?dry_run () =
    { transit_gateway_id; tag_specifications; dry_run }

  let parse xml =
    Some
      { transit_gateway_id =
          Aws.Xml.required
            "TransitGatewayId"
            (Aws.Util.option_bind (Aws.Xml.member "TransitGatewayId" xml) String.parse)
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Some
             (Aws.Query.Pair ("TransitGatewayId", String.to_query v.transit_gateway_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Some ("TransitGatewayId", String.to_json v.transit_gateway_id)
         ])

  let of_json j =
    { transit_gateway_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayId"))
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module GetTransitGatewayAttachmentPropagationsRequest = struct
  type t =
    { transit_gateway_attachment_id : String.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make
      ~transit_gateway_attachment_id
      ?(filters = [])
      ?max_results
      ?next_token
      ?dry_run
      () =
    { transit_gateway_attachment_id; filters; max_results; next_token; dry_run }

  let parse xml =
    Some
      { transit_gateway_attachment_id =
          Aws.Xml.required
            "TransitGatewayAttachmentId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayAttachmentId" xml)
               String.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayAttachmentId"
                , String.to_query v.transit_gateway_attachment_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some
             ("TransitGatewayAttachmentId", String.to_json v.transit_gateway_attachment_id)
         ])

  let of_json j =
    { transit_gateway_attachment_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayAttachmentId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DescribePrefixListsResult = struct
  type t =
    { next_token : String.t option
    ; prefix_lists : PrefixListSet.t
    }

  let make ?next_token ?(prefix_lists = []) () = { next_token; prefix_lists }

  let parse xml =
    Some
      { next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; prefix_lists =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "prefixListSet" xml)
               PrefixListSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("PrefixListSet", PrefixListSet.to_query v.prefix_lists))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("prefixListSet", PrefixListSet.to_json v.prefix_lists)
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ])

  let of_json j =
    { next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; prefix_lists =
        PrefixListSet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "prefixListSet"))
    }
end

module LaunchTemplateSet = struct
  type t = LaunchTemplate.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map LaunchTemplate.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list LaunchTemplate.to_query v

  let to_json v = `List (List.map LaunchTemplate.to_json v)

  let of_json j = Aws.Json.to_list LaunchTemplate.of_json j
end

module DescribeLaunchTemplatesResult = struct
  type t =
    { launch_templates : LaunchTemplateSet.t
    ; next_token : String.t option
    }

  let make ?(launch_templates = []) ?next_token () = { launch_templates; next_token }

  let parse xml =
    Some
      { launch_templates =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "launchTemplates" xml)
               LaunchTemplateSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("LaunchTemplates", LaunchTemplateSet.to_query v.launch_templates))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("launchTemplates", LaunchTemplateSet.to_json v.launch_templates)
         ])

  let of_json j =
    { launch_templates =
        LaunchTemplateSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "launchTemplates"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DisassociateTransitGatewayMulticastDomainResult = struct
  type t = { associations : TransitGatewayMulticastDomainAssociations.t option }

  let make ?associations () = { associations }

  let parse xml =
    Some
      { associations =
          Aws.Util.option_bind
            (Aws.Xml.member "associations" xml)
            TransitGatewayMulticastDomainAssociations.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.associations (fun f ->
               Aws.Query.Pair
                 ("Associations", TransitGatewayMulticastDomainAssociations.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.associations (fun f ->
               "associations", TransitGatewayMulticastDomainAssociations.to_json f)
         ])

  let of_json j =
    { associations =
        Aws.Util.option_map
          (Aws.Json.lookup j "associations")
          TransitGatewayMulticastDomainAssociations.of_json
    }
end

module DescribeCustomerGatewaysRequest = struct
  type t =
    { customer_gateway_ids : CustomerGatewayIdStringList.t
    ; filters : FilterList.t
    ; dry_run : Boolean.t option
    }

  let make ?(customer_gateway_ids = []) ?(filters = []) ?dry_run () =
    { customer_gateway_ids; filters; dry_run }

  let parse xml =
    Some
      { customer_gateway_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "CustomerGatewayId" xml)
               CustomerGatewayIdStringList.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ( "CustomerGatewayId"
                , CustomerGatewayIdStringList.to_query v.customer_gateway_ids ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some
             ( "CustomerGatewayId"
             , CustomerGatewayIdStringList.to_json v.customer_gateway_ids )
         ])

  let of_json j =
    { customer_gateway_ids =
        CustomerGatewayIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "CustomerGatewayId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module DescribeHostsResult = struct
  type t =
    { hosts : HostList.t
    ; next_token : String.t option
    }

  let make ?(hosts = []) ?next_token () = { hosts; next_token }

  let parse xml =
    Some
      { hosts =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "hostSet" xml) HostList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("HostSet", HostList.to_query v.hosts))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("hostSet", HostList.to_json v.hosts)
         ])

  let of_json j =
    { hosts = HostList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "hostSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module CreateLaunchTemplateVersionResult = struct
  type t =
    { launch_template_version : LaunchTemplateVersion.t option
    ; warning : ValidationWarning.t option
    }

  let make ?launch_template_version ?warning () = { launch_template_version; warning }

  let parse xml =
    Some
      { launch_template_version =
          Aws.Util.option_bind
            (Aws.Xml.member "launchTemplateVersion" xml)
            LaunchTemplateVersion.parse
      ; warning =
          Aws.Util.option_bind (Aws.Xml.member "warning" xml) ValidationWarning.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.warning (fun f ->
               Aws.Query.Pair ("Warning", ValidationWarning.to_query f))
         ; Aws.Util.option_map v.launch_template_version (fun f ->
               Aws.Query.Pair ("LaunchTemplateVersion", LaunchTemplateVersion.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.warning (fun f -> "warning", ValidationWarning.to_json f)
         ; Aws.Util.option_map v.launch_template_version (fun f ->
               "launchTemplateVersion", LaunchTemplateVersion.to_json f)
         ])

  let of_json j =
    { launch_template_version =
        Aws.Util.option_map
          (Aws.Json.lookup j "launchTemplateVersion")
          LaunchTemplateVersion.of_json
    ; warning =
        Aws.Util.option_map (Aws.Json.lookup j "warning") ValidationWarning.of_json
    }
end

module CreateCapacityReservationResult = struct
  type t = { capacity_reservation : CapacityReservation.t option }

  let make ?capacity_reservation () = { capacity_reservation }

  let parse xml =
    Some
      { capacity_reservation =
          Aws.Util.option_bind
            (Aws.Xml.member "capacityReservation" xml)
            CapacityReservation.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.capacity_reservation (fun f ->
               Aws.Query.Pair ("CapacityReservation", CapacityReservation.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.capacity_reservation (fun f ->
               "capacityReservation", CapacityReservation.to_json f)
         ])

  let of_json j =
    { capacity_reservation =
        Aws.Util.option_map
          (Aws.Json.lookup j "capacityReservation")
          CapacityReservation.of_json
    }
end

module CreateVpnGatewayResult = struct
  type t = { vpn_gateway : VpnGateway.t option }

  let make ?vpn_gateway () = { vpn_gateway }

  let parse xml =
    Some
      { vpn_gateway =
          Aws.Util.option_bind (Aws.Xml.member "vpnGateway" xml) VpnGateway.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpn_gateway (fun f ->
               Aws.Query.Pair ("VpnGateway", VpnGateway.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpn_gateway (fun f -> "vpnGateway", VpnGateway.to_json f)
         ])

  let of_json j =
    { vpn_gateway =
        Aws.Util.option_map (Aws.Json.lookup j "vpnGateway") VpnGateway.of_json
    }
end

module SearchTransitGatewayMulticastGroupsRequest = struct
  type t =
    { transit_gateway_multicast_domain_id : String.t option
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make
      ?transit_gateway_multicast_domain_id
      ?(filters = [])
      ?max_results
      ?next_token
      ?dry_run
      () =
    { transit_gateway_multicast_domain_id; filters; max_results; next_token; dry_run }

  let parse xml =
    Some
      { transit_gateway_multicast_domain_id =
          Aws.Util.option_bind
            (Aws.Xml.member "TransitGatewayMulticastDomainId" xml)
            String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               Aws.Query.Pair ("TransitGatewayMulticastDomainId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               "TransitGatewayMulticastDomainId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_multicast_domain_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "TransitGatewayMulticastDomainId")
          String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module AdvertiseByoipCidrRequest = struct
  type t =
    { cidr : String.t
    ; dry_run : Boolean.t option
    }

  let make ~cidr ?dry_run () = { cidr; dry_run }

  let parse xml =
    Some
      { cidr =
          Aws.Xml.required
            "Cidr"
            (Aws.Util.option_bind (Aws.Xml.member "Cidr" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Cidr", String.to_query v.cidr))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("Cidr", String.to_json v.cidr)
         ])

  let of_json j =
    { cidr = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Cidr"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DeleteTrafficMirrorTargetRequest = struct
  type t =
    { traffic_mirror_target_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~traffic_mirror_target_id ?dry_run () = { traffic_mirror_target_id; dry_run }

  let parse xml =
    Some
      { traffic_mirror_target_id =
          Aws.Xml.required
            "TrafficMirrorTargetId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TrafficMirrorTargetId" xml)
               String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TrafficMirrorTargetId", String.to_query v.traffic_mirror_target_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("TrafficMirrorTargetId", String.to_json v.traffic_mirror_target_id)
         ])

  let of_json j =
    { traffic_mirror_target_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TrafficMirrorTargetId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module AllocateHostsResult = struct
  type t = { host_ids : ResponseHostIdList.t }

  let make ?(host_ids = []) () = { host_ids }

  let parse xml =
    Some
      { host_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "hostIdSet" xml)
               ResponseHostIdList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("HostIdSet", ResponseHostIdList.to_query v.host_ids)) ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("hostIdSet", ResponseHostIdList.to_json v.host_ids) ])

  let of_json j =
    { host_ids =
        ResponseHostIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "hostIdSet"))
    }
end

module CopySnapshotResult = struct
  type t =
    { snapshot_id : String.t option
    ; tags : TagList.t
    }

  let make ?snapshot_id ?(tags = []) () = { snapshot_id; tags }

  let parse xml =
    Some
      { snapshot_id = Aws.Util.option_bind (Aws.Xml.member "snapshotId" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagList.to_query v.tags))
         ; Aws.Util.option_map v.snapshot_id (fun f ->
               Aws.Query.Pair ("SnapshotId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagList.to_json v.tags)
         ; Aws.Util.option_map v.snapshot_id (fun f -> "snapshotId", String.to_json f)
         ])

  let of_json j =
    { snapshot_id = Aws.Util.option_map (Aws.Json.lookup j "snapshotId") String.of_json
    ; tags = TagList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module ResetInstanceAttributeRequest = struct
  type t =
    { attribute : InstanceAttributeName.t
    ; dry_run : Boolean.t option
    ; instance_id : String.t
    }

  let make ~attribute ?dry_run ~instance_id () = { attribute; dry_run; instance_id }

  let parse xml =
    Some
      { attribute =
          Aws.Xml.required
            "attribute"
            (Aws.Util.option_bind
               (Aws.Xml.member "attribute" xml)
               InstanceAttributeName.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; instance_id =
          Aws.Xml.required
            "instanceId"
            (Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Attribute", InstanceAttributeName.to_query v.attribute))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("instanceId", String.to_json v.instance_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("attribute", InstanceAttributeName.to_json v.attribute)
         ])

  let of_json j =
    { attribute =
        InstanceAttributeName.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "attribute"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceId"))
    }
end

module ModifyTrafficMirrorFilterNetworkServicesResult = struct
  type t = { traffic_mirror_filter : TrafficMirrorFilter.t option }

  let make ?traffic_mirror_filter () = { traffic_mirror_filter }

  let parse xml =
    Some
      { traffic_mirror_filter =
          Aws.Util.option_bind
            (Aws.Xml.member "trafficMirrorFilter" xml)
            TrafficMirrorFilter.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.traffic_mirror_filter (fun f ->
               Aws.Query.Pair ("TrafficMirrorFilter", TrafficMirrorFilter.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.traffic_mirror_filter (fun f ->
               "trafficMirrorFilter", TrafficMirrorFilter.to_json f)
         ])

  let of_json j =
    { traffic_mirror_filter =
        Aws.Util.option_map
          (Aws.Json.lookup j "trafficMirrorFilter")
          TrafficMirrorFilter.of_json
    }
end

module DisassociateSubnetCidrBlockRequest = struct
  type t = { association_id : String.t }

  let make ~association_id () = { association_id }

  let parse xml =
    Some
      { association_id =
          Aws.Xml.required
            "associationId"
            (Aws.Util.option_bind (Aws.Xml.member "associationId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("AssociationId", String.to_query v.association_id)) ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("associationId", String.to_json v.association_id) ])

  let of_json j =
    { association_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "associationId"))
    }
end

module CancelImportTaskResult = struct
  type t =
    { import_task_id : String.t option
    ; previous_state : String.t option
    ; state : String.t option
    }

  let make ?import_task_id ?previous_state ?state () =
    { import_task_id; previous_state; state }

  let parse xml =
    Some
      { import_task_id =
          Aws.Util.option_bind (Aws.Xml.member "importTaskId" xml) String.parse
      ; previous_state =
          Aws.Util.option_bind (Aws.Xml.member "previousState" xml) String.parse
      ; state = Aws.Util.option_bind (Aws.Xml.member "state" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f ->
               Aws.Query.Pair ("State", String.to_query f))
         ; Aws.Util.option_map v.previous_state (fun f ->
               Aws.Query.Pair ("PreviousState", String.to_query f))
         ; Aws.Util.option_map v.import_task_id (fun f ->
               Aws.Query.Pair ("ImportTaskId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.state (fun f -> "state", String.to_json f)
         ; Aws.Util.option_map v.previous_state (fun f ->
               "previousState", String.to_json f)
         ; Aws.Util.option_map v.import_task_id (fun f ->
               "importTaskId", String.to_json f)
         ])

  let of_json j =
    { import_task_id =
        Aws.Util.option_map (Aws.Json.lookup j "importTaskId") String.of_json
    ; previous_state =
        Aws.Util.option_map (Aws.Json.lookup j "previousState") String.of_json
    ; state = Aws.Util.option_map (Aws.Json.lookup j "state") String.of_json
    }
end

module DescribeSpotPriceHistoryRequest = struct
  type t =
    { filters : FilterList.t
    ; availability_zone : String.t option
    ; dry_run : Boolean.t option
    ; end_time : DateTime.t option
    ; instance_types : InstanceTypeList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; product_descriptions : ProductDescriptionList.t
    ; start_time : DateTime.t option
    }

  let make
      ?(filters = [])
      ?availability_zone
      ?dry_run
      ?end_time
      ?(instance_types = [])
      ?max_results
      ?next_token
      ?(product_descriptions = [])
      ?start_time
      () =
    { filters
    ; availability_zone
    ; dry_run
    ; end_time
    ; instance_types
    ; max_results
    ; next_token
    ; product_descriptions
    ; start_time
    }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZone" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; end_time = Aws.Util.option_bind (Aws.Xml.member "endTime" xml) DateTime.parse
      ; instance_types =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "InstanceType" xml)
               InstanceTypeList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "maxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; product_descriptions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ProductDescription" xml)
               ProductDescriptionList.parse)
      ; start_time = Aws.Util.option_bind (Aws.Xml.member "startTime" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.start_time (fun f ->
               Aws.Query.Pair ("StartTime", DateTime.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ProductDescription"
                , ProductDescriptionList.to_query v.product_descriptions ))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair ("InstanceType", InstanceTypeList.to_query v.instance_types))
         ; Aws.Util.option_map v.end_time (fun f ->
               Aws.Query.Pair ("EndTime", DateTime.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.start_time (fun f -> "startTime", DateTime.to_json f)
         ; Some
             ("ProductDescription", ProductDescriptionList.to_json v.product_descriptions)
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "maxResults", Integer.to_json f)
         ; Some ("InstanceType", InstanceTypeList.to_json v.instance_types)
         ; Aws.Util.option_map v.end_time (fun f -> "endTime", DateTime.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "availabilityZone", String.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZone") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; end_time = Aws.Util.option_map (Aws.Json.lookup j "endTime") DateTime.of_json
    ; instance_types =
        InstanceTypeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceType"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "maxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; product_descriptions =
        ProductDescriptionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ProductDescription"))
    ; start_time = Aws.Util.option_map (Aws.Json.lookup j "startTime") DateTime.of_json
    }
end

module TagDescription = struct
  type t =
    { key : String.t
    ; resource_id : String.t
    ; resource_type : ResourceType.t
    ; value : String.t
    }

  let make ~key ~resource_id ~resource_type ~value () =
    { key; resource_id; resource_type; value }

  let parse xml =
    Some
      { key =
          Aws.Xml.required
            "key"
            (Aws.Util.option_bind (Aws.Xml.member "key" xml) String.parse)
      ; resource_id =
          Aws.Xml.required
            "resourceId"
            (Aws.Util.option_bind (Aws.Xml.member "resourceId" xml) String.parse)
      ; resource_type =
          Aws.Xml.required
            "resourceType"
            (Aws.Util.option_bind (Aws.Xml.member "resourceType" xml) ResourceType.parse)
      ; value =
          Aws.Xml.required
            "value"
            (Aws.Util.option_bind (Aws.Xml.member "value" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Value", String.to_query v.value))
         ; Some (Aws.Query.Pair ("ResourceType", ResourceType.to_query v.resource_type))
         ; Some (Aws.Query.Pair ("ResourceId", String.to_query v.resource_id))
         ; Some (Aws.Query.Pair ("Key", String.to_query v.key))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("value", String.to_json v.value)
         ; Some ("resourceType", ResourceType.to_json v.resource_type)
         ; Some ("resourceId", String.to_json v.resource_id)
         ; Some ("key", String.to_json v.key)
         ])

  let of_json j =
    { key = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "key"))
    ; resource_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "resourceId"))
    ; resource_type =
        ResourceType.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "resourceType"))
    ; value = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "value"))
    }
end

module TagDescriptionList = struct
  type t = TagDescription.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map TagDescription.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list TagDescription.to_query v

  let to_json v = `List (List.map TagDescription.to_json v)

  let of_json j = Aws.Json.to_list TagDescription.of_json j
end

module AssociateTransitGatewayRouteTableResult = struct
  type t = { association : TransitGatewayAssociation.t option }

  let make ?association () = { association }

  let parse xml =
    Some
      { association =
          Aws.Util.option_bind
            (Aws.Xml.member "association" xml)
            TransitGatewayAssociation.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association (fun f ->
               Aws.Query.Pair ("Association", TransitGatewayAssociation.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association (fun f ->
               "association", TransitGatewayAssociation.to_json f)
         ])

  let of_json j =
    { association =
        Aws.Util.option_map
          (Aws.Json.lookup j "association")
          TransitGatewayAssociation.of_json
    }
end

module CancelSpotInstanceRequestsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; spot_instance_request_ids : SpotInstanceRequestIdList.t
    }

  let make ?dry_run ~spot_instance_request_ids () = { dry_run; spot_instance_request_ids }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; spot_instance_request_ids =
          Aws.Xml.required
            "SpotInstanceRequestId"
            (Aws.Util.option_bind
               (Aws.Xml.member "SpotInstanceRequestId" xml)
               SpotInstanceRequestIdList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "SpotInstanceRequestId"
                , SpotInstanceRequestIdList.to_query v.spot_instance_request_ids ))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "SpotInstanceRequestId"
             , SpotInstanceRequestIdList.to_json v.spot_instance_request_ids )
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; spot_instance_request_ids =
        SpotInstanceRequestIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SpotInstanceRequestId"))
    }
end

module CreateTrafficMirrorTargetRequest = struct
  type t =
    { network_interface_id : String.t option
    ; network_load_balancer_arn : String.t option
    ; description : String.t option
    ; tag_specifications : TagSpecificationList.t
    ; dry_run : Boolean.t option
    ; client_token : String.t option
    }

  let make
      ?network_interface_id
      ?network_load_balancer_arn
      ?description
      ?(tag_specifications = [])
      ?dry_run
      ?client_token
      () =
    { network_interface_id
    ; network_load_balancer_arn
    ; description
    ; tag_specifications
    ; dry_run
    ; client_token
    }

  let parse xml =
    Some
      { network_interface_id =
          Aws.Util.option_bind (Aws.Xml.member "NetworkInterfaceId" xml) String.parse
      ; network_load_balancer_arn =
          Aws.Util.option_bind (Aws.Xml.member "NetworkLoadBalancerArn" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.network_load_balancer_arn (fun f ->
               Aws.Query.Pair ("NetworkLoadBalancerArn", String.to_query f))
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               Aws.Query.Pair ("NetworkInterfaceId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.network_load_balancer_arn (fun f ->
               "NetworkLoadBalancerArn", String.to_json f)
         ; Aws.Util.option_map v.network_interface_id (fun f ->
               "NetworkInterfaceId", String.to_json f)
         ])

  let of_json j =
    { network_interface_id =
        Aws.Util.option_map (Aws.Json.lookup j "NetworkInterfaceId") String.of_json
    ; network_load_balancer_arn =
        Aws.Util.option_map (Aws.Json.lookup j "NetworkLoadBalancerArn") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    }
end

module DeleteVpnConnectionRequest = struct
  type t =
    { vpn_connection_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~vpn_connection_id ?dry_run () = { vpn_connection_id; dry_run }

  let parse xml =
    Some
      { vpn_connection_id =
          Aws.Xml.required
            "VpnConnectionId"
            (Aws.Util.option_bind (Aws.Xml.member "VpnConnectionId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("VpnConnectionId", String.to_query v.vpn_connection_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("VpnConnectionId", String.to_json v.vpn_connection_id)
         ])

  let of_json j =
    { vpn_connection_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpnConnectionId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module CreateTransitGatewayResult = struct
  type t = { transit_gateway : TransitGateway.t option }

  let make ?transit_gateway () = { transit_gateway }

  let parse xml =
    Some
      { transit_gateway =
          Aws.Util.option_bind (Aws.Xml.member "transitGateway" xml) TransitGateway.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway (fun f ->
               Aws.Query.Pair ("TransitGateway", TransitGateway.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway (fun f ->
               "transitGateway", TransitGateway.to_json f)
         ])

  let of_json j =
    { transit_gateway =
        Aws.Util.option_map (Aws.Json.lookup j "transitGateway") TransitGateway.of_json
    }
end

module DescribeNetworkInterfacePermissionsResult = struct
  type t =
    { network_interface_permissions : NetworkInterfacePermissionList.t
    ; next_token : String.t option
    }

  let make ?(network_interface_permissions = []) ?next_token () =
    { network_interface_permissions; next_token }

  let parse xml =
    Some
      { network_interface_permissions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "networkInterfacePermissions" xml)
               NetworkInterfacePermissionList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "NetworkInterfacePermissions"
                , NetworkInterfacePermissionList.to_query v.network_interface_permissions
                ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "networkInterfacePermissions"
             , NetworkInterfacePermissionList.to_json v.network_interface_permissions )
         ])

  let of_json j =
    { network_interface_permissions =
        NetworkInterfacePermissionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "networkInterfacePermissions"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module CreateTrafficMirrorFilterRuleResult = struct
  type t =
    { traffic_mirror_filter_rule : TrafficMirrorFilterRule.t option
    ; client_token : String.t option
    }

  let make ?traffic_mirror_filter_rule ?client_token () =
    { traffic_mirror_filter_rule; client_token }

  let parse xml =
    Some
      { traffic_mirror_filter_rule =
          Aws.Util.option_bind
            (Aws.Xml.member "trafficMirrorFilterRule" xml)
            TrafficMirrorFilterRule.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "clientToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.traffic_mirror_filter_rule (fun f ->
               Aws.Query.Pair
                 ("TrafficMirrorFilterRule", TrafficMirrorFilterRule.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f -> "clientToken", String.to_json f)
         ; Aws.Util.option_map v.traffic_mirror_filter_rule (fun f ->
               "trafficMirrorFilterRule", TrafficMirrorFilterRule.to_json f)
         ])

  let of_json j =
    { traffic_mirror_filter_rule =
        Aws.Util.option_map
          (Aws.Json.lookup j "trafficMirrorFilterRule")
          TrafficMirrorFilterRule.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "clientToken") String.of_json
    }
end

module DescribeImportSnapshotTasksResult = struct
  type t =
    { import_snapshot_tasks : ImportSnapshotTaskList.t
    ; next_token : String.t option
    }

  let make ?(import_snapshot_tasks = []) ?next_token () =
    { import_snapshot_tasks; next_token }

  let parse xml =
    Some
      { import_snapshot_tasks =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "importSnapshotTaskSet" xml)
               ImportSnapshotTaskList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ImportSnapshotTaskSet"
                , ImportSnapshotTaskList.to_query v.import_snapshot_tasks ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "importSnapshotTaskSet"
             , ImportSnapshotTaskList.to_json v.import_snapshot_tasks )
         ])

  let of_json j =
    { import_snapshot_tasks =
        ImportSnapshotTaskList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "importSnapshotTaskSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module PriceScheduleSpecificationList = struct
  type t = PriceScheduleSpecification.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map PriceScheduleSpecification.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list PriceScheduleSpecification.to_query v

  let to_json v = `List (List.map PriceScheduleSpecification.to_json v)

  let of_json j = Aws.Json.to_list PriceScheduleSpecification.of_json j
end

module CreateReservedInstancesListingRequest = struct
  type t =
    { client_token : String.t
    ; instance_count : Integer.t
    ; price_schedules : PriceScheduleSpecificationList.t
    ; reserved_instances_id : String.t
    }

  let make ~client_token ~instance_count ~price_schedules ~reserved_instances_id () =
    { client_token; instance_count; price_schedules; reserved_instances_id }

  let parse xml =
    Some
      { client_token =
          Aws.Xml.required
            "clientToken"
            (Aws.Util.option_bind (Aws.Xml.member "clientToken" xml) String.parse)
      ; instance_count =
          Aws.Xml.required
            "instanceCount"
            (Aws.Util.option_bind (Aws.Xml.member "instanceCount" xml) Integer.parse)
      ; price_schedules =
          Aws.Xml.required
            "priceSchedules"
            (Aws.Util.option_bind
               (Aws.Xml.member "priceSchedules" xml)
               PriceScheduleSpecificationList.parse)
      ; reserved_instances_id =
          Aws.Xml.required
            "reservedInstancesId"
            (Aws.Util.option_bind (Aws.Xml.member "reservedInstancesId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("ReservedInstancesId", String.to_query v.reserved_instances_id))
         ; Some
             (Aws.Query.Pair
                ( "PriceSchedules"
                , PriceScheduleSpecificationList.to_query v.price_schedules ))
         ; Some (Aws.Query.Pair ("InstanceCount", Integer.to_query v.instance_count))
         ; Some (Aws.Query.Pair ("ClientToken", String.to_query v.client_token))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("reservedInstancesId", String.to_json v.reserved_instances_id)
         ; Some
             ("priceSchedules", PriceScheduleSpecificationList.to_json v.price_schedules)
         ; Some ("instanceCount", Integer.to_json v.instance_count)
         ; Some ("clientToken", String.to_json v.client_token)
         ])

  let of_json j =
    { client_token =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "clientToken"))
    ; instance_count =
        Integer.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceCount"))
    ; price_schedules =
        PriceScheduleSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "priceSchedules"))
    ; reserved_instances_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "reservedInstancesId"))
    }
end

module DeleteVpcEndpointServiceConfigurationsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; service_ids : VpcEndpointServiceIdList.t
    }

  let make ?dry_run ~service_ids () = { dry_run; service_ids }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; service_ids =
          Aws.Xml.required
            "ServiceId"
            (Aws.Util.option_bind
               (Aws.Xml.member "ServiceId" xml)
               VpcEndpointServiceIdList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("ServiceId", VpcEndpointServiceIdList.to_query v.service_ids))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("ServiceId", VpcEndpointServiceIdList.to_json v.service_ids)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; service_ids =
        VpcEndpointServiceIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ServiceId"))
    }
end

module CopyFpgaImageRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; source_fpga_image_id : String.t
    ; description : String.t option
    ; name : String.t option
    ; source_region : String.t
    ; client_token : String.t option
    }

  let make
      ?dry_run
      ~source_fpga_image_id
      ?description
      ?name
      ~source_region
      ?client_token
      () =
    { dry_run; source_fpga_image_id; description; name; source_region; client_token }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; source_fpga_image_id =
          Aws.Xml.required
            "SourceFpgaImageId"
            (Aws.Util.option_bind (Aws.Xml.member "SourceFpgaImageId" xml) String.parse)
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; name = Aws.Util.option_bind (Aws.Xml.member "Name" xml) String.parse
      ; source_region =
          Aws.Xml.required
            "SourceRegion"
            (Aws.Util.option_bind (Aws.Xml.member "SourceRegion" xml) String.parse)
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Some (Aws.Query.Pair ("SourceRegion", String.to_query v.source_region))
         ; Aws.Util.option_map v.name (fun f ->
               Aws.Query.Pair ("Name", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Some
             (Aws.Query.Pair ("SourceFpgaImageId", String.to_query v.source_fpga_image_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Some ("SourceRegion", String.to_json v.source_region)
         ; Aws.Util.option_map v.name (fun f -> "Name", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Some ("SourceFpgaImageId", String.to_json v.source_fpga_image_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; source_fpga_image_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceFpgaImageId"))
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; name = Aws.Util.option_map (Aws.Json.lookup j "Name") String.of_json
    ; source_region =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SourceRegion"))
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    }
end

module DescribeImagesResult = struct
  type t = { images : ImageList.t }

  let make ?(images = []) () = { images }

  let parse xml =
    Some
      { images =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "imagesSet" xml) ImageList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("ImagesSet", ImageList.to_query v.images)) ])

  let to_json v =
    `Assoc (Aws.Util.list_filter_opt [ Some ("imagesSet", ImageList.to_json v.images) ])

  let of_json j =
    { images = ImageList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "imagesSet"))
    }
end

module GetTransitGatewayPrefixListReferencesResult = struct
  type t =
    { transit_gateway_prefix_list_references : TransitGatewayPrefixListReferenceSet.t
    ; next_token : String.t option
    }

  let make ?(transit_gateway_prefix_list_references = []) ?next_token () =
    { transit_gateway_prefix_list_references; next_token }

  let parse xml =
    Some
      { transit_gateway_prefix_list_references =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "transitGatewayPrefixListReferenceSet" xml)
               TransitGatewayPrefixListReferenceSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayPrefixListReferenceSet"
                , TransitGatewayPrefixListReferenceSet.to_query
                    v.transit_gateway_prefix_list_references ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "transitGatewayPrefixListReferenceSet"
             , TransitGatewayPrefixListReferenceSet.to_json
                 v.transit_gateway_prefix_list_references )
         ])

  let of_json j =
    { transit_gateway_prefix_list_references =
        TransitGatewayPrefixListReferenceSet.of_json
          (Aws.Util.of_option_exn
             (Aws.Json.lookup j "transitGatewayPrefixListReferenceSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module CreateFpgaImageResult = struct
  type t =
    { fpga_image_id : String.t option
    ; fpga_image_global_id : String.t option
    }

  let make ?fpga_image_id ?fpga_image_global_id () =
    { fpga_image_id; fpga_image_global_id }

  let parse xml =
    Some
      { fpga_image_id =
          Aws.Util.option_bind (Aws.Xml.member "fpgaImageId" xml) String.parse
      ; fpga_image_global_id =
          Aws.Util.option_bind (Aws.Xml.member "fpgaImageGlobalId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.fpga_image_global_id (fun f ->
               Aws.Query.Pair ("FpgaImageGlobalId", String.to_query f))
         ; Aws.Util.option_map v.fpga_image_id (fun f ->
               Aws.Query.Pair ("FpgaImageId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.fpga_image_global_id (fun f ->
               "fpgaImageGlobalId", String.to_json f)
         ; Aws.Util.option_map v.fpga_image_id (fun f -> "fpgaImageId", String.to_json f)
         ])

  let of_json j =
    { fpga_image_id = Aws.Util.option_map (Aws.Json.lookup j "fpgaImageId") String.of_json
    ; fpga_image_global_id =
        Aws.Util.option_map (Aws.Json.lookup j "fpgaImageGlobalId") String.of_json
    }
end

module StartVpcEndpointServicePrivateDnsVerificationRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; service_id : String.t
    }

  let make ?dry_run ~service_id () = { dry_run; service_id }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; service_id =
          Aws.Xml.required
            "ServiceId"
            (Aws.Util.option_bind (Aws.Xml.member "ServiceId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("ServiceId", String.to_query v.service_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("ServiceId", String.to_json v.service_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; service_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ServiceId"))
    }
end

module GetGroupsForCapacityReservationRequest = struct
  type t =
    { capacity_reservation_id : String.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    ; dry_run : Boolean.t option
    }

  let make ~capacity_reservation_id ?next_token ?max_results ?dry_run () =
    { capacity_reservation_id; next_token; max_results; dry_run }

  let parse xml =
    Some
      { capacity_reservation_id =
          Aws.Xml.required
            "CapacityReservationId"
            (Aws.Util.option_bind
               (Aws.Xml.member "CapacityReservationId" xml)
               String.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("CapacityReservationId", String.to_query v.capacity_reservation_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("CapacityReservationId", String.to_json v.capacity_reservation_id)
         ])

  let of_json j =
    { capacity_reservation_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "CapacityReservationId"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DescribeInstanceEventNotificationAttributesResult = struct
  type t = { instance_tag_attribute : InstanceTagNotificationAttribute.t option }

  let make ?instance_tag_attribute () = { instance_tag_attribute }

  let parse xml =
    Some
      { instance_tag_attribute =
          Aws.Util.option_bind
            (Aws.Xml.member "instanceTagAttribute" xml)
            InstanceTagNotificationAttribute.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_tag_attribute (fun f ->
               Aws.Query.Pair
                 ("InstanceTagAttribute", InstanceTagNotificationAttribute.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_tag_attribute (fun f ->
               "instanceTagAttribute", InstanceTagNotificationAttribute.to_json f)
         ])

  let of_json j =
    { instance_tag_attribute =
        Aws.Util.option_map
          (Aws.Json.lookup j "instanceTagAttribute")
          InstanceTagNotificationAttribute.of_json
    }
end

module ConfirmProductInstanceRequest = struct
  type t =
    { instance_id : String.t
    ; product_code : String.t
    ; dry_run : Boolean.t option
    }

  let make ~instance_id ~product_code ?dry_run () = { instance_id; product_code; dry_run }

  let parse xml =
    Some
      { instance_id =
          Aws.Xml.required
            "InstanceId"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceId" xml) String.parse)
      ; product_code =
          Aws.Xml.required
            "ProductCode"
            (Aws.Util.option_bind (Aws.Xml.member "ProductCode" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("ProductCode", String.to_query v.product_code))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("ProductCode", String.to_json v.product_code)
         ; Some ("InstanceId", String.to_json v.instance_id)
         ])

  let of_json j =
    { instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceId"))
    ; product_code =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ProductCode"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module ModifyFleetResult = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module CreateVpnConnectionRouteRequest = struct
  type t =
    { destination_cidr_block : String.t
    ; vpn_connection_id : String.t
    }

  let make ~destination_cidr_block ~vpn_connection_id () =
    { destination_cidr_block; vpn_connection_id }

  let parse xml =
    Some
      { destination_cidr_block =
          Aws.Xml.required
            "DestinationCidrBlock"
            (Aws.Util.option_bind
               (Aws.Xml.member "DestinationCidrBlock" xml)
               String.parse)
      ; vpn_connection_id =
          Aws.Xml.required
            "VpnConnectionId"
            (Aws.Util.option_bind (Aws.Xml.member "VpnConnectionId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("VpnConnectionId", String.to_query v.vpn_connection_id))
         ; Some
             (Aws.Query.Pair
                ("DestinationCidrBlock", String.to_query v.destination_cidr_block))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("VpnConnectionId", String.to_json v.vpn_connection_id)
         ; Some ("DestinationCidrBlock", String.to_json v.destination_cidr_block)
         ])

  let of_json j =
    { destination_cidr_block =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DestinationCidrBlock"))
    ; vpn_connection_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpnConnectionId"))
    }
end

module DeleteInternetGatewayRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; internet_gateway_id : String.t
    }

  let make ?dry_run ~internet_gateway_id () = { dry_run; internet_gateway_id }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; internet_gateway_id =
          Aws.Xml.required
            "internetGatewayId"
            (Aws.Util.option_bind (Aws.Xml.member "internetGatewayId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("InternetGatewayId", String.to_query v.internet_gateway_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("internetGatewayId", String.to_json v.internet_gateway_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; internet_gateway_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "internetGatewayId"))
    }
end

module RejectTransitGatewayPeeringAttachmentResult = struct
  type t =
    { transit_gateway_peering_attachment : TransitGatewayPeeringAttachment.t option }

  let make ?transit_gateway_peering_attachment () = { transit_gateway_peering_attachment }

  let parse xml =
    Some
      { transit_gateway_peering_attachment =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayPeeringAttachment" xml)
            TransitGatewayPeeringAttachment.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_peering_attachment (fun f ->
               Aws.Query.Pair
                 ( "TransitGatewayPeeringAttachment"
                 , TransitGatewayPeeringAttachment.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_peering_attachment (fun f ->
               ( "transitGatewayPeeringAttachment"
               , TransitGatewayPeeringAttachment.to_json f ))
         ])

  let of_json j =
    { transit_gateway_peering_attachment =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayPeeringAttachment")
          TransitGatewayPeeringAttachment.of_json
    }
end

module CreateReservedInstancesListingResult = struct
  type t = { reserved_instances_listings : ReservedInstancesListingList.t }

  let make ?(reserved_instances_listings = []) () = { reserved_instances_listings }

  let parse xml =
    Some
      { reserved_instances_listings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "reservedInstancesListingsSet" xml)
               ReservedInstancesListingList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "ReservedInstancesListingsSet"
                , ReservedInstancesListingList.to_query v.reserved_instances_listings ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "reservedInstancesListingsSet"
             , ReservedInstancesListingList.to_json v.reserved_instances_listings )
         ])

  let of_json j =
    { reserved_instances_listings =
        ReservedInstancesListingList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "reservedInstancesListingsSet"))
    }
end

module InstanceStatusList = struct
  type t = InstanceStatus.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map InstanceStatus.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list InstanceStatus.to_query v

  let to_json v = `List (List.map InstanceStatus.to_json v)

  let of_json j = Aws.Json.to_list InstanceStatus.of_json j
end

module DescribeInstanceStatusResult = struct
  type t =
    { instance_statuses : InstanceStatusList.t
    ; next_token : String.t option
    }

  let make ?(instance_statuses = []) ?next_token () = { instance_statuses; next_token }

  let parse xml =
    Some
      { instance_statuses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "instanceStatusSet" xml)
               InstanceStatusList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("InstanceStatusSet", InstanceStatusList.to_query v.instance_statuses))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("instanceStatusSet", InstanceStatusList.to_json v.instance_statuses)
         ])

  let of_json j =
    { instance_statuses =
        InstanceStatusList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceStatusSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DescribeInstanceTypeOfferingsResult = struct
  type t =
    { instance_type_offerings : InstanceTypeOfferingsList.t
    ; next_token : String.t option
    }

  let make ?(instance_type_offerings = []) ?next_token () =
    { instance_type_offerings; next_token }

  let parse xml =
    Some
      { instance_type_offerings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "instanceTypeOfferingSet" xml)
               InstanceTypeOfferingsList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "InstanceTypeOfferingSet"
                , InstanceTypeOfferingsList.to_query v.instance_type_offerings ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "instanceTypeOfferingSet"
             , InstanceTypeOfferingsList.to_json v.instance_type_offerings )
         ])

  let of_json j =
    { instance_type_offerings =
        InstanceTypeOfferingsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceTypeOfferingSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module CreateTransitGatewayPrefixListReferenceResult = struct
  type t =
    { transit_gateway_prefix_list_reference : TransitGatewayPrefixListReference.t option }

  let make ?transit_gateway_prefix_list_reference () =
    { transit_gateway_prefix_list_reference }

  let parse xml =
    Some
      { transit_gateway_prefix_list_reference =
          Aws.Util.option_bind
            (Aws.Xml.member "transitGatewayPrefixListReference" xml)
            TransitGatewayPrefixListReference.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_prefix_list_reference (fun f ->
               Aws.Query.Pair
                 ( "TransitGatewayPrefixListReference"
                 , TransitGatewayPrefixListReference.to_query f ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.transit_gateway_prefix_list_reference (fun f ->
               ( "transitGatewayPrefixListReference"
               , TransitGatewayPrefixListReference.to_json f ))
         ])

  let of_json j =
    { transit_gateway_prefix_list_reference =
        Aws.Util.option_map
          (Aws.Json.lookup j "transitGatewayPrefixListReference")
          TransitGatewayPrefixListReference.of_json
    }
end

module TerminateConnectionStatusSet = struct
  type t = TerminateConnectionStatus.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map TerminateConnectionStatus.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list TerminateConnectionStatus.to_query v

  let to_json v = `List (List.map TerminateConnectionStatus.to_json v)

  let of_json j = Aws.Json.to_list TerminateConnectionStatus.of_json j
end

module TerminateClientVpnConnectionsResult = struct
  type t =
    { client_vpn_endpoint_id : String.t option
    ; username : String.t option
    ; connection_statuses : TerminateConnectionStatusSet.t
    }

  let make ?client_vpn_endpoint_id ?username ?(connection_statuses = []) () =
    { client_vpn_endpoint_id; username; connection_statuses }

  let parse xml =
    Some
      { client_vpn_endpoint_id =
          Aws.Util.option_bind (Aws.Xml.member "clientVpnEndpointId" xml) String.parse
      ; username = Aws.Util.option_bind (Aws.Xml.member "username" xml) String.parse
      ; connection_statuses =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "connectionStatuses" xml)
               TerminateConnectionStatusSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "ConnectionStatuses"
                , TerminateConnectionStatusSet.to_query v.connection_statuses ))
         ; Aws.Util.option_map v.username (fun f ->
               Aws.Query.Pair ("Username", String.to_query f))
         ; Aws.Util.option_map v.client_vpn_endpoint_id (fun f ->
               Aws.Query.Pair ("ClientVpnEndpointId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "connectionStatuses"
             , TerminateConnectionStatusSet.to_json v.connection_statuses )
         ; Aws.Util.option_map v.username (fun f -> "username", String.to_json f)
         ; Aws.Util.option_map v.client_vpn_endpoint_id (fun f ->
               "clientVpnEndpointId", String.to_json f)
         ])

  let of_json j =
    { client_vpn_endpoint_id =
        Aws.Util.option_map (Aws.Json.lookup j "clientVpnEndpointId") String.of_json
    ; username = Aws.Util.option_map (Aws.Json.lookup j "username") String.of_json
    ; connection_statuses =
        TerminateConnectionStatusSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "connectionStatuses"))
    }
end

module ClientCertificateRevocationListStatus = struct
  type t =
    { code : ClientCertificateRevocationListStatusCode.t option
    ; message : String.t option
    }

  let make ?code ?message () = { code; message }

  let parse xml =
    Some
      { code =
          Aws.Util.option_bind
            (Aws.Xml.member "code" xml)
            ClientCertificateRevocationListStatusCode.parse
      ; message = Aws.Util.option_bind (Aws.Xml.member "message" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f ->
               Aws.Query.Pair ("Message", String.to_query f))
         ; Aws.Util.option_map v.code (fun f ->
               Aws.Query.Pair
                 ("Code", ClientCertificateRevocationListStatusCode.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.message (fun f -> "message", String.to_json f)
         ; Aws.Util.option_map v.code (fun f ->
               "code", ClientCertificateRevocationListStatusCode.to_json f)
         ])

  let of_json j =
    { code =
        Aws.Util.option_map
          (Aws.Json.lookup j "code")
          ClientCertificateRevocationListStatusCode.of_json
    ; message = Aws.Util.option_map (Aws.Json.lookup j "message") String.of_json
    }
end

module ExportClientVpnClientCertificateRevocationListResult = struct
  type t =
    { certificate_revocation_list : String.t option
    ; status : ClientCertificateRevocationListStatus.t option
    }

  let make ?certificate_revocation_list ?status () =
    { certificate_revocation_list; status }

  let parse xml =
    Some
      { certificate_revocation_list =
          Aws.Util.option_bind
            (Aws.Xml.member "certificateRevocationList" xml)
            String.parse
      ; status =
          Aws.Util.option_bind
            (Aws.Xml.member "status" xml)
            ClientCertificateRevocationListStatus.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", ClientCertificateRevocationListStatus.to_query f))
         ; Aws.Util.option_map v.certificate_revocation_list (fun f ->
               Aws.Query.Pair ("CertificateRevocationList", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               "status", ClientCertificateRevocationListStatus.to_json f)
         ; Aws.Util.option_map v.certificate_revocation_list (fun f ->
               "certificateRevocationList", String.to_json f)
         ])

  let of_json j =
    { certificate_revocation_list =
        Aws.Util.option_map (Aws.Json.lookup j "certificateRevocationList") String.of_json
    ; status =
        Aws.Util.option_map
          (Aws.Json.lookup j "status")
          ClientCertificateRevocationListStatus.of_json
    }
end

module CreateManagedPrefixListRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; prefix_list_name : String.t
    ; entries : AddPrefixListEntries.t
    ; max_entries : Integer.t
    ; tag_specifications : TagSpecificationList.t
    ; address_family : String.t
    ; client_token : String.t option
    }

  let make
      ?dry_run
      ~prefix_list_name
      ?(entries = [])
      ~max_entries
      ?(tag_specifications = [])
      ~address_family
      ?client_token
      () =
    { dry_run
    ; prefix_list_name
    ; entries
    ; max_entries
    ; tag_specifications
    ; address_family
    ; client_token
    }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; prefix_list_name =
          Aws.Xml.required
            "PrefixListName"
            (Aws.Util.option_bind (Aws.Xml.member "PrefixListName" xml) String.parse)
      ; entries =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Entry" xml) AddPrefixListEntries.parse)
      ; max_entries =
          Aws.Xml.required
            "MaxEntries"
            (Aws.Util.option_bind (Aws.Xml.member "MaxEntries" xml) Integer.parse)
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      ; address_family =
          Aws.Xml.required
            "AddressFamily"
            (Aws.Util.option_bind (Aws.Xml.member "AddressFamily" xml) String.parse)
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Some (Aws.Query.Pair ("AddressFamily", String.to_query v.address_family))
         ; Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Some (Aws.Query.Pair ("MaxEntries", Integer.to_query v.max_entries))
         ; Some (Aws.Query.Pair ("Entry", AddPrefixListEntries.to_query v.entries))
         ; Some (Aws.Query.Pair ("PrefixListName", String.to_query v.prefix_list_name))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Some ("AddressFamily", String.to_json v.address_family)
         ; Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Some ("MaxEntries", Integer.to_json v.max_entries)
         ; Some ("Entry", AddPrefixListEntries.to_json v.entries)
         ; Some ("PrefixListName", String.to_json v.prefix_list_name)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; prefix_list_name =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PrefixListName"))
    ; entries =
        AddPrefixListEntries.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Entry"))
    ; max_entries =
        Integer.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "MaxEntries"))
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    ; address_family =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "AddressFamily"))
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    }
end

module CreateClientVpnRouteRequest = struct
  type t =
    { client_vpn_endpoint_id : String.t
    ; destination_cidr_block : String.t
    ; target_vpc_subnet_id : String.t
    ; description : String.t option
    ; client_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make
      ~client_vpn_endpoint_id
      ~destination_cidr_block
      ~target_vpc_subnet_id
      ?description
      ?client_token
      ?dry_run
      () =
    { client_vpn_endpoint_id
    ; destination_cidr_block
    ; target_vpc_subnet_id
    ; description
    ; client_token
    ; dry_run
    }

  let parse xml =
    Some
      { client_vpn_endpoint_id =
          Aws.Xml.required
            "ClientVpnEndpointId"
            (Aws.Util.option_bind (Aws.Xml.member "ClientVpnEndpointId" xml) String.parse)
      ; destination_cidr_block =
          Aws.Xml.required
            "DestinationCidrBlock"
            (Aws.Util.option_bind
               (Aws.Xml.member "DestinationCidrBlock" xml)
               String.parse)
      ; target_vpc_subnet_id =
          Aws.Xml.required
            "TargetVpcSubnetId"
            (Aws.Util.option_bind (Aws.Xml.member "TargetVpcSubnetId" xml) String.parse)
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Some
             (Aws.Query.Pair ("TargetVpcSubnetId", String.to_query v.target_vpc_subnet_id))
         ; Some
             (Aws.Query.Pair
                ("DestinationCidrBlock", String.to_query v.destination_cidr_block))
         ; Some
             (Aws.Query.Pair
                ("ClientVpnEndpointId", String.to_query v.client_vpn_endpoint_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Some ("TargetVpcSubnetId", String.to_json v.target_vpc_subnet_id)
         ; Some ("DestinationCidrBlock", String.to_json v.destination_cidr_block)
         ; Some ("ClientVpnEndpointId", String.to_json v.client_vpn_endpoint_id)
         ])

  let of_json j =
    { client_vpn_endpoint_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ClientVpnEndpointId"))
    ; destination_cidr_block =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DestinationCidrBlock"))
    ; target_vpc_subnet_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TargetVpcSubnetId"))
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module TerminateInstancesResult = struct
  type t = { terminating_instances : InstanceStateChangeList.t }

  let make ?(terminating_instances = []) () = { terminating_instances }

  let parse xml =
    Some
      { terminating_instances =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "instancesSet" xml)
               InstanceStateChangeList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("InstancesSet", InstanceStateChangeList.to_query v.terminating_instances))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("instancesSet", InstanceStateChangeList.to_json v.terminating_instances)
         ])

  let of_json j =
    { terminating_instances =
        InstanceStateChangeList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "instancesSet"))
    }
end

module ExportClientVpnClientConfigurationRequest = struct
  type t =
    { client_vpn_endpoint_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~client_vpn_endpoint_id ?dry_run () = { client_vpn_endpoint_id; dry_run }

  let parse xml =
    Some
      { client_vpn_endpoint_id =
          Aws.Xml.required
            "ClientVpnEndpointId"
            (Aws.Util.option_bind (Aws.Xml.member "ClientVpnEndpointId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ClientVpnEndpointId", String.to_query v.client_vpn_endpoint_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("ClientVpnEndpointId", String.to_json v.client_vpn_endpoint_id)
         ])

  let of_json j =
    { client_vpn_endpoint_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ClientVpnEndpointId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module CreateVpcEndpointConnectionNotificationRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; service_id : String.t option
    ; vpc_endpoint_id : String.t option
    ; connection_notification_arn : String.t
    ; connection_events : ValueStringList.t
    ; client_token : String.t option
    }

  let make
      ?dry_run
      ?service_id
      ?vpc_endpoint_id
      ~connection_notification_arn
      ~connection_events
      ?client_token
      () =
    { dry_run
    ; service_id
    ; vpc_endpoint_id
    ; connection_notification_arn
    ; connection_events
    ; client_token
    }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; service_id = Aws.Util.option_bind (Aws.Xml.member "ServiceId" xml) String.parse
      ; vpc_endpoint_id =
          Aws.Util.option_bind (Aws.Xml.member "VpcEndpointId" xml) String.parse
      ; connection_notification_arn =
          Aws.Xml.required
            "ConnectionNotificationArn"
            (Aws.Util.option_bind
               (Aws.Xml.member "ConnectionNotificationArn" xml)
               String.parse)
      ; connection_events =
          Aws.Xml.required
            "ConnectionEvents"
            (Aws.Util.option_bind
               (Aws.Xml.member "ConnectionEvents" xml)
               ValueStringList.parse)
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ConnectionEvents", ValueStringList.to_query v.connection_events))
         ; Some
             (Aws.Query.Pair
                ( "ConnectionNotificationArn"
                , String.to_query v.connection_notification_arn ))
         ; Aws.Util.option_map v.vpc_endpoint_id (fun f ->
               Aws.Query.Pair ("VpcEndpointId", String.to_query f))
         ; Aws.Util.option_map v.service_id (fun f ->
               Aws.Query.Pair ("ServiceId", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Some ("ConnectionEvents", ValueStringList.to_json v.connection_events)
         ; Some ("ConnectionNotificationArn", String.to_json v.connection_notification_arn)
         ; Aws.Util.option_map v.vpc_endpoint_id (fun f ->
               "VpcEndpointId", String.to_json f)
         ; Aws.Util.option_map v.service_id (fun f -> "ServiceId", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; service_id = Aws.Util.option_map (Aws.Json.lookup j "ServiceId") String.of_json
    ; vpc_endpoint_id =
        Aws.Util.option_map (Aws.Json.lookup j "VpcEndpointId") String.of_json
    ; connection_notification_arn =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ConnectionNotificationArn"))
    ; connection_events =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ConnectionEvents"))
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    }
end

module CreateDefaultVpcResult = struct
  type t = { vpc : Vpc.t option }

  let make ?vpc () = { vpc }

  let parse xml = Some { vpc = Aws.Util.option_bind (Aws.Xml.member "vpc" xml) Vpc.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc (fun f -> Aws.Query.Pair ("Vpc", Vpc.to_query f)) ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc (fun f -> "vpc", Vpc.to_json f) ])

  let of_json j = { vpc = Aws.Util.option_map (Aws.Json.lookup j "vpc") Vpc.of_json }
end

module ModifyTrafficMirrorFilterRuleResult = struct
  type t = { traffic_mirror_filter_rule : TrafficMirrorFilterRule.t option }

  let make ?traffic_mirror_filter_rule () = { traffic_mirror_filter_rule }

  let parse xml =
    Some
      { traffic_mirror_filter_rule =
          Aws.Util.option_bind
            (Aws.Xml.member "trafficMirrorFilterRule" xml)
            TrafficMirrorFilterRule.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.traffic_mirror_filter_rule (fun f ->
               Aws.Query.Pair
                 ("TrafficMirrorFilterRule", TrafficMirrorFilterRule.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.traffic_mirror_filter_rule (fun f ->
               "trafficMirrorFilterRule", TrafficMirrorFilterRule.to_json f)
         ])

  let of_json j =
    { traffic_mirror_filter_rule =
        Aws.Util.option_map
          (Aws.Json.lookup j "trafficMirrorFilterRule")
          TrafficMirrorFilterRule.of_json
    }
end

module DescribeClientVpnTargetNetworksRequest = struct
  type t =
    { client_vpn_endpoint_id : String.t
    ; association_ids : ValueStringList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; filters : FilterList.t
    ; dry_run : Boolean.t option
    }

  let make
      ~client_vpn_endpoint_id
      ?(association_ids = [])
      ?max_results
      ?next_token
      ?(filters = [])
      ?dry_run
      () =
    { client_vpn_endpoint_id; association_ids; max_results; next_token; filters; dry_run }

  let parse xml =
    Some
      { client_vpn_endpoint_id =
          Aws.Xml.required
            "ClientVpnEndpointId"
            (Aws.Util.option_bind (Aws.Xml.member "ClientVpnEndpointId" xml) String.parse)
      ; association_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "AssociationIds" xml)
               ValueStringList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair ("AssociationIds", ValueStringList.to_query v.association_ids))
         ; Some
             (Aws.Query.Pair
                ("ClientVpnEndpointId", String.to_query v.client_vpn_endpoint_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("AssociationIds", ValueStringList.to_json v.association_ids)
         ; Some ("ClientVpnEndpointId", String.to_json v.client_vpn_endpoint_id)
         ])

  let of_json j =
    { client_vpn_endpoint_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ClientVpnEndpointId"))
    ; association_ids =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "AssociationIds"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module AllocateAddressResult = struct
  type t =
    { public_ip : String.t option
    ; allocation_id : String.t option
    ; public_ipv4_pool : String.t option
    ; network_border_group : String.t option
    ; domain : DomainType.t option
    ; customer_owned_ip : String.t option
    ; customer_owned_ipv4_pool : String.t option
    ; carrier_ip : String.t option
    }

  let make
      ?public_ip
      ?allocation_id
      ?public_ipv4_pool
      ?network_border_group
      ?domain
      ?customer_owned_ip
      ?customer_owned_ipv4_pool
      ?carrier_ip
      () =
    { public_ip
    ; allocation_id
    ; public_ipv4_pool
    ; network_border_group
    ; domain
    ; customer_owned_ip
    ; customer_owned_ipv4_pool
    ; carrier_ip
    }

  let parse xml =
    Some
      { public_ip = Aws.Util.option_bind (Aws.Xml.member "publicIp" xml) String.parse
      ; allocation_id =
          Aws.Util.option_bind (Aws.Xml.member "allocationId" xml) String.parse
      ; public_ipv4_pool =
          Aws.Util.option_bind (Aws.Xml.member "publicIpv4Pool" xml) String.parse
      ; network_border_group =
          Aws.Util.option_bind (Aws.Xml.member "networkBorderGroup" xml) String.parse
      ; domain = Aws.Util.option_bind (Aws.Xml.member "domain" xml) DomainType.parse
      ; customer_owned_ip =
          Aws.Util.option_bind (Aws.Xml.member "customerOwnedIp" xml) String.parse
      ; customer_owned_ipv4_pool =
          Aws.Util.option_bind (Aws.Xml.member "customerOwnedIpv4Pool" xml) String.parse
      ; carrier_ip = Aws.Util.option_bind (Aws.Xml.member "carrierIp" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.carrier_ip (fun f ->
               Aws.Query.Pair ("CarrierIp", String.to_query f))
         ; Aws.Util.option_map v.customer_owned_ipv4_pool (fun f ->
               Aws.Query.Pair ("CustomerOwnedIpv4Pool", String.to_query f))
         ; Aws.Util.option_map v.customer_owned_ip (fun f ->
               Aws.Query.Pair ("CustomerOwnedIp", String.to_query f))
         ; Aws.Util.option_map v.domain (fun f ->
               Aws.Query.Pair ("Domain", DomainType.to_query f))
         ; Aws.Util.option_map v.network_border_group (fun f ->
               Aws.Query.Pair ("NetworkBorderGroup", String.to_query f))
         ; Aws.Util.option_map v.public_ipv4_pool (fun f ->
               Aws.Query.Pair ("PublicIpv4Pool", String.to_query f))
         ; Aws.Util.option_map v.allocation_id (fun f ->
               Aws.Query.Pair ("AllocationId", String.to_query f))
         ; Aws.Util.option_map v.public_ip (fun f ->
               Aws.Query.Pair ("PublicIp", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.carrier_ip (fun f -> "carrierIp", String.to_json f)
         ; Aws.Util.option_map v.customer_owned_ipv4_pool (fun f ->
               "customerOwnedIpv4Pool", String.to_json f)
         ; Aws.Util.option_map v.customer_owned_ip (fun f ->
               "customerOwnedIp", String.to_json f)
         ; Aws.Util.option_map v.domain (fun f -> "domain", DomainType.to_json f)
         ; Aws.Util.option_map v.network_border_group (fun f ->
               "networkBorderGroup", String.to_json f)
         ; Aws.Util.option_map v.public_ipv4_pool (fun f ->
               "publicIpv4Pool", String.to_json f)
         ; Aws.Util.option_map v.allocation_id (fun f -> "allocationId", String.to_json f)
         ; Aws.Util.option_map v.public_ip (fun f -> "publicIp", String.to_json f)
         ])

  let of_json j =
    { public_ip = Aws.Util.option_map (Aws.Json.lookup j "publicIp") String.of_json
    ; allocation_id =
        Aws.Util.option_map (Aws.Json.lookup j "allocationId") String.of_json
    ; public_ipv4_pool =
        Aws.Util.option_map (Aws.Json.lookup j "publicIpv4Pool") String.of_json
    ; network_border_group =
        Aws.Util.option_map (Aws.Json.lookup j "networkBorderGroup") String.of_json
    ; domain = Aws.Util.option_map (Aws.Json.lookup j "domain") DomainType.of_json
    ; customer_owned_ip =
        Aws.Util.option_map (Aws.Json.lookup j "customerOwnedIp") String.of_json
    ; customer_owned_ipv4_pool =
        Aws.Util.option_map (Aws.Json.lookup j "customerOwnedIpv4Pool") String.of_json
    ; carrier_ip = Aws.Util.option_map (Aws.Json.lookup j "carrierIp") String.of_json
    }
end

module DeregisterInstanceEventNotificationAttributesResult = struct
  type t = { instance_tag_attribute : InstanceTagNotificationAttribute.t option }

  let make ?instance_tag_attribute () = { instance_tag_attribute }

  let parse xml =
    Some
      { instance_tag_attribute =
          Aws.Util.option_bind
            (Aws.Xml.member "instanceTagAttribute" xml)
            InstanceTagNotificationAttribute.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_tag_attribute (fun f ->
               Aws.Query.Pair
                 ("InstanceTagAttribute", InstanceTagNotificationAttribute.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_tag_attribute (fun f ->
               "instanceTagAttribute", InstanceTagNotificationAttribute.to_json f)
         ])

  let of_json j =
    { instance_tag_attribute =
        Aws.Util.option_map
          (Aws.Json.lookup j "instanceTagAttribute")
          InstanceTagNotificationAttribute.of_json
    }
end

module DeleteNetworkAclEntryRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; egress : Boolean.t
    ; network_acl_id : String.t
    ; rule_number : Integer.t
    }

  let make ?dry_run ~egress ~network_acl_id ~rule_number () =
    { dry_run; egress; network_acl_id; rule_number }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; egress =
          Aws.Xml.required
            "egress"
            (Aws.Util.option_bind (Aws.Xml.member "egress" xml) Boolean.parse)
      ; network_acl_id =
          Aws.Xml.required
            "networkAclId"
            (Aws.Util.option_bind (Aws.Xml.member "networkAclId" xml) String.parse)
      ; rule_number =
          Aws.Xml.required
            "ruleNumber"
            (Aws.Util.option_bind (Aws.Xml.member "ruleNumber" xml) Integer.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("RuleNumber", Integer.to_query v.rule_number))
         ; Some (Aws.Query.Pair ("NetworkAclId", String.to_query v.network_acl_id))
         ; Some (Aws.Query.Pair ("Egress", Boolean.to_query v.egress))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("ruleNumber", Integer.to_json v.rule_number)
         ; Some ("networkAclId", String.to_json v.network_acl_id)
         ; Some ("egress", Boolean.to_json v.egress)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; egress = Boolean.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "egress"))
    ; network_acl_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "networkAclId"))
    ; rule_number =
        Integer.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ruleNumber"))
    }
end

module DisableVpcClassicLinkRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; vpc_id : String.t
    }

  let make ?dry_run ~vpc_id () = { dry_run; vpc_id }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; vpc_id =
          Aws.Xml.required
            "vpcId"
            (Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("vpcId", String.to_json v.vpc_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "vpcId"))
    }
end

module SearchLocalGatewayRoutesRequest = struct
  type t =
    { local_gateway_route_table_id : String.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make ~local_gateway_route_table_id ~filters ?max_results ?next_token ?dry_run () =
    { local_gateway_route_table_id; filters; max_results; next_token; dry_run }

  let parse xml =
    Some
      { local_gateway_route_table_id =
          Aws.Xml.required
            "LocalGatewayRouteTableId"
            (Aws.Util.option_bind
               (Aws.Xml.member "LocalGatewayRouteTableId" xml)
               String.parse)
      ; filters =
          Aws.Xml.required
            "Filter"
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ( "LocalGatewayRouteTableId"
                , String.to_query v.local_gateway_route_table_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some ("LocalGatewayRouteTableId", String.to_json v.local_gateway_route_table_id)
         ])

  let of_json j =
    { local_gateway_route_table_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "LocalGatewayRouteTableId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module CreateVpcEndpointServiceConfigurationResult = struct
  type t =
    { service_configuration : ServiceConfiguration.t option
    ; client_token : String.t option
    }

  let make ?service_configuration ?client_token () =
    { service_configuration; client_token }

  let parse xml =
    Some
      { service_configuration =
          Aws.Util.option_bind
            (Aws.Xml.member "serviceConfiguration" xml)
            ServiceConfiguration.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "clientToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.service_configuration (fun f ->
               Aws.Query.Pair ("ServiceConfiguration", ServiceConfiguration.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f -> "clientToken", String.to_json f)
         ; Aws.Util.option_map v.service_configuration (fun f ->
               "serviceConfiguration", ServiceConfiguration.to_json f)
         ])

  let of_json j =
    { service_configuration =
        Aws.Util.option_map
          (Aws.Json.lookup j "serviceConfiguration")
          ServiceConfiguration.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "clientToken") String.of_json
    }
end

module DeleteVpcEndpointsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; vpc_endpoint_ids : VpcEndpointIdList.t
    }

  let make ?dry_run ~vpc_endpoint_ids () = { dry_run; vpc_endpoint_ids }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; vpc_endpoint_ids =
          Aws.Xml.required
            "VpcEndpointId"
            (Aws.Util.option_bind
               (Aws.Xml.member "VpcEndpointId" xml)
               VpcEndpointIdList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("VpcEndpointId", VpcEndpointIdList.to_query v.vpc_endpoint_ids))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("VpcEndpointId", VpcEndpointIdList.to_json v.vpc_endpoint_ids)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; vpc_endpoint_ids =
        VpcEndpointIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcEndpointId"))
    }
end

module DescribeClientVpnRoutesRequest = struct
  type t =
    { client_vpn_endpoint_id : String.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make ~client_vpn_endpoint_id ?(filters = []) ?max_results ?next_token ?dry_run () =
    { client_vpn_endpoint_id; filters; max_results; next_token; dry_run }

  let parse xml =
    Some
      { client_vpn_endpoint_id =
          Aws.Xml.required
            "ClientVpnEndpointId"
            (Aws.Util.option_bind (Aws.Xml.member "ClientVpnEndpointId" xml) String.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ("ClientVpnEndpointId", String.to_query v.client_vpn_endpoint_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some ("ClientVpnEndpointId", String.to_json v.client_vpn_endpoint_id)
         ])

  let of_json j =
    { client_vpn_endpoint_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ClientVpnEndpointId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module ModifyVpnTunnelCertificateRequest = struct
  type t =
    { vpn_connection_id : String.t
    ; vpn_tunnel_outside_ip_address : String.t
    ; dry_run : Boolean.t option
    }

  let make ~vpn_connection_id ~vpn_tunnel_outside_ip_address ?dry_run () =
    { vpn_connection_id; vpn_tunnel_outside_ip_address; dry_run }

  let parse xml =
    Some
      { vpn_connection_id =
          Aws.Xml.required
            "VpnConnectionId"
            (Aws.Util.option_bind (Aws.Xml.member "VpnConnectionId" xml) String.parse)
      ; vpn_tunnel_outside_ip_address =
          Aws.Xml.required
            "VpnTunnelOutsideIpAddress"
            (Aws.Util.option_bind
               (Aws.Xml.member "VpnTunnelOutsideIpAddress" xml)
               String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "VpnTunnelOutsideIpAddress"
                , String.to_query v.vpn_tunnel_outside_ip_address ))
         ; Some (Aws.Query.Pair ("VpnConnectionId", String.to_query v.vpn_connection_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ("VpnTunnelOutsideIpAddress", String.to_json v.vpn_tunnel_outside_ip_address)
         ; Some ("VpnConnectionId", String.to_json v.vpn_connection_id)
         ])

  let of_json j =
    { vpn_connection_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpnConnectionId"))
    ; vpn_tunnel_outside_ip_address =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "VpnTunnelOutsideIpAddress"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DescribeReservedInstancesListingsResult = struct
  type t = { reserved_instances_listings : ReservedInstancesListingList.t }

  let make ?(reserved_instances_listings = []) () = { reserved_instances_listings }

  let parse xml =
    Some
      { reserved_instances_listings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "reservedInstancesListingsSet" xml)
               ReservedInstancesListingList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "ReservedInstancesListingsSet"
                , ReservedInstancesListingList.to_query v.reserved_instances_listings ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "reservedInstancesListingsSet"
             , ReservedInstancesListingList.to_json v.reserved_instances_listings )
         ])

  let of_json j =
    { reserved_instances_listings =
        ReservedInstancesListingList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "reservedInstancesListingsSet"))
    }
end

module RequestSpotFleetRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; spot_fleet_request_config : SpotFleetRequestConfigData.t
    }

  let make ?dry_run ~spot_fleet_request_config () = { dry_run; spot_fleet_request_config }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; spot_fleet_request_config =
          Aws.Xml.required
            "spotFleetRequestConfig"
            (Aws.Util.option_bind
               (Aws.Xml.member "spotFleetRequestConfig" xml)
               SpotFleetRequestConfigData.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "SpotFleetRequestConfig"
                , SpotFleetRequestConfigData.to_query v.spot_fleet_request_config ))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "spotFleetRequestConfig"
             , SpotFleetRequestConfigData.to_json v.spot_fleet_request_config )
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; spot_fleet_request_config =
        SpotFleetRequestConfigData.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "spotFleetRequestConfig"))
    }
end

module DescribeManagedPrefixListsResult = struct
  type t =
    { next_token : String.t option
    ; prefix_lists : ManagedPrefixListSet.t
    }

  let make ?next_token ?(prefix_lists = []) () = { next_token; prefix_lists }

  let parse xml =
    Some
      { next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; prefix_lists =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "prefixListSet" xml)
               ManagedPrefixListSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("PrefixListSet", ManagedPrefixListSet.to_query v.prefix_lists))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("prefixListSet", ManagedPrefixListSet.to_json v.prefix_lists)
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ])

  let of_json j =
    { next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; prefix_lists =
        ManagedPrefixListSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "prefixListSet"))
    }
end

module DescribeImportSnapshotTasksRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; filters : FilterList.t
    ; import_task_ids : ImportSnapshotTaskIdList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?dry_run ?(filters = []) ?(import_task_ids = []) ?max_results ?next_token () =
    { dry_run; filters; import_task_ids; max_results; next_token }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filters" xml) FilterList.parse)
      ; import_task_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ImportTaskId" xml)
               ImportSnapshotTaskIdList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ImportTaskId", ImportSnapshotTaskIdList.to_query v.import_task_ids))
         ; Some (Aws.Query.Pair ("Filters", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("ImportTaskId", ImportSnapshotTaskIdList.to_json v.import_task_ids)
         ; Some ("Filters", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filters"))
    ; import_task_ids =
        ImportSnapshotTaskIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ImportTaskId"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module DisassociateVpcCidrBlockResult = struct
  type t =
    { ipv6_cidr_block_association : VpcIpv6CidrBlockAssociation.t option
    ; cidr_block_association : VpcCidrBlockAssociation.t option
    ; vpc_id : String.t option
    }

  let make ?ipv6_cidr_block_association ?cidr_block_association ?vpc_id () =
    { ipv6_cidr_block_association; cidr_block_association; vpc_id }

  let parse xml =
    Some
      { ipv6_cidr_block_association =
          Aws.Util.option_bind
            (Aws.Xml.member "ipv6CidrBlockAssociation" xml)
            VpcIpv6CidrBlockAssociation.parse
      ; cidr_block_association =
          Aws.Util.option_bind
            (Aws.Xml.member "cidrBlockAssociation" xml)
            VpcCidrBlockAssociation.parse
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "vpcId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Aws.Util.option_map v.cidr_block_association (fun f ->
               Aws.Query.Pair ("CidrBlockAssociation", VpcCidrBlockAssociation.to_query f))
         ; Aws.Util.option_map v.ipv6_cidr_block_association (fun f ->
               Aws.Query.Pair
                 ("Ipv6CidrBlockAssociation", VpcIpv6CidrBlockAssociation.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.vpc_id (fun f -> "vpcId", String.to_json f)
         ; Aws.Util.option_map v.cidr_block_association (fun f ->
               "cidrBlockAssociation", VpcCidrBlockAssociation.to_json f)
         ; Aws.Util.option_map v.ipv6_cidr_block_association (fun f ->
               "ipv6CidrBlockAssociation", VpcIpv6CidrBlockAssociation.to_json f)
         ])

  let of_json j =
    { ipv6_cidr_block_association =
        Aws.Util.option_map
          (Aws.Json.lookup j "ipv6CidrBlockAssociation")
          VpcIpv6CidrBlockAssociation.of_json
    ; cidr_block_association =
        Aws.Util.option_map
          (Aws.Json.lookup j "cidrBlockAssociation")
          VpcCidrBlockAssociation.of_json
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "vpcId") String.of_json
    }
end

module ModifyLaunchTemplateRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; client_token : String.t option
    ; launch_template_id : String.t option
    ; launch_template_name : String.t option
    ; default_version : String.t option
    }

  let make
      ?dry_run
      ?client_token
      ?launch_template_id
      ?launch_template_name
      ?default_version
      () =
    { dry_run; client_token; launch_template_id; launch_template_name; default_version }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; launch_template_id =
          Aws.Util.option_bind (Aws.Xml.member "LaunchTemplateId" xml) String.parse
      ; launch_template_name =
          Aws.Util.option_bind (Aws.Xml.member "LaunchTemplateName" xml) String.parse
      ; default_version =
          Aws.Util.option_bind (Aws.Xml.member "SetDefaultVersion" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.default_version (fun f ->
               Aws.Query.Pair ("SetDefaultVersion", String.to_query f))
         ; Aws.Util.option_map v.launch_template_name (fun f ->
               Aws.Query.Pair ("LaunchTemplateName", String.to_query f))
         ; Aws.Util.option_map v.launch_template_id (fun f ->
               Aws.Query.Pair ("LaunchTemplateId", String.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.default_version (fun f ->
               "SetDefaultVersion", String.to_json f)
         ; Aws.Util.option_map v.launch_template_name (fun f ->
               "LaunchTemplateName", String.to_json f)
         ; Aws.Util.option_map v.launch_template_id (fun f ->
               "LaunchTemplateId", String.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; launch_template_id =
        Aws.Util.option_map (Aws.Json.lookup j "LaunchTemplateId") String.of_json
    ; launch_template_name =
        Aws.Util.option_map (Aws.Json.lookup j "LaunchTemplateName") String.of_json
    ; default_version =
        Aws.Util.option_map (Aws.Json.lookup j "SetDefaultVersion") String.of_json
    }
end

module DescribeVpcClassicLinkDnsSupportResult = struct
  type t =
    { next_token : String.t option
    ; vpcs : ClassicLinkDnsSupportList.t
    }

  let make ?next_token ?(vpcs = []) () = { next_token; vpcs }

  let parse xml =
    Some
      { next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; vpcs =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "vpcs" xml)
               ClassicLinkDnsSupportList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Vpcs", ClassicLinkDnsSupportList.to_query v.vpcs))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("vpcs", ClassicLinkDnsSupportList.to_json v.vpcs)
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ])

  let of_json j =
    { next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; vpcs =
        ClassicLinkDnsSupportList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "vpcs"))
    }
end

module DeleteTransitGatewayRouteTableRequest = struct
  type t =
    { transit_gateway_route_table_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~transit_gateway_route_table_id ?dry_run () =
    { transit_gateway_route_table_id; dry_run }

  let parse xml =
    Some
      { transit_gateway_route_table_id =
          Aws.Xml.required
            "TransitGatewayRouteTableId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayRouteTableId" xml)
               String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayRouteTableId"
                , String.to_query v.transit_gateway_route_table_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ( "TransitGatewayRouteTableId"
             , String.to_json v.transit_gateway_route_table_id )
         ])

  let of_json j =
    { transit_gateway_route_table_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayRouteTableId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DisableTransitGatewayRouteTablePropagationResult = struct
  type t = { propagation : TransitGatewayPropagation.t option }

  let make ?propagation () = { propagation }

  let parse xml =
    Some
      { propagation =
          Aws.Util.option_bind
            (Aws.Xml.member "propagation" xml)
            TransitGatewayPropagation.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.propagation (fun f ->
               Aws.Query.Pair ("Propagation", TransitGatewayPropagation.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.propagation (fun f ->
               "propagation", TransitGatewayPropagation.to_json f)
         ])

  let of_json j =
    { propagation =
        Aws.Util.option_map
          (Aws.Json.lookup j "propagation")
          TransitGatewayPropagation.of_json
    }
end

module CreateInstanceExportTaskResult = struct
  type t = { export_task : ExportTask.t option }

  let make ?export_task () = { export_task }

  let parse xml =
    Some
      { export_task =
          Aws.Util.option_bind (Aws.Xml.member "exportTask" xml) ExportTask.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.export_task (fun f ->
               Aws.Query.Pair ("ExportTask", ExportTask.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.export_task (fun f -> "exportTask", ExportTask.to_json f)
         ])

  let of_json j =
    { export_task =
        Aws.Util.option_map (Aws.Json.lookup j "exportTask") ExportTask.of_json
    }
end

module CreateClientVpnEndpointRequest = struct
  type t =
    { client_cidr_block : String.t
    ; server_certificate_arn : String.t
    ; authentication_options : ClientVpnAuthenticationRequestList.t
    ; connection_log_options : ConnectionLogOptions.t
    ; dns_servers : ValueStringList.t
    ; transport_protocol : TransportProtocol.t option
    ; vpn_port : Integer.t option
    ; description : String.t option
    ; split_tunnel : Boolean.t option
    ; dry_run : Boolean.t option
    ; client_token : String.t option
    ; tag_specifications : TagSpecificationList.t
    ; security_group_ids : ClientVpnSecurityGroupIdSet.t
    ; vpc_id : String.t option
    ; self_service_portal : SelfServicePortal.t option
    ; client_connect_options : ClientConnectOptions.t option
    }

  let make
      ~client_cidr_block
      ~server_certificate_arn
      ~authentication_options
      ~connection_log_options
      ?(dns_servers = [])
      ?transport_protocol
      ?vpn_port
      ?description
      ?split_tunnel
      ?dry_run
      ?client_token
      ?(tag_specifications = [])
      ?(security_group_ids = [])
      ?vpc_id
      ?self_service_portal
      ?client_connect_options
      () =
    { client_cidr_block
    ; server_certificate_arn
    ; authentication_options
    ; connection_log_options
    ; dns_servers
    ; transport_protocol
    ; vpn_port
    ; description
    ; split_tunnel
    ; dry_run
    ; client_token
    ; tag_specifications
    ; security_group_ids
    ; vpc_id
    ; self_service_portal
    ; client_connect_options
    }

  let parse xml =
    Some
      { client_cidr_block =
          Aws.Xml.required
            "ClientCidrBlock"
            (Aws.Util.option_bind (Aws.Xml.member "ClientCidrBlock" xml) String.parse)
      ; server_certificate_arn =
          Aws.Xml.required
            "ServerCertificateArn"
            (Aws.Util.option_bind
               (Aws.Xml.member "ServerCertificateArn" xml)
               String.parse)
      ; authentication_options =
          Aws.Xml.required
            "Authentication"
            (Aws.Util.option_bind
               (Aws.Xml.member "Authentication" xml)
               ClientVpnAuthenticationRequestList.parse)
      ; connection_log_options =
          Aws.Xml.required
            "ConnectionLogOptions"
            (Aws.Util.option_bind
               (Aws.Xml.member "ConnectionLogOptions" xml)
               ConnectionLogOptions.parse)
      ; dns_servers =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "DnsServers" xml) ValueStringList.parse)
      ; transport_protocol =
          Aws.Util.option_bind
            (Aws.Xml.member "TransportProtocol" xml)
            TransportProtocol.parse
      ; vpn_port = Aws.Util.option_bind (Aws.Xml.member "VpnPort" xml) Integer.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; split_tunnel =
          Aws.Util.option_bind (Aws.Xml.member "SplitTunnel" xml) Boolean.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      ; security_group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "SecurityGroupId" xml)
               ClientVpnSecurityGroupIdSet.parse)
      ; vpc_id = Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) String.parse
      ; self_service_portal =
          Aws.Util.option_bind
            (Aws.Xml.member "SelfServicePortal" xml)
            SelfServicePortal.parse
      ; client_connect_options =
          Aws.Util.option_bind
            (Aws.Xml.member "ClientConnectOptions" xml)
            ClientConnectOptions.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_connect_options (fun f ->
               Aws.Query.Pair ("ClientConnectOptions", ClientConnectOptions.to_query f))
         ; Aws.Util.option_map v.self_service_portal (fun f ->
               Aws.Query.Pair ("SelfServicePortal", SelfServicePortal.to_query f))
         ; Aws.Util.option_map v.vpc_id (fun f ->
               Aws.Query.Pair ("VpcId", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "SecurityGroupId"
                , ClientVpnSecurityGroupIdSet.to_query v.security_group_ids ))
         ; Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.split_tunnel (fun f ->
               Aws.Query.Pair ("SplitTunnel", Boolean.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.vpn_port (fun f ->
               Aws.Query.Pair ("VpnPort", Integer.to_query f))
         ; Aws.Util.option_map v.transport_protocol (fun f ->
               Aws.Query.Pair ("TransportProtocol", TransportProtocol.to_query f))
         ; Some (Aws.Query.Pair ("DnsServers", ValueStringList.to_query v.dns_servers))
         ; Some
             (Aws.Query.Pair
                ( "ConnectionLogOptions"
                , ConnectionLogOptions.to_query v.connection_log_options ))
         ; Some
             (Aws.Query.Pair
                ( "Authentication"
                , ClientVpnAuthenticationRequestList.to_query v.authentication_options ))
         ; Some
             (Aws.Query.Pair
                ("ServerCertificateArn", String.to_query v.server_certificate_arn))
         ; Some (Aws.Query.Pair ("ClientCidrBlock", String.to_query v.client_cidr_block))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_connect_options (fun f ->
               "ClientConnectOptions", ClientConnectOptions.to_json f)
         ; Aws.Util.option_map v.self_service_portal (fun f ->
               "SelfServicePortal", SelfServicePortal.to_json f)
         ; Aws.Util.option_map v.vpc_id (fun f -> "VpcId", String.to_json f)
         ; Some
             ("SecurityGroupId", ClientVpnSecurityGroupIdSet.to_json v.security_group_ids)
         ; Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.split_tunnel (fun f -> "SplitTunnel", Boolean.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.vpn_port (fun f -> "VpnPort", Integer.to_json f)
         ; Aws.Util.option_map v.transport_protocol (fun f ->
               "TransportProtocol", TransportProtocol.to_json f)
         ; Some ("DnsServers", ValueStringList.to_json v.dns_servers)
         ; Some
             ( "ConnectionLogOptions"
             , ConnectionLogOptions.to_json v.connection_log_options )
         ; Some
             ( "Authentication"
             , ClientVpnAuthenticationRequestList.to_json v.authentication_options )
         ; Some ("ServerCertificateArn", String.to_json v.server_certificate_arn)
         ; Some ("ClientCidrBlock", String.to_json v.client_cidr_block)
         ])

  let of_json j =
    { client_cidr_block =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ClientCidrBlock"))
    ; server_certificate_arn =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ServerCertificateArn"))
    ; authentication_options =
        ClientVpnAuthenticationRequestList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "Authentication"))
    ; connection_log_options =
        ConnectionLogOptions.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ConnectionLogOptions"))
    ; dns_servers =
        ValueStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "DnsServers"))
    ; transport_protocol =
        Aws.Util.option_map
          (Aws.Json.lookup j "TransportProtocol")
          TransportProtocol.of_json
    ; vpn_port = Aws.Util.option_map (Aws.Json.lookup j "VpnPort") Integer.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; split_tunnel = Aws.Util.option_map (Aws.Json.lookup j "SplitTunnel") Boolean.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    ; security_group_ids =
        ClientVpnSecurityGroupIdSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SecurityGroupId"))
    ; vpc_id = Aws.Util.option_map (Aws.Json.lookup j "VpcId") String.of_json
    ; self_service_portal =
        Aws.Util.option_map
          (Aws.Json.lookup j "SelfServicePortal")
          SelfServicePortal.of_json
    ; client_connect_options =
        Aws.Util.option_map
          (Aws.Json.lookup j "ClientConnectOptions")
          ClientConnectOptions.of_json
    }
end

module RegisterInstanceEventNotificationAttributesResult = struct
  type t = { instance_tag_attribute : InstanceTagNotificationAttribute.t option }

  let make ?instance_tag_attribute () = { instance_tag_attribute }

  let parse xml =
    Some
      { instance_tag_attribute =
          Aws.Util.option_bind
            (Aws.Xml.member "instanceTagAttribute" xml)
            InstanceTagNotificationAttribute.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_tag_attribute (fun f ->
               Aws.Query.Pair
                 ("InstanceTagAttribute", InstanceTagNotificationAttribute.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_tag_attribute (fun f ->
               "instanceTagAttribute", InstanceTagNotificationAttribute.to_json f)
         ])

  let of_json j =
    { instance_tag_attribute =
        Aws.Util.option_map
          (Aws.Json.lookup j "instanceTagAttribute")
          InstanceTagNotificationAttribute.of_json
    }
end

module CopyImageResult = struct
  type t = { image_id : String.t option }

  let make ?image_id () = { image_id }

  let parse xml =
    Some { image_id = Aws.Util.option_bind (Aws.Xml.member "imageId" xml) String.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.image_id (fun f ->
               Aws.Query.Pair ("ImageId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.image_id (fun f -> "imageId", String.to_json f) ])

  let of_json j =
    { image_id = Aws.Util.option_map (Aws.Json.lookup j "imageId") String.of_json }
end

module CancelBundleTaskRequest = struct
  type t =
    { bundle_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~bundle_id ?dry_run () = { bundle_id; dry_run }

  let parse xml =
    Some
      { bundle_id =
          Aws.Xml.required
            "BundleId"
            (Aws.Util.option_bind (Aws.Xml.member "BundleId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("BundleId", String.to_query v.bundle_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("BundleId", String.to_json v.bundle_id)
         ])

  let of_json j =
    { bundle_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "BundleId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module ModifyVpcEndpointServiceConfigurationResult = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module DescribeTransitGatewaysResult = struct
  type t =
    { transit_gateways : TransitGatewayList.t
    ; next_token : String.t option
    }

  let make ?(transit_gateways = []) ?next_token () = { transit_gateways; next_token }

  let parse xml =
    Some
      { transit_gateways =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "transitGatewaySet" xml)
               TransitGatewayList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TransitGatewaySet", TransitGatewayList.to_query v.transit_gateways))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("transitGatewaySet", TransitGatewayList.to_json v.transit_gateways)
         ])

  let of_json j =
    { transit_gateways =
        TransitGatewayList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "transitGatewaySet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module ModifyManagedPrefixListResult = struct
  type t = { prefix_list : ManagedPrefixList.t option }

  let make ?prefix_list () = { prefix_list }

  let parse xml =
    Some
      { prefix_list =
          Aws.Util.option_bind (Aws.Xml.member "prefixList" xml) ManagedPrefixList.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.prefix_list (fun f ->
               Aws.Query.Pair ("PrefixList", ManagedPrefixList.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.prefix_list (fun f ->
               "prefixList", ManagedPrefixList.to_json f)
         ])

  let of_json j =
    { prefix_list =
        Aws.Util.option_map (Aws.Json.lookup j "prefixList") ManagedPrefixList.of_json
    }
end

module DescribeIpv6PoolsRequest = struct
  type t =
    { pool_ids : Ipv6PoolIdList.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    ; dry_run : Boolean.t option
    ; filters : FilterList.t
    }

  let make ?(pool_ids = []) ?next_token ?max_results ?dry_run ?(filters = []) () =
    { pool_ids; next_token; max_results; dry_run; filters }

  let parse xml =
    Some
      { pool_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "PoolId" xml) Ipv6PoolIdList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("PoolId", Ipv6PoolIdList.to_query v.pool_ids))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Filter", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some ("PoolId", Ipv6PoolIdList.to_json v.pool_ids)
         ])

  let of_json j =
    { pool_ids =
        Ipv6PoolIdList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "PoolId"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    }
end

module LaunchPermissionModifications = struct
  type t =
    { add : LaunchPermissionList.t
    ; remove : LaunchPermissionList.t
    }

  let make ?(add = []) ?(remove = []) () = { add; remove }

  let parse xml =
    Some
      { add =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Add" xml) LaunchPermissionList.parse)
      ; remove =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "Remove" xml)
               LaunchPermissionList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("Remove", LaunchPermissionList.to_query v.remove))
         ; Some (Aws.Query.Pair ("Add", LaunchPermissionList.to_query v.add))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("Remove", LaunchPermissionList.to_json v.remove)
         ; Some ("Add", LaunchPermissionList.to_json v.add)
         ])

  let of_json j =
    { add =
        LaunchPermissionList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Add"))
    ; remove =
        LaunchPermissionList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Remove"))
    }
end

module GetManagedPrefixListEntriesResult = struct
  type t =
    { entries : PrefixListEntrySet.t
    ; next_token : String.t option
    }

  let make ?(entries = []) ?next_token () = { entries; next_token }

  let parse xml =
    Some
      { entries =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "entrySet" xml)
               PrefixListEntrySet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some (Aws.Query.Pair ("EntrySet", PrefixListEntrySet.to_query v.entries))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("entrySet", PrefixListEntrySet.to_json v.entries)
         ])

  let of_json j =
    { entries =
        PrefixListEntrySet.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "entrySet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module CancelSpotFleetRequestsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; spot_fleet_request_ids : SpotFleetRequestIdList.t
    ; terminate_instances : Boolean.t
    }

  let make ?dry_run ~spot_fleet_request_ids ~terminate_instances () =
    { dry_run; spot_fleet_request_ids; terminate_instances }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; spot_fleet_request_ids =
          Aws.Xml.required
            "spotFleetRequestId"
            (Aws.Util.option_bind
               (Aws.Xml.member "spotFleetRequestId" xml)
               SpotFleetRequestIdList.parse)
      ; terminate_instances =
          Aws.Xml.required
            "terminateInstances"
            (Aws.Util.option_bind (Aws.Xml.member "terminateInstances" xml) Boolean.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("TerminateInstances", Boolean.to_query v.terminate_instances))
         ; Some
             (Aws.Query.Pair
                ( "SpotFleetRequestId"
                , SpotFleetRequestIdList.to_query v.spot_fleet_request_ids ))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("terminateInstances", Boolean.to_json v.terminate_instances)
         ; Some
             ( "spotFleetRequestId"
             , SpotFleetRequestIdList.to_json v.spot_fleet_request_ids )
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; spot_fleet_request_ids =
        SpotFleetRequestIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "spotFleetRequestId"))
    ; terminate_instances =
        Boolean.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "terminateInstances"))
    }
end

module AssociateTransitGatewayMulticastDomainRequest = struct
  type t =
    { transit_gateway_multicast_domain_id : String.t option
    ; transit_gateway_attachment_id : String.t option
    ; subnet_ids : ValueStringList.t
    ; dry_run : Boolean.t option
    }

  let make
      ?transit_gateway_multicast_domain_id
      ?transit_gateway_attachment_id
      ?(subnet_ids = [])
      ?dry_run
      () =
    { transit_gateway_multicast_domain_id
    ; transit_gateway_attachment_id
    ; subnet_ids
    ; dry_run
    }

  let parse xml =
    Some
      { transit_gateway_multicast_domain_id =
          Aws.Util.option_bind
            (Aws.Xml.member "TransitGatewayMulticastDomainId" xml)
            String.parse
      ; transit_gateway_attachment_id =
          Aws.Util.option_bind
            (Aws.Xml.member "TransitGatewayAttachmentId" xml)
            String.parse
      ; subnet_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "SubnetIds" xml) ValueStringList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("SubnetIds", ValueStringList.to_query v.subnet_ids))
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               Aws.Query.Pair ("TransitGatewayAttachmentId", String.to_query f))
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               Aws.Query.Pair ("TransitGatewayMulticastDomainId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("SubnetIds", ValueStringList.to_json v.subnet_ids)
         ; Aws.Util.option_map v.transit_gateway_attachment_id (fun f ->
               "TransitGatewayAttachmentId", String.to_json f)
         ; Aws.Util.option_map v.transit_gateway_multicast_domain_id (fun f ->
               "TransitGatewayMulticastDomainId", String.to_json f)
         ])

  let of_json j =
    { transit_gateway_multicast_domain_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "TransitGatewayMulticastDomainId")
          String.of_json
    ; transit_gateway_attachment_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "TransitGatewayAttachmentId")
          String.of_json
    ; subnet_ids =
        ValueStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "SubnetIds"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DisassociateVpcCidrBlockRequest = struct
  type t = { association_id : String.t }

  let make ~association_id () = { association_id }

  let parse xml =
    Some
      { association_id =
          Aws.Xml.required
            "associationId"
            (Aws.Util.option_bind (Aws.Xml.member "associationId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("AssociationId", String.to_query v.association_id)) ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("associationId", String.to_json v.association_id) ])

  let of_json j =
    { association_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "associationId"))
    }
end

module GetDefaultCreditSpecificationRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; instance_family : UnlimitedSupportedInstanceFamily.t
    }

  let make ?dry_run ~instance_family () = { dry_run; instance_family }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; instance_family =
          Aws.Xml.required
            "InstanceFamily"
            (Aws.Util.option_bind
               (Aws.Xml.member "InstanceFamily" xml)
               UnlimitedSupportedInstanceFamily.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "InstanceFamily"
                , UnlimitedSupportedInstanceFamily.to_query v.instance_family ))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ("InstanceFamily", UnlimitedSupportedInstanceFamily.to_json v.instance_family)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; instance_family =
        UnlimitedSupportedInstanceFamily.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceFamily"))
    }
end

module DeleteRouteTableRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; route_table_id : String.t
    }

  let make ?dry_run ~route_table_id () = { dry_run; route_table_id }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; route_table_id =
          Aws.Xml.required
            "routeTableId"
            (Aws.Util.option_bind (Aws.Xml.member "routeTableId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("RouteTableId", String.to_query v.route_table_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("routeTableId", String.to_json v.route_table_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; route_table_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "routeTableId"))
    }
end

module DeleteSpotDatafeedSubscriptionRequest = struct
  type t = { dry_run : Boolean.t option }

  let make ?dry_run () = { dry_run }

  let parse xml =
    Some { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f) ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json }
end

module CreateManagedPrefixListResult = struct
  type t = { prefix_list : ManagedPrefixList.t option }

  let make ?prefix_list () = { prefix_list }

  let parse xml =
    Some
      { prefix_list =
          Aws.Util.option_bind (Aws.Xml.member "prefixList" xml) ManagedPrefixList.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.prefix_list (fun f ->
               Aws.Query.Pair ("PrefixList", ManagedPrefixList.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.prefix_list (fun f ->
               "prefixList", ManagedPrefixList.to_json f)
         ])

  let of_json j =
    { prefix_list =
        Aws.Util.option_map (Aws.Json.lookup j "prefixList") ManagedPrefixList.of_json
    }
end

module AttachClassicLinkVpcResult = struct
  type t = { return : Boolean.t option }

  let make ?return () = { return }

  let parse xml =
    Some { return = Aws.Util.option_bind (Aws.Xml.member "return" xml) Boolean.parse }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f ->
               Aws.Query.Pair ("Return", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.return (fun f -> "return", Boolean.to_json f) ])

  let of_json j =
    { return = Aws.Util.option_map (Aws.Json.lookup j "return") Boolean.of_json }
end

module ReplaceNetworkAclAssociationResult = struct
  type t = { new_association_id : String.t option }

  let make ?new_association_id () = { new_association_id }

  let parse xml =
    Some
      { new_association_id =
          Aws.Util.option_bind (Aws.Xml.member "newAssociationId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.new_association_id (fun f ->
               Aws.Query.Pair ("NewAssociationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.new_association_id (fun f ->
               "newAssociationId", String.to_json f)
         ])

  let of_json j =
    { new_association_id =
        Aws.Util.option_map (Aws.Json.lookup j "newAssociationId") String.of_json
    }
end

module DeleteTransitGatewayPeeringAttachmentRequest = struct
  type t =
    { transit_gateway_attachment_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~transit_gateway_attachment_id ?dry_run () =
    { transit_gateway_attachment_id; dry_run }

  let parse xml =
    Some
      { transit_gateway_attachment_id =
          Aws.Xml.required
            "TransitGatewayAttachmentId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayAttachmentId" xml)
               String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayAttachmentId"
                , String.to_query v.transit_gateway_attachment_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ("TransitGatewayAttachmentId", String.to_json v.transit_gateway_attachment_id)
         ])

  let of_json j =
    { transit_gateway_attachment_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayAttachmentId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module UnassignPrivateIpAddressesRequest = struct
  type t =
    { network_interface_id : String.t
    ; private_ip_addresses : PrivateIpAddressStringList.t
    }

  let make ~network_interface_id ~private_ip_addresses () =
    { network_interface_id; private_ip_addresses }

  let parse xml =
    Some
      { network_interface_id =
          Aws.Xml.required
            "networkInterfaceId"
            (Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse)
      ; private_ip_addresses =
          Aws.Xml.required
            "privateIpAddress"
            (Aws.Util.option_bind
               (Aws.Xml.member "privateIpAddress" xml)
               PrivateIpAddressStringList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "PrivateIpAddress"
                , PrivateIpAddressStringList.to_query v.private_ip_addresses ))
         ; Some
             (Aws.Query.Pair ("NetworkInterfaceId", String.to_query v.network_interface_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "privateIpAddress"
             , PrivateIpAddressStringList.to_json v.private_ip_addresses )
         ; Some ("networkInterfaceId", String.to_json v.network_interface_id)
         ])

  let of_json j =
    { network_interface_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "networkInterfaceId"))
    ; private_ip_addresses =
        PrivateIpAddressStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "privateIpAddress"))
    }
end

module DescribeTrafficMirrorTargetsRequest = struct
  type t =
    { traffic_mirror_target_ids : TrafficMirrorTargetIdList.t
    ; dry_run : Boolean.t option
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make
      ?(traffic_mirror_target_ids = [])
      ?dry_run
      ?(filters = [])
      ?max_results
      ?next_token
      () =
    { traffic_mirror_target_ids; dry_run; filters; max_results; next_token }

  let parse xml =
    Some
      { traffic_mirror_target_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TrafficMirrorTargetId" xml)
               TrafficMirrorTargetIdList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TrafficMirrorTargetId"
                , TrafficMirrorTargetIdList.to_query v.traffic_mirror_target_ids ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ( "TrafficMirrorTargetId"
             , TrafficMirrorTargetIdList.to_json v.traffic_mirror_target_ids )
         ])

  let of_json j =
    { traffic_mirror_target_ids =
        TrafficMirrorTargetIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TrafficMirrorTargetId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module DescribeTrafficMirrorFiltersResult = struct
  type t =
    { traffic_mirror_filters : TrafficMirrorFilterSet.t
    ; next_token : String.t option
    }

  let make ?(traffic_mirror_filters = []) ?next_token () =
    { traffic_mirror_filters; next_token }

  let parse xml =
    Some
      { traffic_mirror_filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "trafficMirrorFilterSet" xml)
               TrafficMirrorFilterSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TrafficMirrorFilterSet"
                , TrafficMirrorFilterSet.to_query v.traffic_mirror_filters ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "trafficMirrorFilterSet"
             , TrafficMirrorFilterSet.to_json v.traffic_mirror_filters )
         ])

  let of_json j =
    { traffic_mirror_filters =
        TrafficMirrorFilterSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "trafficMirrorFilterSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DeleteVpnGatewayRequest = struct
  type t =
    { vpn_gateway_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~vpn_gateway_id ?dry_run () = { vpn_gateway_id; dry_run }

  let parse xml =
    Some
      { vpn_gateway_id =
          Aws.Xml.required
            "VpnGatewayId"
            (Aws.Util.option_bind (Aws.Xml.member "VpnGatewayId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("VpnGatewayId", String.to_query v.vpn_gateway_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("VpnGatewayId", String.to_json v.vpn_gateway_id)
         ])

  let of_json j =
    { vpn_gateway_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpnGatewayId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module DisassociateClientVpnTargetNetworkRequest = struct
  type t =
    { client_vpn_endpoint_id : String.t
    ; association_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~client_vpn_endpoint_id ~association_id ?dry_run () =
    { client_vpn_endpoint_id; association_id; dry_run }

  let parse xml =
    Some
      { client_vpn_endpoint_id =
          Aws.Xml.required
            "ClientVpnEndpointId"
            (Aws.Util.option_bind (Aws.Xml.member "ClientVpnEndpointId" xml) String.parse)
      ; association_id =
          Aws.Xml.required
            "AssociationId"
            (Aws.Util.option_bind (Aws.Xml.member "AssociationId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("AssociationId", String.to_query v.association_id))
         ; Some
             (Aws.Query.Pair
                ("ClientVpnEndpointId", String.to_query v.client_vpn_endpoint_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("AssociationId", String.to_json v.association_id)
         ; Some ("ClientVpnEndpointId", String.to_json v.client_vpn_endpoint_id)
         ])

  let of_json j =
    { client_vpn_endpoint_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ClientVpnEndpointId"))
    ; association_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "AssociationId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module RejectTransitGatewayPeeringAttachmentRequest = struct
  type t =
    { transit_gateway_attachment_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~transit_gateway_attachment_id ?dry_run () =
    { transit_gateway_attachment_id; dry_run }

  let parse xml =
    Some
      { transit_gateway_attachment_id =
          Aws.Xml.required
            "TransitGatewayAttachmentId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayAttachmentId" xml)
               String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayAttachmentId"
                , String.to_query v.transit_gateway_attachment_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ("TransitGatewayAttachmentId", String.to_json v.transit_gateway_attachment_id)
         ])

  let of_json j =
    { transit_gateway_attachment_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayAttachmentId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DisassociateIamInstanceProfileRequest = struct
  type t = { association_id : String.t }

  let make ~association_id () = { association_id }

  let parse xml =
    Some
      { association_id =
          Aws.Xml.required
            "AssociationId"
            (Aws.Util.option_bind (Aws.Xml.member "AssociationId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("AssociationId", String.to_query v.association_id)) ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("AssociationId", String.to_json v.association_id) ])

  let of_json j =
    { association_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "AssociationId"))
    }
end

module DisassociateTransitGatewayRouteTableRequest = struct
  type t =
    { transit_gateway_route_table_id : String.t
    ; transit_gateway_attachment_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~transit_gateway_route_table_id ~transit_gateway_attachment_id ?dry_run () =
    { transit_gateway_route_table_id; transit_gateway_attachment_id; dry_run }

  let parse xml =
    Some
      { transit_gateway_route_table_id =
          Aws.Xml.required
            "TransitGatewayRouteTableId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayRouteTableId" xml)
               String.parse)
      ; transit_gateway_attachment_id =
          Aws.Xml.required
            "TransitGatewayAttachmentId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayAttachmentId" xml)
               String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayAttachmentId"
                , String.to_query v.transit_gateway_attachment_id ))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayRouteTableId"
                , String.to_query v.transit_gateway_route_table_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ("TransitGatewayAttachmentId", String.to_json v.transit_gateway_attachment_id)
         ; Some
             ( "TransitGatewayRouteTableId"
             , String.to_json v.transit_gateway_route_table_id )
         ])

  let of_json j =
    { transit_gateway_route_table_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayRouteTableId"))
    ; transit_gateway_attachment_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayAttachmentId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DescribeTransitGatewayRouteTablesRequest = struct
  type t =
    { transit_gateway_route_table_ids : TransitGatewayRouteTableIdStringList.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make
      ?(transit_gateway_route_table_ids = [])
      ?(filters = [])
      ?max_results
      ?next_token
      ?dry_run
      () =
    { transit_gateway_route_table_ids; filters; max_results; next_token; dry_run }

  let parse xml =
    Some
      { transit_gateway_route_table_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayRouteTableIds" xml)
               TransitGatewayRouteTableIdStringList.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayRouteTableIds"
                , TransitGatewayRouteTableIdStringList.to_query
                    v.transit_gateway_route_table_ids ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some
             ( "TransitGatewayRouteTableIds"
             , TransitGatewayRouteTableIdStringList.to_json
                 v.transit_gateway_route_table_ids )
         ])

  let of_json j =
    { transit_gateway_route_table_ids =
        TransitGatewayRouteTableIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayRouteTableIds"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module RestoreAddressToClassicResult = struct
  type t =
    { public_ip : String.t option
    ; status : Status.t option
    }

  let make ?public_ip ?status () = { public_ip; status }

  let parse xml =
    Some
      { public_ip = Aws.Util.option_bind (Aws.Xml.member "publicIp" xml) String.parse
      ; status = Aws.Util.option_bind (Aws.Xml.member "status" xml) Status.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f ->
               Aws.Query.Pair ("Status", Status.to_query f))
         ; Aws.Util.option_map v.public_ip (fun f ->
               Aws.Query.Pair ("PublicIp", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.status (fun f -> "status", Status.to_json f)
         ; Aws.Util.option_map v.public_ip (fun f -> "publicIp", String.to_json f)
         ])

  let of_json j =
    { public_ip = Aws.Util.option_map (Aws.Json.lookup j "publicIp") String.of_json
    ; status = Aws.Util.option_map (Aws.Json.lookup j "status") Status.of_json
    }
end

module CreateNetworkInterfaceResult = struct
  type t = { network_interface : NetworkInterface.t option }

  let make ?network_interface () = { network_interface }

  let parse xml =
    Some
      { network_interface =
          Aws.Util.option_bind
            (Aws.Xml.member "networkInterface" xml)
            NetworkInterface.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.network_interface (fun f ->
               Aws.Query.Pair ("NetworkInterface", NetworkInterface.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.network_interface (fun f ->
               "networkInterface", NetworkInterface.to_json f)
         ])

  let of_json j =
    { network_interface =
        Aws.Util.option_map
          (Aws.Json.lookup j "networkInterface")
          NetworkInterface.of_json
    }
end

module CreateFlowLogsResult = struct
  type t =
    { client_token : String.t option
    ; flow_log_ids : ValueStringList.t
    ; unsuccessful : UnsuccessfulItemSet.t
    }

  let make ?client_token ?(flow_log_ids = []) ?(unsuccessful = []) () =
    { client_token; flow_log_ids; unsuccessful }

  let parse xml =
    Some
      { client_token =
          Aws.Util.option_bind (Aws.Xml.member "clientToken" xml) String.parse
      ; flow_log_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "flowLogIdSet" xml)
               ValueStringList.parse)
      ; unsuccessful =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "unsuccessful" xml)
               UnsuccessfulItemSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair ("Unsuccessful", UnsuccessfulItemSet.to_query v.unsuccessful))
         ; Some (Aws.Query.Pair ("FlowLogIdSet", ValueStringList.to_query v.flow_log_ids))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("unsuccessful", UnsuccessfulItemSet.to_json v.unsuccessful)
         ; Some ("flowLogIdSet", ValueStringList.to_json v.flow_log_ids)
         ; Aws.Util.option_map v.client_token (fun f -> "clientToken", String.to_json f)
         ])

  let of_json j =
    { client_token = Aws.Util.option_map (Aws.Json.lookup j "clientToken") String.of_json
    ; flow_log_ids =
        ValueStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "flowLogIdSet"))
    ; unsuccessful =
        UnsuccessfulItemSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "unsuccessful"))
    }
end

module GetAssociatedEnclaveCertificateIamRolesResult = struct
  type t = { associated_roles : AssociatedRolesList.t }

  let make ?(associated_roles = []) () = { associated_roles }

  let parse xml =
    Some
      { associated_roles =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "associatedRoleSet" xml)
               AssociatedRolesList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("AssociatedRoleSet", AssociatedRolesList.to_query v.associated_roles))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("associatedRoleSet", AssociatedRolesList.to_json v.associated_roles) ])

  let of_json j =
    { associated_roles =
        AssociatedRolesList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "associatedRoleSet"))
    }
end

module RequestSpotInstancesRequest = struct
  type t =
    { availability_zone_group : String.t option
    ; block_duration_minutes : Integer.t option
    ; client_token : String.t option
    ; dry_run : Boolean.t option
    ; instance_count : Integer.t option
    ; launch_group : String.t option
    ; launch_specification : RequestSpotLaunchSpecification.t option
    ; spot_price : String.t option
    ; type_ : SpotInstanceType.t option
    ; valid_from : DateTime.t option
    ; valid_until : DateTime.t option
    ; tag_specifications : TagSpecificationList.t
    ; instance_interruption_behavior : InstanceInterruptionBehavior.t option
    }

  let make
      ?availability_zone_group
      ?block_duration_minutes
      ?client_token
      ?dry_run
      ?instance_count
      ?launch_group
      ?launch_specification
      ?spot_price
      ?type_
      ?valid_from
      ?valid_until
      ?(tag_specifications = [])
      ?instance_interruption_behavior
      () =
    { availability_zone_group
    ; block_duration_minutes
    ; client_token
    ; dry_run
    ; instance_count
    ; launch_group
    ; launch_specification
    ; spot_price
    ; type_
    ; valid_from
    ; valid_until
    ; tag_specifications
    ; instance_interruption_behavior
    }

  let parse xml =
    Some
      { availability_zone_group =
          Aws.Util.option_bind (Aws.Xml.member "availabilityZoneGroup" xml) String.parse
      ; block_duration_minutes =
          Aws.Util.option_bind (Aws.Xml.member "blockDurationMinutes" xml) Integer.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "clientToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; instance_count =
          Aws.Util.option_bind (Aws.Xml.member "instanceCount" xml) Integer.parse
      ; launch_group =
          Aws.Util.option_bind (Aws.Xml.member "launchGroup" xml) String.parse
      ; launch_specification =
          Aws.Util.option_bind
            (Aws.Xml.member "LaunchSpecification" xml)
            RequestSpotLaunchSpecification.parse
      ; spot_price = Aws.Util.option_bind (Aws.Xml.member "spotPrice" xml) String.parse
      ; type_ = Aws.Util.option_bind (Aws.Xml.member "type" xml) SpotInstanceType.parse
      ; valid_from = Aws.Util.option_bind (Aws.Xml.member "validFrom" xml) DateTime.parse
      ; valid_until =
          Aws.Util.option_bind (Aws.Xml.member "validUntil" xml) DateTime.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      ; instance_interruption_behavior =
          Aws.Util.option_bind
            (Aws.Xml.member "InstanceInterruptionBehavior" xml)
            InstanceInterruptionBehavior.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_interruption_behavior (fun f ->
               Aws.Query.Pair
                 ("InstanceInterruptionBehavior", InstanceInterruptionBehavior.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Aws.Util.option_map v.valid_until (fun f ->
               Aws.Query.Pair ("ValidUntil", DateTime.to_query f))
         ; Aws.Util.option_map v.valid_from (fun f ->
               Aws.Query.Pair ("ValidFrom", DateTime.to_query f))
         ; Aws.Util.option_map v.type_ (fun f ->
               Aws.Query.Pair ("Type", SpotInstanceType.to_query f))
         ; Aws.Util.option_map v.spot_price (fun f ->
               Aws.Query.Pair ("SpotPrice", String.to_query f))
         ; Aws.Util.option_map v.launch_specification (fun f ->
               Aws.Query.Pair
                 ("LaunchSpecification", RequestSpotLaunchSpecification.to_query f))
         ; Aws.Util.option_map v.launch_group (fun f ->
               Aws.Query.Pair ("LaunchGroup", String.to_query f))
         ; Aws.Util.option_map v.instance_count (fun f ->
               Aws.Query.Pair ("InstanceCount", Integer.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.block_duration_minutes (fun f ->
               Aws.Query.Pair ("BlockDurationMinutes", Integer.to_query f))
         ; Aws.Util.option_map v.availability_zone_group (fun f ->
               Aws.Query.Pair ("AvailabilityZoneGroup", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.instance_interruption_behavior (fun f ->
               "InstanceInterruptionBehavior", InstanceInterruptionBehavior.to_json f)
         ; Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Aws.Util.option_map v.valid_until (fun f -> "validUntil", DateTime.to_json f)
         ; Aws.Util.option_map v.valid_from (fun f -> "validFrom", DateTime.to_json f)
         ; Aws.Util.option_map v.type_ (fun f -> "type", SpotInstanceType.to_json f)
         ; Aws.Util.option_map v.spot_price (fun f -> "spotPrice", String.to_json f)
         ; Aws.Util.option_map v.launch_specification (fun f ->
               "LaunchSpecification", RequestSpotLaunchSpecification.to_json f)
         ; Aws.Util.option_map v.launch_group (fun f -> "launchGroup", String.to_json f)
         ; Aws.Util.option_map v.instance_count (fun f ->
               "instanceCount", Integer.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "clientToken", String.to_json f)
         ; Aws.Util.option_map v.block_duration_minutes (fun f ->
               "blockDurationMinutes", Integer.to_json f)
         ; Aws.Util.option_map v.availability_zone_group (fun f ->
               "availabilityZoneGroup", String.to_json f)
         ])

  let of_json j =
    { availability_zone_group =
        Aws.Util.option_map (Aws.Json.lookup j "availabilityZoneGroup") String.of_json
    ; block_duration_minutes =
        Aws.Util.option_map (Aws.Json.lookup j "blockDurationMinutes") Integer.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "clientToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; instance_count =
        Aws.Util.option_map (Aws.Json.lookup j "instanceCount") Integer.of_json
    ; launch_group = Aws.Util.option_map (Aws.Json.lookup j "launchGroup") String.of_json
    ; launch_specification =
        Aws.Util.option_map
          (Aws.Json.lookup j "LaunchSpecification")
          RequestSpotLaunchSpecification.of_json
    ; spot_price = Aws.Util.option_map (Aws.Json.lookup j "spotPrice") String.of_json
    ; type_ = Aws.Util.option_map (Aws.Json.lookup j "type") SpotInstanceType.of_json
    ; valid_from = Aws.Util.option_map (Aws.Json.lookup j "validFrom") DateTime.of_json
    ; valid_until = Aws.Util.option_map (Aws.Json.lookup j "validUntil") DateTime.of_json
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    ; instance_interruption_behavior =
        Aws.Util.option_map
          (Aws.Json.lookup j "InstanceInterruptionBehavior")
          InstanceInterruptionBehavior.of_json
    }
end

module ExportImageRequest = struct
  type t =
    { client_token : String.t option
    ; description : String.t option
    ; disk_image_format : DiskImageFormat.t
    ; dry_run : Boolean.t option
    ; image_id : String.t
    ; s3_export_location : ExportTaskS3LocationRequest.t
    ; role_name : String.t option
    ; tag_specifications : TagSpecificationList.t
    }

  let make
      ?client_token
      ?description
      ~disk_image_format
      ?dry_run
      ~image_id
      ~s3_export_location
      ?role_name
      ?(tag_specifications = [])
      () =
    { client_token
    ; description
    ; disk_image_format
    ; dry_run
    ; image_id
    ; s3_export_location
    ; role_name
    ; tag_specifications
    }

  let parse xml =
    Some
      { client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; description = Aws.Util.option_bind (Aws.Xml.member "Description" xml) String.parse
      ; disk_image_format =
          Aws.Xml.required
            "DiskImageFormat"
            (Aws.Util.option_bind
               (Aws.Xml.member "DiskImageFormat" xml)
               DiskImageFormat.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; image_id =
          Aws.Xml.required
            "ImageId"
            (Aws.Util.option_bind (Aws.Xml.member "ImageId" xml) String.parse)
      ; s3_export_location =
          Aws.Xml.required
            "S3ExportLocation"
            (Aws.Util.option_bind
               (Aws.Xml.member "S3ExportLocation" xml)
               ExportTaskS3LocationRequest.parse)
      ; role_name = Aws.Util.option_bind (Aws.Xml.member "RoleName" xml) String.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Aws.Util.option_map v.role_name (fun f ->
               Aws.Query.Pair ("RoleName", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "S3ExportLocation"
                , ExportTaskS3LocationRequest.to_query v.s3_export_location ))
         ; Some (Aws.Query.Pair ("ImageId", String.to_query v.image_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("DiskImageFormat", DiskImageFormat.to_query v.disk_image_format))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Aws.Util.option_map v.role_name (fun f -> "RoleName", String.to_json f)
         ; Some
             ("S3ExportLocation", ExportTaskS3LocationRequest.to_json v.s3_export_location)
         ; Some ("ImageId", String.to_json v.image_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("DiskImageFormat", DiskImageFormat.to_json v.disk_image_format)
         ; Aws.Util.option_map v.description (fun f -> "Description", String.to_json f)
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ])

  let of_json j =
    { client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; description = Aws.Util.option_map (Aws.Json.lookup j "Description") String.of_json
    ; disk_image_format =
        DiskImageFormat.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "DiskImageFormat"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; image_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ImageId"))
    ; s3_export_location =
        ExportTaskS3LocationRequest.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "S3ExportLocation"))
    ; role_name = Aws.Util.option_map (Aws.Json.lookup j "RoleName") String.of_json
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    }
end

module DescribeExportImageTasksResult = struct
  type t =
    { export_image_tasks : ExportImageTaskList.t
    ; next_token : String.t option
    }

  let make ?(export_image_tasks = []) ?next_token () = { export_image_tasks; next_token }

  let parse xml =
    Some
      { export_image_tasks =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "exportImageTaskSet" xml)
               ExportImageTaskList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("ExportImageTaskSet", ExportImageTaskList.to_query v.export_image_tasks))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("exportImageTaskSet", ExportImageTaskList.to_json v.export_image_tasks)
         ])

  let of_json j =
    { export_image_tasks =
        ExportImageTaskList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "exportImageTaskSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DescribeSecurityGroupsRequest = struct
  type t =
    { filters : FilterList.t
    ; group_ids : GroupIdStringList.t
    ; group_names : GroupNameStringList.t
    ; dry_run : Boolean.t option
    ; next_token : String.t option
    ; max_results : Integer.t option
    }

  let make
      ?(filters = [])
      ?(group_ids = [])
      ?(group_names = [])
      ?dry_run
      ?next_token
      ?max_results
      () =
    { filters; group_ids; group_names; dry_run; next_token; max_results }

  let parse xml =
    Some
      { filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; group_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "GroupId" xml) GroupIdStringList.parse)
      ; group_names =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "GroupName" xml)
               GroupNameStringList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("GroupName", GroupNameStringList.to_query v.group_names))
         ; Some (Aws.Query.Pair ("GroupId", GroupIdStringList.to_query v.group_ids))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("GroupName", GroupNameStringList.to_json v.group_names)
         ; Some ("GroupId", GroupIdStringList.to_json v.group_ids)
         ; Some ("Filter", FilterList.to_json v.filters)
         ])

  let of_json j =
    { filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; group_ids =
        GroupIdStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "GroupId"))
    ; group_names =
        GroupNameStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "GroupName"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    }
end

module DescribeVpcEndpointConnectionNotificationsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; connection_notification_id : String.t option
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make
      ?dry_run
      ?connection_notification_id
      ?(filters = [])
      ?max_results
      ?next_token
      () =
    { dry_run; connection_notification_id; filters; max_results; next_token }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; connection_notification_id =
          Aws.Util.option_bind
            (Aws.Xml.member "ConnectionNotificationId" xml)
            String.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.connection_notification_id (fun f ->
               Aws.Query.Pair ("ConnectionNotificationId", String.to_query f))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.connection_notification_id (fun f ->
               "ConnectionNotificationId", String.to_json f)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; connection_notification_id =
        Aws.Util.option_map (Aws.Json.lookup j "ConnectionNotificationId") String.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module CreateCustomerGatewayRequest = struct
  type t =
    { bgp_asn : Integer.t
    ; public_ip : String.t option
    ; certificate_arn : String.t option
    ; type_ : GatewayType.t
    ; tag_specifications : TagSpecificationList.t
    ; device_name : String.t option
    ; dry_run : Boolean.t option
    }

  let make
      ~bgp_asn
      ?public_ip
      ?certificate_arn
      ~type_
      ?(tag_specifications = [])
      ?device_name
      ?dry_run
      () =
    { bgp_asn
    ; public_ip
    ; certificate_arn
    ; type_
    ; tag_specifications
    ; device_name
    ; dry_run
    }

  let parse xml =
    Some
      { bgp_asn =
          Aws.Xml.required
            "BgpAsn"
            (Aws.Util.option_bind (Aws.Xml.member "BgpAsn" xml) Integer.parse)
      ; public_ip = Aws.Util.option_bind (Aws.Xml.member "IpAddress" xml) String.parse
      ; certificate_arn =
          Aws.Util.option_bind (Aws.Xml.member "CertificateArn" xml) String.parse
      ; type_ =
          Aws.Xml.required
            "Type"
            (Aws.Util.option_bind (Aws.Xml.member "Type" xml) GatewayType.parse)
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      ; device_name = Aws.Util.option_bind (Aws.Xml.member "DeviceName" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.device_name (fun f ->
               Aws.Query.Pair ("DeviceName", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Some (Aws.Query.Pair ("Type", GatewayType.to_query v.type_))
         ; Aws.Util.option_map v.certificate_arn (fun f ->
               Aws.Query.Pair ("CertificateArn", String.to_query f))
         ; Aws.Util.option_map v.public_ip (fun f ->
               Aws.Query.Pair ("IpAddress", String.to_query f))
         ; Some (Aws.Query.Pair ("BgpAsn", Integer.to_query v.bgp_asn))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.device_name (fun f -> "DeviceName", String.to_json f)
         ; Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Some ("Type", GatewayType.to_json v.type_)
         ; Aws.Util.option_map v.certificate_arn (fun f ->
               "CertificateArn", String.to_json f)
         ; Aws.Util.option_map v.public_ip (fun f -> "IpAddress", String.to_json f)
         ; Some ("BgpAsn", Integer.to_json v.bgp_asn)
         ])

  let of_json j =
    { bgp_asn = Integer.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "BgpAsn"))
    ; public_ip = Aws.Util.option_map (Aws.Json.lookup j "IpAddress") String.of_json
    ; certificate_arn =
        Aws.Util.option_map (Aws.Json.lookup j "CertificateArn") String.of_json
    ; type_ = GatewayType.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Type"))
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    ; device_name = Aws.Util.option_map (Aws.Json.lookup j "DeviceName") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module AssociateAddressResult = struct
  type t = { association_id : String.t option }

  let make ?association_id () = { association_id }

  let parse xml =
    Some
      { association_id =
          Aws.Util.option_bind (Aws.Xml.member "associationId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_id (fun f ->
               Aws.Query.Pair ("AssociationId", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.association_id (fun f ->
               "associationId", String.to_json f)
         ])

  let of_json j =
    { association_id =
        Aws.Util.option_map (Aws.Json.lookup j "associationId") String.of_json
    }
end

module CreateLocalGatewayRouteTableVpcAssociationRequest = struct
  type t =
    { local_gateway_route_table_id : String.t
    ; vpc_id : String.t
    ; tag_specifications : TagSpecificationList.t
    ; dry_run : Boolean.t option
    }

  let make ~local_gateway_route_table_id ~vpc_id ?(tag_specifications = []) ?dry_run () =
    { local_gateway_route_table_id; vpc_id; tag_specifications; dry_run }

  let parse xml =
    Some
      { local_gateway_route_table_id =
          Aws.Xml.required
            "LocalGatewayRouteTableId"
            (Aws.Util.option_bind
               (Aws.Xml.member "LocalGatewayRouteTableId" xml)
               String.parse)
      ; vpc_id =
          Aws.Xml.required
            "VpcId"
            (Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) String.parse)
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ; Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ; Some
             (Aws.Query.Pair
                ( "LocalGatewayRouteTableId"
                , String.to_query v.local_gateway_route_table_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ; Some ("VpcId", String.to_json v.vpc_id)
         ; Some ("LocalGatewayRouteTableId", String.to_json v.local_gateway_route_table_id)
         ])

  let of_json j =
    { local_gateway_route_table_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "LocalGatewayRouteTableId"))
    ; vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcId"))
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module AssociateRouteTableRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; route_table_id : String.t
    ; subnet_id : String.t option
    ; gateway_id : String.t option
    }

  let make ?dry_run ~route_table_id ?subnet_id ?gateway_id () =
    { dry_run; route_table_id; subnet_id; gateway_id }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; route_table_id =
          Aws.Xml.required
            "routeTableId"
            (Aws.Util.option_bind (Aws.Xml.member "routeTableId" xml) String.parse)
      ; subnet_id = Aws.Util.option_bind (Aws.Xml.member "subnetId" xml) String.parse
      ; gateway_id = Aws.Util.option_bind (Aws.Xml.member "GatewayId" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.gateway_id (fun f ->
               Aws.Query.Pair ("GatewayId", String.to_query f))
         ; Aws.Util.option_map v.subnet_id (fun f ->
               Aws.Query.Pair ("SubnetId", String.to_query f))
         ; Some (Aws.Query.Pair ("RouteTableId", String.to_query v.route_table_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.gateway_id (fun f -> "GatewayId", String.to_json f)
         ; Aws.Util.option_map v.subnet_id (fun f -> "subnetId", String.to_json f)
         ; Some ("routeTableId", String.to_json v.route_table_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; route_table_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "routeTableId"))
    ; subnet_id = Aws.Util.option_map (Aws.Json.lookup j "subnetId") String.of_json
    ; gateway_id = Aws.Util.option_map (Aws.Json.lookup j "GatewayId") String.of_json
    }
end

module DescribeVpcEndpointConnectionsResult = struct
  type t =
    { vpc_endpoint_connections : VpcEndpointConnectionSet.t
    ; next_token : String.t option
    }

  let make ?(vpc_endpoint_connections = []) ?next_token () =
    { vpc_endpoint_connections; next_token }

  let parse xml =
    Some
      { vpc_endpoint_connections =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "vpcEndpointConnectionSet" xml)
               VpcEndpointConnectionSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "VpcEndpointConnectionSet"
                , VpcEndpointConnectionSet.to_query v.vpc_endpoint_connections ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "vpcEndpointConnectionSet"
             , VpcEndpointConnectionSet.to_json v.vpc_endpoint_connections )
         ])

  let of_json j =
    { vpc_endpoint_connections =
        VpcEndpointConnectionSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "vpcEndpointConnectionSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module ModifyReservedInstancesRequest = struct
  type t =
    { reserved_instances_ids : ReservedInstancesIdStringList.t
    ; client_token : String.t option
    ; target_configurations : ReservedInstancesConfigurationList.t
    }

  let make ~reserved_instances_ids ?client_token ~target_configurations () =
    { reserved_instances_ids; client_token; target_configurations }

  let parse xml =
    Some
      { reserved_instances_ids =
          Aws.Xml.required
            "ReservedInstancesId"
            (Aws.Util.option_bind
               (Aws.Xml.member "ReservedInstancesId" xml)
               ReservedInstancesIdStringList.parse)
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "clientToken" xml) String.parse
      ; target_configurations =
          Aws.Xml.required
            "ReservedInstancesConfigurationSetItemType"
            (Aws.Util.option_bind
               (Aws.Xml.member "ReservedInstancesConfigurationSetItemType" xml)
               ReservedInstancesConfigurationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "ReservedInstancesConfigurationSetItemType"
                , ReservedInstancesConfigurationList.to_query v.target_configurations ))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "ReservedInstancesId"
                , ReservedInstancesIdStringList.to_query v.reserved_instances_ids ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "ReservedInstancesConfigurationSetItemType"
             , ReservedInstancesConfigurationList.to_json v.target_configurations )
         ; Aws.Util.option_map v.client_token (fun f -> "clientToken", String.to_json f)
         ; Some
             ( "ReservedInstancesId"
             , ReservedInstancesIdStringList.to_json v.reserved_instances_ids )
         ])

  let of_json j =
    { reserved_instances_ids =
        ReservedInstancesIdStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ReservedInstancesId"))
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "clientToken") String.of_json
    ; target_configurations =
        ReservedInstancesConfigurationList.of_json
          (Aws.Util.of_option_exn
             (Aws.Json.lookup j "ReservedInstancesConfigurationSetItemType"))
    }
end

module DescribeLocalGatewaysRequest = struct
  type t =
    { local_gateway_ids : LocalGatewayIdSet.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make ?(local_gateway_ids = []) ?(filters = []) ?max_results ?next_token ?dry_run ()
      =
    { local_gateway_ids; filters; max_results; next_token; dry_run }

  let parse xml =
    Some
      { local_gateway_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "LocalGatewayId" xml)
               LocalGatewayIdSet.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ("LocalGatewayId", LocalGatewayIdSet.to_query v.local_gateway_ids))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some ("LocalGatewayId", LocalGatewayIdSet.to_json v.local_gateway_ids)
         ])

  let of_json j =
    { local_gateway_ids =
        LocalGatewayIdSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "LocalGatewayId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module CreateTransitGatewayVpcAttachmentRequest = struct
  type t =
    { transit_gateway_id : String.t
    ; vpc_id : String.t
    ; subnet_ids : TransitGatewaySubnetIdList.t
    ; options : CreateTransitGatewayVpcAttachmentRequestOptions.t option
    ; tag_specifications : TagSpecificationList.t
    ; dry_run : Boolean.t option
    }

  let make
      ~transit_gateway_id
      ~vpc_id
      ~subnet_ids
      ?options
      ?(tag_specifications = [])
      ?dry_run
      () =
    { transit_gateway_id; vpc_id; subnet_ids; options; tag_specifications; dry_run }

  let parse xml =
    Some
      { transit_gateway_id =
          Aws.Xml.required
            "TransitGatewayId"
            (Aws.Util.option_bind (Aws.Xml.member "TransitGatewayId" xml) String.parse)
      ; vpc_id =
          Aws.Xml.required
            "VpcId"
            (Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) String.parse)
      ; subnet_ids =
          Aws.Xml.required
            "SubnetIds"
            (Aws.Util.option_bind
               (Aws.Xml.member "SubnetIds" xml)
               TransitGatewaySubnetIdList.parse)
      ; options =
          Aws.Util.option_bind
            (Aws.Xml.member "Options" xml)
            CreateTransitGatewayVpcAttachmentRequestOptions.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecifications" xml)
               TagSpecificationList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TagSpecifications", TagSpecificationList.to_query v.tag_specifications))
         ; Aws.Util.option_map v.options (fun f ->
               Aws.Query.Pair
                 ("Options", CreateTransitGatewayVpcAttachmentRequestOptions.to_query f))
         ; Some
             (Aws.Query.Pair
                ("SubnetIds", TransitGatewaySubnetIdList.to_query v.subnet_ids))
         ; Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ; Some
             (Aws.Query.Pair ("TransitGatewayId", String.to_query v.transit_gateway_id))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("TagSpecifications", TagSpecificationList.to_json v.tag_specifications)
         ; Aws.Util.option_map v.options (fun f ->
               "Options", CreateTransitGatewayVpcAttachmentRequestOptions.to_json f)
         ; Some ("SubnetIds", TransitGatewaySubnetIdList.to_json v.subnet_ids)
         ; Some ("VpcId", String.to_json v.vpc_id)
         ; Some ("TransitGatewayId", String.to_json v.transit_gateway_id)
         ])

  let of_json j =
    { transit_gateway_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayId"))
    ; vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcId"))
    ; subnet_ids =
        TransitGatewaySubnetIdList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "SubnetIds"))
    ; options =
        Aws.Util.option_map
          (Aws.Json.lookup j "Options")
          CreateTransitGatewayVpcAttachmentRequestOptions.of_json
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecifications"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module ReleaseHostsRequest = struct
  type t = { host_ids : RequestHostIdList.t }

  let make ~host_ids () = { host_ids }

  let parse xml =
    Some
      { host_ids =
          Aws.Xml.required
            "hostId"
            (Aws.Util.option_bind (Aws.Xml.member "hostId" xml) RequestHostIdList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("HostId", RequestHostIdList.to_query v.host_ids)) ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt [ Some ("hostId", RequestHostIdList.to_json v.host_ids) ])

  let of_json j =
    { host_ids =
        RequestHostIdList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "hostId"))
    }
end

module ResetNetworkInterfaceAttributeRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; network_interface_id : String.t
    ; source_dest_check : String.t option
    }

  let make ?dry_run ~network_interface_id ?source_dest_check () =
    { dry_run; network_interface_id; source_dest_check }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; network_interface_id =
          Aws.Xml.required
            "networkInterfaceId"
            (Aws.Util.option_bind (Aws.Xml.member "networkInterfaceId" xml) String.parse)
      ; source_dest_check =
          Aws.Util.option_bind (Aws.Xml.member "sourceDestCheck" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.source_dest_check (fun f ->
               Aws.Query.Pair ("SourceDestCheck", String.to_query f))
         ; Some
             (Aws.Query.Pair ("NetworkInterfaceId", String.to_query v.network_interface_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.source_dest_check (fun f ->
               "sourceDestCheck", String.to_json f)
         ; Some ("networkInterfaceId", String.to_json v.network_interface_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; network_interface_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "networkInterfaceId"))
    ; source_dest_check =
        Aws.Util.option_map (Aws.Json.lookup j "sourceDestCheck") String.of_json
    }
end

module TransitGatewayRouteTablePropagationList = struct
  type t = TransitGatewayRouteTablePropagation.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all
      (List.map TransitGatewayRouteTablePropagation.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list TransitGatewayRouteTablePropagation.to_query v

  let to_json v = `List (List.map TransitGatewayRouteTablePropagation.to_json v)

  let of_json j = Aws.Json.to_list TransitGatewayRouteTablePropagation.of_json j
end

module DeprovisionByoipCidrRequest = struct
  type t =
    { cidr : String.t
    ; dry_run : Boolean.t option
    }

  let make ~cidr ?dry_run () = { cidr; dry_run }

  let parse xml =
    Some
      { cidr =
          Aws.Xml.required
            "Cidr"
            (Aws.Util.option_bind (Aws.Xml.member "Cidr" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Cidr", String.to_query v.cidr))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("Cidr", String.to_json v.cidr)
         ])

  let of_json j =
    { cidr = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Cidr"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DescribeInstanceAttributeRequest = struct
  type t =
    { attribute : InstanceAttributeName.t
    ; dry_run : Boolean.t option
    ; instance_id : String.t
    }

  let make ~attribute ?dry_run ~instance_id () = { attribute; dry_run; instance_id }

  let parse xml =
    Some
      { attribute =
          Aws.Xml.required
            "attribute"
            (Aws.Util.option_bind
               (Aws.Xml.member "attribute" xml)
               InstanceAttributeName.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; instance_id =
          Aws.Xml.required
            "instanceId"
            (Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Attribute", InstanceAttributeName.to_query v.attribute))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("instanceId", String.to_json v.instance_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("attribute", InstanceAttributeName.to_json v.attribute)
         ])

  let of_json j =
    { attribute =
        InstanceAttributeName.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "attribute"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceId"))
    }
end

module ModifyImageAttributeRequest = struct
  type t =
    { attribute : String.t option
    ; description : AttributeValue.t option
    ; image_id : String.t
    ; launch_permission : LaunchPermissionModifications.t option
    ; operation_type : OperationType.t option
    ; product_codes : ProductCodeStringList.t
    ; user_groups : UserGroupStringList.t
    ; user_ids : UserIdStringList.t
    ; value : String.t option
    ; dry_run : Boolean.t option
    }

  let make
      ?attribute
      ?description
      ~image_id
      ?launch_permission
      ?operation_type
      ?(product_codes = [])
      ?(user_groups = [])
      ?(user_ids = [])
      ?value
      ?dry_run
      () =
    { attribute
    ; description
    ; image_id
    ; launch_permission
    ; operation_type
    ; product_codes
    ; user_groups
    ; user_ids
    ; value
    ; dry_run
    }

  let parse xml =
    Some
      { attribute = Aws.Util.option_bind (Aws.Xml.member "Attribute" xml) String.parse
      ; description =
          Aws.Util.option_bind (Aws.Xml.member "Description" xml) AttributeValue.parse
      ; image_id =
          Aws.Xml.required
            "ImageId"
            (Aws.Util.option_bind (Aws.Xml.member "ImageId" xml) String.parse)
      ; launch_permission =
          Aws.Util.option_bind
            (Aws.Xml.member "LaunchPermission" xml)
            LaunchPermissionModifications.parse
      ; operation_type =
          Aws.Util.option_bind (Aws.Xml.member "OperationType" xml) OperationType.parse
      ; product_codes =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ProductCode" xml)
               ProductCodeStringList.parse)
      ; user_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "UserGroup" xml)
               UserGroupStringList.parse)
      ; user_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "UserId" xml) UserIdStringList.parse)
      ; value = Aws.Util.option_bind (Aws.Xml.member "Value" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.value (fun f ->
               Aws.Query.Pair ("Value", String.to_query f))
         ; Some (Aws.Query.Pair ("UserId", UserIdStringList.to_query v.user_ids))
         ; Some (Aws.Query.Pair ("UserGroup", UserGroupStringList.to_query v.user_groups))
         ; Some
             (Aws.Query.Pair
                ("ProductCode", ProductCodeStringList.to_query v.product_codes))
         ; Aws.Util.option_map v.operation_type (fun f ->
               Aws.Query.Pair ("OperationType", OperationType.to_query f))
         ; Aws.Util.option_map v.launch_permission (fun f ->
               Aws.Query.Pair
                 ("LaunchPermission", LaunchPermissionModifications.to_query f))
         ; Some (Aws.Query.Pair ("ImageId", String.to_query v.image_id))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", AttributeValue.to_query f))
         ; Aws.Util.option_map v.attribute (fun f ->
               Aws.Query.Pair ("Attribute", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.value (fun f -> "Value", String.to_json f)
         ; Some ("UserId", UserIdStringList.to_json v.user_ids)
         ; Some ("UserGroup", UserGroupStringList.to_json v.user_groups)
         ; Some ("ProductCode", ProductCodeStringList.to_json v.product_codes)
         ; Aws.Util.option_map v.operation_type (fun f ->
               "OperationType", OperationType.to_json f)
         ; Aws.Util.option_map v.launch_permission (fun f ->
               "LaunchPermission", LaunchPermissionModifications.to_json f)
         ; Some ("ImageId", String.to_json v.image_id)
         ; Aws.Util.option_map v.description (fun f ->
               "Description", AttributeValue.to_json f)
         ; Aws.Util.option_map v.attribute (fun f -> "Attribute", String.to_json f)
         ])

  let of_json j =
    { attribute = Aws.Util.option_map (Aws.Json.lookup j "Attribute") String.of_json
    ; description =
        Aws.Util.option_map (Aws.Json.lookup j "Description") AttributeValue.of_json
    ; image_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ImageId"))
    ; launch_permission =
        Aws.Util.option_map
          (Aws.Json.lookup j "LaunchPermission")
          LaunchPermissionModifications.of_json
    ; operation_type =
        Aws.Util.option_map (Aws.Json.lookup j "OperationType") OperationType.of_json
    ; product_codes =
        ProductCodeStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ProductCode"))
    ; user_groups =
        UserGroupStringList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "UserGroup"))
    ; user_ids =
        UserIdStringList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "UserId"))
    ; value = Aws.Util.option_map (Aws.Json.lookup j "Value") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module PlacementGroupList = struct
  type t = PlacementGroup.t list

  let make elems () = elems

  let parse xml =
    Aws.Util.option_all (List.map PlacementGroup.parse (Aws.Xml.members "item" xml))

  let to_query v = Aws.Query.to_query_list PlacementGroup.to_query v

  let to_json v = `List (List.map PlacementGroup.to_json v)

  let of_json j = Aws.Json.to_list PlacementGroup.of_json j
end

module DescribeHostReservationsResult = struct
  type t =
    { host_reservation_set : HostReservationSet.t
    ; next_token : String.t option
    }

  let make ?(host_reservation_set = []) ?next_token () =
    { host_reservation_set; next_token }

  let parse xml =
    Some
      { host_reservation_set =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "hostReservationSet" xml)
               HostReservationSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("HostReservationSet", HostReservationSet.to_query v.host_reservation_set))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("hostReservationSet", HostReservationSet.to_json v.host_reservation_set)
         ])

  let of_json j =
    { host_reservation_set =
        HostReservationSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "hostReservationSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DescribeFleetHistoryResult = struct
  type t =
    { history_records : HistoryRecordSet.t
    ; last_evaluated_time : DateTime.t option
    ; next_token : String.t option
    ; fleet_id : String.t option
    ; start_time : DateTime.t option
    }

  let make
      ?(history_records = [])
      ?last_evaluated_time
      ?next_token
      ?fleet_id
      ?start_time
      () =
    { history_records; last_evaluated_time; next_token; fleet_id; start_time }

  let parse xml =
    Some
      { history_records =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "historyRecordSet" xml)
               HistoryRecordSet.parse)
      ; last_evaluated_time =
          Aws.Util.option_bind (Aws.Xml.member "lastEvaluatedTime" xml) DateTime.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; fleet_id = Aws.Util.option_bind (Aws.Xml.member "fleetId" xml) String.parse
      ; start_time = Aws.Util.option_bind (Aws.Xml.member "startTime" xml) DateTime.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.start_time (fun f ->
               Aws.Query.Pair ("StartTime", DateTime.to_query f))
         ; Aws.Util.option_map v.fleet_id (fun f ->
               Aws.Query.Pair ("FleetId", String.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.last_evaluated_time (fun f ->
               Aws.Query.Pair ("LastEvaluatedTime", DateTime.to_query f))
         ; Some
             (Aws.Query.Pair
                ("HistoryRecordSet", HistoryRecordSet.to_query v.history_records))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.start_time (fun f -> "startTime", DateTime.to_json f)
         ; Aws.Util.option_map v.fleet_id (fun f -> "fleetId", String.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Aws.Util.option_map v.last_evaluated_time (fun f ->
               "lastEvaluatedTime", DateTime.to_json f)
         ; Some ("historyRecordSet", HistoryRecordSet.to_json v.history_records)
         ])

  let of_json j =
    { history_records =
        HistoryRecordSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "historyRecordSet"))
    ; last_evaluated_time =
        Aws.Util.option_map (Aws.Json.lookup j "lastEvaluatedTime") DateTime.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; fleet_id = Aws.Util.option_map (Aws.Json.lookup j "fleetId") String.of_json
    ; start_time = Aws.Util.option_map (Aws.Json.lookup j "startTime") DateTime.of_json
    }
end

module CreateLaunchTemplateResult = struct
  type t =
    { launch_template : LaunchTemplate.t option
    ; warning : ValidationWarning.t option
    }

  let make ?launch_template ?warning () = { launch_template; warning }

  let parse xml =
    Some
      { launch_template =
          Aws.Util.option_bind (Aws.Xml.member "launchTemplate" xml) LaunchTemplate.parse
      ; warning =
          Aws.Util.option_bind (Aws.Xml.member "warning" xml) ValidationWarning.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.warning (fun f ->
               Aws.Query.Pair ("Warning", ValidationWarning.to_query f))
         ; Aws.Util.option_map v.launch_template (fun f ->
               Aws.Query.Pair ("LaunchTemplate", LaunchTemplate.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.warning (fun f -> "warning", ValidationWarning.to_json f)
         ; Aws.Util.option_map v.launch_template (fun f ->
               "launchTemplate", LaunchTemplate.to_json f)
         ])

  let of_json j =
    { launch_template =
        Aws.Util.option_map (Aws.Json.lookup j "launchTemplate") LaunchTemplate.of_json
    ; warning =
        Aws.Util.option_map (Aws.Json.lookup j "warning") ValidationWarning.of_json
    }
end

module DescribeKeyPairsResult = struct
  type t = { key_pairs : KeyPairList.t }

  let make ?(key_pairs = []) () = { key_pairs }

  let parse xml =
    Some
      { key_pairs =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "keySet" xml) KeyPairList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("KeySet", KeyPairList.to_query v.key_pairs)) ])

  let to_json v =
    `Assoc (Aws.Util.list_filter_opt [ Some ("keySet", KeyPairList.to_json v.key_pairs) ])

  let of_json j =
    { key_pairs =
        KeyPairList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "keySet"))
    }
end

module DeletePlacementGroupRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; group_name : String.t
    }

  let make ?dry_run ~group_name () = { dry_run; group_name }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; group_name =
          Aws.Xml.required
            "groupName"
            (Aws.Util.option_bind (Aws.Xml.member "groupName" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("GroupName", String.to_query v.group_name))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("groupName", String.to_json v.group_name)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; group_name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "groupName"))
    }
end

module CreateSubnetRequest = struct
  type t =
    { tag_specifications : TagSpecificationList.t
    ; availability_zone : String.t option
    ; availability_zone_id : String.t option
    ; cidr_block : String.t
    ; ipv6_cidr_block : String.t option
    ; outpost_arn : String.t option
    ; vpc_id : String.t
    ; dry_run : Boolean.t option
    }

  let make
      ?(tag_specifications = [])
      ?availability_zone
      ?availability_zone_id
      ~cidr_block
      ?ipv6_cidr_block
      ?outpost_arn
      ~vpc_id
      ?dry_run
      () =
    { tag_specifications
    ; availability_zone
    ; availability_zone_id
    ; cidr_block
    ; ipv6_cidr_block
    ; outpost_arn
    ; vpc_id
    ; dry_run
    }

  let parse xml =
    Some
      { tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecification" xml)
               TagSpecificationList.parse)
      ; availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "AvailabilityZone" xml) String.parse
      ; availability_zone_id =
          Aws.Util.option_bind (Aws.Xml.member "AvailabilityZoneId" xml) String.parse
      ; cidr_block =
          Aws.Xml.required
            "CidrBlock"
            (Aws.Util.option_bind (Aws.Xml.member "CidrBlock" xml) String.parse)
      ; ipv6_cidr_block =
          Aws.Util.option_bind (Aws.Xml.member "Ipv6CidrBlock" xml) String.parse
      ; outpost_arn = Aws.Util.option_bind (Aws.Xml.member "OutpostArn" xml) String.parse
      ; vpc_id =
          Aws.Xml.required
            "VpcId"
            (Aws.Util.option_bind (Aws.Xml.member "VpcId" xml) String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("VpcId", String.to_query v.vpc_id))
         ; Aws.Util.option_map v.outpost_arn (fun f ->
               Aws.Query.Pair ("OutpostArn", String.to_query f))
         ; Aws.Util.option_map v.ipv6_cidr_block (fun f ->
               Aws.Query.Pair ("Ipv6CidrBlock", String.to_query f))
         ; Some (Aws.Query.Pair ("CidrBlock", String.to_query v.cidr_block))
         ; Aws.Util.option_map v.availability_zone_id (fun f ->
               Aws.Query.Pair ("AvailabilityZoneId", String.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TagSpecification", TagSpecificationList.to_query v.tag_specifications))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Some ("VpcId", String.to_json v.vpc_id)
         ; Aws.Util.option_map v.outpost_arn (fun f -> "OutpostArn", String.to_json f)
         ; Aws.Util.option_map v.ipv6_cidr_block (fun f ->
               "Ipv6CidrBlock", String.to_json f)
         ; Some ("CidrBlock", String.to_json v.cidr_block)
         ; Aws.Util.option_map v.availability_zone_id (fun f ->
               "AvailabilityZoneId", String.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "AvailabilityZone", String.to_json f)
         ; Some ("TagSpecification", TagSpecificationList.to_json v.tag_specifications)
         ])

  let of_json j =
    { tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecification"))
    ; availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "AvailabilityZone") String.of_json
    ; availability_zone_id =
        Aws.Util.option_map (Aws.Json.lookup j "AvailabilityZoneId") String.of_json
    ; cidr_block = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "CidrBlock"))
    ; ipv6_cidr_block =
        Aws.Util.option_map (Aws.Json.lookup j "Ipv6CidrBlock") String.of_json
    ; outpost_arn = Aws.Util.option_map (Aws.Json.lookup j "OutpostArn") String.of_json
    ; vpc_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "VpcId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    }
end

module GetTransitGatewayRouteTablePropagationsResult = struct
  type t =
    { transit_gateway_route_table_propagations : TransitGatewayRouteTablePropagationList.t
    ; next_token : String.t option
    }

  let make ?(transit_gateway_route_table_propagations = []) ?next_token () =
    { transit_gateway_route_table_propagations; next_token }

  let parse xml =
    Some
      { transit_gateway_route_table_propagations =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "transitGatewayRouteTablePropagations" xml)
               TransitGatewayRouteTablePropagationList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayRouteTablePropagations"
                , TransitGatewayRouteTablePropagationList.to_query
                    v.transit_gateway_route_table_propagations ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "transitGatewayRouteTablePropagations"
             , TransitGatewayRouteTablePropagationList.to_json
                 v.transit_gateway_route_table_propagations )
         ])

  let of_json j =
    { transit_gateway_route_table_propagations =
        TransitGatewayRouteTablePropagationList.of_json
          (Aws.Util.of_option_exn
             (Aws.Json.lookup j "transitGatewayRouteTablePropagations"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DescribePlacementGroupsResult = struct
  type t = { placement_groups : PlacementGroupList.t }

  let make ?(placement_groups = []) () = { placement_groups }

  let parse xml =
    Some
      { placement_groups =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "placementGroupSet" xml)
               PlacementGroupList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ("PlacementGroupSet", PlacementGroupList.to_query v.placement_groups))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("placementGroupSet", PlacementGroupList.to_json v.placement_groups) ])

  let of_json j =
    { placement_groups =
        PlacementGroupList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "placementGroupSet"))
    }
end

module DescribeTagsRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?dry_run ?(filters = []) ?max_results ?next_token () =
    { dry_run; filters; max_results; next_token }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "maxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "maxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "maxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module CreateNetworkAclEntryRequest = struct
  type t =
    { cidr_block : String.t option
    ; dry_run : Boolean.t option
    ; egress : Boolean.t
    ; icmp_type_code : IcmpTypeCode.t option
    ; ipv6_cidr_block : String.t option
    ; network_acl_id : String.t
    ; port_range : PortRange.t option
    ; protocol : String.t
    ; rule_action : RuleAction.t
    ; rule_number : Integer.t
    }

  let make
      ?cidr_block
      ?dry_run
      ~egress
      ?icmp_type_code
      ?ipv6_cidr_block
      ~network_acl_id
      ?port_range
      ~protocol
      ~rule_action
      ~rule_number
      () =
    { cidr_block
    ; dry_run
    ; egress
    ; icmp_type_code
    ; ipv6_cidr_block
    ; network_acl_id
    ; port_range
    ; protocol
    ; rule_action
    ; rule_number
    }

  let parse xml =
    Some
      { cidr_block = Aws.Util.option_bind (Aws.Xml.member "cidrBlock" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; egress =
          Aws.Xml.required
            "egress"
            (Aws.Util.option_bind (Aws.Xml.member "egress" xml) Boolean.parse)
      ; icmp_type_code =
          Aws.Util.option_bind (Aws.Xml.member "Icmp" xml) IcmpTypeCode.parse
      ; ipv6_cidr_block =
          Aws.Util.option_bind (Aws.Xml.member "ipv6CidrBlock" xml) String.parse
      ; network_acl_id =
          Aws.Xml.required
            "networkAclId"
            (Aws.Util.option_bind (Aws.Xml.member "networkAclId" xml) String.parse)
      ; port_range = Aws.Util.option_bind (Aws.Xml.member "portRange" xml) PortRange.parse
      ; protocol =
          Aws.Xml.required
            "protocol"
            (Aws.Util.option_bind (Aws.Xml.member "protocol" xml) String.parse)
      ; rule_action =
          Aws.Xml.required
            "ruleAction"
            (Aws.Util.option_bind (Aws.Xml.member "ruleAction" xml) RuleAction.parse)
      ; rule_number =
          Aws.Xml.required
            "ruleNumber"
            (Aws.Util.option_bind (Aws.Xml.member "ruleNumber" xml) Integer.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("RuleNumber", Integer.to_query v.rule_number))
         ; Some (Aws.Query.Pair ("RuleAction", RuleAction.to_query v.rule_action))
         ; Some (Aws.Query.Pair ("Protocol", String.to_query v.protocol))
         ; Aws.Util.option_map v.port_range (fun f ->
               Aws.Query.Pair ("PortRange", PortRange.to_query f))
         ; Some (Aws.Query.Pair ("NetworkAclId", String.to_query v.network_acl_id))
         ; Aws.Util.option_map v.ipv6_cidr_block (fun f ->
               Aws.Query.Pair ("Ipv6CidrBlock", String.to_query f))
         ; Aws.Util.option_map v.icmp_type_code (fun f ->
               Aws.Query.Pair ("Icmp", IcmpTypeCode.to_query f))
         ; Some (Aws.Query.Pair ("Egress", Boolean.to_query v.egress))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.cidr_block (fun f ->
               Aws.Query.Pair ("CidrBlock", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("ruleNumber", Integer.to_json v.rule_number)
         ; Some ("ruleAction", RuleAction.to_json v.rule_action)
         ; Some ("protocol", String.to_json v.protocol)
         ; Aws.Util.option_map v.port_range (fun f -> "portRange", PortRange.to_json f)
         ; Some ("networkAclId", String.to_json v.network_acl_id)
         ; Aws.Util.option_map v.ipv6_cidr_block (fun f ->
               "ipv6CidrBlock", String.to_json f)
         ; Aws.Util.option_map v.icmp_type_code (fun f -> "Icmp", IcmpTypeCode.to_json f)
         ; Some ("egress", Boolean.to_json v.egress)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.cidr_block (fun f -> "cidrBlock", String.to_json f)
         ])

  let of_json j =
    { cidr_block = Aws.Util.option_map (Aws.Json.lookup j "cidrBlock") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; egress = Boolean.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "egress"))
    ; icmp_type_code = Aws.Util.option_map (Aws.Json.lookup j "Icmp") IcmpTypeCode.of_json
    ; ipv6_cidr_block =
        Aws.Util.option_map (Aws.Json.lookup j "ipv6CidrBlock") String.of_json
    ; network_acl_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "networkAclId"))
    ; port_range = Aws.Util.option_map (Aws.Json.lookup j "portRange") PortRange.of_json
    ; protocol = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "protocol"))
    ; rule_action =
        RuleAction.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ruleAction"))
    ; rule_number =
        Integer.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "ruleNumber"))
    }
end

module DescribeReservedInstancesModificationsResult = struct
  type t =
    { next_token : String.t option
    ; reserved_instances_modifications : ReservedInstancesModificationList.t
    }

  let make ?next_token ?(reserved_instances_modifications = []) () =
    { next_token; reserved_instances_modifications }

  let parse xml =
    Some
      { next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; reserved_instances_modifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "reservedInstancesModificationsSet" xml)
               ReservedInstancesModificationList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "ReservedInstancesModificationsSet"
                , ReservedInstancesModificationList.to_query
                    v.reserved_instances_modifications ))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "reservedInstancesModificationsSet"
             , ReservedInstancesModificationList.to_json
                 v.reserved_instances_modifications )
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ])

  let of_json j =
    { next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; reserved_instances_modifications =
        ReservedInstancesModificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "reservedInstancesModificationsSet"))
    }
end

module AuthorizeSecurityGroupEgressRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; group_id : String.t
    ; ip_permissions : IpPermissionList.t
    ; cidr_ip : String.t option
    ; from_port : Integer.t option
    ; ip_protocol : String.t option
    ; to_port : Integer.t option
    ; source_security_group_name : String.t option
    ; source_security_group_owner_id : String.t option
    }

  let make
      ?dry_run
      ~group_id
      ?(ip_permissions = [])
      ?cidr_ip
      ?from_port
      ?ip_protocol
      ?to_port
      ?source_security_group_name
      ?source_security_group_owner_id
      () =
    { dry_run
    ; group_id
    ; ip_permissions
    ; cidr_ip
    ; from_port
    ; ip_protocol
    ; to_port
    ; source_security_group_name
    ; source_security_group_owner_id
    }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; group_id =
          Aws.Xml.required
            "groupId"
            (Aws.Util.option_bind (Aws.Xml.member "groupId" xml) String.parse)
      ; ip_permissions =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ipPermissions" xml)
               IpPermissionList.parse)
      ; cidr_ip = Aws.Util.option_bind (Aws.Xml.member "cidrIp" xml) String.parse
      ; from_port = Aws.Util.option_bind (Aws.Xml.member "fromPort" xml) Integer.parse
      ; ip_protocol = Aws.Util.option_bind (Aws.Xml.member "ipProtocol" xml) String.parse
      ; to_port = Aws.Util.option_bind (Aws.Xml.member "toPort" xml) Integer.parse
      ; source_security_group_name =
          Aws.Util.option_bind (Aws.Xml.member "sourceSecurityGroupName" xml) String.parse
      ; source_security_group_owner_id =
          Aws.Util.option_bind
            (Aws.Xml.member "sourceSecurityGroupOwnerId" xml)
            String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.source_security_group_owner_id (fun f ->
               Aws.Query.Pair ("SourceSecurityGroupOwnerId", String.to_query f))
         ; Aws.Util.option_map v.source_security_group_name (fun f ->
               Aws.Query.Pair ("SourceSecurityGroupName", String.to_query f))
         ; Aws.Util.option_map v.to_port (fun f ->
               Aws.Query.Pair ("ToPort", Integer.to_query f))
         ; Aws.Util.option_map v.ip_protocol (fun f ->
               Aws.Query.Pair ("IpProtocol", String.to_query f))
         ; Aws.Util.option_map v.from_port (fun f ->
               Aws.Query.Pair ("FromPort", Integer.to_query f))
         ; Aws.Util.option_map v.cidr_ip (fun f ->
               Aws.Query.Pair ("CidrIp", String.to_query f))
         ; Some
             (Aws.Query.Pair ("IpPermissions", IpPermissionList.to_query v.ip_permissions))
         ; Some (Aws.Query.Pair ("GroupId", String.to_query v.group_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.source_security_group_owner_id (fun f ->
               "sourceSecurityGroupOwnerId", String.to_json f)
         ; Aws.Util.option_map v.source_security_group_name (fun f ->
               "sourceSecurityGroupName", String.to_json f)
         ; Aws.Util.option_map v.to_port (fun f -> "toPort", Integer.to_json f)
         ; Aws.Util.option_map v.ip_protocol (fun f -> "ipProtocol", String.to_json f)
         ; Aws.Util.option_map v.from_port (fun f -> "fromPort", Integer.to_json f)
         ; Aws.Util.option_map v.cidr_ip (fun f -> "cidrIp", String.to_json f)
         ; Some ("ipPermissions", IpPermissionList.to_json v.ip_permissions)
         ; Some ("groupId", String.to_json v.group_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; group_id = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "groupId"))
    ; ip_permissions =
        IpPermissionList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ipPermissions"))
    ; cidr_ip = Aws.Util.option_map (Aws.Json.lookup j "cidrIp") String.of_json
    ; from_port = Aws.Util.option_map (Aws.Json.lookup j "fromPort") Integer.of_json
    ; ip_protocol = Aws.Util.option_map (Aws.Json.lookup j "ipProtocol") String.of_json
    ; to_port = Aws.Util.option_map (Aws.Json.lookup j "toPort") Integer.of_json
    ; source_security_group_name =
        Aws.Util.option_map (Aws.Json.lookup j "sourceSecurityGroupName") String.of_json
    ; source_security_group_owner_id =
        Aws.Util.option_map
          (Aws.Json.lookup j "sourceSecurityGroupOwnerId")
          String.of_json
    }
end

module DeleteLocalGatewayRouteTableVpcAssociationRequest = struct
  type t =
    { local_gateway_route_table_vpc_association_id : String.t
    ; dry_run : Boolean.t option
    }

  let make ~local_gateway_route_table_vpc_association_id ?dry_run () =
    { local_gateway_route_table_vpc_association_id; dry_run }

  let parse xml =
    Some
      { local_gateway_route_table_vpc_association_id =
          Aws.Xml.required
            "LocalGatewayRouteTableVpcAssociationId"
            (Aws.Util.option_bind
               (Aws.Xml.member "LocalGatewayRouteTableVpcAssociationId" xml)
               String.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "LocalGatewayRouteTableVpcAssociationId"
                , String.to_query v.local_gateway_route_table_vpc_association_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some
             ( "LocalGatewayRouteTableVpcAssociationId"
             , String.to_json v.local_gateway_route_table_vpc_association_id )
         ])

  let of_json j =
    { local_gateway_route_table_vpc_association_id =
        String.of_json
          (Aws.Util.of_option_exn
             (Aws.Json.lookup j "LocalGatewayRouteTableVpcAssociationId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module DescribeElasticGpusRequest = struct
  type t =
    { elastic_gpu_ids : ElasticGpuIdSet.t
    ; dry_run : Boolean.t option
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    }

  let make ?(elastic_gpu_ids = []) ?dry_run ?(filters = []) ?max_results ?next_token () =
    { elastic_gpu_ids; dry_run; filters; max_results; next_token }

  let parse xml =
    Some
      { elastic_gpu_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "ElasticGpuId" xml)
               ElasticGpuIdSet.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair ("ElasticGpuId", ElasticGpuIdSet.to_query v.elastic_gpu_ids))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("ElasticGpuId", ElasticGpuIdSet.to_json v.elastic_gpu_ids)
         ])

  let of_json j =
    { elastic_gpu_ids =
        ElasticGpuIdSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "ElasticGpuId"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    }
end

module DescribeCapacityReservationsResult = struct
  type t =
    { next_token : String.t option
    ; capacity_reservations : CapacityReservationSet.t
    }

  let make ?next_token ?(capacity_reservations = []) () =
    { next_token; capacity_reservations }

  let parse xml =
    Some
      { next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; capacity_reservations =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "capacityReservationSet" xml)
               CapacityReservationSet.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some
             (Aws.Query.Pair
                ( "CapacityReservationSet"
                , CapacityReservationSet.to_query v.capacity_reservations ))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some
             ( "capacityReservationSet"
             , CapacityReservationSet.to_json v.capacity_reservations )
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ])

  let of_json j =
    { next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; capacity_reservations =
        CapacityReservationSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "capacityReservationSet"))
    }
end

module GetTransitGatewayPrefixListReferencesRequest = struct
  type t =
    { transit_gateway_route_table_id : String.t
    ; filters : FilterList.t
    ; max_results : Integer.t option
    ; next_token : String.t option
    ; dry_run : Boolean.t option
    }

  let make
      ~transit_gateway_route_table_id
      ?(filters = [])
      ?max_results
      ?next_token
      ?dry_run
      () =
    { transit_gateway_route_table_id; filters; max_results; next_token; dry_run }

  let parse xml =
    Some
      { transit_gateway_route_table_id =
          Aws.Xml.required
            "TransitGatewayRouteTableId"
            (Aws.Util.option_bind
               (Aws.Xml.member "TransitGatewayRouteTableId" xml)
               String.parse)
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayRouteTableId"
                , String.to_query v.transit_gateway_route_table_id ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Some
             ( "TransitGatewayRouteTableId"
             , String.to_json v.transit_gateway_route_table_id )
         ])

  let of_json j =
    { transit_gateway_route_table_id =
        String.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TransitGatewayRouteTableId"))
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module GetTransitGatewayAttachmentPropagationsResult = struct
  type t =
    { transit_gateway_attachment_propagations : TransitGatewayAttachmentPropagationList.t
    ; next_token : String.t option
    }

  let make ?(transit_gateway_attachment_propagations = []) ?next_token () =
    { transit_gateway_attachment_propagations; next_token }

  let parse xml =
    Some
      { transit_gateway_attachment_propagations =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "transitGatewayAttachmentPropagations" xml)
               TransitGatewayAttachmentPropagationList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "TransitGatewayAttachmentPropagations"
                , TransitGatewayAttachmentPropagationList.to_query
                    v.transit_gateway_attachment_propagations ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some
             ( "transitGatewayAttachmentPropagations"
             , TransitGatewayAttachmentPropagationList.to_json
                 v.transit_gateway_attachment_propagations )
         ])

  let of_json j =
    { transit_gateway_attachment_propagations =
        TransitGatewayAttachmentPropagationList.of_json
          (Aws.Util.of_option_exn
             (Aws.Json.lookup j "transitGatewayAttachmentPropagations"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DescribeVpnGatewaysResult = struct
  type t = { vpn_gateways : VpnGatewayList.t }

  let make ?(vpn_gateways = []) () = { vpn_gateways }

  let parse xml =
    Some
      { vpn_gateways =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "vpnGatewaySet" xml)
               VpnGatewayList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("VpnGatewaySet", VpnGatewayList.to_query v.vpn_gateways))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("vpnGatewaySet", VpnGatewayList.to_json v.vpn_gateways) ])

  let of_json j =
    { vpn_gateways =
        VpnGatewayList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "vpnGatewaySet"))
    }
end

module DescribeDhcpOptionsResult = struct
  type t =
    { dhcp_options : DhcpOptionsList.t
    ; next_token : String.t option
    }

  let make ?(dhcp_options = []) ?next_token () = { dhcp_options; next_token }

  let parse xml =
    Some
      { dhcp_options =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "dhcpOptionsSet" xml)
               DhcpOptionsList.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair ("DhcpOptionsSet", DhcpOptionsList.to_query v.dhcp_options))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ; Some ("dhcpOptionsSet", DhcpOptionsList.to_json v.dhcp_options)
         ])

  let of_json j =
    { dhcp_options =
        DhcpOptionsList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "dhcpOptionsSet"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    }
end

module DescribeTagsResult = struct
  type t =
    { next_token : String.t option
    ; tags : TagDescriptionList.t
    }

  let make ?next_token ?(tags = []) () = { next_token; tags }

  let parse xml =
    Some
      { next_token = Aws.Util.option_bind (Aws.Xml.member "nextToken" xml) String.parse
      ; tags =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "tagSet" xml) TagDescriptionList.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("TagSet", TagDescriptionList.to_query v.tags))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("tagSet", TagDescriptionList.to_json v.tags)
         ; Aws.Util.option_map v.next_token (fun f -> "nextToken", String.to_json f)
         ])

  let of_json j =
    { next_token = Aws.Util.option_map (Aws.Json.lookup j "nextToken") String.of_json
    ; tags =
        TagDescriptionList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "tagSet"))
    }
end

module CreateTrafficMirrorFilterResult = struct
  type t =
    { traffic_mirror_filter : TrafficMirrorFilter.t option
    ; client_token : String.t option
    }

  let make ?traffic_mirror_filter ?client_token () =
    { traffic_mirror_filter; client_token }

  let parse xml =
    Some
      { traffic_mirror_filter =
          Aws.Util.option_bind
            (Aws.Xml.member "trafficMirrorFilter" xml)
            TrafficMirrorFilter.parse
      ; client_token =
          Aws.Util.option_bind (Aws.Xml.member "clientToken" xml) String.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ; Aws.Util.option_map v.traffic_mirror_filter (fun f ->
               Aws.Query.Pair ("TrafficMirrorFilter", TrafficMirrorFilter.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.client_token (fun f -> "clientToken", String.to_json f)
         ; Aws.Util.option_map v.traffic_mirror_filter (fun f ->
               "trafficMirrorFilter", TrafficMirrorFilter.to_json f)
         ])

  let of_json j =
    { traffic_mirror_filter =
        Aws.Util.option_map
          (Aws.Json.lookup j "trafficMirrorFilter")
          TrafficMirrorFilter.of_json
    ; client_token = Aws.Util.option_map (Aws.Json.lookup j "clientToken") String.of_json
    }
end

module CreateCapacityReservationRequest = struct
  type t =
    { client_token : String.t option
    ; instance_type : String.t
    ; instance_platform : CapacityReservationInstancePlatform.t
    ; availability_zone : String.t option
    ; availability_zone_id : String.t option
    ; tenancy : CapacityReservationTenancy.t option
    ; instance_count : Integer.t
    ; ebs_optimized : Boolean.t option
    ; ephemeral_storage : Boolean.t option
    ; end_date : DateTime.t option
    ; end_date_type : EndDateType.t option
    ; instance_match_criteria : InstanceMatchCriteria.t option
    ; tag_specifications : TagSpecificationList.t
    ; dry_run : Boolean.t option
    }

  let make
      ?client_token
      ~instance_type
      ~instance_platform
      ?availability_zone
      ?availability_zone_id
      ?tenancy
      ~instance_count
      ?ebs_optimized
      ?ephemeral_storage
      ?end_date
      ?end_date_type
      ?instance_match_criteria
      ?(tag_specifications = [])
      ?dry_run
      () =
    { client_token
    ; instance_type
    ; instance_platform
    ; availability_zone
    ; availability_zone_id
    ; tenancy
    ; instance_count
    ; ebs_optimized
    ; ephemeral_storage
    ; end_date
    ; end_date_type
    ; instance_match_criteria
    ; tag_specifications
    ; dry_run
    }

  let parse xml =
    Some
      { client_token =
          Aws.Util.option_bind (Aws.Xml.member "ClientToken" xml) String.parse
      ; instance_type =
          Aws.Xml.required
            "InstanceType"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceType" xml) String.parse)
      ; instance_platform =
          Aws.Xml.required
            "InstancePlatform"
            (Aws.Util.option_bind
               (Aws.Xml.member "InstancePlatform" xml)
               CapacityReservationInstancePlatform.parse)
      ; availability_zone =
          Aws.Util.option_bind (Aws.Xml.member "AvailabilityZone" xml) String.parse
      ; availability_zone_id =
          Aws.Util.option_bind (Aws.Xml.member "AvailabilityZoneId" xml) String.parse
      ; tenancy =
          Aws.Util.option_bind
            (Aws.Xml.member "Tenancy" xml)
            CapacityReservationTenancy.parse
      ; instance_count =
          Aws.Xml.required
            "InstanceCount"
            (Aws.Util.option_bind (Aws.Xml.member "InstanceCount" xml) Integer.parse)
      ; ebs_optimized =
          Aws.Util.option_bind (Aws.Xml.member "EbsOptimized" xml) Boolean.parse
      ; ephemeral_storage =
          Aws.Util.option_bind (Aws.Xml.member "EphemeralStorage" xml) Boolean.parse
      ; end_date = Aws.Util.option_bind (Aws.Xml.member "EndDate" xml) DateTime.parse
      ; end_date_type =
          Aws.Util.option_bind (Aws.Xml.member "EndDateType" xml) EndDateType.parse
      ; instance_match_criteria =
          Aws.Util.option_bind
            (Aws.Xml.member "InstanceMatchCriteria" xml)
            InstanceMatchCriteria.parse
      ; tag_specifications =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "TagSpecifications" xml)
               TagSpecificationList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some
             (Aws.Query.Pair
                ("TagSpecifications", TagSpecificationList.to_query v.tag_specifications))
         ; Aws.Util.option_map v.instance_match_criteria (fun f ->
               Aws.Query.Pair ("InstanceMatchCriteria", InstanceMatchCriteria.to_query f))
         ; Aws.Util.option_map v.end_date_type (fun f ->
               Aws.Query.Pair ("EndDateType", EndDateType.to_query f))
         ; Aws.Util.option_map v.end_date (fun f ->
               Aws.Query.Pair ("EndDate", DateTime.to_query f))
         ; Aws.Util.option_map v.ephemeral_storage (fun f ->
               Aws.Query.Pair ("EphemeralStorage", Boolean.to_query f))
         ; Aws.Util.option_map v.ebs_optimized (fun f ->
               Aws.Query.Pair ("EbsOptimized", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("InstanceCount", Integer.to_query v.instance_count))
         ; Aws.Util.option_map v.tenancy (fun f ->
               Aws.Query.Pair ("Tenancy", CapacityReservationTenancy.to_query f))
         ; Aws.Util.option_map v.availability_zone_id (fun f ->
               Aws.Query.Pair ("AvailabilityZoneId", String.to_query f))
         ; Aws.Util.option_map v.availability_zone (fun f ->
               Aws.Query.Pair ("AvailabilityZone", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "InstancePlatform"
                , CapacityReservationInstancePlatform.to_query v.instance_platform ))
         ; Some (Aws.Query.Pair ("InstanceType", String.to_query v.instance_type))
         ; Aws.Util.option_map v.client_token (fun f ->
               Aws.Query.Pair ("ClientToken", String.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("TagSpecifications", TagSpecificationList.to_json v.tag_specifications)
         ; Aws.Util.option_map v.instance_match_criteria (fun f ->
               "InstanceMatchCriteria", InstanceMatchCriteria.to_json f)
         ; Aws.Util.option_map v.end_date_type (fun f ->
               "EndDateType", EndDateType.to_json f)
         ; Aws.Util.option_map v.end_date (fun f -> "EndDate", DateTime.to_json f)
         ; Aws.Util.option_map v.ephemeral_storage (fun f ->
               "EphemeralStorage", Boolean.to_json f)
         ; Aws.Util.option_map v.ebs_optimized (fun f ->
               "EbsOptimized", Boolean.to_json f)
         ; Some ("InstanceCount", Integer.to_json v.instance_count)
         ; Aws.Util.option_map v.tenancy (fun f ->
               "Tenancy", CapacityReservationTenancy.to_json f)
         ; Aws.Util.option_map v.availability_zone_id (fun f ->
               "AvailabilityZoneId", String.to_json f)
         ; Aws.Util.option_map v.availability_zone (fun f ->
               "AvailabilityZone", String.to_json f)
         ; Some
             ( "InstancePlatform"
             , CapacityReservationInstancePlatform.to_json v.instance_platform )
         ; Some ("InstanceType", String.to_json v.instance_type)
         ; Aws.Util.option_map v.client_token (fun f -> "ClientToken", String.to_json f)
         ])

  let of_json j =
    { client_token = Aws.Util.option_map (Aws.Json.lookup j "ClientToken") String.of_json
    ; instance_type =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceType"))
    ; instance_platform =
        CapacityReservationInstancePlatform.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "InstancePlatform"))
    ; availability_zone =
        Aws.Util.option_map (Aws.Json.lookup j "AvailabilityZone") String.of_json
    ; availability_zone_id =
        Aws.Util.option_map (Aws.Json.lookup j "AvailabilityZoneId") String.of_json
    ; tenancy =
        Aws.Util.option_map
          (Aws.Json.lookup j "Tenancy")
          CapacityReservationTenancy.of_json
    ; instance_count =
        Integer.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "InstanceCount"))
    ; ebs_optimized =
        Aws.Util.option_map (Aws.Json.lookup j "EbsOptimized") Boolean.of_json
    ; ephemeral_storage =
        Aws.Util.option_map (Aws.Json.lookup j "EphemeralStorage") Boolean.of_json
    ; end_date = Aws.Util.option_map (Aws.Json.lookup j "EndDate") DateTime.of_json
    ; end_date_type =
        Aws.Util.option_map (Aws.Json.lookup j "EndDateType") EndDateType.of_json
    ; instance_match_criteria =
        Aws.Util.option_map
          (Aws.Json.lookup j "InstanceMatchCriteria")
          InstanceMatchCriteria.of_json
    ; tag_specifications =
        TagSpecificationList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "TagSpecifications"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end

module CreateImageRequest = struct
  type t =
    { block_device_mappings : BlockDeviceMappingRequestList.t
    ; description : String.t option
    ; dry_run : Boolean.t option
    ; instance_id : String.t
    ; name : String.t
    ; no_reboot : Boolean.t option
    }

  let make
      ?(block_device_mappings = [])
      ?description
      ?dry_run
      ~instance_id
      ~name
      ?no_reboot
      () =
    { block_device_mappings; description; dry_run; instance_id; name; no_reboot }

  let parse xml =
    Some
      { block_device_mappings =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "blockDeviceMapping" xml)
               BlockDeviceMappingRequestList.parse)
      ; description = Aws.Util.option_bind (Aws.Xml.member "description" xml) String.parse
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; instance_id =
          Aws.Xml.required
            "instanceId"
            (Aws.Util.option_bind (Aws.Xml.member "instanceId" xml) String.parse)
      ; name =
          Aws.Xml.required
            "name"
            (Aws.Util.option_bind (Aws.Xml.member "name" xml) String.parse)
      ; no_reboot = Aws.Util.option_bind (Aws.Xml.member "noReboot" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.no_reboot (fun f ->
               Aws.Query.Pair ("NoReboot", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Name", String.to_query v.name))
         ; Some (Aws.Query.Pair ("InstanceId", String.to_query v.instance_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Aws.Util.option_map v.description (fun f ->
               Aws.Query.Pair ("Description", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "BlockDeviceMapping"
                , BlockDeviceMappingRequestList.to_query v.block_device_mappings ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.no_reboot (fun f -> "noReboot", Boolean.to_json f)
         ; Some ("name", String.to_json v.name)
         ; Some ("instanceId", String.to_json v.instance_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ; Aws.Util.option_map v.description (fun f -> "description", String.to_json f)
         ; Some
             ( "blockDeviceMapping"
             , BlockDeviceMappingRequestList.to_json v.block_device_mappings )
         ])

  let of_json j =
    { block_device_mappings =
        BlockDeviceMappingRequestList.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "blockDeviceMapping"))
    ; description = Aws.Util.option_map (Aws.Json.lookup j "description") String.of_json
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; instance_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "instanceId"))
    ; name = String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "name"))
    ; no_reboot = Aws.Util.option_map (Aws.Json.lookup j "noReboot") Boolean.of_json
    }
end

module DeleteNetworkAclRequest = struct
  type t =
    { dry_run : Boolean.t option
    ; network_acl_id : String.t
    }

  let make ?dry_run ~network_acl_id () = { dry_run; network_acl_id }

  let parse xml =
    Some
      { dry_run = Aws.Util.option_bind (Aws.Xml.member "dryRun" xml) Boolean.parse
      ; network_acl_id =
          Aws.Xml.required
            "networkAclId"
            (Aws.Util.option_bind (Aws.Xml.member "networkAclId" xml) String.parse)
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Some (Aws.Query.Pair ("NetworkAclId", String.to_query v.network_acl_id))
         ; Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Some ("networkAclId", String.to_json v.network_acl_id)
         ; Aws.Util.option_map v.dry_run (fun f -> "dryRun", Boolean.to_json f)
         ])

  let of_json j =
    { dry_run = Aws.Util.option_map (Aws.Json.lookup j "dryRun") Boolean.of_json
    ; network_acl_id =
        String.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "networkAclId"))
    }
end

module DescribeCapacityReservationsRequest = struct
  type t =
    { capacity_reservation_ids : CapacityReservationIdSet.t
    ; next_token : String.t option
    ; max_results : Integer.t option
    ; filters : FilterList.t
    ; dry_run : Boolean.t option
    }

  let make
      ?(capacity_reservation_ids = [])
      ?next_token
      ?max_results
      ?(filters = [])
      ?dry_run
      () =
    { capacity_reservation_ids; next_token; max_results; filters; dry_run }

  let parse xml =
    Some
      { capacity_reservation_ids =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind
               (Aws.Xml.member "CapacityReservationId" xml)
               CapacityReservationIdSet.parse)
      ; next_token = Aws.Util.option_bind (Aws.Xml.member "NextToken" xml) String.parse
      ; max_results = Aws.Util.option_bind (Aws.Xml.member "MaxResults" xml) Integer.parse
      ; filters =
          Aws.Util.of_option
            []
            (Aws.Util.option_bind (Aws.Xml.member "Filter" xml) FilterList.parse)
      ; dry_run = Aws.Util.option_bind (Aws.Xml.member "DryRun" xml) Boolean.parse
      }

  let to_query v =
    Aws.Query.List
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f ->
               Aws.Query.Pair ("DryRun", Boolean.to_query f))
         ; Some (Aws.Query.Pair ("Filter", FilterList.to_query v.filters))
         ; Aws.Util.option_map v.max_results (fun f ->
               Aws.Query.Pair ("MaxResults", Integer.to_query f))
         ; Aws.Util.option_map v.next_token (fun f ->
               Aws.Query.Pair ("NextToken", String.to_query f))
         ; Some
             (Aws.Query.Pair
                ( "CapacityReservationId"
                , CapacityReservationIdSet.to_query v.capacity_reservation_ids ))
         ])

  let to_json v =
    `Assoc
      (Aws.Util.list_filter_opt
         [ Aws.Util.option_map v.dry_run (fun f -> "DryRun", Boolean.to_json f)
         ; Some ("Filter", FilterList.to_json v.filters)
         ; Aws.Util.option_map v.max_results (fun f -> "MaxResults", Integer.to_json f)
         ; Aws.Util.option_map v.next_token (fun f -> "NextToken", String.to_json f)
         ; Some
             ( "CapacityReservationId"
             , CapacityReservationIdSet.to_json v.capacity_reservation_ids )
         ])

  let of_json j =
    { capacity_reservation_ids =
        CapacityReservationIdSet.of_json
          (Aws.Util.of_option_exn (Aws.Json.lookup j "CapacityReservationId"))
    ; next_token = Aws.Util.option_map (Aws.Json.lookup j "NextToken") String.of_json
    ; max_results = Aws.Util.option_map (Aws.Json.lookup j "MaxResults") Integer.of_json
    ; filters = FilterList.of_json (Aws.Util.of_option_exn (Aws.Json.lookup j "Filter"))
    ; dry_run = Aws.Util.option_map (Aws.Json.lookup j "DryRun") Boolean.of_json
    }
end
